
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[17:43:32.412] plan(): Setting new future strategy stack:
[17:43:32.413] List of future strategies:
[17:43:32.413] 1. sequential:
[17:43:32.413]    - args: function (..., envir = parent.frame())
[17:43:32.413]    - tweaked: FALSE
[17:43:32.413]    - call: future::plan("sequential")
[17:43:32.426] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> strategies <- supportedStrategies()
> 
> message("*** resolve() ...")
*** resolve() ...
> 
> message("*** resolve() for default ...")
*** resolve() for default ...
> 
> x <- 1
> y <- resolve(x)
> stopifnot(identical(y, x))
> 
> message("*** resolve() for default ... DONE")
*** resolve() for default ... DONE
> 
> 
> for (strategy in strategies) {
+   message(sprintf("- plan('%s') ...", strategy))
+   plan(strategy)
+ 
+   if (strategy == "multisession" && availableCores() >= 2) {
+     message("*** resolve() for Future objects ...")
+     
+     for (result in c(FALSE, TRUE)) {
+       for (recursive in list(FALSE, TRUE, -1, 0, 1, 2, Inf)) {
+         message(sprintf("- result = %s, recursive = %s ...", result, recursive))
+       
+         f <- future({
+           Sys.sleep(0.5)
+           list(a = 1, b = 42L)
+         })
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         f <- future({
+           Sys.sleep(0.5)
+           list(a = 1, b = 42L)
+         }, lazy = TRUE)
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         message("- w/ exception ...")
+         f <- future(list(a = 1, b = 42L, c = stop("Nah!")))
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         f <- future(list(a = 1, b = 42L, c = stop("Nah!")), lazy = TRUE)
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         message(sprintf("- result = %s, recursive = %s ... DONE", result, recursive))
+       } ## for (resolve ...)
+     } ## for (result ...)
+     
+     message("*** resolve() for Future objects ... DONE")
+   } ## if (strategy == "multisession" && availableCores() >= 2)
+   
+   message("*** resolve() for lists ...")
+ 
+   x <- list()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   x$a <- 1
+   x$b <- 2
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   x$a <- future(1)
+   x$b <- future(2)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1, lazy = TRUE)
+   x$b <- future(2)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1, lazy = TRUE)
+   x$b <- future(2, lazy = TRUE)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1)
+   x$b <- future({Sys.sleep(0.5); 2})
+   x[[4]] <- 4
+   dim(x) <- c(2, 2)
+   y <- resolve(x, idxs = 1)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x[[1]]))
+   y <- resolve(x, idxs = 2)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x[[2]]))
+   y <- resolve(x, idxs = 3)
+   stopifnot(identical(y, x))
+   y <- resolve(x, idxs = seq_along(x))
+   stopifnot(identical(y, x))
+   y <- resolve(x, idxs = names(x))
+   stopifnot(identical(y, x))
+ 
+   y <- resolve(x, idxs = matrix(c(1, 2), ncol = 2L), result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   for (kk in 1:3) x[[kk]] <- future({ Sys.sleep(0.1); kk })
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   for (kk in 1:3) x[[kk]] <- future({ Sys.sleep(0.1); kk }, lazy = TRUE)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   x <- list()
+   x$a <- 1
+   x$b <- 2
+ 
+   res <- tryCatch(y <- resolve(x, idxs = 0L), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   x <- list(1, 2)
+   res <- tryCatch(x <- resolve(x, idxs = "a"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for lists ... DONE")
+ 
+ 
+   message("*** resolve() for environments ...")
+ 
+   x <- new.env()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- new.env()
+   x$a <- 1
+   x$b <- 2
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 0L)
+ 
+   x <- new.env()
+   x$a <- future(1)
+   x$b <- future(2)
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x$b))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- new.env()
+   x$a %<-% { 1 }
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)  ## FIXME: Should not do value()!
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- new.env()
+   x$a <- future({ 1 })
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "a")
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "b")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "c")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = names(x), result = TRUE)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, recursive = TRUE, result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for environments ... DONE")
+ 
+ 
+   message("*** resolve() for list environments ...")
+ 
+   x <- listenv()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- listenv()
+   x$a <- 1
+   x$b <- 2
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 0L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- listenv()
+   x$a <- future(1)
+   x$b <- future(2)
+   x$c <- 3
+   names <- names(x)
+   dim(x) <- c(1, 3)
+   names(x) <- names
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- listenv()
+   x$a %<-% { 1 }
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)  ## FIXME: Should not do value()!
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x$a, mustExist = FALSE)))
+   #stopifnot(is.na(futureOf(x$b, mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- listenv()
+   x$a <- future({ 1 })
+   x$b %<-% { Sys.sleep(0.5); 2 }
+   x$c %<-% { 3 }
+   x$d <- 4
+   names <- names(x)
+   dim(x) <- c(2, 2)
+   names(x) <- names
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+   y <- resolve(x, idxs = "a")
+   stopifnot(identical(y, x))
+   stopifnot(identical(futureOf(x$a, mustExist = FALSE), x$a))
+   stopifnot(resolved(x$a))
+   y <- resolve(x, idxs = "b")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   idxs <- matrix(c(1, 2), ncol = 2L)
+   y <- resolve(x, idxs = idxs)
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x$c, mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, idxs = 4L)
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x[[4L]], mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, idxs = names(x), result = TRUE)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, recursive = TRUE, result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   res <- tryCatch(y <- resolve(x, idxs = 0L), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for list environments ... DONE")
+ 
+   message(sprintf("- plan('%s') ...", strategy))
+ } ## for (strategy ...)
- plan('sequential') ...
[17:43:32.616] plan(): Setting new future strategy stack:
[17:43:32.616] List of future strategies:
[17:43:32.616] 1. sequential:
[17:43:32.616]    - args: function (..., envir = parent.frame())
[17:43:32.616]    - tweaked: FALSE
[17:43:32.616]    - call: plan(strategy)
[17:43:32.627] plan(): nbrOfWorkers() = 1
*** resolve() for lists ...
[17:43:32.628] resolve() on list ...
[17:43:32.628]  recursive: 0
[17:43:32.628]  length: 2
[17:43:32.628]  elements: ‘a’, ‘b’
[17:43:32.628]  length: 1 (resolved future 1)
[17:43:32.628]  length: 0 (resolved future 2)
[17:43:32.629] resolve() on list ... DONE
[17:43:32.629] getGlobalsAndPackages() ...
[17:43:32.629] Searching for globals...
[17:43:32.632] 
[17:43:32.632] Searching for globals ... DONE
[17:43:32.632] - globals: [0] <none>
[17:43:32.632] getGlobalsAndPackages() ... DONE
[17:43:32.633] run() for ‘Future’ ...
[17:43:32.633] - state: ‘created’
[17:43:32.633] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:32.633] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:32.634] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:32.634]   - Field: ‘label’
[17:43:32.634]   - Field: ‘local’
[17:43:32.634]   - Field: ‘owner’
[17:43:32.634]   - Field: ‘envir’
[17:43:32.634]   - Field: ‘packages’
[17:43:32.634]   - Field: ‘gc’
[17:43:32.634]   - Field: ‘conditions’
[17:43:32.634]   - Field: ‘expr’
[17:43:32.634]   - Field: ‘uuid’
[17:43:32.635]   - Field: ‘seed’
[17:43:32.635]   - Field: ‘version’
[17:43:32.635]   - Field: ‘result’
[17:43:32.635]   - Field: ‘asynchronous’
[17:43:32.635]   - Field: ‘calls’
[17:43:32.635]   - Field: ‘globals’
[17:43:32.635]   - Field: ‘stdout’
[17:43:32.635]   - Field: ‘earlySignal’
[17:43:32.635]   - Field: ‘lazy’
[17:43:32.635]   - Field: ‘state’
[17:43:32.635] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:32.636] - Launch lazy future ...
[17:43:32.636] Packages needed by the future expression (n = 0): <none>
[17:43:32.637] Packages needed by future strategies (n = 0): <none>
[17:43:32.637] {
[17:43:32.637]     {
[17:43:32.637]         {
[17:43:32.637]             ...future.startTime <- base::Sys.time()
[17:43:32.637]             {
[17:43:32.637]                 {
[17:43:32.637]                   {
[17:43:32.637]                     base::local({
[17:43:32.637]                       has_future <- base::requireNamespace("future", 
[17:43:32.637]                         quietly = TRUE)
[17:43:32.637]                       if (has_future) {
[17:43:32.637]                         ns <- base::getNamespace("future")
[17:43:32.637]                         version <- ns[[".package"]][["version"]]
[17:43:32.637]                         if (is.null(version)) 
[17:43:32.637]                           version <- utils::packageVersion("future")
[17:43:32.637]                       }
[17:43:32.637]                       else {
[17:43:32.637]                         version <- NULL
[17:43:32.637]                       }
[17:43:32.637]                       if (!has_future || version < "1.8.0") {
[17:43:32.637]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:32.637]                           "", base::R.version$version.string), 
[17:43:32.637]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:32.637]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:32.637]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:32.637]                             "release", "version")], collapse = " "), 
[17:43:32.637]                           hostname = base::Sys.info()[["nodename"]])
[17:43:32.637]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:32.637]                           info)
[17:43:32.637]                         info <- base::paste(info, collapse = "; ")
[17:43:32.637]                         if (!has_future) {
[17:43:32.637]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:32.637]                             info)
[17:43:32.637]                         }
[17:43:32.637]                         else {
[17:43:32.637]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:32.637]                             info, version)
[17:43:32.637]                         }
[17:43:32.637]                         base::stop(msg)
[17:43:32.637]                       }
[17:43:32.637]                     })
[17:43:32.637]                   }
[17:43:32.637]                   options(future.plan = NULL)
[17:43:32.637]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:32.637]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:32.637]                 }
[17:43:32.637]                 ...future.workdir <- getwd()
[17:43:32.637]             }
[17:43:32.637]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:32.637]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:32.637]         }
[17:43:32.637]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:32.637]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:32.637]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:32.637]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:32.637]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:32.637]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:32.637]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:32.637]             base::names(...future.oldOptions))
[17:43:32.637]     }
[17:43:32.637]     if (FALSE) {
[17:43:32.637]     }
[17:43:32.637]     else {
[17:43:32.637]         if (TRUE) {
[17:43:32.637]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:32.637]                 open = "w")
[17:43:32.637]         }
[17:43:32.637]         else {
[17:43:32.637]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:32.637]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:32.637]         }
[17:43:32.637]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:32.637]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:32.637]             base::sink(type = "output", split = FALSE)
[17:43:32.637]             base::close(...future.stdout)
[17:43:32.637]         }, add = TRUE)
[17:43:32.637]     }
[17:43:32.637]     ...future.frame <- base::sys.nframe()
[17:43:32.637]     ...future.conditions <- base::list()
[17:43:32.637]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:32.637]     if (FALSE) {
[17:43:32.637]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:32.637]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:32.637]     }
[17:43:32.637]     ...future.result <- base::tryCatch({
[17:43:32.637]         base::withCallingHandlers({
[17:43:32.637]             ...future.value <- base::withVisible(base::local(1))
[17:43:32.637]             future::FutureResult(value = ...future.value$value, 
[17:43:32.637]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:32.637]                   ...future.rng), globalenv = if (FALSE) 
[17:43:32.637]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:32.637]                     ...future.globalenv.names))
[17:43:32.637]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:32.637]         }, condition = base::local({
[17:43:32.637]             c <- base::c
[17:43:32.637]             inherits <- base::inherits
[17:43:32.637]             invokeRestart <- base::invokeRestart
[17:43:32.637]             length <- base::length
[17:43:32.637]             list <- base::list
[17:43:32.637]             seq.int <- base::seq.int
[17:43:32.637]             signalCondition <- base::signalCondition
[17:43:32.637]             sys.calls <- base::sys.calls
[17:43:32.637]             `[[` <- base::`[[`
[17:43:32.637]             `+` <- base::`+`
[17:43:32.637]             `<<-` <- base::`<<-`
[17:43:32.637]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:32.637]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:32.637]                   3L)]
[17:43:32.637]             }
[17:43:32.637]             function(cond) {
[17:43:32.637]                 is_error <- inherits(cond, "error")
[17:43:32.637]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:32.637]                   NULL)
[17:43:32.637]                 if (is_error) {
[17:43:32.637]                   sessionInformation <- function() {
[17:43:32.637]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:32.637]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:32.637]                       search = base::search(), system = base::Sys.info())
[17:43:32.637]                   }
[17:43:32.637]                   ...future.conditions[[length(...future.conditions) + 
[17:43:32.637]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:32.637]                     cond$call), session = sessionInformation(), 
[17:43:32.637]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:32.637]                   signalCondition(cond)
[17:43:32.637]                 }
[17:43:32.637]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:32.637]                 "immediateCondition"))) {
[17:43:32.637]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:32.637]                   ...future.conditions[[length(...future.conditions) + 
[17:43:32.637]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:32.637]                   if (TRUE && !signal) {
[17:43:32.637]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:32.637]                     {
[17:43:32.637]                       inherits <- base::inherits
[17:43:32.637]                       invokeRestart <- base::invokeRestart
[17:43:32.637]                       is.null <- base::is.null
[17:43:32.637]                       muffled <- FALSE
[17:43:32.637]                       if (inherits(cond, "message")) {
[17:43:32.637]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:32.637]                         if (muffled) 
[17:43:32.637]                           invokeRestart("muffleMessage")
[17:43:32.637]                       }
[17:43:32.637]                       else if (inherits(cond, "warning")) {
[17:43:32.637]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:32.637]                         if (muffled) 
[17:43:32.637]                           invokeRestart("muffleWarning")
[17:43:32.637]                       }
[17:43:32.637]                       else if (inherits(cond, "condition")) {
[17:43:32.637]                         if (!is.null(pattern)) {
[17:43:32.637]                           computeRestarts <- base::computeRestarts
[17:43:32.637]                           grepl <- base::grepl
[17:43:32.637]                           restarts <- computeRestarts(cond)
[17:43:32.637]                           for (restart in restarts) {
[17:43:32.637]                             name <- restart$name
[17:43:32.637]                             if (is.null(name)) 
[17:43:32.637]                               next
[17:43:32.637]                             if (!grepl(pattern, name)) 
[17:43:32.637]                               next
[17:43:32.637]                             invokeRestart(restart)
[17:43:32.637]                             muffled <- TRUE
[17:43:32.637]                             break
[17:43:32.637]                           }
[17:43:32.637]                         }
[17:43:32.637]                       }
[17:43:32.637]                       invisible(muffled)
[17:43:32.637]                     }
[17:43:32.637]                     muffleCondition(cond, pattern = "^muffle")
[17:43:32.637]                   }
[17:43:32.637]                 }
[17:43:32.637]                 else {
[17:43:32.637]                   if (TRUE) {
[17:43:32.637]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:32.637]                     {
[17:43:32.637]                       inherits <- base::inherits
[17:43:32.637]                       invokeRestart <- base::invokeRestart
[17:43:32.637]                       is.null <- base::is.null
[17:43:32.637]                       muffled <- FALSE
[17:43:32.637]                       if (inherits(cond, "message")) {
[17:43:32.637]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:32.637]                         if (muffled) 
[17:43:32.637]                           invokeRestart("muffleMessage")
[17:43:32.637]                       }
[17:43:32.637]                       else if (inherits(cond, "warning")) {
[17:43:32.637]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:32.637]                         if (muffled) 
[17:43:32.637]                           invokeRestart("muffleWarning")
[17:43:32.637]                       }
[17:43:32.637]                       else if (inherits(cond, "condition")) {
[17:43:32.637]                         if (!is.null(pattern)) {
[17:43:32.637]                           computeRestarts <- base::computeRestarts
[17:43:32.637]                           grepl <- base::grepl
[17:43:32.637]                           restarts <- computeRestarts(cond)
[17:43:32.637]                           for (restart in restarts) {
[17:43:32.637]                             name <- restart$name
[17:43:32.637]                             if (is.null(name)) 
[17:43:32.637]                               next
[17:43:32.637]                             if (!grepl(pattern, name)) 
[17:43:32.637]                               next
[17:43:32.637]                             invokeRestart(restart)
[17:43:32.637]                             muffled <- TRUE
[17:43:32.637]                             break
[17:43:32.637]                           }
[17:43:32.637]                         }
[17:43:32.637]                       }
[17:43:32.637]                       invisible(muffled)
[17:43:32.637]                     }
[17:43:32.637]                     muffleCondition(cond, pattern = "^muffle")
[17:43:32.637]                   }
[17:43:32.637]                 }
[17:43:32.637]             }
[17:43:32.637]         }))
[17:43:32.637]     }, error = function(ex) {
[17:43:32.637]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:32.637]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:32.637]                 ...future.rng), started = ...future.startTime, 
[17:43:32.637]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:32.637]             version = "1.8"), class = "FutureResult")
[17:43:32.637]     }, finally = {
[17:43:32.637]         if (!identical(...future.workdir, getwd())) 
[17:43:32.637]             setwd(...future.workdir)
[17:43:32.637]         {
[17:43:32.637]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:32.637]                 ...future.oldOptions$nwarnings <- NULL
[17:43:32.637]             }
[17:43:32.637]             base::options(...future.oldOptions)
[17:43:32.637]             if (.Platform$OS.type == "windows") {
[17:43:32.637]                 old_names <- names(...future.oldEnvVars)
[17:43:32.637]                 envs <- base::Sys.getenv()
[17:43:32.637]                 names <- names(envs)
[17:43:32.637]                 common <- intersect(names, old_names)
[17:43:32.637]                 added <- setdiff(names, old_names)
[17:43:32.637]                 removed <- setdiff(old_names, names)
[17:43:32.637]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:32.637]                   envs[common]]
[17:43:32.637]                 NAMES <- toupper(changed)
[17:43:32.637]                 args <- list()
[17:43:32.637]                 for (kk in seq_along(NAMES)) {
[17:43:32.637]                   name <- changed[[kk]]
[17:43:32.637]                   NAME <- NAMES[[kk]]
[17:43:32.637]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:32.637]                     next
[17:43:32.637]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:32.637]                 }
[17:43:32.637]                 NAMES <- toupper(added)
[17:43:32.637]                 for (kk in seq_along(NAMES)) {
[17:43:32.637]                   name <- added[[kk]]
[17:43:32.637]                   NAME <- NAMES[[kk]]
[17:43:32.637]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:32.637]                     next
[17:43:32.637]                   args[[name]] <- ""
[17:43:32.637]                 }
[17:43:32.637]                 NAMES <- toupper(removed)
[17:43:32.637]                 for (kk in seq_along(NAMES)) {
[17:43:32.637]                   name <- removed[[kk]]
[17:43:32.637]                   NAME <- NAMES[[kk]]
[17:43:32.637]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:32.637]                     next
[17:43:32.637]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:32.637]                 }
[17:43:32.637]                 if (length(args) > 0) 
[17:43:32.637]                   base::do.call(base::Sys.setenv, args = args)
[17:43:32.637]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:32.637]             }
[17:43:32.637]             else {
[17:43:32.637]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:32.637]             }
[17:43:32.637]             {
[17:43:32.637]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:32.637]                   0L) {
[17:43:32.637]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:32.637]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:32.637]                   base::options(opts)
[17:43:32.637]                 }
[17:43:32.637]                 {
[17:43:32.637]                   {
[17:43:32.637]                     NULL
[17:43:32.637]                     RNGkind("Mersenne-Twister")
[17:43:32.637]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:32.637]                       inherits = FALSE)
[17:43:32.637]                   }
[17:43:32.637]                   options(future.plan = NULL)
[17:43:32.637]                   if (is.na(NA_character_)) 
[17:43:32.637]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:32.637]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:32.637]                   future::plan(list(function (..., envir = parent.frame()) 
[17:43:32.637]                   {
[17:43:32.637]                     future <- SequentialFuture(..., envir = envir)
[17:43:32.637]                     if (!future$lazy) 
[17:43:32.637]                       future <- run(future)
[17:43:32.637]                     invisible(future)
[17:43:32.637]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:32.637]                 }
[17:43:32.637]             }
[17:43:32.637]         }
[17:43:32.637]     })
[17:43:32.637]     if (TRUE) {
[17:43:32.637]         base::sink(type = "output", split = FALSE)
[17:43:32.637]         if (TRUE) {
[17:43:32.637]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:32.637]         }
[17:43:32.637]         else {
[17:43:32.637]             ...future.result["stdout"] <- base::list(NULL)
[17:43:32.637]         }
[17:43:32.637]         base::close(...future.stdout)
[17:43:32.637]         ...future.stdout <- NULL
[17:43:32.637]     }
[17:43:32.637]     ...future.result$conditions <- ...future.conditions
[17:43:32.637]     ...future.result$finished <- base::Sys.time()
[17:43:32.637]     ...future.result
[17:43:32.637] }
[17:43:32.639] plan(): Setting new future strategy stack:
[17:43:32.639] List of future strategies:
[17:43:32.639] 1. sequential:
[17:43:32.639]    - args: function (..., envir = parent.frame())
[17:43:32.639]    - tweaked: FALSE
[17:43:32.639]    - call: NULL
[17:43:32.640] plan(): nbrOfWorkers() = 1
[17:43:32.641] plan(): Setting new future strategy stack:
[17:43:32.641] List of future strategies:
[17:43:32.641] 1. sequential:
[17:43:32.641]    - args: function (..., envir = parent.frame())
[17:43:32.641]    - tweaked: FALSE
[17:43:32.641]    - call: plan(strategy)
[17:43:32.641] plan(): nbrOfWorkers() = 1
[17:43:32.642] SequentialFuture started (and completed)
[17:43:32.642] - Launch lazy future ... done
[17:43:32.642] run() for ‘SequentialFuture’ ... done
[17:43:32.642] getGlobalsAndPackages() ...
[17:43:32.642] Searching for globals...
[17:43:32.643] 
[17:43:32.643] Searching for globals ... DONE
[17:43:32.645] - globals: [0] <none>
[17:43:32.645] getGlobalsAndPackages() ... DONE
[17:43:32.645] run() for ‘Future’ ...
[17:43:32.645] - state: ‘created’
[17:43:32.645] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:32.646] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:32.646] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:32.646]   - Field: ‘label’
[17:43:32.646]   - Field: ‘local’
[17:43:32.646]   - Field: ‘owner’
[17:43:32.646]   - Field: ‘envir’
[17:43:32.646]   - Field: ‘packages’
[17:43:32.647]   - Field: ‘gc’
[17:43:32.647]   - Field: ‘conditions’
[17:43:32.647]   - Field: ‘expr’
[17:43:32.647]   - Field: ‘uuid’
[17:43:32.647]   - Field: ‘seed’
[17:43:32.647]   - Field: ‘version’
[17:43:32.647]   - Field: ‘result’
[17:43:32.648]   - Field: ‘asynchronous’
[17:43:32.648]   - Field: ‘calls’
[17:43:32.648]   - Field: ‘globals’
[17:43:32.648]   - Field: ‘stdout’
[17:43:32.648]   - Field: ‘earlySignal’
[17:43:32.648]   - Field: ‘lazy’
[17:43:32.648]   - Field: ‘state’
[17:43:32.648] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:32.648] - Launch lazy future ...
[17:43:32.648] Packages needed by the future expression (n = 0): <none>
[17:43:32.649] Packages needed by future strategies (n = 0): <none>
[17:43:32.649] {
[17:43:32.649]     {
[17:43:32.649]         {
[17:43:32.649]             ...future.startTime <- base::Sys.time()
[17:43:32.649]             {
[17:43:32.649]                 {
[17:43:32.649]                   {
[17:43:32.649]                     base::local({
[17:43:32.649]                       has_future <- base::requireNamespace("future", 
[17:43:32.649]                         quietly = TRUE)
[17:43:32.649]                       if (has_future) {
[17:43:32.649]                         ns <- base::getNamespace("future")
[17:43:32.649]                         version <- ns[[".package"]][["version"]]
[17:43:32.649]                         if (is.null(version)) 
[17:43:32.649]                           version <- utils::packageVersion("future")
[17:43:32.649]                       }
[17:43:32.649]                       else {
[17:43:32.649]                         version <- NULL
[17:43:32.649]                       }
[17:43:32.649]                       if (!has_future || version < "1.8.0") {
[17:43:32.649]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:32.649]                           "", base::R.version$version.string), 
[17:43:32.649]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:32.649]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:32.649]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:32.649]                             "release", "version")], collapse = " "), 
[17:43:32.649]                           hostname = base::Sys.info()[["nodename"]])
[17:43:32.649]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:32.649]                           info)
[17:43:32.649]                         info <- base::paste(info, collapse = "; ")
[17:43:32.649]                         if (!has_future) {
[17:43:32.649]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:32.649]                             info)
[17:43:32.649]                         }
[17:43:32.649]                         else {
[17:43:32.649]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:32.649]                             info, version)
[17:43:32.649]                         }
[17:43:32.649]                         base::stop(msg)
[17:43:32.649]                       }
[17:43:32.649]                     })
[17:43:32.649]                   }
[17:43:32.649]                   options(future.plan = NULL)
[17:43:32.649]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:32.649]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:32.649]                 }
[17:43:32.649]                 ...future.workdir <- getwd()
[17:43:32.649]             }
[17:43:32.649]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:32.649]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:32.649]         }
[17:43:32.649]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:32.649]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:32.649]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:32.649]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:32.649]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:32.649]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:32.649]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:32.649]             base::names(...future.oldOptions))
[17:43:32.649]     }
[17:43:32.649]     if (FALSE) {
[17:43:32.649]     }
[17:43:32.649]     else {
[17:43:32.649]         if (TRUE) {
[17:43:32.649]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:32.649]                 open = "w")
[17:43:32.649]         }
[17:43:32.649]         else {
[17:43:32.649]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:32.649]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:32.649]         }
[17:43:32.649]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:32.649]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:32.649]             base::sink(type = "output", split = FALSE)
[17:43:32.649]             base::close(...future.stdout)
[17:43:32.649]         }, add = TRUE)
[17:43:32.649]     }
[17:43:32.649]     ...future.frame <- base::sys.nframe()
[17:43:32.649]     ...future.conditions <- base::list()
[17:43:32.649]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:32.649]     if (FALSE) {
[17:43:32.649]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:32.649]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:32.649]     }
[17:43:32.649]     ...future.result <- base::tryCatch({
[17:43:32.649]         base::withCallingHandlers({
[17:43:32.649]             ...future.value <- base::withVisible(base::local(2))
[17:43:32.649]             future::FutureResult(value = ...future.value$value, 
[17:43:32.649]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:32.649]                   ...future.rng), globalenv = if (FALSE) 
[17:43:32.649]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:32.649]                     ...future.globalenv.names))
[17:43:32.649]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:32.649]         }, condition = base::local({
[17:43:32.649]             c <- base::c
[17:43:32.649]             inherits <- base::inherits
[17:43:32.649]             invokeRestart <- base::invokeRestart
[17:43:32.649]             length <- base::length
[17:43:32.649]             list <- base::list
[17:43:32.649]             seq.int <- base::seq.int
[17:43:32.649]             signalCondition <- base::signalCondition
[17:43:32.649]             sys.calls <- base::sys.calls
[17:43:32.649]             `[[` <- base::`[[`
[17:43:32.649]             `+` <- base::`+`
[17:43:32.649]             `<<-` <- base::`<<-`
[17:43:32.649]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:32.649]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:32.649]                   3L)]
[17:43:32.649]             }
[17:43:32.649]             function(cond) {
[17:43:32.649]                 is_error <- inherits(cond, "error")
[17:43:32.649]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:32.649]                   NULL)
[17:43:32.649]                 if (is_error) {
[17:43:32.649]                   sessionInformation <- function() {
[17:43:32.649]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:32.649]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:32.649]                       search = base::search(), system = base::Sys.info())
[17:43:32.649]                   }
[17:43:32.649]                   ...future.conditions[[length(...future.conditions) + 
[17:43:32.649]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:32.649]                     cond$call), session = sessionInformation(), 
[17:43:32.649]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:32.649]                   signalCondition(cond)
[17:43:32.649]                 }
[17:43:32.649]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:32.649]                 "immediateCondition"))) {
[17:43:32.649]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:32.649]                   ...future.conditions[[length(...future.conditions) + 
[17:43:32.649]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:32.649]                   if (TRUE && !signal) {
[17:43:32.649]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:32.649]                     {
[17:43:32.649]                       inherits <- base::inherits
[17:43:32.649]                       invokeRestart <- base::invokeRestart
[17:43:32.649]                       is.null <- base::is.null
[17:43:32.649]                       muffled <- FALSE
[17:43:32.649]                       if (inherits(cond, "message")) {
[17:43:32.649]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:32.649]                         if (muffled) 
[17:43:32.649]                           invokeRestart("muffleMessage")
[17:43:32.649]                       }
[17:43:32.649]                       else if (inherits(cond, "warning")) {
[17:43:32.649]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:32.649]                         if (muffled) 
[17:43:32.649]                           invokeRestart("muffleWarning")
[17:43:32.649]                       }
[17:43:32.649]                       else if (inherits(cond, "condition")) {
[17:43:32.649]                         if (!is.null(pattern)) {
[17:43:32.649]                           computeRestarts <- base::computeRestarts
[17:43:32.649]                           grepl <- base::grepl
[17:43:32.649]                           restarts <- computeRestarts(cond)
[17:43:32.649]                           for (restart in restarts) {
[17:43:32.649]                             name <- restart$name
[17:43:32.649]                             if (is.null(name)) 
[17:43:32.649]                               next
[17:43:32.649]                             if (!grepl(pattern, name)) 
[17:43:32.649]                               next
[17:43:32.649]                             invokeRestart(restart)
[17:43:32.649]                             muffled <- TRUE
[17:43:32.649]                             break
[17:43:32.649]                           }
[17:43:32.649]                         }
[17:43:32.649]                       }
[17:43:32.649]                       invisible(muffled)
[17:43:32.649]                     }
[17:43:32.649]                     muffleCondition(cond, pattern = "^muffle")
[17:43:32.649]                   }
[17:43:32.649]                 }
[17:43:32.649]                 else {
[17:43:32.649]                   if (TRUE) {
[17:43:32.649]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:32.649]                     {
[17:43:32.649]                       inherits <- base::inherits
[17:43:32.649]                       invokeRestart <- base::invokeRestart
[17:43:32.649]                       is.null <- base::is.null
[17:43:32.649]                       muffled <- FALSE
[17:43:32.649]                       if (inherits(cond, "message")) {
[17:43:32.649]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:32.649]                         if (muffled) 
[17:43:32.649]                           invokeRestart("muffleMessage")
[17:43:32.649]                       }
[17:43:32.649]                       else if (inherits(cond, "warning")) {
[17:43:32.649]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:32.649]                         if (muffled) 
[17:43:32.649]                           invokeRestart("muffleWarning")
[17:43:32.649]                       }
[17:43:32.649]                       else if (inherits(cond, "condition")) {
[17:43:32.649]                         if (!is.null(pattern)) {
[17:43:32.649]                           computeRestarts <- base::computeRestarts
[17:43:32.649]                           grepl <- base::grepl
[17:43:32.649]                           restarts <- computeRestarts(cond)
[17:43:32.649]                           for (restart in restarts) {
[17:43:32.649]                             name <- restart$name
[17:43:32.649]                             if (is.null(name)) 
[17:43:32.649]                               next
[17:43:32.649]                             if (!grepl(pattern, name)) 
[17:43:32.649]                               next
[17:43:32.649]                             invokeRestart(restart)
[17:43:32.649]                             muffled <- TRUE
[17:43:32.649]                             break
[17:43:32.649]                           }
[17:43:32.649]                         }
[17:43:32.649]                       }
[17:43:32.649]                       invisible(muffled)
[17:43:32.649]                     }
[17:43:32.649]                     muffleCondition(cond, pattern = "^muffle")
[17:43:32.649]                   }
[17:43:32.649]                 }
[17:43:32.649]             }
[17:43:32.649]         }))
[17:43:32.649]     }, error = function(ex) {
[17:43:32.649]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:32.649]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:32.649]                 ...future.rng), started = ...future.startTime, 
[17:43:32.649]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:32.649]             version = "1.8"), class = "FutureResult")
[17:43:32.649]     }, finally = {
[17:43:32.649]         if (!identical(...future.workdir, getwd())) 
[17:43:32.649]             setwd(...future.workdir)
[17:43:32.649]         {
[17:43:32.649]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:32.649]                 ...future.oldOptions$nwarnings <- NULL
[17:43:32.649]             }
[17:43:32.649]             base::options(...future.oldOptions)
[17:43:32.649]             if (.Platform$OS.type == "windows") {
[17:43:32.649]                 old_names <- names(...future.oldEnvVars)
[17:43:32.649]                 envs <- base::Sys.getenv()
[17:43:32.649]                 names <- names(envs)
[17:43:32.649]                 common <- intersect(names, old_names)
[17:43:32.649]                 added <- setdiff(names, old_names)
[17:43:32.649]                 removed <- setdiff(old_names, names)
[17:43:32.649]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:32.649]                   envs[common]]
[17:43:32.649]                 NAMES <- toupper(changed)
[17:43:32.649]                 args <- list()
[17:43:32.649]                 for (kk in seq_along(NAMES)) {
[17:43:32.649]                   name <- changed[[kk]]
[17:43:32.649]                   NAME <- NAMES[[kk]]
[17:43:32.649]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:32.649]                     next
[17:43:32.649]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:32.649]                 }
[17:43:32.649]                 NAMES <- toupper(added)
[17:43:32.649]                 for (kk in seq_along(NAMES)) {
[17:43:32.649]                   name <- added[[kk]]
[17:43:32.649]                   NAME <- NAMES[[kk]]
[17:43:32.649]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:32.649]                     next
[17:43:32.649]                   args[[name]] <- ""
[17:43:32.649]                 }
[17:43:32.649]                 NAMES <- toupper(removed)
[17:43:32.649]                 for (kk in seq_along(NAMES)) {
[17:43:32.649]                   name <- removed[[kk]]
[17:43:32.649]                   NAME <- NAMES[[kk]]
[17:43:32.649]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:32.649]                     next
[17:43:32.649]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:32.649]                 }
[17:43:32.649]                 if (length(args) > 0) 
[17:43:32.649]                   base::do.call(base::Sys.setenv, args = args)
[17:43:32.649]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:32.649]             }
[17:43:32.649]             else {
[17:43:32.649]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:32.649]             }
[17:43:32.649]             {
[17:43:32.649]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:32.649]                   0L) {
[17:43:32.649]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:32.649]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:32.649]                   base::options(opts)
[17:43:32.649]                 }
[17:43:32.649]                 {
[17:43:32.649]                   {
[17:43:32.649]                     NULL
[17:43:32.649]                     RNGkind("Mersenne-Twister")
[17:43:32.649]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:32.649]                       inherits = FALSE)
[17:43:32.649]                   }
[17:43:32.649]                   options(future.plan = NULL)
[17:43:32.649]                   if (is.na(NA_character_)) 
[17:43:32.649]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:32.649]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:32.649]                   future::plan(list(function (..., envir = parent.frame()) 
[17:43:32.649]                   {
[17:43:32.649]                     future <- SequentialFuture(..., envir = envir)
[17:43:32.649]                     if (!future$lazy) 
[17:43:32.649]                       future <- run(future)
[17:43:32.649]                     invisible(future)
[17:43:32.649]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:32.649]                 }
[17:43:32.649]             }
[17:43:32.649]         }
[17:43:32.649]     })
[17:43:32.649]     if (TRUE) {
[17:43:32.649]         base::sink(type = "output", split = FALSE)
[17:43:32.649]         if (TRUE) {
[17:43:32.649]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:32.649]         }
[17:43:32.649]         else {
[17:43:32.649]             ...future.result["stdout"] <- base::list(NULL)
[17:43:32.649]         }
[17:43:32.649]         base::close(...future.stdout)
[17:43:32.649]         ...future.stdout <- NULL
[17:43:32.649]     }
[17:43:32.649]     ...future.result$conditions <- ...future.conditions
[17:43:32.649]     ...future.result$finished <- base::Sys.time()
[17:43:32.649]     ...future.result
[17:43:32.649] }
[17:43:32.651] plan(): Setting new future strategy stack:
[17:43:32.651] List of future strategies:
[17:43:32.651] 1. sequential:
[17:43:32.651]    - args: function (..., envir = parent.frame())
[17:43:32.651]    - tweaked: FALSE
[17:43:32.651]    - call: NULL
[17:43:32.651] plan(): nbrOfWorkers() = 1
[17:43:32.652] plan(): Setting new future strategy stack:
[17:43:32.652] List of future strategies:
[17:43:32.652] 1. sequential:
[17:43:32.652]    - args: function (..., envir = parent.frame())
[17:43:32.652]    - tweaked: FALSE
[17:43:32.652]    - call: plan(strategy)
[17:43:32.652] plan(): nbrOfWorkers() = 1
[17:43:32.653] SequentialFuture started (and completed)
[17:43:32.653] - Launch lazy future ... done
[17:43:32.653] run() for ‘SequentialFuture’ ... done
[17:43:32.653] resolve() on list ...
[17:43:32.653]  recursive: 0
[17:43:32.653]  length: 3
[17:43:32.653]  elements: ‘a’, ‘b’, ‘’
[17:43:32.654] resolved() for ‘SequentialFuture’ ...
[17:43:32.654] - state: ‘finished’
[17:43:32.654] - run: TRUE
[17:43:32.654] - result: ‘FutureResult’
[17:43:32.654] resolved() for ‘SequentialFuture’ ... done
[17:43:32.654] Future #1
[17:43:32.654]  length: 2 (resolved future 1)
[17:43:32.654] resolved() for ‘SequentialFuture’ ...
[17:43:32.654] - state: ‘finished’
[17:43:32.655] - run: TRUE
[17:43:32.655] - result: ‘FutureResult’
[17:43:32.655] resolved() for ‘SequentialFuture’ ... done
[17:43:32.655] Future #2
[17:43:32.655]  length: 1 (resolved future 2)
[17:43:32.655]  length: 0 (resolved future 3)
[17:43:32.655] resolve() on list ... DONE
[17:43:32.655] resolved() for ‘SequentialFuture’ ...
[17:43:32.655] - state: ‘finished’
[17:43:32.655] - run: TRUE
[17:43:32.656] - result: ‘FutureResult’
[17:43:32.656] resolved() for ‘SequentialFuture’ ... done
[17:43:32.656] resolved() for ‘SequentialFuture’ ...
[17:43:32.656] - state: ‘finished’
[17:43:32.656] - run: TRUE
[17:43:32.656] - result: ‘FutureResult’
[17:43:32.656] resolved() for ‘SequentialFuture’ ... done
[17:43:32.656] getGlobalsAndPackages() ...
[17:43:32.656] Searching for globals...
[17:43:32.657] 
[17:43:32.657] Searching for globals ... DONE
[17:43:32.657] - globals: [0] <none>
[17:43:32.657] getGlobalsAndPackages() ... DONE
[17:43:32.657] getGlobalsAndPackages() ...
[17:43:32.657] Searching for globals...
[17:43:32.657] 
[17:43:32.658] Searching for globals ... DONE
[17:43:32.658] - globals: [0] <none>
[17:43:32.658] getGlobalsAndPackages() ... DONE
[17:43:32.658] run() for ‘Future’ ...
[17:43:32.658] - state: ‘created’
[17:43:32.658] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:32.658] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:32.659] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:32.659]   - Field: ‘label’
[17:43:32.659]   - Field: ‘local’
[17:43:32.659]   - Field: ‘owner’
[17:43:32.659]   - Field: ‘envir’
[17:43:32.659]   - Field: ‘packages’
[17:43:32.659]   - Field: ‘gc’
[17:43:32.659]   - Field: ‘conditions’
[17:43:32.659]   - Field: ‘expr’
[17:43:32.659]   - Field: ‘uuid’
[17:43:32.659]   - Field: ‘seed’
[17:43:32.660]   - Field: ‘version’
[17:43:32.660]   - Field: ‘result’
[17:43:32.660]   - Field: ‘asynchronous’
[17:43:32.660]   - Field: ‘calls’
[17:43:32.660]   - Field: ‘globals’
[17:43:32.660]   - Field: ‘stdout’
[17:43:32.660]   - Field: ‘earlySignal’
[17:43:32.660]   - Field: ‘lazy’
[17:43:32.660]   - Field: ‘state’
[17:43:32.660] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:32.661] - Launch lazy future ...
[17:43:32.661] Packages needed by the future expression (n = 0): <none>
[17:43:32.661] Packages needed by future strategies (n = 0): <none>
[17:43:32.661] {
[17:43:32.661]     {
[17:43:32.661]         {
[17:43:32.661]             ...future.startTime <- base::Sys.time()
[17:43:32.661]             {
[17:43:32.661]                 {
[17:43:32.661]                   {
[17:43:32.661]                     base::local({
[17:43:32.661]                       has_future <- base::requireNamespace("future", 
[17:43:32.661]                         quietly = TRUE)
[17:43:32.661]                       if (has_future) {
[17:43:32.661]                         ns <- base::getNamespace("future")
[17:43:32.661]                         version <- ns[[".package"]][["version"]]
[17:43:32.661]                         if (is.null(version)) 
[17:43:32.661]                           version <- utils::packageVersion("future")
[17:43:32.661]                       }
[17:43:32.661]                       else {
[17:43:32.661]                         version <- NULL
[17:43:32.661]                       }
[17:43:32.661]                       if (!has_future || version < "1.8.0") {
[17:43:32.661]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:32.661]                           "", base::R.version$version.string), 
[17:43:32.661]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:32.661]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:32.661]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:32.661]                             "release", "version")], collapse = " "), 
[17:43:32.661]                           hostname = base::Sys.info()[["nodename"]])
[17:43:32.661]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:32.661]                           info)
[17:43:32.661]                         info <- base::paste(info, collapse = "; ")
[17:43:32.661]                         if (!has_future) {
[17:43:32.661]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:32.661]                             info)
[17:43:32.661]                         }
[17:43:32.661]                         else {
[17:43:32.661]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:32.661]                             info, version)
[17:43:32.661]                         }
[17:43:32.661]                         base::stop(msg)
[17:43:32.661]                       }
[17:43:32.661]                     })
[17:43:32.661]                   }
[17:43:32.661]                   options(future.plan = NULL)
[17:43:32.661]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:32.661]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:32.661]                 }
[17:43:32.661]                 ...future.workdir <- getwd()
[17:43:32.661]             }
[17:43:32.661]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:32.661]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:32.661]         }
[17:43:32.661]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:32.661]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:32.661]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:32.661]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:32.661]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:32.661]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:32.661]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:32.661]             base::names(...future.oldOptions))
[17:43:32.661]     }
[17:43:32.661]     if (FALSE) {
[17:43:32.661]     }
[17:43:32.661]     else {
[17:43:32.661]         if (TRUE) {
[17:43:32.661]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:32.661]                 open = "w")
[17:43:32.661]         }
[17:43:32.661]         else {
[17:43:32.661]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:32.661]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:32.661]         }
[17:43:32.661]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:32.661]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:32.661]             base::sink(type = "output", split = FALSE)
[17:43:32.661]             base::close(...future.stdout)
[17:43:32.661]         }, add = TRUE)
[17:43:32.661]     }
[17:43:32.661]     ...future.frame <- base::sys.nframe()
[17:43:32.661]     ...future.conditions <- base::list()
[17:43:32.661]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:32.661]     if (FALSE) {
[17:43:32.661]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:32.661]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:32.661]     }
[17:43:32.661]     ...future.result <- base::tryCatch({
[17:43:32.661]         base::withCallingHandlers({
[17:43:32.661]             ...future.value <- base::withVisible(base::local(2))
[17:43:32.661]             future::FutureResult(value = ...future.value$value, 
[17:43:32.661]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:32.661]                   ...future.rng), globalenv = if (FALSE) 
[17:43:32.661]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:32.661]                     ...future.globalenv.names))
[17:43:32.661]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:32.661]         }, condition = base::local({
[17:43:32.661]             c <- base::c
[17:43:32.661]             inherits <- base::inherits
[17:43:32.661]             invokeRestart <- base::invokeRestart
[17:43:32.661]             length <- base::length
[17:43:32.661]             list <- base::list
[17:43:32.661]             seq.int <- base::seq.int
[17:43:32.661]             signalCondition <- base::signalCondition
[17:43:32.661]             sys.calls <- base::sys.calls
[17:43:32.661]             `[[` <- base::`[[`
[17:43:32.661]             `+` <- base::`+`
[17:43:32.661]             `<<-` <- base::`<<-`
[17:43:32.661]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:32.661]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:32.661]                   3L)]
[17:43:32.661]             }
[17:43:32.661]             function(cond) {
[17:43:32.661]                 is_error <- inherits(cond, "error")
[17:43:32.661]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:32.661]                   NULL)
[17:43:32.661]                 if (is_error) {
[17:43:32.661]                   sessionInformation <- function() {
[17:43:32.661]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:32.661]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:32.661]                       search = base::search(), system = base::Sys.info())
[17:43:32.661]                   }
[17:43:32.661]                   ...future.conditions[[length(...future.conditions) + 
[17:43:32.661]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:32.661]                     cond$call), session = sessionInformation(), 
[17:43:32.661]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:32.661]                   signalCondition(cond)
[17:43:32.661]                 }
[17:43:32.661]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:32.661]                 "immediateCondition"))) {
[17:43:32.661]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:32.661]                   ...future.conditions[[length(...future.conditions) + 
[17:43:32.661]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:32.661]                   if (TRUE && !signal) {
[17:43:32.661]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:32.661]                     {
[17:43:32.661]                       inherits <- base::inherits
[17:43:32.661]                       invokeRestart <- base::invokeRestart
[17:43:32.661]                       is.null <- base::is.null
[17:43:32.661]                       muffled <- FALSE
[17:43:32.661]                       if (inherits(cond, "message")) {
[17:43:32.661]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:32.661]                         if (muffled) 
[17:43:32.661]                           invokeRestart("muffleMessage")
[17:43:32.661]                       }
[17:43:32.661]                       else if (inherits(cond, "warning")) {
[17:43:32.661]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:32.661]                         if (muffled) 
[17:43:32.661]                           invokeRestart("muffleWarning")
[17:43:32.661]                       }
[17:43:32.661]                       else if (inherits(cond, "condition")) {
[17:43:32.661]                         if (!is.null(pattern)) {
[17:43:32.661]                           computeRestarts <- base::computeRestarts
[17:43:32.661]                           grepl <- base::grepl
[17:43:32.661]                           restarts <- computeRestarts(cond)
[17:43:32.661]                           for (restart in restarts) {
[17:43:32.661]                             name <- restart$name
[17:43:32.661]                             if (is.null(name)) 
[17:43:32.661]                               next
[17:43:32.661]                             if (!grepl(pattern, name)) 
[17:43:32.661]                               next
[17:43:32.661]                             invokeRestart(restart)
[17:43:32.661]                             muffled <- TRUE
[17:43:32.661]                             break
[17:43:32.661]                           }
[17:43:32.661]                         }
[17:43:32.661]                       }
[17:43:32.661]                       invisible(muffled)
[17:43:32.661]                     }
[17:43:32.661]                     muffleCondition(cond, pattern = "^muffle")
[17:43:32.661]                   }
[17:43:32.661]                 }
[17:43:32.661]                 else {
[17:43:32.661]                   if (TRUE) {
[17:43:32.661]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:32.661]                     {
[17:43:32.661]                       inherits <- base::inherits
[17:43:32.661]                       invokeRestart <- base::invokeRestart
[17:43:32.661]                       is.null <- base::is.null
[17:43:32.661]                       muffled <- FALSE
[17:43:32.661]                       if (inherits(cond, "message")) {
[17:43:32.661]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:32.661]                         if (muffled) 
[17:43:32.661]                           invokeRestart("muffleMessage")
[17:43:32.661]                       }
[17:43:32.661]                       else if (inherits(cond, "warning")) {
[17:43:32.661]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:32.661]                         if (muffled) 
[17:43:32.661]                           invokeRestart("muffleWarning")
[17:43:32.661]                       }
[17:43:32.661]                       else if (inherits(cond, "condition")) {
[17:43:32.661]                         if (!is.null(pattern)) {
[17:43:32.661]                           computeRestarts <- base::computeRestarts
[17:43:32.661]                           grepl <- base::grepl
[17:43:32.661]                           restarts <- computeRestarts(cond)
[17:43:32.661]                           for (restart in restarts) {
[17:43:32.661]                             name <- restart$name
[17:43:32.661]                             if (is.null(name)) 
[17:43:32.661]                               next
[17:43:32.661]                             if (!grepl(pattern, name)) 
[17:43:32.661]                               next
[17:43:32.661]                             invokeRestart(restart)
[17:43:32.661]                             muffled <- TRUE
[17:43:32.661]                             break
[17:43:32.661]                           }
[17:43:32.661]                         }
[17:43:32.661]                       }
[17:43:32.661]                       invisible(muffled)
[17:43:32.661]                     }
[17:43:32.661]                     muffleCondition(cond, pattern = "^muffle")
[17:43:32.661]                   }
[17:43:32.661]                 }
[17:43:32.661]             }
[17:43:32.661]         }))
[17:43:32.661]     }, error = function(ex) {
[17:43:32.661]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:32.661]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:32.661]                 ...future.rng), started = ...future.startTime, 
[17:43:32.661]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:32.661]             version = "1.8"), class = "FutureResult")
[17:43:32.661]     }, finally = {
[17:43:32.661]         if (!identical(...future.workdir, getwd())) 
[17:43:32.661]             setwd(...future.workdir)
[17:43:32.661]         {
[17:43:32.661]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:32.661]                 ...future.oldOptions$nwarnings <- NULL
[17:43:32.661]             }
[17:43:32.661]             base::options(...future.oldOptions)
[17:43:32.661]             if (.Platform$OS.type == "windows") {
[17:43:32.661]                 old_names <- names(...future.oldEnvVars)
[17:43:32.661]                 envs <- base::Sys.getenv()
[17:43:32.661]                 names <- names(envs)
[17:43:32.661]                 common <- intersect(names, old_names)
[17:43:32.661]                 added <- setdiff(names, old_names)
[17:43:32.661]                 removed <- setdiff(old_names, names)
[17:43:32.661]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:32.661]                   envs[common]]
[17:43:32.661]                 NAMES <- toupper(changed)
[17:43:32.661]                 args <- list()
[17:43:32.661]                 for (kk in seq_along(NAMES)) {
[17:43:32.661]                   name <- changed[[kk]]
[17:43:32.661]                   NAME <- NAMES[[kk]]
[17:43:32.661]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:32.661]                     next
[17:43:32.661]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:32.661]                 }
[17:43:32.661]                 NAMES <- toupper(added)
[17:43:32.661]                 for (kk in seq_along(NAMES)) {
[17:43:32.661]                   name <- added[[kk]]
[17:43:32.661]                   NAME <- NAMES[[kk]]
[17:43:32.661]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:32.661]                     next
[17:43:32.661]                   args[[name]] <- ""
[17:43:32.661]                 }
[17:43:32.661]                 NAMES <- toupper(removed)
[17:43:32.661]                 for (kk in seq_along(NAMES)) {
[17:43:32.661]                   name <- removed[[kk]]
[17:43:32.661]                   NAME <- NAMES[[kk]]
[17:43:32.661]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:32.661]                     next
[17:43:32.661]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:32.661]                 }
[17:43:32.661]                 if (length(args) > 0) 
[17:43:32.661]                   base::do.call(base::Sys.setenv, args = args)
[17:43:32.661]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:32.661]             }
[17:43:32.661]             else {
[17:43:32.661]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:32.661]             }
[17:43:32.661]             {
[17:43:32.661]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:32.661]                   0L) {
[17:43:32.661]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:32.661]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:32.661]                   base::options(opts)
[17:43:32.661]                 }
[17:43:32.661]                 {
[17:43:32.661]                   {
[17:43:32.661]                     NULL
[17:43:32.661]                     RNGkind("Mersenne-Twister")
[17:43:32.661]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:32.661]                       inherits = FALSE)
[17:43:32.661]                   }
[17:43:32.661]                   options(future.plan = NULL)
[17:43:32.661]                   if (is.na(NA_character_)) 
[17:43:32.661]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:32.661]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:32.661]                   future::plan(list(function (..., envir = parent.frame()) 
[17:43:32.661]                   {
[17:43:32.661]                     future <- SequentialFuture(..., envir = envir)
[17:43:32.661]                     if (!future$lazy) 
[17:43:32.661]                       future <- run(future)
[17:43:32.661]                     invisible(future)
[17:43:32.661]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:32.661]                 }
[17:43:32.661]             }
[17:43:32.661]         }
[17:43:32.661]     })
[17:43:32.661]     if (TRUE) {
[17:43:32.661]         base::sink(type = "output", split = FALSE)
[17:43:32.661]         if (TRUE) {
[17:43:32.661]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:32.661]         }
[17:43:32.661]         else {
[17:43:32.661]             ...future.result["stdout"] <- base::list(NULL)
[17:43:32.661]         }
[17:43:32.661]         base::close(...future.stdout)
[17:43:32.661]         ...future.stdout <- NULL
[17:43:32.661]     }
[17:43:32.661]     ...future.result$conditions <- ...future.conditions
[17:43:32.661]     ...future.result$finished <- base::Sys.time()
[17:43:32.661]     ...future.result
[17:43:32.661] }
[17:43:32.663] plan(): Setting new future strategy stack:
[17:43:32.663] List of future strategies:
[17:43:32.663] 1. sequential:
[17:43:32.663]    - args: function (..., envir = parent.frame())
[17:43:32.663]    - tweaked: FALSE
[17:43:32.663]    - call: NULL
[17:43:32.663] plan(): nbrOfWorkers() = 1
[17:43:32.664] plan(): Setting new future strategy stack:
[17:43:32.664] List of future strategies:
[17:43:32.664] 1. sequential:
[17:43:32.664]    - args: function (..., envir = parent.frame())
[17:43:32.664]    - tweaked: FALSE
[17:43:32.664]    - call: plan(strategy)
[17:43:32.665] plan(): nbrOfWorkers() = 1
[17:43:32.665] SequentialFuture started (and completed)
[17:43:32.665] - Launch lazy future ... done
[17:43:32.665] run() for ‘SequentialFuture’ ... done
[17:43:32.665] resolve() on list ...
[17:43:32.665]  recursive: 0
[17:43:32.665]  length: 3
[17:43:32.665]  elements: ‘a’, ‘b’, ‘’
[17:43:32.665] run() for ‘Future’ ...
[17:43:32.666] - state: ‘created’
[17:43:32.666] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:32.666] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:32.666] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:32.666]   - Field: ‘label’
[17:43:32.666]   - Field: ‘local’
[17:43:32.666]   - Field: ‘owner’
[17:43:32.666]   - Field: ‘envir’
[17:43:32.666]   - Field: ‘packages’
[17:43:32.667]   - Field: ‘gc’
[17:43:32.667]   - Field: ‘conditions’
[17:43:32.667]   - Field: ‘expr’
[17:43:32.667]   - Field: ‘uuid’
[17:43:32.667]   - Field: ‘seed’
[17:43:32.667]   - Field: ‘version’
[17:43:32.667]   - Field: ‘result’
[17:43:32.667]   - Field: ‘asynchronous’
[17:43:32.667]   - Field: ‘calls’
[17:43:32.667]   - Field: ‘globals’
[17:43:32.668]   - Field: ‘stdout’
[17:43:32.668]   - Field: ‘earlySignal’
[17:43:32.668]   - Field: ‘lazy’
[17:43:32.668]   - Field: ‘state’
[17:43:32.668] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:32.668] - Launch lazy future ...
[17:43:32.668] Packages needed by the future expression (n = 0): <none>
[17:43:32.668] Packages needed by future strategies (n = 0): <none>
[17:43:32.669] {
[17:43:32.669]     {
[17:43:32.669]         {
[17:43:32.669]             ...future.startTime <- base::Sys.time()
[17:43:32.669]             {
[17:43:32.669]                 {
[17:43:32.669]                   {
[17:43:32.669]                     base::local({
[17:43:32.669]                       has_future <- base::requireNamespace("future", 
[17:43:32.669]                         quietly = TRUE)
[17:43:32.669]                       if (has_future) {
[17:43:32.669]                         ns <- base::getNamespace("future")
[17:43:32.669]                         version <- ns[[".package"]][["version"]]
[17:43:32.669]                         if (is.null(version)) 
[17:43:32.669]                           version <- utils::packageVersion("future")
[17:43:32.669]                       }
[17:43:32.669]                       else {
[17:43:32.669]                         version <- NULL
[17:43:32.669]                       }
[17:43:32.669]                       if (!has_future || version < "1.8.0") {
[17:43:32.669]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:32.669]                           "", base::R.version$version.string), 
[17:43:32.669]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:32.669]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:32.669]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:32.669]                             "release", "version")], collapse = " "), 
[17:43:32.669]                           hostname = base::Sys.info()[["nodename"]])
[17:43:32.669]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:32.669]                           info)
[17:43:32.669]                         info <- base::paste(info, collapse = "; ")
[17:43:32.669]                         if (!has_future) {
[17:43:32.669]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:32.669]                             info)
[17:43:32.669]                         }
[17:43:32.669]                         else {
[17:43:32.669]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:32.669]                             info, version)
[17:43:32.669]                         }
[17:43:32.669]                         base::stop(msg)
[17:43:32.669]                       }
[17:43:32.669]                     })
[17:43:32.669]                   }
[17:43:32.669]                   options(future.plan = NULL)
[17:43:32.669]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:32.669]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:32.669]                 }
[17:43:32.669]                 ...future.workdir <- getwd()
[17:43:32.669]             }
[17:43:32.669]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:32.669]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:32.669]         }
[17:43:32.669]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:32.669]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:32.669]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:32.669]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:32.669]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:32.669]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:32.669]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:32.669]             base::names(...future.oldOptions))
[17:43:32.669]     }
[17:43:32.669]     if (FALSE) {
[17:43:32.669]     }
[17:43:32.669]     else {
[17:43:32.669]         if (TRUE) {
[17:43:32.669]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:32.669]                 open = "w")
[17:43:32.669]         }
[17:43:32.669]         else {
[17:43:32.669]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:32.669]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:32.669]         }
[17:43:32.669]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:32.669]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:32.669]             base::sink(type = "output", split = FALSE)
[17:43:32.669]             base::close(...future.stdout)
[17:43:32.669]         }, add = TRUE)
[17:43:32.669]     }
[17:43:32.669]     ...future.frame <- base::sys.nframe()
[17:43:32.669]     ...future.conditions <- base::list()
[17:43:32.669]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:32.669]     if (FALSE) {
[17:43:32.669]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:32.669]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:32.669]     }
[17:43:32.669]     ...future.result <- base::tryCatch({
[17:43:32.669]         base::withCallingHandlers({
[17:43:32.669]             ...future.value <- base::withVisible(base::local(1))
[17:43:32.669]             future::FutureResult(value = ...future.value$value, 
[17:43:32.669]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:32.669]                   ...future.rng), globalenv = if (FALSE) 
[17:43:32.669]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:32.669]                     ...future.globalenv.names))
[17:43:32.669]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:32.669]         }, condition = base::local({
[17:43:32.669]             c <- base::c
[17:43:32.669]             inherits <- base::inherits
[17:43:32.669]             invokeRestart <- base::invokeRestart
[17:43:32.669]             length <- base::length
[17:43:32.669]             list <- base::list
[17:43:32.669]             seq.int <- base::seq.int
[17:43:32.669]             signalCondition <- base::signalCondition
[17:43:32.669]             sys.calls <- base::sys.calls
[17:43:32.669]             `[[` <- base::`[[`
[17:43:32.669]             `+` <- base::`+`
[17:43:32.669]             `<<-` <- base::`<<-`
[17:43:32.669]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:32.669]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:32.669]                   3L)]
[17:43:32.669]             }
[17:43:32.669]             function(cond) {
[17:43:32.669]                 is_error <- inherits(cond, "error")
[17:43:32.669]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:32.669]                   NULL)
[17:43:32.669]                 if (is_error) {
[17:43:32.669]                   sessionInformation <- function() {
[17:43:32.669]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:32.669]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:32.669]                       search = base::search(), system = base::Sys.info())
[17:43:32.669]                   }
[17:43:32.669]                   ...future.conditions[[length(...future.conditions) + 
[17:43:32.669]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:32.669]                     cond$call), session = sessionInformation(), 
[17:43:32.669]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:32.669]                   signalCondition(cond)
[17:43:32.669]                 }
[17:43:32.669]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:32.669]                 "immediateCondition"))) {
[17:43:32.669]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:32.669]                   ...future.conditions[[length(...future.conditions) + 
[17:43:32.669]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:32.669]                   if (TRUE && !signal) {
[17:43:32.669]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:32.669]                     {
[17:43:32.669]                       inherits <- base::inherits
[17:43:32.669]                       invokeRestart <- base::invokeRestart
[17:43:32.669]                       is.null <- base::is.null
[17:43:32.669]                       muffled <- FALSE
[17:43:32.669]                       if (inherits(cond, "message")) {
[17:43:32.669]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:32.669]                         if (muffled) 
[17:43:32.669]                           invokeRestart("muffleMessage")
[17:43:32.669]                       }
[17:43:32.669]                       else if (inherits(cond, "warning")) {
[17:43:32.669]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:32.669]                         if (muffled) 
[17:43:32.669]                           invokeRestart("muffleWarning")
[17:43:32.669]                       }
[17:43:32.669]                       else if (inherits(cond, "condition")) {
[17:43:32.669]                         if (!is.null(pattern)) {
[17:43:32.669]                           computeRestarts <- base::computeRestarts
[17:43:32.669]                           grepl <- base::grepl
[17:43:32.669]                           restarts <- computeRestarts(cond)
[17:43:32.669]                           for (restart in restarts) {
[17:43:32.669]                             name <- restart$name
[17:43:32.669]                             if (is.null(name)) 
[17:43:32.669]                               next
[17:43:32.669]                             if (!grepl(pattern, name)) 
[17:43:32.669]                               next
[17:43:32.669]                             invokeRestart(restart)
[17:43:32.669]                             muffled <- TRUE
[17:43:32.669]                             break
[17:43:32.669]                           }
[17:43:32.669]                         }
[17:43:32.669]                       }
[17:43:32.669]                       invisible(muffled)
[17:43:32.669]                     }
[17:43:32.669]                     muffleCondition(cond, pattern = "^muffle")
[17:43:32.669]                   }
[17:43:32.669]                 }
[17:43:32.669]                 else {
[17:43:32.669]                   if (TRUE) {
[17:43:32.669]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:32.669]                     {
[17:43:32.669]                       inherits <- base::inherits
[17:43:32.669]                       invokeRestart <- base::invokeRestart
[17:43:32.669]                       is.null <- base::is.null
[17:43:32.669]                       muffled <- FALSE
[17:43:32.669]                       if (inherits(cond, "message")) {
[17:43:32.669]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:32.669]                         if (muffled) 
[17:43:32.669]                           invokeRestart("muffleMessage")
[17:43:32.669]                       }
[17:43:32.669]                       else if (inherits(cond, "warning")) {
[17:43:32.669]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:32.669]                         if (muffled) 
[17:43:32.669]                           invokeRestart("muffleWarning")
[17:43:32.669]                       }
[17:43:32.669]                       else if (inherits(cond, "condition")) {
[17:43:32.669]                         if (!is.null(pattern)) {
[17:43:32.669]                           computeRestarts <- base::computeRestarts
[17:43:32.669]                           grepl <- base::grepl
[17:43:32.669]                           restarts <- computeRestarts(cond)
[17:43:32.669]                           for (restart in restarts) {
[17:43:32.669]                             name <- restart$name
[17:43:32.669]                             if (is.null(name)) 
[17:43:32.669]                               next
[17:43:32.669]                             if (!grepl(pattern, name)) 
[17:43:32.669]                               next
[17:43:32.669]                             invokeRestart(restart)
[17:43:32.669]                             muffled <- TRUE
[17:43:32.669]                             break
[17:43:32.669]                           }
[17:43:32.669]                         }
[17:43:32.669]                       }
[17:43:32.669]                       invisible(muffled)
[17:43:32.669]                     }
[17:43:32.669]                     muffleCondition(cond, pattern = "^muffle")
[17:43:32.669]                   }
[17:43:32.669]                 }
[17:43:32.669]             }
[17:43:32.669]         }))
[17:43:32.669]     }, error = function(ex) {
[17:43:32.669]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:32.669]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:32.669]                 ...future.rng), started = ...future.startTime, 
[17:43:32.669]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:32.669]             version = "1.8"), class = "FutureResult")
[17:43:32.669]     }, finally = {
[17:43:32.669]         if (!identical(...future.workdir, getwd())) 
[17:43:32.669]             setwd(...future.workdir)
[17:43:32.669]         {
[17:43:32.669]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:32.669]                 ...future.oldOptions$nwarnings <- NULL
[17:43:32.669]             }
[17:43:32.669]             base::options(...future.oldOptions)
[17:43:32.669]             if (.Platform$OS.type == "windows") {
[17:43:32.669]                 old_names <- names(...future.oldEnvVars)
[17:43:32.669]                 envs <- base::Sys.getenv()
[17:43:32.669]                 names <- names(envs)
[17:43:32.669]                 common <- intersect(names, old_names)
[17:43:32.669]                 added <- setdiff(names, old_names)
[17:43:32.669]                 removed <- setdiff(old_names, names)
[17:43:32.669]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:32.669]                   envs[common]]
[17:43:32.669]                 NAMES <- toupper(changed)
[17:43:32.669]                 args <- list()
[17:43:32.669]                 for (kk in seq_along(NAMES)) {
[17:43:32.669]                   name <- changed[[kk]]
[17:43:32.669]                   NAME <- NAMES[[kk]]
[17:43:32.669]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:32.669]                     next
[17:43:32.669]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:32.669]                 }
[17:43:32.669]                 NAMES <- toupper(added)
[17:43:32.669]                 for (kk in seq_along(NAMES)) {
[17:43:32.669]                   name <- added[[kk]]
[17:43:32.669]                   NAME <- NAMES[[kk]]
[17:43:32.669]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:32.669]                     next
[17:43:32.669]                   args[[name]] <- ""
[17:43:32.669]                 }
[17:43:32.669]                 NAMES <- toupper(removed)
[17:43:32.669]                 for (kk in seq_along(NAMES)) {
[17:43:32.669]                   name <- removed[[kk]]
[17:43:32.669]                   NAME <- NAMES[[kk]]
[17:43:32.669]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:32.669]                     next
[17:43:32.669]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:32.669]                 }
[17:43:32.669]                 if (length(args) > 0) 
[17:43:32.669]                   base::do.call(base::Sys.setenv, args = args)
[17:43:32.669]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:32.669]             }
[17:43:32.669]             else {
[17:43:32.669]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:32.669]             }
[17:43:32.669]             {
[17:43:32.669]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:32.669]                   0L) {
[17:43:32.669]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:32.669]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:32.669]                   base::options(opts)
[17:43:32.669]                 }
[17:43:32.669]                 {
[17:43:32.669]                   {
[17:43:32.669]                     NULL
[17:43:32.669]                     RNGkind("Mersenne-Twister")
[17:43:32.669]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:32.669]                       inherits = FALSE)
[17:43:32.669]                   }
[17:43:32.669]                   options(future.plan = NULL)
[17:43:32.669]                   if (is.na(NA_character_)) 
[17:43:32.669]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:32.669]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:32.669]                   future::plan(list(function (..., envir = parent.frame()) 
[17:43:32.669]                   {
[17:43:32.669]                     future <- SequentialFuture(..., envir = envir)
[17:43:32.669]                     if (!future$lazy) 
[17:43:32.669]                       future <- run(future)
[17:43:32.669]                     invisible(future)
[17:43:32.669]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:32.669]                 }
[17:43:32.669]             }
[17:43:32.669]         }
[17:43:32.669]     })
[17:43:32.669]     if (TRUE) {
[17:43:32.669]         base::sink(type = "output", split = FALSE)
[17:43:32.669]         if (TRUE) {
[17:43:32.669]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:32.669]         }
[17:43:32.669]         else {
[17:43:32.669]             ...future.result["stdout"] <- base::list(NULL)
[17:43:32.669]         }
[17:43:32.669]         base::close(...future.stdout)
[17:43:32.669]         ...future.stdout <- NULL
[17:43:32.669]     }
[17:43:32.669]     ...future.result$conditions <- ...future.conditions
[17:43:32.669]     ...future.result$finished <- base::Sys.time()
[17:43:32.669]     ...future.result
[17:43:32.669] }
[17:43:32.671] plan(): Setting new future strategy stack:
[17:43:32.671] List of future strategies:
[17:43:32.671] 1. sequential:
[17:43:32.671]    - args: function (..., envir = parent.frame())
[17:43:32.671]    - tweaked: FALSE
[17:43:32.671]    - call: NULL
[17:43:32.671] plan(): nbrOfWorkers() = 1
[17:43:32.672] plan(): Setting new future strategy stack:
[17:43:32.672] List of future strategies:
[17:43:32.672] 1. sequential:
[17:43:32.672]    - args: function (..., envir = parent.frame())
[17:43:32.672]    - tweaked: FALSE
[17:43:32.672]    - call: plan(strategy)
[17:43:32.673] plan(): nbrOfWorkers() = 1
[17:43:32.673] SequentialFuture started (and completed)
[17:43:32.673] - Launch lazy future ... done
[17:43:32.673] run() for ‘SequentialFuture’ ... done
[17:43:32.673] resolved() for ‘SequentialFuture’ ...
[17:43:32.673] - state: ‘finished’
[17:43:32.673] - run: TRUE
[17:43:32.673] - result: ‘FutureResult’
[17:43:32.674] resolved() for ‘SequentialFuture’ ... done
[17:43:32.674] Future #1
[17:43:32.674]  length: 2 (resolved future 1)
[17:43:32.674] resolved() for ‘SequentialFuture’ ...
[17:43:32.674] - state: ‘finished’
[17:43:32.674] - run: TRUE
[17:43:32.674] - result: ‘FutureResult’
[17:43:32.674] resolved() for ‘SequentialFuture’ ... done
[17:43:32.674] Future #2
[17:43:32.674]  length: 1 (resolved future 2)
[17:43:32.675]  length: 0 (resolved future 3)
[17:43:32.675] resolve() on list ... DONE
[17:43:32.675] resolved() for ‘SequentialFuture’ ...
[17:43:32.675] - state: ‘finished’
[17:43:32.675] - run: TRUE
[17:43:32.675] - result: ‘FutureResult’
[17:43:32.675] resolved() for ‘SequentialFuture’ ... done
[17:43:32.675] resolved() for ‘SequentialFuture’ ...
[17:43:32.675] - state: ‘finished’
[17:43:32.675] - run: TRUE
[17:43:32.675] - result: ‘FutureResult’
[17:43:32.676] resolved() for ‘SequentialFuture’ ... done
[17:43:32.676] getGlobalsAndPackages() ...
[17:43:32.676] Searching for globals...
[17:43:32.676] 
[17:43:32.676] Searching for globals ... DONE
[17:43:32.676] - globals: [0] <none>
[17:43:32.676] getGlobalsAndPackages() ... DONE
[17:43:32.677] getGlobalsAndPackages() ...
[17:43:32.677] Searching for globals...
[17:43:32.677] 
[17:43:32.677] Searching for globals ... DONE
[17:43:32.677] - globals: [0] <none>
[17:43:32.677] getGlobalsAndPackages() ... DONE
[17:43:32.678] resolve() on list ...
[17:43:32.678]  recursive: 0
[17:43:32.678]  length: 3
[17:43:32.678]  elements: ‘a’, ‘b’, ‘’
[17:43:32.678] run() for ‘Future’ ...
[17:43:32.678] - state: ‘created’
[17:43:32.678] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:32.681] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:32.681] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:32.681]   - Field: ‘label’
[17:43:32.681]   - Field: ‘local’
[17:43:32.681]   - Field: ‘owner’
[17:43:32.681]   - Field: ‘envir’
[17:43:32.682]   - Field: ‘packages’
[17:43:32.682]   - Field: ‘gc’
[17:43:32.682]   - Field: ‘conditions’
[17:43:32.682]   - Field: ‘expr’
[17:43:32.682]   - Field: ‘uuid’
[17:43:32.682]   - Field: ‘seed’
[17:43:32.682]   - Field: ‘version’
[17:43:32.682]   - Field: ‘result’
[17:43:32.682]   - Field: ‘asynchronous’
[17:43:32.682]   - Field: ‘calls’
[17:43:32.682]   - Field: ‘globals’
[17:43:32.683]   - Field: ‘stdout’
[17:43:32.683]   - Field: ‘earlySignal’
[17:43:32.683]   - Field: ‘lazy’
[17:43:32.683]   - Field: ‘state’
[17:43:32.683] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:32.683] - Launch lazy future ...
[17:43:32.683] Packages needed by the future expression (n = 0): <none>
[17:43:32.683] Packages needed by future strategies (n = 0): <none>
[17:43:32.684] {
[17:43:32.684]     {
[17:43:32.684]         {
[17:43:32.684]             ...future.startTime <- base::Sys.time()
[17:43:32.684]             {
[17:43:32.684]                 {
[17:43:32.684]                   {
[17:43:32.684]                     base::local({
[17:43:32.684]                       has_future <- base::requireNamespace("future", 
[17:43:32.684]                         quietly = TRUE)
[17:43:32.684]                       if (has_future) {
[17:43:32.684]                         ns <- base::getNamespace("future")
[17:43:32.684]                         version <- ns[[".package"]][["version"]]
[17:43:32.684]                         if (is.null(version)) 
[17:43:32.684]                           version <- utils::packageVersion("future")
[17:43:32.684]                       }
[17:43:32.684]                       else {
[17:43:32.684]                         version <- NULL
[17:43:32.684]                       }
[17:43:32.684]                       if (!has_future || version < "1.8.0") {
[17:43:32.684]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:32.684]                           "", base::R.version$version.string), 
[17:43:32.684]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:32.684]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:32.684]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:32.684]                             "release", "version")], collapse = " "), 
[17:43:32.684]                           hostname = base::Sys.info()[["nodename"]])
[17:43:32.684]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:32.684]                           info)
[17:43:32.684]                         info <- base::paste(info, collapse = "; ")
[17:43:32.684]                         if (!has_future) {
[17:43:32.684]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:32.684]                             info)
[17:43:32.684]                         }
[17:43:32.684]                         else {
[17:43:32.684]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:32.684]                             info, version)
[17:43:32.684]                         }
[17:43:32.684]                         base::stop(msg)
[17:43:32.684]                       }
[17:43:32.684]                     })
[17:43:32.684]                   }
[17:43:32.684]                   options(future.plan = NULL)
[17:43:32.684]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:32.684]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:32.684]                 }
[17:43:32.684]                 ...future.workdir <- getwd()
[17:43:32.684]             }
[17:43:32.684]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:32.684]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:32.684]         }
[17:43:32.684]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:32.684]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:32.684]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:32.684]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:32.684]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:32.684]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:32.684]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:32.684]             base::names(...future.oldOptions))
[17:43:32.684]     }
[17:43:32.684]     if (FALSE) {
[17:43:32.684]     }
[17:43:32.684]     else {
[17:43:32.684]         if (TRUE) {
[17:43:32.684]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:32.684]                 open = "w")
[17:43:32.684]         }
[17:43:32.684]         else {
[17:43:32.684]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:32.684]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:32.684]         }
[17:43:32.684]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:32.684]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:32.684]             base::sink(type = "output", split = FALSE)
[17:43:32.684]             base::close(...future.stdout)
[17:43:32.684]         }, add = TRUE)
[17:43:32.684]     }
[17:43:32.684]     ...future.frame <- base::sys.nframe()
[17:43:32.684]     ...future.conditions <- base::list()
[17:43:32.684]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:32.684]     if (FALSE) {
[17:43:32.684]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:32.684]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:32.684]     }
[17:43:32.684]     ...future.result <- base::tryCatch({
[17:43:32.684]         base::withCallingHandlers({
[17:43:32.684]             ...future.value <- base::withVisible(base::local(1))
[17:43:32.684]             future::FutureResult(value = ...future.value$value, 
[17:43:32.684]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:32.684]                   ...future.rng), globalenv = if (FALSE) 
[17:43:32.684]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:32.684]                     ...future.globalenv.names))
[17:43:32.684]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:32.684]         }, condition = base::local({
[17:43:32.684]             c <- base::c
[17:43:32.684]             inherits <- base::inherits
[17:43:32.684]             invokeRestart <- base::invokeRestart
[17:43:32.684]             length <- base::length
[17:43:32.684]             list <- base::list
[17:43:32.684]             seq.int <- base::seq.int
[17:43:32.684]             signalCondition <- base::signalCondition
[17:43:32.684]             sys.calls <- base::sys.calls
[17:43:32.684]             `[[` <- base::`[[`
[17:43:32.684]             `+` <- base::`+`
[17:43:32.684]             `<<-` <- base::`<<-`
[17:43:32.684]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:32.684]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:32.684]                   3L)]
[17:43:32.684]             }
[17:43:32.684]             function(cond) {
[17:43:32.684]                 is_error <- inherits(cond, "error")
[17:43:32.684]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:32.684]                   NULL)
[17:43:32.684]                 if (is_error) {
[17:43:32.684]                   sessionInformation <- function() {
[17:43:32.684]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:32.684]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:32.684]                       search = base::search(), system = base::Sys.info())
[17:43:32.684]                   }
[17:43:32.684]                   ...future.conditions[[length(...future.conditions) + 
[17:43:32.684]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:32.684]                     cond$call), session = sessionInformation(), 
[17:43:32.684]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:32.684]                   signalCondition(cond)
[17:43:32.684]                 }
[17:43:32.684]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:32.684]                 "immediateCondition"))) {
[17:43:32.684]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:32.684]                   ...future.conditions[[length(...future.conditions) + 
[17:43:32.684]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:32.684]                   if (TRUE && !signal) {
[17:43:32.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:32.684]                     {
[17:43:32.684]                       inherits <- base::inherits
[17:43:32.684]                       invokeRestart <- base::invokeRestart
[17:43:32.684]                       is.null <- base::is.null
[17:43:32.684]                       muffled <- FALSE
[17:43:32.684]                       if (inherits(cond, "message")) {
[17:43:32.684]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:32.684]                         if (muffled) 
[17:43:32.684]                           invokeRestart("muffleMessage")
[17:43:32.684]                       }
[17:43:32.684]                       else if (inherits(cond, "warning")) {
[17:43:32.684]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:32.684]                         if (muffled) 
[17:43:32.684]                           invokeRestart("muffleWarning")
[17:43:32.684]                       }
[17:43:32.684]                       else if (inherits(cond, "condition")) {
[17:43:32.684]                         if (!is.null(pattern)) {
[17:43:32.684]                           computeRestarts <- base::computeRestarts
[17:43:32.684]                           grepl <- base::grepl
[17:43:32.684]                           restarts <- computeRestarts(cond)
[17:43:32.684]                           for (restart in restarts) {
[17:43:32.684]                             name <- restart$name
[17:43:32.684]                             if (is.null(name)) 
[17:43:32.684]                               next
[17:43:32.684]                             if (!grepl(pattern, name)) 
[17:43:32.684]                               next
[17:43:32.684]                             invokeRestart(restart)
[17:43:32.684]                             muffled <- TRUE
[17:43:32.684]                             break
[17:43:32.684]                           }
[17:43:32.684]                         }
[17:43:32.684]                       }
[17:43:32.684]                       invisible(muffled)
[17:43:32.684]                     }
[17:43:32.684]                     muffleCondition(cond, pattern = "^muffle")
[17:43:32.684]                   }
[17:43:32.684]                 }
[17:43:32.684]                 else {
[17:43:32.684]                   if (TRUE) {
[17:43:32.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:32.684]                     {
[17:43:32.684]                       inherits <- base::inherits
[17:43:32.684]                       invokeRestart <- base::invokeRestart
[17:43:32.684]                       is.null <- base::is.null
[17:43:32.684]                       muffled <- FALSE
[17:43:32.684]                       if (inherits(cond, "message")) {
[17:43:32.684]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:32.684]                         if (muffled) 
[17:43:32.684]                           invokeRestart("muffleMessage")
[17:43:32.684]                       }
[17:43:32.684]                       else if (inherits(cond, "warning")) {
[17:43:32.684]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:32.684]                         if (muffled) 
[17:43:32.684]                           invokeRestart("muffleWarning")
[17:43:32.684]                       }
[17:43:32.684]                       else if (inherits(cond, "condition")) {
[17:43:32.684]                         if (!is.null(pattern)) {
[17:43:32.684]                           computeRestarts <- base::computeRestarts
[17:43:32.684]                           grepl <- base::grepl
[17:43:32.684]                           restarts <- computeRestarts(cond)
[17:43:32.684]                           for (restart in restarts) {
[17:43:32.684]                             name <- restart$name
[17:43:32.684]                             if (is.null(name)) 
[17:43:32.684]                               next
[17:43:32.684]                             if (!grepl(pattern, name)) 
[17:43:32.684]                               next
[17:43:32.684]                             invokeRestart(restart)
[17:43:32.684]                             muffled <- TRUE
[17:43:32.684]                             break
[17:43:32.684]                           }
[17:43:32.684]                         }
[17:43:32.684]                       }
[17:43:32.684]                       invisible(muffled)
[17:43:32.684]                     }
[17:43:32.684]                     muffleCondition(cond, pattern = "^muffle")
[17:43:32.684]                   }
[17:43:32.684]                 }
[17:43:32.684]             }
[17:43:32.684]         }))
[17:43:32.684]     }, error = function(ex) {
[17:43:32.684]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:32.684]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:32.684]                 ...future.rng), started = ...future.startTime, 
[17:43:32.684]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:32.684]             version = "1.8"), class = "FutureResult")
[17:43:32.684]     }, finally = {
[17:43:32.684]         if (!identical(...future.workdir, getwd())) 
[17:43:32.684]             setwd(...future.workdir)
[17:43:32.684]         {
[17:43:32.684]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:32.684]                 ...future.oldOptions$nwarnings <- NULL
[17:43:32.684]             }
[17:43:32.684]             base::options(...future.oldOptions)
[17:43:32.684]             if (.Platform$OS.type == "windows") {
[17:43:32.684]                 old_names <- names(...future.oldEnvVars)
[17:43:32.684]                 envs <- base::Sys.getenv()
[17:43:32.684]                 names <- names(envs)
[17:43:32.684]                 common <- intersect(names, old_names)
[17:43:32.684]                 added <- setdiff(names, old_names)
[17:43:32.684]                 removed <- setdiff(old_names, names)
[17:43:32.684]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:32.684]                   envs[common]]
[17:43:32.684]                 NAMES <- toupper(changed)
[17:43:32.684]                 args <- list()
[17:43:32.684]                 for (kk in seq_along(NAMES)) {
[17:43:32.684]                   name <- changed[[kk]]
[17:43:32.684]                   NAME <- NAMES[[kk]]
[17:43:32.684]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:32.684]                     next
[17:43:32.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:32.684]                 }
[17:43:32.684]                 NAMES <- toupper(added)
[17:43:32.684]                 for (kk in seq_along(NAMES)) {
[17:43:32.684]                   name <- added[[kk]]
[17:43:32.684]                   NAME <- NAMES[[kk]]
[17:43:32.684]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:32.684]                     next
[17:43:32.684]                   args[[name]] <- ""
[17:43:32.684]                 }
[17:43:32.684]                 NAMES <- toupper(removed)
[17:43:32.684]                 for (kk in seq_along(NAMES)) {
[17:43:32.684]                   name <- removed[[kk]]
[17:43:32.684]                   NAME <- NAMES[[kk]]
[17:43:32.684]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:32.684]                     next
[17:43:32.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:32.684]                 }
[17:43:32.684]                 if (length(args) > 0) 
[17:43:32.684]                   base::do.call(base::Sys.setenv, args = args)
[17:43:32.684]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:32.684]             }
[17:43:32.684]             else {
[17:43:32.684]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:32.684]             }
[17:43:32.684]             {
[17:43:32.684]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:32.684]                   0L) {
[17:43:32.684]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:32.684]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:32.684]                   base::options(opts)
[17:43:32.684]                 }
[17:43:32.684]                 {
[17:43:32.684]                   {
[17:43:32.684]                     NULL
[17:43:32.684]                     RNGkind("Mersenne-Twister")
[17:43:32.684]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:32.684]                       inherits = FALSE)
[17:43:32.684]                   }
[17:43:32.684]                   options(future.plan = NULL)
[17:43:32.684]                   if (is.na(NA_character_)) 
[17:43:32.684]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:32.684]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:32.684]                   future::plan(list(function (..., envir = parent.frame()) 
[17:43:32.684]                   {
[17:43:32.684]                     future <- SequentialFuture(..., envir = envir)
[17:43:32.684]                     if (!future$lazy) 
[17:43:32.684]                       future <- run(future)
[17:43:32.684]                     invisible(future)
[17:43:32.684]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:32.684]                 }
[17:43:32.684]             }
[17:43:32.684]         }
[17:43:32.684]     })
[17:43:32.684]     if (TRUE) {
[17:43:32.684]         base::sink(type = "output", split = FALSE)
[17:43:32.684]         if (TRUE) {
[17:43:32.684]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:32.684]         }
[17:43:32.684]         else {
[17:43:32.684]             ...future.result["stdout"] <- base::list(NULL)
[17:43:32.684]         }
[17:43:32.684]         base::close(...future.stdout)
[17:43:32.684]         ...future.stdout <- NULL
[17:43:32.684]     }
[17:43:32.684]     ...future.result$conditions <- ...future.conditions
[17:43:32.684]     ...future.result$finished <- base::Sys.time()
[17:43:32.684]     ...future.result
[17:43:32.684] }
[17:43:32.686] plan(): Setting new future strategy stack:
[17:43:32.686] List of future strategies:
[17:43:32.686] 1. sequential:
[17:43:32.686]    - args: function (..., envir = parent.frame())
[17:43:32.686]    - tweaked: FALSE
[17:43:32.686]    - call: NULL
[17:43:32.686] plan(): nbrOfWorkers() = 1
[17:43:32.687] plan(): Setting new future strategy stack:
[17:43:32.687] List of future strategies:
[17:43:32.687] 1. sequential:
[17:43:32.687]    - args: function (..., envir = parent.frame())
[17:43:32.687]    - tweaked: FALSE
[17:43:32.687]    - call: plan(strategy)
[17:43:32.688] plan(): nbrOfWorkers() = 1
[17:43:32.688] SequentialFuture started (and completed)
[17:43:32.688] - Launch lazy future ... done
[17:43:32.688] run() for ‘SequentialFuture’ ... done
[17:43:32.688] resolved() for ‘SequentialFuture’ ...
[17:43:32.688] - state: ‘finished’
[17:43:32.688] - run: TRUE
[17:43:32.688] - result: ‘FutureResult’
[17:43:32.688] resolved() for ‘SequentialFuture’ ... done
[17:43:32.689] Future #1
[17:43:32.689]  length: 2 (resolved future 1)
[17:43:32.689] run() for ‘Future’ ...
[17:43:32.689] - state: ‘created’
[17:43:32.689] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:32.689] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:32.689] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:32.689]   - Field: ‘label’
[17:43:32.690]   - Field: ‘local’
[17:43:32.690]   - Field: ‘owner’
[17:43:32.690]   - Field: ‘envir’
[17:43:32.690]   - Field: ‘packages’
[17:43:32.690]   - Field: ‘gc’
[17:43:32.690]   - Field: ‘conditions’
[17:43:32.690]   - Field: ‘expr’
[17:43:32.690]   - Field: ‘uuid’
[17:43:32.690]   - Field: ‘seed’
[17:43:32.690]   - Field: ‘version’
[17:43:32.691]   - Field: ‘result’
[17:43:32.691]   - Field: ‘asynchronous’
[17:43:32.691]   - Field: ‘calls’
[17:43:32.691]   - Field: ‘globals’
[17:43:32.691]   - Field: ‘stdout’
[17:43:32.691]   - Field: ‘earlySignal’
[17:43:32.691]   - Field: ‘lazy’
[17:43:32.691]   - Field: ‘state’
[17:43:32.691] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:32.691] - Launch lazy future ...
[17:43:32.692] Packages needed by the future expression (n = 0): <none>
[17:43:32.692] Packages needed by future strategies (n = 0): <none>
[17:43:32.692] {
[17:43:32.692]     {
[17:43:32.692]         {
[17:43:32.692]             ...future.startTime <- base::Sys.time()
[17:43:32.692]             {
[17:43:32.692]                 {
[17:43:32.692]                   {
[17:43:32.692]                     base::local({
[17:43:32.692]                       has_future <- base::requireNamespace("future", 
[17:43:32.692]                         quietly = TRUE)
[17:43:32.692]                       if (has_future) {
[17:43:32.692]                         ns <- base::getNamespace("future")
[17:43:32.692]                         version <- ns[[".package"]][["version"]]
[17:43:32.692]                         if (is.null(version)) 
[17:43:32.692]                           version <- utils::packageVersion("future")
[17:43:32.692]                       }
[17:43:32.692]                       else {
[17:43:32.692]                         version <- NULL
[17:43:32.692]                       }
[17:43:32.692]                       if (!has_future || version < "1.8.0") {
[17:43:32.692]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:32.692]                           "", base::R.version$version.string), 
[17:43:32.692]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:32.692]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:32.692]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:32.692]                             "release", "version")], collapse = " "), 
[17:43:32.692]                           hostname = base::Sys.info()[["nodename"]])
[17:43:32.692]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:32.692]                           info)
[17:43:32.692]                         info <- base::paste(info, collapse = "; ")
[17:43:32.692]                         if (!has_future) {
[17:43:32.692]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:32.692]                             info)
[17:43:32.692]                         }
[17:43:32.692]                         else {
[17:43:32.692]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:32.692]                             info, version)
[17:43:32.692]                         }
[17:43:32.692]                         base::stop(msg)
[17:43:32.692]                       }
[17:43:32.692]                     })
[17:43:32.692]                   }
[17:43:32.692]                   options(future.plan = NULL)
[17:43:32.692]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:32.692]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:32.692]                 }
[17:43:32.692]                 ...future.workdir <- getwd()
[17:43:32.692]             }
[17:43:32.692]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:32.692]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:32.692]         }
[17:43:32.692]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:32.692]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:32.692]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:32.692]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:32.692]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:32.692]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:32.692]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:32.692]             base::names(...future.oldOptions))
[17:43:32.692]     }
[17:43:32.692]     if (FALSE) {
[17:43:32.692]     }
[17:43:32.692]     else {
[17:43:32.692]         if (TRUE) {
[17:43:32.692]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:32.692]                 open = "w")
[17:43:32.692]         }
[17:43:32.692]         else {
[17:43:32.692]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:32.692]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:32.692]         }
[17:43:32.692]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:32.692]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:32.692]             base::sink(type = "output", split = FALSE)
[17:43:32.692]             base::close(...future.stdout)
[17:43:32.692]         }, add = TRUE)
[17:43:32.692]     }
[17:43:32.692]     ...future.frame <- base::sys.nframe()
[17:43:32.692]     ...future.conditions <- base::list()
[17:43:32.692]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:32.692]     if (FALSE) {
[17:43:32.692]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:32.692]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:32.692]     }
[17:43:32.692]     ...future.result <- base::tryCatch({
[17:43:32.692]         base::withCallingHandlers({
[17:43:32.692]             ...future.value <- base::withVisible(base::local(2))
[17:43:32.692]             future::FutureResult(value = ...future.value$value, 
[17:43:32.692]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:32.692]                   ...future.rng), globalenv = if (FALSE) 
[17:43:32.692]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:32.692]                     ...future.globalenv.names))
[17:43:32.692]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:32.692]         }, condition = base::local({
[17:43:32.692]             c <- base::c
[17:43:32.692]             inherits <- base::inherits
[17:43:32.692]             invokeRestart <- base::invokeRestart
[17:43:32.692]             length <- base::length
[17:43:32.692]             list <- base::list
[17:43:32.692]             seq.int <- base::seq.int
[17:43:32.692]             signalCondition <- base::signalCondition
[17:43:32.692]             sys.calls <- base::sys.calls
[17:43:32.692]             `[[` <- base::`[[`
[17:43:32.692]             `+` <- base::`+`
[17:43:32.692]             `<<-` <- base::`<<-`
[17:43:32.692]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:32.692]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:32.692]                   3L)]
[17:43:32.692]             }
[17:43:32.692]             function(cond) {
[17:43:32.692]                 is_error <- inherits(cond, "error")
[17:43:32.692]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:32.692]                   NULL)
[17:43:32.692]                 if (is_error) {
[17:43:32.692]                   sessionInformation <- function() {
[17:43:32.692]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:32.692]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:32.692]                       search = base::search(), system = base::Sys.info())
[17:43:32.692]                   }
[17:43:32.692]                   ...future.conditions[[length(...future.conditions) + 
[17:43:32.692]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:32.692]                     cond$call), session = sessionInformation(), 
[17:43:32.692]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:32.692]                   signalCondition(cond)
[17:43:32.692]                 }
[17:43:32.692]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:32.692]                 "immediateCondition"))) {
[17:43:32.692]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:32.692]                   ...future.conditions[[length(...future.conditions) + 
[17:43:32.692]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:32.692]                   if (TRUE && !signal) {
[17:43:32.692]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:32.692]                     {
[17:43:32.692]                       inherits <- base::inherits
[17:43:32.692]                       invokeRestart <- base::invokeRestart
[17:43:32.692]                       is.null <- base::is.null
[17:43:32.692]                       muffled <- FALSE
[17:43:32.692]                       if (inherits(cond, "message")) {
[17:43:32.692]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:32.692]                         if (muffled) 
[17:43:32.692]                           invokeRestart("muffleMessage")
[17:43:32.692]                       }
[17:43:32.692]                       else if (inherits(cond, "warning")) {
[17:43:32.692]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:32.692]                         if (muffled) 
[17:43:32.692]                           invokeRestart("muffleWarning")
[17:43:32.692]                       }
[17:43:32.692]                       else if (inherits(cond, "condition")) {
[17:43:32.692]                         if (!is.null(pattern)) {
[17:43:32.692]                           computeRestarts <- base::computeRestarts
[17:43:32.692]                           grepl <- base::grepl
[17:43:32.692]                           restarts <- computeRestarts(cond)
[17:43:32.692]                           for (restart in restarts) {
[17:43:32.692]                             name <- restart$name
[17:43:32.692]                             if (is.null(name)) 
[17:43:32.692]                               next
[17:43:32.692]                             if (!grepl(pattern, name)) 
[17:43:32.692]                               next
[17:43:32.692]                             invokeRestart(restart)
[17:43:32.692]                             muffled <- TRUE
[17:43:32.692]                             break
[17:43:32.692]                           }
[17:43:32.692]                         }
[17:43:32.692]                       }
[17:43:32.692]                       invisible(muffled)
[17:43:32.692]                     }
[17:43:32.692]                     muffleCondition(cond, pattern = "^muffle")
[17:43:32.692]                   }
[17:43:32.692]                 }
[17:43:32.692]                 else {
[17:43:32.692]                   if (TRUE) {
[17:43:32.692]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:32.692]                     {
[17:43:32.692]                       inherits <- base::inherits
[17:43:32.692]                       invokeRestart <- base::invokeRestart
[17:43:32.692]                       is.null <- base::is.null
[17:43:32.692]                       muffled <- FALSE
[17:43:32.692]                       if (inherits(cond, "message")) {
[17:43:32.692]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:32.692]                         if (muffled) 
[17:43:32.692]                           invokeRestart("muffleMessage")
[17:43:32.692]                       }
[17:43:32.692]                       else if (inherits(cond, "warning")) {
[17:43:32.692]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:32.692]                         if (muffled) 
[17:43:32.692]                           invokeRestart("muffleWarning")
[17:43:32.692]                       }
[17:43:32.692]                       else if (inherits(cond, "condition")) {
[17:43:32.692]                         if (!is.null(pattern)) {
[17:43:32.692]                           computeRestarts <- base::computeRestarts
[17:43:32.692]                           grepl <- base::grepl
[17:43:32.692]                           restarts <- computeRestarts(cond)
[17:43:32.692]                           for (restart in restarts) {
[17:43:32.692]                             name <- restart$name
[17:43:32.692]                             if (is.null(name)) 
[17:43:32.692]                               next
[17:43:32.692]                             if (!grepl(pattern, name)) 
[17:43:32.692]                               next
[17:43:32.692]                             invokeRestart(restart)
[17:43:32.692]                             muffled <- TRUE
[17:43:32.692]                             break
[17:43:32.692]                           }
[17:43:32.692]                         }
[17:43:32.692]                       }
[17:43:32.692]                       invisible(muffled)
[17:43:32.692]                     }
[17:43:32.692]                     muffleCondition(cond, pattern = "^muffle")
[17:43:32.692]                   }
[17:43:32.692]                 }
[17:43:32.692]             }
[17:43:32.692]         }))
[17:43:32.692]     }, error = function(ex) {
[17:43:32.692]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:32.692]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:32.692]                 ...future.rng), started = ...future.startTime, 
[17:43:32.692]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:32.692]             version = "1.8"), class = "FutureResult")
[17:43:32.692]     }, finally = {
[17:43:32.692]         if (!identical(...future.workdir, getwd())) 
[17:43:32.692]             setwd(...future.workdir)
[17:43:32.692]         {
[17:43:32.692]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:32.692]                 ...future.oldOptions$nwarnings <- NULL
[17:43:32.692]             }
[17:43:32.692]             base::options(...future.oldOptions)
[17:43:32.692]             if (.Platform$OS.type == "windows") {
[17:43:32.692]                 old_names <- names(...future.oldEnvVars)
[17:43:32.692]                 envs <- base::Sys.getenv()
[17:43:32.692]                 names <- names(envs)
[17:43:32.692]                 common <- intersect(names, old_names)
[17:43:32.692]                 added <- setdiff(names, old_names)
[17:43:32.692]                 removed <- setdiff(old_names, names)
[17:43:32.692]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:32.692]                   envs[common]]
[17:43:32.692]                 NAMES <- toupper(changed)
[17:43:32.692]                 args <- list()
[17:43:32.692]                 for (kk in seq_along(NAMES)) {
[17:43:32.692]                   name <- changed[[kk]]
[17:43:32.692]                   NAME <- NAMES[[kk]]
[17:43:32.692]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:32.692]                     next
[17:43:32.692]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:32.692]                 }
[17:43:32.692]                 NAMES <- toupper(added)
[17:43:32.692]                 for (kk in seq_along(NAMES)) {
[17:43:32.692]                   name <- added[[kk]]
[17:43:32.692]                   NAME <- NAMES[[kk]]
[17:43:32.692]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:32.692]                     next
[17:43:32.692]                   args[[name]] <- ""
[17:43:32.692]                 }
[17:43:32.692]                 NAMES <- toupper(removed)
[17:43:32.692]                 for (kk in seq_along(NAMES)) {
[17:43:32.692]                   name <- removed[[kk]]
[17:43:32.692]                   NAME <- NAMES[[kk]]
[17:43:32.692]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:32.692]                     next
[17:43:32.692]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:32.692]                 }
[17:43:32.692]                 if (length(args) > 0) 
[17:43:32.692]                   base::do.call(base::Sys.setenv, args = args)
[17:43:32.692]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:32.692]             }
[17:43:32.692]             else {
[17:43:32.692]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:32.692]             }
[17:43:32.692]             {
[17:43:32.692]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:32.692]                   0L) {
[17:43:32.692]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:32.692]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:32.692]                   base::options(opts)
[17:43:32.692]                 }
[17:43:32.692]                 {
[17:43:32.692]                   {
[17:43:32.692]                     NULL
[17:43:32.692]                     RNGkind("Mersenne-Twister")
[17:43:32.692]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:32.692]                       inherits = FALSE)
[17:43:32.692]                   }
[17:43:32.692]                   options(future.plan = NULL)
[17:43:32.692]                   if (is.na(NA_character_)) 
[17:43:32.692]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:32.692]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:32.692]                   future::plan(list(function (..., envir = parent.frame()) 
[17:43:32.692]                   {
[17:43:32.692]                     future <- SequentialFuture(..., envir = envir)
[17:43:32.692]                     if (!future$lazy) 
[17:43:32.692]                       future <- run(future)
[17:43:32.692]                     invisible(future)
[17:43:32.692]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:32.692]                 }
[17:43:32.692]             }
[17:43:32.692]         }
[17:43:32.692]     })
[17:43:32.692]     if (TRUE) {
[17:43:32.692]         base::sink(type = "output", split = FALSE)
[17:43:32.692]         if (TRUE) {
[17:43:32.692]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:32.692]         }
[17:43:32.692]         else {
[17:43:32.692]             ...future.result["stdout"] <- base::list(NULL)
[17:43:32.692]         }
[17:43:32.692]         base::close(...future.stdout)
[17:43:32.692]         ...future.stdout <- NULL
[17:43:32.692]     }
[17:43:32.692]     ...future.result$conditions <- ...future.conditions
[17:43:32.692]     ...future.result$finished <- base::Sys.time()
[17:43:32.692]     ...future.result
[17:43:32.692] }
[17:43:32.694] plan(): Setting new future strategy stack:
[17:43:32.694] List of future strategies:
[17:43:32.694] 1. sequential:
[17:43:32.694]    - args: function (..., envir = parent.frame())
[17:43:32.694]    - tweaked: FALSE
[17:43:32.694]    - call: NULL
[17:43:32.694] plan(): nbrOfWorkers() = 1
[17:43:32.695] plan(): Setting new future strategy stack:
[17:43:32.695] List of future strategies:
[17:43:32.695] 1. sequential:
[17:43:32.695]    - args: function (..., envir = parent.frame())
[17:43:32.695]    - tweaked: FALSE
[17:43:32.695]    - call: plan(strategy)
[17:43:32.696] plan(): nbrOfWorkers() = 1
[17:43:32.696] SequentialFuture started (and completed)
[17:43:32.696] - Launch lazy future ... done
[17:43:32.696] run() for ‘SequentialFuture’ ... done
[17:43:32.696] resolved() for ‘SequentialFuture’ ...
[17:43:32.696] - state: ‘finished’
[17:43:32.696] - run: TRUE
[17:43:32.696] - result: ‘FutureResult’
[17:43:32.696] resolved() for ‘SequentialFuture’ ... done
[17:43:32.697] Future #2
[17:43:32.697]  length: 1 (resolved future 2)
[17:43:32.697]  length: 0 (resolved future 3)
[17:43:32.697] resolve() on list ... DONE
[17:43:32.697] resolved() for ‘SequentialFuture’ ...
[17:43:32.697] - state: ‘finished’
[17:43:32.697] - run: TRUE
[17:43:32.697] - result: ‘FutureResult’
[17:43:32.697] resolved() for ‘SequentialFuture’ ... done
[17:43:32.697] resolved() for ‘SequentialFuture’ ...
[17:43:32.698] - state: ‘finished’
[17:43:32.698] - run: TRUE
[17:43:32.698] - result: ‘FutureResult’
[17:43:32.698] resolved() for ‘SequentialFuture’ ... done
[17:43:32.698] getGlobalsAndPackages() ...
[17:43:32.698] Searching for globals...
[17:43:32.698] 
[17:43:32.698] Searching for globals ... DONE
[17:43:32.699] - globals: [0] <none>
[17:43:32.699] getGlobalsAndPackages() ... DONE
[17:43:32.699] run() for ‘Future’ ...
[17:43:32.699] - state: ‘created’
[17:43:32.699] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:32.699] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:32.699] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:32.700]   - Field: ‘label’
[17:43:32.700]   - Field: ‘local’
[17:43:32.700]   - Field: ‘owner’
[17:43:32.700]   - Field: ‘envir’
[17:43:32.700]   - Field: ‘packages’
[17:43:32.700]   - Field: ‘gc’
[17:43:32.700]   - Field: ‘conditions’
[17:43:32.700]   - Field: ‘expr’
[17:43:32.700]   - Field: ‘uuid’
[17:43:32.700]   - Field: ‘seed’
[17:43:32.701]   - Field: ‘version’
[17:43:32.701]   - Field: ‘result’
[17:43:32.701]   - Field: ‘asynchronous’
[17:43:32.701]   - Field: ‘calls’
[17:43:32.701]   - Field: ‘globals’
[17:43:32.701]   - Field: ‘stdout’
[17:43:32.701]   - Field: ‘earlySignal’
[17:43:32.701]   - Field: ‘lazy’
[17:43:32.701]   - Field: ‘state’
[17:43:32.701] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:32.702] - Launch lazy future ...
[17:43:32.702] Packages needed by the future expression (n = 0): <none>
[17:43:32.702] Packages needed by future strategies (n = 0): <none>
[17:43:32.702] {
[17:43:32.702]     {
[17:43:32.702]         {
[17:43:32.702]             ...future.startTime <- base::Sys.time()
[17:43:32.702]             {
[17:43:32.702]                 {
[17:43:32.702]                   {
[17:43:32.702]                     base::local({
[17:43:32.702]                       has_future <- base::requireNamespace("future", 
[17:43:32.702]                         quietly = TRUE)
[17:43:32.702]                       if (has_future) {
[17:43:32.702]                         ns <- base::getNamespace("future")
[17:43:32.702]                         version <- ns[[".package"]][["version"]]
[17:43:32.702]                         if (is.null(version)) 
[17:43:32.702]                           version <- utils::packageVersion("future")
[17:43:32.702]                       }
[17:43:32.702]                       else {
[17:43:32.702]                         version <- NULL
[17:43:32.702]                       }
[17:43:32.702]                       if (!has_future || version < "1.8.0") {
[17:43:32.702]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:32.702]                           "", base::R.version$version.string), 
[17:43:32.702]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:32.702]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:32.702]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:32.702]                             "release", "version")], collapse = " "), 
[17:43:32.702]                           hostname = base::Sys.info()[["nodename"]])
[17:43:32.702]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:32.702]                           info)
[17:43:32.702]                         info <- base::paste(info, collapse = "; ")
[17:43:32.702]                         if (!has_future) {
[17:43:32.702]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:32.702]                             info)
[17:43:32.702]                         }
[17:43:32.702]                         else {
[17:43:32.702]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:32.702]                             info, version)
[17:43:32.702]                         }
[17:43:32.702]                         base::stop(msg)
[17:43:32.702]                       }
[17:43:32.702]                     })
[17:43:32.702]                   }
[17:43:32.702]                   options(future.plan = NULL)
[17:43:32.702]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:32.702]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:32.702]                 }
[17:43:32.702]                 ...future.workdir <- getwd()
[17:43:32.702]             }
[17:43:32.702]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:32.702]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:32.702]         }
[17:43:32.702]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:32.702]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:32.702]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:32.702]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:32.702]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:32.702]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:32.702]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:32.702]             base::names(...future.oldOptions))
[17:43:32.702]     }
[17:43:32.702]     if (FALSE) {
[17:43:32.702]     }
[17:43:32.702]     else {
[17:43:32.702]         if (TRUE) {
[17:43:32.702]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:32.702]                 open = "w")
[17:43:32.702]         }
[17:43:32.702]         else {
[17:43:32.702]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:32.702]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:32.702]         }
[17:43:32.702]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:32.702]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:32.702]             base::sink(type = "output", split = FALSE)
[17:43:32.702]             base::close(...future.stdout)
[17:43:32.702]         }, add = TRUE)
[17:43:32.702]     }
[17:43:32.702]     ...future.frame <- base::sys.nframe()
[17:43:32.702]     ...future.conditions <- base::list()
[17:43:32.702]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:32.702]     if (FALSE) {
[17:43:32.702]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:32.702]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:32.702]     }
[17:43:32.702]     ...future.result <- base::tryCatch({
[17:43:32.702]         base::withCallingHandlers({
[17:43:32.702]             ...future.value <- base::withVisible(base::local(1))
[17:43:32.702]             future::FutureResult(value = ...future.value$value, 
[17:43:32.702]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:32.702]                   ...future.rng), globalenv = if (FALSE) 
[17:43:32.702]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:32.702]                     ...future.globalenv.names))
[17:43:32.702]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:32.702]         }, condition = base::local({
[17:43:32.702]             c <- base::c
[17:43:32.702]             inherits <- base::inherits
[17:43:32.702]             invokeRestart <- base::invokeRestart
[17:43:32.702]             length <- base::length
[17:43:32.702]             list <- base::list
[17:43:32.702]             seq.int <- base::seq.int
[17:43:32.702]             signalCondition <- base::signalCondition
[17:43:32.702]             sys.calls <- base::sys.calls
[17:43:32.702]             `[[` <- base::`[[`
[17:43:32.702]             `+` <- base::`+`
[17:43:32.702]             `<<-` <- base::`<<-`
[17:43:32.702]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:32.702]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:32.702]                   3L)]
[17:43:32.702]             }
[17:43:32.702]             function(cond) {
[17:43:32.702]                 is_error <- inherits(cond, "error")
[17:43:32.702]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:32.702]                   NULL)
[17:43:32.702]                 if (is_error) {
[17:43:32.702]                   sessionInformation <- function() {
[17:43:32.702]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:32.702]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:32.702]                       search = base::search(), system = base::Sys.info())
[17:43:32.702]                   }
[17:43:32.702]                   ...future.conditions[[length(...future.conditions) + 
[17:43:32.702]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:32.702]                     cond$call), session = sessionInformation(), 
[17:43:32.702]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:32.702]                   signalCondition(cond)
[17:43:32.702]                 }
[17:43:32.702]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:32.702]                 "immediateCondition"))) {
[17:43:32.702]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:32.702]                   ...future.conditions[[length(...future.conditions) + 
[17:43:32.702]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:32.702]                   if (TRUE && !signal) {
[17:43:32.702]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:32.702]                     {
[17:43:32.702]                       inherits <- base::inherits
[17:43:32.702]                       invokeRestart <- base::invokeRestart
[17:43:32.702]                       is.null <- base::is.null
[17:43:32.702]                       muffled <- FALSE
[17:43:32.702]                       if (inherits(cond, "message")) {
[17:43:32.702]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:32.702]                         if (muffled) 
[17:43:32.702]                           invokeRestart("muffleMessage")
[17:43:32.702]                       }
[17:43:32.702]                       else if (inherits(cond, "warning")) {
[17:43:32.702]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:32.702]                         if (muffled) 
[17:43:32.702]                           invokeRestart("muffleWarning")
[17:43:32.702]                       }
[17:43:32.702]                       else if (inherits(cond, "condition")) {
[17:43:32.702]                         if (!is.null(pattern)) {
[17:43:32.702]                           computeRestarts <- base::computeRestarts
[17:43:32.702]                           grepl <- base::grepl
[17:43:32.702]                           restarts <- computeRestarts(cond)
[17:43:32.702]                           for (restart in restarts) {
[17:43:32.702]                             name <- restart$name
[17:43:32.702]                             if (is.null(name)) 
[17:43:32.702]                               next
[17:43:32.702]                             if (!grepl(pattern, name)) 
[17:43:32.702]                               next
[17:43:32.702]                             invokeRestart(restart)
[17:43:32.702]                             muffled <- TRUE
[17:43:32.702]                             break
[17:43:32.702]                           }
[17:43:32.702]                         }
[17:43:32.702]                       }
[17:43:32.702]                       invisible(muffled)
[17:43:32.702]                     }
[17:43:32.702]                     muffleCondition(cond, pattern = "^muffle")
[17:43:32.702]                   }
[17:43:32.702]                 }
[17:43:32.702]                 else {
[17:43:32.702]                   if (TRUE) {
[17:43:32.702]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:32.702]                     {
[17:43:32.702]                       inherits <- base::inherits
[17:43:32.702]                       invokeRestart <- base::invokeRestart
[17:43:32.702]                       is.null <- base::is.null
[17:43:32.702]                       muffled <- FALSE
[17:43:32.702]                       if (inherits(cond, "message")) {
[17:43:32.702]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:32.702]                         if (muffled) 
[17:43:32.702]                           invokeRestart("muffleMessage")
[17:43:32.702]                       }
[17:43:32.702]                       else if (inherits(cond, "warning")) {
[17:43:32.702]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:32.702]                         if (muffled) 
[17:43:32.702]                           invokeRestart("muffleWarning")
[17:43:32.702]                       }
[17:43:32.702]                       else if (inherits(cond, "condition")) {
[17:43:32.702]                         if (!is.null(pattern)) {
[17:43:32.702]                           computeRestarts <- base::computeRestarts
[17:43:32.702]                           grepl <- base::grepl
[17:43:32.702]                           restarts <- computeRestarts(cond)
[17:43:32.702]                           for (restart in restarts) {
[17:43:32.702]                             name <- restart$name
[17:43:32.702]                             if (is.null(name)) 
[17:43:32.702]                               next
[17:43:32.702]                             if (!grepl(pattern, name)) 
[17:43:32.702]                               next
[17:43:32.702]                             invokeRestart(restart)
[17:43:32.702]                             muffled <- TRUE
[17:43:32.702]                             break
[17:43:32.702]                           }
[17:43:32.702]                         }
[17:43:32.702]                       }
[17:43:32.702]                       invisible(muffled)
[17:43:32.702]                     }
[17:43:32.702]                     muffleCondition(cond, pattern = "^muffle")
[17:43:32.702]                   }
[17:43:32.702]                 }
[17:43:32.702]             }
[17:43:32.702]         }))
[17:43:32.702]     }, error = function(ex) {
[17:43:32.702]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:32.702]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:32.702]                 ...future.rng), started = ...future.startTime, 
[17:43:32.702]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:32.702]             version = "1.8"), class = "FutureResult")
[17:43:32.702]     }, finally = {
[17:43:32.702]         if (!identical(...future.workdir, getwd())) 
[17:43:32.702]             setwd(...future.workdir)
[17:43:32.702]         {
[17:43:32.702]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:32.702]                 ...future.oldOptions$nwarnings <- NULL
[17:43:32.702]             }
[17:43:32.702]             base::options(...future.oldOptions)
[17:43:32.702]             if (.Platform$OS.type == "windows") {
[17:43:32.702]                 old_names <- names(...future.oldEnvVars)
[17:43:32.702]                 envs <- base::Sys.getenv()
[17:43:32.702]                 names <- names(envs)
[17:43:32.702]                 common <- intersect(names, old_names)
[17:43:32.702]                 added <- setdiff(names, old_names)
[17:43:32.702]                 removed <- setdiff(old_names, names)
[17:43:32.702]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:32.702]                   envs[common]]
[17:43:32.702]                 NAMES <- toupper(changed)
[17:43:32.702]                 args <- list()
[17:43:32.702]                 for (kk in seq_along(NAMES)) {
[17:43:32.702]                   name <- changed[[kk]]
[17:43:32.702]                   NAME <- NAMES[[kk]]
[17:43:32.702]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:32.702]                     next
[17:43:32.702]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:32.702]                 }
[17:43:32.702]                 NAMES <- toupper(added)
[17:43:32.702]                 for (kk in seq_along(NAMES)) {
[17:43:32.702]                   name <- added[[kk]]
[17:43:32.702]                   NAME <- NAMES[[kk]]
[17:43:32.702]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:32.702]                     next
[17:43:32.702]                   args[[name]] <- ""
[17:43:32.702]                 }
[17:43:32.702]                 NAMES <- toupper(removed)
[17:43:32.702]                 for (kk in seq_along(NAMES)) {
[17:43:32.702]                   name <- removed[[kk]]
[17:43:32.702]                   NAME <- NAMES[[kk]]
[17:43:32.702]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:32.702]                     next
[17:43:32.702]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:32.702]                 }
[17:43:32.702]                 if (length(args) > 0) 
[17:43:32.702]                   base::do.call(base::Sys.setenv, args = args)
[17:43:32.702]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:32.702]             }
[17:43:32.702]             else {
[17:43:32.702]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:32.702]             }
[17:43:32.702]             {
[17:43:32.702]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:32.702]                   0L) {
[17:43:32.702]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:32.702]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:32.702]                   base::options(opts)
[17:43:32.702]                 }
[17:43:32.702]                 {
[17:43:32.702]                   {
[17:43:32.702]                     NULL
[17:43:32.702]                     RNGkind("Mersenne-Twister")
[17:43:32.702]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:32.702]                       inherits = FALSE)
[17:43:32.702]                   }
[17:43:32.702]                   options(future.plan = NULL)
[17:43:32.702]                   if (is.na(NA_character_)) 
[17:43:32.702]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:32.702]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:32.702]                   future::plan(list(function (..., envir = parent.frame()) 
[17:43:32.702]                   {
[17:43:32.702]                     future <- SequentialFuture(..., envir = envir)
[17:43:32.702]                     if (!future$lazy) 
[17:43:32.702]                       future <- run(future)
[17:43:32.702]                     invisible(future)
[17:43:32.702]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:32.702]                 }
[17:43:32.702]             }
[17:43:32.702]         }
[17:43:32.702]     })
[17:43:32.702]     if (TRUE) {
[17:43:32.702]         base::sink(type = "output", split = FALSE)
[17:43:32.702]         if (TRUE) {
[17:43:32.702]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:32.702]         }
[17:43:32.702]         else {
[17:43:32.702]             ...future.result["stdout"] <- base::list(NULL)
[17:43:32.702]         }
[17:43:32.702]         base::close(...future.stdout)
[17:43:32.702]         ...future.stdout <- NULL
[17:43:32.702]     }
[17:43:32.702]     ...future.result$conditions <- ...future.conditions
[17:43:32.702]     ...future.result$finished <- base::Sys.time()
[17:43:32.702]     ...future.result
[17:43:32.702] }
[17:43:32.704] plan(): Setting new future strategy stack:
[17:43:32.704] List of future strategies:
[17:43:32.704] 1. sequential:
[17:43:32.704]    - args: function (..., envir = parent.frame())
[17:43:32.704]    - tweaked: FALSE
[17:43:32.704]    - call: NULL
[17:43:32.705] plan(): nbrOfWorkers() = 1
[17:43:32.705] plan(): Setting new future strategy stack:
[17:43:32.706] List of future strategies:
[17:43:32.706] 1. sequential:
[17:43:32.706]    - args: function (..., envir = parent.frame())
[17:43:32.706]    - tweaked: FALSE
[17:43:32.706]    - call: plan(strategy)
[17:43:32.706] plan(): nbrOfWorkers() = 1
[17:43:32.706] SequentialFuture started (and completed)
[17:43:32.706] - Launch lazy future ... done
[17:43:32.706] run() for ‘SequentialFuture’ ... done
[17:43:32.706] getGlobalsAndPackages() ...
[17:43:32.707] Searching for globals...
[17:43:32.711] - globals found: [2] ‘{’, ‘Sys.sleep’
[17:43:32.712] Searching for globals ... DONE
[17:43:32.712] Resolving globals: FALSE
[17:43:32.712] 
[17:43:32.712] 
[17:43:32.712] getGlobalsAndPackages() ... DONE
[17:43:32.713] run() for ‘Future’ ...
[17:43:32.713] - state: ‘created’
[17:43:32.713] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:32.713] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:32.713] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:32.713]   - Field: ‘label’
[17:43:32.714]   - Field: ‘local’
[17:43:32.714]   - Field: ‘owner’
[17:43:32.714]   - Field: ‘envir’
[17:43:32.714]   - Field: ‘packages’
[17:43:32.714]   - Field: ‘gc’
[17:43:32.714]   - Field: ‘conditions’
[17:43:32.714]   - Field: ‘expr’
[17:43:32.714]   - Field: ‘uuid’
[17:43:32.714]   - Field: ‘seed’
[17:43:32.717]   - Field: ‘version’
[17:43:32.717]   - Field: ‘result’
[17:43:32.717]   - Field: ‘asynchronous’
[17:43:32.717]   - Field: ‘calls’
[17:43:32.717]   - Field: ‘globals’
[17:43:32.717]   - Field: ‘stdout’
[17:43:32.717]   - Field: ‘earlySignal’
[17:43:32.717]   - Field: ‘lazy’
[17:43:32.717]   - Field: ‘state’
[17:43:32.717] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:32.717] - Launch lazy future ...
[17:43:32.718] Packages needed by the future expression (n = 0): <none>
[17:43:32.718] Packages needed by future strategies (n = 0): <none>
[17:43:32.718] {
[17:43:32.718]     {
[17:43:32.718]         {
[17:43:32.718]             ...future.startTime <- base::Sys.time()
[17:43:32.718]             {
[17:43:32.718]                 {
[17:43:32.718]                   {
[17:43:32.718]                     base::local({
[17:43:32.718]                       has_future <- base::requireNamespace("future", 
[17:43:32.718]                         quietly = TRUE)
[17:43:32.718]                       if (has_future) {
[17:43:32.718]                         ns <- base::getNamespace("future")
[17:43:32.718]                         version <- ns[[".package"]][["version"]]
[17:43:32.718]                         if (is.null(version)) 
[17:43:32.718]                           version <- utils::packageVersion("future")
[17:43:32.718]                       }
[17:43:32.718]                       else {
[17:43:32.718]                         version <- NULL
[17:43:32.718]                       }
[17:43:32.718]                       if (!has_future || version < "1.8.0") {
[17:43:32.718]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:32.718]                           "", base::R.version$version.string), 
[17:43:32.718]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:32.718]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:32.718]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:32.718]                             "release", "version")], collapse = " "), 
[17:43:32.718]                           hostname = base::Sys.info()[["nodename"]])
[17:43:32.718]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:32.718]                           info)
[17:43:32.718]                         info <- base::paste(info, collapse = "; ")
[17:43:32.718]                         if (!has_future) {
[17:43:32.718]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:32.718]                             info)
[17:43:32.718]                         }
[17:43:32.718]                         else {
[17:43:32.718]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:32.718]                             info, version)
[17:43:32.718]                         }
[17:43:32.718]                         base::stop(msg)
[17:43:32.718]                       }
[17:43:32.718]                     })
[17:43:32.718]                   }
[17:43:32.718]                   options(future.plan = NULL)
[17:43:32.718]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:32.718]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:32.718]                 }
[17:43:32.718]                 ...future.workdir <- getwd()
[17:43:32.718]             }
[17:43:32.718]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:32.718]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:32.718]         }
[17:43:32.718]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:32.718]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:32.718]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:32.718]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:32.718]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:32.718]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:32.718]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:32.718]             base::names(...future.oldOptions))
[17:43:32.718]     }
[17:43:32.718]     if (FALSE) {
[17:43:32.718]     }
[17:43:32.718]     else {
[17:43:32.718]         if (TRUE) {
[17:43:32.718]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:32.718]                 open = "w")
[17:43:32.718]         }
[17:43:32.718]         else {
[17:43:32.718]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:32.718]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:32.718]         }
[17:43:32.718]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:32.718]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:32.718]             base::sink(type = "output", split = FALSE)
[17:43:32.718]             base::close(...future.stdout)
[17:43:32.718]         }, add = TRUE)
[17:43:32.718]     }
[17:43:32.718]     ...future.frame <- base::sys.nframe()
[17:43:32.718]     ...future.conditions <- base::list()
[17:43:32.718]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:32.718]     if (FALSE) {
[17:43:32.718]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:32.718]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:32.718]     }
[17:43:32.718]     ...future.result <- base::tryCatch({
[17:43:32.718]         base::withCallingHandlers({
[17:43:32.718]             ...future.value <- base::withVisible(base::local({
[17:43:32.718]                 Sys.sleep(0.5)
[17:43:32.718]                 2
[17:43:32.718]             }))
[17:43:32.718]             future::FutureResult(value = ...future.value$value, 
[17:43:32.718]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:32.718]                   ...future.rng), globalenv = if (FALSE) 
[17:43:32.718]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:32.718]                     ...future.globalenv.names))
[17:43:32.718]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:32.718]         }, condition = base::local({
[17:43:32.718]             c <- base::c
[17:43:32.718]             inherits <- base::inherits
[17:43:32.718]             invokeRestart <- base::invokeRestart
[17:43:32.718]             length <- base::length
[17:43:32.718]             list <- base::list
[17:43:32.718]             seq.int <- base::seq.int
[17:43:32.718]             signalCondition <- base::signalCondition
[17:43:32.718]             sys.calls <- base::sys.calls
[17:43:32.718]             `[[` <- base::`[[`
[17:43:32.718]             `+` <- base::`+`
[17:43:32.718]             `<<-` <- base::`<<-`
[17:43:32.718]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:32.718]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:32.718]                   3L)]
[17:43:32.718]             }
[17:43:32.718]             function(cond) {
[17:43:32.718]                 is_error <- inherits(cond, "error")
[17:43:32.718]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:32.718]                   NULL)
[17:43:32.718]                 if (is_error) {
[17:43:32.718]                   sessionInformation <- function() {
[17:43:32.718]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:32.718]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:32.718]                       search = base::search(), system = base::Sys.info())
[17:43:32.718]                   }
[17:43:32.718]                   ...future.conditions[[length(...future.conditions) + 
[17:43:32.718]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:32.718]                     cond$call), session = sessionInformation(), 
[17:43:32.718]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:32.718]                   signalCondition(cond)
[17:43:32.718]                 }
[17:43:32.718]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:32.718]                 "immediateCondition"))) {
[17:43:32.718]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:32.718]                   ...future.conditions[[length(...future.conditions) + 
[17:43:32.718]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:32.718]                   if (TRUE && !signal) {
[17:43:32.718]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:32.718]                     {
[17:43:32.718]                       inherits <- base::inherits
[17:43:32.718]                       invokeRestart <- base::invokeRestart
[17:43:32.718]                       is.null <- base::is.null
[17:43:32.718]                       muffled <- FALSE
[17:43:32.718]                       if (inherits(cond, "message")) {
[17:43:32.718]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:32.718]                         if (muffled) 
[17:43:32.718]                           invokeRestart("muffleMessage")
[17:43:32.718]                       }
[17:43:32.718]                       else if (inherits(cond, "warning")) {
[17:43:32.718]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:32.718]                         if (muffled) 
[17:43:32.718]                           invokeRestart("muffleWarning")
[17:43:32.718]                       }
[17:43:32.718]                       else if (inherits(cond, "condition")) {
[17:43:32.718]                         if (!is.null(pattern)) {
[17:43:32.718]                           computeRestarts <- base::computeRestarts
[17:43:32.718]                           grepl <- base::grepl
[17:43:32.718]                           restarts <- computeRestarts(cond)
[17:43:32.718]                           for (restart in restarts) {
[17:43:32.718]                             name <- restart$name
[17:43:32.718]                             if (is.null(name)) 
[17:43:32.718]                               next
[17:43:32.718]                             if (!grepl(pattern, name)) 
[17:43:32.718]                               next
[17:43:32.718]                             invokeRestart(restart)
[17:43:32.718]                             muffled <- TRUE
[17:43:32.718]                             break
[17:43:32.718]                           }
[17:43:32.718]                         }
[17:43:32.718]                       }
[17:43:32.718]                       invisible(muffled)
[17:43:32.718]                     }
[17:43:32.718]                     muffleCondition(cond, pattern = "^muffle")
[17:43:32.718]                   }
[17:43:32.718]                 }
[17:43:32.718]                 else {
[17:43:32.718]                   if (TRUE) {
[17:43:32.718]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:32.718]                     {
[17:43:32.718]                       inherits <- base::inherits
[17:43:32.718]                       invokeRestart <- base::invokeRestart
[17:43:32.718]                       is.null <- base::is.null
[17:43:32.718]                       muffled <- FALSE
[17:43:32.718]                       if (inherits(cond, "message")) {
[17:43:32.718]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:32.718]                         if (muffled) 
[17:43:32.718]                           invokeRestart("muffleMessage")
[17:43:32.718]                       }
[17:43:32.718]                       else if (inherits(cond, "warning")) {
[17:43:32.718]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:32.718]                         if (muffled) 
[17:43:32.718]                           invokeRestart("muffleWarning")
[17:43:32.718]                       }
[17:43:32.718]                       else if (inherits(cond, "condition")) {
[17:43:32.718]                         if (!is.null(pattern)) {
[17:43:32.718]                           computeRestarts <- base::computeRestarts
[17:43:32.718]                           grepl <- base::grepl
[17:43:32.718]                           restarts <- computeRestarts(cond)
[17:43:32.718]                           for (restart in restarts) {
[17:43:32.718]                             name <- restart$name
[17:43:32.718]                             if (is.null(name)) 
[17:43:32.718]                               next
[17:43:32.718]                             if (!grepl(pattern, name)) 
[17:43:32.718]                               next
[17:43:32.718]                             invokeRestart(restart)
[17:43:32.718]                             muffled <- TRUE
[17:43:32.718]                             break
[17:43:32.718]                           }
[17:43:32.718]                         }
[17:43:32.718]                       }
[17:43:32.718]                       invisible(muffled)
[17:43:32.718]                     }
[17:43:32.718]                     muffleCondition(cond, pattern = "^muffle")
[17:43:32.718]                   }
[17:43:32.718]                 }
[17:43:32.718]             }
[17:43:32.718]         }))
[17:43:32.718]     }, error = function(ex) {
[17:43:32.718]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:32.718]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:32.718]                 ...future.rng), started = ...future.startTime, 
[17:43:32.718]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:32.718]             version = "1.8"), class = "FutureResult")
[17:43:32.718]     }, finally = {
[17:43:32.718]         if (!identical(...future.workdir, getwd())) 
[17:43:32.718]             setwd(...future.workdir)
[17:43:32.718]         {
[17:43:32.718]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:32.718]                 ...future.oldOptions$nwarnings <- NULL
[17:43:32.718]             }
[17:43:32.718]             base::options(...future.oldOptions)
[17:43:32.718]             if (.Platform$OS.type == "windows") {
[17:43:32.718]                 old_names <- names(...future.oldEnvVars)
[17:43:32.718]                 envs <- base::Sys.getenv()
[17:43:32.718]                 names <- names(envs)
[17:43:32.718]                 common <- intersect(names, old_names)
[17:43:32.718]                 added <- setdiff(names, old_names)
[17:43:32.718]                 removed <- setdiff(old_names, names)
[17:43:32.718]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:32.718]                   envs[common]]
[17:43:32.718]                 NAMES <- toupper(changed)
[17:43:32.718]                 args <- list()
[17:43:32.718]                 for (kk in seq_along(NAMES)) {
[17:43:32.718]                   name <- changed[[kk]]
[17:43:32.718]                   NAME <- NAMES[[kk]]
[17:43:32.718]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:32.718]                     next
[17:43:32.718]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:32.718]                 }
[17:43:32.718]                 NAMES <- toupper(added)
[17:43:32.718]                 for (kk in seq_along(NAMES)) {
[17:43:32.718]                   name <- added[[kk]]
[17:43:32.718]                   NAME <- NAMES[[kk]]
[17:43:32.718]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:32.718]                     next
[17:43:32.718]                   args[[name]] <- ""
[17:43:32.718]                 }
[17:43:32.718]                 NAMES <- toupper(removed)
[17:43:32.718]                 for (kk in seq_along(NAMES)) {
[17:43:32.718]                   name <- removed[[kk]]
[17:43:32.718]                   NAME <- NAMES[[kk]]
[17:43:32.718]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:32.718]                     next
[17:43:32.718]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:32.718]                 }
[17:43:32.718]                 if (length(args) > 0) 
[17:43:32.718]                   base::do.call(base::Sys.setenv, args = args)
[17:43:32.718]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:32.718]             }
[17:43:32.718]             else {
[17:43:32.718]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:32.718]             }
[17:43:32.718]             {
[17:43:32.718]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:32.718]                   0L) {
[17:43:32.718]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:32.718]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:32.718]                   base::options(opts)
[17:43:32.718]                 }
[17:43:32.718]                 {
[17:43:32.718]                   {
[17:43:32.718]                     NULL
[17:43:32.718]                     RNGkind("Mersenne-Twister")
[17:43:32.718]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:32.718]                       inherits = FALSE)
[17:43:32.718]                   }
[17:43:32.718]                   options(future.plan = NULL)
[17:43:32.718]                   if (is.na(NA_character_)) 
[17:43:32.718]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:32.718]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:32.718]                   future::plan(list(function (..., envir = parent.frame()) 
[17:43:32.718]                   {
[17:43:32.718]                     future <- SequentialFuture(..., envir = envir)
[17:43:32.718]                     if (!future$lazy) 
[17:43:32.718]                       future <- run(future)
[17:43:32.718]                     invisible(future)
[17:43:32.718]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:32.718]                 }
[17:43:32.718]             }
[17:43:32.718]         }
[17:43:32.718]     })
[17:43:32.718]     if (TRUE) {
[17:43:32.718]         base::sink(type = "output", split = FALSE)
[17:43:32.718]         if (TRUE) {
[17:43:32.718]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:32.718]         }
[17:43:32.718]         else {
[17:43:32.718]             ...future.result["stdout"] <- base::list(NULL)
[17:43:32.718]         }
[17:43:32.718]         base::close(...future.stdout)
[17:43:32.718]         ...future.stdout <- NULL
[17:43:32.718]     }
[17:43:32.718]     ...future.result$conditions <- ...future.conditions
[17:43:32.718]     ...future.result$finished <- base::Sys.time()
[17:43:32.718]     ...future.result
[17:43:32.718] }
[17:43:32.720] plan(): Setting new future strategy stack:
[17:43:32.720] List of future strategies:
[17:43:32.720] 1. sequential:
[17:43:32.720]    - args: function (..., envir = parent.frame())
[17:43:32.720]    - tweaked: FALSE
[17:43:32.720]    - call: NULL
[17:43:32.721] plan(): nbrOfWorkers() = 1
[17:43:33.222] plan(): Setting new future strategy stack:
[17:43:33.222] List of future strategies:
[17:43:33.222] 1. sequential:
[17:43:33.222]    - args: function (..., envir = parent.frame())
[17:43:33.222]    - tweaked: FALSE
[17:43:33.222]    - call: plan(strategy)
[17:43:33.223] plan(): nbrOfWorkers() = 1
[17:43:33.223] SequentialFuture started (and completed)
[17:43:33.223] - Launch lazy future ... done
[17:43:33.223] run() for ‘SequentialFuture’ ... done
[17:43:33.224] resolve() on list ...
[17:43:33.224]  recursive: 0
[17:43:33.224]  length: 1
[17:43:33.224] 
[17:43:33.224] resolved() for ‘SequentialFuture’ ...
[17:43:33.224] - state: ‘finished’
[17:43:33.224] - run: TRUE
[17:43:33.225] - result: ‘FutureResult’
[17:43:33.225] resolved() for ‘SequentialFuture’ ... done
[17:43:33.225] Future #1
[17:43:33.225]  length: 0 (resolved future 1)
[17:43:33.225] resolve() on list ... DONE
[17:43:33.225] resolved() for ‘SequentialFuture’ ...
[17:43:33.225] - state: ‘finished’
[17:43:33.225] - run: TRUE
[17:43:33.225] - result: ‘FutureResult’
[17:43:33.225] resolved() for ‘SequentialFuture’ ... done
[17:43:33.226] resolve() on list ...
[17:43:33.226]  recursive: 0
[17:43:33.226]  length: 1
[17:43:33.226] 
[17:43:33.226] resolved() for ‘SequentialFuture’ ...
[17:43:33.226] - state: ‘finished’
[17:43:33.226] - run: TRUE
[17:43:33.226] - result: ‘FutureResult’
[17:43:33.226] resolved() for ‘SequentialFuture’ ... done
[17:43:33.226] Future #1
[17:43:33.227]  length: 0 (resolved future 1)
[17:43:33.227] resolve() on list ... DONE
[17:43:33.227] resolved() for ‘SequentialFuture’ ...
[17:43:33.227] - state: ‘finished’
[17:43:33.227] - run: TRUE
[17:43:33.227] - result: ‘FutureResult’
[17:43:33.227] resolved() for ‘SequentialFuture’ ... done
[17:43:33.227] resolve() on list ...
[17:43:33.227]  recursive: 0
[17:43:33.227]  length: 1
[17:43:33.228] 
[17:43:33.228]  length: 0 (resolved future 1)
[17:43:33.228] resolve() on list ... DONE
[17:43:33.228] resolve() on list ...
[17:43:33.228]  recursive: 0
[17:43:33.228]  length: 4
[17:43:33.228] 
[17:43:33.228] resolved() for ‘SequentialFuture’ ...
[17:43:33.228] - state: ‘finished’
[17:43:33.228] - run: TRUE
[17:43:33.229] - result: ‘FutureResult’
[17:43:33.229] resolved() for ‘SequentialFuture’ ... done
[17:43:33.229] Future #1
[17:43:33.229]  length: 3 (resolved future 1)
[17:43:33.229] resolved() for ‘SequentialFuture’ ...
[17:43:33.229] - state: ‘finished’
[17:43:33.229] - run: TRUE
[17:43:33.229] - result: ‘FutureResult’
[17:43:33.229] resolved() for ‘SequentialFuture’ ... done
[17:43:33.229] Future #2
[17:43:33.230]  length: 2 (resolved future 2)
[17:43:33.230]  length: 1 (resolved future 3)
[17:43:33.230]  length: 0 (resolved future 4)
[17:43:33.230] resolve() on list ... DONE
[17:43:33.230] resolve() on list ...
[17:43:33.230]  recursive: 0
[17:43:33.230]  length: 4
[17:43:33.230] 
[17:43:33.230] resolved() for ‘SequentialFuture’ ...
[17:43:33.230] - state: ‘finished’
[17:43:33.231] - run: TRUE
[17:43:33.231] - result: ‘FutureResult’
[17:43:33.231] resolved() for ‘SequentialFuture’ ... done
[17:43:33.231] Future #1
[17:43:33.231]  length: 3 (resolved future 1)
[17:43:33.231] resolved() for ‘SequentialFuture’ ...
[17:43:33.231] - state: ‘finished’
[17:43:33.231] - run: TRUE
[17:43:33.231] - result: ‘FutureResult’
[17:43:33.231] resolved() for ‘SequentialFuture’ ... done
[17:43:33.231] Future #2
[17:43:33.232]  length: 2 (resolved future 2)
[17:43:33.232]  length: 1 (resolved future 3)
[17:43:33.232]  length: 0 (resolved future 4)
[17:43:33.232] resolve() on list ... DONE
[17:43:33.232] resolve() on list ...
[17:43:33.232]  recursive: 0
[17:43:33.232]  length: 1
[17:43:33.232] 
[17:43:33.233]  length: 0 (resolved future 1)
[17:43:33.233] resolve() on list ... DONE
[17:43:33.233] getGlobalsAndPackages() ...
[17:43:33.233] Searching for globals...
[17:43:33.234] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:43:33.234] Searching for globals ... DONE
[17:43:33.234] Resolving globals: FALSE
[17:43:33.235] The total size of the 1 globals is 56 bytes (56 bytes)
[17:43:33.235] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:43:33.236] - globals: [1] ‘kk’
[17:43:33.236] 
[17:43:33.236] getGlobalsAndPackages() ... DONE
[17:43:33.236] run() for ‘Future’ ...
[17:43:33.236] - state: ‘created’
[17:43:33.236] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:33.237] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:33.237] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:33.237]   - Field: ‘label’
[17:43:33.237]   - Field: ‘local’
[17:43:33.237]   - Field: ‘owner’
[17:43:33.237]   - Field: ‘envir’
[17:43:33.237]   - Field: ‘packages’
[17:43:33.237]   - Field: ‘gc’
[17:43:33.237]   - Field: ‘conditions’
[17:43:33.237]   - Field: ‘expr’
[17:43:33.238]   - Field: ‘uuid’
[17:43:33.238]   - Field: ‘seed’
[17:43:33.238]   - Field: ‘version’
[17:43:33.238]   - Field: ‘result’
[17:43:33.238]   - Field: ‘asynchronous’
[17:43:33.238]   - Field: ‘calls’
[17:43:33.238]   - Field: ‘globals’
[17:43:33.238]   - Field: ‘stdout’
[17:43:33.238]   - Field: ‘earlySignal’
[17:43:33.238]   - Field: ‘lazy’
[17:43:33.238]   - Field: ‘state’
[17:43:33.239] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:33.239] - Launch lazy future ...
[17:43:33.239] Packages needed by the future expression (n = 0): <none>
[17:43:33.239] Packages needed by future strategies (n = 0): <none>
[17:43:33.239] {
[17:43:33.239]     {
[17:43:33.239]         {
[17:43:33.239]             ...future.startTime <- base::Sys.time()
[17:43:33.239]             {
[17:43:33.239]                 {
[17:43:33.239]                   {
[17:43:33.239]                     base::local({
[17:43:33.239]                       has_future <- base::requireNamespace("future", 
[17:43:33.239]                         quietly = TRUE)
[17:43:33.239]                       if (has_future) {
[17:43:33.239]                         ns <- base::getNamespace("future")
[17:43:33.239]                         version <- ns[[".package"]][["version"]]
[17:43:33.239]                         if (is.null(version)) 
[17:43:33.239]                           version <- utils::packageVersion("future")
[17:43:33.239]                       }
[17:43:33.239]                       else {
[17:43:33.239]                         version <- NULL
[17:43:33.239]                       }
[17:43:33.239]                       if (!has_future || version < "1.8.0") {
[17:43:33.239]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:33.239]                           "", base::R.version$version.string), 
[17:43:33.239]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:33.239]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:33.239]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:33.239]                             "release", "version")], collapse = " "), 
[17:43:33.239]                           hostname = base::Sys.info()[["nodename"]])
[17:43:33.239]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:33.239]                           info)
[17:43:33.239]                         info <- base::paste(info, collapse = "; ")
[17:43:33.239]                         if (!has_future) {
[17:43:33.239]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:33.239]                             info)
[17:43:33.239]                         }
[17:43:33.239]                         else {
[17:43:33.239]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:33.239]                             info, version)
[17:43:33.239]                         }
[17:43:33.239]                         base::stop(msg)
[17:43:33.239]                       }
[17:43:33.239]                     })
[17:43:33.239]                   }
[17:43:33.239]                   options(future.plan = NULL)
[17:43:33.239]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:33.239]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:33.239]                 }
[17:43:33.239]                 ...future.workdir <- getwd()
[17:43:33.239]             }
[17:43:33.239]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:33.239]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:33.239]         }
[17:43:33.239]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:33.239]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:33.239]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:33.239]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:33.239]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:33.239]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:33.239]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:33.239]             base::names(...future.oldOptions))
[17:43:33.239]     }
[17:43:33.239]     if (FALSE) {
[17:43:33.239]     }
[17:43:33.239]     else {
[17:43:33.239]         if (TRUE) {
[17:43:33.239]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:33.239]                 open = "w")
[17:43:33.239]         }
[17:43:33.239]         else {
[17:43:33.239]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:33.239]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:33.239]         }
[17:43:33.239]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:33.239]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:33.239]             base::sink(type = "output", split = FALSE)
[17:43:33.239]             base::close(...future.stdout)
[17:43:33.239]         }, add = TRUE)
[17:43:33.239]     }
[17:43:33.239]     ...future.frame <- base::sys.nframe()
[17:43:33.239]     ...future.conditions <- base::list()
[17:43:33.239]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:33.239]     if (FALSE) {
[17:43:33.239]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:33.239]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:33.239]     }
[17:43:33.239]     ...future.result <- base::tryCatch({
[17:43:33.239]         base::withCallingHandlers({
[17:43:33.239]             ...future.value <- base::withVisible(base::local({
[17:43:33.239]                 Sys.sleep(0.1)
[17:43:33.239]                 kk
[17:43:33.239]             }))
[17:43:33.239]             future::FutureResult(value = ...future.value$value, 
[17:43:33.239]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:33.239]                   ...future.rng), globalenv = if (FALSE) 
[17:43:33.239]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:33.239]                     ...future.globalenv.names))
[17:43:33.239]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:33.239]         }, condition = base::local({
[17:43:33.239]             c <- base::c
[17:43:33.239]             inherits <- base::inherits
[17:43:33.239]             invokeRestart <- base::invokeRestart
[17:43:33.239]             length <- base::length
[17:43:33.239]             list <- base::list
[17:43:33.239]             seq.int <- base::seq.int
[17:43:33.239]             signalCondition <- base::signalCondition
[17:43:33.239]             sys.calls <- base::sys.calls
[17:43:33.239]             `[[` <- base::`[[`
[17:43:33.239]             `+` <- base::`+`
[17:43:33.239]             `<<-` <- base::`<<-`
[17:43:33.239]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:33.239]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:33.239]                   3L)]
[17:43:33.239]             }
[17:43:33.239]             function(cond) {
[17:43:33.239]                 is_error <- inherits(cond, "error")
[17:43:33.239]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:33.239]                   NULL)
[17:43:33.239]                 if (is_error) {
[17:43:33.239]                   sessionInformation <- function() {
[17:43:33.239]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:33.239]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:33.239]                       search = base::search(), system = base::Sys.info())
[17:43:33.239]                   }
[17:43:33.239]                   ...future.conditions[[length(...future.conditions) + 
[17:43:33.239]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:33.239]                     cond$call), session = sessionInformation(), 
[17:43:33.239]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:33.239]                   signalCondition(cond)
[17:43:33.239]                 }
[17:43:33.239]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:33.239]                 "immediateCondition"))) {
[17:43:33.239]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:33.239]                   ...future.conditions[[length(...future.conditions) + 
[17:43:33.239]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:33.239]                   if (TRUE && !signal) {
[17:43:33.239]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:33.239]                     {
[17:43:33.239]                       inherits <- base::inherits
[17:43:33.239]                       invokeRestart <- base::invokeRestart
[17:43:33.239]                       is.null <- base::is.null
[17:43:33.239]                       muffled <- FALSE
[17:43:33.239]                       if (inherits(cond, "message")) {
[17:43:33.239]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:33.239]                         if (muffled) 
[17:43:33.239]                           invokeRestart("muffleMessage")
[17:43:33.239]                       }
[17:43:33.239]                       else if (inherits(cond, "warning")) {
[17:43:33.239]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:33.239]                         if (muffled) 
[17:43:33.239]                           invokeRestart("muffleWarning")
[17:43:33.239]                       }
[17:43:33.239]                       else if (inherits(cond, "condition")) {
[17:43:33.239]                         if (!is.null(pattern)) {
[17:43:33.239]                           computeRestarts <- base::computeRestarts
[17:43:33.239]                           grepl <- base::grepl
[17:43:33.239]                           restarts <- computeRestarts(cond)
[17:43:33.239]                           for (restart in restarts) {
[17:43:33.239]                             name <- restart$name
[17:43:33.239]                             if (is.null(name)) 
[17:43:33.239]                               next
[17:43:33.239]                             if (!grepl(pattern, name)) 
[17:43:33.239]                               next
[17:43:33.239]                             invokeRestart(restart)
[17:43:33.239]                             muffled <- TRUE
[17:43:33.239]                             break
[17:43:33.239]                           }
[17:43:33.239]                         }
[17:43:33.239]                       }
[17:43:33.239]                       invisible(muffled)
[17:43:33.239]                     }
[17:43:33.239]                     muffleCondition(cond, pattern = "^muffle")
[17:43:33.239]                   }
[17:43:33.239]                 }
[17:43:33.239]                 else {
[17:43:33.239]                   if (TRUE) {
[17:43:33.239]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:33.239]                     {
[17:43:33.239]                       inherits <- base::inherits
[17:43:33.239]                       invokeRestart <- base::invokeRestart
[17:43:33.239]                       is.null <- base::is.null
[17:43:33.239]                       muffled <- FALSE
[17:43:33.239]                       if (inherits(cond, "message")) {
[17:43:33.239]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:33.239]                         if (muffled) 
[17:43:33.239]                           invokeRestart("muffleMessage")
[17:43:33.239]                       }
[17:43:33.239]                       else if (inherits(cond, "warning")) {
[17:43:33.239]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:33.239]                         if (muffled) 
[17:43:33.239]                           invokeRestart("muffleWarning")
[17:43:33.239]                       }
[17:43:33.239]                       else if (inherits(cond, "condition")) {
[17:43:33.239]                         if (!is.null(pattern)) {
[17:43:33.239]                           computeRestarts <- base::computeRestarts
[17:43:33.239]                           grepl <- base::grepl
[17:43:33.239]                           restarts <- computeRestarts(cond)
[17:43:33.239]                           for (restart in restarts) {
[17:43:33.239]                             name <- restart$name
[17:43:33.239]                             if (is.null(name)) 
[17:43:33.239]                               next
[17:43:33.239]                             if (!grepl(pattern, name)) 
[17:43:33.239]                               next
[17:43:33.239]                             invokeRestart(restart)
[17:43:33.239]                             muffled <- TRUE
[17:43:33.239]                             break
[17:43:33.239]                           }
[17:43:33.239]                         }
[17:43:33.239]                       }
[17:43:33.239]                       invisible(muffled)
[17:43:33.239]                     }
[17:43:33.239]                     muffleCondition(cond, pattern = "^muffle")
[17:43:33.239]                   }
[17:43:33.239]                 }
[17:43:33.239]             }
[17:43:33.239]         }))
[17:43:33.239]     }, error = function(ex) {
[17:43:33.239]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:33.239]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:33.239]                 ...future.rng), started = ...future.startTime, 
[17:43:33.239]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:33.239]             version = "1.8"), class = "FutureResult")
[17:43:33.239]     }, finally = {
[17:43:33.239]         if (!identical(...future.workdir, getwd())) 
[17:43:33.239]             setwd(...future.workdir)
[17:43:33.239]         {
[17:43:33.239]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:33.239]                 ...future.oldOptions$nwarnings <- NULL
[17:43:33.239]             }
[17:43:33.239]             base::options(...future.oldOptions)
[17:43:33.239]             if (.Platform$OS.type == "windows") {
[17:43:33.239]                 old_names <- names(...future.oldEnvVars)
[17:43:33.239]                 envs <- base::Sys.getenv()
[17:43:33.239]                 names <- names(envs)
[17:43:33.239]                 common <- intersect(names, old_names)
[17:43:33.239]                 added <- setdiff(names, old_names)
[17:43:33.239]                 removed <- setdiff(old_names, names)
[17:43:33.239]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:33.239]                   envs[common]]
[17:43:33.239]                 NAMES <- toupper(changed)
[17:43:33.239]                 args <- list()
[17:43:33.239]                 for (kk in seq_along(NAMES)) {
[17:43:33.239]                   name <- changed[[kk]]
[17:43:33.239]                   NAME <- NAMES[[kk]]
[17:43:33.239]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:33.239]                     next
[17:43:33.239]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:33.239]                 }
[17:43:33.239]                 NAMES <- toupper(added)
[17:43:33.239]                 for (kk in seq_along(NAMES)) {
[17:43:33.239]                   name <- added[[kk]]
[17:43:33.239]                   NAME <- NAMES[[kk]]
[17:43:33.239]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:33.239]                     next
[17:43:33.239]                   args[[name]] <- ""
[17:43:33.239]                 }
[17:43:33.239]                 NAMES <- toupper(removed)
[17:43:33.239]                 for (kk in seq_along(NAMES)) {
[17:43:33.239]                   name <- removed[[kk]]
[17:43:33.239]                   NAME <- NAMES[[kk]]
[17:43:33.239]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:33.239]                     next
[17:43:33.239]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:33.239]                 }
[17:43:33.239]                 if (length(args) > 0) 
[17:43:33.239]                   base::do.call(base::Sys.setenv, args = args)
[17:43:33.239]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:33.239]             }
[17:43:33.239]             else {
[17:43:33.239]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:33.239]             }
[17:43:33.239]             {
[17:43:33.239]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:33.239]                   0L) {
[17:43:33.239]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:33.239]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:33.239]                   base::options(opts)
[17:43:33.239]                 }
[17:43:33.239]                 {
[17:43:33.239]                   {
[17:43:33.239]                     NULL
[17:43:33.239]                     RNGkind("Mersenne-Twister")
[17:43:33.239]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:33.239]                       inherits = FALSE)
[17:43:33.239]                   }
[17:43:33.239]                   options(future.plan = NULL)
[17:43:33.239]                   if (is.na(NA_character_)) 
[17:43:33.239]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:33.239]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:33.239]                   future::plan(list(function (..., envir = parent.frame()) 
[17:43:33.239]                   {
[17:43:33.239]                     future <- SequentialFuture(..., envir = envir)
[17:43:33.239]                     if (!future$lazy) 
[17:43:33.239]                       future <- run(future)
[17:43:33.239]                     invisible(future)
[17:43:33.239]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:33.239]                 }
[17:43:33.239]             }
[17:43:33.239]         }
[17:43:33.239]     })
[17:43:33.239]     if (TRUE) {
[17:43:33.239]         base::sink(type = "output", split = FALSE)
[17:43:33.239]         if (TRUE) {
[17:43:33.239]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:33.239]         }
[17:43:33.239]         else {
[17:43:33.239]             ...future.result["stdout"] <- base::list(NULL)
[17:43:33.239]         }
[17:43:33.239]         base::close(...future.stdout)
[17:43:33.239]         ...future.stdout <- NULL
[17:43:33.239]     }
[17:43:33.239]     ...future.result$conditions <- ...future.conditions
[17:43:33.239]     ...future.result$finished <- base::Sys.time()
[17:43:33.239]     ...future.result
[17:43:33.239] }
[17:43:33.241] assign_globals() ...
[17:43:33.241] List of 1
[17:43:33.241]  $ kk: int 1
[17:43:33.241]  - attr(*, "where")=List of 1
[17:43:33.241]   ..$ kk:<environment: R_EmptyEnv> 
[17:43:33.241]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:33.241]  - attr(*, "resolved")= logi FALSE
[17:43:33.241]  - attr(*, "total_size")= num 56
[17:43:33.241]  - attr(*, "already-done")= logi TRUE
[17:43:33.246] - copied ‘kk’ to environment
[17:43:33.246] assign_globals() ... done
[17:43:33.247] plan(): Setting new future strategy stack:
[17:43:33.247] List of future strategies:
[17:43:33.247] 1. sequential:
[17:43:33.247]    - args: function (..., envir = parent.frame())
[17:43:33.247]    - tweaked: FALSE
[17:43:33.247]    - call: NULL
[17:43:33.247] plan(): nbrOfWorkers() = 1
[17:43:33.348] plan(): Setting new future strategy stack:
[17:43:33.348] List of future strategies:
[17:43:33.348] 1. sequential:
[17:43:33.348]    - args: function (..., envir = parent.frame())
[17:43:33.348]    - tweaked: FALSE
[17:43:33.348]    - call: plan(strategy)
[17:43:33.349] plan(): nbrOfWorkers() = 1
[17:43:33.351] SequentialFuture started (and completed)
[17:43:33.351] - Launch lazy future ... done
[17:43:33.352] run() for ‘SequentialFuture’ ... done
[17:43:33.352] getGlobalsAndPackages() ...
[17:43:33.352] Searching for globals...
[17:43:33.353] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:43:33.353] Searching for globals ... DONE
[17:43:33.353] Resolving globals: FALSE
[17:43:33.353] The total size of the 1 globals is 56 bytes (56 bytes)
[17:43:33.354] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:43:33.354] - globals: [1] ‘kk’
[17:43:33.354] 
[17:43:33.354] getGlobalsAndPackages() ... DONE
[17:43:33.355] run() for ‘Future’ ...
[17:43:33.355] - state: ‘created’
[17:43:33.355] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:33.355] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:33.355] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:33.355]   - Field: ‘label’
[17:43:33.355]   - Field: ‘local’
[17:43:33.356]   - Field: ‘owner’
[17:43:33.356]   - Field: ‘envir’
[17:43:33.356]   - Field: ‘packages’
[17:43:33.356]   - Field: ‘gc’
[17:43:33.356]   - Field: ‘conditions’
[17:43:33.356]   - Field: ‘expr’
[17:43:33.356]   - Field: ‘uuid’
[17:43:33.356]   - Field: ‘seed’
[17:43:33.356]   - Field: ‘version’
[17:43:33.356]   - Field: ‘result’
[17:43:33.356]   - Field: ‘asynchronous’
[17:43:33.357]   - Field: ‘calls’
[17:43:33.357]   - Field: ‘globals’
[17:43:33.357]   - Field: ‘stdout’
[17:43:33.357]   - Field: ‘earlySignal’
[17:43:33.357]   - Field: ‘lazy’
[17:43:33.357]   - Field: ‘state’
[17:43:33.357] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:33.357] - Launch lazy future ...
[17:43:33.357] Packages needed by the future expression (n = 0): <none>
[17:43:33.358] Packages needed by future strategies (n = 0): <none>
[17:43:33.358] {
[17:43:33.358]     {
[17:43:33.358]         {
[17:43:33.358]             ...future.startTime <- base::Sys.time()
[17:43:33.358]             {
[17:43:33.358]                 {
[17:43:33.358]                   {
[17:43:33.358]                     base::local({
[17:43:33.358]                       has_future <- base::requireNamespace("future", 
[17:43:33.358]                         quietly = TRUE)
[17:43:33.358]                       if (has_future) {
[17:43:33.358]                         ns <- base::getNamespace("future")
[17:43:33.358]                         version <- ns[[".package"]][["version"]]
[17:43:33.358]                         if (is.null(version)) 
[17:43:33.358]                           version <- utils::packageVersion("future")
[17:43:33.358]                       }
[17:43:33.358]                       else {
[17:43:33.358]                         version <- NULL
[17:43:33.358]                       }
[17:43:33.358]                       if (!has_future || version < "1.8.0") {
[17:43:33.358]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:33.358]                           "", base::R.version$version.string), 
[17:43:33.358]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:33.358]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:33.358]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:33.358]                             "release", "version")], collapse = " "), 
[17:43:33.358]                           hostname = base::Sys.info()[["nodename"]])
[17:43:33.358]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:33.358]                           info)
[17:43:33.358]                         info <- base::paste(info, collapse = "; ")
[17:43:33.358]                         if (!has_future) {
[17:43:33.358]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:33.358]                             info)
[17:43:33.358]                         }
[17:43:33.358]                         else {
[17:43:33.358]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:33.358]                             info, version)
[17:43:33.358]                         }
[17:43:33.358]                         base::stop(msg)
[17:43:33.358]                       }
[17:43:33.358]                     })
[17:43:33.358]                   }
[17:43:33.358]                   options(future.plan = NULL)
[17:43:33.358]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:33.358]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:33.358]                 }
[17:43:33.358]                 ...future.workdir <- getwd()
[17:43:33.358]             }
[17:43:33.358]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:33.358]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:33.358]         }
[17:43:33.358]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:33.358]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:33.358]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:33.358]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:33.358]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:33.358]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:33.358]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:33.358]             base::names(...future.oldOptions))
[17:43:33.358]     }
[17:43:33.358]     if (FALSE) {
[17:43:33.358]     }
[17:43:33.358]     else {
[17:43:33.358]         if (TRUE) {
[17:43:33.358]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:33.358]                 open = "w")
[17:43:33.358]         }
[17:43:33.358]         else {
[17:43:33.358]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:33.358]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:33.358]         }
[17:43:33.358]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:33.358]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:33.358]             base::sink(type = "output", split = FALSE)
[17:43:33.358]             base::close(...future.stdout)
[17:43:33.358]         }, add = TRUE)
[17:43:33.358]     }
[17:43:33.358]     ...future.frame <- base::sys.nframe()
[17:43:33.358]     ...future.conditions <- base::list()
[17:43:33.358]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:33.358]     if (FALSE) {
[17:43:33.358]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:33.358]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:33.358]     }
[17:43:33.358]     ...future.result <- base::tryCatch({
[17:43:33.358]         base::withCallingHandlers({
[17:43:33.358]             ...future.value <- base::withVisible(base::local({
[17:43:33.358]                 Sys.sleep(0.1)
[17:43:33.358]                 kk
[17:43:33.358]             }))
[17:43:33.358]             future::FutureResult(value = ...future.value$value, 
[17:43:33.358]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:33.358]                   ...future.rng), globalenv = if (FALSE) 
[17:43:33.358]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:33.358]                     ...future.globalenv.names))
[17:43:33.358]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:33.358]         }, condition = base::local({
[17:43:33.358]             c <- base::c
[17:43:33.358]             inherits <- base::inherits
[17:43:33.358]             invokeRestart <- base::invokeRestart
[17:43:33.358]             length <- base::length
[17:43:33.358]             list <- base::list
[17:43:33.358]             seq.int <- base::seq.int
[17:43:33.358]             signalCondition <- base::signalCondition
[17:43:33.358]             sys.calls <- base::sys.calls
[17:43:33.358]             `[[` <- base::`[[`
[17:43:33.358]             `+` <- base::`+`
[17:43:33.358]             `<<-` <- base::`<<-`
[17:43:33.358]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:33.358]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:33.358]                   3L)]
[17:43:33.358]             }
[17:43:33.358]             function(cond) {
[17:43:33.358]                 is_error <- inherits(cond, "error")
[17:43:33.358]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:33.358]                   NULL)
[17:43:33.358]                 if (is_error) {
[17:43:33.358]                   sessionInformation <- function() {
[17:43:33.358]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:33.358]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:33.358]                       search = base::search(), system = base::Sys.info())
[17:43:33.358]                   }
[17:43:33.358]                   ...future.conditions[[length(...future.conditions) + 
[17:43:33.358]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:33.358]                     cond$call), session = sessionInformation(), 
[17:43:33.358]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:33.358]                   signalCondition(cond)
[17:43:33.358]                 }
[17:43:33.358]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:33.358]                 "immediateCondition"))) {
[17:43:33.358]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:33.358]                   ...future.conditions[[length(...future.conditions) + 
[17:43:33.358]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:33.358]                   if (TRUE && !signal) {
[17:43:33.358]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:33.358]                     {
[17:43:33.358]                       inherits <- base::inherits
[17:43:33.358]                       invokeRestart <- base::invokeRestart
[17:43:33.358]                       is.null <- base::is.null
[17:43:33.358]                       muffled <- FALSE
[17:43:33.358]                       if (inherits(cond, "message")) {
[17:43:33.358]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:33.358]                         if (muffled) 
[17:43:33.358]                           invokeRestart("muffleMessage")
[17:43:33.358]                       }
[17:43:33.358]                       else if (inherits(cond, "warning")) {
[17:43:33.358]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:33.358]                         if (muffled) 
[17:43:33.358]                           invokeRestart("muffleWarning")
[17:43:33.358]                       }
[17:43:33.358]                       else if (inherits(cond, "condition")) {
[17:43:33.358]                         if (!is.null(pattern)) {
[17:43:33.358]                           computeRestarts <- base::computeRestarts
[17:43:33.358]                           grepl <- base::grepl
[17:43:33.358]                           restarts <- computeRestarts(cond)
[17:43:33.358]                           for (restart in restarts) {
[17:43:33.358]                             name <- restart$name
[17:43:33.358]                             if (is.null(name)) 
[17:43:33.358]                               next
[17:43:33.358]                             if (!grepl(pattern, name)) 
[17:43:33.358]                               next
[17:43:33.358]                             invokeRestart(restart)
[17:43:33.358]                             muffled <- TRUE
[17:43:33.358]                             break
[17:43:33.358]                           }
[17:43:33.358]                         }
[17:43:33.358]                       }
[17:43:33.358]                       invisible(muffled)
[17:43:33.358]                     }
[17:43:33.358]                     muffleCondition(cond, pattern = "^muffle")
[17:43:33.358]                   }
[17:43:33.358]                 }
[17:43:33.358]                 else {
[17:43:33.358]                   if (TRUE) {
[17:43:33.358]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:33.358]                     {
[17:43:33.358]                       inherits <- base::inherits
[17:43:33.358]                       invokeRestart <- base::invokeRestart
[17:43:33.358]                       is.null <- base::is.null
[17:43:33.358]                       muffled <- FALSE
[17:43:33.358]                       if (inherits(cond, "message")) {
[17:43:33.358]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:33.358]                         if (muffled) 
[17:43:33.358]                           invokeRestart("muffleMessage")
[17:43:33.358]                       }
[17:43:33.358]                       else if (inherits(cond, "warning")) {
[17:43:33.358]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:33.358]                         if (muffled) 
[17:43:33.358]                           invokeRestart("muffleWarning")
[17:43:33.358]                       }
[17:43:33.358]                       else if (inherits(cond, "condition")) {
[17:43:33.358]                         if (!is.null(pattern)) {
[17:43:33.358]                           computeRestarts <- base::computeRestarts
[17:43:33.358]                           grepl <- base::grepl
[17:43:33.358]                           restarts <- computeRestarts(cond)
[17:43:33.358]                           for (restart in restarts) {
[17:43:33.358]                             name <- restart$name
[17:43:33.358]                             if (is.null(name)) 
[17:43:33.358]                               next
[17:43:33.358]                             if (!grepl(pattern, name)) 
[17:43:33.358]                               next
[17:43:33.358]                             invokeRestart(restart)
[17:43:33.358]                             muffled <- TRUE
[17:43:33.358]                             break
[17:43:33.358]                           }
[17:43:33.358]                         }
[17:43:33.358]                       }
[17:43:33.358]                       invisible(muffled)
[17:43:33.358]                     }
[17:43:33.358]                     muffleCondition(cond, pattern = "^muffle")
[17:43:33.358]                   }
[17:43:33.358]                 }
[17:43:33.358]             }
[17:43:33.358]         }))
[17:43:33.358]     }, error = function(ex) {
[17:43:33.358]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:33.358]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:33.358]                 ...future.rng), started = ...future.startTime, 
[17:43:33.358]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:33.358]             version = "1.8"), class = "FutureResult")
[17:43:33.358]     }, finally = {
[17:43:33.358]         if (!identical(...future.workdir, getwd())) 
[17:43:33.358]             setwd(...future.workdir)
[17:43:33.358]         {
[17:43:33.358]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:33.358]                 ...future.oldOptions$nwarnings <- NULL
[17:43:33.358]             }
[17:43:33.358]             base::options(...future.oldOptions)
[17:43:33.358]             if (.Platform$OS.type == "windows") {
[17:43:33.358]                 old_names <- names(...future.oldEnvVars)
[17:43:33.358]                 envs <- base::Sys.getenv()
[17:43:33.358]                 names <- names(envs)
[17:43:33.358]                 common <- intersect(names, old_names)
[17:43:33.358]                 added <- setdiff(names, old_names)
[17:43:33.358]                 removed <- setdiff(old_names, names)
[17:43:33.358]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:33.358]                   envs[common]]
[17:43:33.358]                 NAMES <- toupper(changed)
[17:43:33.358]                 args <- list()
[17:43:33.358]                 for (kk in seq_along(NAMES)) {
[17:43:33.358]                   name <- changed[[kk]]
[17:43:33.358]                   NAME <- NAMES[[kk]]
[17:43:33.358]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:33.358]                     next
[17:43:33.358]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:33.358]                 }
[17:43:33.358]                 NAMES <- toupper(added)
[17:43:33.358]                 for (kk in seq_along(NAMES)) {
[17:43:33.358]                   name <- added[[kk]]
[17:43:33.358]                   NAME <- NAMES[[kk]]
[17:43:33.358]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:33.358]                     next
[17:43:33.358]                   args[[name]] <- ""
[17:43:33.358]                 }
[17:43:33.358]                 NAMES <- toupper(removed)
[17:43:33.358]                 for (kk in seq_along(NAMES)) {
[17:43:33.358]                   name <- removed[[kk]]
[17:43:33.358]                   NAME <- NAMES[[kk]]
[17:43:33.358]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:33.358]                     next
[17:43:33.358]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:33.358]                 }
[17:43:33.358]                 if (length(args) > 0) 
[17:43:33.358]                   base::do.call(base::Sys.setenv, args = args)
[17:43:33.358]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:33.358]             }
[17:43:33.358]             else {
[17:43:33.358]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:33.358]             }
[17:43:33.358]             {
[17:43:33.358]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:33.358]                   0L) {
[17:43:33.358]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:33.358]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:33.358]                   base::options(opts)
[17:43:33.358]                 }
[17:43:33.358]                 {
[17:43:33.358]                   {
[17:43:33.358]                     NULL
[17:43:33.358]                     RNGkind("Mersenne-Twister")
[17:43:33.358]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:33.358]                       inherits = FALSE)
[17:43:33.358]                   }
[17:43:33.358]                   options(future.plan = NULL)
[17:43:33.358]                   if (is.na(NA_character_)) 
[17:43:33.358]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:33.358]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:33.358]                   future::plan(list(function (..., envir = parent.frame()) 
[17:43:33.358]                   {
[17:43:33.358]                     future <- SequentialFuture(..., envir = envir)
[17:43:33.358]                     if (!future$lazy) 
[17:43:33.358]                       future <- run(future)
[17:43:33.358]                     invisible(future)
[17:43:33.358]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:33.358]                 }
[17:43:33.358]             }
[17:43:33.358]         }
[17:43:33.358]     })
[17:43:33.358]     if (TRUE) {
[17:43:33.358]         base::sink(type = "output", split = FALSE)
[17:43:33.358]         if (TRUE) {
[17:43:33.358]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:33.358]         }
[17:43:33.358]         else {
[17:43:33.358]             ...future.result["stdout"] <- base::list(NULL)
[17:43:33.358]         }
[17:43:33.358]         base::close(...future.stdout)
[17:43:33.358]         ...future.stdout <- NULL
[17:43:33.358]     }
[17:43:33.358]     ...future.result$conditions <- ...future.conditions
[17:43:33.358]     ...future.result$finished <- base::Sys.time()
[17:43:33.358]     ...future.result
[17:43:33.358] }
[17:43:33.360] assign_globals() ...
[17:43:33.360] List of 1
[17:43:33.360]  $ kk: int 2
[17:43:33.360]  - attr(*, "where")=List of 1
[17:43:33.360]   ..$ kk:<environment: R_EmptyEnv> 
[17:43:33.360]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:33.360]  - attr(*, "resolved")= logi FALSE
[17:43:33.360]  - attr(*, "total_size")= num 56
[17:43:33.360]  - attr(*, "already-done")= logi TRUE
[17:43:33.362] - copied ‘kk’ to environment
[17:43:33.362] assign_globals() ... done
[17:43:33.362] plan(): Setting new future strategy stack:
[17:43:33.363] List of future strategies:
[17:43:33.363] 1. sequential:
[17:43:33.363]    - args: function (..., envir = parent.frame())
[17:43:33.363]    - tweaked: FALSE
[17:43:33.363]    - call: NULL
[17:43:33.363] plan(): nbrOfWorkers() = 1
[17:43:33.464] plan(): Setting new future strategy stack:
[17:43:33.464] List of future strategies:
[17:43:33.464] 1. sequential:
[17:43:33.464]    - args: function (..., envir = parent.frame())
[17:43:33.464]    - tweaked: FALSE
[17:43:33.464]    - call: plan(strategy)
[17:43:33.465] plan(): nbrOfWorkers() = 1
[17:43:33.465] SequentialFuture started (and completed)
[17:43:33.465] - Launch lazy future ... done
[17:43:33.465] run() for ‘SequentialFuture’ ... done
[17:43:33.465] getGlobalsAndPackages() ...
[17:43:33.465] Searching for globals...
[17:43:33.467] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:43:33.467] Searching for globals ... DONE
[17:43:33.467] Resolving globals: FALSE
[17:43:33.467] The total size of the 1 globals is 56 bytes (56 bytes)
[17:43:33.468] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:43:33.468] - globals: [1] ‘kk’
[17:43:33.468] 
[17:43:33.468] getGlobalsAndPackages() ... DONE
[17:43:33.468] run() for ‘Future’ ...
[17:43:33.468] - state: ‘created’
[17:43:33.468] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:33.469] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:33.469] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:33.469]   - Field: ‘label’
[17:43:33.469]   - Field: ‘local’
[17:43:33.469]   - Field: ‘owner’
[17:43:33.469]   - Field: ‘envir’
[17:43:33.469]   - Field: ‘packages’
[17:43:33.469]   - Field: ‘gc’
[17:43:33.469]   - Field: ‘conditions’
[17:43:33.470]   - Field: ‘expr’
[17:43:33.470]   - Field: ‘uuid’
[17:43:33.470]   - Field: ‘seed’
[17:43:33.470]   - Field: ‘version’
[17:43:33.470]   - Field: ‘result’
[17:43:33.470]   - Field: ‘asynchronous’
[17:43:33.470]   - Field: ‘calls’
[17:43:33.470]   - Field: ‘globals’
[17:43:33.470]   - Field: ‘stdout’
[17:43:33.470]   - Field: ‘earlySignal’
[17:43:33.470]   - Field: ‘lazy’
[17:43:33.471]   - Field: ‘state’
[17:43:33.471] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:33.471] - Launch lazy future ...
[17:43:33.471] Packages needed by the future expression (n = 0): <none>
[17:43:33.471] Packages needed by future strategies (n = 0): <none>
[17:43:33.472] {
[17:43:33.472]     {
[17:43:33.472]         {
[17:43:33.472]             ...future.startTime <- base::Sys.time()
[17:43:33.472]             {
[17:43:33.472]                 {
[17:43:33.472]                   {
[17:43:33.472]                     base::local({
[17:43:33.472]                       has_future <- base::requireNamespace("future", 
[17:43:33.472]                         quietly = TRUE)
[17:43:33.472]                       if (has_future) {
[17:43:33.472]                         ns <- base::getNamespace("future")
[17:43:33.472]                         version <- ns[[".package"]][["version"]]
[17:43:33.472]                         if (is.null(version)) 
[17:43:33.472]                           version <- utils::packageVersion("future")
[17:43:33.472]                       }
[17:43:33.472]                       else {
[17:43:33.472]                         version <- NULL
[17:43:33.472]                       }
[17:43:33.472]                       if (!has_future || version < "1.8.0") {
[17:43:33.472]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:33.472]                           "", base::R.version$version.string), 
[17:43:33.472]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:33.472]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:33.472]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:33.472]                             "release", "version")], collapse = " "), 
[17:43:33.472]                           hostname = base::Sys.info()[["nodename"]])
[17:43:33.472]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:33.472]                           info)
[17:43:33.472]                         info <- base::paste(info, collapse = "; ")
[17:43:33.472]                         if (!has_future) {
[17:43:33.472]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:33.472]                             info)
[17:43:33.472]                         }
[17:43:33.472]                         else {
[17:43:33.472]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:33.472]                             info, version)
[17:43:33.472]                         }
[17:43:33.472]                         base::stop(msg)
[17:43:33.472]                       }
[17:43:33.472]                     })
[17:43:33.472]                   }
[17:43:33.472]                   options(future.plan = NULL)
[17:43:33.472]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:33.472]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:33.472]                 }
[17:43:33.472]                 ...future.workdir <- getwd()
[17:43:33.472]             }
[17:43:33.472]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:33.472]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:33.472]         }
[17:43:33.472]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:33.472]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:33.472]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:33.472]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:33.472]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:33.472]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:33.472]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:33.472]             base::names(...future.oldOptions))
[17:43:33.472]     }
[17:43:33.472]     if (FALSE) {
[17:43:33.472]     }
[17:43:33.472]     else {
[17:43:33.472]         if (TRUE) {
[17:43:33.472]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:33.472]                 open = "w")
[17:43:33.472]         }
[17:43:33.472]         else {
[17:43:33.472]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:33.472]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:33.472]         }
[17:43:33.472]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:33.472]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:33.472]             base::sink(type = "output", split = FALSE)
[17:43:33.472]             base::close(...future.stdout)
[17:43:33.472]         }, add = TRUE)
[17:43:33.472]     }
[17:43:33.472]     ...future.frame <- base::sys.nframe()
[17:43:33.472]     ...future.conditions <- base::list()
[17:43:33.472]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:33.472]     if (FALSE) {
[17:43:33.472]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:33.472]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:33.472]     }
[17:43:33.472]     ...future.result <- base::tryCatch({
[17:43:33.472]         base::withCallingHandlers({
[17:43:33.472]             ...future.value <- base::withVisible(base::local({
[17:43:33.472]                 Sys.sleep(0.1)
[17:43:33.472]                 kk
[17:43:33.472]             }))
[17:43:33.472]             future::FutureResult(value = ...future.value$value, 
[17:43:33.472]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:33.472]                   ...future.rng), globalenv = if (FALSE) 
[17:43:33.472]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:33.472]                     ...future.globalenv.names))
[17:43:33.472]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:33.472]         }, condition = base::local({
[17:43:33.472]             c <- base::c
[17:43:33.472]             inherits <- base::inherits
[17:43:33.472]             invokeRestart <- base::invokeRestart
[17:43:33.472]             length <- base::length
[17:43:33.472]             list <- base::list
[17:43:33.472]             seq.int <- base::seq.int
[17:43:33.472]             signalCondition <- base::signalCondition
[17:43:33.472]             sys.calls <- base::sys.calls
[17:43:33.472]             `[[` <- base::`[[`
[17:43:33.472]             `+` <- base::`+`
[17:43:33.472]             `<<-` <- base::`<<-`
[17:43:33.472]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:33.472]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:33.472]                   3L)]
[17:43:33.472]             }
[17:43:33.472]             function(cond) {
[17:43:33.472]                 is_error <- inherits(cond, "error")
[17:43:33.472]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:33.472]                   NULL)
[17:43:33.472]                 if (is_error) {
[17:43:33.472]                   sessionInformation <- function() {
[17:43:33.472]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:33.472]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:33.472]                       search = base::search(), system = base::Sys.info())
[17:43:33.472]                   }
[17:43:33.472]                   ...future.conditions[[length(...future.conditions) + 
[17:43:33.472]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:33.472]                     cond$call), session = sessionInformation(), 
[17:43:33.472]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:33.472]                   signalCondition(cond)
[17:43:33.472]                 }
[17:43:33.472]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:33.472]                 "immediateCondition"))) {
[17:43:33.472]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:33.472]                   ...future.conditions[[length(...future.conditions) + 
[17:43:33.472]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:33.472]                   if (TRUE && !signal) {
[17:43:33.472]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:33.472]                     {
[17:43:33.472]                       inherits <- base::inherits
[17:43:33.472]                       invokeRestart <- base::invokeRestart
[17:43:33.472]                       is.null <- base::is.null
[17:43:33.472]                       muffled <- FALSE
[17:43:33.472]                       if (inherits(cond, "message")) {
[17:43:33.472]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:33.472]                         if (muffled) 
[17:43:33.472]                           invokeRestart("muffleMessage")
[17:43:33.472]                       }
[17:43:33.472]                       else if (inherits(cond, "warning")) {
[17:43:33.472]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:33.472]                         if (muffled) 
[17:43:33.472]                           invokeRestart("muffleWarning")
[17:43:33.472]                       }
[17:43:33.472]                       else if (inherits(cond, "condition")) {
[17:43:33.472]                         if (!is.null(pattern)) {
[17:43:33.472]                           computeRestarts <- base::computeRestarts
[17:43:33.472]                           grepl <- base::grepl
[17:43:33.472]                           restarts <- computeRestarts(cond)
[17:43:33.472]                           for (restart in restarts) {
[17:43:33.472]                             name <- restart$name
[17:43:33.472]                             if (is.null(name)) 
[17:43:33.472]                               next
[17:43:33.472]                             if (!grepl(pattern, name)) 
[17:43:33.472]                               next
[17:43:33.472]                             invokeRestart(restart)
[17:43:33.472]                             muffled <- TRUE
[17:43:33.472]                             break
[17:43:33.472]                           }
[17:43:33.472]                         }
[17:43:33.472]                       }
[17:43:33.472]                       invisible(muffled)
[17:43:33.472]                     }
[17:43:33.472]                     muffleCondition(cond, pattern = "^muffle")
[17:43:33.472]                   }
[17:43:33.472]                 }
[17:43:33.472]                 else {
[17:43:33.472]                   if (TRUE) {
[17:43:33.472]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:33.472]                     {
[17:43:33.472]                       inherits <- base::inherits
[17:43:33.472]                       invokeRestart <- base::invokeRestart
[17:43:33.472]                       is.null <- base::is.null
[17:43:33.472]                       muffled <- FALSE
[17:43:33.472]                       if (inherits(cond, "message")) {
[17:43:33.472]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:33.472]                         if (muffled) 
[17:43:33.472]                           invokeRestart("muffleMessage")
[17:43:33.472]                       }
[17:43:33.472]                       else if (inherits(cond, "warning")) {
[17:43:33.472]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:33.472]                         if (muffled) 
[17:43:33.472]                           invokeRestart("muffleWarning")
[17:43:33.472]                       }
[17:43:33.472]                       else if (inherits(cond, "condition")) {
[17:43:33.472]                         if (!is.null(pattern)) {
[17:43:33.472]                           computeRestarts <- base::computeRestarts
[17:43:33.472]                           grepl <- base::grepl
[17:43:33.472]                           restarts <- computeRestarts(cond)
[17:43:33.472]                           for (restart in restarts) {
[17:43:33.472]                             name <- restart$name
[17:43:33.472]                             if (is.null(name)) 
[17:43:33.472]                               next
[17:43:33.472]                             if (!grepl(pattern, name)) 
[17:43:33.472]                               next
[17:43:33.472]                             invokeRestart(restart)
[17:43:33.472]                             muffled <- TRUE
[17:43:33.472]                             break
[17:43:33.472]                           }
[17:43:33.472]                         }
[17:43:33.472]                       }
[17:43:33.472]                       invisible(muffled)
[17:43:33.472]                     }
[17:43:33.472]                     muffleCondition(cond, pattern = "^muffle")
[17:43:33.472]                   }
[17:43:33.472]                 }
[17:43:33.472]             }
[17:43:33.472]         }))
[17:43:33.472]     }, error = function(ex) {
[17:43:33.472]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:33.472]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:33.472]                 ...future.rng), started = ...future.startTime, 
[17:43:33.472]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:33.472]             version = "1.8"), class = "FutureResult")
[17:43:33.472]     }, finally = {
[17:43:33.472]         if (!identical(...future.workdir, getwd())) 
[17:43:33.472]             setwd(...future.workdir)
[17:43:33.472]         {
[17:43:33.472]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:33.472]                 ...future.oldOptions$nwarnings <- NULL
[17:43:33.472]             }
[17:43:33.472]             base::options(...future.oldOptions)
[17:43:33.472]             if (.Platform$OS.type == "windows") {
[17:43:33.472]                 old_names <- names(...future.oldEnvVars)
[17:43:33.472]                 envs <- base::Sys.getenv()
[17:43:33.472]                 names <- names(envs)
[17:43:33.472]                 common <- intersect(names, old_names)
[17:43:33.472]                 added <- setdiff(names, old_names)
[17:43:33.472]                 removed <- setdiff(old_names, names)
[17:43:33.472]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:33.472]                   envs[common]]
[17:43:33.472]                 NAMES <- toupper(changed)
[17:43:33.472]                 args <- list()
[17:43:33.472]                 for (kk in seq_along(NAMES)) {
[17:43:33.472]                   name <- changed[[kk]]
[17:43:33.472]                   NAME <- NAMES[[kk]]
[17:43:33.472]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:33.472]                     next
[17:43:33.472]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:33.472]                 }
[17:43:33.472]                 NAMES <- toupper(added)
[17:43:33.472]                 for (kk in seq_along(NAMES)) {
[17:43:33.472]                   name <- added[[kk]]
[17:43:33.472]                   NAME <- NAMES[[kk]]
[17:43:33.472]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:33.472]                     next
[17:43:33.472]                   args[[name]] <- ""
[17:43:33.472]                 }
[17:43:33.472]                 NAMES <- toupper(removed)
[17:43:33.472]                 for (kk in seq_along(NAMES)) {
[17:43:33.472]                   name <- removed[[kk]]
[17:43:33.472]                   NAME <- NAMES[[kk]]
[17:43:33.472]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:33.472]                     next
[17:43:33.472]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:33.472]                 }
[17:43:33.472]                 if (length(args) > 0) 
[17:43:33.472]                   base::do.call(base::Sys.setenv, args = args)
[17:43:33.472]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:33.472]             }
[17:43:33.472]             else {
[17:43:33.472]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:33.472]             }
[17:43:33.472]             {
[17:43:33.472]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:33.472]                   0L) {
[17:43:33.472]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:33.472]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:33.472]                   base::options(opts)
[17:43:33.472]                 }
[17:43:33.472]                 {
[17:43:33.472]                   {
[17:43:33.472]                     NULL
[17:43:33.472]                     RNGkind("Mersenne-Twister")
[17:43:33.472]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:33.472]                       inherits = FALSE)
[17:43:33.472]                   }
[17:43:33.472]                   options(future.plan = NULL)
[17:43:33.472]                   if (is.na(NA_character_)) 
[17:43:33.472]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:33.472]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:33.472]                   future::plan(list(function (..., envir = parent.frame()) 
[17:43:33.472]                   {
[17:43:33.472]                     future <- SequentialFuture(..., envir = envir)
[17:43:33.472]                     if (!future$lazy) 
[17:43:33.472]                       future <- run(future)
[17:43:33.472]                     invisible(future)
[17:43:33.472]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:33.472]                 }
[17:43:33.472]             }
[17:43:33.472]         }
[17:43:33.472]     })
[17:43:33.472]     if (TRUE) {
[17:43:33.472]         base::sink(type = "output", split = FALSE)
[17:43:33.472]         if (TRUE) {
[17:43:33.472]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:33.472]         }
[17:43:33.472]         else {
[17:43:33.472]             ...future.result["stdout"] <- base::list(NULL)
[17:43:33.472]         }
[17:43:33.472]         base::close(...future.stdout)
[17:43:33.472]         ...future.stdout <- NULL
[17:43:33.472]     }
[17:43:33.472]     ...future.result$conditions <- ...future.conditions
[17:43:33.472]     ...future.result$finished <- base::Sys.time()
[17:43:33.472]     ...future.result
[17:43:33.472] }
[17:43:33.473] assign_globals() ...
[17:43:33.473] List of 1
[17:43:33.473]  $ kk: int 3
[17:43:33.473]  - attr(*, "where")=List of 1
[17:43:33.473]   ..$ kk:<environment: R_EmptyEnv> 
[17:43:33.473]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:33.473]  - attr(*, "resolved")= logi FALSE
[17:43:33.473]  - attr(*, "total_size")= num 56
[17:43:33.473]  - attr(*, "already-done")= logi TRUE
[17:43:33.476] - copied ‘kk’ to environment
[17:43:33.476] assign_globals() ... done
[17:43:33.476] plan(): Setting new future strategy stack:
[17:43:33.476] List of future strategies:
[17:43:33.476] 1. sequential:
[17:43:33.476]    - args: function (..., envir = parent.frame())
[17:43:33.476]    - tweaked: FALSE
[17:43:33.476]    - call: NULL
[17:43:33.477] plan(): nbrOfWorkers() = 1
[17:43:33.578] plan(): Setting new future strategy stack:
[17:43:33.578] List of future strategies:
[17:43:33.578] 1. sequential:
[17:43:33.578]    - args: function (..., envir = parent.frame())
[17:43:33.578]    - tweaked: FALSE
[17:43:33.578]    - call: plan(strategy)
[17:43:33.579] plan(): nbrOfWorkers() = 1
[17:43:33.579] SequentialFuture started (and completed)
[17:43:33.579] - Launch lazy future ... done
[17:43:33.579] run() for ‘SequentialFuture’ ... done
[17:43:33.579] resolve() on list ...
[17:43:33.579]  recursive: 0
[17:43:33.580]  length: 3
[17:43:33.580] 
[17:43:33.580] resolved() for ‘SequentialFuture’ ...
[17:43:33.580] - state: ‘finished’
[17:43:33.580] - run: TRUE
[17:43:33.580] - result: ‘FutureResult’
[17:43:33.580] resolved() for ‘SequentialFuture’ ... done
[17:43:33.580] Future #1
[17:43:33.580]  length: 2 (resolved future 1)
[17:43:33.580] resolved() for ‘SequentialFuture’ ...
[17:43:33.580] - state: ‘finished’
[17:43:33.581] - run: TRUE
[17:43:33.581] - result: ‘FutureResult’
[17:43:33.581] resolved() for ‘SequentialFuture’ ... done
[17:43:33.581] Future #2
[17:43:33.583]  length: 1 (resolved future 2)
[17:43:33.583] resolved() for ‘SequentialFuture’ ...
[17:43:33.583] - state: ‘finished’
[17:43:33.583] - run: TRUE
[17:43:33.583] - result: ‘FutureResult’
[17:43:33.583] resolved() for ‘SequentialFuture’ ... done
[17:43:33.583] Future #3
[17:43:33.583]  length: 0 (resolved future 3)
[17:43:33.584] resolve() on list ... DONE
[17:43:33.584] getGlobalsAndPackages() ...
[17:43:33.584] Searching for globals...
[17:43:33.585] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:43:33.585] Searching for globals ... DONE
[17:43:33.585] Resolving globals: FALSE
[17:43:33.585] The total size of the 1 globals is 56 bytes (56 bytes)
[17:43:33.586] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:43:33.586] - globals: [1] ‘kk’
[17:43:33.586] 
[17:43:33.586] getGlobalsAndPackages() ... DONE
[17:43:33.586] getGlobalsAndPackages() ...
[17:43:33.586] Searching for globals...
[17:43:33.587] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:43:33.587] Searching for globals ... DONE
[17:43:33.588] Resolving globals: FALSE
[17:43:33.588] The total size of the 1 globals is 56 bytes (56 bytes)
[17:43:33.588] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:43:33.588] - globals: [1] ‘kk’
[17:43:33.588] 
[17:43:33.589] getGlobalsAndPackages() ... DONE
[17:43:33.589] getGlobalsAndPackages() ...
[17:43:33.589] Searching for globals...
[17:43:33.590] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:43:33.590] Searching for globals ... DONE
[17:43:33.590] Resolving globals: FALSE
[17:43:33.590] The total size of the 1 globals is 56 bytes (56 bytes)
[17:43:33.591] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:43:33.591] - globals: [1] ‘kk’
[17:43:33.591] 
[17:43:33.591] getGlobalsAndPackages() ... DONE
[17:43:33.591] resolve() on list ...
[17:43:33.591]  recursive: 0
[17:43:33.591]  length: 3
[17:43:33.591] 
[17:43:33.592] run() for ‘Future’ ...
[17:43:33.592] - state: ‘created’
[17:43:33.592] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:33.592] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:33.592] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:33.592]   - Field: ‘label’
[17:43:33.592]   - Field: ‘local’
[17:43:33.592]   - Field: ‘owner’
[17:43:33.593]   - Field: ‘envir’
[17:43:33.593]   - Field: ‘packages’
[17:43:33.593]   - Field: ‘gc’
[17:43:33.593]   - Field: ‘conditions’
[17:43:33.593]   - Field: ‘expr’
[17:43:33.593]   - Field: ‘uuid’
[17:43:33.593]   - Field: ‘seed’
[17:43:33.593]   - Field: ‘version’
[17:43:33.593]   - Field: ‘result’
[17:43:33.593]   - Field: ‘asynchronous’
[17:43:33.593]   - Field: ‘calls’
[17:43:33.594]   - Field: ‘globals’
[17:43:33.594]   - Field: ‘stdout’
[17:43:33.594]   - Field: ‘earlySignal’
[17:43:33.594]   - Field: ‘lazy’
[17:43:33.594]   - Field: ‘state’
[17:43:33.594] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:33.594] - Launch lazy future ...
[17:43:33.594] Packages needed by the future expression (n = 0): <none>
[17:43:33.594] Packages needed by future strategies (n = 0): <none>
[17:43:33.595] {
[17:43:33.595]     {
[17:43:33.595]         {
[17:43:33.595]             ...future.startTime <- base::Sys.time()
[17:43:33.595]             {
[17:43:33.595]                 {
[17:43:33.595]                   {
[17:43:33.595]                     base::local({
[17:43:33.595]                       has_future <- base::requireNamespace("future", 
[17:43:33.595]                         quietly = TRUE)
[17:43:33.595]                       if (has_future) {
[17:43:33.595]                         ns <- base::getNamespace("future")
[17:43:33.595]                         version <- ns[[".package"]][["version"]]
[17:43:33.595]                         if (is.null(version)) 
[17:43:33.595]                           version <- utils::packageVersion("future")
[17:43:33.595]                       }
[17:43:33.595]                       else {
[17:43:33.595]                         version <- NULL
[17:43:33.595]                       }
[17:43:33.595]                       if (!has_future || version < "1.8.0") {
[17:43:33.595]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:33.595]                           "", base::R.version$version.string), 
[17:43:33.595]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:33.595]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:33.595]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:33.595]                             "release", "version")], collapse = " "), 
[17:43:33.595]                           hostname = base::Sys.info()[["nodename"]])
[17:43:33.595]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:33.595]                           info)
[17:43:33.595]                         info <- base::paste(info, collapse = "; ")
[17:43:33.595]                         if (!has_future) {
[17:43:33.595]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:33.595]                             info)
[17:43:33.595]                         }
[17:43:33.595]                         else {
[17:43:33.595]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:33.595]                             info, version)
[17:43:33.595]                         }
[17:43:33.595]                         base::stop(msg)
[17:43:33.595]                       }
[17:43:33.595]                     })
[17:43:33.595]                   }
[17:43:33.595]                   options(future.plan = NULL)
[17:43:33.595]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:33.595]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:33.595]                 }
[17:43:33.595]                 ...future.workdir <- getwd()
[17:43:33.595]             }
[17:43:33.595]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:33.595]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:33.595]         }
[17:43:33.595]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:33.595]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:33.595]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:33.595]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:33.595]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:33.595]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:33.595]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:33.595]             base::names(...future.oldOptions))
[17:43:33.595]     }
[17:43:33.595]     if (FALSE) {
[17:43:33.595]     }
[17:43:33.595]     else {
[17:43:33.595]         if (TRUE) {
[17:43:33.595]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:33.595]                 open = "w")
[17:43:33.595]         }
[17:43:33.595]         else {
[17:43:33.595]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:33.595]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:33.595]         }
[17:43:33.595]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:33.595]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:33.595]             base::sink(type = "output", split = FALSE)
[17:43:33.595]             base::close(...future.stdout)
[17:43:33.595]         }, add = TRUE)
[17:43:33.595]     }
[17:43:33.595]     ...future.frame <- base::sys.nframe()
[17:43:33.595]     ...future.conditions <- base::list()
[17:43:33.595]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:33.595]     if (FALSE) {
[17:43:33.595]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:33.595]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:33.595]     }
[17:43:33.595]     ...future.result <- base::tryCatch({
[17:43:33.595]         base::withCallingHandlers({
[17:43:33.595]             ...future.value <- base::withVisible(base::local({
[17:43:33.595]                 Sys.sleep(0.1)
[17:43:33.595]                 kk
[17:43:33.595]             }))
[17:43:33.595]             future::FutureResult(value = ...future.value$value, 
[17:43:33.595]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:33.595]                   ...future.rng), globalenv = if (FALSE) 
[17:43:33.595]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:33.595]                     ...future.globalenv.names))
[17:43:33.595]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:33.595]         }, condition = base::local({
[17:43:33.595]             c <- base::c
[17:43:33.595]             inherits <- base::inherits
[17:43:33.595]             invokeRestart <- base::invokeRestart
[17:43:33.595]             length <- base::length
[17:43:33.595]             list <- base::list
[17:43:33.595]             seq.int <- base::seq.int
[17:43:33.595]             signalCondition <- base::signalCondition
[17:43:33.595]             sys.calls <- base::sys.calls
[17:43:33.595]             `[[` <- base::`[[`
[17:43:33.595]             `+` <- base::`+`
[17:43:33.595]             `<<-` <- base::`<<-`
[17:43:33.595]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:33.595]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:33.595]                   3L)]
[17:43:33.595]             }
[17:43:33.595]             function(cond) {
[17:43:33.595]                 is_error <- inherits(cond, "error")
[17:43:33.595]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:33.595]                   NULL)
[17:43:33.595]                 if (is_error) {
[17:43:33.595]                   sessionInformation <- function() {
[17:43:33.595]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:33.595]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:33.595]                       search = base::search(), system = base::Sys.info())
[17:43:33.595]                   }
[17:43:33.595]                   ...future.conditions[[length(...future.conditions) + 
[17:43:33.595]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:33.595]                     cond$call), session = sessionInformation(), 
[17:43:33.595]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:33.595]                   signalCondition(cond)
[17:43:33.595]                 }
[17:43:33.595]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:33.595]                 "immediateCondition"))) {
[17:43:33.595]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:33.595]                   ...future.conditions[[length(...future.conditions) + 
[17:43:33.595]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:33.595]                   if (TRUE && !signal) {
[17:43:33.595]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:33.595]                     {
[17:43:33.595]                       inherits <- base::inherits
[17:43:33.595]                       invokeRestart <- base::invokeRestart
[17:43:33.595]                       is.null <- base::is.null
[17:43:33.595]                       muffled <- FALSE
[17:43:33.595]                       if (inherits(cond, "message")) {
[17:43:33.595]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:33.595]                         if (muffled) 
[17:43:33.595]                           invokeRestart("muffleMessage")
[17:43:33.595]                       }
[17:43:33.595]                       else if (inherits(cond, "warning")) {
[17:43:33.595]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:33.595]                         if (muffled) 
[17:43:33.595]                           invokeRestart("muffleWarning")
[17:43:33.595]                       }
[17:43:33.595]                       else if (inherits(cond, "condition")) {
[17:43:33.595]                         if (!is.null(pattern)) {
[17:43:33.595]                           computeRestarts <- base::computeRestarts
[17:43:33.595]                           grepl <- base::grepl
[17:43:33.595]                           restarts <- computeRestarts(cond)
[17:43:33.595]                           for (restart in restarts) {
[17:43:33.595]                             name <- restart$name
[17:43:33.595]                             if (is.null(name)) 
[17:43:33.595]                               next
[17:43:33.595]                             if (!grepl(pattern, name)) 
[17:43:33.595]                               next
[17:43:33.595]                             invokeRestart(restart)
[17:43:33.595]                             muffled <- TRUE
[17:43:33.595]                             break
[17:43:33.595]                           }
[17:43:33.595]                         }
[17:43:33.595]                       }
[17:43:33.595]                       invisible(muffled)
[17:43:33.595]                     }
[17:43:33.595]                     muffleCondition(cond, pattern = "^muffle")
[17:43:33.595]                   }
[17:43:33.595]                 }
[17:43:33.595]                 else {
[17:43:33.595]                   if (TRUE) {
[17:43:33.595]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:33.595]                     {
[17:43:33.595]                       inherits <- base::inherits
[17:43:33.595]                       invokeRestart <- base::invokeRestart
[17:43:33.595]                       is.null <- base::is.null
[17:43:33.595]                       muffled <- FALSE
[17:43:33.595]                       if (inherits(cond, "message")) {
[17:43:33.595]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:33.595]                         if (muffled) 
[17:43:33.595]                           invokeRestart("muffleMessage")
[17:43:33.595]                       }
[17:43:33.595]                       else if (inherits(cond, "warning")) {
[17:43:33.595]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:33.595]                         if (muffled) 
[17:43:33.595]                           invokeRestart("muffleWarning")
[17:43:33.595]                       }
[17:43:33.595]                       else if (inherits(cond, "condition")) {
[17:43:33.595]                         if (!is.null(pattern)) {
[17:43:33.595]                           computeRestarts <- base::computeRestarts
[17:43:33.595]                           grepl <- base::grepl
[17:43:33.595]                           restarts <- computeRestarts(cond)
[17:43:33.595]                           for (restart in restarts) {
[17:43:33.595]                             name <- restart$name
[17:43:33.595]                             if (is.null(name)) 
[17:43:33.595]                               next
[17:43:33.595]                             if (!grepl(pattern, name)) 
[17:43:33.595]                               next
[17:43:33.595]                             invokeRestart(restart)
[17:43:33.595]                             muffled <- TRUE
[17:43:33.595]                             break
[17:43:33.595]                           }
[17:43:33.595]                         }
[17:43:33.595]                       }
[17:43:33.595]                       invisible(muffled)
[17:43:33.595]                     }
[17:43:33.595]                     muffleCondition(cond, pattern = "^muffle")
[17:43:33.595]                   }
[17:43:33.595]                 }
[17:43:33.595]             }
[17:43:33.595]         }))
[17:43:33.595]     }, error = function(ex) {
[17:43:33.595]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:33.595]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:33.595]                 ...future.rng), started = ...future.startTime, 
[17:43:33.595]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:33.595]             version = "1.8"), class = "FutureResult")
[17:43:33.595]     }, finally = {
[17:43:33.595]         if (!identical(...future.workdir, getwd())) 
[17:43:33.595]             setwd(...future.workdir)
[17:43:33.595]         {
[17:43:33.595]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:33.595]                 ...future.oldOptions$nwarnings <- NULL
[17:43:33.595]             }
[17:43:33.595]             base::options(...future.oldOptions)
[17:43:33.595]             if (.Platform$OS.type == "windows") {
[17:43:33.595]                 old_names <- names(...future.oldEnvVars)
[17:43:33.595]                 envs <- base::Sys.getenv()
[17:43:33.595]                 names <- names(envs)
[17:43:33.595]                 common <- intersect(names, old_names)
[17:43:33.595]                 added <- setdiff(names, old_names)
[17:43:33.595]                 removed <- setdiff(old_names, names)
[17:43:33.595]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:33.595]                   envs[common]]
[17:43:33.595]                 NAMES <- toupper(changed)
[17:43:33.595]                 args <- list()
[17:43:33.595]                 for (kk in seq_along(NAMES)) {
[17:43:33.595]                   name <- changed[[kk]]
[17:43:33.595]                   NAME <- NAMES[[kk]]
[17:43:33.595]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:33.595]                     next
[17:43:33.595]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:33.595]                 }
[17:43:33.595]                 NAMES <- toupper(added)
[17:43:33.595]                 for (kk in seq_along(NAMES)) {
[17:43:33.595]                   name <- added[[kk]]
[17:43:33.595]                   NAME <- NAMES[[kk]]
[17:43:33.595]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:33.595]                     next
[17:43:33.595]                   args[[name]] <- ""
[17:43:33.595]                 }
[17:43:33.595]                 NAMES <- toupper(removed)
[17:43:33.595]                 for (kk in seq_along(NAMES)) {
[17:43:33.595]                   name <- removed[[kk]]
[17:43:33.595]                   NAME <- NAMES[[kk]]
[17:43:33.595]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:33.595]                     next
[17:43:33.595]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:33.595]                 }
[17:43:33.595]                 if (length(args) > 0) 
[17:43:33.595]                   base::do.call(base::Sys.setenv, args = args)
[17:43:33.595]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:33.595]             }
[17:43:33.595]             else {
[17:43:33.595]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:33.595]             }
[17:43:33.595]             {
[17:43:33.595]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:33.595]                   0L) {
[17:43:33.595]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:33.595]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:33.595]                   base::options(opts)
[17:43:33.595]                 }
[17:43:33.595]                 {
[17:43:33.595]                   {
[17:43:33.595]                     NULL
[17:43:33.595]                     RNGkind("Mersenne-Twister")
[17:43:33.595]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:33.595]                       inherits = FALSE)
[17:43:33.595]                   }
[17:43:33.595]                   options(future.plan = NULL)
[17:43:33.595]                   if (is.na(NA_character_)) 
[17:43:33.595]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:33.595]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:33.595]                   future::plan(list(function (..., envir = parent.frame()) 
[17:43:33.595]                   {
[17:43:33.595]                     future <- SequentialFuture(..., envir = envir)
[17:43:33.595]                     if (!future$lazy) 
[17:43:33.595]                       future <- run(future)
[17:43:33.595]                     invisible(future)
[17:43:33.595]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:33.595]                 }
[17:43:33.595]             }
[17:43:33.595]         }
[17:43:33.595]     })
[17:43:33.595]     if (TRUE) {
[17:43:33.595]         base::sink(type = "output", split = FALSE)
[17:43:33.595]         if (TRUE) {
[17:43:33.595]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:33.595]         }
[17:43:33.595]         else {
[17:43:33.595]             ...future.result["stdout"] <- base::list(NULL)
[17:43:33.595]         }
[17:43:33.595]         base::close(...future.stdout)
[17:43:33.595]         ...future.stdout <- NULL
[17:43:33.595]     }
[17:43:33.595]     ...future.result$conditions <- ...future.conditions
[17:43:33.595]     ...future.result$finished <- base::Sys.time()
[17:43:33.595]     ...future.result
[17:43:33.595] }
[17:43:33.596] assign_globals() ...
[17:43:33.597] List of 1
[17:43:33.597]  $ kk: int 1
[17:43:33.597]  - attr(*, "where")=List of 1
[17:43:33.597]   ..$ kk:<environment: R_EmptyEnv> 
[17:43:33.597]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:33.597]  - attr(*, "resolved")= logi FALSE
[17:43:33.597]  - attr(*, "total_size")= num 56
[17:43:33.597]  - attr(*, "already-done")= logi TRUE
[17:43:33.599] - copied ‘kk’ to environment
[17:43:33.599] assign_globals() ... done
[17:43:33.599] plan(): Setting new future strategy stack:
[17:43:33.599] List of future strategies:
[17:43:33.599] 1. sequential:
[17:43:33.599]    - args: function (..., envir = parent.frame())
[17:43:33.599]    - tweaked: FALSE
[17:43:33.599]    - call: NULL
[17:43:33.600] plan(): nbrOfWorkers() = 1
[17:43:33.701] plan(): Setting new future strategy stack:
[17:43:33.701] List of future strategies:
[17:43:33.701] 1. sequential:
[17:43:33.701]    - args: function (..., envir = parent.frame())
[17:43:33.701]    - tweaked: FALSE
[17:43:33.701]    - call: plan(strategy)
[17:43:33.702] plan(): nbrOfWorkers() = 1
[17:43:33.702] SequentialFuture started (and completed)
[17:43:33.702] - Launch lazy future ... done
[17:43:33.702] run() for ‘SequentialFuture’ ... done
[17:43:33.702] resolved() for ‘SequentialFuture’ ...
[17:43:33.702] - state: ‘finished’
[17:43:33.702] - run: TRUE
[17:43:33.702] - result: ‘FutureResult’
[17:43:33.703] resolved() for ‘SequentialFuture’ ... done
[17:43:33.703] Future #1
[17:43:33.703]  length: 2 (resolved future 1)
[17:43:33.703] run() for ‘Future’ ...
[17:43:33.703] - state: ‘created’
[17:43:33.703] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:33.703] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:33.704] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:33.704]   - Field: ‘label’
[17:43:33.704]   - Field: ‘local’
[17:43:33.704]   - Field: ‘owner’
[17:43:33.704]   - Field: ‘envir’
[17:43:33.704]   - Field: ‘packages’
[17:43:33.704]   - Field: ‘gc’
[17:43:33.704]   - Field: ‘conditions’
[17:43:33.704]   - Field: ‘expr’
[17:43:33.704]   - Field: ‘uuid’
[17:43:33.705]   - Field: ‘seed’
[17:43:33.705]   - Field: ‘version’
[17:43:33.705]   - Field: ‘result’
[17:43:33.705]   - Field: ‘asynchronous’
[17:43:33.705]   - Field: ‘calls’
[17:43:33.705]   - Field: ‘globals’
[17:43:33.705]   - Field: ‘stdout’
[17:43:33.705]   - Field: ‘earlySignal’
[17:43:33.705]   - Field: ‘lazy’
[17:43:33.705]   - Field: ‘state’
[17:43:33.705] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:33.706] - Launch lazy future ...
[17:43:33.706] Packages needed by the future expression (n = 0): <none>
[17:43:33.706] Packages needed by future strategies (n = 0): <none>
[17:43:33.706] {
[17:43:33.706]     {
[17:43:33.706]         {
[17:43:33.706]             ...future.startTime <- base::Sys.time()
[17:43:33.706]             {
[17:43:33.706]                 {
[17:43:33.706]                   {
[17:43:33.706]                     base::local({
[17:43:33.706]                       has_future <- base::requireNamespace("future", 
[17:43:33.706]                         quietly = TRUE)
[17:43:33.706]                       if (has_future) {
[17:43:33.706]                         ns <- base::getNamespace("future")
[17:43:33.706]                         version <- ns[[".package"]][["version"]]
[17:43:33.706]                         if (is.null(version)) 
[17:43:33.706]                           version <- utils::packageVersion("future")
[17:43:33.706]                       }
[17:43:33.706]                       else {
[17:43:33.706]                         version <- NULL
[17:43:33.706]                       }
[17:43:33.706]                       if (!has_future || version < "1.8.0") {
[17:43:33.706]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:33.706]                           "", base::R.version$version.string), 
[17:43:33.706]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:33.706]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:33.706]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:33.706]                             "release", "version")], collapse = " "), 
[17:43:33.706]                           hostname = base::Sys.info()[["nodename"]])
[17:43:33.706]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:33.706]                           info)
[17:43:33.706]                         info <- base::paste(info, collapse = "; ")
[17:43:33.706]                         if (!has_future) {
[17:43:33.706]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:33.706]                             info)
[17:43:33.706]                         }
[17:43:33.706]                         else {
[17:43:33.706]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:33.706]                             info, version)
[17:43:33.706]                         }
[17:43:33.706]                         base::stop(msg)
[17:43:33.706]                       }
[17:43:33.706]                     })
[17:43:33.706]                   }
[17:43:33.706]                   options(future.plan = NULL)
[17:43:33.706]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:33.706]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:33.706]                 }
[17:43:33.706]                 ...future.workdir <- getwd()
[17:43:33.706]             }
[17:43:33.706]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:33.706]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:33.706]         }
[17:43:33.706]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:33.706]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:33.706]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:33.706]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:33.706]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:33.706]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:33.706]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:33.706]             base::names(...future.oldOptions))
[17:43:33.706]     }
[17:43:33.706]     if (FALSE) {
[17:43:33.706]     }
[17:43:33.706]     else {
[17:43:33.706]         if (TRUE) {
[17:43:33.706]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:33.706]                 open = "w")
[17:43:33.706]         }
[17:43:33.706]         else {
[17:43:33.706]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:33.706]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:33.706]         }
[17:43:33.706]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:33.706]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:33.706]             base::sink(type = "output", split = FALSE)
[17:43:33.706]             base::close(...future.stdout)
[17:43:33.706]         }, add = TRUE)
[17:43:33.706]     }
[17:43:33.706]     ...future.frame <- base::sys.nframe()
[17:43:33.706]     ...future.conditions <- base::list()
[17:43:33.706]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:33.706]     if (FALSE) {
[17:43:33.706]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:33.706]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:33.706]     }
[17:43:33.706]     ...future.result <- base::tryCatch({
[17:43:33.706]         base::withCallingHandlers({
[17:43:33.706]             ...future.value <- base::withVisible(base::local({
[17:43:33.706]                 Sys.sleep(0.1)
[17:43:33.706]                 kk
[17:43:33.706]             }))
[17:43:33.706]             future::FutureResult(value = ...future.value$value, 
[17:43:33.706]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:33.706]                   ...future.rng), globalenv = if (FALSE) 
[17:43:33.706]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:33.706]                     ...future.globalenv.names))
[17:43:33.706]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:33.706]         }, condition = base::local({
[17:43:33.706]             c <- base::c
[17:43:33.706]             inherits <- base::inherits
[17:43:33.706]             invokeRestart <- base::invokeRestart
[17:43:33.706]             length <- base::length
[17:43:33.706]             list <- base::list
[17:43:33.706]             seq.int <- base::seq.int
[17:43:33.706]             signalCondition <- base::signalCondition
[17:43:33.706]             sys.calls <- base::sys.calls
[17:43:33.706]             `[[` <- base::`[[`
[17:43:33.706]             `+` <- base::`+`
[17:43:33.706]             `<<-` <- base::`<<-`
[17:43:33.706]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:33.706]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:33.706]                   3L)]
[17:43:33.706]             }
[17:43:33.706]             function(cond) {
[17:43:33.706]                 is_error <- inherits(cond, "error")
[17:43:33.706]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:33.706]                   NULL)
[17:43:33.706]                 if (is_error) {
[17:43:33.706]                   sessionInformation <- function() {
[17:43:33.706]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:33.706]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:33.706]                       search = base::search(), system = base::Sys.info())
[17:43:33.706]                   }
[17:43:33.706]                   ...future.conditions[[length(...future.conditions) + 
[17:43:33.706]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:33.706]                     cond$call), session = sessionInformation(), 
[17:43:33.706]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:33.706]                   signalCondition(cond)
[17:43:33.706]                 }
[17:43:33.706]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:33.706]                 "immediateCondition"))) {
[17:43:33.706]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:33.706]                   ...future.conditions[[length(...future.conditions) + 
[17:43:33.706]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:33.706]                   if (TRUE && !signal) {
[17:43:33.706]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:33.706]                     {
[17:43:33.706]                       inherits <- base::inherits
[17:43:33.706]                       invokeRestart <- base::invokeRestart
[17:43:33.706]                       is.null <- base::is.null
[17:43:33.706]                       muffled <- FALSE
[17:43:33.706]                       if (inherits(cond, "message")) {
[17:43:33.706]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:33.706]                         if (muffled) 
[17:43:33.706]                           invokeRestart("muffleMessage")
[17:43:33.706]                       }
[17:43:33.706]                       else if (inherits(cond, "warning")) {
[17:43:33.706]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:33.706]                         if (muffled) 
[17:43:33.706]                           invokeRestart("muffleWarning")
[17:43:33.706]                       }
[17:43:33.706]                       else if (inherits(cond, "condition")) {
[17:43:33.706]                         if (!is.null(pattern)) {
[17:43:33.706]                           computeRestarts <- base::computeRestarts
[17:43:33.706]                           grepl <- base::grepl
[17:43:33.706]                           restarts <- computeRestarts(cond)
[17:43:33.706]                           for (restart in restarts) {
[17:43:33.706]                             name <- restart$name
[17:43:33.706]                             if (is.null(name)) 
[17:43:33.706]                               next
[17:43:33.706]                             if (!grepl(pattern, name)) 
[17:43:33.706]                               next
[17:43:33.706]                             invokeRestart(restart)
[17:43:33.706]                             muffled <- TRUE
[17:43:33.706]                             break
[17:43:33.706]                           }
[17:43:33.706]                         }
[17:43:33.706]                       }
[17:43:33.706]                       invisible(muffled)
[17:43:33.706]                     }
[17:43:33.706]                     muffleCondition(cond, pattern = "^muffle")
[17:43:33.706]                   }
[17:43:33.706]                 }
[17:43:33.706]                 else {
[17:43:33.706]                   if (TRUE) {
[17:43:33.706]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:33.706]                     {
[17:43:33.706]                       inherits <- base::inherits
[17:43:33.706]                       invokeRestart <- base::invokeRestart
[17:43:33.706]                       is.null <- base::is.null
[17:43:33.706]                       muffled <- FALSE
[17:43:33.706]                       if (inherits(cond, "message")) {
[17:43:33.706]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:33.706]                         if (muffled) 
[17:43:33.706]                           invokeRestart("muffleMessage")
[17:43:33.706]                       }
[17:43:33.706]                       else if (inherits(cond, "warning")) {
[17:43:33.706]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:33.706]                         if (muffled) 
[17:43:33.706]                           invokeRestart("muffleWarning")
[17:43:33.706]                       }
[17:43:33.706]                       else if (inherits(cond, "condition")) {
[17:43:33.706]                         if (!is.null(pattern)) {
[17:43:33.706]                           computeRestarts <- base::computeRestarts
[17:43:33.706]                           grepl <- base::grepl
[17:43:33.706]                           restarts <- computeRestarts(cond)
[17:43:33.706]                           for (restart in restarts) {
[17:43:33.706]                             name <- restart$name
[17:43:33.706]                             if (is.null(name)) 
[17:43:33.706]                               next
[17:43:33.706]                             if (!grepl(pattern, name)) 
[17:43:33.706]                               next
[17:43:33.706]                             invokeRestart(restart)
[17:43:33.706]                             muffled <- TRUE
[17:43:33.706]                             break
[17:43:33.706]                           }
[17:43:33.706]                         }
[17:43:33.706]                       }
[17:43:33.706]                       invisible(muffled)
[17:43:33.706]                     }
[17:43:33.706]                     muffleCondition(cond, pattern = "^muffle")
[17:43:33.706]                   }
[17:43:33.706]                 }
[17:43:33.706]             }
[17:43:33.706]         }))
[17:43:33.706]     }, error = function(ex) {
[17:43:33.706]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:33.706]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:33.706]                 ...future.rng), started = ...future.startTime, 
[17:43:33.706]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:33.706]             version = "1.8"), class = "FutureResult")
[17:43:33.706]     }, finally = {
[17:43:33.706]         if (!identical(...future.workdir, getwd())) 
[17:43:33.706]             setwd(...future.workdir)
[17:43:33.706]         {
[17:43:33.706]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:33.706]                 ...future.oldOptions$nwarnings <- NULL
[17:43:33.706]             }
[17:43:33.706]             base::options(...future.oldOptions)
[17:43:33.706]             if (.Platform$OS.type == "windows") {
[17:43:33.706]                 old_names <- names(...future.oldEnvVars)
[17:43:33.706]                 envs <- base::Sys.getenv()
[17:43:33.706]                 names <- names(envs)
[17:43:33.706]                 common <- intersect(names, old_names)
[17:43:33.706]                 added <- setdiff(names, old_names)
[17:43:33.706]                 removed <- setdiff(old_names, names)
[17:43:33.706]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:33.706]                   envs[common]]
[17:43:33.706]                 NAMES <- toupper(changed)
[17:43:33.706]                 args <- list()
[17:43:33.706]                 for (kk in seq_along(NAMES)) {
[17:43:33.706]                   name <- changed[[kk]]
[17:43:33.706]                   NAME <- NAMES[[kk]]
[17:43:33.706]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:33.706]                     next
[17:43:33.706]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:33.706]                 }
[17:43:33.706]                 NAMES <- toupper(added)
[17:43:33.706]                 for (kk in seq_along(NAMES)) {
[17:43:33.706]                   name <- added[[kk]]
[17:43:33.706]                   NAME <- NAMES[[kk]]
[17:43:33.706]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:33.706]                     next
[17:43:33.706]                   args[[name]] <- ""
[17:43:33.706]                 }
[17:43:33.706]                 NAMES <- toupper(removed)
[17:43:33.706]                 for (kk in seq_along(NAMES)) {
[17:43:33.706]                   name <- removed[[kk]]
[17:43:33.706]                   NAME <- NAMES[[kk]]
[17:43:33.706]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:33.706]                     next
[17:43:33.706]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:33.706]                 }
[17:43:33.706]                 if (length(args) > 0) 
[17:43:33.706]                   base::do.call(base::Sys.setenv, args = args)
[17:43:33.706]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:33.706]             }
[17:43:33.706]             else {
[17:43:33.706]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:33.706]             }
[17:43:33.706]             {
[17:43:33.706]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:33.706]                   0L) {
[17:43:33.706]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:33.706]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:33.706]                   base::options(opts)
[17:43:33.706]                 }
[17:43:33.706]                 {
[17:43:33.706]                   {
[17:43:33.706]                     NULL
[17:43:33.706]                     RNGkind("Mersenne-Twister")
[17:43:33.706]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:33.706]                       inherits = FALSE)
[17:43:33.706]                   }
[17:43:33.706]                   options(future.plan = NULL)
[17:43:33.706]                   if (is.na(NA_character_)) 
[17:43:33.706]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:33.706]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:33.706]                   future::plan(list(function (..., envir = parent.frame()) 
[17:43:33.706]                   {
[17:43:33.706]                     future <- SequentialFuture(..., envir = envir)
[17:43:33.706]                     if (!future$lazy) 
[17:43:33.706]                       future <- run(future)
[17:43:33.706]                     invisible(future)
[17:43:33.706]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:33.706]                 }
[17:43:33.706]             }
[17:43:33.706]         }
[17:43:33.706]     })
[17:43:33.706]     if (TRUE) {
[17:43:33.706]         base::sink(type = "output", split = FALSE)
[17:43:33.706]         if (TRUE) {
[17:43:33.706]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:33.706]         }
[17:43:33.706]         else {
[17:43:33.706]             ...future.result["stdout"] <- base::list(NULL)
[17:43:33.706]         }
[17:43:33.706]         base::close(...future.stdout)
[17:43:33.706]         ...future.stdout <- NULL
[17:43:33.706]     }
[17:43:33.706]     ...future.result$conditions <- ...future.conditions
[17:43:33.706]     ...future.result$finished <- base::Sys.time()
[17:43:33.706]     ...future.result
[17:43:33.706] }
[17:43:33.708] assign_globals() ...
[17:43:33.708] List of 1
[17:43:33.708]  $ kk: int 2
[17:43:33.708]  - attr(*, "where")=List of 1
[17:43:33.708]   ..$ kk:<environment: R_EmptyEnv> 
[17:43:33.708]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:33.708]  - attr(*, "resolved")= logi FALSE
[17:43:33.708]  - attr(*, "total_size")= num 56
[17:43:33.708]  - attr(*, "already-done")= logi TRUE
[17:43:33.712] - copied ‘kk’ to environment
[17:43:33.712] assign_globals() ... done
[17:43:33.713] plan(): Setting new future strategy stack:
[17:43:33.713] List of future strategies:
[17:43:33.713] 1. sequential:
[17:43:33.713]    - args: function (..., envir = parent.frame())
[17:43:33.713]    - tweaked: FALSE
[17:43:33.713]    - call: NULL
[17:43:33.713] plan(): nbrOfWorkers() = 1
[17:43:33.814] plan(): Setting new future strategy stack:
[17:43:33.814] List of future strategies:
[17:43:33.814] 1. sequential:
[17:43:33.814]    - args: function (..., envir = parent.frame())
[17:43:33.814]    - tweaked: FALSE
[17:43:33.814]    - call: plan(strategy)
[17:43:33.815] plan(): nbrOfWorkers() = 1
[17:43:33.815] SequentialFuture started (and completed)
[17:43:33.815] - Launch lazy future ... done
[17:43:33.815] run() for ‘SequentialFuture’ ... done
[17:43:33.816] resolved() for ‘SequentialFuture’ ...
[17:43:33.816] - state: ‘finished’
[17:43:33.816] - run: TRUE
[17:43:33.816] - result: ‘FutureResult’
[17:43:33.816] resolved() for ‘SequentialFuture’ ... done
[17:43:33.816] Future #2
[17:43:33.816]  length: 1 (resolved future 2)
[17:43:33.816] run() for ‘Future’ ...
[17:43:33.816] - state: ‘created’
[17:43:33.817] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:33.817] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:33.817] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:33.817]   - Field: ‘label’
[17:43:33.817]   - Field: ‘local’
[17:43:33.817]   - Field: ‘owner’
[17:43:33.817]   - Field: ‘envir’
[17:43:33.817]   - Field: ‘packages’
[17:43:33.818]   - Field: ‘gc’
[17:43:33.818]   - Field: ‘conditions’
[17:43:33.818]   - Field: ‘expr’
[17:43:33.818]   - Field: ‘uuid’
[17:43:33.818]   - Field: ‘seed’
[17:43:33.818]   - Field: ‘version’
[17:43:33.818]   - Field: ‘result’
[17:43:33.818]   - Field: ‘asynchronous’
[17:43:33.818]   - Field: ‘calls’
[17:43:33.818]   - Field: ‘globals’
[17:43:33.818]   - Field: ‘stdout’
[17:43:33.819]   - Field: ‘earlySignal’
[17:43:33.819]   - Field: ‘lazy’
[17:43:33.819]   - Field: ‘state’
[17:43:33.819] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:33.819] - Launch lazy future ...
[17:43:33.819] Packages needed by the future expression (n = 0): <none>
[17:43:33.819] Packages needed by future strategies (n = 0): <none>
[17:43:33.820] {
[17:43:33.820]     {
[17:43:33.820]         {
[17:43:33.820]             ...future.startTime <- base::Sys.time()
[17:43:33.820]             {
[17:43:33.820]                 {
[17:43:33.820]                   {
[17:43:33.820]                     base::local({
[17:43:33.820]                       has_future <- base::requireNamespace("future", 
[17:43:33.820]                         quietly = TRUE)
[17:43:33.820]                       if (has_future) {
[17:43:33.820]                         ns <- base::getNamespace("future")
[17:43:33.820]                         version <- ns[[".package"]][["version"]]
[17:43:33.820]                         if (is.null(version)) 
[17:43:33.820]                           version <- utils::packageVersion("future")
[17:43:33.820]                       }
[17:43:33.820]                       else {
[17:43:33.820]                         version <- NULL
[17:43:33.820]                       }
[17:43:33.820]                       if (!has_future || version < "1.8.0") {
[17:43:33.820]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:33.820]                           "", base::R.version$version.string), 
[17:43:33.820]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:33.820]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:33.820]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:33.820]                             "release", "version")], collapse = " "), 
[17:43:33.820]                           hostname = base::Sys.info()[["nodename"]])
[17:43:33.820]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:33.820]                           info)
[17:43:33.820]                         info <- base::paste(info, collapse = "; ")
[17:43:33.820]                         if (!has_future) {
[17:43:33.820]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:33.820]                             info)
[17:43:33.820]                         }
[17:43:33.820]                         else {
[17:43:33.820]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:33.820]                             info, version)
[17:43:33.820]                         }
[17:43:33.820]                         base::stop(msg)
[17:43:33.820]                       }
[17:43:33.820]                     })
[17:43:33.820]                   }
[17:43:33.820]                   options(future.plan = NULL)
[17:43:33.820]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:33.820]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:33.820]                 }
[17:43:33.820]                 ...future.workdir <- getwd()
[17:43:33.820]             }
[17:43:33.820]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:33.820]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:33.820]         }
[17:43:33.820]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:33.820]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:33.820]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:33.820]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:33.820]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:33.820]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:33.820]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:33.820]             base::names(...future.oldOptions))
[17:43:33.820]     }
[17:43:33.820]     if (FALSE) {
[17:43:33.820]     }
[17:43:33.820]     else {
[17:43:33.820]         if (TRUE) {
[17:43:33.820]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:33.820]                 open = "w")
[17:43:33.820]         }
[17:43:33.820]         else {
[17:43:33.820]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:33.820]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:33.820]         }
[17:43:33.820]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:33.820]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:33.820]             base::sink(type = "output", split = FALSE)
[17:43:33.820]             base::close(...future.stdout)
[17:43:33.820]         }, add = TRUE)
[17:43:33.820]     }
[17:43:33.820]     ...future.frame <- base::sys.nframe()
[17:43:33.820]     ...future.conditions <- base::list()
[17:43:33.820]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:33.820]     if (FALSE) {
[17:43:33.820]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:33.820]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:33.820]     }
[17:43:33.820]     ...future.result <- base::tryCatch({
[17:43:33.820]         base::withCallingHandlers({
[17:43:33.820]             ...future.value <- base::withVisible(base::local({
[17:43:33.820]                 Sys.sleep(0.1)
[17:43:33.820]                 kk
[17:43:33.820]             }))
[17:43:33.820]             future::FutureResult(value = ...future.value$value, 
[17:43:33.820]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:33.820]                   ...future.rng), globalenv = if (FALSE) 
[17:43:33.820]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:33.820]                     ...future.globalenv.names))
[17:43:33.820]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:33.820]         }, condition = base::local({
[17:43:33.820]             c <- base::c
[17:43:33.820]             inherits <- base::inherits
[17:43:33.820]             invokeRestart <- base::invokeRestart
[17:43:33.820]             length <- base::length
[17:43:33.820]             list <- base::list
[17:43:33.820]             seq.int <- base::seq.int
[17:43:33.820]             signalCondition <- base::signalCondition
[17:43:33.820]             sys.calls <- base::sys.calls
[17:43:33.820]             `[[` <- base::`[[`
[17:43:33.820]             `+` <- base::`+`
[17:43:33.820]             `<<-` <- base::`<<-`
[17:43:33.820]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:33.820]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:33.820]                   3L)]
[17:43:33.820]             }
[17:43:33.820]             function(cond) {
[17:43:33.820]                 is_error <- inherits(cond, "error")
[17:43:33.820]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:33.820]                   NULL)
[17:43:33.820]                 if (is_error) {
[17:43:33.820]                   sessionInformation <- function() {
[17:43:33.820]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:33.820]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:33.820]                       search = base::search(), system = base::Sys.info())
[17:43:33.820]                   }
[17:43:33.820]                   ...future.conditions[[length(...future.conditions) + 
[17:43:33.820]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:33.820]                     cond$call), session = sessionInformation(), 
[17:43:33.820]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:33.820]                   signalCondition(cond)
[17:43:33.820]                 }
[17:43:33.820]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:33.820]                 "immediateCondition"))) {
[17:43:33.820]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:33.820]                   ...future.conditions[[length(...future.conditions) + 
[17:43:33.820]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:33.820]                   if (TRUE && !signal) {
[17:43:33.820]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:33.820]                     {
[17:43:33.820]                       inherits <- base::inherits
[17:43:33.820]                       invokeRestart <- base::invokeRestart
[17:43:33.820]                       is.null <- base::is.null
[17:43:33.820]                       muffled <- FALSE
[17:43:33.820]                       if (inherits(cond, "message")) {
[17:43:33.820]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:33.820]                         if (muffled) 
[17:43:33.820]                           invokeRestart("muffleMessage")
[17:43:33.820]                       }
[17:43:33.820]                       else if (inherits(cond, "warning")) {
[17:43:33.820]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:33.820]                         if (muffled) 
[17:43:33.820]                           invokeRestart("muffleWarning")
[17:43:33.820]                       }
[17:43:33.820]                       else if (inherits(cond, "condition")) {
[17:43:33.820]                         if (!is.null(pattern)) {
[17:43:33.820]                           computeRestarts <- base::computeRestarts
[17:43:33.820]                           grepl <- base::grepl
[17:43:33.820]                           restarts <- computeRestarts(cond)
[17:43:33.820]                           for (restart in restarts) {
[17:43:33.820]                             name <- restart$name
[17:43:33.820]                             if (is.null(name)) 
[17:43:33.820]                               next
[17:43:33.820]                             if (!grepl(pattern, name)) 
[17:43:33.820]                               next
[17:43:33.820]                             invokeRestart(restart)
[17:43:33.820]                             muffled <- TRUE
[17:43:33.820]                             break
[17:43:33.820]                           }
[17:43:33.820]                         }
[17:43:33.820]                       }
[17:43:33.820]                       invisible(muffled)
[17:43:33.820]                     }
[17:43:33.820]                     muffleCondition(cond, pattern = "^muffle")
[17:43:33.820]                   }
[17:43:33.820]                 }
[17:43:33.820]                 else {
[17:43:33.820]                   if (TRUE) {
[17:43:33.820]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:33.820]                     {
[17:43:33.820]                       inherits <- base::inherits
[17:43:33.820]                       invokeRestart <- base::invokeRestart
[17:43:33.820]                       is.null <- base::is.null
[17:43:33.820]                       muffled <- FALSE
[17:43:33.820]                       if (inherits(cond, "message")) {
[17:43:33.820]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:33.820]                         if (muffled) 
[17:43:33.820]                           invokeRestart("muffleMessage")
[17:43:33.820]                       }
[17:43:33.820]                       else if (inherits(cond, "warning")) {
[17:43:33.820]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:33.820]                         if (muffled) 
[17:43:33.820]                           invokeRestart("muffleWarning")
[17:43:33.820]                       }
[17:43:33.820]                       else if (inherits(cond, "condition")) {
[17:43:33.820]                         if (!is.null(pattern)) {
[17:43:33.820]                           computeRestarts <- base::computeRestarts
[17:43:33.820]                           grepl <- base::grepl
[17:43:33.820]                           restarts <- computeRestarts(cond)
[17:43:33.820]                           for (restart in restarts) {
[17:43:33.820]                             name <- restart$name
[17:43:33.820]                             if (is.null(name)) 
[17:43:33.820]                               next
[17:43:33.820]                             if (!grepl(pattern, name)) 
[17:43:33.820]                               next
[17:43:33.820]                             invokeRestart(restart)
[17:43:33.820]                             muffled <- TRUE
[17:43:33.820]                             break
[17:43:33.820]                           }
[17:43:33.820]                         }
[17:43:33.820]                       }
[17:43:33.820]                       invisible(muffled)
[17:43:33.820]                     }
[17:43:33.820]                     muffleCondition(cond, pattern = "^muffle")
[17:43:33.820]                   }
[17:43:33.820]                 }
[17:43:33.820]             }
[17:43:33.820]         }))
[17:43:33.820]     }, error = function(ex) {
[17:43:33.820]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:33.820]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:33.820]                 ...future.rng), started = ...future.startTime, 
[17:43:33.820]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:33.820]             version = "1.8"), class = "FutureResult")
[17:43:33.820]     }, finally = {
[17:43:33.820]         if (!identical(...future.workdir, getwd())) 
[17:43:33.820]             setwd(...future.workdir)
[17:43:33.820]         {
[17:43:33.820]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:33.820]                 ...future.oldOptions$nwarnings <- NULL
[17:43:33.820]             }
[17:43:33.820]             base::options(...future.oldOptions)
[17:43:33.820]             if (.Platform$OS.type == "windows") {
[17:43:33.820]                 old_names <- names(...future.oldEnvVars)
[17:43:33.820]                 envs <- base::Sys.getenv()
[17:43:33.820]                 names <- names(envs)
[17:43:33.820]                 common <- intersect(names, old_names)
[17:43:33.820]                 added <- setdiff(names, old_names)
[17:43:33.820]                 removed <- setdiff(old_names, names)
[17:43:33.820]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:33.820]                   envs[common]]
[17:43:33.820]                 NAMES <- toupper(changed)
[17:43:33.820]                 args <- list()
[17:43:33.820]                 for (kk in seq_along(NAMES)) {
[17:43:33.820]                   name <- changed[[kk]]
[17:43:33.820]                   NAME <- NAMES[[kk]]
[17:43:33.820]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:33.820]                     next
[17:43:33.820]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:33.820]                 }
[17:43:33.820]                 NAMES <- toupper(added)
[17:43:33.820]                 for (kk in seq_along(NAMES)) {
[17:43:33.820]                   name <- added[[kk]]
[17:43:33.820]                   NAME <- NAMES[[kk]]
[17:43:33.820]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:33.820]                     next
[17:43:33.820]                   args[[name]] <- ""
[17:43:33.820]                 }
[17:43:33.820]                 NAMES <- toupper(removed)
[17:43:33.820]                 for (kk in seq_along(NAMES)) {
[17:43:33.820]                   name <- removed[[kk]]
[17:43:33.820]                   NAME <- NAMES[[kk]]
[17:43:33.820]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:33.820]                     next
[17:43:33.820]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:33.820]                 }
[17:43:33.820]                 if (length(args) > 0) 
[17:43:33.820]                   base::do.call(base::Sys.setenv, args = args)
[17:43:33.820]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:33.820]             }
[17:43:33.820]             else {
[17:43:33.820]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:33.820]             }
[17:43:33.820]             {
[17:43:33.820]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:33.820]                   0L) {
[17:43:33.820]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:33.820]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:33.820]                   base::options(opts)
[17:43:33.820]                 }
[17:43:33.820]                 {
[17:43:33.820]                   {
[17:43:33.820]                     NULL
[17:43:33.820]                     RNGkind("Mersenne-Twister")
[17:43:33.820]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:33.820]                       inherits = FALSE)
[17:43:33.820]                   }
[17:43:33.820]                   options(future.plan = NULL)
[17:43:33.820]                   if (is.na(NA_character_)) 
[17:43:33.820]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:33.820]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:33.820]                   future::plan(list(function (..., envir = parent.frame()) 
[17:43:33.820]                   {
[17:43:33.820]                     future <- SequentialFuture(..., envir = envir)
[17:43:33.820]                     if (!future$lazy) 
[17:43:33.820]                       future <- run(future)
[17:43:33.820]                     invisible(future)
[17:43:33.820]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:33.820]                 }
[17:43:33.820]             }
[17:43:33.820]         }
[17:43:33.820]     })
[17:43:33.820]     if (TRUE) {
[17:43:33.820]         base::sink(type = "output", split = FALSE)
[17:43:33.820]         if (TRUE) {
[17:43:33.820]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:33.820]         }
[17:43:33.820]         else {
[17:43:33.820]             ...future.result["stdout"] <- base::list(NULL)
[17:43:33.820]         }
[17:43:33.820]         base::close(...future.stdout)
[17:43:33.820]         ...future.stdout <- NULL
[17:43:33.820]     }
[17:43:33.820]     ...future.result$conditions <- ...future.conditions
[17:43:33.820]     ...future.result$finished <- base::Sys.time()
[17:43:33.820]     ...future.result
[17:43:33.820] }
[17:43:33.821] assign_globals() ...
[17:43:33.821] List of 1
[17:43:33.821]  $ kk: int 3
[17:43:33.821]  - attr(*, "where")=List of 1
[17:43:33.821]   ..$ kk:<environment: R_EmptyEnv> 
[17:43:33.821]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:33.821]  - attr(*, "resolved")= logi FALSE
[17:43:33.821]  - attr(*, "total_size")= num 56
[17:43:33.821]  - attr(*, "already-done")= logi TRUE
[17:43:33.824] - copied ‘kk’ to environment
[17:43:33.824] assign_globals() ... done
[17:43:33.824] plan(): Setting new future strategy stack:
[17:43:33.824] List of future strategies:
[17:43:33.824] 1. sequential:
[17:43:33.824]    - args: function (..., envir = parent.frame())
[17:43:33.824]    - tweaked: FALSE
[17:43:33.824]    - call: NULL
[17:43:33.825] plan(): nbrOfWorkers() = 1
[17:43:33.926] plan(): Setting new future strategy stack:
[17:43:33.926] List of future strategies:
[17:43:33.926] 1. sequential:
[17:43:33.926]    - args: function (..., envir = parent.frame())
[17:43:33.926]    - tweaked: FALSE
[17:43:33.926]    - call: plan(strategy)
[17:43:33.927] plan(): nbrOfWorkers() = 1
[17:43:33.927] SequentialFuture started (and completed)
[17:43:33.927] - Launch lazy future ... done
[17:43:33.927] run() for ‘SequentialFuture’ ... done
[17:43:33.927] resolved() for ‘SequentialFuture’ ...
[17:43:33.927] - state: ‘finished’
[17:43:33.927] - run: TRUE
[17:43:33.927] - result: ‘FutureResult’
[17:43:33.928] resolved() for ‘SequentialFuture’ ... done
[17:43:33.928] Future #3
[17:43:33.928]  length: 0 (resolved future 3)
[17:43:33.928] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[17:43:33.929] resolve() on environment ...
[17:43:33.929]  recursive: 0
[17:43:33.930]  elements: [2] ‘a’, ‘b’
[17:43:33.930]  length: 1 (resolved future 1)
[17:43:33.930]  length: 0 (resolved future 2)
[17:43:33.930] resolve() on environment ... DONE
[17:43:33.931] getGlobalsAndPackages() ...
[17:43:33.931] Searching for globals...
[17:43:33.931] 
[17:43:33.931] Searching for globals ... DONE
[17:43:33.931] - globals: [0] <none>
[17:43:33.931] getGlobalsAndPackages() ... DONE
[17:43:33.932] run() for ‘Future’ ...
[17:43:33.932] - state: ‘created’
[17:43:33.932] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:33.932] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:33.932] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:33.932]   - Field: ‘label’
[17:43:33.933]   - Field: ‘local’
[17:43:33.933]   - Field: ‘owner’
[17:43:33.933]   - Field: ‘envir’
[17:43:33.933]   - Field: ‘packages’
[17:43:33.933]   - Field: ‘gc’
[17:43:33.933]   - Field: ‘conditions’
[17:43:33.933]   - Field: ‘expr’
[17:43:33.933]   - Field: ‘uuid’
[17:43:33.933]   - Field: ‘seed’
[17:43:33.933]   - Field: ‘version’
[17:43:33.933]   - Field: ‘result’
[17:43:33.934]   - Field: ‘asynchronous’
[17:43:33.934]   - Field: ‘calls’
[17:43:33.934]   - Field: ‘globals’
[17:43:33.934]   - Field: ‘stdout’
[17:43:33.934]   - Field: ‘earlySignal’
[17:43:33.934]   - Field: ‘lazy’
[17:43:33.934]   - Field: ‘state’
[17:43:33.935] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:33.935] - Launch lazy future ...
[17:43:33.935] Packages needed by the future expression (n = 0): <none>
[17:43:33.935] Packages needed by future strategies (n = 0): <none>
[17:43:33.935] {
[17:43:33.935]     {
[17:43:33.935]         {
[17:43:33.935]             ...future.startTime <- base::Sys.time()
[17:43:33.935]             {
[17:43:33.935]                 {
[17:43:33.935]                   {
[17:43:33.935]                     base::local({
[17:43:33.935]                       has_future <- base::requireNamespace("future", 
[17:43:33.935]                         quietly = TRUE)
[17:43:33.935]                       if (has_future) {
[17:43:33.935]                         ns <- base::getNamespace("future")
[17:43:33.935]                         version <- ns[[".package"]][["version"]]
[17:43:33.935]                         if (is.null(version)) 
[17:43:33.935]                           version <- utils::packageVersion("future")
[17:43:33.935]                       }
[17:43:33.935]                       else {
[17:43:33.935]                         version <- NULL
[17:43:33.935]                       }
[17:43:33.935]                       if (!has_future || version < "1.8.0") {
[17:43:33.935]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:33.935]                           "", base::R.version$version.string), 
[17:43:33.935]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:33.935]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:33.935]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:33.935]                             "release", "version")], collapse = " "), 
[17:43:33.935]                           hostname = base::Sys.info()[["nodename"]])
[17:43:33.935]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:33.935]                           info)
[17:43:33.935]                         info <- base::paste(info, collapse = "; ")
[17:43:33.935]                         if (!has_future) {
[17:43:33.935]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:33.935]                             info)
[17:43:33.935]                         }
[17:43:33.935]                         else {
[17:43:33.935]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:33.935]                             info, version)
[17:43:33.935]                         }
[17:43:33.935]                         base::stop(msg)
[17:43:33.935]                       }
[17:43:33.935]                     })
[17:43:33.935]                   }
[17:43:33.935]                   options(future.plan = NULL)
[17:43:33.935]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:33.935]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:33.935]                 }
[17:43:33.935]                 ...future.workdir <- getwd()
[17:43:33.935]             }
[17:43:33.935]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:33.935]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:33.935]         }
[17:43:33.935]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:33.935]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:33.935]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:33.935]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:33.935]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:33.935]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:33.935]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:33.935]             base::names(...future.oldOptions))
[17:43:33.935]     }
[17:43:33.935]     if (FALSE) {
[17:43:33.935]     }
[17:43:33.935]     else {
[17:43:33.935]         if (TRUE) {
[17:43:33.935]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:33.935]                 open = "w")
[17:43:33.935]         }
[17:43:33.935]         else {
[17:43:33.935]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:33.935]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:33.935]         }
[17:43:33.935]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:33.935]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:33.935]             base::sink(type = "output", split = FALSE)
[17:43:33.935]             base::close(...future.stdout)
[17:43:33.935]         }, add = TRUE)
[17:43:33.935]     }
[17:43:33.935]     ...future.frame <- base::sys.nframe()
[17:43:33.935]     ...future.conditions <- base::list()
[17:43:33.935]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:33.935]     if (FALSE) {
[17:43:33.935]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:33.935]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:33.935]     }
[17:43:33.935]     ...future.result <- base::tryCatch({
[17:43:33.935]         base::withCallingHandlers({
[17:43:33.935]             ...future.value <- base::withVisible(base::local(1))
[17:43:33.935]             future::FutureResult(value = ...future.value$value, 
[17:43:33.935]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:33.935]                   ...future.rng), globalenv = if (FALSE) 
[17:43:33.935]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:33.935]                     ...future.globalenv.names))
[17:43:33.935]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:33.935]         }, condition = base::local({
[17:43:33.935]             c <- base::c
[17:43:33.935]             inherits <- base::inherits
[17:43:33.935]             invokeRestart <- base::invokeRestart
[17:43:33.935]             length <- base::length
[17:43:33.935]             list <- base::list
[17:43:33.935]             seq.int <- base::seq.int
[17:43:33.935]             signalCondition <- base::signalCondition
[17:43:33.935]             sys.calls <- base::sys.calls
[17:43:33.935]             `[[` <- base::`[[`
[17:43:33.935]             `+` <- base::`+`
[17:43:33.935]             `<<-` <- base::`<<-`
[17:43:33.935]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:33.935]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:33.935]                   3L)]
[17:43:33.935]             }
[17:43:33.935]             function(cond) {
[17:43:33.935]                 is_error <- inherits(cond, "error")
[17:43:33.935]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:33.935]                   NULL)
[17:43:33.935]                 if (is_error) {
[17:43:33.935]                   sessionInformation <- function() {
[17:43:33.935]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:33.935]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:33.935]                       search = base::search(), system = base::Sys.info())
[17:43:33.935]                   }
[17:43:33.935]                   ...future.conditions[[length(...future.conditions) + 
[17:43:33.935]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:33.935]                     cond$call), session = sessionInformation(), 
[17:43:33.935]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:33.935]                   signalCondition(cond)
[17:43:33.935]                 }
[17:43:33.935]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:33.935]                 "immediateCondition"))) {
[17:43:33.935]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:33.935]                   ...future.conditions[[length(...future.conditions) + 
[17:43:33.935]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:33.935]                   if (TRUE && !signal) {
[17:43:33.935]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:33.935]                     {
[17:43:33.935]                       inherits <- base::inherits
[17:43:33.935]                       invokeRestart <- base::invokeRestart
[17:43:33.935]                       is.null <- base::is.null
[17:43:33.935]                       muffled <- FALSE
[17:43:33.935]                       if (inherits(cond, "message")) {
[17:43:33.935]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:33.935]                         if (muffled) 
[17:43:33.935]                           invokeRestart("muffleMessage")
[17:43:33.935]                       }
[17:43:33.935]                       else if (inherits(cond, "warning")) {
[17:43:33.935]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:33.935]                         if (muffled) 
[17:43:33.935]                           invokeRestart("muffleWarning")
[17:43:33.935]                       }
[17:43:33.935]                       else if (inherits(cond, "condition")) {
[17:43:33.935]                         if (!is.null(pattern)) {
[17:43:33.935]                           computeRestarts <- base::computeRestarts
[17:43:33.935]                           grepl <- base::grepl
[17:43:33.935]                           restarts <- computeRestarts(cond)
[17:43:33.935]                           for (restart in restarts) {
[17:43:33.935]                             name <- restart$name
[17:43:33.935]                             if (is.null(name)) 
[17:43:33.935]                               next
[17:43:33.935]                             if (!grepl(pattern, name)) 
[17:43:33.935]                               next
[17:43:33.935]                             invokeRestart(restart)
[17:43:33.935]                             muffled <- TRUE
[17:43:33.935]                             break
[17:43:33.935]                           }
[17:43:33.935]                         }
[17:43:33.935]                       }
[17:43:33.935]                       invisible(muffled)
[17:43:33.935]                     }
[17:43:33.935]                     muffleCondition(cond, pattern = "^muffle")
[17:43:33.935]                   }
[17:43:33.935]                 }
[17:43:33.935]                 else {
[17:43:33.935]                   if (TRUE) {
[17:43:33.935]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:33.935]                     {
[17:43:33.935]                       inherits <- base::inherits
[17:43:33.935]                       invokeRestart <- base::invokeRestart
[17:43:33.935]                       is.null <- base::is.null
[17:43:33.935]                       muffled <- FALSE
[17:43:33.935]                       if (inherits(cond, "message")) {
[17:43:33.935]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:33.935]                         if (muffled) 
[17:43:33.935]                           invokeRestart("muffleMessage")
[17:43:33.935]                       }
[17:43:33.935]                       else if (inherits(cond, "warning")) {
[17:43:33.935]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:33.935]                         if (muffled) 
[17:43:33.935]                           invokeRestart("muffleWarning")
[17:43:33.935]                       }
[17:43:33.935]                       else if (inherits(cond, "condition")) {
[17:43:33.935]                         if (!is.null(pattern)) {
[17:43:33.935]                           computeRestarts <- base::computeRestarts
[17:43:33.935]                           grepl <- base::grepl
[17:43:33.935]                           restarts <- computeRestarts(cond)
[17:43:33.935]                           for (restart in restarts) {
[17:43:33.935]                             name <- restart$name
[17:43:33.935]                             if (is.null(name)) 
[17:43:33.935]                               next
[17:43:33.935]                             if (!grepl(pattern, name)) 
[17:43:33.935]                               next
[17:43:33.935]                             invokeRestart(restart)
[17:43:33.935]                             muffled <- TRUE
[17:43:33.935]                             break
[17:43:33.935]                           }
[17:43:33.935]                         }
[17:43:33.935]                       }
[17:43:33.935]                       invisible(muffled)
[17:43:33.935]                     }
[17:43:33.935]                     muffleCondition(cond, pattern = "^muffle")
[17:43:33.935]                   }
[17:43:33.935]                 }
[17:43:33.935]             }
[17:43:33.935]         }))
[17:43:33.935]     }, error = function(ex) {
[17:43:33.935]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:33.935]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:33.935]                 ...future.rng), started = ...future.startTime, 
[17:43:33.935]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:33.935]             version = "1.8"), class = "FutureResult")
[17:43:33.935]     }, finally = {
[17:43:33.935]         if (!identical(...future.workdir, getwd())) 
[17:43:33.935]             setwd(...future.workdir)
[17:43:33.935]         {
[17:43:33.935]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:33.935]                 ...future.oldOptions$nwarnings <- NULL
[17:43:33.935]             }
[17:43:33.935]             base::options(...future.oldOptions)
[17:43:33.935]             if (.Platform$OS.type == "windows") {
[17:43:33.935]                 old_names <- names(...future.oldEnvVars)
[17:43:33.935]                 envs <- base::Sys.getenv()
[17:43:33.935]                 names <- names(envs)
[17:43:33.935]                 common <- intersect(names, old_names)
[17:43:33.935]                 added <- setdiff(names, old_names)
[17:43:33.935]                 removed <- setdiff(old_names, names)
[17:43:33.935]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:33.935]                   envs[common]]
[17:43:33.935]                 NAMES <- toupper(changed)
[17:43:33.935]                 args <- list()
[17:43:33.935]                 for (kk in seq_along(NAMES)) {
[17:43:33.935]                   name <- changed[[kk]]
[17:43:33.935]                   NAME <- NAMES[[kk]]
[17:43:33.935]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:33.935]                     next
[17:43:33.935]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:33.935]                 }
[17:43:33.935]                 NAMES <- toupper(added)
[17:43:33.935]                 for (kk in seq_along(NAMES)) {
[17:43:33.935]                   name <- added[[kk]]
[17:43:33.935]                   NAME <- NAMES[[kk]]
[17:43:33.935]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:33.935]                     next
[17:43:33.935]                   args[[name]] <- ""
[17:43:33.935]                 }
[17:43:33.935]                 NAMES <- toupper(removed)
[17:43:33.935]                 for (kk in seq_along(NAMES)) {
[17:43:33.935]                   name <- removed[[kk]]
[17:43:33.935]                   NAME <- NAMES[[kk]]
[17:43:33.935]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:33.935]                     next
[17:43:33.935]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:33.935]                 }
[17:43:33.935]                 if (length(args) > 0) 
[17:43:33.935]                   base::do.call(base::Sys.setenv, args = args)
[17:43:33.935]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:33.935]             }
[17:43:33.935]             else {
[17:43:33.935]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:33.935]             }
[17:43:33.935]             {
[17:43:33.935]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:33.935]                   0L) {
[17:43:33.935]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:33.935]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:33.935]                   base::options(opts)
[17:43:33.935]                 }
[17:43:33.935]                 {
[17:43:33.935]                   {
[17:43:33.935]                     NULL
[17:43:33.935]                     RNGkind("Mersenne-Twister")
[17:43:33.935]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:33.935]                       inherits = FALSE)
[17:43:33.935]                   }
[17:43:33.935]                   options(future.plan = NULL)
[17:43:33.935]                   if (is.na(NA_character_)) 
[17:43:33.935]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:33.935]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:33.935]                   future::plan(list(function (..., envir = parent.frame()) 
[17:43:33.935]                   {
[17:43:33.935]                     future <- SequentialFuture(..., envir = envir)
[17:43:33.935]                     if (!future$lazy) 
[17:43:33.935]                       future <- run(future)
[17:43:33.935]                     invisible(future)
[17:43:33.935]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:33.935]                 }
[17:43:33.935]             }
[17:43:33.935]         }
[17:43:33.935]     })
[17:43:33.935]     if (TRUE) {
[17:43:33.935]         base::sink(type = "output", split = FALSE)
[17:43:33.935]         if (TRUE) {
[17:43:33.935]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:33.935]         }
[17:43:33.935]         else {
[17:43:33.935]             ...future.result["stdout"] <- base::list(NULL)
[17:43:33.935]         }
[17:43:33.935]         base::close(...future.stdout)
[17:43:33.935]         ...future.stdout <- NULL
[17:43:33.935]     }
[17:43:33.935]     ...future.result$conditions <- ...future.conditions
[17:43:33.935]     ...future.result$finished <- base::Sys.time()
[17:43:33.935]     ...future.result
[17:43:33.935] }
[17:43:33.937] plan(): Setting new future strategy stack:
[17:43:33.937] List of future strategies:
[17:43:33.937] 1. sequential:
[17:43:33.937]    - args: function (..., envir = parent.frame())
[17:43:33.937]    - tweaked: FALSE
[17:43:33.937]    - call: NULL
[17:43:33.938] plan(): nbrOfWorkers() = 1
[17:43:33.939] plan(): Setting new future strategy stack:
[17:43:33.939] List of future strategies:
[17:43:33.939] 1. sequential:
[17:43:33.939]    - args: function (..., envir = parent.frame())
[17:43:33.939]    - tweaked: FALSE
[17:43:33.939]    - call: plan(strategy)
[17:43:33.939] plan(): nbrOfWorkers() = 1
[17:43:33.939] SequentialFuture started (and completed)
[17:43:33.939] - Launch lazy future ... done
[17:43:33.939] run() for ‘SequentialFuture’ ... done
[17:43:33.940] getGlobalsAndPackages() ...
[17:43:33.940] Searching for globals...
[17:43:33.940] 
[17:43:33.940] Searching for globals ... DONE
[17:43:33.940] - globals: [0] <none>
[17:43:33.940] getGlobalsAndPackages() ... DONE
[17:43:33.940] run() for ‘Future’ ...
[17:43:33.941] - state: ‘created’
[17:43:33.941] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:33.941] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:33.941] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:33.941]   - Field: ‘label’
[17:43:33.941]   - Field: ‘local’
[17:43:33.941]   - Field: ‘owner’
[17:43:33.942]   - Field: ‘envir’
[17:43:33.942]   - Field: ‘packages’
[17:43:33.942]   - Field: ‘gc’
[17:43:33.942]   - Field: ‘conditions’
[17:43:33.944]   - Field: ‘expr’
[17:43:33.944]   - Field: ‘uuid’
[17:43:33.944]   - Field: ‘seed’
[17:43:33.944]   - Field: ‘version’
[17:43:33.944]   - Field: ‘result’
[17:43:33.944]   - Field: ‘asynchronous’
[17:43:33.944]   - Field: ‘calls’
[17:43:33.944]   - Field: ‘globals’
[17:43:33.944]   - Field: ‘stdout’
[17:43:33.944]   - Field: ‘earlySignal’
[17:43:33.945]   - Field: ‘lazy’
[17:43:33.945]   - Field: ‘state’
[17:43:33.945] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:33.945] - Launch lazy future ...
[17:43:33.945] Packages needed by the future expression (n = 0): <none>
[17:43:33.945] Packages needed by future strategies (n = 0): <none>
[17:43:33.946] {
[17:43:33.946]     {
[17:43:33.946]         {
[17:43:33.946]             ...future.startTime <- base::Sys.time()
[17:43:33.946]             {
[17:43:33.946]                 {
[17:43:33.946]                   {
[17:43:33.946]                     base::local({
[17:43:33.946]                       has_future <- base::requireNamespace("future", 
[17:43:33.946]                         quietly = TRUE)
[17:43:33.946]                       if (has_future) {
[17:43:33.946]                         ns <- base::getNamespace("future")
[17:43:33.946]                         version <- ns[[".package"]][["version"]]
[17:43:33.946]                         if (is.null(version)) 
[17:43:33.946]                           version <- utils::packageVersion("future")
[17:43:33.946]                       }
[17:43:33.946]                       else {
[17:43:33.946]                         version <- NULL
[17:43:33.946]                       }
[17:43:33.946]                       if (!has_future || version < "1.8.0") {
[17:43:33.946]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:33.946]                           "", base::R.version$version.string), 
[17:43:33.946]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:33.946]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:33.946]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:33.946]                             "release", "version")], collapse = " "), 
[17:43:33.946]                           hostname = base::Sys.info()[["nodename"]])
[17:43:33.946]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:33.946]                           info)
[17:43:33.946]                         info <- base::paste(info, collapse = "; ")
[17:43:33.946]                         if (!has_future) {
[17:43:33.946]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:33.946]                             info)
[17:43:33.946]                         }
[17:43:33.946]                         else {
[17:43:33.946]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:33.946]                             info, version)
[17:43:33.946]                         }
[17:43:33.946]                         base::stop(msg)
[17:43:33.946]                       }
[17:43:33.946]                     })
[17:43:33.946]                   }
[17:43:33.946]                   options(future.plan = NULL)
[17:43:33.946]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:33.946]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:33.946]                 }
[17:43:33.946]                 ...future.workdir <- getwd()
[17:43:33.946]             }
[17:43:33.946]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:33.946]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:33.946]         }
[17:43:33.946]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:33.946]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:33.946]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:33.946]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:33.946]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:33.946]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:33.946]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:33.946]             base::names(...future.oldOptions))
[17:43:33.946]     }
[17:43:33.946]     if (FALSE) {
[17:43:33.946]     }
[17:43:33.946]     else {
[17:43:33.946]         if (TRUE) {
[17:43:33.946]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:33.946]                 open = "w")
[17:43:33.946]         }
[17:43:33.946]         else {
[17:43:33.946]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:33.946]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:33.946]         }
[17:43:33.946]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:33.946]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:33.946]             base::sink(type = "output", split = FALSE)
[17:43:33.946]             base::close(...future.stdout)
[17:43:33.946]         }, add = TRUE)
[17:43:33.946]     }
[17:43:33.946]     ...future.frame <- base::sys.nframe()
[17:43:33.946]     ...future.conditions <- base::list()
[17:43:33.946]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:33.946]     if (FALSE) {
[17:43:33.946]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:33.946]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:33.946]     }
[17:43:33.946]     ...future.result <- base::tryCatch({
[17:43:33.946]         base::withCallingHandlers({
[17:43:33.946]             ...future.value <- base::withVisible(base::local(2))
[17:43:33.946]             future::FutureResult(value = ...future.value$value, 
[17:43:33.946]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:33.946]                   ...future.rng), globalenv = if (FALSE) 
[17:43:33.946]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:33.946]                     ...future.globalenv.names))
[17:43:33.946]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:33.946]         }, condition = base::local({
[17:43:33.946]             c <- base::c
[17:43:33.946]             inherits <- base::inherits
[17:43:33.946]             invokeRestart <- base::invokeRestart
[17:43:33.946]             length <- base::length
[17:43:33.946]             list <- base::list
[17:43:33.946]             seq.int <- base::seq.int
[17:43:33.946]             signalCondition <- base::signalCondition
[17:43:33.946]             sys.calls <- base::sys.calls
[17:43:33.946]             `[[` <- base::`[[`
[17:43:33.946]             `+` <- base::`+`
[17:43:33.946]             `<<-` <- base::`<<-`
[17:43:33.946]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:33.946]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:33.946]                   3L)]
[17:43:33.946]             }
[17:43:33.946]             function(cond) {
[17:43:33.946]                 is_error <- inherits(cond, "error")
[17:43:33.946]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:33.946]                   NULL)
[17:43:33.946]                 if (is_error) {
[17:43:33.946]                   sessionInformation <- function() {
[17:43:33.946]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:33.946]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:33.946]                       search = base::search(), system = base::Sys.info())
[17:43:33.946]                   }
[17:43:33.946]                   ...future.conditions[[length(...future.conditions) + 
[17:43:33.946]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:33.946]                     cond$call), session = sessionInformation(), 
[17:43:33.946]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:33.946]                   signalCondition(cond)
[17:43:33.946]                 }
[17:43:33.946]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:33.946]                 "immediateCondition"))) {
[17:43:33.946]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:33.946]                   ...future.conditions[[length(...future.conditions) + 
[17:43:33.946]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:33.946]                   if (TRUE && !signal) {
[17:43:33.946]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:33.946]                     {
[17:43:33.946]                       inherits <- base::inherits
[17:43:33.946]                       invokeRestart <- base::invokeRestart
[17:43:33.946]                       is.null <- base::is.null
[17:43:33.946]                       muffled <- FALSE
[17:43:33.946]                       if (inherits(cond, "message")) {
[17:43:33.946]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:33.946]                         if (muffled) 
[17:43:33.946]                           invokeRestart("muffleMessage")
[17:43:33.946]                       }
[17:43:33.946]                       else if (inherits(cond, "warning")) {
[17:43:33.946]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:33.946]                         if (muffled) 
[17:43:33.946]                           invokeRestart("muffleWarning")
[17:43:33.946]                       }
[17:43:33.946]                       else if (inherits(cond, "condition")) {
[17:43:33.946]                         if (!is.null(pattern)) {
[17:43:33.946]                           computeRestarts <- base::computeRestarts
[17:43:33.946]                           grepl <- base::grepl
[17:43:33.946]                           restarts <- computeRestarts(cond)
[17:43:33.946]                           for (restart in restarts) {
[17:43:33.946]                             name <- restart$name
[17:43:33.946]                             if (is.null(name)) 
[17:43:33.946]                               next
[17:43:33.946]                             if (!grepl(pattern, name)) 
[17:43:33.946]                               next
[17:43:33.946]                             invokeRestart(restart)
[17:43:33.946]                             muffled <- TRUE
[17:43:33.946]                             break
[17:43:33.946]                           }
[17:43:33.946]                         }
[17:43:33.946]                       }
[17:43:33.946]                       invisible(muffled)
[17:43:33.946]                     }
[17:43:33.946]                     muffleCondition(cond, pattern = "^muffle")
[17:43:33.946]                   }
[17:43:33.946]                 }
[17:43:33.946]                 else {
[17:43:33.946]                   if (TRUE) {
[17:43:33.946]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:33.946]                     {
[17:43:33.946]                       inherits <- base::inherits
[17:43:33.946]                       invokeRestart <- base::invokeRestart
[17:43:33.946]                       is.null <- base::is.null
[17:43:33.946]                       muffled <- FALSE
[17:43:33.946]                       if (inherits(cond, "message")) {
[17:43:33.946]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:33.946]                         if (muffled) 
[17:43:33.946]                           invokeRestart("muffleMessage")
[17:43:33.946]                       }
[17:43:33.946]                       else if (inherits(cond, "warning")) {
[17:43:33.946]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:33.946]                         if (muffled) 
[17:43:33.946]                           invokeRestart("muffleWarning")
[17:43:33.946]                       }
[17:43:33.946]                       else if (inherits(cond, "condition")) {
[17:43:33.946]                         if (!is.null(pattern)) {
[17:43:33.946]                           computeRestarts <- base::computeRestarts
[17:43:33.946]                           grepl <- base::grepl
[17:43:33.946]                           restarts <- computeRestarts(cond)
[17:43:33.946]                           for (restart in restarts) {
[17:43:33.946]                             name <- restart$name
[17:43:33.946]                             if (is.null(name)) 
[17:43:33.946]                               next
[17:43:33.946]                             if (!grepl(pattern, name)) 
[17:43:33.946]                               next
[17:43:33.946]                             invokeRestart(restart)
[17:43:33.946]                             muffled <- TRUE
[17:43:33.946]                             break
[17:43:33.946]                           }
[17:43:33.946]                         }
[17:43:33.946]                       }
[17:43:33.946]                       invisible(muffled)
[17:43:33.946]                     }
[17:43:33.946]                     muffleCondition(cond, pattern = "^muffle")
[17:43:33.946]                   }
[17:43:33.946]                 }
[17:43:33.946]             }
[17:43:33.946]         }))
[17:43:33.946]     }, error = function(ex) {
[17:43:33.946]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:33.946]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:33.946]                 ...future.rng), started = ...future.startTime, 
[17:43:33.946]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:33.946]             version = "1.8"), class = "FutureResult")
[17:43:33.946]     }, finally = {
[17:43:33.946]         if (!identical(...future.workdir, getwd())) 
[17:43:33.946]             setwd(...future.workdir)
[17:43:33.946]         {
[17:43:33.946]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:33.946]                 ...future.oldOptions$nwarnings <- NULL
[17:43:33.946]             }
[17:43:33.946]             base::options(...future.oldOptions)
[17:43:33.946]             if (.Platform$OS.type == "windows") {
[17:43:33.946]                 old_names <- names(...future.oldEnvVars)
[17:43:33.946]                 envs <- base::Sys.getenv()
[17:43:33.946]                 names <- names(envs)
[17:43:33.946]                 common <- intersect(names, old_names)
[17:43:33.946]                 added <- setdiff(names, old_names)
[17:43:33.946]                 removed <- setdiff(old_names, names)
[17:43:33.946]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:33.946]                   envs[common]]
[17:43:33.946]                 NAMES <- toupper(changed)
[17:43:33.946]                 args <- list()
[17:43:33.946]                 for (kk in seq_along(NAMES)) {
[17:43:33.946]                   name <- changed[[kk]]
[17:43:33.946]                   NAME <- NAMES[[kk]]
[17:43:33.946]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:33.946]                     next
[17:43:33.946]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:33.946]                 }
[17:43:33.946]                 NAMES <- toupper(added)
[17:43:33.946]                 for (kk in seq_along(NAMES)) {
[17:43:33.946]                   name <- added[[kk]]
[17:43:33.946]                   NAME <- NAMES[[kk]]
[17:43:33.946]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:33.946]                     next
[17:43:33.946]                   args[[name]] <- ""
[17:43:33.946]                 }
[17:43:33.946]                 NAMES <- toupper(removed)
[17:43:33.946]                 for (kk in seq_along(NAMES)) {
[17:43:33.946]                   name <- removed[[kk]]
[17:43:33.946]                   NAME <- NAMES[[kk]]
[17:43:33.946]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:33.946]                     next
[17:43:33.946]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:33.946]                 }
[17:43:33.946]                 if (length(args) > 0) 
[17:43:33.946]                   base::do.call(base::Sys.setenv, args = args)
[17:43:33.946]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:33.946]             }
[17:43:33.946]             else {
[17:43:33.946]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:33.946]             }
[17:43:33.946]             {
[17:43:33.946]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:33.946]                   0L) {
[17:43:33.946]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:33.946]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:33.946]                   base::options(opts)
[17:43:33.946]                 }
[17:43:33.946]                 {
[17:43:33.946]                   {
[17:43:33.946]                     NULL
[17:43:33.946]                     RNGkind("Mersenne-Twister")
[17:43:33.946]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:33.946]                       inherits = FALSE)
[17:43:33.946]                   }
[17:43:33.946]                   options(future.plan = NULL)
[17:43:33.946]                   if (is.na(NA_character_)) 
[17:43:33.946]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:33.946]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:33.946]                   future::plan(list(function (..., envir = parent.frame()) 
[17:43:33.946]                   {
[17:43:33.946]                     future <- SequentialFuture(..., envir = envir)
[17:43:33.946]                     if (!future$lazy) 
[17:43:33.946]                       future <- run(future)
[17:43:33.946]                     invisible(future)
[17:43:33.946]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:33.946]                 }
[17:43:33.946]             }
[17:43:33.946]         }
[17:43:33.946]     })
[17:43:33.946]     if (TRUE) {
[17:43:33.946]         base::sink(type = "output", split = FALSE)
[17:43:33.946]         if (TRUE) {
[17:43:33.946]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:33.946]         }
[17:43:33.946]         else {
[17:43:33.946]             ...future.result["stdout"] <- base::list(NULL)
[17:43:33.946]         }
[17:43:33.946]         base::close(...future.stdout)
[17:43:33.946]         ...future.stdout <- NULL
[17:43:33.946]     }
[17:43:33.946]     ...future.result$conditions <- ...future.conditions
[17:43:33.946]     ...future.result$finished <- base::Sys.time()
[17:43:33.946]     ...future.result
[17:43:33.946] }
[17:43:33.947] plan(): Setting new future strategy stack:
[17:43:33.947] List of future strategies:
[17:43:33.947] 1. sequential:
[17:43:33.947]    - args: function (..., envir = parent.frame())
[17:43:33.947]    - tweaked: FALSE
[17:43:33.947]    - call: NULL
[17:43:33.948] plan(): nbrOfWorkers() = 1
[17:43:33.948] plan(): Setting new future strategy stack:
[17:43:33.949] List of future strategies:
[17:43:33.949] 1. sequential:
[17:43:33.949]    - args: function (..., envir = parent.frame())
[17:43:33.949]    - tweaked: FALSE
[17:43:33.949]    - call: plan(strategy)
[17:43:33.949] plan(): nbrOfWorkers() = 1
[17:43:33.949] SequentialFuture started (and completed)
[17:43:33.949] - Launch lazy future ... done
[17:43:33.949] run() for ‘SequentialFuture’ ... done
[17:43:33.950] resolve() on environment ...
[17:43:33.950]  recursive: 0
[17:43:33.950]  elements: [3] ‘a’, ‘b’, ‘c’
[17:43:33.950] resolved() for ‘SequentialFuture’ ...
[17:43:33.951] - state: ‘finished’
[17:43:33.951] - run: TRUE
[17:43:33.951] - result: ‘FutureResult’
[17:43:33.951] resolved() for ‘SequentialFuture’ ... done
[17:43:33.951] Future #1
[17:43:33.951]  length: 2 (resolved future 1)
[17:43:33.951] resolved() for ‘SequentialFuture’ ...
[17:43:33.951] - state: ‘finished’
[17:43:33.951] - run: TRUE
[17:43:33.951] - result: ‘FutureResult’
[17:43:33.952] resolved() for ‘SequentialFuture’ ... done
[17:43:33.952] Future #2
[17:43:33.952]  length: 1 (resolved future 2)
[17:43:33.952]  length: 0 (resolved future 3)
[17:43:33.952] resolve() on environment ... DONE
[17:43:33.952] resolved() for ‘SequentialFuture’ ...
[17:43:33.952] - state: ‘finished’
[17:43:33.952] - run: TRUE
[17:43:33.952] - result: ‘FutureResult’
[17:43:33.952] resolved() for ‘SequentialFuture’ ... done
[17:43:33.953] resolved() for ‘SequentialFuture’ ...
[17:43:33.953] - state: ‘finished’
[17:43:33.953] - run: TRUE
[17:43:33.953] - result: ‘FutureResult’
[17:43:33.953] resolved() for ‘SequentialFuture’ ... done
[17:43:33.954] getGlobalsAndPackages() ...
[17:43:33.954] Searching for globals...
[17:43:33.954] - globals found: [1] ‘{’
[17:43:33.954] Searching for globals ... DONE
[17:43:33.955] Resolving globals: FALSE
[17:43:33.955] 
[17:43:33.955] 
[17:43:33.955] getGlobalsAndPackages() ... DONE
[17:43:33.955] run() for ‘Future’ ...
[17:43:33.955] - state: ‘created’
[17:43:33.956] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:33.956] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:33.956] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:33.956]   - Field: ‘label’
[17:43:33.956]   - Field: ‘local’
[17:43:33.956]   - Field: ‘owner’
[17:43:33.956]   - Field: ‘envir’
[17:43:33.956]   - Field: ‘packages’
[17:43:33.956]   - Field: ‘gc’
[17:43:33.957]   - Field: ‘conditions’
[17:43:33.957]   - Field: ‘expr’
[17:43:33.957]   - Field: ‘uuid’
[17:43:33.957]   - Field: ‘seed’
[17:43:33.957]   - Field: ‘version’
[17:43:33.957]   - Field: ‘result’
[17:43:33.957]   - Field: ‘asynchronous’
[17:43:33.957]   - Field: ‘calls’
[17:43:33.957]   - Field: ‘globals’
[17:43:33.957]   - Field: ‘stdout’
[17:43:33.957]   - Field: ‘earlySignal’
[17:43:33.958]   - Field: ‘lazy’
[17:43:33.958]   - Field: ‘state’
[17:43:33.958] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:33.958] - Launch lazy future ...
[17:43:33.958] Packages needed by the future expression (n = 0): <none>
[17:43:33.958] Packages needed by future strategies (n = 0): <none>
[17:43:33.959] {
[17:43:33.959]     {
[17:43:33.959]         {
[17:43:33.959]             ...future.startTime <- base::Sys.time()
[17:43:33.959]             {
[17:43:33.959]                 {
[17:43:33.959]                   {
[17:43:33.959]                     base::local({
[17:43:33.959]                       has_future <- base::requireNamespace("future", 
[17:43:33.959]                         quietly = TRUE)
[17:43:33.959]                       if (has_future) {
[17:43:33.959]                         ns <- base::getNamespace("future")
[17:43:33.959]                         version <- ns[[".package"]][["version"]]
[17:43:33.959]                         if (is.null(version)) 
[17:43:33.959]                           version <- utils::packageVersion("future")
[17:43:33.959]                       }
[17:43:33.959]                       else {
[17:43:33.959]                         version <- NULL
[17:43:33.959]                       }
[17:43:33.959]                       if (!has_future || version < "1.8.0") {
[17:43:33.959]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:33.959]                           "", base::R.version$version.string), 
[17:43:33.959]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:33.959]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:33.959]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:33.959]                             "release", "version")], collapse = " "), 
[17:43:33.959]                           hostname = base::Sys.info()[["nodename"]])
[17:43:33.959]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:33.959]                           info)
[17:43:33.959]                         info <- base::paste(info, collapse = "; ")
[17:43:33.959]                         if (!has_future) {
[17:43:33.959]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:33.959]                             info)
[17:43:33.959]                         }
[17:43:33.959]                         else {
[17:43:33.959]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:33.959]                             info, version)
[17:43:33.959]                         }
[17:43:33.959]                         base::stop(msg)
[17:43:33.959]                       }
[17:43:33.959]                     })
[17:43:33.959]                   }
[17:43:33.959]                   options(future.plan = NULL)
[17:43:33.959]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:33.959]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:33.959]                 }
[17:43:33.959]                 ...future.workdir <- getwd()
[17:43:33.959]             }
[17:43:33.959]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:33.959]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:33.959]         }
[17:43:33.959]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:33.959]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:33.959]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:33.959]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:33.959]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:33.959]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:33.959]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:33.959]             base::names(...future.oldOptions))
[17:43:33.959]     }
[17:43:33.959]     if (FALSE) {
[17:43:33.959]     }
[17:43:33.959]     else {
[17:43:33.959]         if (TRUE) {
[17:43:33.959]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:33.959]                 open = "w")
[17:43:33.959]         }
[17:43:33.959]         else {
[17:43:33.959]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:33.959]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:33.959]         }
[17:43:33.959]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:33.959]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:33.959]             base::sink(type = "output", split = FALSE)
[17:43:33.959]             base::close(...future.stdout)
[17:43:33.959]         }, add = TRUE)
[17:43:33.959]     }
[17:43:33.959]     ...future.frame <- base::sys.nframe()
[17:43:33.959]     ...future.conditions <- base::list()
[17:43:33.959]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:33.959]     if (FALSE) {
[17:43:33.959]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:33.959]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:33.959]     }
[17:43:33.959]     ...future.result <- base::tryCatch({
[17:43:33.959]         base::withCallingHandlers({
[17:43:33.959]             ...future.value <- base::withVisible(base::local({
[17:43:33.959]                 1
[17:43:33.959]             }))
[17:43:33.959]             future::FutureResult(value = ...future.value$value, 
[17:43:33.959]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:33.959]                   ...future.rng), globalenv = if (FALSE) 
[17:43:33.959]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:33.959]                     ...future.globalenv.names))
[17:43:33.959]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:33.959]         }, condition = base::local({
[17:43:33.959]             c <- base::c
[17:43:33.959]             inherits <- base::inherits
[17:43:33.959]             invokeRestart <- base::invokeRestart
[17:43:33.959]             length <- base::length
[17:43:33.959]             list <- base::list
[17:43:33.959]             seq.int <- base::seq.int
[17:43:33.959]             signalCondition <- base::signalCondition
[17:43:33.959]             sys.calls <- base::sys.calls
[17:43:33.959]             `[[` <- base::`[[`
[17:43:33.959]             `+` <- base::`+`
[17:43:33.959]             `<<-` <- base::`<<-`
[17:43:33.959]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:33.959]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:33.959]                   3L)]
[17:43:33.959]             }
[17:43:33.959]             function(cond) {
[17:43:33.959]                 is_error <- inherits(cond, "error")
[17:43:33.959]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:33.959]                   NULL)
[17:43:33.959]                 if (is_error) {
[17:43:33.959]                   sessionInformation <- function() {
[17:43:33.959]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:33.959]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:33.959]                       search = base::search(), system = base::Sys.info())
[17:43:33.959]                   }
[17:43:33.959]                   ...future.conditions[[length(...future.conditions) + 
[17:43:33.959]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:33.959]                     cond$call), session = sessionInformation(), 
[17:43:33.959]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:33.959]                   signalCondition(cond)
[17:43:33.959]                 }
[17:43:33.959]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:33.959]                 "immediateCondition"))) {
[17:43:33.959]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:33.959]                   ...future.conditions[[length(...future.conditions) + 
[17:43:33.959]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:33.959]                   if (TRUE && !signal) {
[17:43:33.959]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:33.959]                     {
[17:43:33.959]                       inherits <- base::inherits
[17:43:33.959]                       invokeRestart <- base::invokeRestart
[17:43:33.959]                       is.null <- base::is.null
[17:43:33.959]                       muffled <- FALSE
[17:43:33.959]                       if (inherits(cond, "message")) {
[17:43:33.959]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:33.959]                         if (muffled) 
[17:43:33.959]                           invokeRestart("muffleMessage")
[17:43:33.959]                       }
[17:43:33.959]                       else if (inherits(cond, "warning")) {
[17:43:33.959]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:33.959]                         if (muffled) 
[17:43:33.959]                           invokeRestart("muffleWarning")
[17:43:33.959]                       }
[17:43:33.959]                       else if (inherits(cond, "condition")) {
[17:43:33.959]                         if (!is.null(pattern)) {
[17:43:33.959]                           computeRestarts <- base::computeRestarts
[17:43:33.959]                           grepl <- base::grepl
[17:43:33.959]                           restarts <- computeRestarts(cond)
[17:43:33.959]                           for (restart in restarts) {
[17:43:33.959]                             name <- restart$name
[17:43:33.959]                             if (is.null(name)) 
[17:43:33.959]                               next
[17:43:33.959]                             if (!grepl(pattern, name)) 
[17:43:33.959]                               next
[17:43:33.959]                             invokeRestart(restart)
[17:43:33.959]                             muffled <- TRUE
[17:43:33.959]                             break
[17:43:33.959]                           }
[17:43:33.959]                         }
[17:43:33.959]                       }
[17:43:33.959]                       invisible(muffled)
[17:43:33.959]                     }
[17:43:33.959]                     muffleCondition(cond, pattern = "^muffle")
[17:43:33.959]                   }
[17:43:33.959]                 }
[17:43:33.959]                 else {
[17:43:33.959]                   if (TRUE) {
[17:43:33.959]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:33.959]                     {
[17:43:33.959]                       inherits <- base::inherits
[17:43:33.959]                       invokeRestart <- base::invokeRestart
[17:43:33.959]                       is.null <- base::is.null
[17:43:33.959]                       muffled <- FALSE
[17:43:33.959]                       if (inherits(cond, "message")) {
[17:43:33.959]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:33.959]                         if (muffled) 
[17:43:33.959]                           invokeRestart("muffleMessage")
[17:43:33.959]                       }
[17:43:33.959]                       else if (inherits(cond, "warning")) {
[17:43:33.959]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:33.959]                         if (muffled) 
[17:43:33.959]                           invokeRestart("muffleWarning")
[17:43:33.959]                       }
[17:43:33.959]                       else if (inherits(cond, "condition")) {
[17:43:33.959]                         if (!is.null(pattern)) {
[17:43:33.959]                           computeRestarts <- base::computeRestarts
[17:43:33.959]                           grepl <- base::grepl
[17:43:33.959]                           restarts <- computeRestarts(cond)
[17:43:33.959]                           for (restart in restarts) {
[17:43:33.959]                             name <- restart$name
[17:43:33.959]                             if (is.null(name)) 
[17:43:33.959]                               next
[17:43:33.959]                             if (!grepl(pattern, name)) 
[17:43:33.959]                               next
[17:43:33.959]                             invokeRestart(restart)
[17:43:33.959]                             muffled <- TRUE
[17:43:33.959]                             break
[17:43:33.959]                           }
[17:43:33.959]                         }
[17:43:33.959]                       }
[17:43:33.959]                       invisible(muffled)
[17:43:33.959]                     }
[17:43:33.959]                     muffleCondition(cond, pattern = "^muffle")
[17:43:33.959]                   }
[17:43:33.959]                 }
[17:43:33.959]             }
[17:43:33.959]         }))
[17:43:33.959]     }, error = function(ex) {
[17:43:33.959]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:33.959]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:33.959]                 ...future.rng), started = ...future.startTime, 
[17:43:33.959]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:33.959]             version = "1.8"), class = "FutureResult")
[17:43:33.959]     }, finally = {
[17:43:33.959]         if (!identical(...future.workdir, getwd())) 
[17:43:33.959]             setwd(...future.workdir)
[17:43:33.959]         {
[17:43:33.959]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:33.959]                 ...future.oldOptions$nwarnings <- NULL
[17:43:33.959]             }
[17:43:33.959]             base::options(...future.oldOptions)
[17:43:33.959]             if (.Platform$OS.type == "windows") {
[17:43:33.959]                 old_names <- names(...future.oldEnvVars)
[17:43:33.959]                 envs <- base::Sys.getenv()
[17:43:33.959]                 names <- names(envs)
[17:43:33.959]                 common <- intersect(names, old_names)
[17:43:33.959]                 added <- setdiff(names, old_names)
[17:43:33.959]                 removed <- setdiff(old_names, names)
[17:43:33.959]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:33.959]                   envs[common]]
[17:43:33.959]                 NAMES <- toupper(changed)
[17:43:33.959]                 args <- list()
[17:43:33.959]                 for (kk in seq_along(NAMES)) {
[17:43:33.959]                   name <- changed[[kk]]
[17:43:33.959]                   NAME <- NAMES[[kk]]
[17:43:33.959]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:33.959]                     next
[17:43:33.959]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:33.959]                 }
[17:43:33.959]                 NAMES <- toupper(added)
[17:43:33.959]                 for (kk in seq_along(NAMES)) {
[17:43:33.959]                   name <- added[[kk]]
[17:43:33.959]                   NAME <- NAMES[[kk]]
[17:43:33.959]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:33.959]                     next
[17:43:33.959]                   args[[name]] <- ""
[17:43:33.959]                 }
[17:43:33.959]                 NAMES <- toupper(removed)
[17:43:33.959]                 for (kk in seq_along(NAMES)) {
[17:43:33.959]                   name <- removed[[kk]]
[17:43:33.959]                   NAME <- NAMES[[kk]]
[17:43:33.959]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:33.959]                     next
[17:43:33.959]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:33.959]                 }
[17:43:33.959]                 if (length(args) > 0) 
[17:43:33.959]                   base::do.call(base::Sys.setenv, args = args)
[17:43:33.959]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:33.959]             }
[17:43:33.959]             else {
[17:43:33.959]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:33.959]             }
[17:43:33.959]             {
[17:43:33.959]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:33.959]                   0L) {
[17:43:33.959]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:33.959]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:33.959]                   base::options(opts)
[17:43:33.959]                 }
[17:43:33.959]                 {
[17:43:33.959]                   {
[17:43:33.959]                     NULL
[17:43:33.959]                     RNGkind("Mersenne-Twister")
[17:43:33.959]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:33.959]                       inherits = FALSE)
[17:43:33.959]                   }
[17:43:33.959]                   options(future.plan = NULL)
[17:43:33.959]                   if (is.na(NA_character_)) 
[17:43:33.959]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:33.959]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:33.959]                   future::plan(list(function (..., envir = parent.frame()) 
[17:43:33.959]                   {
[17:43:33.959]                     future <- SequentialFuture(..., envir = envir)
[17:43:33.959]                     if (!future$lazy) 
[17:43:33.959]                       future <- run(future)
[17:43:33.959]                     invisible(future)
[17:43:33.959]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:33.959]                 }
[17:43:33.959]             }
[17:43:33.959]         }
[17:43:33.959]     })
[17:43:33.959]     if (TRUE) {
[17:43:33.959]         base::sink(type = "output", split = FALSE)
[17:43:33.959]         if (TRUE) {
[17:43:33.959]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:33.959]         }
[17:43:33.959]         else {
[17:43:33.959]             ...future.result["stdout"] <- base::list(NULL)
[17:43:33.959]         }
[17:43:33.959]         base::close(...future.stdout)
[17:43:33.959]         ...future.stdout <- NULL
[17:43:33.959]     }
[17:43:33.959]     ...future.result$conditions <- ...future.conditions
[17:43:33.959]     ...future.result$finished <- base::Sys.time()
[17:43:33.959]     ...future.result
[17:43:33.959] }
[17:43:33.960] plan(): Setting new future strategy stack:
[17:43:33.960] List of future strategies:
[17:43:33.960] 1. sequential:
[17:43:33.960]    - args: function (..., envir = parent.frame())
[17:43:33.960]    - tweaked: FALSE
[17:43:33.960]    - call: NULL
[17:43:33.961] plan(): nbrOfWorkers() = 1
[17:43:33.961] plan(): Setting new future strategy stack:
[17:43:33.961] List of future strategies:
[17:43:33.961] 1. sequential:
[17:43:33.961]    - args: function (..., envir = parent.frame())
[17:43:33.961]    - tweaked: FALSE
[17:43:33.961]    - call: plan(strategy)
[17:43:33.962] plan(): nbrOfWorkers() = 1
[17:43:33.962] SequentialFuture started (and completed)
[17:43:33.962] - Launch lazy future ... done
[17:43:33.962] run() for ‘SequentialFuture’ ... done
[17:43:33.963] getGlobalsAndPackages() ...
[17:43:33.963] Searching for globals...
[17:43:33.963] - globals found: [1] ‘{’
[17:43:33.963] Searching for globals ... DONE
[17:43:33.963] Resolving globals: FALSE
[17:43:33.964] 
[17:43:33.964] 
[17:43:33.964] getGlobalsAndPackages() ... DONE
[17:43:33.964] run() for ‘Future’ ...
[17:43:33.964] - state: ‘created’
[17:43:33.964] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:33.964] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:33.965] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:33.965]   - Field: ‘label’
[17:43:33.965]   - Field: ‘local’
[17:43:33.965]   - Field: ‘owner’
[17:43:33.965]   - Field: ‘envir’
[17:43:33.965]   - Field: ‘packages’
[17:43:33.965]   - Field: ‘gc’
[17:43:33.965]   - Field: ‘conditions’
[17:43:33.965]   - Field: ‘expr’
[17:43:33.965]   - Field: ‘uuid’
[17:43:33.966]   - Field: ‘seed’
[17:43:33.966]   - Field: ‘version’
[17:43:33.966]   - Field: ‘result’
[17:43:33.966]   - Field: ‘asynchronous’
[17:43:33.966]   - Field: ‘calls’
[17:43:33.966]   - Field: ‘globals’
[17:43:33.966]   - Field: ‘stdout’
[17:43:33.966]   - Field: ‘earlySignal’
[17:43:33.966]   - Field: ‘lazy’
[17:43:33.966]   - Field: ‘state’
[17:43:33.966] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:33.967] - Launch lazy future ...
[17:43:33.967] Packages needed by the future expression (n = 0): <none>
[17:43:33.967] Packages needed by future strategies (n = 0): <none>
[17:43:33.967] {
[17:43:33.967]     {
[17:43:33.967]         {
[17:43:33.967]             ...future.startTime <- base::Sys.time()
[17:43:33.967]             {
[17:43:33.967]                 {
[17:43:33.967]                   {
[17:43:33.967]                     base::local({
[17:43:33.967]                       has_future <- base::requireNamespace("future", 
[17:43:33.967]                         quietly = TRUE)
[17:43:33.967]                       if (has_future) {
[17:43:33.967]                         ns <- base::getNamespace("future")
[17:43:33.967]                         version <- ns[[".package"]][["version"]]
[17:43:33.967]                         if (is.null(version)) 
[17:43:33.967]                           version <- utils::packageVersion("future")
[17:43:33.967]                       }
[17:43:33.967]                       else {
[17:43:33.967]                         version <- NULL
[17:43:33.967]                       }
[17:43:33.967]                       if (!has_future || version < "1.8.0") {
[17:43:33.967]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:33.967]                           "", base::R.version$version.string), 
[17:43:33.967]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:33.967]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:33.967]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:33.967]                             "release", "version")], collapse = " "), 
[17:43:33.967]                           hostname = base::Sys.info()[["nodename"]])
[17:43:33.967]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:33.967]                           info)
[17:43:33.967]                         info <- base::paste(info, collapse = "; ")
[17:43:33.967]                         if (!has_future) {
[17:43:33.967]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:33.967]                             info)
[17:43:33.967]                         }
[17:43:33.967]                         else {
[17:43:33.967]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:33.967]                             info, version)
[17:43:33.967]                         }
[17:43:33.967]                         base::stop(msg)
[17:43:33.967]                       }
[17:43:33.967]                     })
[17:43:33.967]                   }
[17:43:33.967]                   options(future.plan = NULL)
[17:43:33.967]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:33.967]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:33.967]                 }
[17:43:33.967]                 ...future.workdir <- getwd()
[17:43:33.967]             }
[17:43:33.967]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:33.967]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:33.967]         }
[17:43:33.967]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:33.967]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:33.967]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:33.967]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:33.967]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:33.967]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:33.967]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:33.967]             base::names(...future.oldOptions))
[17:43:33.967]     }
[17:43:33.967]     if (FALSE) {
[17:43:33.967]     }
[17:43:33.967]     else {
[17:43:33.967]         if (TRUE) {
[17:43:33.967]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:33.967]                 open = "w")
[17:43:33.967]         }
[17:43:33.967]         else {
[17:43:33.967]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:33.967]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:33.967]         }
[17:43:33.967]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:33.967]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:33.967]             base::sink(type = "output", split = FALSE)
[17:43:33.967]             base::close(...future.stdout)
[17:43:33.967]         }, add = TRUE)
[17:43:33.967]     }
[17:43:33.967]     ...future.frame <- base::sys.nframe()
[17:43:33.967]     ...future.conditions <- base::list()
[17:43:33.967]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:33.967]     if (FALSE) {
[17:43:33.967]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:33.967]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:33.967]     }
[17:43:33.967]     ...future.result <- base::tryCatch({
[17:43:33.967]         base::withCallingHandlers({
[17:43:33.967]             ...future.value <- base::withVisible(base::local({
[17:43:33.967]                 2
[17:43:33.967]             }))
[17:43:33.967]             future::FutureResult(value = ...future.value$value, 
[17:43:33.967]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:33.967]                   ...future.rng), globalenv = if (FALSE) 
[17:43:33.967]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:33.967]                     ...future.globalenv.names))
[17:43:33.967]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:33.967]         }, condition = base::local({
[17:43:33.967]             c <- base::c
[17:43:33.967]             inherits <- base::inherits
[17:43:33.967]             invokeRestart <- base::invokeRestart
[17:43:33.967]             length <- base::length
[17:43:33.967]             list <- base::list
[17:43:33.967]             seq.int <- base::seq.int
[17:43:33.967]             signalCondition <- base::signalCondition
[17:43:33.967]             sys.calls <- base::sys.calls
[17:43:33.967]             `[[` <- base::`[[`
[17:43:33.967]             `+` <- base::`+`
[17:43:33.967]             `<<-` <- base::`<<-`
[17:43:33.967]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:33.967]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:33.967]                   3L)]
[17:43:33.967]             }
[17:43:33.967]             function(cond) {
[17:43:33.967]                 is_error <- inherits(cond, "error")
[17:43:33.967]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:33.967]                   NULL)
[17:43:33.967]                 if (is_error) {
[17:43:33.967]                   sessionInformation <- function() {
[17:43:33.967]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:33.967]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:33.967]                       search = base::search(), system = base::Sys.info())
[17:43:33.967]                   }
[17:43:33.967]                   ...future.conditions[[length(...future.conditions) + 
[17:43:33.967]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:33.967]                     cond$call), session = sessionInformation(), 
[17:43:33.967]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:33.967]                   signalCondition(cond)
[17:43:33.967]                 }
[17:43:33.967]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:33.967]                 "immediateCondition"))) {
[17:43:33.967]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:33.967]                   ...future.conditions[[length(...future.conditions) + 
[17:43:33.967]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:33.967]                   if (TRUE && !signal) {
[17:43:33.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:33.967]                     {
[17:43:33.967]                       inherits <- base::inherits
[17:43:33.967]                       invokeRestart <- base::invokeRestart
[17:43:33.967]                       is.null <- base::is.null
[17:43:33.967]                       muffled <- FALSE
[17:43:33.967]                       if (inherits(cond, "message")) {
[17:43:33.967]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:33.967]                         if (muffled) 
[17:43:33.967]                           invokeRestart("muffleMessage")
[17:43:33.967]                       }
[17:43:33.967]                       else if (inherits(cond, "warning")) {
[17:43:33.967]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:33.967]                         if (muffled) 
[17:43:33.967]                           invokeRestart("muffleWarning")
[17:43:33.967]                       }
[17:43:33.967]                       else if (inherits(cond, "condition")) {
[17:43:33.967]                         if (!is.null(pattern)) {
[17:43:33.967]                           computeRestarts <- base::computeRestarts
[17:43:33.967]                           grepl <- base::grepl
[17:43:33.967]                           restarts <- computeRestarts(cond)
[17:43:33.967]                           for (restart in restarts) {
[17:43:33.967]                             name <- restart$name
[17:43:33.967]                             if (is.null(name)) 
[17:43:33.967]                               next
[17:43:33.967]                             if (!grepl(pattern, name)) 
[17:43:33.967]                               next
[17:43:33.967]                             invokeRestart(restart)
[17:43:33.967]                             muffled <- TRUE
[17:43:33.967]                             break
[17:43:33.967]                           }
[17:43:33.967]                         }
[17:43:33.967]                       }
[17:43:33.967]                       invisible(muffled)
[17:43:33.967]                     }
[17:43:33.967]                     muffleCondition(cond, pattern = "^muffle")
[17:43:33.967]                   }
[17:43:33.967]                 }
[17:43:33.967]                 else {
[17:43:33.967]                   if (TRUE) {
[17:43:33.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:33.967]                     {
[17:43:33.967]                       inherits <- base::inherits
[17:43:33.967]                       invokeRestart <- base::invokeRestart
[17:43:33.967]                       is.null <- base::is.null
[17:43:33.967]                       muffled <- FALSE
[17:43:33.967]                       if (inherits(cond, "message")) {
[17:43:33.967]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:33.967]                         if (muffled) 
[17:43:33.967]                           invokeRestart("muffleMessage")
[17:43:33.967]                       }
[17:43:33.967]                       else if (inherits(cond, "warning")) {
[17:43:33.967]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:33.967]                         if (muffled) 
[17:43:33.967]                           invokeRestart("muffleWarning")
[17:43:33.967]                       }
[17:43:33.967]                       else if (inherits(cond, "condition")) {
[17:43:33.967]                         if (!is.null(pattern)) {
[17:43:33.967]                           computeRestarts <- base::computeRestarts
[17:43:33.967]                           grepl <- base::grepl
[17:43:33.967]                           restarts <- computeRestarts(cond)
[17:43:33.967]                           for (restart in restarts) {
[17:43:33.967]                             name <- restart$name
[17:43:33.967]                             if (is.null(name)) 
[17:43:33.967]                               next
[17:43:33.967]                             if (!grepl(pattern, name)) 
[17:43:33.967]                               next
[17:43:33.967]                             invokeRestart(restart)
[17:43:33.967]                             muffled <- TRUE
[17:43:33.967]                             break
[17:43:33.967]                           }
[17:43:33.967]                         }
[17:43:33.967]                       }
[17:43:33.967]                       invisible(muffled)
[17:43:33.967]                     }
[17:43:33.967]                     muffleCondition(cond, pattern = "^muffle")
[17:43:33.967]                   }
[17:43:33.967]                 }
[17:43:33.967]             }
[17:43:33.967]         }))
[17:43:33.967]     }, error = function(ex) {
[17:43:33.967]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:33.967]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:33.967]                 ...future.rng), started = ...future.startTime, 
[17:43:33.967]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:33.967]             version = "1.8"), class = "FutureResult")
[17:43:33.967]     }, finally = {
[17:43:33.967]         if (!identical(...future.workdir, getwd())) 
[17:43:33.967]             setwd(...future.workdir)
[17:43:33.967]         {
[17:43:33.967]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:33.967]                 ...future.oldOptions$nwarnings <- NULL
[17:43:33.967]             }
[17:43:33.967]             base::options(...future.oldOptions)
[17:43:33.967]             if (.Platform$OS.type == "windows") {
[17:43:33.967]                 old_names <- names(...future.oldEnvVars)
[17:43:33.967]                 envs <- base::Sys.getenv()
[17:43:33.967]                 names <- names(envs)
[17:43:33.967]                 common <- intersect(names, old_names)
[17:43:33.967]                 added <- setdiff(names, old_names)
[17:43:33.967]                 removed <- setdiff(old_names, names)
[17:43:33.967]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:33.967]                   envs[common]]
[17:43:33.967]                 NAMES <- toupper(changed)
[17:43:33.967]                 args <- list()
[17:43:33.967]                 for (kk in seq_along(NAMES)) {
[17:43:33.967]                   name <- changed[[kk]]
[17:43:33.967]                   NAME <- NAMES[[kk]]
[17:43:33.967]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:33.967]                     next
[17:43:33.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:33.967]                 }
[17:43:33.967]                 NAMES <- toupper(added)
[17:43:33.967]                 for (kk in seq_along(NAMES)) {
[17:43:33.967]                   name <- added[[kk]]
[17:43:33.967]                   NAME <- NAMES[[kk]]
[17:43:33.967]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:33.967]                     next
[17:43:33.967]                   args[[name]] <- ""
[17:43:33.967]                 }
[17:43:33.967]                 NAMES <- toupper(removed)
[17:43:33.967]                 for (kk in seq_along(NAMES)) {
[17:43:33.967]                   name <- removed[[kk]]
[17:43:33.967]                   NAME <- NAMES[[kk]]
[17:43:33.967]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:33.967]                     next
[17:43:33.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:33.967]                 }
[17:43:33.967]                 if (length(args) > 0) 
[17:43:33.967]                   base::do.call(base::Sys.setenv, args = args)
[17:43:33.967]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:33.967]             }
[17:43:33.967]             else {
[17:43:33.967]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:33.967]             }
[17:43:33.967]             {
[17:43:33.967]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:33.967]                   0L) {
[17:43:33.967]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:33.967]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:33.967]                   base::options(opts)
[17:43:33.967]                 }
[17:43:33.967]                 {
[17:43:33.967]                   {
[17:43:33.967]                     NULL
[17:43:33.967]                     RNGkind("Mersenne-Twister")
[17:43:33.967]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:33.967]                       inherits = FALSE)
[17:43:33.967]                   }
[17:43:33.967]                   options(future.plan = NULL)
[17:43:33.967]                   if (is.na(NA_character_)) 
[17:43:33.967]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:33.967]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:33.967]                   future::plan(list(function (..., envir = parent.frame()) 
[17:43:33.967]                   {
[17:43:33.967]                     future <- SequentialFuture(..., envir = envir)
[17:43:33.967]                     if (!future$lazy) 
[17:43:33.967]                       future <- run(future)
[17:43:33.967]                     invisible(future)
[17:43:33.967]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:33.967]                 }
[17:43:33.967]             }
[17:43:33.967]         }
[17:43:33.967]     })
[17:43:33.967]     if (TRUE) {
[17:43:33.967]         base::sink(type = "output", split = FALSE)
[17:43:33.967]         if (TRUE) {
[17:43:33.967]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:33.967]         }
[17:43:33.967]         else {
[17:43:33.967]             ...future.result["stdout"] <- base::list(NULL)
[17:43:33.967]         }
[17:43:33.967]         base::close(...future.stdout)
[17:43:33.967]         ...future.stdout <- NULL
[17:43:33.967]     }
[17:43:33.967]     ...future.result$conditions <- ...future.conditions
[17:43:33.967]     ...future.result$finished <- base::Sys.time()
[17:43:33.967]     ...future.result
[17:43:33.967] }
[17:43:33.969] plan(): Setting new future strategy stack:
[17:43:33.969] List of future strategies:
[17:43:33.969] 1. sequential:
[17:43:33.969]    - args: function (..., envir = parent.frame())
[17:43:33.969]    - tweaked: FALSE
[17:43:33.969]    - call: NULL
[17:43:33.969] plan(): nbrOfWorkers() = 1
[17:43:33.970] plan(): Setting new future strategy stack:
[17:43:33.970] List of future strategies:
[17:43:33.970] 1. sequential:
[17:43:33.970]    - args: function (..., envir = parent.frame())
[17:43:33.970]    - tweaked: FALSE
[17:43:33.970]    - call: plan(strategy)
[17:43:33.971] plan(): nbrOfWorkers() = 1
[17:43:33.971] SequentialFuture started (and completed)
[17:43:33.973] - Launch lazy future ... done
[17:43:33.973] run() for ‘SequentialFuture’ ... done
[17:43:33.974] resolve() on environment ...
[17:43:33.974]  recursive: 0
[17:43:33.974]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[17:43:33.974] resolved() for ‘SequentialFuture’ ...
[17:43:33.974] - state: ‘finished’
[17:43:33.974] - run: TRUE
[17:43:33.975] - result: ‘FutureResult’
[17:43:33.975] resolved() for ‘SequentialFuture’ ... done
[17:43:33.975] Future #1
[17:43:33.975]  length: 2 (resolved future 1)
[17:43:33.975] resolved() for ‘SequentialFuture’ ...
[17:43:33.975] - state: ‘finished’
[17:43:33.975] - run: TRUE
[17:43:33.975] - result: ‘FutureResult’
[17:43:33.975] resolved() for ‘SequentialFuture’ ... done
[17:43:33.975] Future #2
[17:43:33.976]  length: 1 (resolved future 2)
[17:43:33.976]  length: 0 (resolved future 3)
[17:43:33.976] resolve() on environment ... DONE
[17:43:33.976] getGlobalsAndPackages() ...
[17:43:33.976] Searching for globals...
[17:43:33.977] - globals found: [1] ‘{’
[17:43:33.977] Searching for globals ... DONE
[17:43:33.977] Resolving globals: FALSE
[17:43:33.977] 
[17:43:33.977] 
[17:43:33.977] getGlobalsAndPackages() ... DONE
[17:43:33.978] run() for ‘Future’ ...
[17:43:33.978] - state: ‘created’
[17:43:33.978] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:33.978] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:33.978] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:33.978]   - Field: ‘label’
[17:43:33.979]   - Field: ‘local’
[17:43:33.979]   - Field: ‘owner’
[17:43:33.979]   - Field: ‘envir’
[17:43:33.979]   - Field: ‘packages’
[17:43:33.979]   - Field: ‘gc’
[17:43:33.979]   - Field: ‘conditions’
[17:43:33.979]   - Field: ‘expr’
[17:43:33.979]   - Field: ‘uuid’
[17:43:33.979]   - Field: ‘seed’
[17:43:33.979]   - Field: ‘version’
[17:43:33.979]   - Field: ‘result’
[17:43:33.980]   - Field: ‘asynchronous’
[17:43:33.980]   - Field: ‘calls’
[17:43:33.980]   - Field: ‘globals’
[17:43:33.980]   - Field: ‘stdout’
[17:43:33.980]   - Field: ‘earlySignal’
[17:43:33.980]   - Field: ‘lazy’
[17:43:33.980]   - Field: ‘state’
[17:43:33.980] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:33.980] - Launch lazy future ...
[17:43:33.980] Packages needed by the future expression (n = 0): <none>
[17:43:33.981] Packages needed by future strategies (n = 0): <none>
[17:43:33.981] {
[17:43:33.981]     {
[17:43:33.981]         {
[17:43:33.981]             ...future.startTime <- base::Sys.time()
[17:43:33.981]             {
[17:43:33.981]                 {
[17:43:33.981]                   {
[17:43:33.981]                     base::local({
[17:43:33.981]                       has_future <- base::requireNamespace("future", 
[17:43:33.981]                         quietly = TRUE)
[17:43:33.981]                       if (has_future) {
[17:43:33.981]                         ns <- base::getNamespace("future")
[17:43:33.981]                         version <- ns[[".package"]][["version"]]
[17:43:33.981]                         if (is.null(version)) 
[17:43:33.981]                           version <- utils::packageVersion("future")
[17:43:33.981]                       }
[17:43:33.981]                       else {
[17:43:33.981]                         version <- NULL
[17:43:33.981]                       }
[17:43:33.981]                       if (!has_future || version < "1.8.0") {
[17:43:33.981]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:33.981]                           "", base::R.version$version.string), 
[17:43:33.981]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:33.981]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:33.981]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:33.981]                             "release", "version")], collapse = " "), 
[17:43:33.981]                           hostname = base::Sys.info()[["nodename"]])
[17:43:33.981]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:33.981]                           info)
[17:43:33.981]                         info <- base::paste(info, collapse = "; ")
[17:43:33.981]                         if (!has_future) {
[17:43:33.981]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:33.981]                             info)
[17:43:33.981]                         }
[17:43:33.981]                         else {
[17:43:33.981]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:33.981]                             info, version)
[17:43:33.981]                         }
[17:43:33.981]                         base::stop(msg)
[17:43:33.981]                       }
[17:43:33.981]                     })
[17:43:33.981]                   }
[17:43:33.981]                   options(future.plan = NULL)
[17:43:33.981]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:33.981]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:33.981]                 }
[17:43:33.981]                 ...future.workdir <- getwd()
[17:43:33.981]             }
[17:43:33.981]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:33.981]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:33.981]         }
[17:43:33.981]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:33.981]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:33.981]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:33.981]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:33.981]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:33.981]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:33.981]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:33.981]             base::names(...future.oldOptions))
[17:43:33.981]     }
[17:43:33.981]     if (FALSE) {
[17:43:33.981]     }
[17:43:33.981]     else {
[17:43:33.981]         if (TRUE) {
[17:43:33.981]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:33.981]                 open = "w")
[17:43:33.981]         }
[17:43:33.981]         else {
[17:43:33.981]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:33.981]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:33.981]         }
[17:43:33.981]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:33.981]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:33.981]             base::sink(type = "output", split = FALSE)
[17:43:33.981]             base::close(...future.stdout)
[17:43:33.981]         }, add = TRUE)
[17:43:33.981]     }
[17:43:33.981]     ...future.frame <- base::sys.nframe()
[17:43:33.981]     ...future.conditions <- base::list()
[17:43:33.981]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:33.981]     if (FALSE) {
[17:43:33.981]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:33.981]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:33.981]     }
[17:43:33.981]     ...future.result <- base::tryCatch({
[17:43:33.981]         base::withCallingHandlers({
[17:43:33.981]             ...future.value <- base::withVisible(base::local({
[17:43:33.981]                 1
[17:43:33.981]             }))
[17:43:33.981]             future::FutureResult(value = ...future.value$value, 
[17:43:33.981]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:33.981]                   ...future.rng), globalenv = if (FALSE) 
[17:43:33.981]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:33.981]                     ...future.globalenv.names))
[17:43:33.981]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:33.981]         }, condition = base::local({
[17:43:33.981]             c <- base::c
[17:43:33.981]             inherits <- base::inherits
[17:43:33.981]             invokeRestart <- base::invokeRestart
[17:43:33.981]             length <- base::length
[17:43:33.981]             list <- base::list
[17:43:33.981]             seq.int <- base::seq.int
[17:43:33.981]             signalCondition <- base::signalCondition
[17:43:33.981]             sys.calls <- base::sys.calls
[17:43:33.981]             `[[` <- base::`[[`
[17:43:33.981]             `+` <- base::`+`
[17:43:33.981]             `<<-` <- base::`<<-`
[17:43:33.981]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:33.981]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:33.981]                   3L)]
[17:43:33.981]             }
[17:43:33.981]             function(cond) {
[17:43:33.981]                 is_error <- inherits(cond, "error")
[17:43:33.981]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:33.981]                   NULL)
[17:43:33.981]                 if (is_error) {
[17:43:33.981]                   sessionInformation <- function() {
[17:43:33.981]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:33.981]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:33.981]                       search = base::search(), system = base::Sys.info())
[17:43:33.981]                   }
[17:43:33.981]                   ...future.conditions[[length(...future.conditions) + 
[17:43:33.981]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:33.981]                     cond$call), session = sessionInformation(), 
[17:43:33.981]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:33.981]                   signalCondition(cond)
[17:43:33.981]                 }
[17:43:33.981]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:33.981]                 "immediateCondition"))) {
[17:43:33.981]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:33.981]                   ...future.conditions[[length(...future.conditions) + 
[17:43:33.981]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:33.981]                   if (TRUE && !signal) {
[17:43:33.981]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:33.981]                     {
[17:43:33.981]                       inherits <- base::inherits
[17:43:33.981]                       invokeRestart <- base::invokeRestart
[17:43:33.981]                       is.null <- base::is.null
[17:43:33.981]                       muffled <- FALSE
[17:43:33.981]                       if (inherits(cond, "message")) {
[17:43:33.981]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:33.981]                         if (muffled) 
[17:43:33.981]                           invokeRestart("muffleMessage")
[17:43:33.981]                       }
[17:43:33.981]                       else if (inherits(cond, "warning")) {
[17:43:33.981]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:33.981]                         if (muffled) 
[17:43:33.981]                           invokeRestart("muffleWarning")
[17:43:33.981]                       }
[17:43:33.981]                       else if (inherits(cond, "condition")) {
[17:43:33.981]                         if (!is.null(pattern)) {
[17:43:33.981]                           computeRestarts <- base::computeRestarts
[17:43:33.981]                           grepl <- base::grepl
[17:43:33.981]                           restarts <- computeRestarts(cond)
[17:43:33.981]                           for (restart in restarts) {
[17:43:33.981]                             name <- restart$name
[17:43:33.981]                             if (is.null(name)) 
[17:43:33.981]                               next
[17:43:33.981]                             if (!grepl(pattern, name)) 
[17:43:33.981]                               next
[17:43:33.981]                             invokeRestart(restart)
[17:43:33.981]                             muffled <- TRUE
[17:43:33.981]                             break
[17:43:33.981]                           }
[17:43:33.981]                         }
[17:43:33.981]                       }
[17:43:33.981]                       invisible(muffled)
[17:43:33.981]                     }
[17:43:33.981]                     muffleCondition(cond, pattern = "^muffle")
[17:43:33.981]                   }
[17:43:33.981]                 }
[17:43:33.981]                 else {
[17:43:33.981]                   if (TRUE) {
[17:43:33.981]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:33.981]                     {
[17:43:33.981]                       inherits <- base::inherits
[17:43:33.981]                       invokeRestart <- base::invokeRestart
[17:43:33.981]                       is.null <- base::is.null
[17:43:33.981]                       muffled <- FALSE
[17:43:33.981]                       if (inherits(cond, "message")) {
[17:43:33.981]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:33.981]                         if (muffled) 
[17:43:33.981]                           invokeRestart("muffleMessage")
[17:43:33.981]                       }
[17:43:33.981]                       else if (inherits(cond, "warning")) {
[17:43:33.981]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:33.981]                         if (muffled) 
[17:43:33.981]                           invokeRestart("muffleWarning")
[17:43:33.981]                       }
[17:43:33.981]                       else if (inherits(cond, "condition")) {
[17:43:33.981]                         if (!is.null(pattern)) {
[17:43:33.981]                           computeRestarts <- base::computeRestarts
[17:43:33.981]                           grepl <- base::grepl
[17:43:33.981]                           restarts <- computeRestarts(cond)
[17:43:33.981]                           for (restart in restarts) {
[17:43:33.981]                             name <- restart$name
[17:43:33.981]                             if (is.null(name)) 
[17:43:33.981]                               next
[17:43:33.981]                             if (!grepl(pattern, name)) 
[17:43:33.981]                               next
[17:43:33.981]                             invokeRestart(restart)
[17:43:33.981]                             muffled <- TRUE
[17:43:33.981]                             break
[17:43:33.981]                           }
[17:43:33.981]                         }
[17:43:33.981]                       }
[17:43:33.981]                       invisible(muffled)
[17:43:33.981]                     }
[17:43:33.981]                     muffleCondition(cond, pattern = "^muffle")
[17:43:33.981]                   }
[17:43:33.981]                 }
[17:43:33.981]             }
[17:43:33.981]         }))
[17:43:33.981]     }, error = function(ex) {
[17:43:33.981]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:33.981]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:33.981]                 ...future.rng), started = ...future.startTime, 
[17:43:33.981]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:33.981]             version = "1.8"), class = "FutureResult")
[17:43:33.981]     }, finally = {
[17:43:33.981]         if (!identical(...future.workdir, getwd())) 
[17:43:33.981]             setwd(...future.workdir)
[17:43:33.981]         {
[17:43:33.981]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:33.981]                 ...future.oldOptions$nwarnings <- NULL
[17:43:33.981]             }
[17:43:33.981]             base::options(...future.oldOptions)
[17:43:33.981]             if (.Platform$OS.type == "windows") {
[17:43:33.981]                 old_names <- names(...future.oldEnvVars)
[17:43:33.981]                 envs <- base::Sys.getenv()
[17:43:33.981]                 names <- names(envs)
[17:43:33.981]                 common <- intersect(names, old_names)
[17:43:33.981]                 added <- setdiff(names, old_names)
[17:43:33.981]                 removed <- setdiff(old_names, names)
[17:43:33.981]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:33.981]                   envs[common]]
[17:43:33.981]                 NAMES <- toupper(changed)
[17:43:33.981]                 args <- list()
[17:43:33.981]                 for (kk in seq_along(NAMES)) {
[17:43:33.981]                   name <- changed[[kk]]
[17:43:33.981]                   NAME <- NAMES[[kk]]
[17:43:33.981]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:33.981]                     next
[17:43:33.981]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:33.981]                 }
[17:43:33.981]                 NAMES <- toupper(added)
[17:43:33.981]                 for (kk in seq_along(NAMES)) {
[17:43:33.981]                   name <- added[[kk]]
[17:43:33.981]                   NAME <- NAMES[[kk]]
[17:43:33.981]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:33.981]                     next
[17:43:33.981]                   args[[name]] <- ""
[17:43:33.981]                 }
[17:43:33.981]                 NAMES <- toupper(removed)
[17:43:33.981]                 for (kk in seq_along(NAMES)) {
[17:43:33.981]                   name <- removed[[kk]]
[17:43:33.981]                   NAME <- NAMES[[kk]]
[17:43:33.981]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:33.981]                     next
[17:43:33.981]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:33.981]                 }
[17:43:33.981]                 if (length(args) > 0) 
[17:43:33.981]                   base::do.call(base::Sys.setenv, args = args)
[17:43:33.981]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:33.981]             }
[17:43:33.981]             else {
[17:43:33.981]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:33.981]             }
[17:43:33.981]             {
[17:43:33.981]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:33.981]                   0L) {
[17:43:33.981]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:33.981]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:33.981]                   base::options(opts)
[17:43:33.981]                 }
[17:43:33.981]                 {
[17:43:33.981]                   {
[17:43:33.981]                     NULL
[17:43:33.981]                     RNGkind("Mersenne-Twister")
[17:43:33.981]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:33.981]                       inherits = FALSE)
[17:43:33.981]                   }
[17:43:33.981]                   options(future.plan = NULL)
[17:43:33.981]                   if (is.na(NA_character_)) 
[17:43:33.981]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:33.981]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:33.981]                   future::plan(list(function (..., envir = parent.frame()) 
[17:43:33.981]                   {
[17:43:33.981]                     future <- SequentialFuture(..., envir = envir)
[17:43:33.981]                     if (!future$lazy) 
[17:43:33.981]                       future <- run(future)
[17:43:33.981]                     invisible(future)
[17:43:33.981]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:33.981]                 }
[17:43:33.981]             }
[17:43:33.981]         }
[17:43:33.981]     })
[17:43:33.981]     if (TRUE) {
[17:43:33.981]         base::sink(type = "output", split = FALSE)
[17:43:33.981]         if (TRUE) {
[17:43:33.981]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:33.981]         }
[17:43:33.981]         else {
[17:43:33.981]             ...future.result["stdout"] <- base::list(NULL)
[17:43:33.981]         }
[17:43:33.981]         base::close(...future.stdout)
[17:43:33.981]         ...future.stdout <- NULL
[17:43:33.981]     }
[17:43:33.981]     ...future.result$conditions <- ...future.conditions
[17:43:33.981]     ...future.result$finished <- base::Sys.time()
[17:43:33.981]     ...future.result
[17:43:33.981] }
[17:43:33.983] plan(): Setting new future strategy stack:
[17:43:33.983] List of future strategies:
[17:43:33.983] 1. sequential:
[17:43:33.983]    - args: function (..., envir = parent.frame())
[17:43:33.983]    - tweaked: FALSE
[17:43:33.983]    - call: NULL
[17:43:33.983] plan(): nbrOfWorkers() = 1
[17:43:33.984] plan(): Setting new future strategy stack:
[17:43:33.984] List of future strategies:
[17:43:33.984] 1. sequential:
[17:43:33.984]    - args: function (..., envir = parent.frame())
[17:43:33.984]    - tweaked: FALSE
[17:43:33.984]    - call: plan(strategy)
[17:43:33.984] plan(): nbrOfWorkers() = 1
[17:43:33.985] SequentialFuture started (and completed)
[17:43:33.985] - Launch lazy future ... done
[17:43:33.985] run() for ‘SequentialFuture’ ... done
[17:43:33.985] getGlobalsAndPackages() ...
[17:43:33.985] Searching for globals...
[17:43:33.986] - globals found: [1] ‘{’
[17:43:33.986] Searching for globals ... DONE
[17:43:33.986] Resolving globals: FALSE
[17:43:33.986] 
[17:43:33.986] 
[17:43:33.986] getGlobalsAndPackages() ... DONE
[17:43:33.987] run() for ‘Future’ ...
[17:43:33.987] - state: ‘created’
[17:43:33.987] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:33.987] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:33.987] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:33.987]   - Field: ‘label’
[17:43:33.987]   - Field: ‘local’
[17:43:33.987]   - Field: ‘owner’
[17:43:33.988]   - Field: ‘envir’
[17:43:33.988]   - Field: ‘packages’
[17:43:33.988]   - Field: ‘gc’
[17:43:33.988]   - Field: ‘conditions’
[17:43:33.988]   - Field: ‘expr’
[17:43:33.988]   - Field: ‘uuid’
[17:43:33.988]   - Field: ‘seed’
[17:43:33.988]   - Field: ‘version’
[17:43:33.988]   - Field: ‘result’
[17:43:33.988]   - Field: ‘asynchronous’
[17:43:33.988]   - Field: ‘calls’
[17:43:33.989]   - Field: ‘globals’
[17:43:33.989]   - Field: ‘stdout’
[17:43:33.989]   - Field: ‘earlySignal’
[17:43:33.989]   - Field: ‘lazy’
[17:43:33.989]   - Field: ‘state’
[17:43:33.989] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:33.989] - Launch lazy future ...
[17:43:33.989] Packages needed by the future expression (n = 0): <none>
[17:43:33.989] Packages needed by future strategies (n = 0): <none>
[17:43:33.990] {
[17:43:33.990]     {
[17:43:33.990]         {
[17:43:33.990]             ...future.startTime <- base::Sys.time()
[17:43:33.990]             {
[17:43:33.990]                 {
[17:43:33.990]                   {
[17:43:33.990]                     base::local({
[17:43:33.990]                       has_future <- base::requireNamespace("future", 
[17:43:33.990]                         quietly = TRUE)
[17:43:33.990]                       if (has_future) {
[17:43:33.990]                         ns <- base::getNamespace("future")
[17:43:33.990]                         version <- ns[[".package"]][["version"]]
[17:43:33.990]                         if (is.null(version)) 
[17:43:33.990]                           version <- utils::packageVersion("future")
[17:43:33.990]                       }
[17:43:33.990]                       else {
[17:43:33.990]                         version <- NULL
[17:43:33.990]                       }
[17:43:33.990]                       if (!has_future || version < "1.8.0") {
[17:43:33.990]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:33.990]                           "", base::R.version$version.string), 
[17:43:33.990]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:33.990]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:33.990]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:33.990]                             "release", "version")], collapse = " "), 
[17:43:33.990]                           hostname = base::Sys.info()[["nodename"]])
[17:43:33.990]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:33.990]                           info)
[17:43:33.990]                         info <- base::paste(info, collapse = "; ")
[17:43:33.990]                         if (!has_future) {
[17:43:33.990]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:33.990]                             info)
[17:43:33.990]                         }
[17:43:33.990]                         else {
[17:43:33.990]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:33.990]                             info, version)
[17:43:33.990]                         }
[17:43:33.990]                         base::stop(msg)
[17:43:33.990]                       }
[17:43:33.990]                     })
[17:43:33.990]                   }
[17:43:33.990]                   options(future.plan = NULL)
[17:43:33.990]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:33.990]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:33.990]                 }
[17:43:33.990]                 ...future.workdir <- getwd()
[17:43:33.990]             }
[17:43:33.990]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:33.990]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:33.990]         }
[17:43:33.990]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:33.990]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:33.990]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:33.990]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:33.990]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:33.990]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:33.990]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:33.990]             base::names(...future.oldOptions))
[17:43:33.990]     }
[17:43:33.990]     if (FALSE) {
[17:43:33.990]     }
[17:43:33.990]     else {
[17:43:33.990]         if (TRUE) {
[17:43:33.990]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:33.990]                 open = "w")
[17:43:33.990]         }
[17:43:33.990]         else {
[17:43:33.990]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:33.990]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:33.990]         }
[17:43:33.990]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:33.990]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:33.990]             base::sink(type = "output", split = FALSE)
[17:43:33.990]             base::close(...future.stdout)
[17:43:33.990]         }, add = TRUE)
[17:43:33.990]     }
[17:43:33.990]     ...future.frame <- base::sys.nframe()
[17:43:33.990]     ...future.conditions <- base::list()
[17:43:33.990]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:33.990]     if (FALSE) {
[17:43:33.990]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:33.990]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:33.990]     }
[17:43:33.990]     ...future.result <- base::tryCatch({
[17:43:33.990]         base::withCallingHandlers({
[17:43:33.990]             ...future.value <- base::withVisible(base::local({
[17:43:33.990]                 2
[17:43:33.990]             }))
[17:43:33.990]             future::FutureResult(value = ...future.value$value, 
[17:43:33.990]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:33.990]                   ...future.rng), globalenv = if (FALSE) 
[17:43:33.990]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:33.990]                     ...future.globalenv.names))
[17:43:33.990]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:33.990]         }, condition = base::local({
[17:43:33.990]             c <- base::c
[17:43:33.990]             inherits <- base::inherits
[17:43:33.990]             invokeRestart <- base::invokeRestart
[17:43:33.990]             length <- base::length
[17:43:33.990]             list <- base::list
[17:43:33.990]             seq.int <- base::seq.int
[17:43:33.990]             signalCondition <- base::signalCondition
[17:43:33.990]             sys.calls <- base::sys.calls
[17:43:33.990]             `[[` <- base::`[[`
[17:43:33.990]             `+` <- base::`+`
[17:43:33.990]             `<<-` <- base::`<<-`
[17:43:33.990]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:33.990]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:33.990]                   3L)]
[17:43:33.990]             }
[17:43:33.990]             function(cond) {
[17:43:33.990]                 is_error <- inherits(cond, "error")
[17:43:33.990]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:33.990]                   NULL)
[17:43:33.990]                 if (is_error) {
[17:43:33.990]                   sessionInformation <- function() {
[17:43:33.990]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:33.990]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:33.990]                       search = base::search(), system = base::Sys.info())
[17:43:33.990]                   }
[17:43:33.990]                   ...future.conditions[[length(...future.conditions) + 
[17:43:33.990]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:33.990]                     cond$call), session = sessionInformation(), 
[17:43:33.990]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:33.990]                   signalCondition(cond)
[17:43:33.990]                 }
[17:43:33.990]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:33.990]                 "immediateCondition"))) {
[17:43:33.990]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:33.990]                   ...future.conditions[[length(...future.conditions) + 
[17:43:33.990]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:33.990]                   if (TRUE && !signal) {
[17:43:33.990]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:33.990]                     {
[17:43:33.990]                       inherits <- base::inherits
[17:43:33.990]                       invokeRestart <- base::invokeRestart
[17:43:33.990]                       is.null <- base::is.null
[17:43:33.990]                       muffled <- FALSE
[17:43:33.990]                       if (inherits(cond, "message")) {
[17:43:33.990]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:33.990]                         if (muffled) 
[17:43:33.990]                           invokeRestart("muffleMessage")
[17:43:33.990]                       }
[17:43:33.990]                       else if (inherits(cond, "warning")) {
[17:43:33.990]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:33.990]                         if (muffled) 
[17:43:33.990]                           invokeRestart("muffleWarning")
[17:43:33.990]                       }
[17:43:33.990]                       else if (inherits(cond, "condition")) {
[17:43:33.990]                         if (!is.null(pattern)) {
[17:43:33.990]                           computeRestarts <- base::computeRestarts
[17:43:33.990]                           grepl <- base::grepl
[17:43:33.990]                           restarts <- computeRestarts(cond)
[17:43:33.990]                           for (restart in restarts) {
[17:43:33.990]                             name <- restart$name
[17:43:33.990]                             if (is.null(name)) 
[17:43:33.990]                               next
[17:43:33.990]                             if (!grepl(pattern, name)) 
[17:43:33.990]                               next
[17:43:33.990]                             invokeRestart(restart)
[17:43:33.990]                             muffled <- TRUE
[17:43:33.990]                             break
[17:43:33.990]                           }
[17:43:33.990]                         }
[17:43:33.990]                       }
[17:43:33.990]                       invisible(muffled)
[17:43:33.990]                     }
[17:43:33.990]                     muffleCondition(cond, pattern = "^muffle")
[17:43:33.990]                   }
[17:43:33.990]                 }
[17:43:33.990]                 else {
[17:43:33.990]                   if (TRUE) {
[17:43:33.990]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:33.990]                     {
[17:43:33.990]                       inherits <- base::inherits
[17:43:33.990]                       invokeRestart <- base::invokeRestart
[17:43:33.990]                       is.null <- base::is.null
[17:43:33.990]                       muffled <- FALSE
[17:43:33.990]                       if (inherits(cond, "message")) {
[17:43:33.990]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:33.990]                         if (muffled) 
[17:43:33.990]                           invokeRestart("muffleMessage")
[17:43:33.990]                       }
[17:43:33.990]                       else if (inherits(cond, "warning")) {
[17:43:33.990]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:33.990]                         if (muffled) 
[17:43:33.990]                           invokeRestart("muffleWarning")
[17:43:33.990]                       }
[17:43:33.990]                       else if (inherits(cond, "condition")) {
[17:43:33.990]                         if (!is.null(pattern)) {
[17:43:33.990]                           computeRestarts <- base::computeRestarts
[17:43:33.990]                           grepl <- base::grepl
[17:43:33.990]                           restarts <- computeRestarts(cond)
[17:43:33.990]                           for (restart in restarts) {
[17:43:33.990]                             name <- restart$name
[17:43:33.990]                             if (is.null(name)) 
[17:43:33.990]                               next
[17:43:33.990]                             if (!grepl(pattern, name)) 
[17:43:33.990]                               next
[17:43:33.990]                             invokeRestart(restart)
[17:43:33.990]                             muffled <- TRUE
[17:43:33.990]                             break
[17:43:33.990]                           }
[17:43:33.990]                         }
[17:43:33.990]                       }
[17:43:33.990]                       invisible(muffled)
[17:43:33.990]                     }
[17:43:33.990]                     muffleCondition(cond, pattern = "^muffle")
[17:43:33.990]                   }
[17:43:33.990]                 }
[17:43:33.990]             }
[17:43:33.990]         }))
[17:43:33.990]     }, error = function(ex) {
[17:43:33.990]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:33.990]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:33.990]                 ...future.rng), started = ...future.startTime, 
[17:43:33.990]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:33.990]             version = "1.8"), class = "FutureResult")
[17:43:33.990]     }, finally = {
[17:43:33.990]         if (!identical(...future.workdir, getwd())) 
[17:43:33.990]             setwd(...future.workdir)
[17:43:33.990]         {
[17:43:33.990]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:33.990]                 ...future.oldOptions$nwarnings <- NULL
[17:43:33.990]             }
[17:43:33.990]             base::options(...future.oldOptions)
[17:43:33.990]             if (.Platform$OS.type == "windows") {
[17:43:33.990]                 old_names <- names(...future.oldEnvVars)
[17:43:33.990]                 envs <- base::Sys.getenv()
[17:43:33.990]                 names <- names(envs)
[17:43:33.990]                 common <- intersect(names, old_names)
[17:43:33.990]                 added <- setdiff(names, old_names)
[17:43:33.990]                 removed <- setdiff(old_names, names)
[17:43:33.990]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:33.990]                   envs[common]]
[17:43:33.990]                 NAMES <- toupper(changed)
[17:43:33.990]                 args <- list()
[17:43:33.990]                 for (kk in seq_along(NAMES)) {
[17:43:33.990]                   name <- changed[[kk]]
[17:43:33.990]                   NAME <- NAMES[[kk]]
[17:43:33.990]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:33.990]                     next
[17:43:33.990]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:33.990]                 }
[17:43:33.990]                 NAMES <- toupper(added)
[17:43:33.990]                 for (kk in seq_along(NAMES)) {
[17:43:33.990]                   name <- added[[kk]]
[17:43:33.990]                   NAME <- NAMES[[kk]]
[17:43:33.990]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:33.990]                     next
[17:43:33.990]                   args[[name]] <- ""
[17:43:33.990]                 }
[17:43:33.990]                 NAMES <- toupper(removed)
[17:43:33.990]                 for (kk in seq_along(NAMES)) {
[17:43:33.990]                   name <- removed[[kk]]
[17:43:33.990]                   NAME <- NAMES[[kk]]
[17:43:33.990]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:33.990]                     next
[17:43:33.990]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:33.990]                 }
[17:43:33.990]                 if (length(args) > 0) 
[17:43:33.990]                   base::do.call(base::Sys.setenv, args = args)
[17:43:33.990]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:33.990]             }
[17:43:33.990]             else {
[17:43:33.990]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:33.990]             }
[17:43:33.990]             {
[17:43:33.990]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:33.990]                   0L) {
[17:43:33.990]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:33.990]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:33.990]                   base::options(opts)
[17:43:33.990]                 }
[17:43:33.990]                 {
[17:43:33.990]                   {
[17:43:33.990]                     NULL
[17:43:33.990]                     RNGkind("Mersenne-Twister")
[17:43:33.990]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:33.990]                       inherits = FALSE)
[17:43:33.990]                   }
[17:43:33.990]                   options(future.plan = NULL)
[17:43:33.990]                   if (is.na(NA_character_)) 
[17:43:33.990]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:33.990]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:33.990]                   future::plan(list(function (..., envir = parent.frame()) 
[17:43:33.990]                   {
[17:43:33.990]                     future <- SequentialFuture(..., envir = envir)
[17:43:33.990]                     if (!future$lazy) 
[17:43:33.990]                       future <- run(future)
[17:43:33.990]                     invisible(future)
[17:43:33.990]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:33.990]                 }
[17:43:33.990]             }
[17:43:33.990]         }
[17:43:33.990]     })
[17:43:33.990]     if (TRUE) {
[17:43:33.990]         base::sink(type = "output", split = FALSE)
[17:43:33.990]         if (TRUE) {
[17:43:33.990]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:33.990]         }
[17:43:33.990]         else {
[17:43:33.990]             ...future.result["stdout"] <- base::list(NULL)
[17:43:33.990]         }
[17:43:33.990]         base::close(...future.stdout)
[17:43:33.990]         ...future.stdout <- NULL
[17:43:33.990]     }
[17:43:33.990]     ...future.result$conditions <- ...future.conditions
[17:43:33.990]     ...future.result$finished <- base::Sys.time()
[17:43:33.990]     ...future.result
[17:43:33.990] }
[17:43:33.992] plan(): Setting new future strategy stack:
[17:43:33.992] List of future strategies:
[17:43:33.992] 1. sequential:
[17:43:33.992]    - args: function (..., envir = parent.frame())
[17:43:33.992]    - tweaked: FALSE
[17:43:33.992]    - call: NULL
[17:43:33.992] plan(): nbrOfWorkers() = 1
[17:43:33.993] plan(): Setting new future strategy stack:
[17:43:33.993] List of future strategies:
[17:43:33.993] 1. sequential:
[17:43:33.993]    - args: function (..., envir = parent.frame())
[17:43:33.993]    - tweaked: FALSE
[17:43:33.993]    - call: plan(strategy)
[17:43:33.993] plan(): nbrOfWorkers() = 1
[17:43:33.993] SequentialFuture started (and completed)
[17:43:33.993] - Launch lazy future ... done
[17:43:33.993] run() for ‘SequentialFuture’ ... done
[17:43:33.994] resolve() on environment ...
[17:43:33.994]  recursive: 0
[17:43:33.995]  elements: [3] ‘a’
[17:43:33.995] resolved() for ‘SequentialFuture’ ...
[17:43:33.995] - state: ‘finished’
[17:43:33.995] - run: TRUE
[17:43:33.995] - result: ‘FutureResult’
[17:43:33.995] resolved() for ‘SequentialFuture’ ... done
[17:43:33.995] Future #1
[17:43:33.995]  length: 2 (resolved future 1)
[17:43:33.995] resolved() for ‘SequentialFuture’ ...
[17:43:33.995] - state: ‘finished’
[17:43:33.996] - run: TRUE
[17:43:33.996] - result: ‘FutureResult’
[17:43:33.996] resolved() for ‘SequentialFuture’ ... done
[17:43:33.996] Future #2
[17:43:33.996]  length: 1 (resolved future 2)
[17:43:33.996]  length: 0 (resolved future 3)
[17:43:33.996] resolve() on environment ... DONE
[17:43:33.996] resolved() for ‘SequentialFuture’ ...
[17:43:33.997] - state: ‘finished’
[17:43:33.997] - run: TRUE
[17:43:33.997] - result: ‘FutureResult’
[17:43:33.997] resolved() for ‘SequentialFuture’ ... done
[17:43:33.997] resolve() on environment ...
[17:43:33.997]  recursive: 0
[17:43:33.998]  elements: [3] ‘b’
[17:43:33.998] resolved() for ‘SequentialFuture’ ...
[17:43:33.998] - state: ‘finished’
[17:43:33.998] - run: TRUE
[17:43:33.998] - result: ‘FutureResult’
[17:43:33.998] resolved() for ‘SequentialFuture’ ... done
[17:43:34.000] Future #1
[17:43:34.000]  length: 2 (resolved future 1)
[17:43:34.000] resolved() for ‘SequentialFuture’ ...
[17:43:34.000] - state: ‘finished’
[17:43:34.000] - run: TRUE
[17:43:34.000] - result: ‘FutureResult’
[17:43:34.001] resolved() for ‘SequentialFuture’ ... done
[17:43:34.001] Future #2
[17:43:34.001]  length: 1 (resolved future 2)
[17:43:34.001]  length: 0 (resolved future 3)
[17:43:34.001] resolve() on environment ... DONE
[17:43:34.001] resolve() on environment ...
[17:43:34.002]  recursive: 0
[17:43:34.002]  elements: [3] ‘c’
[17:43:34.002] resolved() for ‘SequentialFuture’ ...
[17:43:34.002] - state: ‘finished’
[17:43:34.002] - run: TRUE
[17:43:34.002] - result: ‘FutureResult’
[17:43:34.002] resolved() for ‘SequentialFuture’ ... done
[17:43:34.003] Future #1
[17:43:34.003]  length: 2 (resolved future 1)
[17:43:34.003] resolved() for ‘SequentialFuture’ ...
[17:43:34.003] - state: ‘finished’
[17:43:34.003] - run: TRUE
[17:43:34.003] - result: ‘FutureResult’
[17:43:34.003] resolved() for ‘SequentialFuture’ ... done
[17:43:34.003] Future #2
[17:43:34.003]  length: 1 (resolved future 2)
[17:43:34.003]  length: 0 (resolved future 3)
[17:43:34.004] resolve() on environment ... DONE
[17:43:34.004] resolve() on environment ...
[17:43:34.004]  recursive: 0
[17:43:34.005]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[17:43:34.005] resolved() for ‘SequentialFuture’ ...
[17:43:34.005] - state: ‘finished’
[17:43:34.005] - run: TRUE
[17:43:34.005] - result: ‘FutureResult’
[17:43:34.005] resolved() for ‘SequentialFuture’ ... done
[17:43:34.005] Future #1
[17:43:34.006]  length: 2 (resolved future 1)
[17:43:34.006] resolved() for ‘SequentialFuture’ ...
[17:43:34.006] - state: ‘finished’
[17:43:34.006] - run: TRUE
[17:43:34.006] - result: ‘FutureResult’
[17:43:34.006] resolved() for ‘SequentialFuture’ ... done
[17:43:34.006] Future #2
[17:43:34.006]  length: 1 (resolved future 2)
[17:43:34.007]  length: 0 (resolved future 3)
[17:43:34.007] resolve() on environment ... DONE
[17:43:34.007] resolve() on environment ...
[17:43:34.007]  recursive: 99
[17:43:34.008]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[17:43:34.008] resolved() for ‘SequentialFuture’ ...
[17:43:34.008] - state: ‘finished’
[17:43:34.008] - run: TRUE
[17:43:34.008] - result: ‘FutureResult’
[17:43:34.008] resolved() for ‘SequentialFuture’ ... done
[17:43:34.008] Future #1
[17:43:34.008] resolved() for ‘SequentialFuture’ ...
[17:43:34.008] - state: ‘finished’
[17:43:34.009] - run: TRUE
[17:43:34.009] - result: ‘FutureResult’
[17:43:34.009] resolved() for ‘SequentialFuture’ ... done
[17:43:34.009] A SequentialFuture was resolved
[17:43:34.009]  length: 2 (resolved future 1)
[17:43:34.009] resolved() for ‘SequentialFuture’ ...
[17:43:34.009] - state: ‘finished’
[17:43:34.009] - run: TRUE
[17:43:34.009] - result: ‘FutureResult’
[17:43:34.009] resolved() for ‘SequentialFuture’ ... done
[17:43:34.010] Future #2
[17:43:34.010] resolved() for ‘SequentialFuture’ ...
[17:43:34.010] - state: ‘finished’
[17:43:34.010] - run: TRUE
[17:43:34.010] - result: ‘FutureResult’
[17:43:34.010] resolved() for ‘SequentialFuture’ ... done
[17:43:34.010] A SequentialFuture was resolved
[17:43:34.010]  length: 1 (resolved future 2)
[17:43:34.010]  length: 0 (resolved future 3)
[17:43:34.010] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[17:43:34.012] resolve() on list environment ...
[17:43:34.012]  recursive: 0
[17:43:34.013]  length: 2
[17:43:34.013]  elements: ‘a’, ‘b’
[17:43:34.013]  length: 1 (resolved future 1)
[17:43:34.013]  length: 0 (resolved future 2)
[17:43:34.013] resolve() on list environment ... DONE
[17:43:34.013] getGlobalsAndPackages() ...
[17:43:34.013] Searching for globals...
[17:43:34.014] 
[17:43:34.014] Searching for globals ... DONE
[17:43:34.014] - globals: [0] <none>
[17:43:34.014] getGlobalsAndPackages() ... DONE
[17:43:34.014] run() for ‘Future’ ...
[17:43:34.014] - state: ‘created’
[17:43:34.014] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:34.015] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:34.015] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:34.015]   - Field: ‘label’
[17:43:34.015]   - Field: ‘local’
[17:43:34.015]   - Field: ‘owner’
[17:43:34.015]   - Field: ‘envir’
[17:43:34.015]   - Field: ‘packages’
[17:43:34.016]   - Field: ‘gc’
[17:43:34.016]   - Field: ‘conditions’
[17:43:34.016]   - Field: ‘expr’
[17:43:34.016]   - Field: ‘uuid’
[17:43:34.016]   - Field: ‘seed’
[17:43:34.016]   - Field: ‘version’
[17:43:34.016]   - Field: ‘result’
[17:43:34.016]   - Field: ‘asynchronous’
[17:43:34.016]   - Field: ‘calls’
[17:43:34.016]   - Field: ‘globals’
[17:43:34.016]   - Field: ‘stdout’
[17:43:34.017]   - Field: ‘earlySignal’
[17:43:34.017]   - Field: ‘lazy’
[17:43:34.017]   - Field: ‘state’
[17:43:34.017] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:34.017] - Launch lazy future ...
[17:43:34.017] Packages needed by the future expression (n = 0): <none>
[17:43:34.017] Packages needed by future strategies (n = 0): <none>
[17:43:34.018] {
[17:43:34.018]     {
[17:43:34.018]         {
[17:43:34.018]             ...future.startTime <- base::Sys.time()
[17:43:34.018]             {
[17:43:34.018]                 {
[17:43:34.018]                   {
[17:43:34.018]                     base::local({
[17:43:34.018]                       has_future <- base::requireNamespace("future", 
[17:43:34.018]                         quietly = TRUE)
[17:43:34.018]                       if (has_future) {
[17:43:34.018]                         ns <- base::getNamespace("future")
[17:43:34.018]                         version <- ns[[".package"]][["version"]]
[17:43:34.018]                         if (is.null(version)) 
[17:43:34.018]                           version <- utils::packageVersion("future")
[17:43:34.018]                       }
[17:43:34.018]                       else {
[17:43:34.018]                         version <- NULL
[17:43:34.018]                       }
[17:43:34.018]                       if (!has_future || version < "1.8.0") {
[17:43:34.018]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:34.018]                           "", base::R.version$version.string), 
[17:43:34.018]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:34.018]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:34.018]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:34.018]                             "release", "version")], collapse = " "), 
[17:43:34.018]                           hostname = base::Sys.info()[["nodename"]])
[17:43:34.018]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:34.018]                           info)
[17:43:34.018]                         info <- base::paste(info, collapse = "; ")
[17:43:34.018]                         if (!has_future) {
[17:43:34.018]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:34.018]                             info)
[17:43:34.018]                         }
[17:43:34.018]                         else {
[17:43:34.018]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:34.018]                             info, version)
[17:43:34.018]                         }
[17:43:34.018]                         base::stop(msg)
[17:43:34.018]                       }
[17:43:34.018]                     })
[17:43:34.018]                   }
[17:43:34.018]                   options(future.plan = NULL)
[17:43:34.018]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:34.018]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:34.018]                 }
[17:43:34.018]                 ...future.workdir <- getwd()
[17:43:34.018]             }
[17:43:34.018]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:34.018]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:34.018]         }
[17:43:34.018]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:34.018]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:34.018]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:34.018]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:34.018]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:34.018]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:34.018]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:34.018]             base::names(...future.oldOptions))
[17:43:34.018]     }
[17:43:34.018]     if (FALSE) {
[17:43:34.018]     }
[17:43:34.018]     else {
[17:43:34.018]         if (TRUE) {
[17:43:34.018]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:34.018]                 open = "w")
[17:43:34.018]         }
[17:43:34.018]         else {
[17:43:34.018]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:34.018]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:34.018]         }
[17:43:34.018]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:34.018]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:34.018]             base::sink(type = "output", split = FALSE)
[17:43:34.018]             base::close(...future.stdout)
[17:43:34.018]         }, add = TRUE)
[17:43:34.018]     }
[17:43:34.018]     ...future.frame <- base::sys.nframe()
[17:43:34.018]     ...future.conditions <- base::list()
[17:43:34.018]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:34.018]     if (FALSE) {
[17:43:34.018]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:34.018]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:34.018]     }
[17:43:34.018]     ...future.result <- base::tryCatch({
[17:43:34.018]         base::withCallingHandlers({
[17:43:34.018]             ...future.value <- base::withVisible(base::local(1))
[17:43:34.018]             future::FutureResult(value = ...future.value$value, 
[17:43:34.018]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:34.018]                   ...future.rng), globalenv = if (FALSE) 
[17:43:34.018]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:34.018]                     ...future.globalenv.names))
[17:43:34.018]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:34.018]         }, condition = base::local({
[17:43:34.018]             c <- base::c
[17:43:34.018]             inherits <- base::inherits
[17:43:34.018]             invokeRestart <- base::invokeRestart
[17:43:34.018]             length <- base::length
[17:43:34.018]             list <- base::list
[17:43:34.018]             seq.int <- base::seq.int
[17:43:34.018]             signalCondition <- base::signalCondition
[17:43:34.018]             sys.calls <- base::sys.calls
[17:43:34.018]             `[[` <- base::`[[`
[17:43:34.018]             `+` <- base::`+`
[17:43:34.018]             `<<-` <- base::`<<-`
[17:43:34.018]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:34.018]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:34.018]                   3L)]
[17:43:34.018]             }
[17:43:34.018]             function(cond) {
[17:43:34.018]                 is_error <- inherits(cond, "error")
[17:43:34.018]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:34.018]                   NULL)
[17:43:34.018]                 if (is_error) {
[17:43:34.018]                   sessionInformation <- function() {
[17:43:34.018]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:34.018]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:34.018]                       search = base::search(), system = base::Sys.info())
[17:43:34.018]                   }
[17:43:34.018]                   ...future.conditions[[length(...future.conditions) + 
[17:43:34.018]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:34.018]                     cond$call), session = sessionInformation(), 
[17:43:34.018]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:34.018]                   signalCondition(cond)
[17:43:34.018]                 }
[17:43:34.018]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:34.018]                 "immediateCondition"))) {
[17:43:34.018]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:34.018]                   ...future.conditions[[length(...future.conditions) + 
[17:43:34.018]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:34.018]                   if (TRUE && !signal) {
[17:43:34.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:34.018]                     {
[17:43:34.018]                       inherits <- base::inherits
[17:43:34.018]                       invokeRestart <- base::invokeRestart
[17:43:34.018]                       is.null <- base::is.null
[17:43:34.018]                       muffled <- FALSE
[17:43:34.018]                       if (inherits(cond, "message")) {
[17:43:34.018]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:34.018]                         if (muffled) 
[17:43:34.018]                           invokeRestart("muffleMessage")
[17:43:34.018]                       }
[17:43:34.018]                       else if (inherits(cond, "warning")) {
[17:43:34.018]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:34.018]                         if (muffled) 
[17:43:34.018]                           invokeRestart("muffleWarning")
[17:43:34.018]                       }
[17:43:34.018]                       else if (inherits(cond, "condition")) {
[17:43:34.018]                         if (!is.null(pattern)) {
[17:43:34.018]                           computeRestarts <- base::computeRestarts
[17:43:34.018]                           grepl <- base::grepl
[17:43:34.018]                           restarts <- computeRestarts(cond)
[17:43:34.018]                           for (restart in restarts) {
[17:43:34.018]                             name <- restart$name
[17:43:34.018]                             if (is.null(name)) 
[17:43:34.018]                               next
[17:43:34.018]                             if (!grepl(pattern, name)) 
[17:43:34.018]                               next
[17:43:34.018]                             invokeRestart(restart)
[17:43:34.018]                             muffled <- TRUE
[17:43:34.018]                             break
[17:43:34.018]                           }
[17:43:34.018]                         }
[17:43:34.018]                       }
[17:43:34.018]                       invisible(muffled)
[17:43:34.018]                     }
[17:43:34.018]                     muffleCondition(cond, pattern = "^muffle")
[17:43:34.018]                   }
[17:43:34.018]                 }
[17:43:34.018]                 else {
[17:43:34.018]                   if (TRUE) {
[17:43:34.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:34.018]                     {
[17:43:34.018]                       inherits <- base::inherits
[17:43:34.018]                       invokeRestart <- base::invokeRestart
[17:43:34.018]                       is.null <- base::is.null
[17:43:34.018]                       muffled <- FALSE
[17:43:34.018]                       if (inherits(cond, "message")) {
[17:43:34.018]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:34.018]                         if (muffled) 
[17:43:34.018]                           invokeRestart("muffleMessage")
[17:43:34.018]                       }
[17:43:34.018]                       else if (inherits(cond, "warning")) {
[17:43:34.018]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:34.018]                         if (muffled) 
[17:43:34.018]                           invokeRestart("muffleWarning")
[17:43:34.018]                       }
[17:43:34.018]                       else if (inherits(cond, "condition")) {
[17:43:34.018]                         if (!is.null(pattern)) {
[17:43:34.018]                           computeRestarts <- base::computeRestarts
[17:43:34.018]                           grepl <- base::grepl
[17:43:34.018]                           restarts <- computeRestarts(cond)
[17:43:34.018]                           for (restart in restarts) {
[17:43:34.018]                             name <- restart$name
[17:43:34.018]                             if (is.null(name)) 
[17:43:34.018]                               next
[17:43:34.018]                             if (!grepl(pattern, name)) 
[17:43:34.018]                               next
[17:43:34.018]                             invokeRestart(restart)
[17:43:34.018]                             muffled <- TRUE
[17:43:34.018]                             break
[17:43:34.018]                           }
[17:43:34.018]                         }
[17:43:34.018]                       }
[17:43:34.018]                       invisible(muffled)
[17:43:34.018]                     }
[17:43:34.018]                     muffleCondition(cond, pattern = "^muffle")
[17:43:34.018]                   }
[17:43:34.018]                 }
[17:43:34.018]             }
[17:43:34.018]         }))
[17:43:34.018]     }, error = function(ex) {
[17:43:34.018]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:34.018]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:34.018]                 ...future.rng), started = ...future.startTime, 
[17:43:34.018]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:34.018]             version = "1.8"), class = "FutureResult")
[17:43:34.018]     }, finally = {
[17:43:34.018]         if (!identical(...future.workdir, getwd())) 
[17:43:34.018]             setwd(...future.workdir)
[17:43:34.018]         {
[17:43:34.018]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:34.018]                 ...future.oldOptions$nwarnings <- NULL
[17:43:34.018]             }
[17:43:34.018]             base::options(...future.oldOptions)
[17:43:34.018]             if (.Platform$OS.type == "windows") {
[17:43:34.018]                 old_names <- names(...future.oldEnvVars)
[17:43:34.018]                 envs <- base::Sys.getenv()
[17:43:34.018]                 names <- names(envs)
[17:43:34.018]                 common <- intersect(names, old_names)
[17:43:34.018]                 added <- setdiff(names, old_names)
[17:43:34.018]                 removed <- setdiff(old_names, names)
[17:43:34.018]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:34.018]                   envs[common]]
[17:43:34.018]                 NAMES <- toupper(changed)
[17:43:34.018]                 args <- list()
[17:43:34.018]                 for (kk in seq_along(NAMES)) {
[17:43:34.018]                   name <- changed[[kk]]
[17:43:34.018]                   NAME <- NAMES[[kk]]
[17:43:34.018]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.018]                     next
[17:43:34.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:34.018]                 }
[17:43:34.018]                 NAMES <- toupper(added)
[17:43:34.018]                 for (kk in seq_along(NAMES)) {
[17:43:34.018]                   name <- added[[kk]]
[17:43:34.018]                   NAME <- NAMES[[kk]]
[17:43:34.018]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.018]                     next
[17:43:34.018]                   args[[name]] <- ""
[17:43:34.018]                 }
[17:43:34.018]                 NAMES <- toupper(removed)
[17:43:34.018]                 for (kk in seq_along(NAMES)) {
[17:43:34.018]                   name <- removed[[kk]]
[17:43:34.018]                   NAME <- NAMES[[kk]]
[17:43:34.018]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.018]                     next
[17:43:34.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:34.018]                 }
[17:43:34.018]                 if (length(args) > 0) 
[17:43:34.018]                   base::do.call(base::Sys.setenv, args = args)
[17:43:34.018]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:34.018]             }
[17:43:34.018]             else {
[17:43:34.018]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:34.018]             }
[17:43:34.018]             {
[17:43:34.018]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:34.018]                   0L) {
[17:43:34.018]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:34.018]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:34.018]                   base::options(opts)
[17:43:34.018]                 }
[17:43:34.018]                 {
[17:43:34.018]                   {
[17:43:34.018]                     NULL
[17:43:34.018]                     RNGkind("Mersenne-Twister")
[17:43:34.018]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:34.018]                       inherits = FALSE)
[17:43:34.018]                   }
[17:43:34.018]                   options(future.plan = NULL)
[17:43:34.018]                   if (is.na(NA_character_)) 
[17:43:34.018]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:34.018]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:34.018]                   future::plan(list(function (..., envir = parent.frame()) 
[17:43:34.018]                   {
[17:43:34.018]                     future <- SequentialFuture(..., envir = envir)
[17:43:34.018]                     if (!future$lazy) 
[17:43:34.018]                       future <- run(future)
[17:43:34.018]                     invisible(future)
[17:43:34.018]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:34.018]                 }
[17:43:34.018]             }
[17:43:34.018]         }
[17:43:34.018]     })
[17:43:34.018]     if (TRUE) {
[17:43:34.018]         base::sink(type = "output", split = FALSE)
[17:43:34.018]         if (TRUE) {
[17:43:34.018]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:34.018]         }
[17:43:34.018]         else {
[17:43:34.018]             ...future.result["stdout"] <- base::list(NULL)
[17:43:34.018]         }
[17:43:34.018]         base::close(...future.stdout)
[17:43:34.018]         ...future.stdout <- NULL
[17:43:34.018]     }
[17:43:34.018]     ...future.result$conditions <- ...future.conditions
[17:43:34.018]     ...future.result$finished <- base::Sys.time()
[17:43:34.018]     ...future.result
[17:43:34.018] }
[17:43:34.020] plan(): Setting new future strategy stack:
[17:43:34.020] List of future strategies:
[17:43:34.020] 1. sequential:
[17:43:34.020]    - args: function (..., envir = parent.frame())
[17:43:34.020]    - tweaked: FALSE
[17:43:34.020]    - call: NULL
[17:43:34.020] plan(): nbrOfWorkers() = 1
[17:43:34.021] plan(): Setting new future strategy stack:
[17:43:34.021] List of future strategies:
[17:43:34.021] 1. sequential:
[17:43:34.021]    - args: function (..., envir = parent.frame())
[17:43:34.021]    - tweaked: FALSE
[17:43:34.021]    - call: plan(strategy)
[17:43:34.021] plan(): nbrOfWorkers() = 1
[17:43:34.021] SequentialFuture started (and completed)
[17:43:34.022] - Launch lazy future ... done
[17:43:34.022] run() for ‘SequentialFuture’ ... done
[17:43:34.022] getGlobalsAndPackages() ...
[17:43:34.022] Searching for globals...
[17:43:34.022] 
[17:43:34.022] Searching for globals ... DONE
[17:43:34.022] - globals: [0] <none>
[17:43:34.022] getGlobalsAndPackages() ... DONE
[17:43:34.023] run() for ‘Future’ ...
[17:43:34.023] - state: ‘created’
[17:43:34.023] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:34.023] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:34.023] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:34.023]   - Field: ‘label’
[17:43:34.024]   - Field: ‘local’
[17:43:34.024]   - Field: ‘owner’
[17:43:34.024]   - Field: ‘envir’
[17:43:34.024]   - Field: ‘packages’
[17:43:34.024]   - Field: ‘gc’
[17:43:34.024]   - Field: ‘conditions’
[17:43:34.024]   - Field: ‘expr’
[17:43:34.024]   - Field: ‘uuid’
[17:43:34.024]   - Field: ‘seed’
[17:43:34.024]   - Field: ‘version’
[17:43:34.024]   - Field: ‘result’
[17:43:34.027]   - Field: ‘asynchronous’
[17:43:34.027]   - Field: ‘calls’
[17:43:34.027]   - Field: ‘globals’
[17:43:34.027]   - Field: ‘stdout’
[17:43:34.027]   - Field: ‘earlySignal’
[17:43:34.027]   - Field: ‘lazy’
[17:43:34.027]   - Field: ‘state’
[17:43:34.027] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:34.027] - Launch lazy future ...
[17:43:34.028] Packages needed by the future expression (n = 0): <none>
[17:43:34.028] Packages needed by future strategies (n = 0): <none>
[17:43:34.028] {
[17:43:34.028]     {
[17:43:34.028]         {
[17:43:34.028]             ...future.startTime <- base::Sys.time()
[17:43:34.028]             {
[17:43:34.028]                 {
[17:43:34.028]                   {
[17:43:34.028]                     base::local({
[17:43:34.028]                       has_future <- base::requireNamespace("future", 
[17:43:34.028]                         quietly = TRUE)
[17:43:34.028]                       if (has_future) {
[17:43:34.028]                         ns <- base::getNamespace("future")
[17:43:34.028]                         version <- ns[[".package"]][["version"]]
[17:43:34.028]                         if (is.null(version)) 
[17:43:34.028]                           version <- utils::packageVersion("future")
[17:43:34.028]                       }
[17:43:34.028]                       else {
[17:43:34.028]                         version <- NULL
[17:43:34.028]                       }
[17:43:34.028]                       if (!has_future || version < "1.8.0") {
[17:43:34.028]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:34.028]                           "", base::R.version$version.string), 
[17:43:34.028]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:34.028]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:34.028]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:34.028]                             "release", "version")], collapse = " "), 
[17:43:34.028]                           hostname = base::Sys.info()[["nodename"]])
[17:43:34.028]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:34.028]                           info)
[17:43:34.028]                         info <- base::paste(info, collapse = "; ")
[17:43:34.028]                         if (!has_future) {
[17:43:34.028]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:34.028]                             info)
[17:43:34.028]                         }
[17:43:34.028]                         else {
[17:43:34.028]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:34.028]                             info, version)
[17:43:34.028]                         }
[17:43:34.028]                         base::stop(msg)
[17:43:34.028]                       }
[17:43:34.028]                     })
[17:43:34.028]                   }
[17:43:34.028]                   options(future.plan = NULL)
[17:43:34.028]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:34.028]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:34.028]                 }
[17:43:34.028]                 ...future.workdir <- getwd()
[17:43:34.028]             }
[17:43:34.028]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:34.028]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:34.028]         }
[17:43:34.028]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:34.028]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:34.028]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:34.028]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:34.028]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:34.028]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:34.028]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:34.028]             base::names(...future.oldOptions))
[17:43:34.028]     }
[17:43:34.028]     if (FALSE) {
[17:43:34.028]     }
[17:43:34.028]     else {
[17:43:34.028]         if (TRUE) {
[17:43:34.028]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:34.028]                 open = "w")
[17:43:34.028]         }
[17:43:34.028]         else {
[17:43:34.028]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:34.028]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:34.028]         }
[17:43:34.028]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:34.028]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:34.028]             base::sink(type = "output", split = FALSE)
[17:43:34.028]             base::close(...future.stdout)
[17:43:34.028]         }, add = TRUE)
[17:43:34.028]     }
[17:43:34.028]     ...future.frame <- base::sys.nframe()
[17:43:34.028]     ...future.conditions <- base::list()
[17:43:34.028]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:34.028]     if (FALSE) {
[17:43:34.028]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:34.028]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:34.028]     }
[17:43:34.028]     ...future.result <- base::tryCatch({
[17:43:34.028]         base::withCallingHandlers({
[17:43:34.028]             ...future.value <- base::withVisible(base::local(2))
[17:43:34.028]             future::FutureResult(value = ...future.value$value, 
[17:43:34.028]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:34.028]                   ...future.rng), globalenv = if (FALSE) 
[17:43:34.028]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:34.028]                     ...future.globalenv.names))
[17:43:34.028]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:34.028]         }, condition = base::local({
[17:43:34.028]             c <- base::c
[17:43:34.028]             inherits <- base::inherits
[17:43:34.028]             invokeRestart <- base::invokeRestart
[17:43:34.028]             length <- base::length
[17:43:34.028]             list <- base::list
[17:43:34.028]             seq.int <- base::seq.int
[17:43:34.028]             signalCondition <- base::signalCondition
[17:43:34.028]             sys.calls <- base::sys.calls
[17:43:34.028]             `[[` <- base::`[[`
[17:43:34.028]             `+` <- base::`+`
[17:43:34.028]             `<<-` <- base::`<<-`
[17:43:34.028]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:34.028]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:34.028]                   3L)]
[17:43:34.028]             }
[17:43:34.028]             function(cond) {
[17:43:34.028]                 is_error <- inherits(cond, "error")
[17:43:34.028]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:34.028]                   NULL)
[17:43:34.028]                 if (is_error) {
[17:43:34.028]                   sessionInformation <- function() {
[17:43:34.028]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:34.028]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:34.028]                       search = base::search(), system = base::Sys.info())
[17:43:34.028]                   }
[17:43:34.028]                   ...future.conditions[[length(...future.conditions) + 
[17:43:34.028]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:34.028]                     cond$call), session = sessionInformation(), 
[17:43:34.028]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:34.028]                   signalCondition(cond)
[17:43:34.028]                 }
[17:43:34.028]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:34.028]                 "immediateCondition"))) {
[17:43:34.028]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:34.028]                   ...future.conditions[[length(...future.conditions) + 
[17:43:34.028]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:34.028]                   if (TRUE && !signal) {
[17:43:34.028]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:34.028]                     {
[17:43:34.028]                       inherits <- base::inherits
[17:43:34.028]                       invokeRestart <- base::invokeRestart
[17:43:34.028]                       is.null <- base::is.null
[17:43:34.028]                       muffled <- FALSE
[17:43:34.028]                       if (inherits(cond, "message")) {
[17:43:34.028]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:34.028]                         if (muffled) 
[17:43:34.028]                           invokeRestart("muffleMessage")
[17:43:34.028]                       }
[17:43:34.028]                       else if (inherits(cond, "warning")) {
[17:43:34.028]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:34.028]                         if (muffled) 
[17:43:34.028]                           invokeRestart("muffleWarning")
[17:43:34.028]                       }
[17:43:34.028]                       else if (inherits(cond, "condition")) {
[17:43:34.028]                         if (!is.null(pattern)) {
[17:43:34.028]                           computeRestarts <- base::computeRestarts
[17:43:34.028]                           grepl <- base::grepl
[17:43:34.028]                           restarts <- computeRestarts(cond)
[17:43:34.028]                           for (restart in restarts) {
[17:43:34.028]                             name <- restart$name
[17:43:34.028]                             if (is.null(name)) 
[17:43:34.028]                               next
[17:43:34.028]                             if (!grepl(pattern, name)) 
[17:43:34.028]                               next
[17:43:34.028]                             invokeRestart(restart)
[17:43:34.028]                             muffled <- TRUE
[17:43:34.028]                             break
[17:43:34.028]                           }
[17:43:34.028]                         }
[17:43:34.028]                       }
[17:43:34.028]                       invisible(muffled)
[17:43:34.028]                     }
[17:43:34.028]                     muffleCondition(cond, pattern = "^muffle")
[17:43:34.028]                   }
[17:43:34.028]                 }
[17:43:34.028]                 else {
[17:43:34.028]                   if (TRUE) {
[17:43:34.028]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:34.028]                     {
[17:43:34.028]                       inherits <- base::inherits
[17:43:34.028]                       invokeRestart <- base::invokeRestart
[17:43:34.028]                       is.null <- base::is.null
[17:43:34.028]                       muffled <- FALSE
[17:43:34.028]                       if (inherits(cond, "message")) {
[17:43:34.028]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:34.028]                         if (muffled) 
[17:43:34.028]                           invokeRestart("muffleMessage")
[17:43:34.028]                       }
[17:43:34.028]                       else if (inherits(cond, "warning")) {
[17:43:34.028]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:34.028]                         if (muffled) 
[17:43:34.028]                           invokeRestart("muffleWarning")
[17:43:34.028]                       }
[17:43:34.028]                       else if (inherits(cond, "condition")) {
[17:43:34.028]                         if (!is.null(pattern)) {
[17:43:34.028]                           computeRestarts <- base::computeRestarts
[17:43:34.028]                           grepl <- base::grepl
[17:43:34.028]                           restarts <- computeRestarts(cond)
[17:43:34.028]                           for (restart in restarts) {
[17:43:34.028]                             name <- restart$name
[17:43:34.028]                             if (is.null(name)) 
[17:43:34.028]                               next
[17:43:34.028]                             if (!grepl(pattern, name)) 
[17:43:34.028]                               next
[17:43:34.028]                             invokeRestart(restart)
[17:43:34.028]                             muffled <- TRUE
[17:43:34.028]                             break
[17:43:34.028]                           }
[17:43:34.028]                         }
[17:43:34.028]                       }
[17:43:34.028]                       invisible(muffled)
[17:43:34.028]                     }
[17:43:34.028]                     muffleCondition(cond, pattern = "^muffle")
[17:43:34.028]                   }
[17:43:34.028]                 }
[17:43:34.028]             }
[17:43:34.028]         }))
[17:43:34.028]     }, error = function(ex) {
[17:43:34.028]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:34.028]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:34.028]                 ...future.rng), started = ...future.startTime, 
[17:43:34.028]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:34.028]             version = "1.8"), class = "FutureResult")
[17:43:34.028]     }, finally = {
[17:43:34.028]         if (!identical(...future.workdir, getwd())) 
[17:43:34.028]             setwd(...future.workdir)
[17:43:34.028]         {
[17:43:34.028]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:34.028]                 ...future.oldOptions$nwarnings <- NULL
[17:43:34.028]             }
[17:43:34.028]             base::options(...future.oldOptions)
[17:43:34.028]             if (.Platform$OS.type == "windows") {
[17:43:34.028]                 old_names <- names(...future.oldEnvVars)
[17:43:34.028]                 envs <- base::Sys.getenv()
[17:43:34.028]                 names <- names(envs)
[17:43:34.028]                 common <- intersect(names, old_names)
[17:43:34.028]                 added <- setdiff(names, old_names)
[17:43:34.028]                 removed <- setdiff(old_names, names)
[17:43:34.028]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:34.028]                   envs[common]]
[17:43:34.028]                 NAMES <- toupper(changed)
[17:43:34.028]                 args <- list()
[17:43:34.028]                 for (kk in seq_along(NAMES)) {
[17:43:34.028]                   name <- changed[[kk]]
[17:43:34.028]                   NAME <- NAMES[[kk]]
[17:43:34.028]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.028]                     next
[17:43:34.028]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:34.028]                 }
[17:43:34.028]                 NAMES <- toupper(added)
[17:43:34.028]                 for (kk in seq_along(NAMES)) {
[17:43:34.028]                   name <- added[[kk]]
[17:43:34.028]                   NAME <- NAMES[[kk]]
[17:43:34.028]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.028]                     next
[17:43:34.028]                   args[[name]] <- ""
[17:43:34.028]                 }
[17:43:34.028]                 NAMES <- toupper(removed)
[17:43:34.028]                 for (kk in seq_along(NAMES)) {
[17:43:34.028]                   name <- removed[[kk]]
[17:43:34.028]                   NAME <- NAMES[[kk]]
[17:43:34.028]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.028]                     next
[17:43:34.028]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:34.028]                 }
[17:43:34.028]                 if (length(args) > 0) 
[17:43:34.028]                   base::do.call(base::Sys.setenv, args = args)
[17:43:34.028]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:34.028]             }
[17:43:34.028]             else {
[17:43:34.028]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:34.028]             }
[17:43:34.028]             {
[17:43:34.028]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:34.028]                   0L) {
[17:43:34.028]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:34.028]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:34.028]                   base::options(opts)
[17:43:34.028]                 }
[17:43:34.028]                 {
[17:43:34.028]                   {
[17:43:34.028]                     NULL
[17:43:34.028]                     RNGkind("Mersenne-Twister")
[17:43:34.028]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:34.028]                       inherits = FALSE)
[17:43:34.028]                   }
[17:43:34.028]                   options(future.plan = NULL)
[17:43:34.028]                   if (is.na(NA_character_)) 
[17:43:34.028]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:34.028]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:34.028]                   future::plan(list(function (..., envir = parent.frame()) 
[17:43:34.028]                   {
[17:43:34.028]                     future <- SequentialFuture(..., envir = envir)
[17:43:34.028]                     if (!future$lazy) 
[17:43:34.028]                       future <- run(future)
[17:43:34.028]                     invisible(future)
[17:43:34.028]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:34.028]                 }
[17:43:34.028]             }
[17:43:34.028]         }
[17:43:34.028]     })
[17:43:34.028]     if (TRUE) {
[17:43:34.028]         base::sink(type = "output", split = FALSE)
[17:43:34.028]         if (TRUE) {
[17:43:34.028]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:34.028]         }
[17:43:34.028]         else {
[17:43:34.028]             ...future.result["stdout"] <- base::list(NULL)
[17:43:34.028]         }
[17:43:34.028]         base::close(...future.stdout)
[17:43:34.028]         ...future.stdout <- NULL
[17:43:34.028]     }
[17:43:34.028]     ...future.result$conditions <- ...future.conditions
[17:43:34.028]     ...future.result$finished <- base::Sys.time()
[17:43:34.028]     ...future.result
[17:43:34.028] }
[17:43:34.030] plan(): Setting new future strategy stack:
[17:43:34.030] List of future strategies:
[17:43:34.030] 1. sequential:
[17:43:34.030]    - args: function (..., envir = parent.frame())
[17:43:34.030]    - tweaked: FALSE
[17:43:34.030]    - call: NULL
[17:43:34.030] plan(): nbrOfWorkers() = 1
[17:43:34.031] plan(): Setting new future strategy stack:
[17:43:34.031] List of future strategies:
[17:43:34.031] 1. sequential:
[17:43:34.031]    - args: function (..., envir = parent.frame())
[17:43:34.031]    - tweaked: FALSE
[17:43:34.031]    - call: plan(strategy)
[17:43:34.032] plan(): nbrOfWorkers() = 1
[17:43:34.032] SequentialFuture started (and completed)
[17:43:34.032] - Launch lazy future ... done
[17:43:34.032] run() for ‘SequentialFuture’ ... done
[17:43:34.033] resolve() on list environment ...
[17:43:34.033]  recursive: 0
[17:43:34.033]  length: 3
[17:43:34.034]  elements: ‘a’, ‘b’, ‘c’
[17:43:34.034] resolved() for ‘SequentialFuture’ ...
[17:43:34.034] - state: ‘finished’
[17:43:34.034] - run: TRUE
[17:43:34.034] - result: ‘FutureResult’
[17:43:34.035] resolved() for ‘SequentialFuture’ ... done
[17:43:34.035] Future #1
[17:43:34.035]  length: 2 (resolved future 1)
[17:43:34.035] resolved() for ‘SequentialFuture’ ...
[17:43:34.035] - state: ‘finished’
[17:43:34.035] - run: TRUE
[17:43:34.035] - result: ‘FutureResult’
[17:43:34.036] resolved() for ‘SequentialFuture’ ... done
[17:43:34.036] Future #2
[17:43:34.036]  length: 1 (resolved future 2)
[17:43:34.036]  length: 0 (resolved future 3)
[17:43:34.036] resolve() on list environment ... DONE
[17:43:34.037] getGlobalsAndPackages() ...
[17:43:34.037] Searching for globals...
[17:43:34.038] - globals found: [1] ‘{’
[17:43:34.038] Searching for globals ... DONE
[17:43:34.038] Resolving globals: FALSE
[17:43:34.039] 
[17:43:34.039] 
[17:43:34.039] getGlobalsAndPackages() ... DONE
[17:43:34.039] run() for ‘Future’ ...
[17:43:34.039] - state: ‘created’
[17:43:34.039] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:34.040] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:34.040] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:34.040]   - Field: ‘label’
[17:43:34.040]   - Field: ‘local’
[17:43:34.040]   - Field: ‘owner’
[17:43:34.040]   - Field: ‘envir’
[17:43:34.040]   - Field: ‘packages’
[17:43:34.040]   - Field: ‘gc’
[17:43:34.040]   - Field: ‘conditions’
[17:43:34.041]   - Field: ‘expr’
[17:43:34.041]   - Field: ‘uuid’
[17:43:34.041]   - Field: ‘seed’
[17:43:34.041]   - Field: ‘version’
[17:43:34.041]   - Field: ‘result’
[17:43:34.041]   - Field: ‘asynchronous’
[17:43:34.041]   - Field: ‘calls’
[17:43:34.041]   - Field: ‘globals’
[17:43:34.041]   - Field: ‘stdout’
[17:43:34.041]   - Field: ‘earlySignal’
[17:43:34.041]   - Field: ‘lazy’
[17:43:34.042]   - Field: ‘state’
[17:43:34.042] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:34.042] - Launch lazy future ...
[17:43:34.042] Packages needed by the future expression (n = 0): <none>
[17:43:34.042] Packages needed by future strategies (n = 0): <none>
[17:43:34.043] {
[17:43:34.043]     {
[17:43:34.043]         {
[17:43:34.043]             ...future.startTime <- base::Sys.time()
[17:43:34.043]             {
[17:43:34.043]                 {
[17:43:34.043]                   {
[17:43:34.043]                     base::local({
[17:43:34.043]                       has_future <- base::requireNamespace("future", 
[17:43:34.043]                         quietly = TRUE)
[17:43:34.043]                       if (has_future) {
[17:43:34.043]                         ns <- base::getNamespace("future")
[17:43:34.043]                         version <- ns[[".package"]][["version"]]
[17:43:34.043]                         if (is.null(version)) 
[17:43:34.043]                           version <- utils::packageVersion("future")
[17:43:34.043]                       }
[17:43:34.043]                       else {
[17:43:34.043]                         version <- NULL
[17:43:34.043]                       }
[17:43:34.043]                       if (!has_future || version < "1.8.0") {
[17:43:34.043]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:34.043]                           "", base::R.version$version.string), 
[17:43:34.043]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:34.043]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:34.043]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:34.043]                             "release", "version")], collapse = " "), 
[17:43:34.043]                           hostname = base::Sys.info()[["nodename"]])
[17:43:34.043]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:34.043]                           info)
[17:43:34.043]                         info <- base::paste(info, collapse = "; ")
[17:43:34.043]                         if (!has_future) {
[17:43:34.043]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:34.043]                             info)
[17:43:34.043]                         }
[17:43:34.043]                         else {
[17:43:34.043]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:34.043]                             info, version)
[17:43:34.043]                         }
[17:43:34.043]                         base::stop(msg)
[17:43:34.043]                       }
[17:43:34.043]                     })
[17:43:34.043]                   }
[17:43:34.043]                   options(future.plan = NULL)
[17:43:34.043]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:34.043]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:34.043]                 }
[17:43:34.043]                 ...future.workdir <- getwd()
[17:43:34.043]             }
[17:43:34.043]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:34.043]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:34.043]         }
[17:43:34.043]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:34.043]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:34.043]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:34.043]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:34.043]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:34.043]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:34.043]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:34.043]             base::names(...future.oldOptions))
[17:43:34.043]     }
[17:43:34.043]     if (FALSE) {
[17:43:34.043]     }
[17:43:34.043]     else {
[17:43:34.043]         if (TRUE) {
[17:43:34.043]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:34.043]                 open = "w")
[17:43:34.043]         }
[17:43:34.043]         else {
[17:43:34.043]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:34.043]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:34.043]         }
[17:43:34.043]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:34.043]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:34.043]             base::sink(type = "output", split = FALSE)
[17:43:34.043]             base::close(...future.stdout)
[17:43:34.043]         }, add = TRUE)
[17:43:34.043]     }
[17:43:34.043]     ...future.frame <- base::sys.nframe()
[17:43:34.043]     ...future.conditions <- base::list()
[17:43:34.043]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:34.043]     if (FALSE) {
[17:43:34.043]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:34.043]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:34.043]     }
[17:43:34.043]     ...future.result <- base::tryCatch({
[17:43:34.043]         base::withCallingHandlers({
[17:43:34.043]             ...future.value <- base::withVisible(base::local({
[17:43:34.043]                 1
[17:43:34.043]             }))
[17:43:34.043]             future::FutureResult(value = ...future.value$value, 
[17:43:34.043]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:34.043]                   ...future.rng), globalenv = if (FALSE) 
[17:43:34.043]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:34.043]                     ...future.globalenv.names))
[17:43:34.043]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:34.043]         }, condition = base::local({
[17:43:34.043]             c <- base::c
[17:43:34.043]             inherits <- base::inherits
[17:43:34.043]             invokeRestart <- base::invokeRestart
[17:43:34.043]             length <- base::length
[17:43:34.043]             list <- base::list
[17:43:34.043]             seq.int <- base::seq.int
[17:43:34.043]             signalCondition <- base::signalCondition
[17:43:34.043]             sys.calls <- base::sys.calls
[17:43:34.043]             `[[` <- base::`[[`
[17:43:34.043]             `+` <- base::`+`
[17:43:34.043]             `<<-` <- base::`<<-`
[17:43:34.043]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:34.043]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:34.043]                   3L)]
[17:43:34.043]             }
[17:43:34.043]             function(cond) {
[17:43:34.043]                 is_error <- inherits(cond, "error")
[17:43:34.043]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:34.043]                   NULL)
[17:43:34.043]                 if (is_error) {
[17:43:34.043]                   sessionInformation <- function() {
[17:43:34.043]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:34.043]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:34.043]                       search = base::search(), system = base::Sys.info())
[17:43:34.043]                   }
[17:43:34.043]                   ...future.conditions[[length(...future.conditions) + 
[17:43:34.043]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:34.043]                     cond$call), session = sessionInformation(), 
[17:43:34.043]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:34.043]                   signalCondition(cond)
[17:43:34.043]                 }
[17:43:34.043]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:34.043]                 "immediateCondition"))) {
[17:43:34.043]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:34.043]                   ...future.conditions[[length(...future.conditions) + 
[17:43:34.043]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:34.043]                   if (TRUE && !signal) {
[17:43:34.043]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:34.043]                     {
[17:43:34.043]                       inherits <- base::inherits
[17:43:34.043]                       invokeRestart <- base::invokeRestart
[17:43:34.043]                       is.null <- base::is.null
[17:43:34.043]                       muffled <- FALSE
[17:43:34.043]                       if (inherits(cond, "message")) {
[17:43:34.043]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:34.043]                         if (muffled) 
[17:43:34.043]                           invokeRestart("muffleMessage")
[17:43:34.043]                       }
[17:43:34.043]                       else if (inherits(cond, "warning")) {
[17:43:34.043]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:34.043]                         if (muffled) 
[17:43:34.043]                           invokeRestart("muffleWarning")
[17:43:34.043]                       }
[17:43:34.043]                       else if (inherits(cond, "condition")) {
[17:43:34.043]                         if (!is.null(pattern)) {
[17:43:34.043]                           computeRestarts <- base::computeRestarts
[17:43:34.043]                           grepl <- base::grepl
[17:43:34.043]                           restarts <- computeRestarts(cond)
[17:43:34.043]                           for (restart in restarts) {
[17:43:34.043]                             name <- restart$name
[17:43:34.043]                             if (is.null(name)) 
[17:43:34.043]                               next
[17:43:34.043]                             if (!grepl(pattern, name)) 
[17:43:34.043]                               next
[17:43:34.043]                             invokeRestart(restart)
[17:43:34.043]                             muffled <- TRUE
[17:43:34.043]                             break
[17:43:34.043]                           }
[17:43:34.043]                         }
[17:43:34.043]                       }
[17:43:34.043]                       invisible(muffled)
[17:43:34.043]                     }
[17:43:34.043]                     muffleCondition(cond, pattern = "^muffle")
[17:43:34.043]                   }
[17:43:34.043]                 }
[17:43:34.043]                 else {
[17:43:34.043]                   if (TRUE) {
[17:43:34.043]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:34.043]                     {
[17:43:34.043]                       inherits <- base::inherits
[17:43:34.043]                       invokeRestart <- base::invokeRestart
[17:43:34.043]                       is.null <- base::is.null
[17:43:34.043]                       muffled <- FALSE
[17:43:34.043]                       if (inherits(cond, "message")) {
[17:43:34.043]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:34.043]                         if (muffled) 
[17:43:34.043]                           invokeRestart("muffleMessage")
[17:43:34.043]                       }
[17:43:34.043]                       else if (inherits(cond, "warning")) {
[17:43:34.043]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:34.043]                         if (muffled) 
[17:43:34.043]                           invokeRestart("muffleWarning")
[17:43:34.043]                       }
[17:43:34.043]                       else if (inherits(cond, "condition")) {
[17:43:34.043]                         if (!is.null(pattern)) {
[17:43:34.043]                           computeRestarts <- base::computeRestarts
[17:43:34.043]                           grepl <- base::grepl
[17:43:34.043]                           restarts <- computeRestarts(cond)
[17:43:34.043]                           for (restart in restarts) {
[17:43:34.043]                             name <- restart$name
[17:43:34.043]                             if (is.null(name)) 
[17:43:34.043]                               next
[17:43:34.043]                             if (!grepl(pattern, name)) 
[17:43:34.043]                               next
[17:43:34.043]                             invokeRestart(restart)
[17:43:34.043]                             muffled <- TRUE
[17:43:34.043]                             break
[17:43:34.043]                           }
[17:43:34.043]                         }
[17:43:34.043]                       }
[17:43:34.043]                       invisible(muffled)
[17:43:34.043]                     }
[17:43:34.043]                     muffleCondition(cond, pattern = "^muffle")
[17:43:34.043]                   }
[17:43:34.043]                 }
[17:43:34.043]             }
[17:43:34.043]         }))
[17:43:34.043]     }, error = function(ex) {
[17:43:34.043]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:34.043]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:34.043]                 ...future.rng), started = ...future.startTime, 
[17:43:34.043]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:34.043]             version = "1.8"), class = "FutureResult")
[17:43:34.043]     }, finally = {
[17:43:34.043]         if (!identical(...future.workdir, getwd())) 
[17:43:34.043]             setwd(...future.workdir)
[17:43:34.043]         {
[17:43:34.043]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:34.043]                 ...future.oldOptions$nwarnings <- NULL
[17:43:34.043]             }
[17:43:34.043]             base::options(...future.oldOptions)
[17:43:34.043]             if (.Platform$OS.type == "windows") {
[17:43:34.043]                 old_names <- names(...future.oldEnvVars)
[17:43:34.043]                 envs <- base::Sys.getenv()
[17:43:34.043]                 names <- names(envs)
[17:43:34.043]                 common <- intersect(names, old_names)
[17:43:34.043]                 added <- setdiff(names, old_names)
[17:43:34.043]                 removed <- setdiff(old_names, names)
[17:43:34.043]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:34.043]                   envs[common]]
[17:43:34.043]                 NAMES <- toupper(changed)
[17:43:34.043]                 args <- list()
[17:43:34.043]                 for (kk in seq_along(NAMES)) {
[17:43:34.043]                   name <- changed[[kk]]
[17:43:34.043]                   NAME <- NAMES[[kk]]
[17:43:34.043]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.043]                     next
[17:43:34.043]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:34.043]                 }
[17:43:34.043]                 NAMES <- toupper(added)
[17:43:34.043]                 for (kk in seq_along(NAMES)) {
[17:43:34.043]                   name <- added[[kk]]
[17:43:34.043]                   NAME <- NAMES[[kk]]
[17:43:34.043]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.043]                     next
[17:43:34.043]                   args[[name]] <- ""
[17:43:34.043]                 }
[17:43:34.043]                 NAMES <- toupper(removed)
[17:43:34.043]                 for (kk in seq_along(NAMES)) {
[17:43:34.043]                   name <- removed[[kk]]
[17:43:34.043]                   NAME <- NAMES[[kk]]
[17:43:34.043]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.043]                     next
[17:43:34.043]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:34.043]                 }
[17:43:34.043]                 if (length(args) > 0) 
[17:43:34.043]                   base::do.call(base::Sys.setenv, args = args)
[17:43:34.043]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:34.043]             }
[17:43:34.043]             else {
[17:43:34.043]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:34.043]             }
[17:43:34.043]             {
[17:43:34.043]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:34.043]                   0L) {
[17:43:34.043]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:34.043]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:34.043]                   base::options(opts)
[17:43:34.043]                 }
[17:43:34.043]                 {
[17:43:34.043]                   {
[17:43:34.043]                     NULL
[17:43:34.043]                     RNGkind("Mersenne-Twister")
[17:43:34.043]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:34.043]                       inherits = FALSE)
[17:43:34.043]                   }
[17:43:34.043]                   options(future.plan = NULL)
[17:43:34.043]                   if (is.na(NA_character_)) 
[17:43:34.043]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:34.043]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:34.043]                   future::plan(list(function (..., envir = parent.frame()) 
[17:43:34.043]                   {
[17:43:34.043]                     future <- SequentialFuture(..., envir = envir)
[17:43:34.043]                     if (!future$lazy) 
[17:43:34.043]                       future <- run(future)
[17:43:34.043]                     invisible(future)
[17:43:34.043]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:34.043]                 }
[17:43:34.043]             }
[17:43:34.043]         }
[17:43:34.043]     })
[17:43:34.043]     if (TRUE) {
[17:43:34.043]         base::sink(type = "output", split = FALSE)
[17:43:34.043]         if (TRUE) {
[17:43:34.043]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:34.043]         }
[17:43:34.043]         else {
[17:43:34.043]             ...future.result["stdout"] <- base::list(NULL)
[17:43:34.043]         }
[17:43:34.043]         base::close(...future.stdout)
[17:43:34.043]         ...future.stdout <- NULL
[17:43:34.043]     }
[17:43:34.043]     ...future.result$conditions <- ...future.conditions
[17:43:34.043]     ...future.result$finished <- base::Sys.time()
[17:43:34.043]     ...future.result
[17:43:34.043] }
[17:43:34.044] plan(): Setting new future strategy stack:
[17:43:34.045] List of future strategies:
[17:43:34.045] 1. sequential:
[17:43:34.045]    - args: function (..., envir = parent.frame())
[17:43:34.045]    - tweaked: FALSE
[17:43:34.045]    - call: NULL
[17:43:34.045] plan(): nbrOfWorkers() = 1
[17:43:34.046] plan(): Setting new future strategy stack:
[17:43:34.046] List of future strategies:
[17:43:34.046] 1. sequential:
[17:43:34.046]    - args: function (..., envir = parent.frame())
[17:43:34.046]    - tweaked: FALSE
[17:43:34.046]    - call: plan(strategy)
[17:43:34.046] plan(): nbrOfWorkers() = 1
[17:43:34.046] SequentialFuture started (and completed)
[17:43:34.046] - Launch lazy future ... done
[17:43:34.047] run() for ‘SequentialFuture’ ... done
[17:43:34.047] getGlobalsAndPackages() ...
[17:43:34.047] Searching for globals...
[17:43:34.048] - globals found: [1] ‘{’
[17:43:34.048] Searching for globals ... DONE
[17:43:34.048] Resolving globals: FALSE
[17:43:34.048] 
[17:43:34.048] 
[17:43:34.048] getGlobalsAndPackages() ... DONE
[17:43:34.049] run() for ‘Future’ ...
[17:43:34.049] - state: ‘created’
[17:43:34.049] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:34.049] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:34.049] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:34.049]   - Field: ‘label’
[17:43:34.049]   - Field: ‘local’
[17:43:34.049]   - Field: ‘owner’
[17:43:34.050]   - Field: ‘envir’
[17:43:34.050]   - Field: ‘packages’
[17:43:34.050]   - Field: ‘gc’
[17:43:34.050]   - Field: ‘conditions’
[17:43:34.050]   - Field: ‘expr’
[17:43:34.050]   - Field: ‘uuid’
[17:43:34.050]   - Field: ‘seed’
[17:43:34.050]   - Field: ‘version’
[17:43:34.050]   - Field: ‘result’
[17:43:34.050]   - Field: ‘asynchronous’
[17:43:34.050]   - Field: ‘calls’
[17:43:34.051]   - Field: ‘globals’
[17:43:34.051]   - Field: ‘stdout’
[17:43:34.051]   - Field: ‘earlySignal’
[17:43:34.051]   - Field: ‘lazy’
[17:43:34.051]   - Field: ‘state’
[17:43:34.051] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:34.051] - Launch lazy future ...
[17:43:34.051] Packages needed by the future expression (n = 0): <none>
[17:43:34.051] Packages needed by future strategies (n = 0): <none>
[17:43:34.052] {
[17:43:34.052]     {
[17:43:34.052]         {
[17:43:34.052]             ...future.startTime <- base::Sys.time()
[17:43:34.052]             {
[17:43:34.052]                 {
[17:43:34.052]                   {
[17:43:34.052]                     base::local({
[17:43:34.052]                       has_future <- base::requireNamespace("future", 
[17:43:34.052]                         quietly = TRUE)
[17:43:34.052]                       if (has_future) {
[17:43:34.052]                         ns <- base::getNamespace("future")
[17:43:34.052]                         version <- ns[[".package"]][["version"]]
[17:43:34.052]                         if (is.null(version)) 
[17:43:34.052]                           version <- utils::packageVersion("future")
[17:43:34.052]                       }
[17:43:34.052]                       else {
[17:43:34.052]                         version <- NULL
[17:43:34.052]                       }
[17:43:34.052]                       if (!has_future || version < "1.8.0") {
[17:43:34.052]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:34.052]                           "", base::R.version$version.string), 
[17:43:34.052]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:34.052]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:34.052]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:34.052]                             "release", "version")], collapse = " "), 
[17:43:34.052]                           hostname = base::Sys.info()[["nodename"]])
[17:43:34.052]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:34.052]                           info)
[17:43:34.052]                         info <- base::paste(info, collapse = "; ")
[17:43:34.052]                         if (!has_future) {
[17:43:34.052]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:34.052]                             info)
[17:43:34.052]                         }
[17:43:34.052]                         else {
[17:43:34.052]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:34.052]                             info, version)
[17:43:34.052]                         }
[17:43:34.052]                         base::stop(msg)
[17:43:34.052]                       }
[17:43:34.052]                     })
[17:43:34.052]                   }
[17:43:34.052]                   options(future.plan = NULL)
[17:43:34.052]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:34.052]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:34.052]                 }
[17:43:34.052]                 ...future.workdir <- getwd()
[17:43:34.052]             }
[17:43:34.052]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:34.052]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:34.052]         }
[17:43:34.052]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:34.052]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:34.052]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:34.052]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:34.052]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:34.052]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:34.052]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:34.052]             base::names(...future.oldOptions))
[17:43:34.052]     }
[17:43:34.052]     if (FALSE) {
[17:43:34.052]     }
[17:43:34.052]     else {
[17:43:34.052]         if (TRUE) {
[17:43:34.052]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:34.052]                 open = "w")
[17:43:34.052]         }
[17:43:34.052]         else {
[17:43:34.052]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:34.052]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:34.052]         }
[17:43:34.052]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:34.052]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:34.052]             base::sink(type = "output", split = FALSE)
[17:43:34.052]             base::close(...future.stdout)
[17:43:34.052]         }, add = TRUE)
[17:43:34.052]     }
[17:43:34.052]     ...future.frame <- base::sys.nframe()
[17:43:34.052]     ...future.conditions <- base::list()
[17:43:34.052]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:34.052]     if (FALSE) {
[17:43:34.052]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:34.052]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:34.052]     }
[17:43:34.052]     ...future.result <- base::tryCatch({
[17:43:34.052]         base::withCallingHandlers({
[17:43:34.052]             ...future.value <- base::withVisible(base::local({
[17:43:34.052]                 2
[17:43:34.052]             }))
[17:43:34.052]             future::FutureResult(value = ...future.value$value, 
[17:43:34.052]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:34.052]                   ...future.rng), globalenv = if (FALSE) 
[17:43:34.052]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:34.052]                     ...future.globalenv.names))
[17:43:34.052]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:34.052]         }, condition = base::local({
[17:43:34.052]             c <- base::c
[17:43:34.052]             inherits <- base::inherits
[17:43:34.052]             invokeRestart <- base::invokeRestart
[17:43:34.052]             length <- base::length
[17:43:34.052]             list <- base::list
[17:43:34.052]             seq.int <- base::seq.int
[17:43:34.052]             signalCondition <- base::signalCondition
[17:43:34.052]             sys.calls <- base::sys.calls
[17:43:34.052]             `[[` <- base::`[[`
[17:43:34.052]             `+` <- base::`+`
[17:43:34.052]             `<<-` <- base::`<<-`
[17:43:34.052]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:34.052]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:34.052]                   3L)]
[17:43:34.052]             }
[17:43:34.052]             function(cond) {
[17:43:34.052]                 is_error <- inherits(cond, "error")
[17:43:34.052]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:34.052]                   NULL)
[17:43:34.052]                 if (is_error) {
[17:43:34.052]                   sessionInformation <- function() {
[17:43:34.052]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:34.052]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:34.052]                       search = base::search(), system = base::Sys.info())
[17:43:34.052]                   }
[17:43:34.052]                   ...future.conditions[[length(...future.conditions) + 
[17:43:34.052]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:34.052]                     cond$call), session = sessionInformation(), 
[17:43:34.052]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:34.052]                   signalCondition(cond)
[17:43:34.052]                 }
[17:43:34.052]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:34.052]                 "immediateCondition"))) {
[17:43:34.052]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:34.052]                   ...future.conditions[[length(...future.conditions) + 
[17:43:34.052]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:34.052]                   if (TRUE && !signal) {
[17:43:34.052]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:34.052]                     {
[17:43:34.052]                       inherits <- base::inherits
[17:43:34.052]                       invokeRestart <- base::invokeRestart
[17:43:34.052]                       is.null <- base::is.null
[17:43:34.052]                       muffled <- FALSE
[17:43:34.052]                       if (inherits(cond, "message")) {
[17:43:34.052]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:34.052]                         if (muffled) 
[17:43:34.052]                           invokeRestart("muffleMessage")
[17:43:34.052]                       }
[17:43:34.052]                       else if (inherits(cond, "warning")) {
[17:43:34.052]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:34.052]                         if (muffled) 
[17:43:34.052]                           invokeRestart("muffleWarning")
[17:43:34.052]                       }
[17:43:34.052]                       else if (inherits(cond, "condition")) {
[17:43:34.052]                         if (!is.null(pattern)) {
[17:43:34.052]                           computeRestarts <- base::computeRestarts
[17:43:34.052]                           grepl <- base::grepl
[17:43:34.052]                           restarts <- computeRestarts(cond)
[17:43:34.052]                           for (restart in restarts) {
[17:43:34.052]                             name <- restart$name
[17:43:34.052]                             if (is.null(name)) 
[17:43:34.052]                               next
[17:43:34.052]                             if (!grepl(pattern, name)) 
[17:43:34.052]                               next
[17:43:34.052]                             invokeRestart(restart)
[17:43:34.052]                             muffled <- TRUE
[17:43:34.052]                             break
[17:43:34.052]                           }
[17:43:34.052]                         }
[17:43:34.052]                       }
[17:43:34.052]                       invisible(muffled)
[17:43:34.052]                     }
[17:43:34.052]                     muffleCondition(cond, pattern = "^muffle")
[17:43:34.052]                   }
[17:43:34.052]                 }
[17:43:34.052]                 else {
[17:43:34.052]                   if (TRUE) {
[17:43:34.052]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:34.052]                     {
[17:43:34.052]                       inherits <- base::inherits
[17:43:34.052]                       invokeRestart <- base::invokeRestart
[17:43:34.052]                       is.null <- base::is.null
[17:43:34.052]                       muffled <- FALSE
[17:43:34.052]                       if (inherits(cond, "message")) {
[17:43:34.052]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:34.052]                         if (muffled) 
[17:43:34.052]                           invokeRestart("muffleMessage")
[17:43:34.052]                       }
[17:43:34.052]                       else if (inherits(cond, "warning")) {
[17:43:34.052]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:34.052]                         if (muffled) 
[17:43:34.052]                           invokeRestart("muffleWarning")
[17:43:34.052]                       }
[17:43:34.052]                       else if (inherits(cond, "condition")) {
[17:43:34.052]                         if (!is.null(pattern)) {
[17:43:34.052]                           computeRestarts <- base::computeRestarts
[17:43:34.052]                           grepl <- base::grepl
[17:43:34.052]                           restarts <- computeRestarts(cond)
[17:43:34.052]                           for (restart in restarts) {
[17:43:34.052]                             name <- restart$name
[17:43:34.052]                             if (is.null(name)) 
[17:43:34.052]                               next
[17:43:34.052]                             if (!grepl(pattern, name)) 
[17:43:34.052]                               next
[17:43:34.052]                             invokeRestart(restart)
[17:43:34.052]                             muffled <- TRUE
[17:43:34.052]                             break
[17:43:34.052]                           }
[17:43:34.052]                         }
[17:43:34.052]                       }
[17:43:34.052]                       invisible(muffled)
[17:43:34.052]                     }
[17:43:34.052]                     muffleCondition(cond, pattern = "^muffle")
[17:43:34.052]                   }
[17:43:34.052]                 }
[17:43:34.052]             }
[17:43:34.052]         }))
[17:43:34.052]     }, error = function(ex) {
[17:43:34.052]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:34.052]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:34.052]                 ...future.rng), started = ...future.startTime, 
[17:43:34.052]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:34.052]             version = "1.8"), class = "FutureResult")
[17:43:34.052]     }, finally = {
[17:43:34.052]         if (!identical(...future.workdir, getwd())) 
[17:43:34.052]             setwd(...future.workdir)
[17:43:34.052]         {
[17:43:34.052]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:34.052]                 ...future.oldOptions$nwarnings <- NULL
[17:43:34.052]             }
[17:43:34.052]             base::options(...future.oldOptions)
[17:43:34.052]             if (.Platform$OS.type == "windows") {
[17:43:34.052]                 old_names <- names(...future.oldEnvVars)
[17:43:34.052]                 envs <- base::Sys.getenv()
[17:43:34.052]                 names <- names(envs)
[17:43:34.052]                 common <- intersect(names, old_names)
[17:43:34.052]                 added <- setdiff(names, old_names)
[17:43:34.052]                 removed <- setdiff(old_names, names)
[17:43:34.052]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:34.052]                   envs[common]]
[17:43:34.052]                 NAMES <- toupper(changed)
[17:43:34.052]                 args <- list()
[17:43:34.052]                 for (kk in seq_along(NAMES)) {
[17:43:34.052]                   name <- changed[[kk]]
[17:43:34.052]                   NAME <- NAMES[[kk]]
[17:43:34.052]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.052]                     next
[17:43:34.052]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:34.052]                 }
[17:43:34.052]                 NAMES <- toupper(added)
[17:43:34.052]                 for (kk in seq_along(NAMES)) {
[17:43:34.052]                   name <- added[[kk]]
[17:43:34.052]                   NAME <- NAMES[[kk]]
[17:43:34.052]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.052]                     next
[17:43:34.052]                   args[[name]] <- ""
[17:43:34.052]                 }
[17:43:34.052]                 NAMES <- toupper(removed)
[17:43:34.052]                 for (kk in seq_along(NAMES)) {
[17:43:34.052]                   name <- removed[[kk]]
[17:43:34.052]                   NAME <- NAMES[[kk]]
[17:43:34.052]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.052]                     next
[17:43:34.052]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:34.052]                 }
[17:43:34.052]                 if (length(args) > 0) 
[17:43:34.052]                   base::do.call(base::Sys.setenv, args = args)
[17:43:34.052]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:34.052]             }
[17:43:34.052]             else {
[17:43:34.052]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:34.052]             }
[17:43:34.052]             {
[17:43:34.052]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:34.052]                   0L) {
[17:43:34.052]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:34.052]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:34.052]                   base::options(opts)
[17:43:34.052]                 }
[17:43:34.052]                 {
[17:43:34.052]                   {
[17:43:34.052]                     NULL
[17:43:34.052]                     RNGkind("Mersenne-Twister")
[17:43:34.052]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:34.052]                       inherits = FALSE)
[17:43:34.052]                   }
[17:43:34.052]                   options(future.plan = NULL)
[17:43:34.052]                   if (is.na(NA_character_)) 
[17:43:34.052]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:34.052]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:34.052]                   future::plan(list(function (..., envir = parent.frame()) 
[17:43:34.052]                   {
[17:43:34.052]                     future <- SequentialFuture(..., envir = envir)
[17:43:34.052]                     if (!future$lazy) 
[17:43:34.052]                       future <- run(future)
[17:43:34.052]                     invisible(future)
[17:43:34.052]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:34.052]                 }
[17:43:34.052]             }
[17:43:34.052]         }
[17:43:34.052]     })
[17:43:34.052]     if (TRUE) {
[17:43:34.052]         base::sink(type = "output", split = FALSE)
[17:43:34.052]         if (TRUE) {
[17:43:34.052]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:34.052]         }
[17:43:34.052]         else {
[17:43:34.052]             ...future.result["stdout"] <- base::list(NULL)
[17:43:34.052]         }
[17:43:34.052]         base::close(...future.stdout)
[17:43:34.052]         ...future.stdout <- NULL
[17:43:34.052]     }
[17:43:34.052]     ...future.result$conditions <- ...future.conditions
[17:43:34.052]     ...future.result$finished <- base::Sys.time()
[17:43:34.052]     ...future.result
[17:43:34.052] }
[17:43:34.054] plan(): Setting new future strategy stack:
[17:43:34.054] List of future strategies:
[17:43:34.054] 1. sequential:
[17:43:34.054]    - args: function (..., envir = parent.frame())
[17:43:34.054]    - tweaked: FALSE
[17:43:34.054]    - call: NULL
[17:43:34.054] plan(): nbrOfWorkers() = 1
[17:43:34.055] plan(): Setting new future strategy stack:
[17:43:34.055] List of future strategies:
[17:43:34.055] 1. sequential:
[17:43:34.055]    - args: function (..., envir = parent.frame())
[17:43:34.055]    - tweaked: FALSE
[17:43:34.055]    - call: plan(strategy)
[17:43:34.055] plan(): nbrOfWorkers() = 1
[17:43:34.056] SequentialFuture started (and completed)
[17:43:34.058] - Launch lazy future ... done
[17:43:34.058] run() for ‘SequentialFuture’ ... done
[17:43:34.059] resolve() on list environment ...
[17:43:34.059]  recursive: 0
[17:43:34.059]  length: 3
[17:43:34.059]  elements: ‘a’, ‘b’, ‘c’
[17:43:34.059] resolved() for ‘SequentialFuture’ ...
[17:43:34.060] - state: ‘finished’
[17:43:34.060] - run: TRUE
[17:43:34.060] - result: ‘FutureResult’
[17:43:34.060] resolved() for ‘SequentialFuture’ ... done
[17:43:34.060] Future #1
[17:43:34.060]  length: 2 (resolved future 1)
[17:43:34.060] resolved() for ‘SequentialFuture’ ...
[17:43:34.060] - state: ‘finished’
[17:43:34.060] - run: TRUE
[17:43:34.060] - result: ‘FutureResult’
[17:43:34.061] resolved() for ‘SequentialFuture’ ... done
[17:43:34.061] Future #2
[17:43:34.061]  length: 1 (resolved future 2)
[17:43:34.061]  length: 0 (resolved future 3)
[17:43:34.061] resolve() on list environment ... DONE
[17:43:34.061] getGlobalsAndPackages() ...
[17:43:34.062] Searching for globals...
[17:43:34.062] - globals found: [1] ‘{’
[17:43:34.062] Searching for globals ... DONE
[17:43:34.062] Resolving globals: FALSE
[17:43:34.063] 
[17:43:34.063] 
[17:43:34.063] getGlobalsAndPackages() ... DONE
[17:43:34.063] run() for ‘Future’ ...
[17:43:34.063] - state: ‘created’
[17:43:34.063] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:34.064] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:34.064] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:34.064]   - Field: ‘label’
[17:43:34.064]   - Field: ‘local’
[17:43:34.064]   - Field: ‘owner’
[17:43:34.064]   - Field: ‘envir’
[17:43:34.064]   - Field: ‘packages’
[17:43:34.064]   - Field: ‘gc’
[17:43:34.064]   - Field: ‘conditions’
[17:43:34.065]   - Field: ‘expr’
[17:43:34.065]   - Field: ‘uuid’
[17:43:34.065]   - Field: ‘seed’
[17:43:34.065]   - Field: ‘version’
[17:43:34.065]   - Field: ‘result’
[17:43:34.065]   - Field: ‘asynchronous’
[17:43:34.065]   - Field: ‘calls’
[17:43:34.065]   - Field: ‘globals’
[17:43:34.065]   - Field: ‘stdout’
[17:43:34.065]   - Field: ‘earlySignal’
[17:43:34.065]   - Field: ‘lazy’
[17:43:34.066]   - Field: ‘state’
[17:43:34.066] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:34.066] - Launch lazy future ...
[17:43:34.066] Packages needed by the future expression (n = 0): <none>
[17:43:34.066] Packages needed by future strategies (n = 0): <none>
[17:43:34.066] {
[17:43:34.066]     {
[17:43:34.066]         {
[17:43:34.066]             ...future.startTime <- base::Sys.time()
[17:43:34.066]             {
[17:43:34.066]                 {
[17:43:34.066]                   {
[17:43:34.066]                     base::local({
[17:43:34.066]                       has_future <- base::requireNamespace("future", 
[17:43:34.066]                         quietly = TRUE)
[17:43:34.066]                       if (has_future) {
[17:43:34.066]                         ns <- base::getNamespace("future")
[17:43:34.066]                         version <- ns[[".package"]][["version"]]
[17:43:34.066]                         if (is.null(version)) 
[17:43:34.066]                           version <- utils::packageVersion("future")
[17:43:34.066]                       }
[17:43:34.066]                       else {
[17:43:34.066]                         version <- NULL
[17:43:34.066]                       }
[17:43:34.066]                       if (!has_future || version < "1.8.0") {
[17:43:34.066]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:34.066]                           "", base::R.version$version.string), 
[17:43:34.066]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:34.066]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:34.066]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:34.066]                             "release", "version")], collapse = " "), 
[17:43:34.066]                           hostname = base::Sys.info()[["nodename"]])
[17:43:34.066]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:34.066]                           info)
[17:43:34.066]                         info <- base::paste(info, collapse = "; ")
[17:43:34.066]                         if (!has_future) {
[17:43:34.066]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:34.066]                             info)
[17:43:34.066]                         }
[17:43:34.066]                         else {
[17:43:34.066]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:34.066]                             info, version)
[17:43:34.066]                         }
[17:43:34.066]                         base::stop(msg)
[17:43:34.066]                       }
[17:43:34.066]                     })
[17:43:34.066]                   }
[17:43:34.066]                   options(future.plan = NULL)
[17:43:34.066]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:34.066]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:34.066]                 }
[17:43:34.066]                 ...future.workdir <- getwd()
[17:43:34.066]             }
[17:43:34.066]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:34.066]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:34.066]         }
[17:43:34.066]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:34.066]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:34.066]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:34.066]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:34.066]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:34.066]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:34.066]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:34.066]             base::names(...future.oldOptions))
[17:43:34.066]     }
[17:43:34.066]     if (FALSE) {
[17:43:34.066]     }
[17:43:34.066]     else {
[17:43:34.066]         if (TRUE) {
[17:43:34.066]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:34.066]                 open = "w")
[17:43:34.066]         }
[17:43:34.066]         else {
[17:43:34.066]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:34.066]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:34.066]         }
[17:43:34.066]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:34.066]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:34.066]             base::sink(type = "output", split = FALSE)
[17:43:34.066]             base::close(...future.stdout)
[17:43:34.066]         }, add = TRUE)
[17:43:34.066]     }
[17:43:34.066]     ...future.frame <- base::sys.nframe()
[17:43:34.066]     ...future.conditions <- base::list()
[17:43:34.066]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:34.066]     if (FALSE) {
[17:43:34.066]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:34.066]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:34.066]     }
[17:43:34.066]     ...future.result <- base::tryCatch({
[17:43:34.066]         base::withCallingHandlers({
[17:43:34.066]             ...future.value <- base::withVisible(base::local({
[17:43:34.066]                 1
[17:43:34.066]             }))
[17:43:34.066]             future::FutureResult(value = ...future.value$value, 
[17:43:34.066]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:34.066]                   ...future.rng), globalenv = if (FALSE) 
[17:43:34.066]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:34.066]                     ...future.globalenv.names))
[17:43:34.066]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:34.066]         }, condition = base::local({
[17:43:34.066]             c <- base::c
[17:43:34.066]             inherits <- base::inherits
[17:43:34.066]             invokeRestart <- base::invokeRestart
[17:43:34.066]             length <- base::length
[17:43:34.066]             list <- base::list
[17:43:34.066]             seq.int <- base::seq.int
[17:43:34.066]             signalCondition <- base::signalCondition
[17:43:34.066]             sys.calls <- base::sys.calls
[17:43:34.066]             `[[` <- base::`[[`
[17:43:34.066]             `+` <- base::`+`
[17:43:34.066]             `<<-` <- base::`<<-`
[17:43:34.066]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:34.066]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:34.066]                   3L)]
[17:43:34.066]             }
[17:43:34.066]             function(cond) {
[17:43:34.066]                 is_error <- inherits(cond, "error")
[17:43:34.066]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:34.066]                   NULL)
[17:43:34.066]                 if (is_error) {
[17:43:34.066]                   sessionInformation <- function() {
[17:43:34.066]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:34.066]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:34.066]                       search = base::search(), system = base::Sys.info())
[17:43:34.066]                   }
[17:43:34.066]                   ...future.conditions[[length(...future.conditions) + 
[17:43:34.066]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:34.066]                     cond$call), session = sessionInformation(), 
[17:43:34.066]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:34.066]                   signalCondition(cond)
[17:43:34.066]                 }
[17:43:34.066]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:34.066]                 "immediateCondition"))) {
[17:43:34.066]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:34.066]                   ...future.conditions[[length(...future.conditions) + 
[17:43:34.066]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:34.066]                   if (TRUE && !signal) {
[17:43:34.066]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:34.066]                     {
[17:43:34.066]                       inherits <- base::inherits
[17:43:34.066]                       invokeRestart <- base::invokeRestart
[17:43:34.066]                       is.null <- base::is.null
[17:43:34.066]                       muffled <- FALSE
[17:43:34.066]                       if (inherits(cond, "message")) {
[17:43:34.066]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:34.066]                         if (muffled) 
[17:43:34.066]                           invokeRestart("muffleMessage")
[17:43:34.066]                       }
[17:43:34.066]                       else if (inherits(cond, "warning")) {
[17:43:34.066]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:34.066]                         if (muffled) 
[17:43:34.066]                           invokeRestart("muffleWarning")
[17:43:34.066]                       }
[17:43:34.066]                       else if (inherits(cond, "condition")) {
[17:43:34.066]                         if (!is.null(pattern)) {
[17:43:34.066]                           computeRestarts <- base::computeRestarts
[17:43:34.066]                           grepl <- base::grepl
[17:43:34.066]                           restarts <- computeRestarts(cond)
[17:43:34.066]                           for (restart in restarts) {
[17:43:34.066]                             name <- restart$name
[17:43:34.066]                             if (is.null(name)) 
[17:43:34.066]                               next
[17:43:34.066]                             if (!grepl(pattern, name)) 
[17:43:34.066]                               next
[17:43:34.066]                             invokeRestart(restart)
[17:43:34.066]                             muffled <- TRUE
[17:43:34.066]                             break
[17:43:34.066]                           }
[17:43:34.066]                         }
[17:43:34.066]                       }
[17:43:34.066]                       invisible(muffled)
[17:43:34.066]                     }
[17:43:34.066]                     muffleCondition(cond, pattern = "^muffle")
[17:43:34.066]                   }
[17:43:34.066]                 }
[17:43:34.066]                 else {
[17:43:34.066]                   if (TRUE) {
[17:43:34.066]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:34.066]                     {
[17:43:34.066]                       inherits <- base::inherits
[17:43:34.066]                       invokeRestart <- base::invokeRestart
[17:43:34.066]                       is.null <- base::is.null
[17:43:34.066]                       muffled <- FALSE
[17:43:34.066]                       if (inherits(cond, "message")) {
[17:43:34.066]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:34.066]                         if (muffled) 
[17:43:34.066]                           invokeRestart("muffleMessage")
[17:43:34.066]                       }
[17:43:34.066]                       else if (inherits(cond, "warning")) {
[17:43:34.066]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:34.066]                         if (muffled) 
[17:43:34.066]                           invokeRestart("muffleWarning")
[17:43:34.066]                       }
[17:43:34.066]                       else if (inherits(cond, "condition")) {
[17:43:34.066]                         if (!is.null(pattern)) {
[17:43:34.066]                           computeRestarts <- base::computeRestarts
[17:43:34.066]                           grepl <- base::grepl
[17:43:34.066]                           restarts <- computeRestarts(cond)
[17:43:34.066]                           for (restart in restarts) {
[17:43:34.066]                             name <- restart$name
[17:43:34.066]                             if (is.null(name)) 
[17:43:34.066]                               next
[17:43:34.066]                             if (!grepl(pattern, name)) 
[17:43:34.066]                               next
[17:43:34.066]                             invokeRestart(restart)
[17:43:34.066]                             muffled <- TRUE
[17:43:34.066]                             break
[17:43:34.066]                           }
[17:43:34.066]                         }
[17:43:34.066]                       }
[17:43:34.066]                       invisible(muffled)
[17:43:34.066]                     }
[17:43:34.066]                     muffleCondition(cond, pattern = "^muffle")
[17:43:34.066]                   }
[17:43:34.066]                 }
[17:43:34.066]             }
[17:43:34.066]         }))
[17:43:34.066]     }, error = function(ex) {
[17:43:34.066]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:34.066]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:34.066]                 ...future.rng), started = ...future.startTime, 
[17:43:34.066]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:34.066]             version = "1.8"), class = "FutureResult")
[17:43:34.066]     }, finally = {
[17:43:34.066]         if (!identical(...future.workdir, getwd())) 
[17:43:34.066]             setwd(...future.workdir)
[17:43:34.066]         {
[17:43:34.066]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:34.066]                 ...future.oldOptions$nwarnings <- NULL
[17:43:34.066]             }
[17:43:34.066]             base::options(...future.oldOptions)
[17:43:34.066]             if (.Platform$OS.type == "windows") {
[17:43:34.066]                 old_names <- names(...future.oldEnvVars)
[17:43:34.066]                 envs <- base::Sys.getenv()
[17:43:34.066]                 names <- names(envs)
[17:43:34.066]                 common <- intersect(names, old_names)
[17:43:34.066]                 added <- setdiff(names, old_names)
[17:43:34.066]                 removed <- setdiff(old_names, names)
[17:43:34.066]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:34.066]                   envs[common]]
[17:43:34.066]                 NAMES <- toupper(changed)
[17:43:34.066]                 args <- list()
[17:43:34.066]                 for (kk in seq_along(NAMES)) {
[17:43:34.066]                   name <- changed[[kk]]
[17:43:34.066]                   NAME <- NAMES[[kk]]
[17:43:34.066]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.066]                     next
[17:43:34.066]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:34.066]                 }
[17:43:34.066]                 NAMES <- toupper(added)
[17:43:34.066]                 for (kk in seq_along(NAMES)) {
[17:43:34.066]                   name <- added[[kk]]
[17:43:34.066]                   NAME <- NAMES[[kk]]
[17:43:34.066]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.066]                     next
[17:43:34.066]                   args[[name]] <- ""
[17:43:34.066]                 }
[17:43:34.066]                 NAMES <- toupper(removed)
[17:43:34.066]                 for (kk in seq_along(NAMES)) {
[17:43:34.066]                   name <- removed[[kk]]
[17:43:34.066]                   NAME <- NAMES[[kk]]
[17:43:34.066]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.066]                     next
[17:43:34.066]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:34.066]                 }
[17:43:34.066]                 if (length(args) > 0) 
[17:43:34.066]                   base::do.call(base::Sys.setenv, args = args)
[17:43:34.066]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:34.066]             }
[17:43:34.066]             else {
[17:43:34.066]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:34.066]             }
[17:43:34.066]             {
[17:43:34.066]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:34.066]                   0L) {
[17:43:34.066]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:34.066]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:34.066]                   base::options(opts)
[17:43:34.066]                 }
[17:43:34.066]                 {
[17:43:34.066]                   {
[17:43:34.066]                     NULL
[17:43:34.066]                     RNGkind("Mersenne-Twister")
[17:43:34.066]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:34.066]                       inherits = FALSE)
[17:43:34.066]                   }
[17:43:34.066]                   options(future.plan = NULL)
[17:43:34.066]                   if (is.na(NA_character_)) 
[17:43:34.066]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:34.066]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:34.066]                   future::plan(list(function (..., envir = parent.frame()) 
[17:43:34.066]                   {
[17:43:34.066]                     future <- SequentialFuture(..., envir = envir)
[17:43:34.066]                     if (!future$lazy) 
[17:43:34.066]                       future <- run(future)
[17:43:34.066]                     invisible(future)
[17:43:34.066]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:34.066]                 }
[17:43:34.066]             }
[17:43:34.066]         }
[17:43:34.066]     })
[17:43:34.066]     if (TRUE) {
[17:43:34.066]         base::sink(type = "output", split = FALSE)
[17:43:34.066]         if (TRUE) {
[17:43:34.066]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:34.066]         }
[17:43:34.066]         else {
[17:43:34.066]             ...future.result["stdout"] <- base::list(NULL)
[17:43:34.066]         }
[17:43:34.066]         base::close(...future.stdout)
[17:43:34.066]         ...future.stdout <- NULL
[17:43:34.066]     }
[17:43:34.066]     ...future.result$conditions <- ...future.conditions
[17:43:34.066]     ...future.result$finished <- base::Sys.time()
[17:43:34.066]     ...future.result
[17:43:34.066] }
[17:43:34.068] plan(): Setting new future strategy stack:
[17:43:34.068] List of future strategies:
[17:43:34.068] 1. sequential:
[17:43:34.068]    - args: function (..., envir = parent.frame())
[17:43:34.068]    - tweaked: FALSE
[17:43:34.068]    - call: NULL
[17:43:34.069] plan(): nbrOfWorkers() = 1
[17:43:34.069] plan(): Setting new future strategy stack:
[17:43:34.069] List of future strategies:
[17:43:34.069] 1. sequential:
[17:43:34.069]    - args: function (..., envir = parent.frame())
[17:43:34.069]    - tweaked: FALSE
[17:43:34.069]    - call: plan(strategy)
[17:43:34.070] plan(): nbrOfWorkers() = 1
[17:43:34.070] SequentialFuture started (and completed)
[17:43:34.070] - Launch lazy future ... done
[17:43:34.070] run() for ‘SequentialFuture’ ... done
[17:43:34.071] getGlobalsAndPackages() ...
[17:43:34.071] Searching for globals...
[17:43:34.072] - globals found: [2] ‘{’, ‘Sys.sleep’
[17:43:34.072] Searching for globals ... DONE
[17:43:34.072] Resolving globals: FALSE
[17:43:34.072] 
[17:43:34.072] 
[17:43:34.072] getGlobalsAndPackages() ... DONE
[17:43:34.072] run() for ‘Future’ ...
[17:43:34.073] - state: ‘created’
[17:43:34.073] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:34.073] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:34.073] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:34.073]   - Field: ‘label’
[17:43:34.073]   - Field: ‘local’
[17:43:34.073]   - Field: ‘owner’
[17:43:34.073]   - Field: ‘envir’
[17:43:34.074]   - Field: ‘packages’
[17:43:34.074]   - Field: ‘gc’
[17:43:34.074]   - Field: ‘conditions’
[17:43:34.074]   - Field: ‘expr’
[17:43:34.074]   - Field: ‘uuid’
[17:43:34.074]   - Field: ‘seed’
[17:43:34.074]   - Field: ‘version’
[17:43:34.074]   - Field: ‘result’
[17:43:34.074]   - Field: ‘asynchronous’
[17:43:34.074]   - Field: ‘calls’
[17:43:34.074]   - Field: ‘globals’
[17:43:34.075]   - Field: ‘stdout’
[17:43:34.075]   - Field: ‘earlySignal’
[17:43:34.075]   - Field: ‘lazy’
[17:43:34.075]   - Field: ‘state’
[17:43:34.075] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:34.075] - Launch lazy future ...
[17:43:34.075] Packages needed by the future expression (n = 0): <none>
[17:43:34.075] Packages needed by future strategies (n = 0): <none>
[17:43:34.076] {
[17:43:34.076]     {
[17:43:34.076]         {
[17:43:34.076]             ...future.startTime <- base::Sys.time()
[17:43:34.076]             {
[17:43:34.076]                 {
[17:43:34.076]                   {
[17:43:34.076]                     base::local({
[17:43:34.076]                       has_future <- base::requireNamespace("future", 
[17:43:34.076]                         quietly = TRUE)
[17:43:34.076]                       if (has_future) {
[17:43:34.076]                         ns <- base::getNamespace("future")
[17:43:34.076]                         version <- ns[[".package"]][["version"]]
[17:43:34.076]                         if (is.null(version)) 
[17:43:34.076]                           version <- utils::packageVersion("future")
[17:43:34.076]                       }
[17:43:34.076]                       else {
[17:43:34.076]                         version <- NULL
[17:43:34.076]                       }
[17:43:34.076]                       if (!has_future || version < "1.8.0") {
[17:43:34.076]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:34.076]                           "", base::R.version$version.string), 
[17:43:34.076]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:34.076]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:34.076]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:34.076]                             "release", "version")], collapse = " "), 
[17:43:34.076]                           hostname = base::Sys.info()[["nodename"]])
[17:43:34.076]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:34.076]                           info)
[17:43:34.076]                         info <- base::paste(info, collapse = "; ")
[17:43:34.076]                         if (!has_future) {
[17:43:34.076]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:34.076]                             info)
[17:43:34.076]                         }
[17:43:34.076]                         else {
[17:43:34.076]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:34.076]                             info, version)
[17:43:34.076]                         }
[17:43:34.076]                         base::stop(msg)
[17:43:34.076]                       }
[17:43:34.076]                     })
[17:43:34.076]                   }
[17:43:34.076]                   options(future.plan = NULL)
[17:43:34.076]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:34.076]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:34.076]                 }
[17:43:34.076]                 ...future.workdir <- getwd()
[17:43:34.076]             }
[17:43:34.076]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:34.076]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:34.076]         }
[17:43:34.076]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:34.076]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:34.076]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:34.076]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:34.076]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:34.076]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:34.076]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:34.076]             base::names(...future.oldOptions))
[17:43:34.076]     }
[17:43:34.076]     if (FALSE) {
[17:43:34.076]     }
[17:43:34.076]     else {
[17:43:34.076]         if (TRUE) {
[17:43:34.076]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:34.076]                 open = "w")
[17:43:34.076]         }
[17:43:34.076]         else {
[17:43:34.076]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:34.076]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:34.076]         }
[17:43:34.076]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:34.076]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:34.076]             base::sink(type = "output", split = FALSE)
[17:43:34.076]             base::close(...future.stdout)
[17:43:34.076]         }, add = TRUE)
[17:43:34.076]     }
[17:43:34.076]     ...future.frame <- base::sys.nframe()
[17:43:34.076]     ...future.conditions <- base::list()
[17:43:34.076]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:34.076]     if (FALSE) {
[17:43:34.076]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:34.076]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:34.076]     }
[17:43:34.076]     ...future.result <- base::tryCatch({
[17:43:34.076]         base::withCallingHandlers({
[17:43:34.076]             ...future.value <- base::withVisible(base::local({
[17:43:34.076]                 Sys.sleep(0.5)
[17:43:34.076]                 2
[17:43:34.076]             }))
[17:43:34.076]             future::FutureResult(value = ...future.value$value, 
[17:43:34.076]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:34.076]                   ...future.rng), globalenv = if (FALSE) 
[17:43:34.076]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:34.076]                     ...future.globalenv.names))
[17:43:34.076]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:34.076]         }, condition = base::local({
[17:43:34.076]             c <- base::c
[17:43:34.076]             inherits <- base::inherits
[17:43:34.076]             invokeRestart <- base::invokeRestart
[17:43:34.076]             length <- base::length
[17:43:34.076]             list <- base::list
[17:43:34.076]             seq.int <- base::seq.int
[17:43:34.076]             signalCondition <- base::signalCondition
[17:43:34.076]             sys.calls <- base::sys.calls
[17:43:34.076]             `[[` <- base::`[[`
[17:43:34.076]             `+` <- base::`+`
[17:43:34.076]             `<<-` <- base::`<<-`
[17:43:34.076]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:34.076]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:34.076]                   3L)]
[17:43:34.076]             }
[17:43:34.076]             function(cond) {
[17:43:34.076]                 is_error <- inherits(cond, "error")
[17:43:34.076]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:34.076]                   NULL)
[17:43:34.076]                 if (is_error) {
[17:43:34.076]                   sessionInformation <- function() {
[17:43:34.076]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:34.076]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:34.076]                       search = base::search(), system = base::Sys.info())
[17:43:34.076]                   }
[17:43:34.076]                   ...future.conditions[[length(...future.conditions) + 
[17:43:34.076]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:34.076]                     cond$call), session = sessionInformation(), 
[17:43:34.076]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:34.076]                   signalCondition(cond)
[17:43:34.076]                 }
[17:43:34.076]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:34.076]                 "immediateCondition"))) {
[17:43:34.076]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:34.076]                   ...future.conditions[[length(...future.conditions) + 
[17:43:34.076]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:34.076]                   if (TRUE && !signal) {
[17:43:34.076]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:34.076]                     {
[17:43:34.076]                       inherits <- base::inherits
[17:43:34.076]                       invokeRestart <- base::invokeRestart
[17:43:34.076]                       is.null <- base::is.null
[17:43:34.076]                       muffled <- FALSE
[17:43:34.076]                       if (inherits(cond, "message")) {
[17:43:34.076]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:34.076]                         if (muffled) 
[17:43:34.076]                           invokeRestart("muffleMessage")
[17:43:34.076]                       }
[17:43:34.076]                       else if (inherits(cond, "warning")) {
[17:43:34.076]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:34.076]                         if (muffled) 
[17:43:34.076]                           invokeRestart("muffleWarning")
[17:43:34.076]                       }
[17:43:34.076]                       else if (inherits(cond, "condition")) {
[17:43:34.076]                         if (!is.null(pattern)) {
[17:43:34.076]                           computeRestarts <- base::computeRestarts
[17:43:34.076]                           grepl <- base::grepl
[17:43:34.076]                           restarts <- computeRestarts(cond)
[17:43:34.076]                           for (restart in restarts) {
[17:43:34.076]                             name <- restart$name
[17:43:34.076]                             if (is.null(name)) 
[17:43:34.076]                               next
[17:43:34.076]                             if (!grepl(pattern, name)) 
[17:43:34.076]                               next
[17:43:34.076]                             invokeRestart(restart)
[17:43:34.076]                             muffled <- TRUE
[17:43:34.076]                             break
[17:43:34.076]                           }
[17:43:34.076]                         }
[17:43:34.076]                       }
[17:43:34.076]                       invisible(muffled)
[17:43:34.076]                     }
[17:43:34.076]                     muffleCondition(cond, pattern = "^muffle")
[17:43:34.076]                   }
[17:43:34.076]                 }
[17:43:34.076]                 else {
[17:43:34.076]                   if (TRUE) {
[17:43:34.076]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:34.076]                     {
[17:43:34.076]                       inherits <- base::inherits
[17:43:34.076]                       invokeRestart <- base::invokeRestart
[17:43:34.076]                       is.null <- base::is.null
[17:43:34.076]                       muffled <- FALSE
[17:43:34.076]                       if (inherits(cond, "message")) {
[17:43:34.076]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:34.076]                         if (muffled) 
[17:43:34.076]                           invokeRestart("muffleMessage")
[17:43:34.076]                       }
[17:43:34.076]                       else if (inherits(cond, "warning")) {
[17:43:34.076]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:34.076]                         if (muffled) 
[17:43:34.076]                           invokeRestart("muffleWarning")
[17:43:34.076]                       }
[17:43:34.076]                       else if (inherits(cond, "condition")) {
[17:43:34.076]                         if (!is.null(pattern)) {
[17:43:34.076]                           computeRestarts <- base::computeRestarts
[17:43:34.076]                           grepl <- base::grepl
[17:43:34.076]                           restarts <- computeRestarts(cond)
[17:43:34.076]                           for (restart in restarts) {
[17:43:34.076]                             name <- restart$name
[17:43:34.076]                             if (is.null(name)) 
[17:43:34.076]                               next
[17:43:34.076]                             if (!grepl(pattern, name)) 
[17:43:34.076]                               next
[17:43:34.076]                             invokeRestart(restart)
[17:43:34.076]                             muffled <- TRUE
[17:43:34.076]                             break
[17:43:34.076]                           }
[17:43:34.076]                         }
[17:43:34.076]                       }
[17:43:34.076]                       invisible(muffled)
[17:43:34.076]                     }
[17:43:34.076]                     muffleCondition(cond, pattern = "^muffle")
[17:43:34.076]                   }
[17:43:34.076]                 }
[17:43:34.076]             }
[17:43:34.076]         }))
[17:43:34.076]     }, error = function(ex) {
[17:43:34.076]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:34.076]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:34.076]                 ...future.rng), started = ...future.startTime, 
[17:43:34.076]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:34.076]             version = "1.8"), class = "FutureResult")
[17:43:34.076]     }, finally = {
[17:43:34.076]         if (!identical(...future.workdir, getwd())) 
[17:43:34.076]             setwd(...future.workdir)
[17:43:34.076]         {
[17:43:34.076]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:34.076]                 ...future.oldOptions$nwarnings <- NULL
[17:43:34.076]             }
[17:43:34.076]             base::options(...future.oldOptions)
[17:43:34.076]             if (.Platform$OS.type == "windows") {
[17:43:34.076]                 old_names <- names(...future.oldEnvVars)
[17:43:34.076]                 envs <- base::Sys.getenv()
[17:43:34.076]                 names <- names(envs)
[17:43:34.076]                 common <- intersect(names, old_names)
[17:43:34.076]                 added <- setdiff(names, old_names)
[17:43:34.076]                 removed <- setdiff(old_names, names)
[17:43:34.076]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:34.076]                   envs[common]]
[17:43:34.076]                 NAMES <- toupper(changed)
[17:43:34.076]                 args <- list()
[17:43:34.076]                 for (kk in seq_along(NAMES)) {
[17:43:34.076]                   name <- changed[[kk]]
[17:43:34.076]                   NAME <- NAMES[[kk]]
[17:43:34.076]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.076]                     next
[17:43:34.076]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:34.076]                 }
[17:43:34.076]                 NAMES <- toupper(added)
[17:43:34.076]                 for (kk in seq_along(NAMES)) {
[17:43:34.076]                   name <- added[[kk]]
[17:43:34.076]                   NAME <- NAMES[[kk]]
[17:43:34.076]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.076]                     next
[17:43:34.076]                   args[[name]] <- ""
[17:43:34.076]                 }
[17:43:34.076]                 NAMES <- toupper(removed)
[17:43:34.076]                 for (kk in seq_along(NAMES)) {
[17:43:34.076]                   name <- removed[[kk]]
[17:43:34.076]                   NAME <- NAMES[[kk]]
[17:43:34.076]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.076]                     next
[17:43:34.076]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:34.076]                 }
[17:43:34.076]                 if (length(args) > 0) 
[17:43:34.076]                   base::do.call(base::Sys.setenv, args = args)
[17:43:34.076]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:34.076]             }
[17:43:34.076]             else {
[17:43:34.076]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:34.076]             }
[17:43:34.076]             {
[17:43:34.076]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:34.076]                   0L) {
[17:43:34.076]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:34.076]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:34.076]                   base::options(opts)
[17:43:34.076]                 }
[17:43:34.076]                 {
[17:43:34.076]                   {
[17:43:34.076]                     NULL
[17:43:34.076]                     RNGkind("Mersenne-Twister")
[17:43:34.076]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:34.076]                       inherits = FALSE)
[17:43:34.076]                   }
[17:43:34.076]                   options(future.plan = NULL)
[17:43:34.076]                   if (is.na(NA_character_)) 
[17:43:34.076]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:34.076]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:34.076]                   future::plan(list(function (..., envir = parent.frame()) 
[17:43:34.076]                   {
[17:43:34.076]                     future <- SequentialFuture(..., envir = envir)
[17:43:34.076]                     if (!future$lazy) 
[17:43:34.076]                       future <- run(future)
[17:43:34.076]                     invisible(future)
[17:43:34.076]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:34.076]                 }
[17:43:34.076]             }
[17:43:34.076]         }
[17:43:34.076]     })
[17:43:34.076]     if (TRUE) {
[17:43:34.076]         base::sink(type = "output", split = FALSE)
[17:43:34.076]         if (TRUE) {
[17:43:34.076]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:34.076]         }
[17:43:34.076]         else {
[17:43:34.076]             ...future.result["stdout"] <- base::list(NULL)
[17:43:34.076]         }
[17:43:34.076]         base::close(...future.stdout)
[17:43:34.076]         ...future.stdout <- NULL
[17:43:34.076]     }
[17:43:34.076]     ...future.result$conditions <- ...future.conditions
[17:43:34.076]     ...future.result$finished <- base::Sys.time()
[17:43:34.076]     ...future.result
[17:43:34.076] }
[17:43:34.077] plan(): Setting new future strategy stack:
[17:43:34.078] List of future strategies:
[17:43:34.078] 1. sequential:
[17:43:34.078]    - args: function (..., envir = parent.frame())
[17:43:34.078]    - tweaked: FALSE
[17:43:34.078]    - call: NULL
[17:43:34.078] plan(): nbrOfWorkers() = 1
[17:43:34.579] plan(): Setting new future strategy stack:
[17:43:34.580] List of future strategies:
[17:43:34.580] 1. sequential:
[17:43:34.580]    - args: function (..., envir = parent.frame())
[17:43:34.580]    - tweaked: FALSE
[17:43:34.580]    - call: plan(strategy)
[17:43:34.580] plan(): nbrOfWorkers() = 1
[17:43:34.580] SequentialFuture started (and completed)
[17:43:34.581] - Launch lazy future ... done
[17:43:34.581] run() for ‘SequentialFuture’ ... done
[17:43:34.581] getGlobalsAndPackages() ...
[17:43:34.581] Searching for globals...
[17:43:34.582] - globals found: [1] ‘{’
[17:43:34.582] Searching for globals ... DONE
[17:43:34.582] Resolving globals: FALSE
[17:43:34.582] 
[17:43:34.582] 
[17:43:34.582] getGlobalsAndPackages() ... DONE
[17:43:34.583] run() for ‘Future’ ...
[17:43:34.583] - state: ‘created’
[17:43:34.583] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:43:34.583] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:43:34.583] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:43:34.584]   - Field: ‘label’
[17:43:34.584]   - Field: ‘local’
[17:43:34.584]   - Field: ‘owner’
[17:43:34.586]   - Field: ‘envir’
[17:43:34.586]   - Field: ‘packages’
[17:43:34.586]   - Field: ‘gc’
[17:43:34.586]   - Field: ‘conditions’
[17:43:34.586]   - Field: ‘expr’
[17:43:34.586]   - Field: ‘uuid’
[17:43:34.586]   - Field: ‘seed’
[17:43:34.586]   - Field: ‘version’
[17:43:34.586]   - Field: ‘result’
[17:43:34.587]   - Field: ‘asynchronous’
[17:43:34.587]   - Field: ‘calls’
[17:43:34.587]   - Field: ‘globals’
[17:43:34.587]   - Field: ‘stdout’
[17:43:34.587]   - Field: ‘earlySignal’
[17:43:34.587]   - Field: ‘lazy’
[17:43:34.587]   - Field: ‘state’
[17:43:34.587] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:43:34.587] - Launch lazy future ...
[17:43:34.588] Packages needed by the future expression (n = 0): <none>
[17:43:34.588] Packages needed by future strategies (n = 0): <none>
[17:43:34.588] {
[17:43:34.588]     {
[17:43:34.588]         {
[17:43:34.588]             ...future.startTime <- base::Sys.time()
[17:43:34.588]             {
[17:43:34.588]                 {
[17:43:34.588]                   {
[17:43:34.588]                     base::local({
[17:43:34.588]                       has_future <- base::requireNamespace("future", 
[17:43:34.588]                         quietly = TRUE)
[17:43:34.588]                       if (has_future) {
[17:43:34.588]                         ns <- base::getNamespace("future")
[17:43:34.588]                         version <- ns[[".package"]][["version"]]
[17:43:34.588]                         if (is.null(version)) 
[17:43:34.588]                           version <- utils::packageVersion("future")
[17:43:34.588]                       }
[17:43:34.588]                       else {
[17:43:34.588]                         version <- NULL
[17:43:34.588]                       }
[17:43:34.588]                       if (!has_future || version < "1.8.0") {
[17:43:34.588]                         info <- base::c(r_version = base::gsub("R version ", 
[17:43:34.588]                           "", base::R.version$version.string), 
[17:43:34.588]                           platform = base::sprintf("%s (%s-bit)", 
[17:43:34.588]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:34.588]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:34.588]                             "release", "version")], collapse = " "), 
[17:43:34.588]                           hostname = base::Sys.info()[["nodename"]])
[17:43:34.588]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:43:34.588]                           info)
[17:43:34.588]                         info <- base::paste(info, collapse = "; ")
[17:43:34.588]                         if (!has_future) {
[17:43:34.588]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:34.588]                             info)
[17:43:34.588]                         }
[17:43:34.588]                         else {
[17:43:34.588]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:34.588]                             info, version)
[17:43:34.588]                         }
[17:43:34.588]                         base::stop(msg)
[17:43:34.588]                       }
[17:43:34.588]                     })
[17:43:34.588]                   }
[17:43:34.588]                   options(future.plan = NULL)
[17:43:34.588]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:34.588]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:34.588]                 }
[17:43:34.588]                 ...future.workdir <- getwd()
[17:43:34.588]             }
[17:43:34.588]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:34.588]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:34.588]         }
[17:43:34.588]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:34.588]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:34.588]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:34.588]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:34.588]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:34.588]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:34.588]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:34.588]             base::names(...future.oldOptions))
[17:43:34.588]     }
[17:43:34.588]     if (FALSE) {
[17:43:34.588]     }
[17:43:34.588]     else {
[17:43:34.588]         if (TRUE) {
[17:43:34.588]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:34.588]                 open = "w")
[17:43:34.588]         }
[17:43:34.588]         else {
[17:43:34.588]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:34.588]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:34.588]         }
[17:43:34.588]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:34.588]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:34.588]             base::sink(type = "output", split = FALSE)
[17:43:34.588]             base::close(...future.stdout)
[17:43:34.588]         }, add = TRUE)
[17:43:34.588]     }
[17:43:34.588]     ...future.frame <- base::sys.nframe()
[17:43:34.588]     ...future.conditions <- base::list()
[17:43:34.588]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:34.588]     if (FALSE) {
[17:43:34.588]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:34.588]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:34.588]     }
[17:43:34.588]     ...future.result <- base::tryCatch({
[17:43:34.588]         base::withCallingHandlers({
[17:43:34.588]             ...future.value <- base::withVisible(base::local({
[17:43:34.588]                 3
[17:43:34.588]             }))
[17:43:34.588]             future::FutureResult(value = ...future.value$value, 
[17:43:34.588]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:34.588]                   ...future.rng), globalenv = if (FALSE) 
[17:43:34.588]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:34.588]                     ...future.globalenv.names))
[17:43:34.588]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:34.588]         }, condition = base::local({
[17:43:34.588]             c <- base::c
[17:43:34.588]             inherits <- base::inherits
[17:43:34.588]             invokeRestart <- base::invokeRestart
[17:43:34.588]             length <- base::length
[17:43:34.588]             list <- base::list
[17:43:34.588]             seq.int <- base::seq.int
[17:43:34.588]             signalCondition <- base::signalCondition
[17:43:34.588]             sys.calls <- base::sys.calls
[17:43:34.588]             `[[` <- base::`[[`
[17:43:34.588]             `+` <- base::`+`
[17:43:34.588]             `<<-` <- base::`<<-`
[17:43:34.588]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:34.588]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:34.588]                   3L)]
[17:43:34.588]             }
[17:43:34.588]             function(cond) {
[17:43:34.588]                 is_error <- inherits(cond, "error")
[17:43:34.588]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:34.588]                   NULL)
[17:43:34.588]                 if (is_error) {
[17:43:34.588]                   sessionInformation <- function() {
[17:43:34.588]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:34.588]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:34.588]                       search = base::search(), system = base::Sys.info())
[17:43:34.588]                   }
[17:43:34.588]                   ...future.conditions[[length(...future.conditions) + 
[17:43:34.588]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:34.588]                     cond$call), session = sessionInformation(), 
[17:43:34.588]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:34.588]                   signalCondition(cond)
[17:43:34.588]                 }
[17:43:34.588]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:34.588]                 "immediateCondition"))) {
[17:43:34.588]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:34.588]                   ...future.conditions[[length(...future.conditions) + 
[17:43:34.588]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:34.588]                   if (TRUE && !signal) {
[17:43:34.588]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:34.588]                     {
[17:43:34.588]                       inherits <- base::inherits
[17:43:34.588]                       invokeRestart <- base::invokeRestart
[17:43:34.588]                       is.null <- base::is.null
[17:43:34.588]                       muffled <- FALSE
[17:43:34.588]                       if (inherits(cond, "message")) {
[17:43:34.588]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:34.588]                         if (muffled) 
[17:43:34.588]                           invokeRestart("muffleMessage")
[17:43:34.588]                       }
[17:43:34.588]                       else if (inherits(cond, "warning")) {
[17:43:34.588]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:34.588]                         if (muffled) 
[17:43:34.588]                           invokeRestart("muffleWarning")
[17:43:34.588]                       }
[17:43:34.588]                       else if (inherits(cond, "condition")) {
[17:43:34.588]                         if (!is.null(pattern)) {
[17:43:34.588]                           computeRestarts <- base::computeRestarts
[17:43:34.588]                           grepl <- base::grepl
[17:43:34.588]                           restarts <- computeRestarts(cond)
[17:43:34.588]                           for (restart in restarts) {
[17:43:34.588]                             name <- restart$name
[17:43:34.588]                             if (is.null(name)) 
[17:43:34.588]                               next
[17:43:34.588]                             if (!grepl(pattern, name)) 
[17:43:34.588]                               next
[17:43:34.588]                             invokeRestart(restart)
[17:43:34.588]                             muffled <- TRUE
[17:43:34.588]                             break
[17:43:34.588]                           }
[17:43:34.588]                         }
[17:43:34.588]                       }
[17:43:34.588]                       invisible(muffled)
[17:43:34.588]                     }
[17:43:34.588]                     muffleCondition(cond, pattern = "^muffle")
[17:43:34.588]                   }
[17:43:34.588]                 }
[17:43:34.588]                 else {
[17:43:34.588]                   if (TRUE) {
[17:43:34.588]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:34.588]                     {
[17:43:34.588]                       inherits <- base::inherits
[17:43:34.588]                       invokeRestart <- base::invokeRestart
[17:43:34.588]                       is.null <- base::is.null
[17:43:34.588]                       muffled <- FALSE
[17:43:34.588]                       if (inherits(cond, "message")) {
[17:43:34.588]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:34.588]                         if (muffled) 
[17:43:34.588]                           invokeRestart("muffleMessage")
[17:43:34.588]                       }
[17:43:34.588]                       else if (inherits(cond, "warning")) {
[17:43:34.588]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:34.588]                         if (muffled) 
[17:43:34.588]                           invokeRestart("muffleWarning")
[17:43:34.588]                       }
[17:43:34.588]                       else if (inherits(cond, "condition")) {
[17:43:34.588]                         if (!is.null(pattern)) {
[17:43:34.588]                           computeRestarts <- base::computeRestarts
[17:43:34.588]                           grepl <- base::grepl
[17:43:34.588]                           restarts <- computeRestarts(cond)
[17:43:34.588]                           for (restart in restarts) {
[17:43:34.588]                             name <- restart$name
[17:43:34.588]                             if (is.null(name)) 
[17:43:34.588]                               next
[17:43:34.588]                             if (!grepl(pattern, name)) 
[17:43:34.588]                               next
[17:43:34.588]                             invokeRestart(restart)
[17:43:34.588]                             muffled <- TRUE
[17:43:34.588]                             break
[17:43:34.588]                           }
[17:43:34.588]                         }
[17:43:34.588]                       }
[17:43:34.588]                       invisible(muffled)
[17:43:34.588]                     }
[17:43:34.588]                     muffleCondition(cond, pattern = "^muffle")
[17:43:34.588]                   }
[17:43:34.588]                 }
[17:43:34.588]             }
[17:43:34.588]         }))
[17:43:34.588]     }, error = function(ex) {
[17:43:34.588]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:34.588]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:34.588]                 ...future.rng), started = ...future.startTime, 
[17:43:34.588]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:34.588]             version = "1.8"), class = "FutureResult")
[17:43:34.588]     }, finally = {
[17:43:34.588]         if (!identical(...future.workdir, getwd())) 
[17:43:34.588]             setwd(...future.workdir)
[17:43:34.588]         {
[17:43:34.588]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:34.588]                 ...future.oldOptions$nwarnings <- NULL
[17:43:34.588]             }
[17:43:34.588]             base::options(...future.oldOptions)
[17:43:34.588]             if (.Platform$OS.type == "windows") {
[17:43:34.588]                 old_names <- names(...future.oldEnvVars)
[17:43:34.588]                 envs <- base::Sys.getenv()
[17:43:34.588]                 names <- names(envs)
[17:43:34.588]                 common <- intersect(names, old_names)
[17:43:34.588]                 added <- setdiff(names, old_names)
[17:43:34.588]                 removed <- setdiff(old_names, names)
[17:43:34.588]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:34.588]                   envs[common]]
[17:43:34.588]                 NAMES <- toupper(changed)
[17:43:34.588]                 args <- list()
[17:43:34.588]                 for (kk in seq_along(NAMES)) {
[17:43:34.588]                   name <- changed[[kk]]
[17:43:34.588]                   NAME <- NAMES[[kk]]
[17:43:34.588]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.588]                     next
[17:43:34.588]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:34.588]                 }
[17:43:34.588]                 NAMES <- toupper(added)
[17:43:34.588]                 for (kk in seq_along(NAMES)) {
[17:43:34.588]                   name <- added[[kk]]
[17:43:34.588]                   NAME <- NAMES[[kk]]
[17:43:34.588]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.588]                     next
[17:43:34.588]                   args[[name]] <- ""
[17:43:34.588]                 }
[17:43:34.588]                 NAMES <- toupper(removed)
[17:43:34.588]                 for (kk in seq_along(NAMES)) {
[17:43:34.588]                   name <- removed[[kk]]
[17:43:34.588]                   NAME <- NAMES[[kk]]
[17:43:34.588]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.588]                     next
[17:43:34.588]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:34.588]                 }
[17:43:34.588]                 if (length(args) > 0) 
[17:43:34.588]                   base::do.call(base::Sys.setenv, args = args)
[17:43:34.588]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:34.588]             }
[17:43:34.588]             else {
[17:43:34.588]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:34.588]             }
[17:43:34.588]             {
[17:43:34.588]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:34.588]                   0L) {
[17:43:34.588]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:34.588]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:34.588]                   base::options(opts)
[17:43:34.588]                 }
[17:43:34.588]                 {
[17:43:34.588]                   {
[17:43:34.588]                     NULL
[17:43:34.588]                     RNGkind("Mersenne-Twister")
[17:43:34.588]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:43:34.588]                       inherits = FALSE)
[17:43:34.588]                   }
[17:43:34.588]                   options(future.plan = NULL)
[17:43:34.588]                   if (is.na(NA_character_)) 
[17:43:34.588]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:34.588]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:34.588]                   future::plan(list(function (..., envir = parent.frame()) 
[17:43:34.588]                   {
[17:43:34.588]                     future <- SequentialFuture(..., envir = envir)
[17:43:34.588]                     if (!future$lazy) 
[17:43:34.588]                       future <- run(future)
[17:43:34.588]                     invisible(future)
[17:43:34.588]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:34.588]                 }
[17:43:34.588]             }
[17:43:34.588]         }
[17:43:34.588]     })
[17:43:34.588]     if (TRUE) {
[17:43:34.588]         base::sink(type = "output", split = FALSE)
[17:43:34.588]         if (TRUE) {
[17:43:34.588]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:34.588]         }
[17:43:34.588]         else {
[17:43:34.588]             ...future.result["stdout"] <- base::list(NULL)
[17:43:34.588]         }
[17:43:34.588]         base::close(...future.stdout)
[17:43:34.588]         ...future.stdout <- NULL
[17:43:34.588]     }
[17:43:34.588]     ...future.result$conditions <- ...future.conditions
[17:43:34.588]     ...future.result$finished <- base::Sys.time()
[17:43:34.588]     ...future.result
[17:43:34.588] }
[17:43:34.590] plan(): Setting new future strategy stack:
[17:43:34.590] List of future strategies:
[17:43:34.590] 1. sequential:
[17:43:34.590]    - args: function (..., envir = parent.frame())
[17:43:34.590]    - tweaked: FALSE
[17:43:34.590]    - call: NULL
[17:43:34.590] plan(): nbrOfWorkers() = 1
[17:43:34.591] plan(): Setting new future strategy stack:
[17:43:34.591] List of future strategies:
[17:43:34.591] 1. sequential:
[17:43:34.591]    - args: function (..., envir = parent.frame())
[17:43:34.591]    - tweaked: FALSE
[17:43:34.591]    - call: plan(strategy)
[17:43:34.592] plan(): nbrOfWorkers() = 1
[17:43:34.592] SequentialFuture started (and completed)
[17:43:34.592] - Launch lazy future ... done
[17:43:34.592] run() for ‘SequentialFuture’ ... done
[17:43:34.593] resolve() on list environment ...
[17:43:34.593]  recursive: 0
[17:43:34.593]  length: 4
[17:43:34.593]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:43:34.594] resolved() for ‘SequentialFuture’ ...
[17:43:34.594] - state: ‘finished’
[17:43:34.594] - run: TRUE
[17:43:34.594] - result: ‘FutureResult’
[17:43:34.594] resolved() for ‘SequentialFuture’ ... done
[17:43:34.594] Future #1
[17:43:34.594]  length: 3 (resolved future 1)
[17:43:34.594] resolved() for ‘SequentialFuture’ ...
[17:43:34.594] - state: ‘finished’
[17:43:34.594] - run: TRUE
[17:43:34.595] - result: ‘FutureResult’
[17:43:34.595] resolved() for ‘SequentialFuture’ ... done
[17:43:34.595] Future #2
[17:43:34.595]  length: 2 (resolved future 2)
[17:43:34.595] resolved() for ‘SequentialFuture’ ...
[17:43:34.595] - state: ‘finished’
[17:43:34.595] - run: TRUE
[17:43:34.595] - result: ‘FutureResult’
[17:43:34.595] resolved() for ‘SequentialFuture’ ... done
[17:43:34.595] Future #3
[17:43:34.595]  length: 1 (resolved future 3)
[17:43:34.596]  length: 0 (resolved future 4)
[17:43:34.596] resolve() on list environment ... DONE
[17:43:34.596] resolved() for ‘SequentialFuture’ ...
[17:43:34.596] - state: ‘finished’
[17:43:34.596] - run: TRUE
[17:43:34.596] - result: ‘FutureResult’
[17:43:34.596] resolved() for ‘SequentialFuture’ ... done
[17:43:34.596] resolve() on list environment ...
[17:43:34.597]  recursive: 0
[17:43:34.597]  length: 4
[17:43:34.597]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:43:34.597] resolved() for ‘SequentialFuture’ ...
[17:43:34.598] - state: ‘finished’
[17:43:34.598] - run: TRUE
[17:43:34.598] - result: ‘FutureResult’
[17:43:34.598] resolved() for ‘SequentialFuture’ ... done
[17:43:34.598] Future #1
[17:43:34.598]  length: 3 (resolved future 1)
[17:43:34.598] resolved() for ‘SequentialFuture’ ...
[17:43:34.598] - state: ‘finished’
[17:43:34.598] - run: TRUE
[17:43:34.598] - result: ‘FutureResult’
[17:43:34.598] resolved() for ‘SequentialFuture’ ... done
[17:43:34.599] Future #2
[17:43:34.599]  length: 2 (resolved future 2)
[17:43:34.599] resolved() for ‘SequentialFuture’ ...
[17:43:34.599] - state: ‘finished’
[17:43:34.599] - run: TRUE
[17:43:34.599] - result: ‘FutureResult’
[17:43:34.599] resolved() for ‘SequentialFuture’ ... done
[17:43:34.599] Future #3
[17:43:34.599]  length: 1 (resolved future 3)
[17:43:34.599]  length: 0 (resolved future 4)
[17:43:34.600] resolve() on list environment ... DONE
[17:43:34.600] resolve() on list environment ...
[17:43:34.600]  recursive: 0
[17:43:34.601]  length: 4
[17:43:34.601]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:43:34.601] resolved() for ‘SequentialFuture’ ...
[17:43:34.601] - state: ‘finished’
[17:43:34.601] - run: TRUE
[17:43:34.601] - result: ‘FutureResult’
[17:43:34.601] resolved() for ‘SequentialFuture’ ... done
[17:43:34.602] Future #1
[17:43:34.602]  length: 3 (resolved future 1)
[17:43:34.602] resolved() for ‘SequentialFuture’ ...
[17:43:34.602] - state: ‘finished’
[17:43:34.602] - run: TRUE
[17:43:34.602] - result: ‘FutureResult’
[17:43:34.602] resolved() for ‘SequentialFuture’ ... done
[17:43:34.602] Future #2
[17:43:34.602]  length: 2 (resolved future 2)
[17:43:34.602] resolved() for ‘SequentialFuture’ ...
[17:43:34.602] - state: ‘finished’
[17:43:34.603] - run: TRUE
[17:43:34.603] - result: ‘FutureResult’
[17:43:34.603] resolved() for ‘SequentialFuture’ ... done
[17:43:34.603] Future #3
[17:43:34.603]  length: 1 (resolved future 3)
[17:43:34.603]  length: 0 (resolved future 4)
[17:43:34.603] resolve() on list environment ... DONE
[17:43:34.604] resolve() on list environment ...
[17:43:34.604]  recursive: 0
[17:43:34.604]  length: 4
[17:43:34.604]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:43:34.605] resolved() for ‘SequentialFuture’ ...
[17:43:34.605] - state: ‘finished’
[17:43:34.605] - run: TRUE
[17:43:34.605] - result: ‘FutureResult’
[17:43:34.605] resolved() for ‘SequentialFuture’ ... done
[17:43:34.605] Future #1
[17:43:34.605]  length: 3 (resolved future 1)
[17:43:34.605] resolved() for ‘SequentialFuture’ ...
[17:43:34.605] - state: ‘finished’
[17:43:34.605] - run: TRUE
[17:43:34.605] - result: ‘FutureResult’
[17:43:34.606] resolved() for ‘SequentialFuture’ ... done
[17:43:34.606] Future #2
[17:43:34.606]  length: 2 (resolved future 2)
[17:43:34.606] resolved() for ‘SequentialFuture’ ...
[17:43:34.606] - state: ‘finished’
[17:43:34.606] - run: TRUE
[17:43:34.606] - result: ‘FutureResult’
[17:43:34.606] resolved() for ‘SequentialFuture’ ... done
[17:43:34.606] Future #3
[17:43:34.606]  length: 1 (resolved future 3)
[17:43:34.607]  length: 0 (resolved future 4)
[17:43:34.607] resolve() on list environment ... DONE
[17:43:34.633] resolve() on list environment ...
[17:43:34.633]  recursive: 0
[17:43:34.634]  length: 4
[17:43:34.634]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:43:34.634] resolved() for ‘SequentialFuture’ ...
[17:43:34.634] - state: ‘finished’
[17:43:34.634] - run: TRUE
[17:43:34.634] - result: ‘FutureResult’
[17:43:34.634] resolved() for ‘SequentialFuture’ ... done
[17:43:34.635] Future #1
[17:43:34.635]  length: 3 (resolved future 1)
[17:43:34.635] resolved() for ‘SequentialFuture’ ...
[17:43:34.635] - state: ‘finished’
[17:43:34.635] - run: TRUE
[17:43:34.635] - result: ‘FutureResult’
[17:43:34.635] resolved() for ‘SequentialFuture’ ... done
[17:43:34.635] Future #2
[17:43:34.635]  length: 2 (resolved future 2)
[17:43:34.636] resolved() for ‘SequentialFuture’ ...
[17:43:34.636] - state: ‘finished’
[17:43:34.636] - run: TRUE
[17:43:34.636] - result: ‘FutureResult’
[17:43:34.636] resolved() for ‘SequentialFuture’ ... done
[17:43:34.636] Future #3
[17:43:34.636]  length: 1 (resolved future 3)
[17:43:34.636]  length: 0 (resolved future 4)
[17:43:34.636] resolve() on list environment ... DONE
[17:43:34.637] resolve() on list environment ...
[17:43:34.637]  recursive: 99
[17:43:34.638]  length: 4
[17:43:34.638]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:43:34.638] resolved() for ‘SequentialFuture’ ...
[17:43:34.638] - state: ‘finished’
[17:43:34.638] - run: TRUE
[17:43:34.639] - result: ‘FutureResult’
[17:43:34.639] resolved() for ‘SequentialFuture’ ... done
[17:43:34.639] Future #1
[17:43:34.639] resolved() for ‘SequentialFuture’ ...
[17:43:34.639] - state: ‘finished’
[17:43:34.639] - run: TRUE
[17:43:34.639] - result: ‘FutureResult’
[17:43:34.639] resolved() for ‘SequentialFuture’ ... done
[17:43:34.639] A SequentialFuture was resolved
[17:43:34.640]  length: 3 (resolved future 1)
[17:43:34.640] resolved() for ‘SequentialFuture’ ...
[17:43:34.640] - state: ‘finished’
[17:43:34.640] - run: TRUE
[17:43:34.640] - result: ‘FutureResult’
[17:43:34.640] resolved() for ‘SequentialFuture’ ... done
[17:43:34.640] Future #2
[17:43:34.640] resolved() for ‘SequentialFuture’ ...
[17:43:34.640] - state: ‘finished’
[17:43:34.640] - run: TRUE
[17:43:34.641] - result: ‘FutureResult’
[17:43:34.641] resolved() for ‘SequentialFuture’ ... done
[17:43:34.641] A SequentialFuture was resolved
[17:43:34.641]  length: 2 (resolved future 2)
[17:43:34.641] resolved() for ‘SequentialFuture’ ...
[17:43:34.641] - state: ‘finished’
[17:43:34.641] - run: TRUE
[17:43:34.641] - result: ‘FutureResult’
[17:43:34.641] resolved() for ‘SequentialFuture’ ... done
[17:43:34.641] Future #3
[17:43:34.642] resolved() for ‘SequentialFuture’ ...
[17:43:34.642] - state: ‘finished’
[17:43:34.642] - run: TRUE
[17:43:34.642] - result: ‘FutureResult’
[17:43:34.642] resolved() for ‘SequentialFuture’ ... done
[17:43:34.642] A SequentialFuture was resolved
[17:43:34.642]  length: 1 (resolved future 3)
[17:43:34.642]  length: 0 (resolved future 4)
[17:43:34.642] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('sequential') ...
- plan('multicore') ...
[17:43:34.643] plan(): Setting new future strategy stack:
[17:43:34.643] List of future strategies:
[17:43:34.643] 1. multicore:
[17:43:34.643]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:34.643]    - tweaked: FALSE
[17:43:34.643]    - call: plan(strategy)
[17:43:34.647] plan(): nbrOfWorkers() = 2
*** resolve() for lists ...
[17:43:34.647] resolve() on list ...
[17:43:34.647]  recursive: 0
[17:43:34.648]  length: 2
[17:43:34.648]  elements: ‘a’, ‘b’
[17:43:34.648]  length: 1 (resolved future 1)
[17:43:34.648]  length: 0 (resolved future 2)
[17:43:34.648] resolve() on list ... DONE
[17:43:34.648] getGlobalsAndPackages() ...
[17:43:34.648] Searching for globals...
[17:43:34.649] 
[17:43:34.649] Searching for globals ... DONE
[17:43:34.649] - globals: [0] <none>
[17:43:34.649] getGlobalsAndPackages() ... DONE
[17:43:34.649] run() for ‘Future’ ...
[17:43:34.649] - state: ‘created’
[17:43:34.649] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:34.653] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:34.653] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:34.653]   - Field: ‘label’
[17:43:34.653]   - Field: ‘local’
[17:43:34.653]   - Field: ‘owner’
[17:43:34.653]   - Field: ‘envir’
[17:43:34.653]   - Field: ‘workers’
[17:43:34.654]   - Field: ‘packages’
[17:43:34.654]   - Field: ‘gc’
[17:43:34.654]   - Field: ‘job’
[17:43:34.654]   - Field: ‘conditions’
[17:43:34.654]   - Field: ‘expr’
[17:43:34.654]   - Field: ‘uuid’
[17:43:34.654]   - Field: ‘seed’
[17:43:34.654]   - Field: ‘version’
[17:43:34.654]   - Field: ‘result’
[17:43:34.654]   - Field: ‘asynchronous’
[17:43:34.654]   - Field: ‘calls’
[17:43:34.655]   - Field: ‘globals’
[17:43:34.655]   - Field: ‘stdout’
[17:43:34.655]   - Field: ‘earlySignal’
[17:43:34.655]   - Field: ‘lazy’
[17:43:34.655]   - Field: ‘state’
[17:43:34.655] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:34.655] - Launch lazy future ...
[17:43:34.656] Packages needed by the future expression (n = 0): <none>
[17:43:34.656] Packages needed by future strategies (n = 0): <none>
[17:43:34.657] {
[17:43:34.657]     {
[17:43:34.657]         {
[17:43:34.657]             ...future.startTime <- base::Sys.time()
[17:43:34.657]             {
[17:43:34.657]                 {
[17:43:34.657]                   {
[17:43:34.657]                     {
[17:43:34.657]                       base::local({
[17:43:34.657]                         has_future <- base::requireNamespace("future", 
[17:43:34.657]                           quietly = TRUE)
[17:43:34.657]                         if (has_future) {
[17:43:34.657]                           ns <- base::getNamespace("future")
[17:43:34.657]                           version <- ns[[".package"]][["version"]]
[17:43:34.657]                           if (is.null(version)) 
[17:43:34.657]                             version <- utils::packageVersion("future")
[17:43:34.657]                         }
[17:43:34.657]                         else {
[17:43:34.657]                           version <- NULL
[17:43:34.657]                         }
[17:43:34.657]                         if (!has_future || version < "1.8.0") {
[17:43:34.657]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:34.657]                             "", base::R.version$version.string), 
[17:43:34.657]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:34.657]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:34.657]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:34.657]                               "release", "version")], collapse = " "), 
[17:43:34.657]                             hostname = base::Sys.info()[["nodename"]])
[17:43:34.657]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:34.657]                             info)
[17:43:34.657]                           info <- base::paste(info, collapse = "; ")
[17:43:34.657]                           if (!has_future) {
[17:43:34.657]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:34.657]                               info)
[17:43:34.657]                           }
[17:43:34.657]                           else {
[17:43:34.657]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:34.657]                               info, version)
[17:43:34.657]                           }
[17:43:34.657]                           base::stop(msg)
[17:43:34.657]                         }
[17:43:34.657]                       })
[17:43:34.657]                     }
[17:43:34.657]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:34.657]                     base::options(mc.cores = 1L)
[17:43:34.657]                   }
[17:43:34.657]                   options(future.plan = NULL)
[17:43:34.657]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:34.657]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:34.657]                 }
[17:43:34.657]                 ...future.workdir <- getwd()
[17:43:34.657]             }
[17:43:34.657]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:34.657]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:34.657]         }
[17:43:34.657]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:34.657]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:34.657]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:34.657]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:34.657]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:34.657]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:34.657]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:34.657]             base::names(...future.oldOptions))
[17:43:34.657]     }
[17:43:34.657]     if (FALSE) {
[17:43:34.657]     }
[17:43:34.657]     else {
[17:43:34.657]         if (TRUE) {
[17:43:34.657]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:34.657]                 open = "w")
[17:43:34.657]         }
[17:43:34.657]         else {
[17:43:34.657]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:34.657]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:34.657]         }
[17:43:34.657]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:34.657]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:34.657]             base::sink(type = "output", split = FALSE)
[17:43:34.657]             base::close(...future.stdout)
[17:43:34.657]         }, add = TRUE)
[17:43:34.657]     }
[17:43:34.657]     ...future.frame <- base::sys.nframe()
[17:43:34.657]     ...future.conditions <- base::list()
[17:43:34.657]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:34.657]     if (FALSE) {
[17:43:34.657]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:34.657]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:34.657]     }
[17:43:34.657]     ...future.result <- base::tryCatch({
[17:43:34.657]         base::withCallingHandlers({
[17:43:34.657]             ...future.value <- base::withVisible(base::local({
[17:43:34.657]                 withCallingHandlers({
[17:43:34.657]                   1
[17:43:34.657]                 }, immediateCondition = function(cond) {
[17:43:34.657]                   save_rds <- function (object, pathname, ...) 
[17:43:34.657]                   {
[17:43:34.657]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:34.657]                     if (file_test("-f", pathname_tmp)) {
[17:43:34.657]                       fi_tmp <- file.info(pathname_tmp)
[17:43:34.657]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:34.657]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:34.657]                         fi_tmp[["mtime"]])
[17:43:34.657]                     }
[17:43:34.657]                     tryCatch({
[17:43:34.657]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:34.657]                     }, error = function(ex) {
[17:43:34.657]                       msg <- conditionMessage(ex)
[17:43:34.657]                       fi_tmp <- file.info(pathname_tmp)
[17:43:34.657]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:34.657]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:34.657]                         fi_tmp[["mtime"]], msg)
[17:43:34.657]                       ex$message <- msg
[17:43:34.657]                       stop(ex)
[17:43:34.657]                     })
[17:43:34.657]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:34.657]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:34.657]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:34.657]                       fi_tmp <- file.info(pathname_tmp)
[17:43:34.657]                       fi <- file.info(pathname)
[17:43:34.657]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:34.657]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:34.657]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:34.657]                         fi[["size"]], fi[["mtime"]])
[17:43:34.657]                       stop(msg)
[17:43:34.657]                     }
[17:43:34.657]                     invisible(pathname)
[17:43:34.657]                   }
[17:43:34.657]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:34.657]                     rootPath = tempdir()) 
[17:43:34.657]                   {
[17:43:34.657]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:34.657]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:34.657]                       tmpdir = path, fileext = ".rds")
[17:43:34.657]                     save_rds(obj, file)
[17:43:34.657]                   }
[17:43:34.657]                   saveImmediateCondition(cond, path = "/tmp/RtmpLaOb2h/.future/immediateConditions")
[17:43:34.657]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:34.657]                   {
[17:43:34.657]                     inherits <- base::inherits
[17:43:34.657]                     invokeRestart <- base::invokeRestart
[17:43:34.657]                     is.null <- base::is.null
[17:43:34.657]                     muffled <- FALSE
[17:43:34.657]                     if (inherits(cond, "message")) {
[17:43:34.657]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:34.657]                       if (muffled) 
[17:43:34.657]                         invokeRestart("muffleMessage")
[17:43:34.657]                     }
[17:43:34.657]                     else if (inherits(cond, "warning")) {
[17:43:34.657]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:34.657]                       if (muffled) 
[17:43:34.657]                         invokeRestart("muffleWarning")
[17:43:34.657]                     }
[17:43:34.657]                     else if (inherits(cond, "condition")) {
[17:43:34.657]                       if (!is.null(pattern)) {
[17:43:34.657]                         computeRestarts <- base::computeRestarts
[17:43:34.657]                         grepl <- base::grepl
[17:43:34.657]                         restarts <- computeRestarts(cond)
[17:43:34.657]                         for (restart in restarts) {
[17:43:34.657]                           name <- restart$name
[17:43:34.657]                           if (is.null(name)) 
[17:43:34.657]                             next
[17:43:34.657]                           if (!grepl(pattern, name)) 
[17:43:34.657]                             next
[17:43:34.657]                           invokeRestart(restart)
[17:43:34.657]                           muffled <- TRUE
[17:43:34.657]                           break
[17:43:34.657]                         }
[17:43:34.657]                       }
[17:43:34.657]                     }
[17:43:34.657]                     invisible(muffled)
[17:43:34.657]                   }
[17:43:34.657]                   muffleCondition(cond)
[17:43:34.657]                 })
[17:43:34.657]             }))
[17:43:34.657]             future::FutureResult(value = ...future.value$value, 
[17:43:34.657]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:34.657]                   ...future.rng), globalenv = if (FALSE) 
[17:43:34.657]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:34.657]                     ...future.globalenv.names))
[17:43:34.657]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:34.657]         }, condition = base::local({
[17:43:34.657]             c <- base::c
[17:43:34.657]             inherits <- base::inherits
[17:43:34.657]             invokeRestart <- base::invokeRestart
[17:43:34.657]             length <- base::length
[17:43:34.657]             list <- base::list
[17:43:34.657]             seq.int <- base::seq.int
[17:43:34.657]             signalCondition <- base::signalCondition
[17:43:34.657]             sys.calls <- base::sys.calls
[17:43:34.657]             `[[` <- base::`[[`
[17:43:34.657]             `+` <- base::`+`
[17:43:34.657]             `<<-` <- base::`<<-`
[17:43:34.657]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:34.657]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:34.657]                   3L)]
[17:43:34.657]             }
[17:43:34.657]             function(cond) {
[17:43:34.657]                 is_error <- inherits(cond, "error")
[17:43:34.657]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:34.657]                   NULL)
[17:43:34.657]                 if (is_error) {
[17:43:34.657]                   sessionInformation <- function() {
[17:43:34.657]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:34.657]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:34.657]                       search = base::search(), system = base::Sys.info())
[17:43:34.657]                   }
[17:43:34.657]                   ...future.conditions[[length(...future.conditions) + 
[17:43:34.657]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:34.657]                     cond$call), session = sessionInformation(), 
[17:43:34.657]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:34.657]                   signalCondition(cond)
[17:43:34.657]                 }
[17:43:34.657]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:34.657]                 "immediateCondition"))) {
[17:43:34.657]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:34.657]                   ...future.conditions[[length(...future.conditions) + 
[17:43:34.657]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:34.657]                   if (TRUE && !signal) {
[17:43:34.657]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:34.657]                     {
[17:43:34.657]                       inherits <- base::inherits
[17:43:34.657]                       invokeRestart <- base::invokeRestart
[17:43:34.657]                       is.null <- base::is.null
[17:43:34.657]                       muffled <- FALSE
[17:43:34.657]                       if (inherits(cond, "message")) {
[17:43:34.657]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:34.657]                         if (muffled) 
[17:43:34.657]                           invokeRestart("muffleMessage")
[17:43:34.657]                       }
[17:43:34.657]                       else if (inherits(cond, "warning")) {
[17:43:34.657]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:34.657]                         if (muffled) 
[17:43:34.657]                           invokeRestart("muffleWarning")
[17:43:34.657]                       }
[17:43:34.657]                       else if (inherits(cond, "condition")) {
[17:43:34.657]                         if (!is.null(pattern)) {
[17:43:34.657]                           computeRestarts <- base::computeRestarts
[17:43:34.657]                           grepl <- base::grepl
[17:43:34.657]                           restarts <- computeRestarts(cond)
[17:43:34.657]                           for (restart in restarts) {
[17:43:34.657]                             name <- restart$name
[17:43:34.657]                             if (is.null(name)) 
[17:43:34.657]                               next
[17:43:34.657]                             if (!grepl(pattern, name)) 
[17:43:34.657]                               next
[17:43:34.657]                             invokeRestart(restart)
[17:43:34.657]                             muffled <- TRUE
[17:43:34.657]                             break
[17:43:34.657]                           }
[17:43:34.657]                         }
[17:43:34.657]                       }
[17:43:34.657]                       invisible(muffled)
[17:43:34.657]                     }
[17:43:34.657]                     muffleCondition(cond, pattern = "^muffle")
[17:43:34.657]                   }
[17:43:34.657]                 }
[17:43:34.657]                 else {
[17:43:34.657]                   if (TRUE) {
[17:43:34.657]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:34.657]                     {
[17:43:34.657]                       inherits <- base::inherits
[17:43:34.657]                       invokeRestart <- base::invokeRestart
[17:43:34.657]                       is.null <- base::is.null
[17:43:34.657]                       muffled <- FALSE
[17:43:34.657]                       if (inherits(cond, "message")) {
[17:43:34.657]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:34.657]                         if (muffled) 
[17:43:34.657]                           invokeRestart("muffleMessage")
[17:43:34.657]                       }
[17:43:34.657]                       else if (inherits(cond, "warning")) {
[17:43:34.657]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:34.657]                         if (muffled) 
[17:43:34.657]                           invokeRestart("muffleWarning")
[17:43:34.657]                       }
[17:43:34.657]                       else if (inherits(cond, "condition")) {
[17:43:34.657]                         if (!is.null(pattern)) {
[17:43:34.657]                           computeRestarts <- base::computeRestarts
[17:43:34.657]                           grepl <- base::grepl
[17:43:34.657]                           restarts <- computeRestarts(cond)
[17:43:34.657]                           for (restart in restarts) {
[17:43:34.657]                             name <- restart$name
[17:43:34.657]                             if (is.null(name)) 
[17:43:34.657]                               next
[17:43:34.657]                             if (!grepl(pattern, name)) 
[17:43:34.657]                               next
[17:43:34.657]                             invokeRestart(restart)
[17:43:34.657]                             muffled <- TRUE
[17:43:34.657]                             break
[17:43:34.657]                           }
[17:43:34.657]                         }
[17:43:34.657]                       }
[17:43:34.657]                       invisible(muffled)
[17:43:34.657]                     }
[17:43:34.657]                     muffleCondition(cond, pattern = "^muffle")
[17:43:34.657]                   }
[17:43:34.657]                 }
[17:43:34.657]             }
[17:43:34.657]         }))
[17:43:34.657]     }, error = function(ex) {
[17:43:34.657]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:34.657]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:34.657]                 ...future.rng), started = ...future.startTime, 
[17:43:34.657]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:34.657]             version = "1.8"), class = "FutureResult")
[17:43:34.657]     }, finally = {
[17:43:34.657]         if (!identical(...future.workdir, getwd())) 
[17:43:34.657]             setwd(...future.workdir)
[17:43:34.657]         {
[17:43:34.657]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:34.657]                 ...future.oldOptions$nwarnings <- NULL
[17:43:34.657]             }
[17:43:34.657]             base::options(...future.oldOptions)
[17:43:34.657]             if (.Platform$OS.type == "windows") {
[17:43:34.657]                 old_names <- names(...future.oldEnvVars)
[17:43:34.657]                 envs <- base::Sys.getenv()
[17:43:34.657]                 names <- names(envs)
[17:43:34.657]                 common <- intersect(names, old_names)
[17:43:34.657]                 added <- setdiff(names, old_names)
[17:43:34.657]                 removed <- setdiff(old_names, names)
[17:43:34.657]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:34.657]                   envs[common]]
[17:43:34.657]                 NAMES <- toupper(changed)
[17:43:34.657]                 args <- list()
[17:43:34.657]                 for (kk in seq_along(NAMES)) {
[17:43:34.657]                   name <- changed[[kk]]
[17:43:34.657]                   NAME <- NAMES[[kk]]
[17:43:34.657]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.657]                     next
[17:43:34.657]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:34.657]                 }
[17:43:34.657]                 NAMES <- toupper(added)
[17:43:34.657]                 for (kk in seq_along(NAMES)) {
[17:43:34.657]                   name <- added[[kk]]
[17:43:34.657]                   NAME <- NAMES[[kk]]
[17:43:34.657]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.657]                     next
[17:43:34.657]                   args[[name]] <- ""
[17:43:34.657]                 }
[17:43:34.657]                 NAMES <- toupper(removed)
[17:43:34.657]                 for (kk in seq_along(NAMES)) {
[17:43:34.657]                   name <- removed[[kk]]
[17:43:34.657]                   NAME <- NAMES[[kk]]
[17:43:34.657]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.657]                     next
[17:43:34.657]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:34.657]                 }
[17:43:34.657]                 if (length(args) > 0) 
[17:43:34.657]                   base::do.call(base::Sys.setenv, args = args)
[17:43:34.657]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:34.657]             }
[17:43:34.657]             else {
[17:43:34.657]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:34.657]             }
[17:43:34.657]             {
[17:43:34.657]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:34.657]                   0L) {
[17:43:34.657]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:34.657]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:34.657]                   base::options(opts)
[17:43:34.657]                 }
[17:43:34.657]                 {
[17:43:34.657]                   {
[17:43:34.657]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:34.657]                     NULL
[17:43:34.657]                   }
[17:43:34.657]                   options(future.plan = NULL)
[17:43:34.657]                   if (is.na(NA_character_)) 
[17:43:34.657]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:34.657]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:34.657]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:43:34.657]                     envir = parent.frame()) 
[17:43:34.657]                   {
[17:43:34.657]                     default_workers <- missing(workers)
[17:43:34.657]                     if (is.function(workers)) 
[17:43:34.657]                       workers <- workers()
[17:43:34.657]                     workers <- structure(as.integer(workers), 
[17:43:34.657]                       class = class(workers))
[17:43:34.657]                     stop_if_not(is.finite(workers), workers >= 
[17:43:34.657]                       1L)
[17:43:34.657]                     if ((workers == 1L && !inherits(workers, 
[17:43:34.657]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:34.657]                       if (default_workers) 
[17:43:34.657]                         supportsMulticore(warn = TRUE)
[17:43:34.657]                       return(sequential(..., envir = envir))
[17:43:34.657]                     }
[17:43:34.657]                     oopts <- options(mc.cores = workers)
[17:43:34.657]                     on.exit(options(oopts))
[17:43:34.657]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:34.657]                       envir = envir)
[17:43:34.657]                     if (!future$lazy) 
[17:43:34.657]                       future <- run(future)
[17:43:34.657]                     invisible(future)
[17:43:34.657]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:34.657]                 }
[17:43:34.657]             }
[17:43:34.657]         }
[17:43:34.657]     })
[17:43:34.657]     if (TRUE) {
[17:43:34.657]         base::sink(type = "output", split = FALSE)
[17:43:34.657]         if (TRUE) {
[17:43:34.657]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:34.657]         }
[17:43:34.657]         else {
[17:43:34.657]             ...future.result["stdout"] <- base::list(NULL)
[17:43:34.657]         }
[17:43:34.657]         base::close(...future.stdout)
[17:43:34.657]         ...future.stdout <- NULL
[17:43:34.657]     }
[17:43:34.657]     ...future.result$conditions <- ...future.conditions
[17:43:34.657]     ...future.result$finished <- base::Sys.time()
[17:43:34.657]     ...future.result
[17:43:34.657] }
[17:43:34.659] requestCore(): workers = 2
[17:43:34.662] MulticoreFuture started
[17:43:34.662] - Launch lazy future ... done
[17:43:34.663] plan(): Setting new future strategy stack:
[17:43:34.663] run() for ‘MulticoreFuture’ ... done
[17:43:34.663] getGlobalsAndPackages() ...
[17:43:34.664] Searching for globals...
[17:43:34.663] List of future strategies:
[17:43:34.663] 1. sequential:
[17:43:34.663]    - args: function (..., envir = parent.frame())
[17:43:34.663]    - tweaked: FALSE
[17:43:34.663]    - call: NULL
[17:43:34.664] plan(): nbrOfWorkers() = 1
[17:43:34.664] 
[17:43:34.665] Searching for globals ... DONE
[17:43:34.665] - globals: [0] <none>
[17:43:34.665] getGlobalsAndPackages() ... DONE
[17:43:34.666] plan(): Setting new future strategy stack:
[17:43:34.666] run() for ‘Future’ ...
[17:43:34.666] - state: ‘created’
[17:43:34.666] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:34.666] List of future strategies:
[17:43:34.666] 1. multicore:
[17:43:34.666]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:34.666]    - tweaked: FALSE
[17:43:34.666]    - call: plan(strategy)
[17:43:34.671] plan(): nbrOfWorkers() = 2
[17:43:34.672] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:34.672] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:34.672]   - Field: ‘label’
[17:43:34.673]   - Field: ‘local’
[17:43:34.673]   - Field: ‘owner’
[17:43:34.673]   - Field: ‘envir’
[17:43:34.673]   - Field: ‘workers’
[17:43:34.673]   - Field: ‘packages’
[17:43:34.673]   - Field: ‘gc’
[17:43:34.673]   - Field: ‘job’
[17:43:34.674]   - Field: ‘conditions’
[17:43:34.674]   - Field: ‘expr’
[17:43:34.674]   - Field: ‘uuid’
[17:43:34.674]   - Field: ‘seed’
[17:43:34.674]   - Field: ‘version’
[17:43:34.674]   - Field: ‘result’
[17:43:34.675]   - Field: ‘asynchronous’
[17:43:34.675]   - Field: ‘calls’
[17:43:34.675]   - Field: ‘globals’
[17:43:34.675]   - Field: ‘stdout’
[17:43:34.675]   - Field: ‘earlySignal’
[17:43:34.675]   - Field: ‘lazy’
[17:43:34.675]   - Field: ‘state’
[17:43:34.676] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:34.676] - Launch lazy future ...
[17:43:34.676] Packages needed by the future expression (n = 0): <none>
[17:43:34.680] Packages needed by future strategies (n = 0): <none>
[17:43:34.681] {
[17:43:34.681]     {
[17:43:34.681]         {
[17:43:34.681]             ...future.startTime <- base::Sys.time()
[17:43:34.681]             {
[17:43:34.681]                 {
[17:43:34.681]                   {
[17:43:34.681]                     {
[17:43:34.681]                       base::local({
[17:43:34.681]                         has_future <- base::requireNamespace("future", 
[17:43:34.681]                           quietly = TRUE)
[17:43:34.681]                         if (has_future) {
[17:43:34.681]                           ns <- base::getNamespace("future")
[17:43:34.681]                           version <- ns[[".package"]][["version"]]
[17:43:34.681]                           if (is.null(version)) 
[17:43:34.681]                             version <- utils::packageVersion("future")
[17:43:34.681]                         }
[17:43:34.681]                         else {
[17:43:34.681]                           version <- NULL
[17:43:34.681]                         }
[17:43:34.681]                         if (!has_future || version < "1.8.0") {
[17:43:34.681]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:34.681]                             "", base::R.version$version.string), 
[17:43:34.681]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:34.681]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:34.681]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:34.681]                               "release", "version")], collapse = " "), 
[17:43:34.681]                             hostname = base::Sys.info()[["nodename"]])
[17:43:34.681]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:34.681]                             info)
[17:43:34.681]                           info <- base::paste(info, collapse = "; ")
[17:43:34.681]                           if (!has_future) {
[17:43:34.681]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:34.681]                               info)
[17:43:34.681]                           }
[17:43:34.681]                           else {
[17:43:34.681]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:34.681]                               info, version)
[17:43:34.681]                           }
[17:43:34.681]                           base::stop(msg)
[17:43:34.681]                         }
[17:43:34.681]                       })
[17:43:34.681]                     }
[17:43:34.681]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:34.681]                     base::options(mc.cores = 1L)
[17:43:34.681]                   }
[17:43:34.681]                   options(future.plan = NULL)
[17:43:34.681]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:34.681]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:34.681]                 }
[17:43:34.681]                 ...future.workdir <- getwd()
[17:43:34.681]             }
[17:43:34.681]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:34.681]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:34.681]         }
[17:43:34.681]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:34.681]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:34.681]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:34.681]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:34.681]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:34.681]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:34.681]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:34.681]             base::names(...future.oldOptions))
[17:43:34.681]     }
[17:43:34.681]     if (FALSE) {
[17:43:34.681]     }
[17:43:34.681]     else {
[17:43:34.681]         if (TRUE) {
[17:43:34.681]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:34.681]                 open = "w")
[17:43:34.681]         }
[17:43:34.681]         else {
[17:43:34.681]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:34.681]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:34.681]         }
[17:43:34.681]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:34.681]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:34.681]             base::sink(type = "output", split = FALSE)
[17:43:34.681]             base::close(...future.stdout)
[17:43:34.681]         }, add = TRUE)
[17:43:34.681]     }
[17:43:34.681]     ...future.frame <- base::sys.nframe()
[17:43:34.681]     ...future.conditions <- base::list()
[17:43:34.681]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:34.681]     if (FALSE) {
[17:43:34.681]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:34.681]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:34.681]     }
[17:43:34.681]     ...future.result <- base::tryCatch({
[17:43:34.681]         base::withCallingHandlers({
[17:43:34.681]             ...future.value <- base::withVisible(base::local({
[17:43:34.681]                 withCallingHandlers({
[17:43:34.681]                   2
[17:43:34.681]                 }, immediateCondition = function(cond) {
[17:43:34.681]                   save_rds <- function (object, pathname, ...) 
[17:43:34.681]                   {
[17:43:34.681]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:34.681]                     if (file_test("-f", pathname_tmp)) {
[17:43:34.681]                       fi_tmp <- file.info(pathname_tmp)
[17:43:34.681]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:34.681]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:34.681]                         fi_tmp[["mtime"]])
[17:43:34.681]                     }
[17:43:34.681]                     tryCatch({
[17:43:34.681]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:34.681]                     }, error = function(ex) {
[17:43:34.681]                       msg <- conditionMessage(ex)
[17:43:34.681]                       fi_tmp <- file.info(pathname_tmp)
[17:43:34.681]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:34.681]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:34.681]                         fi_tmp[["mtime"]], msg)
[17:43:34.681]                       ex$message <- msg
[17:43:34.681]                       stop(ex)
[17:43:34.681]                     })
[17:43:34.681]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:34.681]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:34.681]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:34.681]                       fi_tmp <- file.info(pathname_tmp)
[17:43:34.681]                       fi <- file.info(pathname)
[17:43:34.681]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:34.681]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:34.681]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:34.681]                         fi[["size"]], fi[["mtime"]])
[17:43:34.681]                       stop(msg)
[17:43:34.681]                     }
[17:43:34.681]                     invisible(pathname)
[17:43:34.681]                   }
[17:43:34.681]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:34.681]                     rootPath = tempdir()) 
[17:43:34.681]                   {
[17:43:34.681]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:34.681]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:34.681]                       tmpdir = path, fileext = ".rds")
[17:43:34.681]                     save_rds(obj, file)
[17:43:34.681]                   }
[17:43:34.681]                   saveImmediateCondition(cond, path = "/tmp/RtmpLaOb2h/.future/immediateConditions")
[17:43:34.681]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:34.681]                   {
[17:43:34.681]                     inherits <- base::inherits
[17:43:34.681]                     invokeRestart <- base::invokeRestart
[17:43:34.681]                     is.null <- base::is.null
[17:43:34.681]                     muffled <- FALSE
[17:43:34.681]                     if (inherits(cond, "message")) {
[17:43:34.681]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:34.681]                       if (muffled) 
[17:43:34.681]                         invokeRestart("muffleMessage")
[17:43:34.681]                     }
[17:43:34.681]                     else if (inherits(cond, "warning")) {
[17:43:34.681]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:34.681]                       if (muffled) 
[17:43:34.681]                         invokeRestart("muffleWarning")
[17:43:34.681]                     }
[17:43:34.681]                     else if (inherits(cond, "condition")) {
[17:43:34.681]                       if (!is.null(pattern)) {
[17:43:34.681]                         computeRestarts <- base::computeRestarts
[17:43:34.681]                         grepl <- base::grepl
[17:43:34.681]                         restarts <- computeRestarts(cond)
[17:43:34.681]                         for (restart in restarts) {
[17:43:34.681]                           name <- restart$name
[17:43:34.681]                           if (is.null(name)) 
[17:43:34.681]                             next
[17:43:34.681]                           if (!grepl(pattern, name)) 
[17:43:34.681]                             next
[17:43:34.681]                           invokeRestart(restart)
[17:43:34.681]                           muffled <- TRUE
[17:43:34.681]                           break
[17:43:34.681]                         }
[17:43:34.681]                       }
[17:43:34.681]                     }
[17:43:34.681]                     invisible(muffled)
[17:43:34.681]                   }
[17:43:34.681]                   muffleCondition(cond)
[17:43:34.681]                 })
[17:43:34.681]             }))
[17:43:34.681]             future::FutureResult(value = ...future.value$value, 
[17:43:34.681]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:34.681]                   ...future.rng), globalenv = if (FALSE) 
[17:43:34.681]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:34.681]                     ...future.globalenv.names))
[17:43:34.681]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:34.681]         }, condition = base::local({
[17:43:34.681]             c <- base::c
[17:43:34.681]             inherits <- base::inherits
[17:43:34.681]             invokeRestart <- base::invokeRestart
[17:43:34.681]             length <- base::length
[17:43:34.681]             list <- base::list
[17:43:34.681]             seq.int <- base::seq.int
[17:43:34.681]             signalCondition <- base::signalCondition
[17:43:34.681]             sys.calls <- base::sys.calls
[17:43:34.681]             `[[` <- base::`[[`
[17:43:34.681]             `+` <- base::`+`
[17:43:34.681]             `<<-` <- base::`<<-`
[17:43:34.681]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:34.681]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:34.681]                   3L)]
[17:43:34.681]             }
[17:43:34.681]             function(cond) {
[17:43:34.681]                 is_error <- inherits(cond, "error")
[17:43:34.681]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:34.681]                   NULL)
[17:43:34.681]                 if (is_error) {
[17:43:34.681]                   sessionInformation <- function() {
[17:43:34.681]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:34.681]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:34.681]                       search = base::search(), system = base::Sys.info())
[17:43:34.681]                   }
[17:43:34.681]                   ...future.conditions[[length(...future.conditions) + 
[17:43:34.681]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:34.681]                     cond$call), session = sessionInformation(), 
[17:43:34.681]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:34.681]                   signalCondition(cond)
[17:43:34.681]                 }
[17:43:34.681]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:34.681]                 "immediateCondition"))) {
[17:43:34.681]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:34.681]                   ...future.conditions[[length(...future.conditions) + 
[17:43:34.681]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:34.681]                   if (TRUE && !signal) {
[17:43:34.681]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:34.681]                     {
[17:43:34.681]                       inherits <- base::inherits
[17:43:34.681]                       invokeRestart <- base::invokeRestart
[17:43:34.681]                       is.null <- base::is.null
[17:43:34.681]                       muffled <- FALSE
[17:43:34.681]                       if (inherits(cond, "message")) {
[17:43:34.681]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:34.681]                         if (muffled) 
[17:43:34.681]                           invokeRestart("muffleMessage")
[17:43:34.681]                       }
[17:43:34.681]                       else if (inherits(cond, "warning")) {
[17:43:34.681]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:34.681]                         if (muffled) 
[17:43:34.681]                           invokeRestart("muffleWarning")
[17:43:34.681]                       }
[17:43:34.681]                       else if (inherits(cond, "condition")) {
[17:43:34.681]                         if (!is.null(pattern)) {
[17:43:34.681]                           computeRestarts <- base::computeRestarts
[17:43:34.681]                           grepl <- base::grepl
[17:43:34.681]                           restarts <- computeRestarts(cond)
[17:43:34.681]                           for (restart in restarts) {
[17:43:34.681]                             name <- restart$name
[17:43:34.681]                             if (is.null(name)) 
[17:43:34.681]                               next
[17:43:34.681]                             if (!grepl(pattern, name)) 
[17:43:34.681]                               next
[17:43:34.681]                             invokeRestart(restart)
[17:43:34.681]                             muffled <- TRUE
[17:43:34.681]                             break
[17:43:34.681]                           }
[17:43:34.681]                         }
[17:43:34.681]                       }
[17:43:34.681]                       invisible(muffled)
[17:43:34.681]                     }
[17:43:34.681]                     muffleCondition(cond, pattern = "^muffle")
[17:43:34.681]                   }
[17:43:34.681]                 }
[17:43:34.681]                 else {
[17:43:34.681]                   if (TRUE) {
[17:43:34.681]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:34.681]                     {
[17:43:34.681]                       inherits <- base::inherits
[17:43:34.681]                       invokeRestart <- base::invokeRestart
[17:43:34.681]                       is.null <- base::is.null
[17:43:34.681]                       muffled <- FALSE
[17:43:34.681]                       if (inherits(cond, "message")) {
[17:43:34.681]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:34.681]                         if (muffled) 
[17:43:34.681]                           invokeRestart("muffleMessage")
[17:43:34.681]                       }
[17:43:34.681]                       else if (inherits(cond, "warning")) {
[17:43:34.681]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:34.681]                         if (muffled) 
[17:43:34.681]                           invokeRestart("muffleWarning")
[17:43:34.681]                       }
[17:43:34.681]                       else if (inherits(cond, "condition")) {
[17:43:34.681]                         if (!is.null(pattern)) {
[17:43:34.681]                           computeRestarts <- base::computeRestarts
[17:43:34.681]                           grepl <- base::grepl
[17:43:34.681]                           restarts <- computeRestarts(cond)
[17:43:34.681]                           for (restart in restarts) {
[17:43:34.681]                             name <- restart$name
[17:43:34.681]                             if (is.null(name)) 
[17:43:34.681]                               next
[17:43:34.681]                             if (!grepl(pattern, name)) 
[17:43:34.681]                               next
[17:43:34.681]                             invokeRestart(restart)
[17:43:34.681]                             muffled <- TRUE
[17:43:34.681]                             break
[17:43:34.681]                           }
[17:43:34.681]                         }
[17:43:34.681]                       }
[17:43:34.681]                       invisible(muffled)
[17:43:34.681]                     }
[17:43:34.681]                     muffleCondition(cond, pattern = "^muffle")
[17:43:34.681]                   }
[17:43:34.681]                 }
[17:43:34.681]             }
[17:43:34.681]         }))
[17:43:34.681]     }, error = function(ex) {
[17:43:34.681]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:34.681]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:34.681]                 ...future.rng), started = ...future.startTime, 
[17:43:34.681]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:34.681]             version = "1.8"), class = "FutureResult")
[17:43:34.681]     }, finally = {
[17:43:34.681]         if (!identical(...future.workdir, getwd())) 
[17:43:34.681]             setwd(...future.workdir)
[17:43:34.681]         {
[17:43:34.681]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:34.681]                 ...future.oldOptions$nwarnings <- NULL
[17:43:34.681]             }
[17:43:34.681]             base::options(...future.oldOptions)
[17:43:34.681]             if (.Platform$OS.type == "windows") {
[17:43:34.681]                 old_names <- names(...future.oldEnvVars)
[17:43:34.681]                 envs <- base::Sys.getenv()
[17:43:34.681]                 names <- names(envs)
[17:43:34.681]                 common <- intersect(names, old_names)
[17:43:34.681]                 added <- setdiff(names, old_names)
[17:43:34.681]                 removed <- setdiff(old_names, names)
[17:43:34.681]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:34.681]                   envs[common]]
[17:43:34.681]                 NAMES <- toupper(changed)
[17:43:34.681]                 args <- list()
[17:43:34.681]                 for (kk in seq_along(NAMES)) {
[17:43:34.681]                   name <- changed[[kk]]
[17:43:34.681]                   NAME <- NAMES[[kk]]
[17:43:34.681]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.681]                     next
[17:43:34.681]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:34.681]                 }
[17:43:34.681]                 NAMES <- toupper(added)
[17:43:34.681]                 for (kk in seq_along(NAMES)) {
[17:43:34.681]                   name <- added[[kk]]
[17:43:34.681]                   NAME <- NAMES[[kk]]
[17:43:34.681]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.681]                     next
[17:43:34.681]                   args[[name]] <- ""
[17:43:34.681]                 }
[17:43:34.681]                 NAMES <- toupper(removed)
[17:43:34.681]                 for (kk in seq_along(NAMES)) {
[17:43:34.681]                   name <- removed[[kk]]
[17:43:34.681]                   NAME <- NAMES[[kk]]
[17:43:34.681]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.681]                     next
[17:43:34.681]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:34.681]                 }
[17:43:34.681]                 if (length(args) > 0) 
[17:43:34.681]                   base::do.call(base::Sys.setenv, args = args)
[17:43:34.681]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:34.681]             }
[17:43:34.681]             else {
[17:43:34.681]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:34.681]             }
[17:43:34.681]             {
[17:43:34.681]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:34.681]                   0L) {
[17:43:34.681]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:34.681]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:34.681]                   base::options(opts)
[17:43:34.681]                 }
[17:43:34.681]                 {
[17:43:34.681]                   {
[17:43:34.681]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:34.681]                     NULL
[17:43:34.681]                   }
[17:43:34.681]                   options(future.plan = NULL)
[17:43:34.681]                   if (is.na(NA_character_)) 
[17:43:34.681]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:34.681]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:34.681]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:43:34.681]                     envir = parent.frame()) 
[17:43:34.681]                   {
[17:43:34.681]                     default_workers <- missing(workers)
[17:43:34.681]                     if (is.function(workers)) 
[17:43:34.681]                       workers <- workers()
[17:43:34.681]                     workers <- structure(as.integer(workers), 
[17:43:34.681]                       class = class(workers))
[17:43:34.681]                     stop_if_not(is.finite(workers), workers >= 
[17:43:34.681]                       1L)
[17:43:34.681]                     if ((workers == 1L && !inherits(workers, 
[17:43:34.681]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:34.681]                       if (default_workers) 
[17:43:34.681]                         supportsMulticore(warn = TRUE)
[17:43:34.681]                       return(sequential(..., envir = envir))
[17:43:34.681]                     }
[17:43:34.681]                     oopts <- options(mc.cores = workers)
[17:43:34.681]                     on.exit(options(oopts))
[17:43:34.681]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:34.681]                       envir = envir)
[17:43:34.681]                     if (!future$lazy) 
[17:43:34.681]                       future <- run(future)
[17:43:34.681]                     invisible(future)
[17:43:34.681]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:34.681]                 }
[17:43:34.681]             }
[17:43:34.681]         }
[17:43:34.681]     })
[17:43:34.681]     if (TRUE) {
[17:43:34.681]         base::sink(type = "output", split = FALSE)
[17:43:34.681]         if (TRUE) {
[17:43:34.681]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:34.681]         }
[17:43:34.681]         else {
[17:43:34.681]             ...future.result["stdout"] <- base::list(NULL)
[17:43:34.681]         }
[17:43:34.681]         base::close(...future.stdout)
[17:43:34.681]         ...future.stdout <- NULL
[17:43:34.681]     }
[17:43:34.681]     ...future.result$conditions <- ...future.conditions
[17:43:34.681]     ...future.result$finished <- base::Sys.time()
[17:43:34.681]     ...future.result
[17:43:34.681] }
[17:43:34.685] requestCore(): workers = 2
[17:43:34.692] MulticoreFuture started
[17:43:34.692] - Launch lazy future ... done
[17:43:34.692] run() for ‘MulticoreFuture’ ... done
[17:43:34.693] resolve() on list ...
[17:43:34.693] plan(): Setting new future strategy stack:
[17:43:34.693]  recursive: 0
[17:43:34.693]  length: 3
[17:43:34.694]  elements: ‘a’, ‘b’, ‘’
[17:43:34.693] List of future strategies:
[17:43:34.693] 1. sequential:
[17:43:34.693]    - args: function (..., envir = parent.frame())
[17:43:34.693]    - tweaked: FALSE
[17:43:34.693]    - call: NULL
[17:43:34.694] plan(): nbrOfWorkers() = 1
[17:43:34.696] Future #1
[17:43:34.696]  length: 2 (resolved future 1)
[17:43:34.696] plan(): Setting new future strategy stack:
[17:43:34.696] List of future strategies:
[17:43:34.696] 1. multicore:
[17:43:34.696]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:34.696]    - tweaked: FALSE
[17:43:34.696]    - call: plan(strategy)
[17:43:34.703] plan(): nbrOfWorkers() = 2
[17:43:34.703] Future #2
[17:43:34.704]  length: 1 (resolved future 2)
[17:43:34.704]  length: 0 (resolved future 3)
[17:43:34.704] resolve() on list ... DONE
[17:43:34.705] getGlobalsAndPackages() ...
[17:43:34.705] Searching for globals...
[17:43:34.706] 
[17:43:34.706] Searching for globals ... DONE
[17:43:34.706] - globals: [0] <none>
[17:43:34.706] getGlobalsAndPackages() ... DONE
[17:43:34.707] getGlobalsAndPackages() ...
[17:43:34.707] Searching for globals...
[17:43:34.708] 
[17:43:34.708] Searching for globals ... DONE
[17:43:34.708] - globals: [0] <none>
[17:43:34.708] getGlobalsAndPackages() ... DONE
[17:43:34.708] run() for ‘Future’ ...
[17:43:34.708] - state: ‘created’
[17:43:34.709] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:34.714] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:34.714] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:34.714]   - Field: ‘label’
[17:43:34.714]   - Field: ‘local’
[17:43:34.714]   - Field: ‘owner’
[17:43:34.714]   - Field: ‘envir’
[17:43:34.715]   - Field: ‘workers’
[17:43:34.715]   - Field: ‘packages’
[17:43:34.715]   - Field: ‘gc’
[17:43:34.715]   - Field: ‘job’
[17:43:34.715]   - Field: ‘conditions’
[17:43:34.715]   - Field: ‘expr’
[17:43:34.716]   - Field: ‘uuid’
[17:43:34.716]   - Field: ‘seed’
[17:43:34.716]   - Field: ‘version’
[17:43:34.716]   - Field: ‘result’
[17:43:34.716]   - Field: ‘asynchronous’
[17:43:34.716]   - Field: ‘calls’
[17:43:34.716]   - Field: ‘globals’
[17:43:34.717]   - Field: ‘stdout’
[17:43:34.717]   - Field: ‘earlySignal’
[17:43:34.717]   - Field: ‘lazy’
[17:43:34.717]   - Field: ‘state’
[17:43:34.717] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:34.717] - Launch lazy future ...
[17:43:34.718] Packages needed by the future expression (n = 0): <none>
[17:43:34.718] Packages needed by future strategies (n = 0): <none>
[17:43:34.719] {
[17:43:34.719]     {
[17:43:34.719]         {
[17:43:34.719]             ...future.startTime <- base::Sys.time()
[17:43:34.719]             {
[17:43:34.719]                 {
[17:43:34.719]                   {
[17:43:34.719]                     {
[17:43:34.719]                       base::local({
[17:43:34.719]                         has_future <- base::requireNamespace("future", 
[17:43:34.719]                           quietly = TRUE)
[17:43:34.719]                         if (has_future) {
[17:43:34.719]                           ns <- base::getNamespace("future")
[17:43:34.719]                           version <- ns[[".package"]][["version"]]
[17:43:34.719]                           if (is.null(version)) 
[17:43:34.719]                             version <- utils::packageVersion("future")
[17:43:34.719]                         }
[17:43:34.719]                         else {
[17:43:34.719]                           version <- NULL
[17:43:34.719]                         }
[17:43:34.719]                         if (!has_future || version < "1.8.0") {
[17:43:34.719]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:34.719]                             "", base::R.version$version.string), 
[17:43:34.719]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:34.719]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:34.719]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:34.719]                               "release", "version")], collapse = " "), 
[17:43:34.719]                             hostname = base::Sys.info()[["nodename"]])
[17:43:34.719]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:34.719]                             info)
[17:43:34.719]                           info <- base::paste(info, collapse = "; ")
[17:43:34.719]                           if (!has_future) {
[17:43:34.719]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:34.719]                               info)
[17:43:34.719]                           }
[17:43:34.719]                           else {
[17:43:34.719]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:34.719]                               info, version)
[17:43:34.719]                           }
[17:43:34.719]                           base::stop(msg)
[17:43:34.719]                         }
[17:43:34.719]                       })
[17:43:34.719]                     }
[17:43:34.719]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:34.719]                     base::options(mc.cores = 1L)
[17:43:34.719]                   }
[17:43:34.719]                   options(future.plan = NULL)
[17:43:34.719]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:34.719]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:34.719]                 }
[17:43:34.719]                 ...future.workdir <- getwd()
[17:43:34.719]             }
[17:43:34.719]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:34.719]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:34.719]         }
[17:43:34.719]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:34.719]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:34.719]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:34.719]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:34.719]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:34.719]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:34.719]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:34.719]             base::names(...future.oldOptions))
[17:43:34.719]     }
[17:43:34.719]     if (FALSE) {
[17:43:34.719]     }
[17:43:34.719]     else {
[17:43:34.719]         if (TRUE) {
[17:43:34.719]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:34.719]                 open = "w")
[17:43:34.719]         }
[17:43:34.719]         else {
[17:43:34.719]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:34.719]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:34.719]         }
[17:43:34.719]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:34.719]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:34.719]             base::sink(type = "output", split = FALSE)
[17:43:34.719]             base::close(...future.stdout)
[17:43:34.719]         }, add = TRUE)
[17:43:34.719]     }
[17:43:34.719]     ...future.frame <- base::sys.nframe()
[17:43:34.719]     ...future.conditions <- base::list()
[17:43:34.719]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:34.719]     if (FALSE) {
[17:43:34.719]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:34.719]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:34.719]     }
[17:43:34.719]     ...future.result <- base::tryCatch({
[17:43:34.719]         base::withCallingHandlers({
[17:43:34.719]             ...future.value <- base::withVisible(base::local({
[17:43:34.719]                 withCallingHandlers({
[17:43:34.719]                   2
[17:43:34.719]                 }, immediateCondition = function(cond) {
[17:43:34.719]                   save_rds <- function (object, pathname, ...) 
[17:43:34.719]                   {
[17:43:34.719]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:34.719]                     if (file_test("-f", pathname_tmp)) {
[17:43:34.719]                       fi_tmp <- file.info(pathname_tmp)
[17:43:34.719]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:34.719]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:34.719]                         fi_tmp[["mtime"]])
[17:43:34.719]                     }
[17:43:34.719]                     tryCatch({
[17:43:34.719]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:34.719]                     }, error = function(ex) {
[17:43:34.719]                       msg <- conditionMessage(ex)
[17:43:34.719]                       fi_tmp <- file.info(pathname_tmp)
[17:43:34.719]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:34.719]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:34.719]                         fi_tmp[["mtime"]], msg)
[17:43:34.719]                       ex$message <- msg
[17:43:34.719]                       stop(ex)
[17:43:34.719]                     })
[17:43:34.719]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:34.719]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:34.719]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:34.719]                       fi_tmp <- file.info(pathname_tmp)
[17:43:34.719]                       fi <- file.info(pathname)
[17:43:34.719]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:34.719]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:34.719]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:34.719]                         fi[["size"]], fi[["mtime"]])
[17:43:34.719]                       stop(msg)
[17:43:34.719]                     }
[17:43:34.719]                     invisible(pathname)
[17:43:34.719]                   }
[17:43:34.719]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:34.719]                     rootPath = tempdir()) 
[17:43:34.719]                   {
[17:43:34.719]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:34.719]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:34.719]                       tmpdir = path, fileext = ".rds")
[17:43:34.719]                     save_rds(obj, file)
[17:43:34.719]                   }
[17:43:34.719]                   saveImmediateCondition(cond, path = "/tmp/RtmpLaOb2h/.future/immediateConditions")
[17:43:34.719]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:34.719]                   {
[17:43:34.719]                     inherits <- base::inherits
[17:43:34.719]                     invokeRestart <- base::invokeRestart
[17:43:34.719]                     is.null <- base::is.null
[17:43:34.719]                     muffled <- FALSE
[17:43:34.719]                     if (inherits(cond, "message")) {
[17:43:34.719]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:34.719]                       if (muffled) 
[17:43:34.719]                         invokeRestart("muffleMessage")
[17:43:34.719]                     }
[17:43:34.719]                     else if (inherits(cond, "warning")) {
[17:43:34.719]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:34.719]                       if (muffled) 
[17:43:34.719]                         invokeRestart("muffleWarning")
[17:43:34.719]                     }
[17:43:34.719]                     else if (inherits(cond, "condition")) {
[17:43:34.719]                       if (!is.null(pattern)) {
[17:43:34.719]                         computeRestarts <- base::computeRestarts
[17:43:34.719]                         grepl <- base::grepl
[17:43:34.719]                         restarts <- computeRestarts(cond)
[17:43:34.719]                         for (restart in restarts) {
[17:43:34.719]                           name <- restart$name
[17:43:34.719]                           if (is.null(name)) 
[17:43:34.719]                             next
[17:43:34.719]                           if (!grepl(pattern, name)) 
[17:43:34.719]                             next
[17:43:34.719]                           invokeRestart(restart)
[17:43:34.719]                           muffled <- TRUE
[17:43:34.719]                           break
[17:43:34.719]                         }
[17:43:34.719]                       }
[17:43:34.719]                     }
[17:43:34.719]                     invisible(muffled)
[17:43:34.719]                   }
[17:43:34.719]                   muffleCondition(cond)
[17:43:34.719]                 })
[17:43:34.719]             }))
[17:43:34.719]             future::FutureResult(value = ...future.value$value, 
[17:43:34.719]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:34.719]                   ...future.rng), globalenv = if (FALSE) 
[17:43:34.719]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:34.719]                     ...future.globalenv.names))
[17:43:34.719]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:34.719]         }, condition = base::local({
[17:43:34.719]             c <- base::c
[17:43:34.719]             inherits <- base::inherits
[17:43:34.719]             invokeRestart <- base::invokeRestart
[17:43:34.719]             length <- base::length
[17:43:34.719]             list <- base::list
[17:43:34.719]             seq.int <- base::seq.int
[17:43:34.719]             signalCondition <- base::signalCondition
[17:43:34.719]             sys.calls <- base::sys.calls
[17:43:34.719]             `[[` <- base::`[[`
[17:43:34.719]             `+` <- base::`+`
[17:43:34.719]             `<<-` <- base::`<<-`
[17:43:34.719]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:34.719]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:34.719]                   3L)]
[17:43:34.719]             }
[17:43:34.719]             function(cond) {
[17:43:34.719]                 is_error <- inherits(cond, "error")
[17:43:34.719]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:34.719]                   NULL)
[17:43:34.719]                 if (is_error) {
[17:43:34.719]                   sessionInformation <- function() {
[17:43:34.719]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:34.719]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:34.719]                       search = base::search(), system = base::Sys.info())
[17:43:34.719]                   }
[17:43:34.719]                   ...future.conditions[[length(...future.conditions) + 
[17:43:34.719]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:34.719]                     cond$call), session = sessionInformation(), 
[17:43:34.719]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:34.719]                   signalCondition(cond)
[17:43:34.719]                 }
[17:43:34.719]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:34.719]                 "immediateCondition"))) {
[17:43:34.719]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:34.719]                   ...future.conditions[[length(...future.conditions) + 
[17:43:34.719]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:34.719]                   if (TRUE && !signal) {
[17:43:34.719]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:34.719]                     {
[17:43:34.719]                       inherits <- base::inherits
[17:43:34.719]                       invokeRestart <- base::invokeRestart
[17:43:34.719]                       is.null <- base::is.null
[17:43:34.719]                       muffled <- FALSE
[17:43:34.719]                       if (inherits(cond, "message")) {
[17:43:34.719]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:34.719]                         if (muffled) 
[17:43:34.719]                           invokeRestart("muffleMessage")
[17:43:34.719]                       }
[17:43:34.719]                       else if (inherits(cond, "warning")) {
[17:43:34.719]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:34.719]                         if (muffled) 
[17:43:34.719]                           invokeRestart("muffleWarning")
[17:43:34.719]                       }
[17:43:34.719]                       else if (inherits(cond, "condition")) {
[17:43:34.719]                         if (!is.null(pattern)) {
[17:43:34.719]                           computeRestarts <- base::computeRestarts
[17:43:34.719]                           grepl <- base::grepl
[17:43:34.719]                           restarts <- computeRestarts(cond)
[17:43:34.719]                           for (restart in restarts) {
[17:43:34.719]                             name <- restart$name
[17:43:34.719]                             if (is.null(name)) 
[17:43:34.719]                               next
[17:43:34.719]                             if (!grepl(pattern, name)) 
[17:43:34.719]                               next
[17:43:34.719]                             invokeRestart(restart)
[17:43:34.719]                             muffled <- TRUE
[17:43:34.719]                             break
[17:43:34.719]                           }
[17:43:34.719]                         }
[17:43:34.719]                       }
[17:43:34.719]                       invisible(muffled)
[17:43:34.719]                     }
[17:43:34.719]                     muffleCondition(cond, pattern = "^muffle")
[17:43:34.719]                   }
[17:43:34.719]                 }
[17:43:34.719]                 else {
[17:43:34.719]                   if (TRUE) {
[17:43:34.719]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:34.719]                     {
[17:43:34.719]                       inherits <- base::inherits
[17:43:34.719]                       invokeRestart <- base::invokeRestart
[17:43:34.719]                       is.null <- base::is.null
[17:43:34.719]                       muffled <- FALSE
[17:43:34.719]                       if (inherits(cond, "message")) {
[17:43:34.719]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:34.719]                         if (muffled) 
[17:43:34.719]                           invokeRestart("muffleMessage")
[17:43:34.719]                       }
[17:43:34.719]                       else if (inherits(cond, "warning")) {
[17:43:34.719]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:34.719]                         if (muffled) 
[17:43:34.719]                           invokeRestart("muffleWarning")
[17:43:34.719]                       }
[17:43:34.719]                       else if (inherits(cond, "condition")) {
[17:43:34.719]                         if (!is.null(pattern)) {
[17:43:34.719]                           computeRestarts <- base::computeRestarts
[17:43:34.719]                           grepl <- base::grepl
[17:43:34.719]                           restarts <- computeRestarts(cond)
[17:43:34.719]                           for (restart in restarts) {
[17:43:34.719]                             name <- restart$name
[17:43:34.719]                             if (is.null(name)) 
[17:43:34.719]                               next
[17:43:34.719]                             if (!grepl(pattern, name)) 
[17:43:34.719]                               next
[17:43:34.719]                             invokeRestart(restart)
[17:43:34.719]                             muffled <- TRUE
[17:43:34.719]                             break
[17:43:34.719]                           }
[17:43:34.719]                         }
[17:43:34.719]                       }
[17:43:34.719]                       invisible(muffled)
[17:43:34.719]                     }
[17:43:34.719]                     muffleCondition(cond, pattern = "^muffle")
[17:43:34.719]                   }
[17:43:34.719]                 }
[17:43:34.719]             }
[17:43:34.719]         }))
[17:43:34.719]     }, error = function(ex) {
[17:43:34.719]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:34.719]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:34.719]                 ...future.rng), started = ...future.startTime, 
[17:43:34.719]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:34.719]             version = "1.8"), class = "FutureResult")
[17:43:34.719]     }, finally = {
[17:43:34.719]         if (!identical(...future.workdir, getwd())) 
[17:43:34.719]             setwd(...future.workdir)
[17:43:34.719]         {
[17:43:34.719]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:34.719]                 ...future.oldOptions$nwarnings <- NULL
[17:43:34.719]             }
[17:43:34.719]             base::options(...future.oldOptions)
[17:43:34.719]             if (.Platform$OS.type == "windows") {
[17:43:34.719]                 old_names <- names(...future.oldEnvVars)
[17:43:34.719]                 envs <- base::Sys.getenv()
[17:43:34.719]                 names <- names(envs)
[17:43:34.719]                 common <- intersect(names, old_names)
[17:43:34.719]                 added <- setdiff(names, old_names)
[17:43:34.719]                 removed <- setdiff(old_names, names)
[17:43:34.719]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:34.719]                   envs[common]]
[17:43:34.719]                 NAMES <- toupper(changed)
[17:43:34.719]                 args <- list()
[17:43:34.719]                 for (kk in seq_along(NAMES)) {
[17:43:34.719]                   name <- changed[[kk]]
[17:43:34.719]                   NAME <- NAMES[[kk]]
[17:43:34.719]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.719]                     next
[17:43:34.719]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:34.719]                 }
[17:43:34.719]                 NAMES <- toupper(added)
[17:43:34.719]                 for (kk in seq_along(NAMES)) {
[17:43:34.719]                   name <- added[[kk]]
[17:43:34.719]                   NAME <- NAMES[[kk]]
[17:43:34.719]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.719]                     next
[17:43:34.719]                   args[[name]] <- ""
[17:43:34.719]                 }
[17:43:34.719]                 NAMES <- toupper(removed)
[17:43:34.719]                 for (kk in seq_along(NAMES)) {
[17:43:34.719]                   name <- removed[[kk]]
[17:43:34.719]                   NAME <- NAMES[[kk]]
[17:43:34.719]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.719]                     next
[17:43:34.719]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:34.719]                 }
[17:43:34.719]                 if (length(args) > 0) 
[17:43:34.719]                   base::do.call(base::Sys.setenv, args = args)
[17:43:34.719]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:34.719]             }
[17:43:34.719]             else {
[17:43:34.719]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:34.719]             }
[17:43:34.719]             {
[17:43:34.719]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:34.719]                   0L) {
[17:43:34.719]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:34.719]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:34.719]                   base::options(opts)
[17:43:34.719]                 }
[17:43:34.719]                 {
[17:43:34.719]                   {
[17:43:34.719]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:34.719]                     NULL
[17:43:34.719]                   }
[17:43:34.719]                   options(future.plan = NULL)
[17:43:34.719]                   if (is.na(NA_character_)) 
[17:43:34.719]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:34.719]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:34.719]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:43:34.719]                     envir = parent.frame()) 
[17:43:34.719]                   {
[17:43:34.719]                     default_workers <- missing(workers)
[17:43:34.719]                     if (is.function(workers)) 
[17:43:34.719]                       workers <- workers()
[17:43:34.719]                     workers <- structure(as.integer(workers), 
[17:43:34.719]                       class = class(workers))
[17:43:34.719]                     stop_if_not(is.finite(workers), workers >= 
[17:43:34.719]                       1L)
[17:43:34.719]                     if ((workers == 1L && !inherits(workers, 
[17:43:34.719]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:34.719]                       if (default_workers) 
[17:43:34.719]                         supportsMulticore(warn = TRUE)
[17:43:34.719]                       return(sequential(..., envir = envir))
[17:43:34.719]                     }
[17:43:34.719]                     oopts <- options(mc.cores = workers)
[17:43:34.719]                     on.exit(options(oopts))
[17:43:34.719]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:34.719]                       envir = envir)
[17:43:34.719]                     if (!future$lazy) 
[17:43:34.719]                       future <- run(future)
[17:43:34.719]                     invisible(future)
[17:43:34.719]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:34.719]                 }
[17:43:34.719]             }
[17:43:34.719]         }
[17:43:34.719]     })
[17:43:34.719]     if (TRUE) {
[17:43:34.719]         base::sink(type = "output", split = FALSE)
[17:43:34.719]         if (TRUE) {
[17:43:34.719]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:34.719]         }
[17:43:34.719]         else {
[17:43:34.719]             ...future.result["stdout"] <- base::list(NULL)
[17:43:34.719]         }
[17:43:34.719]         base::close(...future.stdout)
[17:43:34.719]         ...future.stdout <- NULL
[17:43:34.719]     }
[17:43:34.719]     ...future.result$conditions <- ...future.conditions
[17:43:34.719]     ...future.result$finished <- base::Sys.time()
[17:43:34.719]     ...future.result
[17:43:34.719] }
[17:43:34.722] requestCore(): workers = 2
[17:43:34.723] Poll #1 (0): usedCores() = 2, workers = 2
[17:43:34.739] MulticoreFuture started
[17:43:34.739] - Launch lazy future ... done
[17:43:34.739] run() for ‘MulticoreFuture’ ... done
[17:43:34.740] resolve() on list ...
[17:43:34.740]  recursive: 0
[17:43:34.740] plan(): Setting new future strategy stack:
[17:43:34.740]  length: 3
[17:43:34.740]  elements: ‘a’, ‘b’, ‘’
[17:43:34.741] run() for ‘Future’ ...
[17:43:34.741] - state: ‘created’
[17:43:34.740] List of future strategies:
[17:43:34.740] 1. sequential:
[17:43:34.740]    - args: function (..., envir = parent.frame())
[17:43:34.740]    - tweaked: FALSE
[17:43:34.740]    - call: NULL
[17:43:34.741] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:34.742] plan(): nbrOfWorkers() = 1
[17:43:34.744] plan(): Setting new future strategy stack:
[17:43:34.744] List of future strategies:
[17:43:34.744] 1. multicore:
[17:43:34.744]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:34.744]    - tweaked: FALSE
[17:43:34.744]    - call: plan(strategy)
[17:43:34.748] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:34.748] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:34.748]   - Field: ‘label’
[17:43:34.749]   - Field: ‘local’
[17:43:34.749]   - Field: ‘owner’
[17:43:34.749]   - Field: ‘envir’
[17:43:34.749]   - Field: ‘workers’
[17:43:34.750]   - Field: ‘packages’
[17:43:34.750]   - Field: ‘gc’
[17:43:34.750] plan(): nbrOfWorkers() = 2
[17:43:34.750]   - Field: ‘job’
[17:43:34.750]   - Field: ‘conditions’
[17:43:34.750]   - Field: ‘expr’
[17:43:34.751]   - Field: ‘uuid’
[17:43:34.751]   - Field: ‘seed’
[17:43:34.751]   - Field: ‘version’
[17:43:34.751]   - Field: ‘result’
[17:43:34.751]   - Field: ‘asynchronous’
[17:43:34.751]   - Field: ‘calls’
[17:43:34.752]   - Field: ‘globals’
[17:43:34.752]   - Field: ‘stdout’
[17:43:34.752]   - Field: ‘earlySignal’
[17:43:34.752]   - Field: ‘lazy’
[17:43:34.752]   - Field: ‘state’
[17:43:34.752] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:34.753] - Launch lazy future ...
[17:43:34.753] Packages needed by the future expression (n = 0): <none>
[17:43:34.753] Packages needed by future strategies (n = 0): <none>
[17:43:34.754] {
[17:43:34.754]     {
[17:43:34.754]         {
[17:43:34.754]             ...future.startTime <- base::Sys.time()
[17:43:34.754]             {
[17:43:34.754]                 {
[17:43:34.754]                   {
[17:43:34.754]                     {
[17:43:34.754]                       base::local({
[17:43:34.754]                         has_future <- base::requireNamespace("future", 
[17:43:34.754]                           quietly = TRUE)
[17:43:34.754]                         if (has_future) {
[17:43:34.754]                           ns <- base::getNamespace("future")
[17:43:34.754]                           version <- ns[[".package"]][["version"]]
[17:43:34.754]                           if (is.null(version)) 
[17:43:34.754]                             version <- utils::packageVersion("future")
[17:43:34.754]                         }
[17:43:34.754]                         else {
[17:43:34.754]                           version <- NULL
[17:43:34.754]                         }
[17:43:34.754]                         if (!has_future || version < "1.8.0") {
[17:43:34.754]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:34.754]                             "", base::R.version$version.string), 
[17:43:34.754]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:34.754]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:34.754]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:34.754]                               "release", "version")], collapse = " "), 
[17:43:34.754]                             hostname = base::Sys.info()[["nodename"]])
[17:43:34.754]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:34.754]                             info)
[17:43:34.754]                           info <- base::paste(info, collapse = "; ")
[17:43:34.754]                           if (!has_future) {
[17:43:34.754]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:34.754]                               info)
[17:43:34.754]                           }
[17:43:34.754]                           else {
[17:43:34.754]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:34.754]                               info, version)
[17:43:34.754]                           }
[17:43:34.754]                           base::stop(msg)
[17:43:34.754]                         }
[17:43:34.754]                       })
[17:43:34.754]                     }
[17:43:34.754]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:34.754]                     base::options(mc.cores = 1L)
[17:43:34.754]                   }
[17:43:34.754]                   options(future.plan = NULL)
[17:43:34.754]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:34.754]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:34.754]                 }
[17:43:34.754]                 ...future.workdir <- getwd()
[17:43:34.754]             }
[17:43:34.754]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:34.754]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:34.754]         }
[17:43:34.754]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:34.754]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:34.754]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:34.754]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:34.754]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:34.754]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:34.754]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:34.754]             base::names(...future.oldOptions))
[17:43:34.754]     }
[17:43:34.754]     if (FALSE) {
[17:43:34.754]     }
[17:43:34.754]     else {
[17:43:34.754]         if (TRUE) {
[17:43:34.754]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:34.754]                 open = "w")
[17:43:34.754]         }
[17:43:34.754]         else {
[17:43:34.754]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:34.754]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:34.754]         }
[17:43:34.754]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:34.754]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:34.754]             base::sink(type = "output", split = FALSE)
[17:43:34.754]             base::close(...future.stdout)
[17:43:34.754]         }, add = TRUE)
[17:43:34.754]     }
[17:43:34.754]     ...future.frame <- base::sys.nframe()
[17:43:34.754]     ...future.conditions <- base::list()
[17:43:34.754]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:34.754]     if (FALSE) {
[17:43:34.754]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:34.754]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:34.754]     }
[17:43:34.754]     ...future.result <- base::tryCatch({
[17:43:34.754]         base::withCallingHandlers({
[17:43:34.754]             ...future.value <- base::withVisible(base::local({
[17:43:34.754]                 withCallingHandlers({
[17:43:34.754]                   1
[17:43:34.754]                 }, immediateCondition = function(cond) {
[17:43:34.754]                   save_rds <- function (object, pathname, ...) 
[17:43:34.754]                   {
[17:43:34.754]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:34.754]                     if (file_test("-f", pathname_tmp)) {
[17:43:34.754]                       fi_tmp <- file.info(pathname_tmp)
[17:43:34.754]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:34.754]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:34.754]                         fi_tmp[["mtime"]])
[17:43:34.754]                     }
[17:43:34.754]                     tryCatch({
[17:43:34.754]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:34.754]                     }, error = function(ex) {
[17:43:34.754]                       msg <- conditionMessage(ex)
[17:43:34.754]                       fi_tmp <- file.info(pathname_tmp)
[17:43:34.754]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:34.754]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:34.754]                         fi_tmp[["mtime"]], msg)
[17:43:34.754]                       ex$message <- msg
[17:43:34.754]                       stop(ex)
[17:43:34.754]                     })
[17:43:34.754]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:34.754]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:34.754]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:34.754]                       fi_tmp <- file.info(pathname_tmp)
[17:43:34.754]                       fi <- file.info(pathname)
[17:43:34.754]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:34.754]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:34.754]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:34.754]                         fi[["size"]], fi[["mtime"]])
[17:43:34.754]                       stop(msg)
[17:43:34.754]                     }
[17:43:34.754]                     invisible(pathname)
[17:43:34.754]                   }
[17:43:34.754]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:34.754]                     rootPath = tempdir()) 
[17:43:34.754]                   {
[17:43:34.754]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:34.754]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:34.754]                       tmpdir = path, fileext = ".rds")
[17:43:34.754]                     save_rds(obj, file)
[17:43:34.754]                   }
[17:43:34.754]                   saveImmediateCondition(cond, path = "/tmp/RtmpLaOb2h/.future/immediateConditions")
[17:43:34.754]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:34.754]                   {
[17:43:34.754]                     inherits <- base::inherits
[17:43:34.754]                     invokeRestart <- base::invokeRestart
[17:43:34.754]                     is.null <- base::is.null
[17:43:34.754]                     muffled <- FALSE
[17:43:34.754]                     if (inherits(cond, "message")) {
[17:43:34.754]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:34.754]                       if (muffled) 
[17:43:34.754]                         invokeRestart("muffleMessage")
[17:43:34.754]                     }
[17:43:34.754]                     else if (inherits(cond, "warning")) {
[17:43:34.754]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:34.754]                       if (muffled) 
[17:43:34.754]                         invokeRestart("muffleWarning")
[17:43:34.754]                     }
[17:43:34.754]                     else if (inherits(cond, "condition")) {
[17:43:34.754]                       if (!is.null(pattern)) {
[17:43:34.754]                         computeRestarts <- base::computeRestarts
[17:43:34.754]                         grepl <- base::grepl
[17:43:34.754]                         restarts <- computeRestarts(cond)
[17:43:34.754]                         for (restart in restarts) {
[17:43:34.754]                           name <- restart$name
[17:43:34.754]                           if (is.null(name)) 
[17:43:34.754]                             next
[17:43:34.754]                           if (!grepl(pattern, name)) 
[17:43:34.754]                             next
[17:43:34.754]                           invokeRestart(restart)
[17:43:34.754]                           muffled <- TRUE
[17:43:34.754]                           break
[17:43:34.754]                         }
[17:43:34.754]                       }
[17:43:34.754]                     }
[17:43:34.754]                     invisible(muffled)
[17:43:34.754]                   }
[17:43:34.754]                   muffleCondition(cond)
[17:43:34.754]                 })
[17:43:34.754]             }))
[17:43:34.754]             future::FutureResult(value = ...future.value$value, 
[17:43:34.754]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:34.754]                   ...future.rng), globalenv = if (FALSE) 
[17:43:34.754]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:34.754]                     ...future.globalenv.names))
[17:43:34.754]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:34.754]         }, condition = base::local({
[17:43:34.754]             c <- base::c
[17:43:34.754]             inherits <- base::inherits
[17:43:34.754]             invokeRestart <- base::invokeRestart
[17:43:34.754]             length <- base::length
[17:43:34.754]             list <- base::list
[17:43:34.754]             seq.int <- base::seq.int
[17:43:34.754]             signalCondition <- base::signalCondition
[17:43:34.754]             sys.calls <- base::sys.calls
[17:43:34.754]             `[[` <- base::`[[`
[17:43:34.754]             `+` <- base::`+`
[17:43:34.754]             `<<-` <- base::`<<-`
[17:43:34.754]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:34.754]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:34.754]                   3L)]
[17:43:34.754]             }
[17:43:34.754]             function(cond) {
[17:43:34.754]                 is_error <- inherits(cond, "error")
[17:43:34.754]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:34.754]                   NULL)
[17:43:34.754]                 if (is_error) {
[17:43:34.754]                   sessionInformation <- function() {
[17:43:34.754]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:34.754]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:34.754]                       search = base::search(), system = base::Sys.info())
[17:43:34.754]                   }
[17:43:34.754]                   ...future.conditions[[length(...future.conditions) + 
[17:43:34.754]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:34.754]                     cond$call), session = sessionInformation(), 
[17:43:34.754]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:34.754]                   signalCondition(cond)
[17:43:34.754]                 }
[17:43:34.754]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:34.754]                 "immediateCondition"))) {
[17:43:34.754]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:34.754]                   ...future.conditions[[length(...future.conditions) + 
[17:43:34.754]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:34.754]                   if (TRUE && !signal) {
[17:43:34.754]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:34.754]                     {
[17:43:34.754]                       inherits <- base::inherits
[17:43:34.754]                       invokeRestart <- base::invokeRestart
[17:43:34.754]                       is.null <- base::is.null
[17:43:34.754]                       muffled <- FALSE
[17:43:34.754]                       if (inherits(cond, "message")) {
[17:43:34.754]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:34.754]                         if (muffled) 
[17:43:34.754]                           invokeRestart("muffleMessage")
[17:43:34.754]                       }
[17:43:34.754]                       else if (inherits(cond, "warning")) {
[17:43:34.754]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:34.754]                         if (muffled) 
[17:43:34.754]                           invokeRestart("muffleWarning")
[17:43:34.754]                       }
[17:43:34.754]                       else if (inherits(cond, "condition")) {
[17:43:34.754]                         if (!is.null(pattern)) {
[17:43:34.754]                           computeRestarts <- base::computeRestarts
[17:43:34.754]                           grepl <- base::grepl
[17:43:34.754]                           restarts <- computeRestarts(cond)
[17:43:34.754]                           for (restart in restarts) {
[17:43:34.754]                             name <- restart$name
[17:43:34.754]                             if (is.null(name)) 
[17:43:34.754]                               next
[17:43:34.754]                             if (!grepl(pattern, name)) 
[17:43:34.754]                               next
[17:43:34.754]                             invokeRestart(restart)
[17:43:34.754]                             muffled <- TRUE
[17:43:34.754]                             break
[17:43:34.754]                           }
[17:43:34.754]                         }
[17:43:34.754]                       }
[17:43:34.754]                       invisible(muffled)
[17:43:34.754]                     }
[17:43:34.754]                     muffleCondition(cond, pattern = "^muffle")
[17:43:34.754]                   }
[17:43:34.754]                 }
[17:43:34.754]                 else {
[17:43:34.754]                   if (TRUE) {
[17:43:34.754]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:34.754]                     {
[17:43:34.754]                       inherits <- base::inherits
[17:43:34.754]                       invokeRestart <- base::invokeRestart
[17:43:34.754]                       is.null <- base::is.null
[17:43:34.754]                       muffled <- FALSE
[17:43:34.754]                       if (inherits(cond, "message")) {
[17:43:34.754]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:34.754]                         if (muffled) 
[17:43:34.754]                           invokeRestart("muffleMessage")
[17:43:34.754]                       }
[17:43:34.754]                       else if (inherits(cond, "warning")) {
[17:43:34.754]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:34.754]                         if (muffled) 
[17:43:34.754]                           invokeRestart("muffleWarning")
[17:43:34.754]                       }
[17:43:34.754]                       else if (inherits(cond, "condition")) {
[17:43:34.754]                         if (!is.null(pattern)) {
[17:43:34.754]                           computeRestarts <- base::computeRestarts
[17:43:34.754]                           grepl <- base::grepl
[17:43:34.754]                           restarts <- computeRestarts(cond)
[17:43:34.754]                           for (restart in restarts) {
[17:43:34.754]                             name <- restart$name
[17:43:34.754]                             if (is.null(name)) 
[17:43:34.754]                               next
[17:43:34.754]                             if (!grepl(pattern, name)) 
[17:43:34.754]                               next
[17:43:34.754]                             invokeRestart(restart)
[17:43:34.754]                             muffled <- TRUE
[17:43:34.754]                             break
[17:43:34.754]                           }
[17:43:34.754]                         }
[17:43:34.754]                       }
[17:43:34.754]                       invisible(muffled)
[17:43:34.754]                     }
[17:43:34.754]                     muffleCondition(cond, pattern = "^muffle")
[17:43:34.754]                   }
[17:43:34.754]                 }
[17:43:34.754]             }
[17:43:34.754]         }))
[17:43:34.754]     }, error = function(ex) {
[17:43:34.754]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:34.754]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:34.754]                 ...future.rng), started = ...future.startTime, 
[17:43:34.754]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:34.754]             version = "1.8"), class = "FutureResult")
[17:43:34.754]     }, finally = {
[17:43:34.754]         if (!identical(...future.workdir, getwd())) 
[17:43:34.754]             setwd(...future.workdir)
[17:43:34.754]         {
[17:43:34.754]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:34.754]                 ...future.oldOptions$nwarnings <- NULL
[17:43:34.754]             }
[17:43:34.754]             base::options(...future.oldOptions)
[17:43:34.754]             if (.Platform$OS.type == "windows") {
[17:43:34.754]                 old_names <- names(...future.oldEnvVars)
[17:43:34.754]                 envs <- base::Sys.getenv()
[17:43:34.754]                 names <- names(envs)
[17:43:34.754]                 common <- intersect(names, old_names)
[17:43:34.754]                 added <- setdiff(names, old_names)
[17:43:34.754]                 removed <- setdiff(old_names, names)
[17:43:34.754]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:34.754]                   envs[common]]
[17:43:34.754]                 NAMES <- toupper(changed)
[17:43:34.754]                 args <- list()
[17:43:34.754]                 for (kk in seq_along(NAMES)) {
[17:43:34.754]                   name <- changed[[kk]]
[17:43:34.754]                   NAME <- NAMES[[kk]]
[17:43:34.754]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.754]                     next
[17:43:34.754]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:34.754]                 }
[17:43:34.754]                 NAMES <- toupper(added)
[17:43:34.754]                 for (kk in seq_along(NAMES)) {
[17:43:34.754]                   name <- added[[kk]]
[17:43:34.754]                   NAME <- NAMES[[kk]]
[17:43:34.754]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.754]                     next
[17:43:34.754]                   args[[name]] <- ""
[17:43:34.754]                 }
[17:43:34.754]                 NAMES <- toupper(removed)
[17:43:34.754]                 for (kk in seq_along(NAMES)) {
[17:43:34.754]                   name <- removed[[kk]]
[17:43:34.754]                   NAME <- NAMES[[kk]]
[17:43:34.754]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.754]                     next
[17:43:34.754]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:34.754]                 }
[17:43:34.754]                 if (length(args) > 0) 
[17:43:34.754]                   base::do.call(base::Sys.setenv, args = args)
[17:43:34.754]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:34.754]             }
[17:43:34.754]             else {
[17:43:34.754]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:34.754]             }
[17:43:34.754]             {
[17:43:34.754]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:34.754]                   0L) {
[17:43:34.754]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:34.754]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:34.754]                   base::options(opts)
[17:43:34.754]                 }
[17:43:34.754]                 {
[17:43:34.754]                   {
[17:43:34.754]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:34.754]                     NULL
[17:43:34.754]                   }
[17:43:34.754]                   options(future.plan = NULL)
[17:43:34.754]                   if (is.na(NA_character_)) 
[17:43:34.754]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:34.754]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:34.754]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:43:34.754]                     envir = parent.frame()) 
[17:43:34.754]                   {
[17:43:34.754]                     default_workers <- missing(workers)
[17:43:34.754]                     if (is.function(workers)) 
[17:43:34.754]                       workers <- workers()
[17:43:34.754]                     workers <- structure(as.integer(workers), 
[17:43:34.754]                       class = class(workers))
[17:43:34.754]                     stop_if_not(is.finite(workers), workers >= 
[17:43:34.754]                       1L)
[17:43:34.754]                     if ((workers == 1L && !inherits(workers, 
[17:43:34.754]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:34.754]                       if (default_workers) 
[17:43:34.754]                         supportsMulticore(warn = TRUE)
[17:43:34.754]                       return(sequential(..., envir = envir))
[17:43:34.754]                     }
[17:43:34.754]                     oopts <- options(mc.cores = workers)
[17:43:34.754]                     on.exit(options(oopts))
[17:43:34.754]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:34.754]                       envir = envir)
[17:43:34.754]                     if (!future$lazy) 
[17:43:34.754]                       future <- run(future)
[17:43:34.754]                     invisible(future)
[17:43:34.754]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:34.754]                 }
[17:43:34.754]             }
[17:43:34.754]         }
[17:43:34.754]     })
[17:43:34.754]     if (TRUE) {
[17:43:34.754]         base::sink(type = "output", split = FALSE)
[17:43:34.754]         if (TRUE) {
[17:43:34.754]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:34.754]         }
[17:43:34.754]         else {
[17:43:34.754]             ...future.result["stdout"] <- base::list(NULL)
[17:43:34.754]         }
[17:43:34.754]         base::close(...future.stdout)
[17:43:34.754]         ...future.stdout <- NULL
[17:43:34.754]     }
[17:43:34.754]     ...future.result$conditions <- ...future.conditions
[17:43:34.754]     ...future.result$finished <- base::Sys.time()
[17:43:34.754]     ...future.result
[17:43:34.754] }
[17:43:34.758] requestCore(): workers = 2
[17:43:34.758] Poll #1 (0): usedCores() = 2, workers = 2
[17:43:34.791] MulticoreFuture started
[17:43:34.792] - Launch lazy future ... done
[17:43:34.792] run() for ‘MulticoreFuture’ ... done
[17:43:34.792] plan(): Setting new future strategy stack:
[17:43:34.793] List of future strategies:
[17:43:34.793] 1. sequential:
[17:43:34.793]    - args: function (..., envir = parent.frame())
[17:43:34.793]    - tweaked: FALSE
[17:43:34.793]    - call: NULL
[17:43:34.794] plan(): nbrOfWorkers() = 1
[17:43:34.796] plan(): Setting new future strategy stack:
[17:43:34.796] List of future strategies:
[17:43:34.796] 1. multicore:
[17:43:34.796]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:34.796]    - tweaked: FALSE
[17:43:34.796]    - call: plan(strategy)
[17:43:34.801] plan(): nbrOfWorkers() = 2
[17:43:34.802] Future #1
[17:43:34.802]  length: 2 (resolved future 1)
[17:43:34.803] Future #2
[17:43:34.803]  length: 1 (resolved future 2)
[17:43:34.803]  length: 0 (resolved future 3)
[17:43:34.803] resolve() on list ... DONE
[17:43:34.804] getGlobalsAndPackages() ...
[17:43:34.804] Searching for globals...
[17:43:34.805] 
[17:43:34.805] Searching for globals ... DONE
[17:43:34.805] - globals: [0] <none>
[17:43:34.805] getGlobalsAndPackages() ... DONE
[17:43:34.806] getGlobalsAndPackages() ...
[17:43:34.806] Searching for globals...
[17:43:34.806] 
[17:43:34.807] Searching for globals ... DONE
[17:43:34.807] - globals: [0] <none>
[17:43:34.807] getGlobalsAndPackages() ... DONE
[17:43:34.807] resolve() on list ...
[17:43:34.807]  recursive: 0
[17:43:34.808]  length: 3
[17:43:34.808]  elements: ‘a’, ‘b’, ‘’
[17:43:34.808] run() for ‘Future’ ...
[17:43:34.808] - state: ‘created’
[17:43:34.808] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:34.813] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:34.813] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:34.814]   - Field: ‘label’
[17:43:34.814]   - Field: ‘local’
[17:43:34.814]   - Field: ‘owner’
[17:43:34.814]   - Field: ‘envir’
[17:43:34.814]   - Field: ‘workers’
[17:43:34.814]   - Field: ‘packages’
[17:43:34.815]   - Field: ‘gc’
[17:43:34.815]   - Field: ‘job’
[17:43:34.815]   - Field: ‘conditions’
[17:43:34.815]   - Field: ‘expr’
[17:43:34.815]   - Field: ‘uuid’
[17:43:34.815]   - Field: ‘seed’
[17:43:34.816]   - Field: ‘version’
[17:43:34.816]   - Field: ‘result’
[17:43:34.816]   - Field: ‘asynchronous’
[17:43:34.816]   - Field: ‘calls’
[17:43:34.816]   - Field: ‘globals’
[17:43:34.816]   - Field: ‘stdout’
[17:43:34.817]   - Field: ‘earlySignal’
[17:43:34.817]   - Field: ‘lazy’
[17:43:34.817]   - Field: ‘state’
[17:43:34.817] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:34.817] - Launch lazy future ...
[17:43:34.818] Packages needed by the future expression (n = 0): <none>
[17:43:34.818] Packages needed by future strategies (n = 0): <none>
[17:43:34.819] {
[17:43:34.819]     {
[17:43:34.819]         {
[17:43:34.819]             ...future.startTime <- base::Sys.time()
[17:43:34.819]             {
[17:43:34.819]                 {
[17:43:34.819]                   {
[17:43:34.819]                     {
[17:43:34.819]                       base::local({
[17:43:34.819]                         has_future <- base::requireNamespace("future", 
[17:43:34.819]                           quietly = TRUE)
[17:43:34.819]                         if (has_future) {
[17:43:34.819]                           ns <- base::getNamespace("future")
[17:43:34.819]                           version <- ns[[".package"]][["version"]]
[17:43:34.819]                           if (is.null(version)) 
[17:43:34.819]                             version <- utils::packageVersion("future")
[17:43:34.819]                         }
[17:43:34.819]                         else {
[17:43:34.819]                           version <- NULL
[17:43:34.819]                         }
[17:43:34.819]                         if (!has_future || version < "1.8.0") {
[17:43:34.819]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:34.819]                             "", base::R.version$version.string), 
[17:43:34.819]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:34.819]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:34.819]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:34.819]                               "release", "version")], collapse = " "), 
[17:43:34.819]                             hostname = base::Sys.info()[["nodename"]])
[17:43:34.819]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:34.819]                             info)
[17:43:34.819]                           info <- base::paste(info, collapse = "; ")
[17:43:34.819]                           if (!has_future) {
[17:43:34.819]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:34.819]                               info)
[17:43:34.819]                           }
[17:43:34.819]                           else {
[17:43:34.819]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:34.819]                               info, version)
[17:43:34.819]                           }
[17:43:34.819]                           base::stop(msg)
[17:43:34.819]                         }
[17:43:34.819]                       })
[17:43:34.819]                     }
[17:43:34.819]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:34.819]                     base::options(mc.cores = 1L)
[17:43:34.819]                   }
[17:43:34.819]                   options(future.plan = NULL)
[17:43:34.819]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:34.819]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:34.819]                 }
[17:43:34.819]                 ...future.workdir <- getwd()
[17:43:34.819]             }
[17:43:34.819]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:34.819]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:34.819]         }
[17:43:34.819]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:34.819]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:34.819]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:34.819]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:34.819]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:34.819]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:34.819]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:34.819]             base::names(...future.oldOptions))
[17:43:34.819]     }
[17:43:34.819]     if (FALSE) {
[17:43:34.819]     }
[17:43:34.819]     else {
[17:43:34.819]         if (TRUE) {
[17:43:34.819]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:34.819]                 open = "w")
[17:43:34.819]         }
[17:43:34.819]         else {
[17:43:34.819]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:34.819]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:34.819]         }
[17:43:34.819]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:34.819]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:34.819]             base::sink(type = "output", split = FALSE)
[17:43:34.819]             base::close(...future.stdout)
[17:43:34.819]         }, add = TRUE)
[17:43:34.819]     }
[17:43:34.819]     ...future.frame <- base::sys.nframe()
[17:43:34.819]     ...future.conditions <- base::list()
[17:43:34.819]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:34.819]     if (FALSE) {
[17:43:34.819]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:34.819]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:34.819]     }
[17:43:34.819]     ...future.result <- base::tryCatch({
[17:43:34.819]         base::withCallingHandlers({
[17:43:34.819]             ...future.value <- base::withVisible(base::local({
[17:43:34.819]                 withCallingHandlers({
[17:43:34.819]                   1
[17:43:34.819]                 }, immediateCondition = function(cond) {
[17:43:34.819]                   save_rds <- function (object, pathname, ...) 
[17:43:34.819]                   {
[17:43:34.819]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:34.819]                     if (file_test("-f", pathname_tmp)) {
[17:43:34.819]                       fi_tmp <- file.info(pathname_tmp)
[17:43:34.819]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:34.819]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:34.819]                         fi_tmp[["mtime"]])
[17:43:34.819]                     }
[17:43:34.819]                     tryCatch({
[17:43:34.819]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:34.819]                     }, error = function(ex) {
[17:43:34.819]                       msg <- conditionMessage(ex)
[17:43:34.819]                       fi_tmp <- file.info(pathname_tmp)
[17:43:34.819]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:34.819]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:34.819]                         fi_tmp[["mtime"]], msg)
[17:43:34.819]                       ex$message <- msg
[17:43:34.819]                       stop(ex)
[17:43:34.819]                     })
[17:43:34.819]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:34.819]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:34.819]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:34.819]                       fi_tmp <- file.info(pathname_tmp)
[17:43:34.819]                       fi <- file.info(pathname)
[17:43:34.819]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:34.819]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:34.819]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:34.819]                         fi[["size"]], fi[["mtime"]])
[17:43:34.819]                       stop(msg)
[17:43:34.819]                     }
[17:43:34.819]                     invisible(pathname)
[17:43:34.819]                   }
[17:43:34.819]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:34.819]                     rootPath = tempdir()) 
[17:43:34.819]                   {
[17:43:34.819]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:34.819]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:34.819]                       tmpdir = path, fileext = ".rds")
[17:43:34.819]                     save_rds(obj, file)
[17:43:34.819]                   }
[17:43:34.819]                   saveImmediateCondition(cond, path = "/tmp/RtmpLaOb2h/.future/immediateConditions")
[17:43:34.819]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:34.819]                   {
[17:43:34.819]                     inherits <- base::inherits
[17:43:34.819]                     invokeRestart <- base::invokeRestart
[17:43:34.819]                     is.null <- base::is.null
[17:43:34.819]                     muffled <- FALSE
[17:43:34.819]                     if (inherits(cond, "message")) {
[17:43:34.819]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:34.819]                       if (muffled) 
[17:43:34.819]                         invokeRestart("muffleMessage")
[17:43:34.819]                     }
[17:43:34.819]                     else if (inherits(cond, "warning")) {
[17:43:34.819]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:34.819]                       if (muffled) 
[17:43:34.819]                         invokeRestart("muffleWarning")
[17:43:34.819]                     }
[17:43:34.819]                     else if (inherits(cond, "condition")) {
[17:43:34.819]                       if (!is.null(pattern)) {
[17:43:34.819]                         computeRestarts <- base::computeRestarts
[17:43:34.819]                         grepl <- base::grepl
[17:43:34.819]                         restarts <- computeRestarts(cond)
[17:43:34.819]                         for (restart in restarts) {
[17:43:34.819]                           name <- restart$name
[17:43:34.819]                           if (is.null(name)) 
[17:43:34.819]                             next
[17:43:34.819]                           if (!grepl(pattern, name)) 
[17:43:34.819]                             next
[17:43:34.819]                           invokeRestart(restart)
[17:43:34.819]                           muffled <- TRUE
[17:43:34.819]                           break
[17:43:34.819]                         }
[17:43:34.819]                       }
[17:43:34.819]                     }
[17:43:34.819]                     invisible(muffled)
[17:43:34.819]                   }
[17:43:34.819]                   muffleCondition(cond)
[17:43:34.819]                 })
[17:43:34.819]             }))
[17:43:34.819]             future::FutureResult(value = ...future.value$value, 
[17:43:34.819]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:34.819]                   ...future.rng), globalenv = if (FALSE) 
[17:43:34.819]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:34.819]                     ...future.globalenv.names))
[17:43:34.819]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:34.819]         }, condition = base::local({
[17:43:34.819]             c <- base::c
[17:43:34.819]             inherits <- base::inherits
[17:43:34.819]             invokeRestart <- base::invokeRestart
[17:43:34.819]             length <- base::length
[17:43:34.819]             list <- base::list
[17:43:34.819]             seq.int <- base::seq.int
[17:43:34.819]             signalCondition <- base::signalCondition
[17:43:34.819]             sys.calls <- base::sys.calls
[17:43:34.819]             `[[` <- base::`[[`
[17:43:34.819]             `+` <- base::`+`
[17:43:34.819]             `<<-` <- base::`<<-`
[17:43:34.819]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:34.819]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:34.819]                   3L)]
[17:43:34.819]             }
[17:43:34.819]             function(cond) {
[17:43:34.819]                 is_error <- inherits(cond, "error")
[17:43:34.819]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:34.819]                   NULL)
[17:43:34.819]                 if (is_error) {
[17:43:34.819]                   sessionInformation <- function() {
[17:43:34.819]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:34.819]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:34.819]                       search = base::search(), system = base::Sys.info())
[17:43:34.819]                   }
[17:43:34.819]                   ...future.conditions[[length(...future.conditions) + 
[17:43:34.819]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:34.819]                     cond$call), session = sessionInformation(), 
[17:43:34.819]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:34.819]                   signalCondition(cond)
[17:43:34.819]                 }
[17:43:34.819]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:34.819]                 "immediateCondition"))) {
[17:43:34.819]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:34.819]                   ...future.conditions[[length(...future.conditions) + 
[17:43:34.819]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:34.819]                   if (TRUE && !signal) {
[17:43:34.819]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:34.819]                     {
[17:43:34.819]                       inherits <- base::inherits
[17:43:34.819]                       invokeRestart <- base::invokeRestart
[17:43:34.819]                       is.null <- base::is.null
[17:43:34.819]                       muffled <- FALSE
[17:43:34.819]                       if (inherits(cond, "message")) {
[17:43:34.819]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:34.819]                         if (muffled) 
[17:43:34.819]                           invokeRestart("muffleMessage")
[17:43:34.819]                       }
[17:43:34.819]                       else if (inherits(cond, "warning")) {
[17:43:34.819]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:34.819]                         if (muffled) 
[17:43:34.819]                           invokeRestart("muffleWarning")
[17:43:34.819]                       }
[17:43:34.819]                       else if (inherits(cond, "condition")) {
[17:43:34.819]                         if (!is.null(pattern)) {
[17:43:34.819]                           computeRestarts <- base::computeRestarts
[17:43:34.819]                           grepl <- base::grepl
[17:43:34.819]                           restarts <- computeRestarts(cond)
[17:43:34.819]                           for (restart in restarts) {
[17:43:34.819]                             name <- restart$name
[17:43:34.819]                             if (is.null(name)) 
[17:43:34.819]                               next
[17:43:34.819]                             if (!grepl(pattern, name)) 
[17:43:34.819]                               next
[17:43:34.819]                             invokeRestart(restart)
[17:43:34.819]                             muffled <- TRUE
[17:43:34.819]                             break
[17:43:34.819]                           }
[17:43:34.819]                         }
[17:43:34.819]                       }
[17:43:34.819]                       invisible(muffled)
[17:43:34.819]                     }
[17:43:34.819]                     muffleCondition(cond, pattern = "^muffle")
[17:43:34.819]                   }
[17:43:34.819]                 }
[17:43:34.819]                 else {
[17:43:34.819]                   if (TRUE) {
[17:43:34.819]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:34.819]                     {
[17:43:34.819]                       inherits <- base::inherits
[17:43:34.819]                       invokeRestart <- base::invokeRestart
[17:43:34.819]                       is.null <- base::is.null
[17:43:34.819]                       muffled <- FALSE
[17:43:34.819]                       if (inherits(cond, "message")) {
[17:43:34.819]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:34.819]                         if (muffled) 
[17:43:34.819]                           invokeRestart("muffleMessage")
[17:43:34.819]                       }
[17:43:34.819]                       else if (inherits(cond, "warning")) {
[17:43:34.819]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:34.819]                         if (muffled) 
[17:43:34.819]                           invokeRestart("muffleWarning")
[17:43:34.819]                       }
[17:43:34.819]                       else if (inherits(cond, "condition")) {
[17:43:34.819]                         if (!is.null(pattern)) {
[17:43:34.819]                           computeRestarts <- base::computeRestarts
[17:43:34.819]                           grepl <- base::grepl
[17:43:34.819]                           restarts <- computeRestarts(cond)
[17:43:34.819]                           for (restart in restarts) {
[17:43:34.819]                             name <- restart$name
[17:43:34.819]                             if (is.null(name)) 
[17:43:34.819]                               next
[17:43:34.819]                             if (!grepl(pattern, name)) 
[17:43:34.819]                               next
[17:43:34.819]                             invokeRestart(restart)
[17:43:34.819]                             muffled <- TRUE
[17:43:34.819]                             break
[17:43:34.819]                           }
[17:43:34.819]                         }
[17:43:34.819]                       }
[17:43:34.819]                       invisible(muffled)
[17:43:34.819]                     }
[17:43:34.819]                     muffleCondition(cond, pattern = "^muffle")
[17:43:34.819]                   }
[17:43:34.819]                 }
[17:43:34.819]             }
[17:43:34.819]         }))
[17:43:34.819]     }, error = function(ex) {
[17:43:34.819]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:34.819]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:34.819]                 ...future.rng), started = ...future.startTime, 
[17:43:34.819]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:34.819]             version = "1.8"), class = "FutureResult")
[17:43:34.819]     }, finally = {
[17:43:34.819]         if (!identical(...future.workdir, getwd())) 
[17:43:34.819]             setwd(...future.workdir)
[17:43:34.819]         {
[17:43:34.819]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:34.819]                 ...future.oldOptions$nwarnings <- NULL
[17:43:34.819]             }
[17:43:34.819]             base::options(...future.oldOptions)
[17:43:34.819]             if (.Platform$OS.type == "windows") {
[17:43:34.819]                 old_names <- names(...future.oldEnvVars)
[17:43:34.819]                 envs <- base::Sys.getenv()
[17:43:34.819]                 names <- names(envs)
[17:43:34.819]                 common <- intersect(names, old_names)
[17:43:34.819]                 added <- setdiff(names, old_names)
[17:43:34.819]                 removed <- setdiff(old_names, names)
[17:43:34.819]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:34.819]                   envs[common]]
[17:43:34.819]                 NAMES <- toupper(changed)
[17:43:34.819]                 args <- list()
[17:43:34.819]                 for (kk in seq_along(NAMES)) {
[17:43:34.819]                   name <- changed[[kk]]
[17:43:34.819]                   NAME <- NAMES[[kk]]
[17:43:34.819]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.819]                     next
[17:43:34.819]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:34.819]                 }
[17:43:34.819]                 NAMES <- toupper(added)
[17:43:34.819]                 for (kk in seq_along(NAMES)) {
[17:43:34.819]                   name <- added[[kk]]
[17:43:34.819]                   NAME <- NAMES[[kk]]
[17:43:34.819]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.819]                     next
[17:43:34.819]                   args[[name]] <- ""
[17:43:34.819]                 }
[17:43:34.819]                 NAMES <- toupper(removed)
[17:43:34.819]                 for (kk in seq_along(NAMES)) {
[17:43:34.819]                   name <- removed[[kk]]
[17:43:34.819]                   NAME <- NAMES[[kk]]
[17:43:34.819]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.819]                     next
[17:43:34.819]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:34.819]                 }
[17:43:34.819]                 if (length(args) > 0) 
[17:43:34.819]                   base::do.call(base::Sys.setenv, args = args)
[17:43:34.819]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:34.819]             }
[17:43:34.819]             else {
[17:43:34.819]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:34.819]             }
[17:43:34.819]             {
[17:43:34.819]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:34.819]                   0L) {
[17:43:34.819]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:34.819]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:34.819]                   base::options(opts)
[17:43:34.819]                 }
[17:43:34.819]                 {
[17:43:34.819]                   {
[17:43:34.819]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:34.819]                     NULL
[17:43:34.819]                   }
[17:43:34.819]                   options(future.plan = NULL)
[17:43:34.819]                   if (is.na(NA_character_)) 
[17:43:34.819]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:34.819]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:34.819]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:43:34.819]                     envir = parent.frame()) 
[17:43:34.819]                   {
[17:43:34.819]                     default_workers <- missing(workers)
[17:43:34.819]                     if (is.function(workers)) 
[17:43:34.819]                       workers <- workers()
[17:43:34.819]                     workers <- structure(as.integer(workers), 
[17:43:34.819]                       class = class(workers))
[17:43:34.819]                     stop_if_not(is.finite(workers), workers >= 
[17:43:34.819]                       1L)
[17:43:34.819]                     if ((workers == 1L && !inherits(workers, 
[17:43:34.819]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:34.819]                       if (default_workers) 
[17:43:34.819]                         supportsMulticore(warn = TRUE)
[17:43:34.819]                       return(sequential(..., envir = envir))
[17:43:34.819]                     }
[17:43:34.819]                     oopts <- options(mc.cores = workers)
[17:43:34.819]                     on.exit(options(oopts))
[17:43:34.819]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:34.819]                       envir = envir)
[17:43:34.819]                     if (!future$lazy) 
[17:43:34.819]                       future <- run(future)
[17:43:34.819]                     invisible(future)
[17:43:34.819]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:34.819]                 }
[17:43:34.819]             }
[17:43:34.819]         }
[17:43:34.819]     })
[17:43:34.819]     if (TRUE) {
[17:43:34.819]         base::sink(type = "output", split = FALSE)
[17:43:34.819]         if (TRUE) {
[17:43:34.819]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:34.819]         }
[17:43:34.819]         else {
[17:43:34.819]             ...future.result["stdout"] <- base::list(NULL)
[17:43:34.819]         }
[17:43:34.819]         base::close(...future.stdout)
[17:43:34.819]         ...future.stdout <- NULL
[17:43:34.819]     }
[17:43:34.819]     ...future.result$conditions <- ...future.conditions
[17:43:34.819]     ...future.result$finished <- base::Sys.time()
[17:43:34.819]     ...future.result
[17:43:34.819] }
[17:43:34.822] requestCore(): workers = 2
[17:43:34.823] Poll #1 (0): usedCores() = 2, workers = 2
[17:43:34.837] MulticoreFuture started
[17:43:34.838] - Launch lazy future ... done
[17:43:34.838] run() for ‘MulticoreFuture’ ... done
[17:43:34.839] plan(): Setting new future strategy stack:
[17:43:34.839] List of future strategies:
[17:43:34.839] 1. sequential:
[17:43:34.839]    - args: function (..., envir = parent.frame())
[17:43:34.839]    - tweaked: FALSE
[17:43:34.839]    - call: NULL
[17:43:34.840] plan(): nbrOfWorkers() = 1
[17:43:34.842] plan(): Setting new future strategy stack:
[17:43:34.842] List of future strategies:
[17:43:34.842] 1. multicore:
[17:43:34.842]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:34.842]    - tweaked: FALSE
[17:43:34.842]    - call: plan(strategy)
[17:43:34.847] plan(): nbrOfWorkers() = 2
[17:43:34.848] Future #1
[17:43:34.848]  length: 2 (resolved future 1)
[17:43:34.848] run() for ‘Future’ ...
[17:43:34.849] - state: ‘created’
[17:43:34.849] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:34.853] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:34.854] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:34.854]   - Field: ‘label’
[17:43:34.854]   - Field: ‘local’
[17:43:34.854]   - Field: ‘owner’
[17:43:34.854]   - Field: ‘envir’
[17:43:34.854]   - Field: ‘workers’
[17:43:34.855]   - Field: ‘packages’
[17:43:34.855]   - Field: ‘gc’
[17:43:34.855]   - Field: ‘job’
[17:43:34.855]   - Field: ‘conditions’
[17:43:34.855]   - Field: ‘expr’
[17:43:34.855]   - Field: ‘uuid’
[17:43:34.856]   - Field: ‘seed’
[17:43:34.856]   - Field: ‘version’
[17:43:34.856]   - Field: ‘result’
[17:43:34.856]   - Field: ‘asynchronous’
[17:43:34.856]   - Field: ‘calls’
[17:43:34.856]   - Field: ‘globals’
[17:43:34.857]   - Field: ‘stdout’
[17:43:34.857]   - Field: ‘earlySignal’
[17:43:34.857]   - Field: ‘lazy’
[17:43:34.857]   - Field: ‘state’
[17:43:34.857] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:34.857] - Launch lazy future ...
[17:43:34.858] Packages needed by the future expression (n = 0): <none>
[17:43:34.858] Packages needed by future strategies (n = 0): <none>
[17:43:34.859] {
[17:43:34.859]     {
[17:43:34.859]         {
[17:43:34.859]             ...future.startTime <- base::Sys.time()
[17:43:34.859]             {
[17:43:34.859]                 {
[17:43:34.859]                   {
[17:43:34.859]                     {
[17:43:34.859]                       base::local({
[17:43:34.859]                         has_future <- base::requireNamespace("future", 
[17:43:34.859]                           quietly = TRUE)
[17:43:34.859]                         if (has_future) {
[17:43:34.859]                           ns <- base::getNamespace("future")
[17:43:34.859]                           version <- ns[[".package"]][["version"]]
[17:43:34.859]                           if (is.null(version)) 
[17:43:34.859]                             version <- utils::packageVersion("future")
[17:43:34.859]                         }
[17:43:34.859]                         else {
[17:43:34.859]                           version <- NULL
[17:43:34.859]                         }
[17:43:34.859]                         if (!has_future || version < "1.8.0") {
[17:43:34.859]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:34.859]                             "", base::R.version$version.string), 
[17:43:34.859]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:34.859]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:34.859]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:34.859]                               "release", "version")], collapse = " "), 
[17:43:34.859]                             hostname = base::Sys.info()[["nodename"]])
[17:43:34.859]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:34.859]                             info)
[17:43:34.859]                           info <- base::paste(info, collapse = "; ")
[17:43:34.859]                           if (!has_future) {
[17:43:34.859]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:34.859]                               info)
[17:43:34.859]                           }
[17:43:34.859]                           else {
[17:43:34.859]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:34.859]                               info, version)
[17:43:34.859]                           }
[17:43:34.859]                           base::stop(msg)
[17:43:34.859]                         }
[17:43:34.859]                       })
[17:43:34.859]                     }
[17:43:34.859]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:34.859]                     base::options(mc.cores = 1L)
[17:43:34.859]                   }
[17:43:34.859]                   options(future.plan = NULL)
[17:43:34.859]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:34.859]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:34.859]                 }
[17:43:34.859]                 ...future.workdir <- getwd()
[17:43:34.859]             }
[17:43:34.859]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:34.859]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:34.859]         }
[17:43:34.859]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:34.859]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:34.859]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:34.859]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:34.859]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:34.859]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:34.859]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:34.859]             base::names(...future.oldOptions))
[17:43:34.859]     }
[17:43:34.859]     if (FALSE) {
[17:43:34.859]     }
[17:43:34.859]     else {
[17:43:34.859]         if (TRUE) {
[17:43:34.859]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:34.859]                 open = "w")
[17:43:34.859]         }
[17:43:34.859]         else {
[17:43:34.859]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:34.859]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:34.859]         }
[17:43:34.859]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:34.859]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:34.859]             base::sink(type = "output", split = FALSE)
[17:43:34.859]             base::close(...future.stdout)
[17:43:34.859]         }, add = TRUE)
[17:43:34.859]     }
[17:43:34.859]     ...future.frame <- base::sys.nframe()
[17:43:34.859]     ...future.conditions <- base::list()
[17:43:34.859]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:34.859]     if (FALSE) {
[17:43:34.859]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:34.859]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:34.859]     }
[17:43:34.859]     ...future.result <- base::tryCatch({
[17:43:34.859]         base::withCallingHandlers({
[17:43:34.859]             ...future.value <- base::withVisible(base::local({
[17:43:34.859]                 withCallingHandlers({
[17:43:34.859]                   2
[17:43:34.859]                 }, immediateCondition = function(cond) {
[17:43:34.859]                   save_rds <- function (object, pathname, ...) 
[17:43:34.859]                   {
[17:43:34.859]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:34.859]                     if (file_test("-f", pathname_tmp)) {
[17:43:34.859]                       fi_tmp <- file.info(pathname_tmp)
[17:43:34.859]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:34.859]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:34.859]                         fi_tmp[["mtime"]])
[17:43:34.859]                     }
[17:43:34.859]                     tryCatch({
[17:43:34.859]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:34.859]                     }, error = function(ex) {
[17:43:34.859]                       msg <- conditionMessage(ex)
[17:43:34.859]                       fi_tmp <- file.info(pathname_tmp)
[17:43:34.859]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:34.859]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:34.859]                         fi_tmp[["mtime"]], msg)
[17:43:34.859]                       ex$message <- msg
[17:43:34.859]                       stop(ex)
[17:43:34.859]                     })
[17:43:34.859]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:34.859]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:34.859]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:34.859]                       fi_tmp <- file.info(pathname_tmp)
[17:43:34.859]                       fi <- file.info(pathname)
[17:43:34.859]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:34.859]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:34.859]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:34.859]                         fi[["size"]], fi[["mtime"]])
[17:43:34.859]                       stop(msg)
[17:43:34.859]                     }
[17:43:34.859]                     invisible(pathname)
[17:43:34.859]                   }
[17:43:34.859]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:34.859]                     rootPath = tempdir()) 
[17:43:34.859]                   {
[17:43:34.859]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:34.859]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:34.859]                       tmpdir = path, fileext = ".rds")
[17:43:34.859]                     save_rds(obj, file)
[17:43:34.859]                   }
[17:43:34.859]                   saveImmediateCondition(cond, path = "/tmp/RtmpLaOb2h/.future/immediateConditions")
[17:43:34.859]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:34.859]                   {
[17:43:34.859]                     inherits <- base::inherits
[17:43:34.859]                     invokeRestart <- base::invokeRestart
[17:43:34.859]                     is.null <- base::is.null
[17:43:34.859]                     muffled <- FALSE
[17:43:34.859]                     if (inherits(cond, "message")) {
[17:43:34.859]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:34.859]                       if (muffled) 
[17:43:34.859]                         invokeRestart("muffleMessage")
[17:43:34.859]                     }
[17:43:34.859]                     else if (inherits(cond, "warning")) {
[17:43:34.859]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:34.859]                       if (muffled) 
[17:43:34.859]                         invokeRestart("muffleWarning")
[17:43:34.859]                     }
[17:43:34.859]                     else if (inherits(cond, "condition")) {
[17:43:34.859]                       if (!is.null(pattern)) {
[17:43:34.859]                         computeRestarts <- base::computeRestarts
[17:43:34.859]                         grepl <- base::grepl
[17:43:34.859]                         restarts <- computeRestarts(cond)
[17:43:34.859]                         for (restart in restarts) {
[17:43:34.859]                           name <- restart$name
[17:43:34.859]                           if (is.null(name)) 
[17:43:34.859]                             next
[17:43:34.859]                           if (!grepl(pattern, name)) 
[17:43:34.859]                             next
[17:43:34.859]                           invokeRestart(restart)
[17:43:34.859]                           muffled <- TRUE
[17:43:34.859]                           break
[17:43:34.859]                         }
[17:43:34.859]                       }
[17:43:34.859]                     }
[17:43:34.859]                     invisible(muffled)
[17:43:34.859]                   }
[17:43:34.859]                   muffleCondition(cond)
[17:43:34.859]                 })
[17:43:34.859]             }))
[17:43:34.859]             future::FutureResult(value = ...future.value$value, 
[17:43:34.859]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:34.859]                   ...future.rng), globalenv = if (FALSE) 
[17:43:34.859]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:34.859]                     ...future.globalenv.names))
[17:43:34.859]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:34.859]         }, condition = base::local({
[17:43:34.859]             c <- base::c
[17:43:34.859]             inherits <- base::inherits
[17:43:34.859]             invokeRestart <- base::invokeRestart
[17:43:34.859]             length <- base::length
[17:43:34.859]             list <- base::list
[17:43:34.859]             seq.int <- base::seq.int
[17:43:34.859]             signalCondition <- base::signalCondition
[17:43:34.859]             sys.calls <- base::sys.calls
[17:43:34.859]             `[[` <- base::`[[`
[17:43:34.859]             `+` <- base::`+`
[17:43:34.859]             `<<-` <- base::`<<-`
[17:43:34.859]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:34.859]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:34.859]                   3L)]
[17:43:34.859]             }
[17:43:34.859]             function(cond) {
[17:43:34.859]                 is_error <- inherits(cond, "error")
[17:43:34.859]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:34.859]                   NULL)
[17:43:34.859]                 if (is_error) {
[17:43:34.859]                   sessionInformation <- function() {
[17:43:34.859]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:34.859]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:34.859]                       search = base::search(), system = base::Sys.info())
[17:43:34.859]                   }
[17:43:34.859]                   ...future.conditions[[length(...future.conditions) + 
[17:43:34.859]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:34.859]                     cond$call), session = sessionInformation(), 
[17:43:34.859]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:34.859]                   signalCondition(cond)
[17:43:34.859]                 }
[17:43:34.859]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:34.859]                 "immediateCondition"))) {
[17:43:34.859]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:34.859]                   ...future.conditions[[length(...future.conditions) + 
[17:43:34.859]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:34.859]                   if (TRUE && !signal) {
[17:43:34.859]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:34.859]                     {
[17:43:34.859]                       inherits <- base::inherits
[17:43:34.859]                       invokeRestart <- base::invokeRestart
[17:43:34.859]                       is.null <- base::is.null
[17:43:34.859]                       muffled <- FALSE
[17:43:34.859]                       if (inherits(cond, "message")) {
[17:43:34.859]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:34.859]                         if (muffled) 
[17:43:34.859]                           invokeRestart("muffleMessage")
[17:43:34.859]                       }
[17:43:34.859]                       else if (inherits(cond, "warning")) {
[17:43:34.859]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:34.859]                         if (muffled) 
[17:43:34.859]                           invokeRestart("muffleWarning")
[17:43:34.859]                       }
[17:43:34.859]                       else if (inherits(cond, "condition")) {
[17:43:34.859]                         if (!is.null(pattern)) {
[17:43:34.859]                           computeRestarts <- base::computeRestarts
[17:43:34.859]                           grepl <- base::grepl
[17:43:34.859]                           restarts <- computeRestarts(cond)
[17:43:34.859]                           for (restart in restarts) {
[17:43:34.859]                             name <- restart$name
[17:43:34.859]                             if (is.null(name)) 
[17:43:34.859]                               next
[17:43:34.859]                             if (!grepl(pattern, name)) 
[17:43:34.859]                               next
[17:43:34.859]                             invokeRestart(restart)
[17:43:34.859]                             muffled <- TRUE
[17:43:34.859]                             break
[17:43:34.859]                           }
[17:43:34.859]                         }
[17:43:34.859]                       }
[17:43:34.859]                       invisible(muffled)
[17:43:34.859]                     }
[17:43:34.859]                     muffleCondition(cond, pattern = "^muffle")
[17:43:34.859]                   }
[17:43:34.859]                 }
[17:43:34.859]                 else {
[17:43:34.859]                   if (TRUE) {
[17:43:34.859]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:34.859]                     {
[17:43:34.859]                       inherits <- base::inherits
[17:43:34.859]                       invokeRestart <- base::invokeRestart
[17:43:34.859]                       is.null <- base::is.null
[17:43:34.859]                       muffled <- FALSE
[17:43:34.859]                       if (inherits(cond, "message")) {
[17:43:34.859]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:34.859]                         if (muffled) 
[17:43:34.859]                           invokeRestart("muffleMessage")
[17:43:34.859]                       }
[17:43:34.859]                       else if (inherits(cond, "warning")) {
[17:43:34.859]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:34.859]                         if (muffled) 
[17:43:34.859]                           invokeRestart("muffleWarning")
[17:43:34.859]                       }
[17:43:34.859]                       else if (inherits(cond, "condition")) {
[17:43:34.859]                         if (!is.null(pattern)) {
[17:43:34.859]                           computeRestarts <- base::computeRestarts
[17:43:34.859]                           grepl <- base::grepl
[17:43:34.859]                           restarts <- computeRestarts(cond)
[17:43:34.859]                           for (restart in restarts) {
[17:43:34.859]                             name <- restart$name
[17:43:34.859]                             if (is.null(name)) 
[17:43:34.859]                               next
[17:43:34.859]                             if (!grepl(pattern, name)) 
[17:43:34.859]                               next
[17:43:34.859]                             invokeRestart(restart)
[17:43:34.859]                             muffled <- TRUE
[17:43:34.859]                             break
[17:43:34.859]                           }
[17:43:34.859]                         }
[17:43:34.859]                       }
[17:43:34.859]                       invisible(muffled)
[17:43:34.859]                     }
[17:43:34.859]                     muffleCondition(cond, pattern = "^muffle")
[17:43:34.859]                   }
[17:43:34.859]                 }
[17:43:34.859]             }
[17:43:34.859]         }))
[17:43:34.859]     }, error = function(ex) {
[17:43:34.859]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:34.859]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:34.859]                 ...future.rng), started = ...future.startTime, 
[17:43:34.859]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:34.859]             version = "1.8"), class = "FutureResult")
[17:43:34.859]     }, finally = {
[17:43:34.859]         if (!identical(...future.workdir, getwd())) 
[17:43:34.859]             setwd(...future.workdir)
[17:43:34.859]         {
[17:43:34.859]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:34.859]                 ...future.oldOptions$nwarnings <- NULL
[17:43:34.859]             }
[17:43:34.859]             base::options(...future.oldOptions)
[17:43:34.859]             if (.Platform$OS.type == "windows") {
[17:43:34.859]                 old_names <- names(...future.oldEnvVars)
[17:43:34.859]                 envs <- base::Sys.getenv()
[17:43:34.859]                 names <- names(envs)
[17:43:34.859]                 common <- intersect(names, old_names)
[17:43:34.859]                 added <- setdiff(names, old_names)
[17:43:34.859]                 removed <- setdiff(old_names, names)
[17:43:34.859]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:34.859]                   envs[common]]
[17:43:34.859]                 NAMES <- toupper(changed)
[17:43:34.859]                 args <- list()
[17:43:34.859]                 for (kk in seq_along(NAMES)) {
[17:43:34.859]                   name <- changed[[kk]]
[17:43:34.859]                   NAME <- NAMES[[kk]]
[17:43:34.859]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.859]                     next
[17:43:34.859]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:34.859]                 }
[17:43:34.859]                 NAMES <- toupper(added)
[17:43:34.859]                 for (kk in seq_along(NAMES)) {
[17:43:34.859]                   name <- added[[kk]]
[17:43:34.859]                   NAME <- NAMES[[kk]]
[17:43:34.859]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.859]                     next
[17:43:34.859]                   args[[name]] <- ""
[17:43:34.859]                 }
[17:43:34.859]                 NAMES <- toupper(removed)
[17:43:34.859]                 for (kk in seq_along(NAMES)) {
[17:43:34.859]                   name <- removed[[kk]]
[17:43:34.859]                   NAME <- NAMES[[kk]]
[17:43:34.859]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.859]                     next
[17:43:34.859]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:34.859]                 }
[17:43:34.859]                 if (length(args) > 0) 
[17:43:34.859]                   base::do.call(base::Sys.setenv, args = args)
[17:43:34.859]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:34.859]             }
[17:43:34.859]             else {
[17:43:34.859]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:34.859]             }
[17:43:34.859]             {
[17:43:34.859]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:34.859]                   0L) {
[17:43:34.859]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:34.859]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:34.859]                   base::options(opts)
[17:43:34.859]                 }
[17:43:34.859]                 {
[17:43:34.859]                   {
[17:43:34.859]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:34.859]                     NULL
[17:43:34.859]                   }
[17:43:34.859]                   options(future.plan = NULL)
[17:43:34.859]                   if (is.na(NA_character_)) 
[17:43:34.859]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:34.859]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:34.859]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:43:34.859]                     envir = parent.frame()) 
[17:43:34.859]                   {
[17:43:34.859]                     default_workers <- missing(workers)
[17:43:34.859]                     if (is.function(workers)) 
[17:43:34.859]                       workers <- workers()
[17:43:34.859]                     workers <- structure(as.integer(workers), 
[17:43:34.859]                       class = class(workers))
[17:43:34.859]                     stop_if_not(is.finite(workers), workers >= 
[17:43:34.859]                       1L)
[17:43:34.859]                     if ((workers == 1L && !inherits(workers, 
[17:43:34.859]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:34.859]                       if (default_workers) 
[17:43:34.859]                         supportsMulticore(warn = TRUE)
[17:43:34.859]                       return(sequential(..., envir = envir))
[17:43:34.859]                     }
[17:43:34.859]                     oopts <- options(mc.cores = workers)
[17:43:34.859]                     on.exit(options(oopts))
[17:43:34.859]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:34.859]                       envir = envir)
[17:43:34.859]                     if (!future$lazy) 
[17:43:34.859]                       future <- run(future)
[17:43:34.859]                     invisible(future)
[17:43:34.859]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:34.859]                 }
[17:43:34.859]             }
[17:43:34.859]         }
[17:43:34.859]     })
[17:43:34.859]     if (TRUE) {
[17:43:34.859]         base::sink(type = "output", split = FALSE)
[17:43:34.859]         if (TRUE) {
[17:43:34.859]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:34.859]         }
[17:43:34.859]         else {
[17:43:34.859]             ...future.result["stdout"] <- base::list(NULL)
[17:43:34.859]         }
[17:43:34.859]         base::close(...future.stdout)
[17:43:34.859]         ...future.stdout <- NULL
[17:43:34.859]     }
[17:43:34.859]     ...future.result$conditions <- ...future.conditions
[17:43:34.859]     ...future.result$finished <- base::Sys.time()
[17:43:34.859]     ...future.result
[17:43:34.859] }
[17:43:34.863] requestCore(): workers = 2
[17:43:34.863] Poll #1 (0): usedCores() = 2, workers = 2
[17:43:34.877] MulticoreFuture started
[17:43:34.878] - Launch lazy future ... done
[17:43:34.878] run() for ‘MulticoreFuture’ ... done
[17:43:34.878] plan(): Setting new future strategy stack:
[17:43:34.879] List of future strategies:
[17:43:34.879] 1. sequential:
[17:43:34.879]    - args: function (..., envir = parent.frame())
[17:43:34.879]    - tweaked: FALSE
[17:43:34.879]    - call: NULL
[17:43:34.880] plan(): nbrOfWorkers() = 1
[17:43:34.887] plan(): Setting new future strategy stack:
[17:43:34.888] List of future strategies:
[17:43:34.888] 1. multicore:
[17:43:34.888]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:34.888]    - tweaked: FALSE
[17:43:34.888]    - call: plan(strategy)
[17:43:34.889]  length: 1 (resolved future 3)
[17:43:34.895] plan(): nbrOfWorkers() = 2
[17:43:34.899] Future #2
[17:43:34.900]  length: 0 (resolved future 2)
[17:43:34.904] resolve() on list ... DONE
[17:43:34.905] getGlobalsAndPackages() ...
[17:43:34.905] Searching for globals...
[17:43:34.906] 
[17:43:34.907] Searching for globals ... DONE
[17:43:34.907] - globals: [0] <none>
[17:43:34.907] getGlobalsAndPackages() ... DONE
[17:43:34.908] run() for ‘Future’ ...
[17:43:34.908] - state: ‘created’
[17:43:34.909] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:34.914] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:34.914] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:34.914]   - Field: ‘label’
[17:43:34.914]   - Field: ‘local’
[17:43:34.915]   - Field: ‘owner’
[17:43:34.915]   - Field: ‘envir’
[17:43:34.915]   - Field: ‘workers’
[17:43:34.915]   - Field: ‘packages’
[17:43:34.915]   - Field: ‘gc’
[17:43:34.916]   - Field: ‘job’
[17:43:34.916]   - Field: ‘conditions’
[17:43:34.916]   - Field: ‘expr’
[17:43:34.916]   - Field: ‘uuid’
[17:43:34.916]   - Field: ‘seed’
[17:43:34.916]   - Field: ‘version’
[17:43:34.916]   - Field: ‘result’
[17:43:34.917]   - Field: ‘asynchronous’
[17:43:34.917]   - Field: ‘calls’
[17:43:34.917]   - Field: ‘globals’
[17:43:34.917]   - Field: ‘stdout’
[17:43:34.918]   - Field: ‘earlySignal’
[17:43:34.918]   - Field: ‘lazy’
[17:43:34.918]   - Field: ‘state’
[17:43:34.918] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:34.918] - Launch lazy future ...
[17:43:34.919] Packages needed by the future expression (n = 0): <none>
[17:43:34.919] Packages needed by future strategies (n = 0): <none>
[17:43:34.920] {
[17:43:34.920]     {
[17:43:34.920]         {
[17:43:34.920]             ...future.startTime <- base::Sys.time()
[17:43:34.920]             {
[17:43:34.920]                 {
[17:43:34.920]                   {
[17:43:34.920]                     {
[17:43:34.920]                       base::local({
[17:43:34.920]                         has_future <- base::requireNamespace("future", 
[17:43:34.920]                           quietly = TRUE)
[17:43:34.920]                         if (has_future) {
[17:43:34.920]                           ns <- base::getNamespace("future")
[17:43:34.920]                           version <- ns[[".package"]][["version"]]
[17:43:34.920]                           if (is.null(version)) 
[17:43:34.920]                             version <- utils::packageVersion("future")
[17:43:34.920]                         }
[17:43:34.920]                         else {
[17:43:34.920]                           version <- NULL
[17:43:34.920]                         }
[17:43:34.920]                         if (!has_future || version < "1.8.0") {
[17:43:34.920]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:34.920]                             "", base::R.version$version.string), 
[17:43:34.920]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:34.920]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:34.920]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:34.920]                               "release", "version")], collapse = " "), 
[17:43:34.920]                             hostname = base::Sys.info()[["nodename"]])
[17:43:34.920]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:34.920]                             info)
[17:43:34.920]                           info <- base::paste(info, collapse = "; ")
[17:43:34.920]                           if (!has_future) {
[17:43:34.920]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:34.920]                               info)
[17:43:34.920]                           }
[17:43:34.920]                           else {
[17:43:34.920]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:34.920]                               info, version)
[17:43:34.920]                           }
[17:43:34.920]                           base::stop(msg)
[17:43:34.920]                         }
[17:43:34.920]                       })
[17:43:34.920]                     }
[17:43:34.920]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:34.920]                     base::options(mc.cores = 1L)
[17:43:34.920]                   }
[17:43:34.920]                   options(future.plan = NULL)
[17:43:34.920]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:34.920]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:34.920]                 }
[17:43:34.920]                 ...future.workdir <- getwd()
[17:43:34.920]             }
[17:43:34.920]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:34.920]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:34.920]         }
[17:43:34.920]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:34.920]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:34.920]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:34.920]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:34.920]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:34.920]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:34.920]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:34.920]             base::names(...future.oldOptions))
[17:43:34.920]     }
[17:43:34.920]     if (FALSE) {
[17:43:34.920]     }
[17:43:34.920]     else {
[17:43:34.920]         if (TRUE) {
[17:43:34.920]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:34.920]                 open = "w")
[17:43:34.920]         }
[17:43:34.920]         else {
[17:43:34.920]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:34.920]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:34.920]         }
[17:43:34.920]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:34.920]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:34.920]             base::sink(type = "output", split = FALSE)
[17:43:34.920]             base::close(...future.stdout)
[17:43:34.920]         }, add = TRUE)
[17:43:34.920]     }
[17:43:34.920]     ...future.frame <- base::sys.nframe()
[17:43:34.920]     ...future.conditions <- base::list()
[17:43:34.920]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:34.920]     if (FALSE) {
[17:43:34.920]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:34.920]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:34.920]     }
[17:43:34.920]     ...future.result <- base::tryCatch({
[17:43:34.920]         base::withCallingHandlers({
[17:43:34.920]             ...future.value <- base::withVisible(base::local({
[17:43:34.920]                 withCallingHandlers({
[17:43:34.920]                   1
[17:43:34.920]                 }, immediateCondition = function(cond) {
[17:43:34.920]                   save_rds <- function (object, pathname, ...) 
[17:43:34.920]                   {
[17:43:34.920]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:34.920]                     if (file_test("-f", pathname_tmp)) {
[17:43:34.920]                       fi_tmp <- file.info(pathname_tmp)
[17:43:34.920]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:34.920]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:34.920]                         fi_tmp[["mtime"]])
[17:43:34.920]                     }
[17:43:34.920]                     tryCatch({
[17:43:34.920]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:34.920]                     }, error = function(ex) {
[17:43:34.920]                       msg <- conditionMessage(ex)
[17:43:34.920]                       fi_tmp <- file.info(pathname_tmp)
[17:43:34.920]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:34.920]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:34.920]                         fi_tmp[["mtime"]], msg)
[17:43:34.920]                       ex$message <- msg
[17:43:34.920]                       stop(ex)
[17:43:34.920]                     })
[17:43:34.920]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:34.920]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:34.920]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:34.920]                       fi_tmp <- file.info(pathname_tmp)
[17:43:34.920]                       fi <- file.info(pathname)
[17:43:34.920]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:34.920]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:34.920]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:34.920]                         fi[["size"]], fi[["mtime"]])
[17:43:34.920]                       stop(msg)
[17:43:34.920]                     }
[17:43:34.920]                     invisible(pathname)
[17:43:34.920]                   }
[17:43:34.920]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:34.920]                     rootPath = tempdir()) 
[17:43:34.920]                   {
[17:43:34.920]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:34.920]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:34.920]                       tmpdir = path, fileext = ".rds")
[17:43:34.920]                     save_rds(obj, file)
[17:43:34.920]                   }
[17:43:34.920]                   saveImmediateCondition(cond, path = "/tmp/RtmpLaOb2h/.future/immediateConditions")
[17:43:34.920]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:34.920]                   {
[17:43:34.920]                     inherits <- base::inherits
[17:43:34.920]                     invokeRestart <- base::invokeRestart
[17:43:34.920]                     is.null <- base::is.null
[17:43:34.920]                     muffled <- FALSE
[17:43:34.920]                     if (inherits(cond, "message")) {
[17:43:34.920]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:34.920]                       if (muffled) 
[17:43:34.920]                         invokeRestart("muffleMessage")
[17:43:34.920]                     }
[17:43:34.920]                     else if (inherits(cond, "warning")) {
[17:43:34.920]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:34.920]                       if (muffled) 
[17:43:34.920]                         invokeRestart("muffleWarning")
[17:43:34.920]                     }
[17:43:34.920]                     else if (inherits(cond, "condition")) {
[17:43:34.920]                       if (!is.null(pattern)) {
[17:43:34.920]                         computeRestarts <- base::computeRestarts
[17:43:34.920]                         grepl <- base::grepl
[17:43:34.920]                         restarts <- computeRestarts(cond)
[17:43:34.920]                         for (restart in restarts) {
[17:43:34.920]                           name <- restart$name
[17:43:34.920]                           if (is.null(name)) 
[17:43:34.920]                             next
[17:43:34.920]                           if (!grepl(pattern, name)) 
[17:43:34.920]                             next
[17:43:34.920]                           invokeRestart(restart)
[17:43:34.920]                           muffled <- TRUE
[17:43:34.920]                           break
[17:43:34.920]                         }
[17:43:34.920]                       }
[17:43:34.920]                     }
[17:43:34.920]                     invisible(muffled)
[17:43:34.920]                   }
[17:43:34.920]                   muffleCondition(cond)
[17:43:34.920]                 })
[17:43:34.920]             }))
[17:43:34.920]             future::FutureResult(value = ...future.value$value, 
[17:43:34.920]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:34.920]                   ...future.rng), globalenv = if (FALSE) 
[17:43:34.920]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:34.920]                     ...future.globalenv.names))
[17:43:34.920]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:34.920]         }, condition = base::local({
[17:43:34.920]             c <- base::c
[17:43:34.920]             inherits <- base::inherits
[17:43:34.920]             invokeRestart <- base::invokeRestart
[17:43:34.920]             length <- base::length
[17:43:34.920]             list <- base::list
[17:43:34.920]             seq.int <- base::seq.int
[17:43:34.920]             signalCondition <- base::signalCondition
[17:43:34.920]             sys.calls <- base::sys.calls
[17:43:34.920]             `[[` <- base::`[[`
[17:43:34.920]             `+` <- base::`+`
[17:43:34.920]             `<<-` <- base::`<<-`
[17:43:34.920]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:34.920]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:34.920]                   3L)]
[17:43:34.920]             }
[17:43:34.920]             function(cond) {
[17:43:34.920]                 is_error <- inherits(cond, "error")
[17:43:34.920]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:34.920]                   NULL)
[17:43:34.920]                 if (is_error) {
[17:43:34.920]                   sessionInformation <- function() {
[17:43:34.920]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:34.920]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:34.920]                       search = base::search(), system = base::Sys.info())
[17:43:34.920]                   }
[17:43:34.920]                   ...future.conditions[[length(...future.conditions) + 
[17:43:34.920]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:34.920]                     cond$call), session = sessionInformation(), 
[17:43:34.920]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:34.920]                   signalCondition(cond)
[17:43:34.920]                 }
[17:43:34.920]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:34.920]                 "immediateCondition"))) {
[17:43:34.920]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:34.920]                   ...future.conditions[[length(...future.conditions) + 
[17:43:34.920]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:34.920]                   if (TRUE && !signal) {
[17:43:34.920]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:34.920]                     {
[17:43:34.920]                       inherits <- base::inherits
[17:43:34.920]                       invokeRestart <- base::invokeRestart
[17:43:34.920]                       is.null <- base::is.null
[17:43:34.920]                       muffled <- FALSE
[17:43:34.920]                       if (inherits(cond, "message")) {
[17:43:34.920]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:34.920]                         if (muffled) 
[17:43:34.920]                           invokeRestart("muffleMessage")
[17:43:34.920]                       }
[17:43:34.920]                       else if (inherits(cond, "warning")) {
[17:43:34.920]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:34.920]                         if (muffled) 
[17:43:34.920]                           invokeRestart("muffleWarning")
[17:43:34.920]                       }
[17:43:34.920]                       else if (inherits(cond, "condition")) {
[17:43:34.920]                         if (!is.null(pattern)) {
[17:43:34.920]                           computeRestarts <- base::computeRestarts
[17:43:34.920]                           grepl <- base::grepl
[17:43:34.920]                           restarts <- computeRestarts(cond)
[17:43:34.920]                           for (restart in restarts) {
[17:43:34.920]                             name <- restart$name
[17:43:34.920]                             if (is.null(name)) 
[17:43:34.920]                               next
[17:43:34.920]                             if (!grepl(pattern, name)) 
[17:43:34.920]                               next
[17:43:34.920]                             invokeRestart(restart)
[17:43:34.920]                             muffled <- TRUE
[17:43:34.920]                             break
[17:43:34.920]                           }
[17:43:34.920]                         }
[17:43:34.920]                       }
[17:43:34.920]                       invisible(muffled)
[17:43:34.920]                     }
[17:43:34.920]                     muffleCondition(cond, pattern = "^muffle")
[17:43:34.920]                   }
[17:43:34.920]                 }
[17:43:34.920]                 else {
[17:43:34.920]                   if (TRUE) {
[17:43:34.920]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:34.920]                     {
[17:43:34.920]                       inherits <- base::inherits
[17:43:34.920]                       invokeRestart <- base::invokeRestart
[17:43:34.920]                       is.null <- base::is.null
[17:43:34.920]                       muffled <- FALSE
[17:43:34.920]                       if (inherits(cond, "message")) {
[17:43:34.920]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:34.920]                         if (muffled) 
[17:43:34.920]                           invokeRestart("muffleMessage")
[17:43:34.920]                       }
[17:43:34.920]                       else if (inherits(cond, "warning")) {
[17:43:34.920]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:34.920]                         if (muffled) 
[17:43:34.920]                           invokeRestart("muffleWarning")
[17:43:34.920]                       }
[17:43:34.920]                       else if (inherits(cond, "condition")) {
[17:43:34.920]                         if (!is.null(pattern)) {
[17:43:34.920]                           computeRestarts <- base::computeRestarts
[17:43:34.920]                           grepl <- base::grepl
[17:43:34.920]                           restarts <- computeRestarts(cond)
[17:43:34.920]                           for (restart in restarts) {
[17:43:34.920]                             name <- restart$name
[17:43:34.920]                             if (is.null(name)) 
[17:43:34.920]                               next
[17:43:34.920]                             if (!grepl(pattern, name)) 
[17:43:34.920]                               next
[17:43:34.920]                             invokeRestart(restart)
[17:43:34.920]                             muffled <- TRUE
[17:43:34.920]                             break
[17:43:34.920]                           }
[17:43:34.920]                         }
[17:43:34.920]                       }
[17:43:34.920]                       invisible(muffled)
[17:43:34.920]                     }
[17:43:34.920]                     muffleCondition(cond, pattern = "^muffle")
[17:43:34.920]                   }
[17:43:34.920]                 }
[17:43:34.920]             }
[17:43:34.920]         }))
[17:43:34.920]     }, error = function(ex) {
[17:43:34.920]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:34.920]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:34.920]                 ...future.rng), started = ...future.startTime, 
[17:43:34.920]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:34.920]             version = "1.8"), class = "FutureResult")
[17:43:34.920]     }, finally = {
[17:43:34.920]         if (!identical(...future.workdir, getwd())) 
[17:43:34.920]             setwd(...future.workdir)
[17:43:34.920]         {
[17:43:34.920]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:34.920]                 ...future.oldOptions$nwarnings <- NULL
[17:43:34.920]             }
[17:43:34.920]             base::options(...future.oldOptions)
[17:43:34.920]             if (.Platform$OS.type == "windows") {
[17:43:34.920]                 old_names <- names(...future.oldEnvVars)
[17:43:34.920]                 envs <- base::Sys.getenv()
[17:43:34.920]                 names <- names(envs)
[17:43:34.920]                 common <- intersect(names, old_names)
[17:43:34.920]                 added <- setdiff(names, old_names)
[17:43:34.920]                 removed <- setdiff(old_names, names)
[17:43:34.920]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:34.920]                   envs[common]]
[17:43:34.920]                 NAMES <- toupper(changed)
[17:43:34.920]                 args <- list()
[17:43:34.920]                 for (kk in seq_along(NAMES)) {
[17:43:34.920]                   name <- changed[[kk]]
[17:43:34.920]                   NAME <- NAMES[[kk]]
[17:43:34.920]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.920]                     next
[17:43:34.920]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:34.920]                 }
[17:43:34.920]                 NAMES <- toupper(added)
[17:43:34.920]                 for (kk in seq_along(NAMES)) {
[17:43:34.920]                   name <- added[[kk]]
[17:43:34.920]                   NAME <- NAMES[[kk]]
[17:43:34.920]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.920]                     next
[17:43:34.920]                   args[[name]] <- ""
[17:43:34.920]                 }
[17:43:34.920]                 NAMES <- toupper(removed)
[17:43:34.920]                 for (kk in seq_along(NAMES)) {
[17:43:34.920]                   name <- removed[[kk]]
[17:43:34.920]                   NAME <- NAMES[[kk]]
[17:43:34.920]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.920]                     next
[17:43:34.920]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:34.920]                 }
[17:43:34.920]                 if (length(args) > 0) 
[17:43:34.920]                   base::do.call(base::Sys.setenv, args = args)
[17:43:34.920]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:34.920]             }
[17:43:34.920]             else {
[17:43:34.920]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:34.920]             }
[17:43:34.920]             {
[17:43:34.920]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:34.920]                   0L) {
[17:43:34.920]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:34.920]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:34.920]                   base::options(opts)
[17:43:34.920]                 }
[17:43:34.920]                 {
[17:43:34.920]                   {
[17:43:34.920]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:34.920]                     NULL
[17:43:34.920]                   }
[17:43:34.920]                   options(future.plan = NULL)
[17:43:34.920]                   if (is.na(NA_character_)) 
[17:43:34.920]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:34.920]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:34.920]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:43:34.920]                     envir = parent.frame()) 
[17:43:34.920]                   {
[17:43:34.920]                     default_workers <- missing(workers)
[17:43:34.920]                     if (is.function(workers)) 
[17:43:34.920]                       workers <- workers()
[17:43:34.920]                     workers <- structure(as.integer(workers), 
[17:43:34.920]                       class = class(workers))
[17:43:34.920]                     stop_if_not(is.finite(workers), workers >= 
[17:43:34.920]                       1L)
[17:43:34.920]                     if ((workers == 1L && !inherits(workers, 
[17:43:34.920]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:34.920]                       if (default_workers) 
[17:43:34.920]                         supportsMulticore(warn = TRUE)
[17:43:34.920]                       return(sequential(..., envir = envir))
[17:43:34.920]                     }
[17:43:34.920]                     oopts <- options(mc.cores = workers)
[17:43:34.920]                     on.exit(options(oopts))
[17:43:34.920]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:34.920]                       envir = envir)
[17:43:34.920]                     if (!future$lazy) 
[17:43:34.920]                       future <- run(future)
[17:43:34.920]                     invisible(future)
[17:43:34.920]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:34.920]                 }
[17:43:34.920]             }
[17:43:34.920]         }
[17:43:34.920]     })
[17:43:34.920]     if (TRUE) {
[17:43:34.920]         base::sink(type = "output", split = FALSE)
[17:43:34.920]         if (TRUE) {
[17:43:34.920]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:34.920]         }
[17:43:34.920]         else {
[17:43:34.920]             ...future.result["stdout"] <- base::list(NULL)
[17:43:34.920]         }
[17:43:34.920]         base::close(...future.stdout)
[17:43:34.920]         ...future.stdout <- NULL
[17:43:34.920]     }
[17:43:34.920]     ...future.result$conditions <- ...future.conditions
[17:43:34.920]     ...future.result$finished <- base::Sys.time()
[17:43:34.920]     ...future.result
[17:43:34.920] }
[17:43:34.923] requestCore(): workers = 2
[17:43:34.923] Poll #1 (0): usedCores() = 2, workers = 2
[17:43:34.937] MulticoreFuture started
[17:43:34.937] - Launch lazy future ... done
[17:43:34.938] run() for ‘MulticoreFuture’ ... done
[17:43:34.938] getGlobalsAndPackages() ...
[17:43:34.938] plan(): Setting new future strategy stack:
[17:43:34.938] Searching for globals...
[17:43:34.938] List of future strategies:
[17:43:34.938] 1. sequential:
[17:43:34.938]    - args: function (..., envir = parent.frame())
[17:43:34.938]    - tweaked: FALSE
[17:43:34.938]    - call: NULL
[17:43:34.939] plan(): nbrOfWorkers() = 1
[17:43:34.941] - globals found: [2] ‘{’, ‘Sys.sleep’
[17:43:34.941] Searching for globals ... DONE
[17:43:34.941] Resolving globals: FALSE
[17:43:34.941] plan(): Setting new future strategy stack:
[17:43:34.942] 
[17:43:34.942] 
[17:43:34.942] List of future strategies:
[17:43:34.942] 1. multicore:
[17:43:34.942]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:34.942]    - tweaked: FALSE
[17:43:34.942]    - call: plan(strategy)
[17:43:34.942] getGlobalsAndPackages() ... DONE
[17:43:34.943] run() for ‘Future’ ...
[17:43:34.943] - state: ‘created’
[17:43:34.943] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:34.947] plan(): nbrOfWorkers() = 2
[17:43:34.949] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:34.949] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:34.949]   - Field: ‘label’
[17:43:34.949]   - Field: ‘local’
[17:43:34.949]   - Field: ‘owner’
[17:43:34.950]   - Field: ‘envir’
[17:43:34.950]   - Field: ‘workers’
[17:43:34.950]   - Field: ‘packages’
[17:43:34.950]   - Field: ‘gc’
[17:43:34.950]   - Field: ‘job’
[17:43:34.950]   - Field: ‘conditions’
[17:43:34.951]   - Field: ‘expr’
[17:43:34.951]   - Field: ‘uuid’
[17:43:34.951]   - Field: ‘seed’
[17:43:34.951]   - Field: ‘version’
[17:43:34.951]   - Field: ‘result’
[17:43:34.951]   - Field: ‘asynchronous’
[17:43:34.952]   - Field: ‘calls’
[17:43:34.952]   - Field: ‘globals’
[17:43:34.952]   - Field: ‘stdout’
[17:43:34.952]   - Field: ‘earlySignal’
[17:43:34.952]   - Field: ‘lazy’
[17:43:34.953]   - Field: ‘state’
[17:43:34.953] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:34.953] - Launch lazy future ...
[17:43:34.953] Packages needed by the future expression (n = 0): <none>
[17:43:34.954] Packages needed by future strategies (n = 0): <none>
[17:43:34.954] {
[17:43:34.954]     {
[17:43:34.954]         {
[17:43:34.954]             ...future.startTime <- base::Sys.time()
[17:43:34.954]             {
[17:43:34.954]                 {
[17:43:34.954]                   {
[17:43:34.954]                     {
[17:43:34.954]                       base::local({
[17:43:34.954]                         has_future <- base::requireNamespace("future", 
[17:43:34.954]                           quietly = TRUE)
[17:43:34.954]                         if (has_future) {
[17:43:34.954]                           ns <- base::getNamespace("future")
[17:43:34.954]                           version <- ns[[".package"]][["version"]]
[17:43:34.954]                           if (is.null(version)) 
[17:43:34.954]                             version <- utils::packageVersion("future")
[17:43:34.954]                         }
[17:43:34.954]                         else {
[17:43:34.954]                           version <- NULL
[17:43:34.954]                         }
[17:43:34.954]                         if (!has_future || version < "1.8.0") {
[17:43:34.954]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:34.954]                             "", base::R.version$version.string), 
[17:43:34.954]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:34.954]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:34.954]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:34.954]                               "release", "version")], collapse = " "), 
[17:43:34.954]                             hostname = base::Sys.info()[["nodename"]])
[17:43:34.954]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:34.954]                             info)
[17:43:34.954]                           info <- base::paste(info, collapse = "; ")
[17:43:34.954]                           if (!has_future) {
[17:43:34.954]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:34.954]                               info)
[17:43:34.954]                           }
[17:43:34.954]                           else {
[17:43:34.954]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:34.954]                               info, version)
[17:43:34.954]                           }
[17:43:34.954]                           base::stop(msg)
[17:43:34.954]                         }
[17:43:34.954]                       })
[17:43:34.954]                     }
[17:43:34.954]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:34.954]                     base::options(mc.cores = 1L)
[17:43:34.954]                   }
[17:43:34.954]                   options(future.plan = NULL)
[17:43:34.954]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:34.954]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:34.954]                 }
[17:43:34.954]                 ...future.workdir <- getwd()
[17:43:34.954]             }
[17:43:34.954]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:34.954]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:34.954]         }
[17:43:34.954]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:34.954]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:34.954]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:34.954]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:34.954]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:34.954]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:34.954]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:34.954]             base::names(...future.oldOptions))
[17:43:34.954]     }
[17:43:34.954]     if (FALSE) {
[17:43:34.954]     }
[17:43:34.954]     else {
[17:43:34.954]         if (TRUE) {
[17:43:34.954]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:34.954]                 open = "w")
[17:43:34.954]         }
[17:43:34.954]         else {
[17:43:34.954]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:34.954]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:34.954]         }
[17:43:34.954]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:34.954]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:34.954]             base::sink(type = "output", split = FALSE)
[17:43:34.954]             base::close(...future.stdout)
[17:43:34.954]         }, add = TRUE)
[17:43:34.954]     }
[17:43:34.954]     ...future.frame <- base::sys.nframe()
[17:43:34.954]     ...future.conditions <- base::list()
[17:43:34.954]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:34.954]     if (FALSE) {
[17:43:34.954]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:34.954]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:34.954]     }
[17:43:34.954]     ...future.result <- base::tryCatch({
[17:43:34.954]         base::withCallingHandlers({
[17:43:34.954]             ...future.value <- base::withVisible(base::local({
[17:43:34.954]                 withCallingHandlers({
[17:43:34.954]                   {
[17:43:34.954]                     Sys.sleep(0.5)
[17:43:34.954]                     2
[17:43:34.954]                   }
[17:43:34.954]                 }, immediateCondition = function(cond) {
[17:43:34.954]                   save_rds <- function (object, pathname, ...) 
[17:43:34.954]                   {
[17:43:34.954]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:34.954]                     if (file_test("-f", pathname_tmp)) {
[17:43:34.954]                       fi_tmp <- file.info(pathname_tmp)
[17:43:34.954]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:34.954]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:34.954]                         fi_tmp[["mtime"]])
[17:43:34.954]                     }
[17:43:34.954]                     tryCatch({
[17:43:34.954]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:34.954]                     }, error = function(ex) {
[17:43:34.954]                       msg <- conditionMessage(ex)
[17:43:34.954]                       fi_tmp <- file.info(pathname_tmp)
[17:43:34.954]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:34.954]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:34.954]                         fi_tmp[["mtime"]], msg)
[17:43:34.954]                       ex$message <- msg
[17:43:34.954]                       stop(ex)
[17:43:34.954]                     })
[17:43:34.954]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:34.954]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:34.954]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:34.954]                       fi_tmp <- file.info(pathname_tmp)
[17:43:34.954]                       fi <- file.info(pathname)
[17:43:34.954]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:34.954]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:34.954]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:34.954]                         fi[["size"]], fi[["mtime"]])
[17:43:34.954]                       stop(msg)
[17:43:34.954]                     }
[17:43:34.954]                     invisible(pathname)
[17:43:34.954]                   }
[17:43:34.954]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:34.954]                     rootPath = tempdir()) 
[17:43:34.954]                   {
[17:43:34.954]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:34.954]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:34.954]                       tmpdir = path, fileext = ".rds")
[17:43:34.954]                     save_rds(obj, file)
[17:43:34.954]                   }
[17:43:34.954]                   saveImmediateCondition(cond, path = "/tmp/RtmpLaOb2h/.future/immediateConditions")
[17:43:34.954]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:34.954]                   {
[17:43:34.954]                     inherits <- base::inherits
[17:43:34.954]                     invokeRestart <- base::invokeRestart
[17:43:34.954]                     is.null <- base::is.null
[17:43:34.954]                     muffled <- FALSE
[17:43:34.954]                     if (inherits(cond, "message")) {
[17:43:34.954]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:34.954]                       if (muffled) 
[17:43:34.954]                         invokeRestart("muffleMessage")
[17:43:34.954]                     }
[17:43:34.954]                     else if (inherits(cond, "warning")) {
[17:43:34.954]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:34.954]                       if (muffled) 
[17:43:34.954]                         invokeRestart("muffleWarning")
[17:43:34.954]                     }
[17:43:34.954]                     else if (inherits(cond, "condition")) {
[17:43:34.954]                       if (!is.null(pattern)) {
[17:43:34.954]                         computeRestarts <- base::computeRestarts
[17:43:34.954]                         grepl <- base::grepl
[17:43:34.954]                         restarts <- computeRestarts(cond)
[17:43:34.954]                         for (restart in restarts) {
[17:43:34.954]                           name <- restart$name
[17:43:34.954]                           if (is.null(name)) 
[17:43:34.954]                             next
[17:43:34.954]                           if (!grepl(pattern, name)) 
[17:43:34.954]                             next
[17:43:34.954]                           invokeRestart(restart)
[17:43:34.954]                           muffled <- TRUE
[17:43:34.954]                           break
[17:43:34.954]                         }
[17:43:34.954]                       }
[17:43:34.954]                     }
[17:43:34.954]                     invisible(muffled)
[17:43:34.954]                   }
[17:43:34.954]                   muffleCondition(cond)
[17:43:34.954]                 })
[17:43:34.954]             }))
[17:43:34.954]             future::FutureResult(value = ...future.value$value, 
[17:43:34.954]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:34.954]                   ...future.rng), globalenv = if (FALSE) 
[17:43:34.954]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:34.954]                     ...future.globalenv.names))
[17:43:34.954]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:34.954]         }, condition = base::local({
[17:43:34.954]             c <- base::c
[17:43:34.954]             inherits <- base::inherits
[17:43:34.954]             invokeRestart <- base::invokeRestart
[17:43:34.954]             length <- base::length
[17:43:34.954]             list <- base::list
[17:43:34.954]             seq.int <- base::seq.int
[17:43:34.954]             signalCondition <- base::signalCondition
[17:43:34.954]             sys.calls <- base::sys.calls
[17:43:34.954]             `[[` <- base::`[[`
[17:43:34.954]             `+` <- base::`+`
[17:43:34.954]             `<<-` <- base::`<<-`
[17:43:34.954]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:34.954]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:34.954]                   3L)]
[17:43:34.954]             }
[17:43:34.954]             function(cond) {
[17:43:34.954]                 is_error <- inherits(cond, "error")
[17:43:34.954]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:34.954]                   NULL)
[17:43:34.954]                 if (is_error) {
[17:43:34.954]                   sessionInformation <- function() {
[17:43:34.954]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:34.954]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:34.954]                       search = base::search(), system = base::Sys.info())
[17:43:34.954]                   }
[17:43:34.954]                   ...future.conditions[[length(...future.conditions) + 
[17:43:34.954]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:34.954]                     cond$call), session = sessionInformation(), 
[17:43:34.954]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:34.954]                   signalCondition(cond)
[17:43:34.954]                 }
[17:43:34.954]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:34.954]                 "immediateCondition"))) {
[17:43:34.954]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:34.954]                   ...future.conditions[[length(...future.conditions) + 
[17:43:34.954]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:34.954]                   if (TRUE && !signal) {
[17:43:34.954]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:34.954]                     {
[17:43:34.954]                       inherits <- base::inherits
[17:43:34.954]                       invokeRestart <- base::invokeRestart
[17:43:34.954]                       is.null <- base::is.null
[17:43:34.954]                       muffled <- FALSE
[17:43:34.954]                       if (inherits(cond, "message")) {
[17:43:34.954]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:34.954]                         if (muffled) 
[17:43:34.954]                           invokeRestart("muffleMessage")
[17:43:34.954]                       }
[17:43:34.954]                       else if (inherits(cond, "warning")) {
[17:43:34.954]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:34.954]                         if (muffled) 
[17:43:34.954]                           invokeRestart("muffleWarning")
[17:43:34.954]                       }
[17:43:34.954]                       else if (inherits(cond, "condition")) {
[17:43:34.954]                         if (!is.null(pattern)) {
[17:43:34.954]                           computeRestarts <- base::computeRestarts
[17:43:34.954]                           grepl <- base::grepl
[17:43:34.954]                           restarts <- computeRestarts(cond)
[17:43:34.954]                           for (restart in restarts) {
[17:43:34.954]                             name <- restart$name
[17:43:34.954]                             if (is.null(name)) 
[17:43:34.954]                               next
[17:43:34.954]                             if (!grepl(pattern, name)) 
[17:43:34.954]                               next
[17:43:34.954]                             invokeRestart(restart)
[17:43:34.954]                             muffled <- TRUE
[17:43:34.954]                             break
[17:43:34.954]                           }
[17:43:34.954]                         }
[17:43:34.954]                       }
[17:43:34.954]                       invisible(muffled)
[17:43:34.954]                     }
[17:43:34.954]                     muffleCondition(cond, pattern = "^muffle")
[17:43:34.954]                   }
[17:43:34.954]                 }
[17:43:34.954]                 else {
[17:43:34.954]                   if (TRUE) {
[17:43:34.954]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:34.954]                     {
[17:43:34.954]                       inherits <- base::inherits
[17:43:34.954]                       invokeRestart <- base::invokeRestart
[17:43:34.954]                       is.null <- base::is.null
[17:43:34.954]                       muffled <- FALSE
[17:43:34.954]                       if (inherits(cond, "message")) {
[17:43:34.954]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:34.954]                         if (muffled) 
[17:43:34.954]                           invokeRestart("muffleMessage")
[17:43:34.954]                       }
[17:43:34.954]                       else if (inherits(cond, "warning")) {
[17:43:34.954]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:34.954]                         if (muffled) 
[17:43:34.954]                           invokeRestart("muffleWarning")
[17:43:34.954]                       }
[17:43:34.954]                       else if (inherits(cond, "condition")) {
[17:43:34.954]                         if (!is.null(pattern)) {
[17:43:34.954]                           computeRestarts <- base::computeRestarts
[17:43:34.954]                           grepl <- base::grepl
[17:43:34.954]                           restarts <- computeRestarts(cond)
[17:43:34.954]                           for (restart in restarts) {
[17:43:34.954]                             name <- restart$name
[17:43:34.954]                             if (is.null(name)) 
[17:43:34.954]                               next
[17:43:34.954]                             if (!grepl(pattern, name)) 
[17:43:34.954]                               next
[17:43:34.954]                             invokeRestart(restart)
[17:43:34.954]                             muffled <- TRUE
[17:43:34.954]                             break
[17:43:34.954]                           }
[17:43:34.954]                         }
[17:43:34.954]                       }
[17:43:34.954]                       invisible(muffled)
[17:43:34.954]                     }
[17:43:34.954]                     muffleCondition(cond, pattern = "^muffle")
[17:43:34.954]                   }
[17:43:34.954]                 }
[17:43:34.954]             }
[17:43:34.954]         }))
[17:43:34.954]     }, error = function(ex) {
[17:43:34.954]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:34.954]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:34.954]                 ...future.rng), started = ...future.startTime, 
[17:43:34.954]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:34.954]             version = "1.8"), class = "FutureResult")
[17:43:34.954]     }, finally = {
[17:43:34.954]         if (!identical(...future.workdir, getwd())) 
[17:43:34.954]             setwd(...future.workdir)
[17:43:34.954]         {
[17:43:34.954]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:34.954]                 ...future.oldOptions$nwarnings <- NULL
[17:43:34.954]             }
[17:43:34.954]             base::options(...future.oldOptions)
[17:43:34.954]             if (.Platform$OS.type == "windows") {
[17:43:34.954]                 old_names <- names(...future.oldEnvVars)
[17:43:34.954]                 envs <- base::Sys.getenv()
[17:43:34.954]                 names <- names(envs)
[17:43:34.954]                 common <- intersect(names, old_names)
[17:43:34.954]                 added <- setdiff(names, old_names)
[17:43:34.954]                 removed <- setdiff(old_names, names)
[17:43:34.954]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:34.954]                   envs[common]]
[17:43:34.954]                 NAMES <- toupper(changed)
[17:43:34.954]                 args <- list()
[17:43:34.954]                 for (kk in seq_along(NAMES)) {
[17:43:34.954]                   name <- changed[[kk]]
[17:43:34.954]                   NAME <- NAMES[[kk]]
[17:43:34.954]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.954]                     next
[17:43:34.954]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:34.954]                 }
[17:43:34.954]                 NAMES <- toupper(added)
[17:43:34.954]                 for (kk in seq_along(NAMES)) {
[17:43:34.954]                   name <- added[[kk]]
[17:43:34.954]                   NAME <- NAMES[[kk]]
[17:43:34.954]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.954]                     next
[17:43:34.954]                   args[[name]] <- ""
[17:43:34.954]                 }
[17:43:34.954]                 NAMES <- toupper(removed)
[17:43:34.954]                 for (kk in seq_along(NAMES)) {
[17:43:34.954]                   name <- removed[[kk]]
[17:43:34.954]                   NAME <- NAMES[[kk]]
[17:43:34.954]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:34.954]                     next
[17:43:34.954]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:34.954]                 }
[17:43:34.954]                 if (length(args) > 0) 
[17:43:34.954]                   base::do.call(base::Sys.setenv, args = args)
[17:43:34.954]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:34.954]             }
[17:43:34.954]             else {
[17:43:34.954]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:34.954]             }
[17:43:34.954]             {
[17:43:34.954]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:34.954]                   0L) {
[17:43:34.954]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:34.954]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:34.954]                   base::options(opts)
[17:43:34.954]                 }
[17:43:34.954]                 {
[17:43:34.954]                   {
[17:43:34.954]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:34.954]                     NULL
[17:43:34.954]                   }
[17:43:34.954]                   options(future.plan = NULL)
[17:43:34.954]                   if (is.na(NA_character_)) 
[17:43:34.954]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:34.954]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:34.954]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:43:34.954]                     envir = parent.frame()) 
[17:43:34.954]                   {
[17:43:34.954]                     default_workers <- missing(workers)
[17:43:34.954]                     if (is.function(workers)) 
[17:43:34.954]                       workers <- workers()
[17:43:34.954]                     workers <- structure(as.integer(workers), 
[17:43:34.954]                       class = class(workers))
[17:43:34.954]                     stop_if_not(is.finite(workers), workers >= 
[17:43:34.954]                       1L)
[17:43:34.954]                     if ((workers == 1L && !inherits(workers, 
[17:43:34.954]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:34.954]                       if (default_workers) 
[17:43:34.954]                         supportsMulticore(warn = TRUE)
[17:43:34.954]                       return(sequential(..., envir = envir))
[17:43:34.954]                     }
[17:43:34.954]                     oopts <- options(mc.cores = workers)
[17:43:34.954]                     on.exit(options(oopts))
[17:43:34.954]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:34.954]                       envir = envir)
[17:43:34.954]                     if (!future$lazy) 
[17:43:34.954]                       future <- run(future)
[17:43:34.954]                     invisible(future)
[17:43:34.954]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:34.954]                 }
[17:43:34.954]             }
[17:43:34.954]         }
[17:43:34.954]     })
[17:43:34.954]     if (TRUE) {
[17:43:34.954]         base::sink(type = "output", split = FALSE)
[17:43:34.954]         if (TRUE) {
[17:43:34.954]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:34.954]         }
[17:43:34.954]         else {
[17:43:34.954]             ...future.result["stdout"] <- base::list(NULL)
[17:43:34.954]         }
[17:43:34.954]         base::close(...future.stdout)
[17:43:34.954]         ...future.stdout <- NULL
[17:43:34.954]     }
[17:43:34.954]     ...future.result$conditions <- ...future.conditions
[17:43:34.954]     ...future.result$finished <- base::Sys.time()
[17:43:34.954]     ...future.result
[17:43:34.954] }
[17:43:34.958] requestCore(): workers = 2
[17:43:34.958] Poll #1 (0): usedCores() = 2, workers = 2
[17:43:34.973] MulticoreFuture started
[17:43:34.974] - Launch lazy future ... done
[17:43:34.974] run() for ‘MulticoreFuture’ ... done
[17:43:34.974] plan(): Setting new future strategy stack:
[17:43:34.975] resolve() on list ...
[17:43:34.975]  recursive: 0
[17:43:34.975]  length: 1
[17:43:34.975] 
[17:43:34.974] List of future strategies:
[17:43:34.974] 1. sequential:
[17:43:34.974]    - args: function (..., envir = parent.frame())
[17:43:34.974]    - tweaked: FALSE
[17:43:34.974]    - call: NULL
[17:43:34.976] plan(): nbrOfWorkers() = 1
[17:43:34.976] Future #1
[17:43:34.976]  length: 0 (resolved future 1)
[17:43:34.976] resolve() on list ... DONE
[17:43:34.977] resolve() on list ...
[17:43:34.977]  recursive: 0
[17:43:34.977]  length: 1
[17:43:34.977] 
[17:43:35.479] plan(): Setting new future strategy stack:
[17:43:35.479] List of future strategies:
[17:43:35.479] 1. multicore:
[17:43:35.479]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:35.479]    - tweaked: FALSE
[17:43:35.479]    - call: plan(strategy)
[17:43:35.484] plan(): nbrOfWorkers() = 2
[17:43:35.489] Future #1
[17:43:35.489]  length: 0 (resolved future 1)
[17:43:35.489] resolve() on list ... DONE
[17:43:35.490] resolve() on list ...
[17:43:35.490]  recursive: 0
[17:43:35.490]  length: 1
[17:43:35.490] 
[17:43:35.490]  length: 0 (resolved future 1)
[17:43:35.491] resolve() on list ... DONE
[17:43:35.491] resolve() on list ...
[17:43:35.491]  recursive: 0
[17:43:35.491]  length: 4
[17:43:35.491] 
[17:43:35.492] Future #1
[17:43:35.492]  length: 3 (resolved future 1)
[17:43:35.492] Future #2
[17:43:35.492]  length: 2 (resolved future 2)
[17:43:35.493]  length: 1 (resolved future 3)
[17:43:35.493]  length: 0 (resolved future 4)
[17:43:35.493] resolve() on list ... DONE
[17:43:35.493] resolve() on list ...
[17:43:35.493]  recursive: 0
[17:43:35.494]  length: 4
[17:43:35.494] 
[17:43:35.494] Future #1
[17:43:35.494]  length: 3 (resolved future 1)
[17:43:35.494] Future #2
[17:43:35.495]  length: 2 (resolved future 2)
[17:43:35.495]  length: 1 (resolved future 3)
[17:43:35.495]  length: 0 (resolved future 4)
[17:43:35.495] resolve() on list ... DONE
[17:43:35.495] resolve() on list ...
[17:43:35.496]  recursive: 0
[17:43:35.496]  length: 1
[17:43:35.496] 
[17:43:35.500]  length: 0 (resolved future 1)
[17:43:35.500] resolve() on list ... DONE
[17:43:35.501] getGlobalsAndPackages() ...
[17:43:35.501] Searching for globals...
[17:43:35.505] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:43:35.505] Searching for globals ... DONE
[17:43:35.505] Resolving globals: FALSE
[17:43:35.506] The total size of the 1 globals is 56 bytes (56 bytes)
[17:43:35.506] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:43:35.506] - globals: [1] ‘kk’
[17:43:35.507] 
[17:43:35.507] getGlobalsAndPackages() ... DONE
[17:43:35.507] run() for ‘Future’ ...
[17:43:35.507] - state: ‘created’
[17:43:35.508] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:35.512] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:35.512] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:35.513]   - Field: ‘label’
[17:43:35.513]   - Field: ‘local’
[17:43:35.513]   - Field: ‘owner’
[17:43:35.513]   - Field: ‘envir’
[17:43:35.514]   - Field: ‘workers’
[17:43:35.514]   - Field: ‘packages’
[17:43:35.514]   - Field: ‘gc’
[17:43:35.514]   - Field: ‘job’
[17:43:35.514]   - Field: ‘conditions’
[17:43:35.514]   - Field: ‘expr’
[17:43:35.515]   - Field: ‘uuid’
[17:43:35.515]   - Field: ‘seed’
[17:43:35.515]   - Field: ‘version’
[17:43:35.515]   - Field: ‘result’
[17:43:35.515]   - Field: ‘asynchronous’
[17:43:35.515]   - Field: ‘calls’
[17:43:35.516]   - Field: ‘globals’
[17:43:35.516]   - Field: ‘stdout’
[17:43:35.516]   - Field: ‘earlySignal’
[17:43:35.516]   - Field: ‘lazy’
[17:43:35.516]   - Field: ‘state’
[17:43:35.516] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:35.516] - Launch lazy future ...
[17:43:35.517] Packages needed by the future expression (n = 0): <none>
[17:43:35.517] Packages needed by future strategies (n = 0): <none>
[17:43:35.518] {
[17:43:35.518]     {
[17:43:35.518]         {
[17:43:35.518]             ...future.startTime <- base::Sys.time()
[17:43:35.518]             {
[17:43:35.518]                 {
[17:43:35.518]                   {
[17:43:35.518]                     {
[17:43:35.518]                       base::local({
[17:43:35.518]                         has_future <- base::requireNamespace("future", 
[17:43:35.518]                           quietly = TRUE)
[17:43:35.518]                         if (has_future) {
[17:43:35.518]                           ns <- base::getNamespace("future")
[17:43:35.518]                           version <- ns[[".package"]][["version"]]
[17:43:35.518]                           if (is.null(version)) 
[17:43:35.518]                             version <- utils::packageVersion("future")
[17:43:35.518]                         }
[17:43:35.518]                         else {
[17:43:35.518]                           version <- NULL
[17:43:35.518]                         }
[17:43:35.518]                         if (!has_future || version < "1.8.0") {
[17:43:35.518]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:35.518]                             "", base::R.version$version.string), 
[17:43:35.518]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:35.518]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:35.518]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:35.518]                               "release", "version")], collapse = " "), 
[17:43:35.518]                             hostname = base::Sys.info()[["nodename"]])
[17:43:35.518]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:35.518]                             info)
[17:43:35.518]                           info <- base::paste(info, collapse = "; ")
[17:43:35.518]                           if (!has_future) {
[17:43:35.518]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:35.518]                               info)
[17:43:35.518]                           }
[17:43:35.518]                           else {
[17:43:35.518]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:35.518]                               info, version)
[17:43:35.518]                           }
[17:43:35.518]                           base::stop(msg)
[17:43:35.518]                         }
[17:43:35.518]                       })
[17:43:35.518]                     }
[17:43:35.518]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:35.518]                     base::options(mc.cores = 1L)
[17:43:35.518]                   }
[17:43:35.518]                   options(future.plan = NULL)
[17:43:35.518]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:35.518]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:35.518]                 }
[17:43:35.518]                 ...future.workdir <- getwd()
[17:43:35.518]             }
[17:43:35.518]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:35.518]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:35.518]         }
[17:43:35.518]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:35.518]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:35.518]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:35.518]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:35.518]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:35.518]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:35.518]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:35.518]             base::names(...future.oldOptions))
[17:43:35.518]     }
[17:43:35.518]     if (FALSE) {
[17:43:35.518]     }
[17:43:35.518]     else {
[17:43:35.518]         if (TRUE) {
[17:43:35.518]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:35.518]                 open = "w")
[17:43:35.518]         }
[17:43:35.518]         else {
[17:43:35.518]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:35.518]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:35.518]         }
[17:43:35.518]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:35.518]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:35.518]             base::sink(type = "output", split = FALSE)
[17:43:35.518]             base::close(...future.stdout)
[17:43:35.518]         }, add = TRUE)
[17:43:35.518]     }
[17:43:35.518]     ...future.frame <- base::sys.nframe()
[17:43:35.518]     ...future.conditions <- base::list()
[17:43:35.518]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:35.518]     if (FALSE) {
[17:43:35.518]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:35.518]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:35.518]     }
[17:43:35.518]     ...future.result <- base::tryCatch({
[17:43:35.518]         base::withCallingHandlers({
[17:43:35.518]             ...future.value <- base::withVisible(base::local({
[17:43:35.518]                 withCallingHandlers({
[17:43:35.518]                   {
[17:43:35.518]                     Sys.sleep(0.1)
[17:43:35.518]                     kk
[17:43:35.518]                   }
[17:43:35.518]                 }, immediateCondition = function(cond) {
[17:43:35.518]                   save_rds <- function (object, pathname, ...) 
[17:43:35.518]                   {
[17:43:35.518]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:35.518]                     if (file_test("-f", pathname_tmp)) {
[17:43:35.518]                       fi_tmp <- file.info(pathname_tmp)
[17:43:35.518]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:35.518]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:35.518]                         fi_tmp[["mtime"]])
[17:43:35.518]                     }
[17:43:35.518]                     tryCatch({
[17:43:35.518]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:35.518]                     }, error = function(ex) {
[17:43:35.518]                       msg <- conditionMessage(ex)
[17:43:35.518]                       fi_tmp <- file.info(pathname_tmp)
[17:43:35.518]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:35.518]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:35.518]                         fi_tmp[["mtime"]], msg)
[17:43:35.518]                       ex$message <- msg
[17:43:35.518]                       stop(ex)
[17:43:35.518]                     })
[17:43:35.518]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:35.518]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:35.518]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:35.518]                       fi_tmp <- file.info(pathname_tmp)
[17:43:35.518]                       fi <- file.info(pathname)
[17:43:35.518]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:35.518]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:35.518]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:35.518]                         fi[["size"]], fi[["mtime"]])
[17:43:35.518]                       stop(msg)
[17:43:35.518]                     }
[17:43:35.518]                     invisible(pathname)
[17:43:35.518]                   }
[17:43:35.518]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:35.518]                     rootPath = tempdir()) 
[17:43:35.518]                   {
[17:43:35.518]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:35.518]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:35.518]                       tmpdir = path, fileext = ".rds")
[17:43:35.518]                     save_rds(obj, file)
[17:43:35.518]                   }
[17:43:35.518]                   saveImmediateCondition(cond, path = "/tmp/RtmpLaOb2h/.future/immediateConditions")
[17:43:35.518]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:35.518]                   {
[17:43:35.518]                     inherits <- base::inherits
[17:43:35.518]                     invokeRestart <- base::invokeRestart
[17:43:35.518]                     is.null <- base::is.null
[17:43:35.518]                     muffled <- FALSE
[17:43:35.518]                     if (inherits(cond, "message")) {
[17:43:35.518]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:35.518]                       if (muffled) 
[17:43:35.518]                         invokeRestart("muffleMessage")
[17:43:35.518]                     }
[17:43:35.518]                     else if (inherits(cond, "warning")) {
[17:43:35.518]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:35.518]                       if (muffled) 
[17:43:35.518]                         invokeRestart("muffleWarning")
[17:43:35.518]                     }
[17:43:35.518]                     else if (inherits(cond, "condition")) {
[17:43:35.518]                       if (!is.null(pattern)) {
[17:43:35.518]                         computeRestarts <- base::computeRestarts
[17:43:35.518]                         grepl <- base::grepl
[17:43:35.518]                         restarts <- computeRestarts(cond)
[17:43:35.518]                         for (restart in restarts) {
[17:43:35.518]                           name <- restart$name
[17:43:35.518]                           if (is.null(name)) 
[17:43:35.518]                             next
[17:43:35.518]                           if (!grepl(pattern, name)) 
[17:43:35.518]                             next
[17:43:35.518]                           invokeRestart(restart)
[17:43:35.518]                           muffled <- TRUE
[17:43:35.518]                           break
[17:43:35.518]                         }
[17:43:35.518]                       }
[17:43:35.518]                     }
[17:43:35.518]                     invisible(muffled)
[17:43:35.518]                   }
[17:43:35.518]                   muffleCondition(cond)
[17:43:35.518]                 })
[17:43:35.518]             }))
[17:43:35.518]             future::FutureResult(value = ...future.value$value, 
[17:43:35.518]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:35.518]                   ...future.rng), globalenv = if (FALSE) 
[17:43:35.518]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:35.518]                     ...future.globalenv.names))
[17:43:35.518]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:35.518]         }, condition = base::local({
[17:43:35.518]             c <- base::c
[17:43:35.518]             inherits <- base::inherits
[17:43:35.518]             invokeRestart <- base::invokeRestart
[17:43:35.518]             length <- base::length
[17:43:35.518]             list <- base::list
[17:43:35.518]             seq.int <- base::seq.int
[17:43:35.518]             signalCondition <- base::signalCondition
[17:43:35.518]             sys.calls <- base::sys.calls
[17:43:35.518]             `[[` <- base::`[[`
[17:43:35.518]             `+` <- base::`+`
[17:43:35.518]             `<<-` <- base::`<<-`
[17:43:35.518]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:35.518]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:35.518]                   3L)]
[17:43:35.518]             }
[17:43:35.518]             function(cond) {
[17:43:35.518]                 is_error <- inherits(cond, "error")
[17:43:35.518]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:35.518]                   NULL)
[17:43:35.518]                 if (is_error) {
[17:43:35.518]                   sessionInformation <- function() {
[17:43:35.518]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:35.518]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:35.518]                       search = base::search(), system = base::Sys.info())
[17:43:35.518]                   }
[17:43:35.518]                   ...future.conditions[[length(...future.conditions) + 
[17:43:35.518]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:35.518]                     cond$call), session = sessionInformation(), 
[17:43:35.518]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:35.518]                   signalCondition(cond)
[17:43:35.518]                 }
[17:43:35.518]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:35.518]                 "immediateCondition"))) {
[17:43:35.518]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:35.518]                   ...future.conditions[[length(...future.conditions) + 
[17:43:35.518]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:35.518]                   if (TRUE && !signal) {
[17:43:35.518]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:35.518]                     {
[17:43:35.518]                       inherits <- base::inherits
[17:43:35.518]                       invokeRestart <- base::invokeRestart
[17:43:35.518]                       is.null <- base::is.null
[17:43:35.518]                       muffled <- FALSE
[17:43:35.518]                       if (inherits(cond, "message")) {
[17:43:35.518]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:35.518]                         if (muffled) 
[17:43:35.518]                           invokeRestart("muffleMessage")
[17:43:35.518]                       }
[17:43:35.518]                       else if (inherits(cond, "warning")) {
[17:43:35.518]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:35.518]                         if (muffled) 
[17:43:35.518]                           invokeRestart("muffleWarning")
[17:43:35.518]                       }
[17:43:35.518]                       else if (inherits(cond, "condition")) {
[17:43:35.518]                         if (!is.null(pattern)) {
[17:43:35.518]                           computeRestarts <- base::computeRestarts
[17:43:35.518]                           grepl <- base::grepl
[17:43:35.518]                           restarts <- computeRestarts(cond)
[17:43:35.518]                           for (restart in restarts) {
[17:43:35.518]                             name <- restart$name
[17:43:35.518]                             if (is.null(name)) 
[17:43:35.518]                               next
[17:43:35.518]                             if (!grepl(pattern, name)) 
[17:43:35.518]                               next
[17:43:35.518]                             invokeRestart(restart)
[17:43:35.518]                             muffled <- TRUE
[17:43:35.518]                             break
[17:43:35.518]                           }
[17:43:35.518]                         }
[17:43:35.518]                       }
[17:43:35.518]                       invisible(muffled)
[17:43:35.518]                     }
[17:43:35.518]                     muffleCondition(cond, pattern = "^muffle")
[17:43:35.518]                   }
[17:43:35.518]                 }
[17:43:35.518]                 else {
[17:43:35.518]                   if (TRUE) {
[17:43:35.518]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:35.518]                     {
[17:43:35.518]                       inherits <- base::inherits
[17:43:35.518]                       invokeRestart <- base::invokeRestart
[17:43:35.518]                       is.null <- base::is.null
[17:43:35.518]                       muffled <- FALSE
[17:43:35.518]                       if (inherits(cond, "message")) {
[17:43:35.518]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:35.518]                         if (muffled) 
[17:43:35.518]                           invokeRestart("muffleMessage")
[17:43:35.518]                       }
[17:43:35.518]                       else if (inherits(cond, "warning")) {
[17:43:35.518]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:35.518]                         if (muffled) 
[17:43:35.518]                           invokeRestart("muffleWarning")
[17:43:35.518]                       }
[17:43:35.518]                       else if (inherits(cond, "condition")) {
[17:43:35.518]                         if (!is.null(pattern)) {
[17:43:35.518]                           computeRestarts <- base::computeRestarts
[17:43:35.518]                           grepl <- base::grepl
[17:43:35.518]                           restarts <- computeRestarts(cond)
[17:43:35.518]                           for (restart in restarts) {
[17:43:35.518]                             name <- restart$name
[17:43:35.518]                             if (is.null(name)) 
[17:43:35.518]                               next
[17:43:35.518]                             if (!grepl(pattern, name)) 
[17:43:35.518]                               next
[17:43:35.518]                             invokeRestart(restart)
[17:43:35.518]                             muffled <- TRUE
[17:43:35.518]                             break
[17:43:35.518]                           }
[17:43:35.518]                         }
[17:43:35.518]                       }
[17:43:35.518]                       invisible(muffled)
[17:43:35.518]                     }
[17:43:35.518]                     muffleCondition(cond, pattern = "^muffle")
[17:43:35.518]                   }
[17:43:35.518]                 }
[17:43:35.518]             }
[17:43:35.518]         }))
[17:43:35.518]     }, error = function(ex) {
[17:43:35.518]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:35.518]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:35.518]                 ...future.rng), started = ...future.startTime, 
[17:43:35.518]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:35.518]             version = "1.8"), class = "FutureResult")
[17:43:35.518]     }, finally = {
[17:43:35.518]         if (!identical(...future.workdir, getwd())) 
[17:43:35.518]             setwd(...future.workdir)
[17:43:35.518]         {
[17:43:35.518]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:35.518]                 ...future.oldOptions$nwarnings <- NULL
[17:43:35.518]             }
[17:43:35.518]             base::options(...future.oldOptions)
[17:43:35.518]             if (.Platform$OS.type == "windows") {
[17:43:35.518]                 old_names <- names(...future.oldEnvVars)
[17:43:35.518]                 envs <- base::Sys.getenv()
[17:43:35.518]                 names <- names(envs)
[17:43:35.518]                 common <- intersect(names, old_names)
[17:43:35.518]                 added <- setdiff(names, old_names)
[17:43:35.518]                 removed <- setdiff(old_names, names)
[17:43:35.518]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:35.518]                   envs[common]]
[17:43:35.518]                 NAMES <- toupper(changed)
[17:43:35.518]                 args <- list()
[17:43:35.518]                 for (kk in seq_along(NAMES)) {
[17:43:35.518]                   name <- changed[[kk]]
[17:43:35.518]                   NAME <- NAMES[[kk]]
[17:43:35.518]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:35.518]                     next
[17:43:35.518]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:35.518]                 }
[17:43:35.518]                 NAMES <- toupper(added)
[17:43:35.518]                 for (kk in seq_along(NAMES)) {
[17:43:35.518]                   name <- added[[kk]]
[17:43:35.518]                   NAME <- NAMES[[kk]]
[17:43:35.518]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:35.518]                     next
[17:43:35.518]                   args[[name]] <- ""
[17:43:35.518]                 }
[17:43:35.518]                 NAMES <- toupper(removed)
[17:43:35.518]                 for (kk in seq_along(NAMES)) {
[17:43:35.518]                   name <- removed[[kk]]
[17:43:35.518]                   NAME <- NAMES[[kk]]
[17:43:35.518]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:35.518]                     next
[17:43:35.518]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:35.518]                 }
[17:43:35.518]                 if (length(args) > 0) 
[17:43:35.518]                   base::do.call(base::Sys.setenv, args = args)
[17:43:35.518]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:35.518]             }
[17:43:35.518]             else {
[17:43:35.518]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:35.518]             }
[17:43:35.518]             {
[17:43:35.518]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:35.518]                   0L) {
[17:43:35.518]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:35.518]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:35.518]                   base::options(opts)
[17:43:35.518]                 }
[17:43:35.518]                 {
[17:43:35.518]                   {
[17:43:35.518]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:35.518]                     NULL
[17:43:35.518]                   }
[17:43:35.518]                   options(future.plan = NULL)
[17:43:35.518]                   if (is.na(NA_character_)) 
[17:43:35.518]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:35.518]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:35.518]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:43:35.518]                     envir = parent.frame()) 
[17:43:35.518]                   {
[17:43:35.518]                     default_workers <- missing(workers)
[17:43:35.518]                     if (is.function(workers)) 
[17:43:35.518]                       workers <- workers()
[17:43:35.518]                     workers <- structure(as.integer(workers), 
[17:43:35.518]                       class = class(workers))
[17:43:35.518]                     stop_if_not(is.finite(workers), workers >= 
[17:43:35.518]                       1L)
[17:43:35.518]                     if ((workers == 1L && !inherits(workers, 
[17:43:35.518]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:35.518]                       if (default_workers) 
[17:43:35.518]                         supportsMulticore(warn = TRUE)
[17:43:35.518]                       return(sequential(..., envir = envir))
[17:43:35.518]                     }
[17:43:35.518]                     oopts <- options(mc.cores = workers)
[17:43:35.518]                     on.exit(options(oopts))
[17:43:35.518]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:35.518]                       envir = envir)
[17:43:35.518]                     if (!future$lazy) 
[17:43:35.518]                       future <- run(future)
[17:43:35.518]                     invisible(future)
[17:43:35.518]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:35.518]                 }
[17:43:35.518]             }
[17:43:35.518]         }
[17:43:35.518]     })
[17:43:35.518]     if (TRUE) {
[17:43:35.518]         base::sink(type = "output", split = FALSE)
[17:43:35.518]         if (TRUE) {
[17:43:35.518]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:35.518]         }
[17:43:35.518]         else {
[17:43:35.518]             ...future.result["stdout"] <- base::list(NULL)
[17:43:35.518]         }
[17:43:35.518]         base::close(...future.stdout)
[17:43:35.518]         ...future.stdout <- NULL
[17:43:35.518]     }
[17:43:35.518]     ...future.result$conditions <- ...future.conditions
[17:43:35.518]     ...future.result$finished <- base::Sys.time()
[17:43:35.518]     ...future.result
[17:43:35.518] }
[17:43:35.520] assign_globals() ...
[17:43:35.520] List of 1
[17:43:35.520]  $ kk: int 1
[17:43:35.520]  - attr(*, "where")=List of 1
[17:43:35.520]   ..$ kk:<environment: R_EmptyEnv> 
[17:43:35.520]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:35.520]  - attr(*, "resolved")= logi FALSE
[17:43:35.520]  - attr(*, "total_size")= num 56
[17:43:35.520]  - attr(*, "already-done")= logi TRUE
[17:43:35.524] - copied ‘kk’ to environment
[17:43:35.524] assign_globals() ... done
[17:43:35.524] requestCore(): workers = 2
[17:43:35.525] Poll #1 (0): usedCores() = 2, workers = 2
[17:43:35.538] MulticoreFuture started
[17:43:35.539] - Launch lazy future ... done
[17:43:35.539] run() for ‘MulticoreFuture’ ... done
[17:43:35.540] getGlobalsAndPackages() ...
[17:43:35.540] plan(): Setting new future strategy stack:
[17:43:35.540] Searching for globals...
[17:43:35.540] List of future strategies:
[17:43:35.540] 1. sequential:
[17:43:35.540]    - args: function (..., envir = parent.frame())
[17:43:35.540]    - tweaked: FALSE
[17:43:35.540]    - call: NULL
[17:43:35.541] plan(): nbrOfWorkers() = 1
[17:43:35.543] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:43:35.543] Searching for globals ... DONE
[17:43:35.544] Resolving globals: FALSE
[17:43:35.544] The total size of the 1 globals is 56 bytes (56 bytes)
[17:43:35.545] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:43:35.545] - globals: [1] ‘kk’
[17:43:35.546] 
[17:43:35.546] getGlobalsAndPackages() ... DONE
[17:43:35.546] run() for ‘Future’ ...
[17:43:35.546] - state: ‘created’
[17:43:35.547] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:35.551] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:35.552] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:35.552]   - Field: ‘label’
[17:43:35.552]   - Field: ‘local’
[17:43:35.552]   - Field: ‘owner’
[17:43:35.552]   - Field: ‘envir’
[17:43:35.552]   - Field: ‘workers’
[17:43:35.553]   - Field: ‘packages’
[17:43:35.553]   - Field: ‘gc’
[17:43:35.553]   - Field: ‘job’
[17:43:35.553]   - Field: ‘conditions’
[17:43:35.553]   - Field: ‘expr’
[17:43:35.553]   - Field: ‘uuid’
[17:43:35.553]   - Field: ‘seed’
[17:43:35.554]   - Field: ‘version’
[17:43:35.554]   - Field: ‘result’
[17:43:35.554]   - Field: ‘asynchronous’
[17:43:35.554]   - Field: ‘calls’
[17:43:35.554]   - Field: ‘globals’
[17:43:35.554]   - Field: ‘stdout’
[17:43:35.554]   - Field: ‘earlySignal’
[17:43:35.555]   - Field: ‘lazy’
[17:43:35.555]   - Field: ‘state’
[17:43:35.555] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:35.555] - Launch lazy future ...
[17:43:35.556] Packages needed by the future expression (n = 0): <none>
[17:43:35.556] Packages needed by future strategies (n = 0): <none>
[17:43:35.556] {
[17:43:35.556]     {
[17:43:35.556]         {
[17:43:35.556]             ...future.startTime <- base::Sys.time()
[17:43:35.556]             {
[17:43:35.556]                 {
[17:43:35.556]                   {
[17:43:35.556]                     {
[17:43:35.556]                       base::local({
[17:43:35.556]                         has_future <- base::requireNamespace("future", 
[17:43:35.556]                           quietly = TRUE)
[17:43:35.556]                         if (has_future) {
[17:43:35.556]                           ns <- base::getNamespace("future")
[17:43:35.556]                           version <- ns[[".package"]][["version"]]
[17:43:35.556]                           if (is.null(version)) 
[17:43:35.556]                             version <- utils::packageVersion("future")
[17:43:35.556]                         }
[17:43:35.556]                         else {
[17:43:35.556]                           version <- NULL
[17:43:35.556]                         }
[17:43:35.556]                         if (!has_future || version < "1.8.0") {
[17:43:35.556]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:35.556]                             "", base::R.version$version.string), 
[17:43:35.556]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:35.556]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:35.556]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:35.556]                               "release", "version")], collapse = " "), 
[17:43:35.556]                             hostname = base::Sys.info()[["nodename"]])
[17:43:35.556]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:35.556]                             info)
[17:43:35.556]                           info <- base::paste(info, collapse = "; ")
[17:43:35.556]                           if (!has_future) {
[17:43:35.556]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:35.556]                               info)
[17:43:35.556]                           }
[17:43:35.556]                           else {
[17:43:35.556]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:35.556]                               info, version)
[17:43:35.556]                           }
[17:43:35.556]                           base::stop(msg)
[17:43:35.556]                         }
[17:43:35.556]                       })
[17:43:35.556]                     }
[17:43:35.556]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:35.556]                     base::options(mc.cores = 1L)
[17:43:35.556]                   }
[17:43:35.556]                   options(future.plan = NULL)
[17:43:35.556]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:35.556]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:35.556]                 }
[17:43:35.556]                 ...future.workdir <- getwd()
[17:43:35.556]             }
[17:43:35.556]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:35.556]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:35.556]         }
[17:43:35.556]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:35.556]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:35.556]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:35.556]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:35.556]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:35.556]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:35.556]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:35.556]             base::names(...future.oldOptions))
[17:43:35.556]     }
[17:43:35.556]     if (FALSE) {
[17:43:35.556]     }
[17:43:35.556]     else {
[17:43:35.556]         if (TRUE) {
[17:43:35.556]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:35.556]                 open = "w")
[17:43:35.556]         }
[17:43:35.556]         else {
[17:43:35.556]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:35.556]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:35.556]         }
[17:43:35.556]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:35.556]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:35.556]             base::sink(type = "output", split = FALSE)
[17:43:35.556]             base::close(...future.stdout)
[17:43:35.556]         }, add = TRUE)
[17:43:35.556]     }
[17:43:35.556]     ...future.frame <- base::sys.nframe()
[17:43:35.556]     ...future.conditions <- base::list()
[17:43:35.556]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:35.556]     if (FALSE) {
[17:43:35.556]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:35.556]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:35.556]     }
[17:43:35.556]     ...future.result <- base::tryCatch({
[17:43:35.556]         base::withCallingHandlers({
[17:43:35.556]             ...future.value <- base::withVisible(base::local({
[17:43:35.556]                 withCallingHandlers({
[17:43:35.556]                   {
[17:43:35.556]                     Sys.sleep(0.1)
[17:43:35.556]                     kk
[17:43:35.556]                   }
[17:43:35.556]                 }, immediateCondition = function(cond) {
[17:43:35.556]                   save_rds <- function (object, pathname, ...) 
[17:43:35.556]                   {
[17:43:35.556]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:35.556]                     if (file_test("-f", pathname_tmp)) {
[17:43:35.556]                       fi_tmp <- file.info(pathname_tmp)
[17:43:35.556]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:35.556]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:35.556]                         fi_tmp[["mtime"]])
[17:43:35.556]                     }
[17:43:35.556]                     tryCatch({
[17:43:35.556]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:35.556]                     }, error = function(ex) {
[17:43:35.556]                       msg <- conditionMessage(ex)
[17:43:35.556]                       fi_tmp <- file.info(pathname_tmp)
[17:43:35.556]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:35.556]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:35.556]                         fi_tmp[["mtime"]], msg)
[17:43:35.556]                       ex$message <- msg
[17:43:35.556]                       stop(ex)
[17:43:35.556]                     })
[17:43:35.556]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:35.556]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:35.556]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:35.556]                       fi_tmp <- file.info(pathname_tmp)
[17:43:35.556]                       fi <- file.info(pathname)
[17:43:35.556]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:35.556]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:35.556]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:35.556]                         fi[["size"]], fi[["mtime"]])
[17:43:35.556]                       stop(msg)
[17:43:35.556]                     }
[17:43:35.556]                     invisible(pathname)
[17:43:35.556]                   }
[17:43:35.556]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:35.556]                     rootPath = tempdir()) 
[17:43:35.556]                   {
[17:43:35.556]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:35.556]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:35.556]                       tmpdir = path, fileext = ".rds")
[17:43:35.556]                     save_rds(obj, file)
[17:43:35.556]                   }
[17:43:35.556]                   saveImmediateCondition(cond, path = "/tmp/RtmpLaOb2h/.future/immediateConditions")
[17:43:35.556]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:35.556]                   {
[17:43:35.556]                     inherits <- base::inherits
[17:43:35.556]                     invokeRestart <- base::invokeRestart
[17:43:35.556]                     is.null <- base::is.null
[17:43:35.556]                     muffled <- FALSE
[17:43:35.556]                     if (inherits(cond, "message")) {
[17:43:35.556]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:35.556]                       if (muffled) 
[17:43:35.556]                         invokeRestart("muffleMessage")
[17:43:35.556]                     }
[17:43:35.556]                     else if (inherits(cond, "warning")) {
[17:43:35.556]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:35.556]                       if (muffled) 
[17:43:35.556]                         invokeRestart("muffleWarning")
[17:43:35.556]                     }
[17:43:35.556]                     else if (inherits(cond, "condition")) {
[17:43:35.556]                       if (!is.null(pattern)) {
[17:43:35.556]                         computeRestarts <- base::computeRestarts
[17:43:35.556]                         grepl <- base::grepl
[17:43:35.556]                         restarts <- computeRestarts(cond)
[17:43:35.556]                         for (restart in restarts) {
[17:43:35.556]                           name <- restart$name
[17:43:35.556]                           if (is.null(name)) 
[17:43:35.556]                             next
[17:43:35.556]                           if (!grepl(pattern, name)) 
[17:43:35.556]                             next
[17:43:35.556]                           invokeRestart(restart)
[17:43:35.556]                           muffled <- TRUE
[17:43:35.556]                           break
[17:43:35.556]                         }
[17:43:35.556]                       }
[17:43:35.556]                     }
[17:43:35.556]                     invisible(muffled)
[17:43:35.556]                   }
[17:43:35.556]                   muffleCondition(cond)
[17:43:35.556]                 })
[17:43:35.556]             }))
[17:43:35.556]             future::FutureResult(value = ...future.value$value, 
[17:43:35.556]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:35.556]                   ...future.rng), globalenv = if (FALSE) 
[17:43:35.556]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:35.556]                     ...future.globalenv.names))
[17:43:35.556]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:35.556]         }, condition = base::local({
[17:43:35.556]             c <- base::c
[17:43:35.556]             inherits <- base::inherits
[17:43:35.556]             invokeRestart <- base::invokeRestart
[17:43:35.556]             length <- base::length
[17:43:35.556]             list <- base::list
[17:43:35.556]             seq.int <- base::seq.int
[17:43:35.556]             signalCondition <- base::signalCondition
[17:43:35.556]             sys.calls <- base::sys.calls
[17:43:35.556]             `[[` <- base::`[[`
[17:43:35.556]             `+` <- base::`+`
[17:43:35.556]             `<<-` <- base::`<<-`
[17:43:35.556]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:35.556]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:35.556]                   3L)]
[17:43:35.556]             }
[17:43:35.556]             function(cond) {
[17:43:35.556]                 is_error <- inherits(cond, "error")
[17:43:35.556]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:35.556]                   NULL)
[17:43:35.556]                 if (is_error) {
[17:43:35.556]                   sessionInformation <- function() {
[17:43:35.556]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:35.556]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:35.556]                       search = base::search(), system = base::Sys.info())
[17:43:35.556]                   }
[17:43:35.556]                   ...future.conditions[[length(...future.conditions) + 
[17:43:35.556]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:35.556]                     cond$call), session = sessionInformation(), 
[17:43:35.556]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:35.556]                   signalCondition(cond)
[17:43:35.556]                 }
[17:43:35.556]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:35.556]                 "immediateCondition"))) {
[17:43:35.556]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:35.556]                   ...future.conditions[[length(...future.conditions) + 
[17:43:35.556]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:35.556]                   if (TRUE && !signal) {
[17:43:35.556]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:35.556]                     {
[17:43:35.556]                       inherits <- base::inherits
[17:43:35.556]                       invokeRestart <- base::invokeRestart
[17:43:35.556]                       is.null <- base::is.null
[17:43:35.556]                       muffled <- FALSE
[17:43:35.556]                       if (inherits(cond, "message")) {
[17:43:35.556]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:35.556]                         if (muffled) 
[17:43:35.556]                           invokeRestart("muffleMessage")
[17:43:35.556]                       }
[17:43:35.556]                       else if (inherits(cond, "warning")) {
[17:43:35.556]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:35.556]                         if (muffled) 
[17:43:35.556]                           invokeRestart("muffleWarning")
[17:43:35.556]                       }
[17:43:35.556]                       else if (inherits(cond, "condition")) {
[17:43:35.556]                         if (!is.null(pattern)) {
[17:43:35.556]                           computeRestarts <- base::computeRestarts
[17:43:35.556]                           grepl <- base::grepl
[17:43:35.556]                           restarts <- computeRestarts(cond)
[17:43:35.556]                           for (restart in restarts) {
[17:43:35.556]                             name <- restart$name
[17:43:35.556]                             if (is.null(name)) 
[17:43:35.556]                               next
[17:43:35.556]                             if (!grepl(pattern, name)) 
[17:43:35.556]                               next
[17:43:35.556]                             invokeRestart(restart)
[17:43:35.556]                             muffled <- TRUE
[17:43:35.556]                             break
[17:43:35.556]                           }
[17:43:35.556]                         }
[17:43:35.556]                       }
[17:43:35.556]                       invisible(muffled)
[17:43:35.556]                     }
[17:43:35.556]                     muffleCondition(cond, pattern = "^muffle")
[17:43:35.556]                   }
[17:43:35.556]                 }
[17:43:35.556]                 else {
[17:43:35.556]                   if (TRUE) {
[17:43:35.556]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:35.556]                     {
[17:43:35.556]                       inherits <- base::inherits
[17:43:35.556]                       invokeRestart <- base::invokeRestart
[17:43:35.556]                       is.null <- base::is.null
[17:43:35.556]                       muffled <- FALSE
[17:43:35.556]                       if (inherits(cond, "message")) {
[17:43:35.556]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:35.556]                         if (muffled) 
[17:43:35.556]                           invokeRestart("muffleMessage")
[17:43:35.556]                       }
[17:43:35.556]                       else if (inherits(cond, "warning")) {
[17:43:35.556]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:35.556]                         if (muffled) 
[17:43:35.556]                           invokeRestart("muffleWarning")
[17:43:35.556]                       }
[17:43:35.556]                       else if (inherits(cond, "condition")) {
[17:43:35.556]                         if (!is.null(pattern)) {
[17:43:35.556]                           computeRestarts <- base::computeRestarts
[17:43:35.556]                           grepl <- base::grepl
[17:43:35.556]                           restarts <- computeRestarts(cond)
[17:43:35.556]                           for (restart in restarts) {
[17:43:35.556]                             name <- restart$name
[17:43:35.556]                             if (is.null(name)) 
[17:43:35.556]                               next
[17:43:35.556]                             if (!grepl(pattern, name)) 
[17:43:35.556]                               next
[17:43:35.556]                             invokeRestart(restart)
[17:43:35.556]                             muffled <- TRUE
[17:43:35.556]                             break
[17:43:35.556]                           }
[17:43:35.556]                         }
[17:43:35.556]                       }
[17:43:35.556]                       invisible(muffled)
[17:43:35.556]                     }
[17:43:35.556]                     muffleCondition(cond, pattern = "^muffle")
[17:43:35.556]                   }
[17:43:35.556]                 }
[17:43:35.556]             }
[17:43:35.556]         }))
[17:43:35.556]     }, error = function(ex) {
[17:43:35.556]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:35.556]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:35.556]                 ...future.rng), started = ...future.startTime, 
[17:43:35.556]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:35.556]             version = "1.8"), class = "FutureResult")
[17:43:35.556]     }, finally = {
[17:43:35.556]         if (!identical(...future.workdir, getwd())) 
[17:43:35.556]             setwd(...future.workdir)
[17:43:35.556]         {
[17:43:35.556]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:35.556]                 ...future.oldOptions$nwarnings <- NULL
[17:43:35.556]             }
[17:43:35.556]             base::options(...future.oldOptions)
[17:43:35.556]             if (.Platform$OS.type == "windows") {
[17:43:35.556]                 old_names <- names(...future.oldEnvVars)
[17:43:35.556]                 envs <- base::Sys.getenv()
[17:43:35.556]                 names <- names(envs)
[17:43:35.556]                 common <- intersect(names, old_names)
[17:43:35.556]                 added <- setdiff(names, old_names)
[17:43:35.556]                 removed <- setdiff(old_names, names)
[17:43:35.556]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:35.556]                   envs[common]]
[17:43:35.556]                 NAMES <- toupper(changed)
[17:43:35.556]                 args <- list()
[17:43:35.556]                 for (kk in seq_along(NAMES)) {
[17:43:35.556]                   name <- changed[[kk]]
[17:43:35.556]                   NAME <- NAMES[[kk]]
[17:43:35.556]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:35.556]                     next
[17:43:35.556]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:35.556]                 }
[17:43:35.556]                 NAMES <- toupper(added)
[17:43:35.556]                 for (kk in seq_along(NAMES)) {
[17:43:35.556]                   name <- added[[kk]]
[17:43:35.556]                   NAME <- NAMES[[kk]]
[17:43:35.556]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:35.556]                     next
[17:43:35.556]                   args[[name]] <- ""
[17:43:35.556]                 }
[17:43:35.556]                 NAMES <- toupper(removed)
[17:43:35.556]                 for (kk in seq_along(NAMES)) {
[17:43:35.556]                   name <- removed[[kk]]
[17:43:35.556]                   NAME <- NAMES[[kk]]
[17:43:35.556]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:35.556]                     next
[17:43:35.556]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:35.556]                 }
[17:43:35.556]                 if (length(args) > 0) 
[17:43:35.556]                   base::do.call(base::Sys.setenv, args = args)
[17:43:35.556]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:35.556]             }
[17:43:35.556]             else {
[17:43:35.556]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:35.556]             }
[17:43:35.556]             {
[17:43:35.556]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:35.556]                   0L) {
[17:43:35.556]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:35.556]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:35.556]                   base::options(opts)
[17:43:35.556]                 }
[17:43:35.556]                 {
[17:43:35.556]                   {
[17:43:35.556]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:35.556]                     NULL
[17:43:35.556]                   }
[17:43:35.556]                   options(future.plan = NULL)
[17:43:35.556]                   if (is.na(NA_character_)) 
[17:43:35.556]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:35.556]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:35.556]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:43:35.556]                     envir = parent.frame()) 
[17:43:35.556]                   {
[17:43:35.556]                     default_workers <- missing(workers)
[17:43:35.556]                     if (is.function(workers)) 
[17:43:35.556]                       workers <- workers()
[17:43:35.556]                     workers <- structure(as.integer(workers), 
[17:43:35.556]                       class = class(workers))
[17:43:35.556]                     stop_if_not(is.finite(workers), workers >= 
[17:43:35.556]                       1L)
[17:43:35.556]                     if ((workers == 1L && !inherits(workers, 
[17:43:35.556]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:35.556]                       if (default_workers) 
[17:43:35.556]                         supportsMulticore(warn = TRUE)
[17:43:35.556]                       return(sequential(..., envir = envir))
[17:43:35.556]                     }
[17:43:35.556]                     oopts <- options(mc.cores = workers)
[17:43:35.556]                     on.exit(options(oopts))
[17:43:35.556]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:35.556]                       envir = envir)
[17:43:35.556]                     if (!future$lazy) 
[17:43:35.556]                       future <- run(future)
[17:43:35.556]                     invisible(future)
[17:43:35.556]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:35.556]                 }
[17:43:35.556]             }
[17:43:35.556]         }
[17:43:35.556]     })
[17:43:35.556]     if (TRUE) {
[17:43:35.556]         base::sink(type = "output", split = FALSE)
[17:43:35.556]         if (TRUE) {
[17:43:35.556]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:35.556]         }
[17:43:35.556]         else {
[17:43:35.556]             ...future.result["stdout"] <- base::list(NULL)
[17:43:35.556]         }
[17:43:35.556]         base::close(...future.stdout)
[17:43:35.556]         ...future.stdout <- NULL
[17:43:35.556]     }
[17:43:35.556]     ...future.result$conditions <- ...future.conditions
[17:43:35.556]     ...future.result$finished <- base::Sys.time()
[17:43:35.556]     ...future.result
[17:43:35.556] }
[17:43:35.560] assign_globals() ...
[17:43:35.560] List of 1
[17:43:35.560]  $ kk: int 2
[17:43:35.560]  - attr(*, "where")=List of 1
[17:43:35.560]   ..$ kk:<environment: R_EmptyEnv> 
[17:43:35.560]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:35.560]  - attr(*, "resolved")= logi FALSE
[17:43:35.560]  - attr(*, "total_size")= num 56
[17:43:35.560]  - attr(*, "already-done")= logi TRUE
[17:43:35.564] - copied ‘kk’ to environment
[17:43:35.564] assign_globals() ... done
[17:43:35.565] requestCore(): workers = 2
[17:43:35.565] Poll #1 (0): usedCores() = 2, workers = 2
[17:43:35.582] MulticoreFuture started
[17:43:35.583] - Launch lazy future ... done
[17:43:35.584] run() for ‘MulticoreFuture’ ... done
[17:43:35.584] plan(): Setting new future strategy stack:
[17:43:35.585] getGlobalsAndPackages() ...
[17:43:35.585] Searching for globals...
[17:43:35.584] List of future strategies:
[17:43:35.584] 1. sequential:
[17:43:35.584]    - args: function (..., envir = parent.frame())
[17:43:35.584]    - tweaked: FALSE
[17:43:35.584]    - call: NULL
[17:43:35.586] plan(): nbrOfWorkers() = 1
[17:43:35.590] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:43:35.590] Searching for globals ... DONE
[17:43:35.590] Resolving globals: FALSE
[17:43:35.591] The total size of the 1 globals is 56 bytes (56 bytes)
[17:43:35.592] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:43:35.592] - globals: [1] ‘kk’
[17:43:35.592] 
[17:43:35.593] getGlobalsAndPackages() ... DONE
[17:43:35.593] run() for ‘Future’ ...
[17:43:35.593] - state: ‘created’
[17:43:35.594] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:35.599] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:35.599] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:35.600]   - Field: ‘label’
[17:43:35.600]   - Field: ‘local’
[17:43:35.600]   - Field: ‘owner’
[17:43:35.600]   - Field: ‘envir’
[17:43:35.600]   - Field: ‘workers’
[17:43:35.600]   - Field: ‘packages’
[17:43:35.601]   - Field: ‘gc’
[17:43:35.601]   - Field: ‘job’
[17:43:35.601]   - Field: ‘conditions’
[17:43:35.601]   - Field: ‘expr’
[17:43:35.601]   - Field: ‘uuid’
[17:43:35.602]   - Field: ‘seed’
[17:43:35.602]   - Field: ‘version’
[17:43:35.602]   - Field: ‘result’
[17:43:35.602]   - Field: ‘asynchronous’
[17:43:35.602]   - Field: ‘calls’
[17:43:35.602]   - Field: ‘globals’
[17:43:35.603]   - Field: ‘stdout’
[17:43:35.603]   - Field: ‘earlySignal’
[17:43:35.603]   - Field: ‘lazy’
[17:43:35.603]   - Field: ‘state’
[17:43:35.603] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:35.603] - Launch lazy future ...
[17:43:35.604] Packages needed by the future expression (n = 0): <none>
[17:43:35.604] Packages needed by future strategies (n = 0): <none>
[17:43:35.605] {
[17:43:35.605]     {
[17:43:35.605]         {
[17:43:35.605]             ...future.startTime <- base::Sys.time()
[17:43:35.605]             {
[17:43:35.605]                 {
[17:43:35.605]                   {
[17:43:35.605]                     {
[17:43:35.605]                       base::local({
[17:43:35.605]                         has_future <- base::requireNamespace("future", 
[17:43:35.605]                           quietly = TRUE)
[17:43:35.605]                         if (has_future) {
[17:43:35.605]                           ns <- base::getNamespace("future")
[17:43:35.605]                           version <- ns[[".package"]][["version"]]
[17:43:35.605]                           if (is.null(version)) 
[17:43:35.605]                             version <- utils::packageVersion("future")
[17:43:35.605]                         }
[17:43:35.605]                         else {
[17:43:35.605]                           version <- NULL
[17:43:35.605]                         }
[17:43:35.605]                         if (!has_future || version < "1.8.0") {
[17:43:35.605]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:35.605]                             "", base::R.version$version.string), 
[17:43:35.605]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:35.605]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:35.605]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:35.605]                               "release", "version")], collapse = " "), 
[17:43:35.605]                             hostname = base::Sys.info()[["nodename"]])
[17:43:35.605]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:35.605]                             info)
[17:43:35.605]                           info <- base::paste(info, collapse = "; ")
[17:43:35.605]                           if (!has_future) {
[17:43:35.605]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:35.605]                               info)
[17:43:35.605]                           }
[17:43:35.605]                           else {
[17:43:35.605]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:35.605]                               info, version)
[17:43:35.605]                           }
[17:43:35.605]                           base::stop(msg)
[17:43:35.605]                         }
[17:43:35.605]                       })
[17:43:35.605]                     }
[17:43:35.605]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:35.605]                     base::options(mc.cores = 1L)
[17:43:35.605]                   }
[17:43:35.605]                   options(future.plan = NULL)
[17:43:35.605]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:35.605]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:35.605]                 }
[17:43:35.605]                 ...future.workdir <- getwd()
[17:43:35.605]             }
[17:43:35.605]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:35.605]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:35.605]         }
[17:43:35.605]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:35.605]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:35.605]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:35.605]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:35.605]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:35.605]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:35.605]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:35.605]             base::names(...future.oldOptions))
[17:43:35.605]     }
[17:43:35.605]     if (FALSE) {
[17:43:35.605]     }
[17:43:35.605]     else {
[17:43:35.605]         if (TRUE) {
[17:43:35.605]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:35.605]                 open = "w")
[17:43:35.605]         }
[17:43:35.605]         else {
[17:43:35.605]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:35.605]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:35.605]         }
[17:43:35.605]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:35.605]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:35.605]             base::sink(type = "output", split = FALSE)
[17:43:35.605]             base::close(...future.stdout)
[17:43:35.605]         }, add = TRUE)
[17:43:35.605]     }
[17:43:35.605]     ...future.frame <- base::sys.nframe()
[17:43:35.605]     ...future.conditions <- base::list()
[17:43:35.605]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:35.605]     if (FALSE) {
[17:43:35.605]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:35.605]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:35.605]     }
[17:43:35.605]     ...future.result <- base::tryCatch({
[17:43:35.605]         base::withCallingHandlers({
[17:43:35.605]             ...future.value <- base::withVisible(base::local({
[17:43:35.605]                 withCallingHandlers({
[17:43:35.605]                   {
[17:43:35.605]                     Sys.sleep(0.1)
[17:43:35.605]                     kk
[17:43:35.605]                   }
[17:43:35.605]                 }, immediateCondition = function(cond) {
[17:43:35.605]                   save_rds <- function (object, pathname, ...) 
[17:43:35.605]                   {
[17:43:35.605]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:35.605]                     if (file_test("-f", pathname_tmp)) {
[17:43:35.605]                       fi_tmp <- file.info(pathname_tmp)
[17:43:35.605]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:35.605]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:35.605]                         fi_tmp[["mtime"]])
[17:43:35.605]                     }
[17:43:35.605]                     tryCatch({
[17:43:35.605]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:35.605]                     }, error = function(ex) {
[17:43:35.605]                       msg <- conditionMessage(ex)
[17:43:35.605]                       fi_tmp <- file.info(pathname_tmp)
[17:43:35.605]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:35.605]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:35.605]                         fi_tmp[["mtime"]], msg)
[17:43:35.605]                       ex$message <- msg
[17:43:35.605]                       stop(ex)
[17:43:35.605]                     })
[17:43:35.605]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:35.605]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:35.605]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:35.605]                       fi_tmp <- file.info(pathname_tmp)
[17:43:35.605]                       fi <- file.info(pathname)
[17:43:35.605]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:35.605]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:35.605]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:35.605]                         fi[["size"]], fi[["mtime"]])
[17:43:35.605]                       stop(msg)
[17:43:35.605]                     }
[17:43:35.605]                     invisible(pathname)
[17:43:35.605]                   }
[17:43:35.605]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:35.605]                     rootPath = tempdir()) 
[17:43:35.605]                   {
[17:43:35.605]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:35.605]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:35.605]                       tmpdir = path, fileext = ".rds")
[17:43:35.605]                     save_rds(obj, file)
[17:43:35.605]                   }
[17:43:35.605]                   saveImmediateCondition(cond, path = "/tmp/RtmpLaOb2h/.future/immediateConditions")
[17:43:35.605]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:35.605]                   {
[17:43:35.605]                     inherits <- base::inherits
[17:43:35.605]                     invokeRestart <- base::invokeRestart
[17:43:35.605]                     is.null <- base::is.null
[17:43:35.605]                     muffled <- FALSE
[17:43:35.605]                     if (inherits(cond, "message")) {
[17:43:35.605]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:35.605]                       if (muffled) 
[17:43:35.605]                         invokeRestart("muffleMessage")
[17:43:35.605]                     }
[17:43:35.605]                     else if (inherits(cond, "warning")) {
[17:43:35.605]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:35.605]                       if (muffled) 
[17:43:35.605]                         invokeRestart("muffleWarning")
[17:43:35.605]                     }
[17:43:35.605]                     else if (inherits(cond, "condition")) {
[17:43:35.605]                       if (!is.null(pattern)) {
[17:43:35.605]                         computeRestarts <- base::computeRestarts
[17:43:35.605]                         grepl <- base::grepl
[17:43:35.605]                         restarts <- computeRestarts(cond)
[17:43:35.605]                         for (restart in restarts) {
[17:43:35.605]                           name <- restart$name
[17:43:35.605]                           if (is.null(name)) 
[17:43:35.605]                             next
[17:43:35.605]                           if (!grepl(pattern, name)) 
[17:43:35.605]                             next
[17:43:35.605]                           invokeRestart(restart)
[17:43:35.605]                           muffled <- TRUE
[17:43:35.605]                           break
[17:43:35.605]                         }
[17:43:35.605]                       }
[17:43:35.605]                     }
[17:43:35.605]                     invisible(muffled)
[17:43:35.605]                   }
[17:43:35.605]                   muffleCondition(cond)
[17:43:35.605]                 })
[17:43:35.605]             }))
[17:43:35.605]             future::FutureResult(value = ...future.value$value, 
[17:43:35.605]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:35.605]                   ...future.rng), globalenv = if (FALSE) 
[17:43:35.605]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:35.605]                     ...future.globalenv.names))
[17:43:35.605]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:35.605]         }, condition = base::local({
[17:43:35.605]             c <- base::c
[17:43:35.605]             inherits <- base::inherits
[17:43:35.605]             invokeRestart <- base::invokeRestart
[17:43:35.605]             length <- base::length
[17:43:35.605]             list <- base::list
[17:43:35.605]             seq.int <- base::seq.int
[17:43:35.605]             signalCondition <- base::signalCondition
[17:43:35.605]             sys.calls <- base::sys.calls
[17:43:35.605]             `[[` <- base::`[[`
[17:43:35.605]             `+` <- base::`+`
[17:43:35.605]             `<<-` <- base::`<<-`
[17:43:35.605]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:35.605]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:35.605]                   3L)]
[17:43:35.605]             }
[17:43:35.605]             function(cond) {
[17:43:35.605]                 is_error <- inherits(cond, "error")
[17:43:35.605]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:35.605]                   NULL)
[17:43:35.605]                 if (is_error) {
[17:43:35.605]                   sessionInformation <- function() {
[17:43:35.605]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:35.605]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:35.605]                       search = base::search(), system = base::Sys.info())
[17:43:35.605]                   }
[17:43:35.605]                   ...future.conditions[[length(...future.conditions) + 
[17:43:35.605]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:35.605]                     cond$call), session = sessionInformation(), 
[17:43:35.605]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:35.605]                   signalCondition(cond)
[17:43:35.605]                 }
[17:43:35.605]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:35.605]                 "immediateCondition"))) {
[17:43:35.605]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:35.605]                   ...future.conditions[[length(...future.conditions) + 
[17:43:35.605]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:35.605]                   if (TRUE && !signal) {
[17:43:35.605]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:35.605]                     {
[17:43:35.605]                       inherits <- base::inherits
[17:43:35.605]                       invokeRestart <- base::invokeRestart
[17:43:35.605]                       is.null <- base::is.null
[17:43:35.605]                       muffled <- FALSE
[17:43:35.605]                       if (inherits(cond, "message")) {
[17:43:35.605]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:35.605]                         if (muffled) 
[17:43:35.605]                           invokeRestart("muffleMessage")
[17:43:35.605]                       }
[17:43:35.605]                       else if (inherits(cond, "warning")) {
[17:43:35.605]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:35.605]                         if (muffled) 
[17:43:35.605]                           invokeRestart("muffleWarning")
[17:43:35.605]                       }
[17:43:35.605]                       else if (inherits(cond, "condition")) {
[17:43:35.605]                         if (!is.null(pattern)) {
[17:43:35.605]                           computeRestarts <- base::computeRestarts
[17:43:35.605]                           grepl <- base::grepl
[17:43:35.605]                           restarts <- computeRestarts(cond)
[17:43:35.605]                           for (restart in restarts) {
[17:43:35.605]                             name <- restart$name
[17:43:35.605]                             if (is.null(name)) 
[17:43:35.605]                               next
[17:43:35.605]                             if (!grepl(pattern, name)) 
[17:43:35.605]                               next
[17:43:35.605]                             invokeRestart(restart)
[17:43:35.605]                             muffled <- TRUE
[17:43:35.605]                             break
[17:43:35.605]                           }
[17:43:35.605]                         }
[17:43:35.605]                       }
[17:43:35.605]                       invisible(muffled)
[17:43:35.605]                     }
[17:43:35.605]                     muffleCondition(cond, pattern = "^muffle")
[17:43:35.605]                   }
[17:43:35.605]                 }
[17:43:35.605]                 else {
[17:43:35.605]                   if (TRUE) {
[17:43:35.605]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:35.605]                     {
[17:43:35.605]                       inherits <- base::inherits
[17:43:35.605]                       invokeRestart <- base::invokeRestart
[17:43:35.605]                       is.null <- base::is.null
[17:43:35.605]                       muffled <- FALSE
[17:43:35.605]                       if (inherits(cond, "message")) {
[17:43:35.605]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:35.605]                         if (muffled) 
[17:43:35.605]                           invokeRestart("muffleMessage")
[17:43:35.605]                       }
[17:43:35.605]                       else if (inherits(cond, "warning")) {
[17:43:35.605]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:35.605]                         if (muffled) 
[17:43:35.605]                           invokeRestart("muffleWarning")
[17:43:35.605]                       }
[17:43:35.605]                       else if (inherits(cond, "condition")) {
[17:43:35.605]                         if (!is.null(pattern)) {
[17:43:35.605]                           computeRestarts <- base::computeRestarts
[17:43:35.605]                           grepl <- base::grepl
[17:43:35.605]                           restarts <- computeRestarts(cond)
[17:43:35.605]                           for (restart in restarts) {
[17:43:35.605]                             name <- restart$name
[17:43:35.605]                             if (is.null(name)) 
[17:43:35.605]                               next
[17:43:35.605]                             if (!grepl(pattern, name)) 
[17:43:35.605]                               next
[17:43:35.605]                             invokeRestart(restart)
[17:43:35.605]                             muffled <- TRUE
[17:43:35.605]                             break
[17:43:35.605]                           }
[17:43:35.605]                         }
[17:43:35.605]                       }
[17:43:35.605]                       invisible(muffled)
[17:43:35.605]                     }
[17:43:35.605]                     muffleCondition(cond, pattern = "^muffle")
[17:43:35.605]                   }
[17:43:35.605]                 }
[17:43:35.605]             }
[17:43:35.605]         }))
[17:43:35.605]     }, error = function(ex) {
[17:43:35.605]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:35.605]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:35.605]                 ...future.rng), started = ...future.startTime, 
[17:43:35.605]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:35.605]             version = "1.8"), class = "FutureResult")
[17:43:35.605]     }, finally = {
[17:43:35.605]         if (!identical(...future.workdir, getwd())) 
[17:43:35.605]             setwd(...future.workdir)
[17:43:35.605]         {
[17:43:35.605]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:35.605]                 ...future.oldOptions$nwarnings <- NULL
[17:43:35.605]             }
[17:43:35.605]             base::options(...future.oldOptions)
[17:43:35.605]             if (.Platform$OS.type == "windows") {
[17:43:35.605]                 old_names <- names(...future.oldEnvVars)
[17:43:35.605]                 envs <- base::Sys.getenv()
[17:43:35.605]                 names <- names(envs)
[17:43:35.605]                 common <- intersect(names, old_names)
[17:43:35.605]                 added <- setdiff(names, old_names)
[17:43:35.605]                 removed <- setdiff(old_names, names)
[17:43:35.605]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:35.605]                   envs[common]]
[17:43:35.605]                 NAMES <- toupper(changed)
[17:43:35.605]                 args <- list()
[17:43:35.605]                 for (kk in seq_along(NAMES)) {
[17:43:35.605]                   name <- changed[[kk]]
[17:43:35.605]                   NAME <- NAMES[[kk]]
[17:43:35.605]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:35.605]                     next
[17:43:35.605]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:35.605]                 }
[17:43:35.605]                 NAMES <- toupper(added)
[17:43:35.605]                 for (kk in seq_along(NAMES)) {
[17:43:35.605]                   name <- added[[kk]]
[17:43:35.605]                   NAME <- NAMES[[kk]]
[17:43:35.605]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:35.605]                     next
[17:43:35.605]                   args[[name]] <- ""
[17:43:35.605]                 }
[17:43:35.605]                 NAMES <- toupper(removed)
[17:43:35.605]                 for (kk in seq_along(NAMES)) {
[17:43:35.605]                   name <- removed[[kk]]
[17:43:35.605]                   NAME <- NAMES[[kk]]
[17:43:35.605]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:35.605]                     next
[17:43:35.605]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:35.605]                 }
[17:43:35.605]                 if (length(args) > 0) 
[17:43:35.605]                   base::do.call(base::Sys.setenv, args = args)
[17:43:35.605]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:35.605]             }
[17:43:35.605]             else {
[17:43:35.605]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:35.605]             }
[17:43:35.605]             {
[17:43:35.605]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:35.605]                   0L) {
[17:43:35.605]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:35.605]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:35.605]                   base::options(opts)
[17:43:35.605]                 }
[17:43:35.605]                 {
[17:43:35.605]                   {
[17:43:35.605]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:35.605]                     NULL
[17:43:35.605]                   }
[17:43:35.605]                   options(future.plan = NULL)
[17:43:35.605]                   if (is.na(NA_character_)) 
[17:43:35.605]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:35.605]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:35.605]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:43:35.605]                     envir = parent.frame()) 
[17:43:35.605]                   {
[17:43:35.605]                     default_workers <- missing(workers)
[17:43:35.605]                     if (is.function(workers)) 
[17:43:35.605]                       workers <- workers()
[17:43:35.605]                     workers <- structure(as.integer(workers), 
[17:43:35.605]                       class = class(workers))
[17:43:35.605]                     stop_if_not(is.finite(workers), workers >= 
[17:43:35.605]                       1L)
[17:43:35.605]                     if ((workers == 1L && !inherits(workers, 
[17:43:35.605]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:35.605]                       if (default_workers) 
[17:43:35.605]                         supportsMulticore(warn = TRUE)
[17:43:35.605]                       return(sequential(..., envir = envir))
[17:43:35.605]                     }
[17:43:35.605]                     oopts <- options(mc.cores = workers)
[17:43:35.605]                     on.exit(options(oopts))
[17:43:35.605]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:35.605]                       envir = envir)
[17:43:35.605]                     if (!future$lazy) 
[17:43:35.605]                       future <- run(future)
[17:43:35.605]                     invisible(future)
[17:43:35.605]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:35.605]                 }
[17:43:35.605]             }
[17:43:35.605]         }
[17:43:35.605]     })
[17:43:35.605]     if (TRUE) {
[17:43:35.605]         base::sink(type = "output", split = FALSE)
[17:43:35.605]         if (TRUE) {
[17:43:35.605]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:35.605]         }
[17:43:35.605]         else {
[17:43:35.605]             ...future.result["stdout"] <- base::list(NULL)
[17:43:35.605]         }
[17:43:35.605]         base::close(...future.stdout)
[17:43:35.605]         ...future.stdout <- NULL
[17:43:35.605]     }
[17:43:35.605]     ...future.result$conditions <- ...future.conditions
[17:43:35.605]     ...future.result$finished <- base::Sys.time()
[17:43:35.605]     ...future.result
[17:43:35.605] }
[17:43:35.608] assign_globals() ...
[17:43:35.608] List of 1
[17:43:35.608]  $ kk: int 3
[17:43:35.608]  - attr(*, "where")=List of 1
[17:43:35.608]   ..$ kk:<environment: R_EmptyEnv> 
[17:43:35.608]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:35.608]  - attr(*, "resolved")= logi FALSE
[17:43:35.608]  - attr(*, "total_size")= num 56
[17:43:35.608]  - attr(*, "already-done")= logi TRUE
[17:43:35.612] - copied ‘kk’ to environment
[17:43:35.612] assign_globals() ... done
[17:43:35.612] requestCore(): workers = 2
[17:43:35.613] Poll #1 (0): usedCores() = 2, workers = 2
[17:43:35.645] plan(): Setting new future strategy stack:
[17:43:35.644] Poll #2 (0.03 secs): usedCores() = 2, workers = 2
[17:43:35.645] List of future strategies:
[17:43:35.645] 1. multicore:
[17:43:35.645]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:35.645]    - tweaked: FALSE
[17:43:35.645]    - call: plan(strategy)
[17:43:35.650] plan(): nbrOfWorkers() = 2
[17:43:35.659] MulticoreFuture started
[17:43:35.660] - Launch lazy future ... done
[17:43:35.660] run() for ‘MulticoreFuture’ ... done
[17:43:35.660] plan(): Setting new future strategy stack:
[17:43:35.661] resolve() on list ...
[17:43:35.661]  recursive: 0
[17:43:35.661]  length: 3
[17:43:35.661] 
[17:43:35.661] Future #1
[17:43:35.661] List of future strategies:
[17:43:35.661] 1. sequential:
[17:43:35.661]    - args: function (..., envir = parent.frame())
[17:43:35.661]    - tweaked: FALSE
[17:43:35.661]    - call: NULL
[17:43:35.662]  length: 2 (resolved future 1)
[17:43:35.662] plan(): nbrOfWorkers() = 1
[17:43:35.690] plan(): Setting new future strategy stack:
[17:43:35.690] List of future strategies:
[17:43:35.690] 1. multicore:
[17:43:35.690]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:35.690]    - tweaked: FALSE
[17:43:35.690]    - call: plan(strategy)
[17:43:35.695] plan(): nbrOfWorkers() = 2
[17:43:35.695] Future #2
[17:43:35.696]  length: 1 (resolved future 2)
[17:43:35.764] plan(): Setting new future strategy stack:
[17:43:35.764] List of future strategies:
[17:43:35.764] 1. multicore:
[17:43:35.764]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:35.764]    - tweaked: FALSE
[17:43:35.764]    - call: plan(strategy)
[17:43:35.771] plan(): nbrOfWorkers() = 2
[17:43:35.778] Future #3
[17:43:35.778]  length: 0 (resolved future 3)
[17:43:35.778] resolve() on list ... DONE
[17:43:35.779] getGlobalsAndPackages() ...
[17:43:35.779] Searching for globals...
[17:43:35.781] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:43:35.781] Searching for globals ... DONE
[17:43:35.781] Resolving globals: FALSE
[17:43:35.782] The total size of the 1 globals is 56 bytes (56 bytes)
[17:43:35.783] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:43:35.783] - globals: [1] ‘kk’
[17:43:35.783] 
[17:43:35.783] getGlobalsAndPackages() ... DONE
[17:43:35.784] getGlobalsAndPackages() ...
[17:43:35.784] Searching for globals...
[17:43:35.785] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:43:35.786] Searching for globals ... DONE
[17:43:35.786] Resolving globals: FALSE
[17:43:35.786] The total size of the 1 globals is 56 bytes (56 bytes)
[17:43:35.787] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:43:35.787] - globals: [1] ‘kk’
[17:43:35.787] 
[17:43:35.787] getGlobalsAndPackages() ... DONE
[17:43:35.788] getGlobalsAndPackages() ...
[17:43:35.788] Searching for globals...
[17:43:35.789] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:43:35.789] Searching for globals ... DONE
[17:43:35.790] Resolving globals: FALSE
[17:43:35.790] The total size of the 1 globals is 56 bytes (56 bytes)
[17:43:35.790] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:43:35.791] - globals: [1] ‘kk’
[17:43:35.791] 
[17:43:35.791] getGlobalsAndPackages() ... DONE
[17:43:35.791] resolve() on list ...
[17:43:35.791]  recursive: 0
[17:43:35.791]  length: 3
[17:43:35.792] 
[17:43:35.792] run() for ‘Future’ ...
[17:43:35.792] - state: ‘created’
[17:43:35.795] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:35.801] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:35.801] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:35.802]   - Field: ‘label’
[17:43:35.802]   - Field: ‘local’
[17:43:35.802]   - Field: ‘owner’
[17:43:35.802]   - Field: ‘envir’
[17:43:35.802]   - Field: ‘workers’
[17:43:35.802]   - Field: ‘packages’
[17:43:35.803]   - Field: ‘gc’
[17:43:35.803]   - Field: ‘job’
[17:43:35.803]   - Field: ‘conditions’
[17:43:35.803]   - Field: ‘expr’
[17:43:35.803]   - Field: ‘uuid’
[17:43:35.804]   - Field: ‘seed’
[17:43:35.804]   - Field: ‘version’
[17:43:35.804]   - Field: ‘result’
[17:43:35.804]   - Field: ‘asynchronous’
[17:43:35.804]   - Field: ‘calls’
[17:43:35.804]   - Field: ‘globals’
[17:43:35.804]   - Field: ‘stdout’
[17:43:35.805]   - Field: ‘earlySignal’
[17:43:35.805]   - Field: ‘lazy’
[17:43:35.805]   - Field: ‘state’
[17:43:35.805] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:35.805] - Launch lazy future ...
[17:43:35.806] Packages needed by the future expression (n = 0): <none>
[17:43:35.806] Packages needed by future strategies (n = 0): <none>
[17:43:35.807] {
[17:43:35.807]     {
[17:43:35.807]         {
[17:43:35.807]             ...future.startTime <- base::Sys.time()
[17:43:35.807]             {
[17:43:35.807]                 {
[17:43:35.807]                   {
[17:43:35.807]                     {
[17:43:35.807]                       base::local({
[17:43:35.807]                         has_future <- base::requireNamespace("future", 
[17:43:35.807]                           quietly = TRUE)
[17:43:35.807]                         if (has_future) {
[17:43:35.807]                           ns <- base::getNamespace("future")
[17:43:35.807]                           version <- ns[[".package"]][["version"]]
[17:43:35.807]                           if (is.null(version)) 
[17:43:35.807]                             version <- utils::packageVersion("future")
[17:43:35.807]                         }
[17:43:35.807]                         else {
[17:43:35.807]                           version <- NULL
[17:43:35.807]                         }
[17:43:35.807]                         if (!has_future || version < "1.8.0") {
[17:43:35.807]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:35.807]                             "", base::R.version$version.string), 
[17:43:35.807]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:35.807]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:35.807]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:35.807]                               "release", "version")], collapse = " "), 
[17:43:35.807]                             hostname = base::Sys.info()[["nodename"]])
[17:43:35.807]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:35.807]                             info)
[17:43:35.807]                           info <- base::paste(info, collapse = "; ")
[17:43:35.807]                           if (!has_future) {
[17:43:35.807]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:35.807]                               info)
[17:43:35.807]                           }
[17:43:35.807]                           else {
[17:43:35.807]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:35.807]                               info, version)
[17:43:35.807]                           }
[17:43:35.807]                           base::stop(msg)
[17:43:35.807]                         }
[17:43:35.807]                       })
[17:43:35.807]                     }
[17:43:35.807]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:35.807]                     base::options(mc.cores = 1L)
[17:43:35.807]                   }
[17:43:35.807]                   options(future.plan = NULL)
[17:43:35.807]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:35.807]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:35.807]                 }
[17:43:35.807]                 ...future.workdir <- getwd()
[17:43:35.807]             }
[17:43:35.807]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:35.807]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:35.807]         }
[17:43:35.807]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:35.807]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:35.807]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:35.807]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:35.807]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:35.807]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:35.807]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:35.807]             base::names(...future.oldOptions))
[17:43:35.807]     }
[17:43:35.807]     if (FALSE) {
[17:43:35.807]     }
[17:43:35.807]     else {
[17:43:35.807]         if (TRUE) {
[17:43:35.807]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:35.807]                 open = "w")
[17:43:35.807]         }
[17:43:35.807]         else {
[17:43:35.807]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:35.807]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:35.807]         }
[17:43:35.807]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:35.807]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:35.807]             base::sink(type = "output", split = FALSE)
[17:43:35.807]             base::close(...future.stdout)
[17:43:35.807]         }, add = TRUE)
[17:43:35.807]     }
[17:43:35.807]     ...future.frame <- base::sys.nframe()
[17:43:35.807]     ...future.conditions <- base::list()
[17:43:35.807]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:35.807]     if (FALSE) {
[17:43:35.807]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:35.807]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:35.807]     }
[17:43:35.807]     ...future.result <- base::tryCatch({
[17:43:35.807]         base::withCallingHandlers({
[17:43:35.807]             ...future.value <- base::withVisible(base::local({
[17:43:35.807]                 withCallingHandlers({
[17:43:35.807]                   {
[17:43:35.807]                     Sys.sleep(0.1)
[17:43:35.807]                     kk
[17:43:35.807]                   }
[17:43:35.807]                 }, immediateCondition = function(cond) {
[17:43:35.807]                   save_rds <- function (object, pathname, ...) 
[17:43:35.807]                   {
[17:43:35.807]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:35.807]                     if (file_test("-f", pathname_tmp)) {
[17:43:35.807]                       fi_tmp <- file.info(pathname_tmp)
[17:43:35.807]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:35.807]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:35.807]                         fi_tmp[["mtime"]])
[17:43:35.807]                     }
[17:43:35.807]                     tryCatch({
[17:43:35.807]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:35.807]                     }, error = function(ex) {
[17:43:35.807]                       msg <- conditionMessage(ex)
[17:43:35.807]                       fi_tmp <- file.info(pathname_tmp)
[17:43:35.807]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:35.807]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:35.807]                         fi_tmp[["mtime"]], msg)
[17:43:35.807]                       ex$message <- msg
[17:43:35.807]                       stop(ex)
[17:43:35.807]                     })
[17:43:35.807]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:35.807]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:35.807]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:35.807]                       fi_tmp <- file.info(pathname_tmp)
[17:43:35.807]                       fi <- file.info(pathname)
[17:43:35.807]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:35.807]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:35.807]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:35.807]                         fi[["size"]], fi[["mtime"]])
[17:43:35.807]                       stop(msg)
[17:43:35.807]                     }
[17:43:35.807]                     invisible(pathname)
[17:43:35.807]                   }
[17:43:35.807]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:35.807]                     rootPath = tempdir()) 
[17:43:35.807]                   {
[17:43:35.807]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:35.807]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:35.807]                       tmpdir = path, fileext = ".rds")
[17:43:35.807]                     save_rds(obj, file)
[17:43:35.807]                   }
[17:43:35.807]                   saveImmediateCondition(cond, path = "/tmp/RtmpLaOb2h/.future/immediateConditions")
[17:43:35.807]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:35.807]                   {
[17:43:35.807]                     inherits <- base::inherits
[17:43:35.807]                     invokeRestart <- base::invokeRestart
[17:43:35.807]                     is.null <- base::is.null
[17:43:35.807]                     muffled <- FALSE
[17:43:35.807]                     if (inherits(cond, "message")) {
[17:43:35.807]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:35.807]                       if (muffled) 
[17:43:35.807]                         invokeRestart("muffleMessage")
[17:43:35.807]                     }
[17:43:35.807]                     else if (inherits(cond, "warning")) {
[17:43:35.807]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:35.807]                       if (muffled) 
[17:43:35.807]                         invokeRestart("muffleWarning")
[17:43:35.807]                     }
[17:43:35.807]                     else if (inherits(cond, "condition")) {
[17:43:35.807]                       if (!is.null(pattern)) {
[17:43:35.807]                         computeRestarts <- base::computeRestarts
[17:43:35.807]                         grepl <- base::grepl
[17:43:35.807]                         restarts <- computeRestarts(cond)
[17:43:35.807]                         for (restart in restarts) {
[17:43:35.807]                           name <- restart$name
[17:43:35.807]                           if (is.null(name)) 
[17:43:35.807]                             next
[17:43:35.807]                           if (!grepl(pattern, name)) 
[17:43:35.807]                             next
[17:43:35.807]                           invokeRestart(restart)
[17:43:35.807]                           muffled <- TRUE
[17:43:35.807]                           break
[17:43:35.807]                         }
[17:43:35.807]                       }
[17:43:35.807]                     }
[17:43:35.807]                     invisible(muffled)
[17:43:35.807]                   }
[17:43:35.807]                   muffleCondition(cond)
[17:43:35.807]                 })
[17:43:35.807]             }))
[17:43:35.807]             future::FutureResult(value = ...future.value$value, 
[17:43:35.807]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:35.807]                   ...future.rng), globalenv = if (FALSE) 
[17:43:35.807]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:35.807]                     ...future.globalenv.names))
[17:43:35.807]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:35.807]         }, condition = base::local({
[17:43:35.807]             c <- base::c
[17:43:35.807]             inherits <- base::inherits
[17:43:35.807]             invokeRestart <- base::invokeRestart
[17:43:35.807]             length <- base::length
[17:43:35.807]             list <- base::list
[17:43:35.807]             seq.int <- base::seq.int
[17:43:35.807]             signalCondition <- base::signalCondition
[17:43:35.807]             sys.calls <- base::sys.calls
[17:43:35.807]             `[[` <- base::`[[`
[17:43:35.807]             `+` <- base::`+`
[17:43:35.807]             `<<-` <- base::`<<-`
[17:43:35.807]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:35.807]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:35.807]                   3L)]
[17:43:35.807]             }
[17:43:35.807]             function(cond) {
[17:43:35.807]                 is_error <- inherits(cond, "error")
[17:43:35.807]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:35.807]                   NULL)
[17:43:35.807]                 if (is_error) {
[17:43:35.807]                   sessionInformation <- function() {
[17:43:35.807]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:35.807]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:35.807]                       search = base::search(), system = base::Sys.info())
[17:43:35.807]                   }
[17:43:35.807]                   ...future.conditions[[length(...future.conditions) + 
[17:43:35.807]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:35.807]                     cond$call), session = sessionInformation(), 
[17:43:35.807]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:35.807]                   signalCondition(cond)
[17:43:35.807]                 }
[17:43:35.807]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:35.807]                 "immediateCondition"))) {
[17:43:35.807]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:35.807]                   ...future.conditions[[length(...future.conditions) + 
[17:43:35.807]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:35.807]                   if (TRUE && !signal) {
[17:43:35.807]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:35.807]                     {
[17:43:35.807]                       inherits <- base::inherits
[17:43:35.807]                       invokeRestart <- base::invokeRestart
[17:43:35.807]                       is.null <- base::is.null
[17:43:35.807]                       muffled <- FALSE
[17:43:35.807]                       if (inherits(cond, "message")) {
[17:43:35.807]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:35.807]                         if (muffled) 
[17:43:35.807]                           invokeRestart("muffleMessage")
[17:43:35.807]                       }
[17:43:35.807]                       else if (inherits(cond, "warning")) {
[17:43:35.807]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:35.807]                         if (muffled) 
[17:43:35.807]                           invokeRestart("muffleWarning")
[17:43:35.807]                       }
[17:43:35.807]                       else if (inherits(cond, "condition")) {
[17:43:35.807]                         if (!is.null(pattern)) {
[17:43:35.807]                           computeRestarts <- base::computeRestarts
[17:43:35.807]                           grepl <- base::grepl
[17:43:35.807]                           restarts <- computeRestarts(cond)
[17:43:35.807]                           for (restart in restarts) {
[17:43:35.807]                             name <- restart$name
[17:43:35.807]                             if (is.null(name)) 
[17:43:35.807]                               next
[17:43:35.807]                             if (!grepl(pattern, name)) 
[17:43:35.807]                               next
[17:43:35.807]                             invokeRestart(restart)
[17:43:35.807]                             muffled <- TRUE
[17:43:35.807]                             break
[17:43:35.807]                           }
[17:43:35.807]                         }
[17:43:35.807]                       }
[17:43:35.807]                       invisible(muffled)
[17:43:35.807]                     }
[17:43:35.807]                     muffleCondition(cond, pattern = "^muffle")
[17:43:35.807]                   }
[17:43:35.807]                 }
[17:43:35.807]                 else {
[17:43:35.807]                   if (TRUE) {
[17:43:35.807]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:35.807]                     {
[17:43:35.807]                       inherits <- base::inherits
[17:43:35.807]                       invokeRestart <- base::invokeRestart
[17:43:35.807]                       is.null <- base::is.null
[17:43:35.807]                       muffled <- FALSE
[17:43:35.807]                       if (inherits(cond, "message")) {
[17:43:35.807]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:35.807]                         if (muffled) 
[17:43:35.807]                           invokeRestart("muffleMessage")
[17:43:35.807]                       }
[17:43:35.807]                       else if (inherits(cond, "warning")) {
[17:43:35.807]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:35.807]                         if (muffled) 
[17:43:35.807]                           invokeRestart("muffleWarning")
[17:43:35.807]                       }
[17:43:35.807]                       else if (inherits(cond, "condition")) {
[17:43:35.807]                         if (!is.null(pattern)) {
[17:43:35.807]                           computeRestarts <- base::computeRestarts
[17:43:35.807]                           grepl <- base::grepl
[17:43:35.807]                           restarts <- computeRestarts(cond)
[17:43:35.807]                           for (restart in restarts) {
[17:43:35.807]                             name <- restart$name
[17:43:35.807]                             if (is.null(name)) 
[17:43:35.807]                               next
[17:43:35.807]                             if (!grepl(pattern, name)) 
[17:43:35.807]                               next
[17:43:35.807]                             invokeRestart(restart)
[17:43:35.807]                             muffled <- TRUE
[17:43:35.807]                             break
[17:43:35.807]                           }
[17:43:35.807]                         }
[17:43:35.807]                       }
[17:43:35.807]                       invisible(muffled)
[17:43:35.807]                     }
[17:43:35.807]                     muffleCondition(cond, pattern = "^muffle")
[17:43:35.807]                   }
[17:43:35.807]                 }
[17:43:35.807]             }
[17:43:35.807]         }))
[17:43:35.807]     }, error = function(ex) {
[17:43:35.807]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:35.807]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:35.807]                 ...future.rng), started = ...future.startTime, 
[17:43:35.807]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:35.807]             version = "1.8"), class = "FutureResult")
[17:43:35.807]     }, finally = {
[17:43:35.807]         if (!identical(...future.workdir, getwd())) 
[17:43:35.807]             setwd(...future.workdir)
[17:43:35.807]         {
[17:43:35.807]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:35.807]                 ...future.oldOptions$nwarnings <- NULL
[17:43:35.807]             }
[17:43:35.807]             base::options(...future.oldOptions)
[17:43:35.807]             if (.Platform$OS.type == "windows") {
[17:43:35.807]                 old_names <- names(...future.oldEnvVars)
[17:43:35.807]                 envs <- base::Sys.getenv()
[17:43:35.807]                 names <- names(envs)
[17:43:35.807]                 common <- intersect(names, old_names)
[17:43:35.807]                 added <- setdiff(names, old_names)
[17:43:35.807]                 removed <- setdiff(old_names, names)
[17:43:35.807]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:35.807]                   envs[common]]
[17:43:35.807]                 NAMES <- toupper(changed)
[17:43:35.807]                 args <- list()
[17:43:35.807]                 for (kk in seq_along(NAMES)) {
[17:43:35.807]                   name <- changed[[kk]]
[17:43:35.807]                   NAME <- NAMES[[kk]]
[17:43:35.807]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:35.807]                     next
[17:43:35.807]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:35.807]                 }
[17:43:35.807]                 NAMES <- toupper(added)
[17:43:35.807]                 for (kk in seq_along(NAMES)) {
[17:43:35.807]                   name <- added[[kk]]
[17:43:35.807]                   NAME <- NAMES[[kk]]
[17:43:35.807]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:35.807]                     next
[17:43:35.807]                   args[[name]] <- ""
[17:43:35.807]                 }
[17:43:35.807]                 NAMES <- toupper(removed)
[17:43:35.807]                 for (kk in seq_along(NAMES)) {
[17:43:35.807]                   name <- removed[[kk]]
[17:43:35.807]                   NAME <- NAMES[[kk]]
[17:43:35.807]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:35.807]                     next
[17:43:35.807]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:35.807]                 }
[17:43:35.807]                 if (length(args) > 0) 
[17:43:35.807]                   base::do.call(base::Sys.setenv, args = args)
[17:43:35.807]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:35.807]             }
[17:43:35.807]             else {
[17:43:35.807]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:35.807]             }
[17:43:35.807]             {
[17:43:35.807]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:35.807]                   0L) {
[17:43:35.807]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:35.807]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:35.807]                   base::options(opts)
[17:43:35.807]                 }
[17:43:35.807]                 {
[17:43:35.807]                   {
[17:43:35.807]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:35.807]                     NULL
[17:43:35.807]                   }
[17:43:35.807]                   options(future.plan = NULL)
[17:43:35.807]                   if (is.na(NA_character_)) 
[17:43:35.807]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:35.807]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:35.807]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:43:35.807]                     envir = parent.frame()) 
[17:43:35.807]                   {
[17:43:35.807]                     default_workers <- missing(workers)
[17:43:35.807]                     if (is.function(workers)) 
[17:43:35.807]                       workers <- workers()
[17:43:35.807]                     workers <- structure(as.integer(workers), 
[17:43:35.807]                       class = class(workers))
[17:43:35.807]                     stop_if_not(is.finite(workers), workers >= 
[17:43:35.807]                       1L)
[17:43:35.807]                     if ((workers == 1L && !inherits(workers, 
[17:43:35.807]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:35.807]                       if (default_workers) 
[17:43:35.807]                         supportsMulticore(warn = TRUE)
[17:43:35.807]                       return(sequential(..., envir = envir))
[17:43:35.807]                     }
[17:43:35.807]                     oopts <- options(mc.cores = workers)
[17:43:35.807]                     on.exit(options(oopts))
[17:43:35.807]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:35.807]                       envir = envir)
[17:43:35.807]                     if (!future$lazy) 
[17:43:35.807]                       future <- run(future)
[17:43:35.807]                     invisible(future)
[17:43:35.807]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:35.807]                 }
[17:43:35.807]             }
[17:43:35.807]         }
[17:43:35.807]     })
[17:43:35.807]     if (TRUE) {
[17:43:35.807]         base::sink(type = "output", split = FALSE)
[17:43:35.807]         if (TRUE) {
[17:43:35.807]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:35.807]         }
[17:43:35.807]         else {
[17:43:35.807]             ...future.result["stdout"] <- base::list(NULL)
[17:43:35.807]         }
[17:43:35.807]         base::close(...future.stdout)
[17:43:35.807]         ...future.stdout <- NULL
[17:43:35.807]     }
[17:43:35.807]     ...future.result$conditions <- ...future.conditions
[17:43:35.807]     ...future.result$finished <- base::Sys.time()
[17:43:35.807]     ...future.result
[17:43:35.807] }
[17:43:35.810] assign_globals() ...
[17:43:35.810] List of 1
[17:43:35.810]  $ kk: int 1
[17:43:35.810]  - attr(*, "where")=List of 1
[17:43:35.810]   ..$ kk:<environment: R_EmptyEnv> 
[17:43:35.810]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:35.810]  - attr(*, "resolved")= logi FALSE
[17:43:35.810]  - attr(*, "total_size")= num 56
[17:43:35.810]  - attr(*, "already-done")= logi TRUE
[17:43:35.814] - copied ‘kk’ to environment
[17:43:35.814] assign_globals() ... done
[17:43:35.814] requestCore(): workers = 2
[17:43:35.815] Poll #1 (0): usedCores() = 2, workers = 2
[17:43:35.828] MulticoreFuture started
[17:43:35.829] - Launch lazy future ... done
[17:43:35.829] run() for ‘MulticoreFuture’ ... done
[17:43:35.830] plan(): Setting new future strategy stack:
[17:43:35.830] List of future strategies:
[17:43:35.830] 1. sequential:
[17:43:35.830]    - args: function (..., envir = parent.frame())
[17:43:35.830]    - tweaked: FALSE
[17:43:35.830]    - call: NULL
[17:43:35.831] plan(): nbrOfWorkers() = 1
[17:43:35.840] run() for ‘Future’ ...
[17:43:35.840] - state: ‘created’
[17:43:35.841] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:35.847] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:35.847] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:35.847]   - Field: ‘label’
[17:43:35.847]   - Field: ‘local’
[17:43:35.847]   - Field: ‘owner’
[17:43:35.848]   - Field: ‘envir’
[17:43:35.848]   - Field: ‘workers’
[17:43:35.848]   - Field: ‘packages’
[17:43:35.848]   - Field: ‘gc’
[17:43:35.848]   - Field: ‘job’
[17:43:35.848]   - Field: ‘conditions’
[17:43:35.849]   - Field: ‘expr’
[17:43:35.849]   - Field: ‘uuid’
[17:43:35.849]   - Field: ‘seed’
[17:43:35.849]   - Field: ‘version’
[17:43:35.849]   - Field: ‘result’
[17:43:35.849]   - Field: ‘asynchronous’
[17:43:35.850]   - Field: ‘calls’
[17:43:35.850]   - Field: ‘globals’
[17:43:35.850]   - Field: ‘stdout’
[17:43:35.850]   - Field: ‘earlySignal’
[17:43:35.850]   - Field: ‘lazy’
[17:43:35.850]   - Field: ‘state’
[17:43:35.851] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:35.851] - Launch lazy future ...
[17:43:35.851] Packages needed by the future expression (n = 0): <none>
[17:43:35.851] Packages needed by future strategies (n = 0): <none>
[17:43:35.852] {
[17:43:35.852]     {
[17:43:35.852]         {
[17:43:35.852]             ...future.startTime <- base::Sys.time()
[17:43:35.852]             {
[17:43:35.852]                 {
[17:43:35.852]                   {
[17:43:35.852]                     {
[17:43:35.852]                       base::local({
[17:43:35.852]                         has_future <- base::requireNamespace("future", 
[17:43:35.852]                           quietly = TRUE)
[17:43:35.852]                         if (has_future) {
[17:43:35.852]                           ns <- base::getNamespace("future")
[17:43:35.852]                           version <- ns[[".package"]][["version"]]
[17:43:35.852]                           if (is.null(version)) 
[17:43:35.852]                             version <- utils::packageVersion("future")
[17:43:35.852]                         }
[17:43:35.852]                         else {
[17:43:35.852]                           version <- NULL
[17:43:35.852]                         }
[17:43:35.852]                         if (!has_future || version < "1.8.0") {
[17:43:35.852]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:35.852]                             "", base::R.version$version.string), 
[17:43:35.852]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:35.852]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:35.852]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:35.852]                               "release", "version")], collapse = " "), 
[17:43:35.852]                             hostname = base::Sys.info()[["nodename"]])
[17:43:35.852]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:35.852]                             info)
[17:43:35.852]                           info <- base::paste(info, collapse = "; ")
[17:43:35.852]                           if (!has_future) {
[17:43:35.852]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:35.852]                               info)
[17:43:35.852]                           }
[17:43:35.852]                           else {
[17:43:35.852]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:35.852]                               info, version)
[17:43:35.852]                           }
[17:43:35.852]                           base::stop(msg)
[17:43:35.852]                         }
[17:43:35.852]                       })
[17:43:35.852]                     }
[17:43:35.852]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:35.852]                     base::options(mc.cores = 1L)
[17:43:35.852]                   }
[17:43:35.852]                   options(future.plan = NULL)
[17:43:35.852]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:35.852]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:35.852]                 }
[17:43:35.852]                 ...future.workdir <- getwd()
[17:43:35.852]             }
[17:43:35.852]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:35.852]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:35.852]         }
[17:43:35.852]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:35.852]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:35.852]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:35.852]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:35.852]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:35.852]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:35.852]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:35.852]             base::names(...future.oldOptions))
[17:43:35.852]     }
[17:43:35.852]     if (FALSE) {
[17:43:35.852]     }
[17:43:35.852]     else {
[17:43:35.852]         if (TRUE) {
[17:43:35.852]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:35.852]                 open = "w")
[17:43:35.852]         }
[17:43:35.852]         else {
[17:43:35.852]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:35.852]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:35.852]         }
[17:43:35.852]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:35.852]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:35.852]             base::sink(type = "output", split = FALSE)
[17:43:35.852]             base::close(...future.stdout)
[17:43:35.852]         }, add = TRUE)
[17:43:35.852]     }
[17:43:35.852]     ...future.frame <- base::sys.nframe()
[17:43:35.852]     ...future.conditions <- base::list()
[17:43:35.852]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:35.852]     if (FALSE) {
[17:43:35.852]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:35.852]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:35.852]     }
[17:43:35.852]     ...future.result <- base::tryCatch({
[17:43:35.852]         base::withCallingHandlers({
[17:43:35.852]             ...future.value <- base::withVisible(base::local({
[17:43:35.852]                 withCallingHandlers({
[17:43:35.852]                   {
[17:43:35.852]                     Sys.sleep(0.1)
[17:43:35.852]                     kk
[17:43:35.852]                   }
[17:43:35.852]                 }, immediateCondition = function(cond) {
[17:43:35.852]                   save_rds <- function (object, pathname, ...) 
[17:43:35.852]                   {
[17:43:35.852]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:35.852]                     if (file_test("-f", pathname_tmp)) {
[17:43:35.852]                       fi_tmp <- file.info(pathname_tmp)
[17:43:35.852]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:35.852]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:35.852]                         fi_tmp[["mtime"]])
[17:43:35.852]                     }
[17:43:35.852]                     tryCatch({
[17:43:35.852]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:35.852]                     }, error = function(ex) {
[17:43:35.852]                       msg <- conditionMessage(ex)
[17:43:35.852]                       fi_tmp <- file.info(pathname_tmp)
[17:43:35.852]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:35.852]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:35.852]                         fi_tmp[["mtime"]], msg)
[17:43:35.852]                       ex$message <- msg
[17:43:35.852]                       stop(ex)
[17:43:35.852]                     })
[17:43:35.852]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:35.852]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:35.852]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:35.852]                       fi_tmp <- file.info(pathname_tmp)
[17:43:35.852]                       fi <- file.info(pathname)
[17:43:35.852]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:35.852]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:35.852]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:35.852]                         fi[["size"]], fi[["mtime"]])
[17:43:35.852]                       stop(msg)
[17:43:35.852]                     }
[17:43:35.852]                     invisible(pathname)
[17:43:35.852]                   }
[17:43:35.852]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:35.852]                     rootPath = tempdir()) 
[17:43:35.852]                   {
[17:43:35.852]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:35.852]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:35.852]                       tmpdir = path, fileext = ".rds")
[17:43:35.852]                     save_rds(obj, file)
[17:43:35.852]                   }
[17:43:35.852]                   saveImmediateCondition(cond, path = "/tmp/RtmpLaOb2h/.future/immediateConditions")
[17:43:35.852]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:35.852]                   {
[17:43:35.852]                     inherits <- base::inherits
[17:43:35.852]                     invokeRestart <- base::invokeRestart
[17:43:35.852]                     is.null <- base::is.null
[17:43:35.852]                     muffled <- FALSE
[17:43:35.852]                     if (inherits(cond, "message")) {
[17:43:35.852]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:35.852]                       if (muffled) 
[17:43:35.852]                         invokeRestart("muffleMessage")
[17:43:35.852]                     }
[17:43:35.852]                     else if (inherits(cond, "warning")) {
[17:43:35.852]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:35.852]                       if (muffled) 
[17:43:35.852]                         invokeRestart("muffleWarning")
[17:43:35.852]                     }
[17:43:35.852]                     else if (inherits(cond, "condition")) {
[17:43:35.852]                       if (!is.null(pattern)) {
[17:43:35.852]                         computeRestarts <- base::computeRestarts
[17:43:35.852]                         grepl <- base::grepl
[17:43:35.852]                         restarts <- computeRestarts(cond)
[17:43:35.852]                         for (restart in restarts) {
[17:43:35.852]                           name <- restart$name
[17:43:35.852]                           if (is.null(name)) 
[17:43:35.852]                             next
[17:43:35.852]                           if (!grepl(pattern, name)) 
[17:43:35.852]                             next
[17:43:35.852]                           invokeRestart(restart)
[17:43:35.852]                           muffled <- TRUE
[17:43:35.852]                           break
[17:43:35.852]                         }
[17:43:35.852]                       }
[17:43:35.852]                     }
[17:43:35.852]                     invisible(muffled)
[17:43:35.852]                   }
[17:43:35.852]                   muffleCondition(cond)
[17:43:35.852]                 })
[17:43:35.852]             }))
[17:43:35.852]             future::FutureResult(value = ...future.value$value, 
[17:43:35.852]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:35.852]                   ...future.rng), globalenv = if (FALSE) 
[17:43:35.852]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:35.852]                     ...future.globalenv.names))
[17:43:35.852]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:35.852]         }, condition = base::local({
[17:43:35.852]             c <- base::c
[17:43:35.852]             inherits <- base::inherits
[17:43:35.852]             invokeRestart <- base::invokeRestart
[17:43:35.852]             length <- base::length
[17:43:35.852]             list <- base::list
[17:43:35.852]             seq.int <- base::seq.int
[17:43:35.852]             signalCondition <- base::signalCondition
[17:43:35.852]             sys.calls <- base::sys.calls
[17:43:35.852]             `[[` <- base::`[[`
[17:43:35.852]             `+` <- base::`+`
[17:43:35.852]             `<<-` <- base::`<<-`
[17:43:35.852]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:35.852]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:35.852]                   3L)]
[17:43:35.852]             }
[17:43:35.852]             function(cond) {
[17:43:35.852]                 is_error <- inherits(cond, "error")
[17:43:35.852]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:35.852]                   NULL)
[17:43:35.852]                 if (is_error) {
[17:43:35.852]                   sessionInformation <- function() {
[17:43:35.852]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:35.852]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:35.852]                       search = base::search(), system = base::Sys.info())
[17:43:35.852]                   }
[17:43:35.852]                   ...future.conditions[[length(...future.conditions) + 
[17:43:35.852]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:35.852]                     cond$call), session = sessionInformation(), 
[17:43:35.852]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:35.852]                   signalCondition(cond)
[17:43:35.852]                 }
[17:43:35.852]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:35.852]                 "immediateCondition"))) {
[17:43:35.852]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:35.852]                   ...future.conditions[[length(...future.conditions) + 
[17:43:35.852]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:35.852]                   if (TRUE && !signal) {
[17:43:35.852]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:35.852]                     {
[17:43:35.852]                       inherits <- base::inherits
[17:43:35.852]                       invokeRestart <- base::invokeRestart
[17:43:35.852]                       is.null <- base::is.null
[17:43:35.852]                       muffled <- FALSE
[17:43:35.852]                       if (inherits(cond, "message")) {
[17:43:35.852]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:35.852]                         if (muffled) 
[17:43:35.852]                           invokeRestart("muffleMessage")
[17:43:35.852]                       }
[17:43:35.852]                       else if (inherits(cond, "warning")) {
[17:43:35.852]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:35.852]                         if (muffled) 
[17:43:35.852]                           invokeRestart("muffleWarning")
[17:43:35.852]                       }
[17:43:35.852]                       else if (inherits(cond, "condition")) {
[17:43:35.852]                         if (!is.null(pattern)) {
[17:43:35.852]                           computeRestarts <- base::computeRestarts
[17:43:35.852]                           grepl <- base::grepl
[17:43:35.852]                           restarts <- computeRestarts(cond)
[17:43:35.852]                           for (restart in restarts) {
[17:43:35.852]                             name <- restart$name
[17:43:35.852]                             if (is.null(name)) 
[17:43:35.852]                               next
[17:43:35.852]                             if (!grepl(pattern, name)) 
[17:43:35.852]                               next
[17:43:35.852]                             invokeRestart(restart)
[17:43:35.852]                             muffled <- TRUE
[17:43:35.852]                             break
[17:43:35.852]                           }
[17:43:35.852]                         }
[17:43:35.852]                       }
[17:43:35.852]                       invisible(muffled)
[17:43:35.852]                     }
[17:43:35.852]                     muffleCondition(cond, pattern = "^muffle")
[17:43:35.852]                   }
[17:43:35.852]                 }
[17:43:35.852]                 else {
[17:43:35.852]                   if (TRUE) {
[17:43:35.852]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:35.852]                     {
[17:43:35.852]                       inherits <- base::inherits
[17:43:35.852]                       invokeRestart <- base::invokeRestart
[17:43:35.852]                       is.null <- base::is.null
[17:43:35.852]                       muffled <- FALSE
[17:43:35.852]                       if (inherits(cond, "message")) {
[17:43:35.852]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:35.852]                         if (muffled) 
[17:43:35.852]                           invokeRestart("muffleMessage")
[17:43:35.852]                       }
[17:43:35.852]                       else if (inherits(cond, "warning")) {
[17:43:35.852]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:35.852]                         if (muffled) 
[17:43:35.852]                           invokeRestart("muffleWarning")
[17:43:35.852]                       }
[17:43:35.852]                       else if (inherits(cond, "condition")) {
[17:43:35.852]                         if (!is.null(pattern)) {
[17:43:35.852]                           computeRestarts <- base::computeRestarts
[17:43:35.852]                           grepl <- base::grepl
[17:43:35.852]                           restarts <- computeRestarts(cond)
[17:43:35.852]                           for (restart in restarts) {
[17:43:35.852]                             name <- restart$name
[17:43:35.852]                             if (is.null(name)) 
[17:43:35.852]                               next
[17:43:35.852]                             if (!grepl(pattern, name)) 
[17:43:35.852]                               next
[17:43:35.852]                             invokeRestart(restart)
[17:43:35.852]                             muffled <- TRUE
[17:43:35.852]                             break
[17:43:35.852]                           }
[17:43:35.852]                         }
[17:43:35.852]                       }
[17:43:35.852]                       invisible(muffled)
[17:43:35.852]                     }
[17:43:35.852]                     muffleCondition(cond, pattern = "^muffle")
[17:43:35.852]                   }
[17:43:35.852]                 }
[17:43:35.852]             }
[17:43:35.852]         }))
[17:43:35.852]     }, error = function(ex) {
[17:43:35.852]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:35.852]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:35.852]                 ...future.rng), started = ...future.startTime, 
[17:43:35.852]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:35.852]             version = "1.8"), class = "FutureResult")
[17:43:35.852]     }, finally = {
[17:43:35.852]         if (!identical(...future.workdir, getwd())) 
[17:43:35.852]             setwd(...future.workdir)
[17:43:35.852]         {
[17:43:35.852]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:35.852]                 ...future.oldOptions$nwarnings <- NULL
[17:43:35.852]             }
[17:43:35.852]             base::options(...future.oldOptions)
[17:43:35.852]             if (.Platform$OS.type == "windows") {
[17:43:35.852]                 old_names <- names(...future.oldEnvVars)
[17:43:35.852]                 envs <- base::Sys.getenv()
[17:43:35.852]                 names <- names(envs)
[17:43:35.852]                 common <- intersect(names, old_names)
[17:43:35.852]                 added <- setdiff(names, old_names)
[17:43:35.852]                 removed <- setdiff(old_names, names)
[17:43:35.852]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:35.852]                   envs[common]]
[17:43:35.852]                 NAMES <- toupper(changed)
[17:43:35.852]                 args <- list()
[17:43:35.852]                 for (kk in seq_along(NAMES)) {
[17:43:35.852]                   name <- changed[[kk]]
[17:43:35.852]                   NAME <- NAMES[[kk]]
[17:43:35.852]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:35.852]                     next
[17:43:35.852]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:35.852]                 }
[17:43:35.852]                 NAMES <- toupper(added)
[17:43:35.852]                 for (kk in seq_along(NAMES)) {
[17:43:35.852]                   name <- added[[kk]]
[17:43:35.852]                   NAME <- NAMES[[kk]]
[17:43:35.852]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:35.852]                     next
[17:43:35.852]                   args[[name]] <- ""
[17:43:35.852]                 }
[17:43:35.852]                 NAMES <- toupper(removed)
[17:43:35.852]                 for (kk in seq_along(NAMES)) {
[17:43:35.852]                   name <- removed[[kk]]
[17:43:35.852]                   NAME <- NAMES[[kk]]
[17:43:35.852]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:35.852]                     next
[17:43:35.852]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:35.852]                 }
[17:43:35.852]                 if (length(args) > 0) 
[17:43:35.852]                   base::do.call(base::Sys.setenv, args = args)
[17:43:35.852]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:35.852]             }
[17:43:35.852]             else {
[17:43:35.852]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:35.852]             }
[17:43:35.852]             {
[17:43:35.852]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:35.852]                   0L) {
[17:43:35.852]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:35.852]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:35.852]                   base::options(opts)
[17:43:35.852]                 }
[17:43:35.852]                 {
[17:43:35.852]                   {
[17:43:35.852]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:35.852]                     NULL
[17:43:35.852]                   }
[17:43:35.852]                   options(future.plan = NULL)
[17:43:35.852]                   if (is.na(NA_character_)) 
[17:43:35.852]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:35.852]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:35.852]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:43:35.852]                     envir = parent.frame()) 
[17:43:35.852]                   {
[17:43:35.852]                     default_workers <- missing(workers)
[17:43:35.852]                     if (is.function(workers)) 
[17:43:35.852]                       workers <- workers()
[17:43:35.852]                     workers <- structure(as.integer(workers), 
[17:43:35.852]                       class = class(workers))
[17:43:35.852]                     stop_if_not(is.finite(workers), workers >= 
[17:43:35.852]                       1L)
[17:43:35.852]                     if ((workers == 1L && !inherits(workers, 
[17:43:35.852]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:35.852]                       if (default_workers) 
[17:43:35.852]                         supportsMulticore(warn = TRUE)
[17:43:35.852]                       return(sequential(..., envir = envir))
[17:43:35.852]                     }
[17:43:35.852]                     oopts <- options(mc.cores = workers)
[17:43:35.852]                     on.exit(options(oopts))
[17:43:35.852]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:35.852]                       envir = envir)
[17:43:35.852]                     if (!future$lazy) 
[17:43:35.852]                       future <- run(future)
[17:43:35.852]                     invisible(future)
[17:43:35.852]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:35.852]                 }
[17:43:35.852]             }
[17:43:35.852]         }
[17:43:35.852]     })
[17:43:35.852]     if (TRUE) {
[17:43:35.852]         base::sink(type = "output", split = FALSE)
[17:43:35.852]         if (TRUE) {
[17:43:35.852]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:35.852]         }
[17:43:35.852]         else {
[17:43:35.852]             ...future.result["stdout"] <- base::list(NULL)
[17:43:35.852]         }
[17:43:35.852]         base::close(...future.stdout)
[17:43:35.852]         ...future.stdout <- NULL
[17:43:35.852]     }
[17:43:35.852]     ...future.result$conditions <- ...future.conditions
[17:43:35.852]     ...future.result$finished <- base::Sys.time()
[17:43:35.852]     ...future.result
[17:43:35.852] }
[17:43:35.856] assign_globals() ...
[17:43:35.856] List of 1
[17:43:35.856]  $ kk: int 2
[17:43:35.856]  - attr(*, "where")=List of 1
[17:43:35.856]   ..$ kk:<environment: R_EmptyEnv> 
[17:43:35.856]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:35.856]  - attr(*, "resolved")= logi FALSE
[17:43:35.856]  - attr(*, "total_size")= num 56
[17:43:35.856]  - attr(*, "already-done")= logi TRUE
[17:43:35.860] - copied ‘kk’ to environment
[17:43:35.860] assign_globals() ... done
[17:43:35.861] requestCore(): workers = 2
[17:43:35.861] Poll #1 (0): usedCores() = 2, workers = 2
[17:43:35.875] MulticoreFuture started
[17:43:35.876] - Launch lazy future ... done
[17:43:35.876] run() for ‘MulticoreFuture’ ... done
[17:43:35.877] plan(): Setting new future strategy stack:
[17:43:35.877] List of future strategies:
[17:43:35.877] 1. sequential:
[17:43:35.877]    - args: function (..., envir = parent.frame())
[17:43:35.877]    - tweaked: FALSE
[17:43:35.877]    - call: NULL
[17:43:35.878] plan(): nbrOfWorkers() = 1
[17:43:35.887] run() for ‘Future’ ...
[17:43:35.887] - state: ‘created’
[17:43:35.887] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:35.894] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:35.894] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:35.894]   - Field: ‘label’
[17:43:35.895]   - Field: ‘local’
[17:43:35.895]   - Field: ‘owner’
[17:43:35.895]   - Field: ‘envir’
[17:43:35.895]   - Field: ‘workers’
[17:43:35.895]   - Field: ‘packages’
[17:43:35.896]   - Field: ‘gc’
[17:43:35.896]   - Field: ‘job’
[17:43:35.896]   - Field: ‘conditions’
[17:43:35.896]   - Field: ‘expr’
[17:43:35.896]   - Field: ‘uuid’
[17:43:35.896]   - Field: ‘seed’
[17:43:35.897]   - Field: ‘version’
[17:43:35.897]   - Field: ‘result’
[17:43:35.897]   - Field: ‘asynchronous’
[17:43:35.897]   - Field: ‘calls’
[17:43:35.897]   - Field: ‘globals’
[17:43:35.897]   - Field: ‘stdout’
[17:43:35.898]   - Field: ‘earlySignal’
[17:43:35.898]   - Field: ‘lazy’
[17:43:35.898]   - Field: ‘state’
[17:43:35.898] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:35.898] - Launch lazy future ...
[17:43:35.899] Packages needed by the future expression (n = 0): <none>
[17:43:35.903] Packages needed by future strategies (n = 0): <none>
[17:43:35.905] {
[17:43:35.905]     {
[17:43:35.905]         {
[17:43:35.905]             ...future.startTime <- base::Sys.time()
[17:43:35.905]             {
[17:43:35.905]                 {
[17:43:35.905]                   {
[17:43:35.905]                     {
[17:43:35.905]                       base::local({
[17:43:35.905]                         has_future <- base::requireNamespace("future", 
[17:43:35.905]                           quietly = TRUE)
[17:43:35.905]                         if (has_future) {
[17:43:35.905]                           ns <- base::getNamespace("future")
[17:43:35.905]                           version <- ns[[".package"]][["version"]]
[17:43:35.905]                           if (is.null(version)) 
[17:43:35.905]                             version <- utils::packageVersion("future")
[17:43:35.905]                         }
[17:43:35.905]                         else {
[17:43:35.905]                           version <- NULL
[17:43:35.905]                         }
[17:43:35.905]                         if (!has_future || version < "1.8.0") {
[17:43:35.905]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:35.905]                             "", base::R.version$version.string), 
[17:43:35.905]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:35.905]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:35.905]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:35.905]                               "release", "version")], collapse = " "), 
[17:43:35.905]                             hostname = base::Sys.info()[["nodename"]])
[17:43:35.905]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:35.905]                             info)
[17:43:35.905]                           info <- base::paste(info, collapse = "; ")
[17:43:35.905]                           if (!has_future) {
[17:43:35.905]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:35.905]                               info)
[17:43:35.905]                           }
[17:43:35.905]                           else {
[17:43:35.905]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:35.905]                               info, version)
[17:43:35.905]                           }
[17:43:35.905]                           base::stop(msg)
[17:43:35.905]                         }
[17:43:35.905]                       })
[17:43:35.905]                     }
[17:43:35.905]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:35.905]                     base::options(mc.cores = 1L)
[17:43:35.905]                   }
[17:43:35.905]                   options(future.plan = NULL)
[17:43:35.905]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:35.905]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:35.905]                 }
[17:43:35.905]                 ...future.workdir <- getwd()
[17:43:35.905]             }
[17:43:35.905]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:35.905]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:35.905]         }
[17:43:35.905]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:35.905]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:35.905]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:35.905]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:35.905]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:35.905]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:35.905]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:35.905]             base::names(...future.oldOptions))
[17:43:35.905]     }
[17:43:35.905]     if (FALSE) {
[17:43:35.905]     }
[17:43:35.905]     else {
[17:43:35.905]         if (TRUE) {
[17:43:35.905]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:35.905]                 open = "w")
[17:43:35.905]         }
[17:43:35.905]         else {
[17:43:35.905]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:35.905]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:35.905]         }
[17:43:35.905]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:35.905]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:35.905]             base::sink(type = "output", split = FALSE)
[17:43:35.905]             base::close(...future.stdout)
[17:43:35.905]         }, add = TRUE)
[17:43:35.905]     }
[17:43:35.905]     ...future.frame <- base::sys.nframe()
[17:43:35.905]     ...future.conditions <- base::list()
[17:43:35.905]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:35.905]     if (FALSE) {
[17:43:35.905]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:35.905]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:35.905]     }
[17:43:35.905]     ...future.result <- base::tryCatch({
[17:43:35.905]         base::withCallingHandlers({
[17:43:35.905]             ...future.value <- base::withVisible(base::local({
[17:43:35.905]                 withCallingHandlers({
[17:43:35.905]                   {
[17:43:35.905]                     Sys.sleep(0.1)
[17:43:35.905]                     kk
[17:43:35.905]                   }
[17:43:35.905]                 }, immediateCondition = function(cond) {
[17:43:35.905]                   save_rds <- function (object, pathname, ...) 
[17:43:35.905]                   {
[17:43:35.905]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:35.905]                     if (file_test("-f", pathname_tmp)) {
[17:43:35.905]                       fi_tmp <- file.info(pathname_tmp)
[17:43:35.905]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:35.905]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:35.905]                         fi_tmp[["mtime"]])
[17:43:35.905]                     }
[17:43:35.905]                     tryCatch({
[17:43:35.905]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:35.905]                     }, error = function(ex) {
[17:43:35.905]                       msg <- conditionMessage(ex)
[17:43:35.905]                       fi_tmp <- file.info(pathname_tmp)
[17:43:35.905]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:35.905]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:35.905]                         fi_tmp[["mtime"]], msg)
[17:43:35.905]                       ex$message <- msg
[17:43:35.905]                       stop(ex)
[17:43:35.905]                     })
[17:43:35.905]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:35.905]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:35.905]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:35.905]                       fi_tmp <- file.info(pathname_tmp)
[17:43:35.905]                       fi <- file.info(pathname)
[17:43:35.905]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:35.905]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:35.905]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:35.905]                         fi[["size"]], fi[["mtime"]])
[17:43:35.905]                       stop(msg)
[17:43:35.905]                     }
[17:43:35.905]                     invisible(pathname)
[17:43:35.905]                   }
[17:43:35.905]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:35.905]                     rootPath = tempdir()) 
[17:43:35.905]                   {
[17:43:35.905]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:35.905]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:35.905]                       tmpdir = path, fileext = ".rds")
[17:43:35.905]                     save_rds(obj, file)
[17:43:35.905]                   }
[17:43:35.905]                   saveImmediateCondition(cond, path = "/tmp/RtmpLaOb2h/.future/immediateConditions")
[17:43:35.905]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:35.905]                   {
[17:43:35.905]                     inherits <- base::inherits
[17:43:35.905]                     invokeRestart <- base::invokeRestart
[17:43:35.905]                     is.null <- base::is.null
[17:43:35.905]                     muffled <- FALSE
[17:43:35.905]                     if (inherits(cond, "message")) {
[17:43:35.905]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:35.905]                       if (muffled) 
[17:43:35.905]                         invokeRestart("muffleMessage")
[17:43:35.905]                     }
[17:43:35.905]                     else if (inherits(cond, "warning")) {
[17:43:35.905]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:35.905]                       if (muffled) 
[17:43:35.905]                         invokeRestart("muffleWarning")
[17:43:35.905]                     }
[17:43:35.905]                     else if (inherits(cond, "condition")) {
[17:43:35.905]                       if (!is.null(pattern)) {
[17:43:35.905]                         computeRestarts <- base::computeRestarts
[17:43:35.905]                         grepl <- base::grepl
[17:43:35.905]                         restarts <- computeRestarts(cond)
[17:43:35.905]                         for (restart in restarts) {
[17:43:35.905]                           name <- restart$name
[17:43:35.905]                           if (is.null(name)) 
[17:43:35.905]                             next
[17:43:35.905]                           if (!grepl(pattern, name)) 
[17:43:35.905]                             next
[17:43:35.905]                           invokeRestart(restart)
[17:43:35.905]                           muffled <- TRUE
[17:43:35.905]                           break
[17:43:35.905]                         }
[17:43:35.905]                       }
[17:43:35.905]                     }
[17:43:35.905]                     invisible(muffled)
[17:43:35.905]                   }
[17:43:35.905]                   muffleCondition(cond)
[17:43:35.905]                 })
[17:43:35.905]             }))
[17:43:35.905]             future::FutureResult(value = ...future.value$value, 
[17:43:35.905]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:35.905]                   ...future.rng), globalenv = if (FALSE) 
[17:43:35.905]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:35.905]                     ...future.globalenv.names))
[17:43:35.905]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:35.905]         }, condition = base::local({
[17:43:35.905]             c <- base::c
[17:43:35.905]             inherits <- base::inherits
[17:43:35.905]             invokeRestart <- base::invokeRestart
[17:43:35.905]             length <- base::length
[17:43:35.905]             list <- base::list
[17:43:35.905]             seq.int <- base::seq.int
[17:43:35.905]             signalCondition <- base::signalCondition
[17:43:35.905]             sys.calls <- base::sys.calls
[17:43:35.905]             `[[` <- base::`[[`
[17:43:35.905]             `+` <- base::`+`
[17:43:35.905]             `<<-` <- base::`<<-`
[17:43:35.905]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:35.905]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:35.905]                   3L)]
[17:43:35.905]             }
[17:43:35.905]             function(cond) {
[17:43:35.905]                 is_error <- inherits(cond, "error")
[17:43:35.905]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:35.905]                   NULL)
[17:43:35.905]                 if (is_error) {
[17:43:35.905]                   sessionInformation <- function() {
[17:43:35.905]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:35.905]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:35.905]                       search = base::search(), system = base::Sys.info())
[17:43:35.905]                   }
[17:43:35.905]                   ...future.conditions[[length(...future.conditions) + 
[17:43:35.905]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:35.905]                     cond$call), session = sessionInformation(), 
[17:43:35.905]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:35.905]                   signalCondition(cond)
[17:43:35.905]                 }
[17:43:35.905]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:35.905]                 "immediateCondition"))) {
[17:43:35.905]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:35.905]                   ...future.conditions[[length(...future.conditions) + 
[17:43:35.905]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:35.905]                   if (TRUE && !signal) {
[17:43:35.905]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:35.905]                     {
[17:43:35.905]                       inherits <- base::inherits
[17:43:35.905]                       invokeRestart <- base::invokeRestart
[17:43:35.905]                       is.null <- base::is.null
[17:43:35.905]                       muffled <- FALSE
[17:43:35.905]                       if (inherits(cond, "message")) {
[17:43:35.905]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:35.905]                         if (muffled) 
[17:43:35.905]                           invokeRestart("muffleMessage")
[17:43:35.905]                       }
[17:43:35.905]                       else if (inherits(cond, "warning")) {
[17:43:35.905]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:35.905]                         if (muffled) 
[17:43:35.905]                           invokeRestart("muffleWarning")
[17:43:35.905]                       }
[17:43:35.905]                       else if (inherits(cond, "condition")) {
[17:43:35.905]                         if (!is.null(pattern)) {
[17:43:35.905]                           computeRestarts <- base::computeRestarts
[17:43:35.905]                           grepl <- base::grepl
[17:43:35.905]                           restarts <- computeRestarts(cond)
[17:43:35.905]                           for (restart in restarts) {
[17:43:35.905]                             name <- restart$name
[17:43:35.905]                             if (is.null(name)) 
[17:43:35.905]                               next
[17:43:35.905]                             if (!grepl(pattern, name)) 
[17:43:35.905]                               next
[17:43:35.905]                             invokeRestart(restart)
[17:43:35.905]                             muffled <- TRUE
[17:43:35.905]                             break
[17:43:35.905]                           }
[17:43:35.905]                         }
[17:43:35.905]                       }
[17:43:35.905]                       invisible(muffled)
[17:43:35.905]                     }
[17:43:35.905]                     muffleCondition(cond, pattern = "^muffle")
[17:43:35.905]                   }
[17:43:35.905]                 }
[17:43:35.905]                 else {
[17:43:35.905]                   if (TRUE) {
[17:43:35.905]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:35.905]                     {
[17:43:35.905]                       inherits <- base::inherits
[17:43:35.905]                       invokeRestart <- base::invokeRestart
[17:43:35.905]                       is.null <- base::is.null
[17:43:35.905]                       muffled <- FALSE
[17:43:35.905]                       if (inherits(cond, "message")) {
[17:43:35.905]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:35.905]                         if (muffled) 
[17:43:35.905]                           invokeRestart("muffleMessage")
[17:43:35.905]                       }
[17:43:35.905]                       else if (inherits(cond, "warning")) {
[17:43:35.905]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:35.905]                         if (muffled) 
[17:43:35.905]                           invokeRestart("muffleWarning")
[17:43:35.905]                       }
[17:43:35.905]                       else if (inherits(cond, "condition")) {
[17:43:35.905]                         if (!is.null(pattern)) {
[17:43:35.905]                           computeRestarts <- base::computeRestarts
[17:43:35.905]                           grepl <- base::grepl
[17:43:35.905]                           restarts <- computeRestarts(cond)
[17:43:35.905]                           for (restart in restarts) {
[17:43:35.905]                             name <- restart$name
[17:43:35.905]                             if (is.null(name)) 
[17:43:35.905]                               next
[17:43:35.905]                             if (!grepl(pattern, name)) 
[17:43:35.905]                               next
[17:43:35.905]                             invokeRestart(restart)
[17:43:35.905]                             muffled <- TRUE
[17:43:35.905]                             break
[17:43:35.905]                           }
[17:43:35.905]                         }
[17:43:35.905]                       }
[17:43:35.905]                       invisible(muffled)
[17:43:35.905]                     }
[17:43:35.905]                     muffleCondition(cond, pattern = "^muffle")
[17:43:35.905]                   }
[17:43:35.905]                 }
[17:43:35.905]             }
[17:43:35.905]         }))
[17:43:35.905]     }, error = function(ex) {
[17:43:35.905]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:35.905]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:35.905]                 ...future.rng), started = ...future.startTime, 
[17:43:35.905]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:35.905]             version = "1.8"), class = "FutureResult")
[17:43:35.905]     }, finally = {
[17:43:35.905]         if (!identical(...future.workdir, getwd())) 
[17:43:35.905]             setwd(...future.workdir)
[17:43:35.905]         {
[17:43:35.905]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:35.905]                 ...future.oldOptions$nwarnings <- NULL
[17:43:35.905]             }
[17:43:35.905]             base::options(...future.oldOptions)
[17:43:35.905]             if (.Platform$OS.type == "windows") {
[17:43:35.905]                 old_names <- names(...future.oldEnvVars)
[17:43:35.905]                 envs <- base::Sys.getenv()
[17:43:35.905]                 names <- names(envs)
[17:43:35.905]                 common <- intersect(names, old_names)
[17:43:35.905]                 added <- setdiff(names, old_names)
[17:43:35.905]                 removed <- setdiff(old_names, names)
[17:43:35.905]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:35.905]                   envs[common]]
[17:43:35.905]                 NAMES <- toupper(changed)
[17:43:35.905]                 args <- list()
[17:43:35.905]                 for (kk in seq_along(NAMES)) {
[17:43:35.905]                   name <- changed[[kk]]
[17:43:35.905]                   NAME <- NAMES[[kk]]
[17:43:35.905]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:35.905]                     next
[17:43:35.905]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:35.905]                 }
[17:43:35.905]                 NAMES <- toupper(added)
[17:43:35.905]                 for (kk in seq_along(NAMES)) {
[17:43:35.905]                   name <- added[[kk]]
[17:43:35.905]                   NAME <- NAMES[[kk]]
[17:43:35.905]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:35.905]                     next
[17:43:35.905]                   args[[name]] <- ""
[17:43:35.905]                 }
[17:43:35.905]                 NAMES <- toupper(removed)
[17:43:35.905]                 for (kk in seq_along(NAMES)) {
[17:43:35.905]                   name <- removed[[kk]]
[17:43:35.905]                   NAME <- NAMES[[kk]]
[17:43:35.905]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:35.905]                     next
[17:43:35.905]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:35.905]                 }
[17:43:35.905]                 if (length(args) > 0) 
[17:43:35.905]                   base::do.call(base::Sys.setenv, args = args)
[17:43:35.905]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:35.905]             }
[17:43:35.905]             else {
[17:43:35.905]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:35.905]             }
[17:43:35.905]             {
[17:43:35.905]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:35.905]                   0L) {
[17:43:35.905]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:35.905]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:35.905]                   base::options(opts)
[17:43:35.905]                 }
[17:43:35.905]                 {
[17:43:35.905]                   {
[17:43:35.905]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:35.905]                     NULL
[17:43:35.905]                   }
[17:43:35.905]                   options(future.plan = NULL)
[17:43:35.905]                   if (is.na(NA_character_)) 
[17:43:35.905]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:35.905]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:35.905]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:43:35.905]                     envir = parent.frame()) 
[17:43:35.905]                   {
[17:43:35.905]                     default_workers <- missing(workers)
[17:43:35.905]                     if (is.function(workers)) 
[17:43:35.905]                       workers <- workers()
[17:43:35.905]                     workers <- structure(as.integer(workers), 
[17:43:35.905]                       class = class(workers))
[17:43:35.905]                     stop_if_not(is.finite(workers), workers >= 
[17:43:35.905]                       1L)
[17:43:35.905]                     if ((workers == 1L && !inherits(workers, 
[17:43:35.905]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:35.905]                       if (default_workers) 
[17:43:35.905]                         supportsMulticore(warn = TRUE)
[17:43:35.905]                       return(sequential(..., envir = envir))
[17:43:35.905]                     }
[17:43:35.905]                     oopts <- options(mc.cores = workers)
[17:43:35.905]                     on.exit(options(oopts))
[17:43:35.905]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:35.905]                       envir = envir)
[17:43:35.905]                     if (!future$lazy) 
[17:43:35.905]                       future <- run(future)
[17:43:35.905]                     invisible(future)
[17:43:35.905]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:35.905]                 }
[17:43:35.905]             }
[17:43:35.905]         }
[17:43:35.905]     })
[17:43:35.905]     if (TRUE) {
[17:43:35.905]         base::sink(type = "output", split = FALSE)
[17:43:35.905]         if (TRUE) {
[17:43:35.905]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:35.905]         }
[17:43:35.905]         else {
[17:43:35.905]             ...future.result["stdout"] <- base::list(NULL)
[17:43:35.905]         }
[17:43:35.905]         base::close(...future.stdout)
[17:43:35.905]         ...future.stdout <- NULL
[17:43:35.905]     }
[17:43:35.905]     ...future.result$conditions <- ...future.conditions
[17:43:35.905]     ...future.result$finished <- base::Sys.time()
[17:43:35.905]     ...future.result
[17:43:35.905] }
[17:43:35.908] assign_globals() ...
[17:43:35.909] List of 1
[17:43:35.909]  $ kk: int 3
[17:43:35.909]  - attr(*, "where")=List of 1
[17:43:35.909]   ..$ kk:<environment: R_EmptyEnv> 
[17:43:35.909]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:43:35.909]  - attr(*, "resolved")= logi FALSE
[17:43:35.909]  - attr(*, "total_size")= num 56
[17:43:35.909]  - attr(*, "already-done")= logi TRUE
[17:43:35.914] - copied ‘kk’ to environment
[17:43:35.914] assign_globals() ... done
[17:43:35.914] requestCore(): workers = 2
[17:43:35.915] Poll #1 (0): usedCores() = 2, workers = 2
[17:43:35.934] plan(): Setting new future strategy stack:
[17:43:35.934] List of future strategies:
[17:43:35.934] 1. multicore:
[17:43:35.934]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:35.934]    - tweaked: FALSE
[17:43:35.934]    - call: plan(strategy)
[17:43:35.939] plan(): nbrOfWorkers() = 2
[17:43:35.946] Poll #2 (0.03 secs): usedCores() = 2, workers = 2
[17:43:35.961] MulticoreFuture started
[17:43:35.962] - Launch lazy future ... done
[17:43:35.962] run() for ‘MulticoreFuture’ ... done
[17:43:35.963] plan(): Setting new future strategy stack:
[17:43:35.963] List of future strategies:
[17:43:35.963] 1. sequential:
[17:43:35.963]    - args: function (..., envir = parent.frame())
[17:43:35.963]    - tweaked: FALSE
[17:43:35.963]    - call: NULL
[17:43:35.964] plan(): nbrOfWorkers() = 1
[17:43:35.980] plan(): Setting new future strategy stack:
[17:43:35.980] List of future strategies:
[17:43:35.980] 1. multicore:
[17:43:35.980]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:35.980]    - tweaked: FALSE
[17:43:35.980]    - call: plan(strategy)
[17:43:35.984] Future #1
[17:43:35.984]  length: 2 (resolved future 1)
[17:43:35.985] plan(): nbrOfWorkers() = 2
[17:43:35.986] Future #2
[17:43:35.986]  length: 1 (resolved future 2)
[17:43:36.067] plan(): Setting new future strategy stack:
[17:43:36.068] List of future strategies:
[17:43:36.068] 1. multicore:
[17:43:36.068]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:36.068]    - tweaked: FALSE
[17:43:36.068]    - call: plan(strategy)
[17:43:36.073] plan(): nbrOfWorkers() = 2
[17:43:36.074] Future #3
[17:43:36.074]  length: 0 (resolved future 3)
[17:43:36.074] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[17:43:36.076] resolve() on environment ...
[17:43:36.076]  recursive: 0
[17:43:36.077]  elements: [2] ‘a’, ‘b’
[17:43:36.077]  length: 1 (resolved future 1)
[17:43:36.077]  length: 0 (resolved future 2)
[17:43:36.077] resolve() on environment ... DONE
[17:43:36.078] getGlobalsAndPackages() ...
[17:43:36.078] Searching for globals...
[17:43:36.079] 
[17:43:36.079] Searching for globals ... DONE
[17:43:36.079] - globals: [0] <none>
[17:43:36.079] getGlobalsAndPackages() ... DONE
[17:43:36.080] run() for ‘Future’ ...
[17:43:36.080] - state: ‘created’
[17:43:36.080] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:36.085] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:36.085] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:36.085]   - Field: ‘label’
[17:43:36.086]   - Field: ‘local’
[17:43:36.086]   - Field: ‘owner’
[17:43:36.086]   - Field: ‘envir’
[17:43:36.086]   - Field: ‘workers’
[17:43:36.086]   - Field: ‘packages’
[17:43:36.086]   - Field: ‘gc’
[17:43:36.087]   - Field: ‘job’
[17:43:36.087]   - Field: ‘conditions’
[17:43:36.087]   - Field: ‘expr’
[17:43:36.087]   - Field: ‘uuid’
[17:43:36.087]   - Field: ‘seed’
[17:43:36.087]   - Field: ‘version’
[17:43:36.088]   - Field: ‘result’
[17:43:36.088]   - Field: ‘asynchronous’
[17:43:36.088]   - Field: ‘calls’
[17:43:36.088]   - Field: ‘globals’
[17:43:36.088]   - Field: ‘stdout’
[17:43:36.088]   - Field: ‘earlySignal’
[17:43:36.089]   - Field: ‘lazy’
[17:43:36.089]   - Field: ‘state’
[17:43:36.089] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:36.089] - Launch lazy future ...
[17:43:36.090] Packages needed by the future expression (n = 0): <none>
[17:43:36.090] Packages needed by future strategies (n = 0): <none>
[17:43:36.090] {
[17:43:36.090]     {
[17:43:36.090]         {
[17:43:36.090]             ...future.startTime <- base::Sys.time()
[17:43:36.090]             {
[17:43:36.090]                 {
[17:43:36.090]                   {
[17:43:36.090]                     {
[17:43:36.090]                       base::local({
[17:43:36.090]                         has_future <- base::requireNamespace("future", 
[17:43:36.090]                           quietly = TRUE)
[17:43:36.090]                         if (has_future) {
[17:43:36.090]                           ns <- base::getNamespace("future")
[17:43:36.090]                           version <- ns[[".package"]][["version"]]
[17:43:36.090]                           if (is.null(version)) 
[17:43:36.090]                             version <- utils::packageVersion("future")
[17:43:36.090]                         }
[17:43:36.090]                         else {
[17:43:36.090]                           version <- NULL
[17:43:36.090]                         }
[17:43:36.090]                         if (!has_future || version < "1.8.0") {
[17:43:36.090]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:36.090]                             "", base::R.version$version.string), 
[17:43:36.090]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:36.090]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:36.090]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:36.090]                               "release", "version")], collapse = " "), 
[17:43:36.090]                             hostname = base::Sys.info()[["nodename"]])
[17:43:36.090]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:36.090]                             info)
[17:43:36.090]                           info <- base::paste(info, collapse = "; ")
[17:43:36.090]                           if (!has_future) {
[17:43:36.090]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:36.090]                               info)
[17:43:36.090]                           }
[17:43:36.090]                           else {
[17:43:36.090]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:36.090]                               info, version)
[17:43:36.090]                           }
[17:43:36.090]                           base::stop(msg)
[17:43:36.090]                         }
[17:43:36.090]                       })
[17:43:36.090]                     }
[17:43:36.090]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:36.090]                     base::options(mc.cores = 1L)
[17:43:36.090]                   }
[17:43:36.090]                   options(future.plan = NULL)
[17:43:36.090]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:36.090]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:36.090]                 }
[17:43:36.090]                 ...future.workdir <- getwd()
[17:43:36.090]             }
[17:43:36.090]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:36.090]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:36.090]         }
[17:43:36.090]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:36.090]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:36.090]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:36.090]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:36.090]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:36.090]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:36.090]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:36.090]             base::names(...future.oldOptions))
[17:43:36.090]     }
[17:43:36.090]     if (FALSE) {
[17:43:36.090]     }
[17:43:36.090]     else {
[17:43:36.090]         if (TRUE) {
[17:43:36.090]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:36.090]                 open = "w")
[17:43:36.090]         }
[17:43:36.090]         else {
[17:43:36.090]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:36.090]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:36.090]         }
[17:43:36.090]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:36.090]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:36.090]             base::sink(type = "output", split = FALSE)
[17:43:36.090]             base::close(...future.stdout)
[17:43:36.090]         }, add = TRUE)
[17:43:36.090]     }
[17:43:36.090]     ...future.frame <- base::sys.nframe()
[17:43:36.090]     ...future.conditions <- base::list()
[17:43:36.090]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:36.090]     if (FALSE) {
[17:43:36.090]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:36.090]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:36.090]     }
[17:43:36.090]     ...future.result <- base::tryCatch({
[17:43:36.090]         base::withCallingHandlers({
[17:43:36.090]             ...future.value <- base::withVisible(base::local({
[17:43:36.090]                 withCallingHandlers({
[17:43:36.090]                   1
[17:43:36.090]                 }, immediateCondition = function(cond) {
[17:43:36.090]                   save_rds <- function (object, pathname, ...) 
[17:43:36.090]                   {
[17:43:36.090]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:36.090]                     if (file_test("-f", pathname_tmp)) {
[17:43:36.090]                       fi_tmp <- file.info(pathname_tmp)
[17:43:36.090]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:36.090]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:36.090]                         fi_tmp[["mtime"]])
[17:43:36.090]                     }
[17:43:36.090]                     tryCatch({
[17:43:36.090]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:36.090]                     }, error = function(ex) {
[17:43:36.090]                       msg <- conditionMessage(ex)
[17:43:36.090]                       fi_tmp <- file.info(pathname_tmp)
[17:43:36.090]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:36.090]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:36.090]                         fi_tmp[["mtime"]], msg)
[17:43:36.090]                       ex$message <- msg
[17:43:36.090]                       stop(ex)
[17:43:36.090]                     })
[17:43:36.090]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:36.090]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:36.090]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:36.090]                       fi_tmp <- file.info(pathname_tmp)
[17:43:36.090]                       fi <- file.info(pathname)
[17:43:36.090]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:36.090]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:36.090]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:36.090]                         fi[["size"]], fi[["mtime"]])
[17:43:36.090]                       stop(msg)
[17:43:36.090]                     }
[17:43:36.090]                     invisible(pathname)
[17:43:36.090]                   }
[17:43:36.090]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:36.090]                     rootPath = tempdir()) 
[17:43:36.090]                   {
[17:43:36.090]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:36.090]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:36.090]                       tmpdir = path, fileext = ".rds")
[17:43:36.090]                     save_rds(obj, file)
[17:43:36.090]                   }
[17:43:36.090]                   saveImmediateCondition(cond, path = "/tmp/RtmpLaOb2h/.future/immediateConditions")
[17:43:36.090]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:36.090]                   {
[17:43:36.090]                     inherits <- base::inherits
[17:43:36.090]                     invokeRestart <- base::invokeRestart
[17:43:36.090]                     is.null <- base::is.null
[17:43:36.090]                     muffled <- FALSE
[17:43:36.090]                     if (inherits(cond, "message")) {
[17:43:36.090]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:36.090]                       if (muffled) 
[17:43:36.090]                         invokeRestart("muffleMessage")
[17:43:36.090]                     }
[17:43:36.090]                     else if (inherits(cond, "warning")) {
[17:43:36.090]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:36.090]                       if (muffled) 
[17:43:36.090]                         invokeRestart("muffleWarning")
[17:43:36.090]                     }
[17:43:36.090]                     else if (inherits(cond, "condition")) {
[17:43:36.090]                       if (!is.null(pattern)) {
[17:43:36.090]                         computeRestarts <- base::computeRestarts
[17:43:36.090]                         grepl <- base::grepl
[17:43:36.090]                         restarts <- computeRestarts(cond)
[17:43:36.090]                         for (restart in restarts) {
[17:43:36.090]                           name <- restart$name
[17:43:36.090]                           if (is.null(name)) 
[17:43:36.090]                             next
[17:43:36.090]                           if (!grepl(pattern, name)) 
[17:43:36.090]                             next
[17:43:36.090]                           invokeRestart(restart)
[17:43:36.090]                           muffled <- TRUE
[17:43:36.090]                           break
[17:43:36.090]                         }
[17:43:36.090]                       }
[17:43:36.090]                     }
[17:43:36.090]                     invisible(muffled)
[17:43:36.090]                   }
[17:43:36.090]                   muffleCondition(cond)
[17:43:36.090]                 })
[17:43:36.090]             }))
[17:43:36.090]             future::FutureResult(value = ...future.value$value, 
[17:43:36.090]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:36.090]                   ...future.rng), globalenv = if (FALSE) 
[17:43:36.090]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:36.090]                     ...future.globalenv.names))
[17:43:36.090]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:36.090]         }, condition = base::local({
[17:43:36.090]             c <- base::c
[17:43:36.090]             inherits <- base::inherits
[17:43:36.090]             invokeRestart <- base::invokeRestart
[17:43:36.090]             length <- base::length
[17:43:36.090]             list <- base::list
[17:43:36.090]             seq.int <- base::seq.int
[17:43:36.090]             signalCondition <- base::signalCondition
[17:43:36.090]             sys.calls <- base::sys.calls
[17:43:36.090]             `[[` <- base::`[[`
[17:43:36.090]             `+` <- base::`+`
[17:43:36.090]             `<<-` <- base::`<<-`
[17:43:36.090]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:36.090]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:36.090]                   3L)]
[17:43:36.090]             }
[17:43:36.090]             function(cond) {
[17:43:36.090]                 is_error <- inherits(cond, "error")
[17:43:36.090]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:36.090]                   NULL)
[17:43:36.090]                 if (is_error) {
[17:43:36.090]                   sessionInformation <- function() {
[17:43:36.090]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:36.090]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:36.090]                       search = base::search(), system = base::Sys.info())
[17:43:36.090]                   }
[17:43:36.090]                   ...future.conditions[[length(...future.conditions) + 
[17:43:36.090]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:36.090]                     cond$call), session = sessionInformation(), 
[17:43:36.090]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:36.090]                   signalCondition(cond)
[17:43:36.090]                 }
[17:43:36.090]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:36.090]                 "immediateCondition"))) {
[17:43:36.090]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:36.090]                   ...future.conditions[[length(...future.conditions) + 
[17:43:36.090]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:36.090]                   if (TRUE && !signal) {
[17:43:36.090]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:36.090]                     {
[17:43:36.090]                       inherits <- base::inherits
[17:43:36.090]                       invokeRestart <- base::invokeRestart
[17:43:36.090]                       is.null <- base::is.null
[17:43:36.090]                       muffled <- FALSE
[17:43:36.090]                       if (inherits(cond, "message")) {
[17:43:36.090]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:36.090]                         if (muffled) 
[17:43:36.090]                           invokeRestart("muffleMessage")
[17:43:36.090]                       }
[17:43:36.090]                       else if (inherits(cond, "warning")) {
[17:43:36.090]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:36.090]                         if (muffled) 
[17:43:36.090]                           invokeRestart("muffleWarning")
[17:43:36.090]                       }
[17:43:36.090]                       else if (inherits(cond, "condition")) {
[17:43:36.090]                         if (!is.null(pattern)) {
[17:43:36.090]                           computeRestarts <- base::computeRestarts
[17:43:36.090]                           grepl <- base::grepl
[17:43:36.090]                           restarts <- computeRestarts(cond)
[17:43:36.090]                           for (restart in restarts) {
[17:43:36.090]                             name <- restart$name
[17:43:36.090]                             if (is.null(name)) 
[17:43:36.090]                               next
[17:43:36.090]                             if (!grepl(pattern, name)) 
[17:43:36.090]                               next
[17:43:36.090]                             invokeRestart(restart)
[17:43:36.090]                             muffled <- TRUE
[17:43:36.090]                             break
[17:43:36.090]                           }
[17:43:36.090]                         }
[17:43:36.090]                       }
[17:43:36.090]                       invisible(muffled)
[17:43:36.090]                     }
[17:43:36.090]                     muffleCondition(cond, pattern = "^muffle")
[17:43:36.090]                   }
[17:43:36.090]                 }
[17:43:36.090]                 else {
[17:43:36.090]                   if (TRUE) {
[17:43:36.090]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:36.090]                     {
[17:43:36.090]                       inherits <- base::inherits
[17:43:36.090]                       invokeRestart <- base::invokeRestart
[17:43:36.090]                       is.null <- base::is.null
[17:43:36.090]                       muffled <- FALSE
[17:43:36.090]                       if (inherits(cond, "message")) {
[17:43:36.090]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:36.090]                         if (muffled) 
[17:43:36.090]                           invokeRestart("muffleMessage")
[17:43:36.090]                       }
[17:43:36.090]                       else if (inherits(cond, "warning")) {
[17:43:36.090]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:36.090]                         if (muffled) 
[17:43:36.090]                           invokeRestart("muffleWarning")
[17:43:36.090]                       }
[17:43:36.090]                       else if (inherits(cond, "condition")) {
[17:43:36.090]                         if (!is.null(pattern)) {
[17:43:36.090]                           computeRestarts <- base::computeRestarts
[17:43:36.090]                           grepl <- base::grepl
[17:43:36.090]                           restarts <- computeRestarts(cond)
[17:43:36.090]                           for (restart in restarts) {
[17:43:36.090]                             name <- restart$name
[17:43:36.090]                             if (is.null(name)) 
[17:43:36.090]                               next
[17:43:36.090]                             if (!grepl(pattern, name)) 
[17:43:36.090]                               next
[17:43:36.090]                             invokeRestart(restart)
[17:43:36.090]                             muffled <- TRUE
[17:43:36.090]                             break
[17:43:36.090]                           }
[17:43:36.090]                         }
[17:43:36.090]                       }
[17:43:36.090]                       invisible(muffled)
[17:43:36.090]                     }
[17:43:36.090]                     muffleCondition(cond, pattern = "^muffle")
[17:43:36.090]                   }
[17:43:36.090]                 }
[17:43:36.090]             }
[17:43:36.090]         }))
[17:43:36.090]     }, error = function(ex) {
[17:43:36.090]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:36.090]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:36.090]                 ...future.rng), started = ...future.startTime, 
[17:43:36.090]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:36.090]             version = "1.8"), class = "FutureResult")
[17:43:36.090]     }, finally = {
[17:43:36.090]         if (!identical(...future.workdir, getwd())) 
[17:43:36.090]             setwd(...future.workdir)
[17:43:36.090]         {
[17:43:36.090]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:36.090]                 ...future.oldOptions$nwarnings <- NULL
[17:43:36.090]             }
[17:43:36.090]             base::options(...future.oldOptions)
[17:43:36.090]             if (.Platform$OS.type == "windows") {
[17:43:36.090]                 old_names <- names(...future.oldEnvVars)
[17:43:36.090]                 envs <- base::Sys.getenv()
[17:43:36.090]                 names <- names(envs)
[17:43:36.090]                 common <- intersect(names, old_names)
[17:43:36.090]                 added <- setdiff(names, old_names)
[17:43:36.090]                 removed <- setdiff(old_names, names)
[17:43:36.090]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:36.090]                   envs[common]]
[17:43:36.090]                 NAMES <- toupper(changed)
[17:43:36.090]                 args <- list()
[17:43:36.090]                 for (kk in seq_along(NAMES)) {
[17:43:36.090]                   name <- changed[[kk]]
[17:43:36.090]                   NAME <- NAMES[[kk]]
[17:43:36.090]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:36.090]                     next
[17:43:36.090]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:36.090]                 }
[17:43:36.090]                 NAMES <- toupper(added)
[17:43:36.090]                 for (kk in seq_along(NAMES)) {
[17:43:36.090]                   name <- added[[kk]]
[17:43:36.090]                   NAME <- NAMES[[kk]]
[17:43:36.090]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:36.090]                     next
[17:43:36.090]                   args[[name]] <- ""
[17:43:36.090]                 }
[17:43:36.090]                 NAMES <- toupper(removed)
[17:43:36.090]                 for (kk in seq_along(NAMES)) {
[17:43:36.090]                   name <- removed[[kk]]
[17:43:36.090]                   NAME <- NAMES[[kk]]
[17:43:36.090]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:36.090]                     next
[17:43:36.090]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:36.090]                 }
[17:43:36.090]                 if (length(args) > 0) 
[17:43:36.090]                   base::do.call(base::Sys.setenv, args = args)
[17:43:36.090]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:36.090]             }
[17:43:36.090]             else {
[17:43:36.090]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:36.090]             }
[17:43:36.090]             {
[17:43:36.090]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:36.090]                   0L) {
[17:43:36.090]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:36.090]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:36.090]                   base::options(opts)
[17:43:36.090]                 }
[17:43:36.090]                 {
[17:43:36.090]                   {
[17:43:36.090]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:36.090]                     NULL
[17:43:36.090]                   }
[17:43:36.090]                   options(future.plan = NULL)
[17:43:36.090]                   if (is.na(NA_character_)) 
[17:43:36.090]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:36.090]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:36.090]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:43:36.090]                     envir = parent.frame()) 
[17:43:36.090]                   {
[17:43:36.090]                     default_workers <- missing(workers)
[17:43:36.090]                     if (is.function(workers)) 
[17:43:36.090]                       workers <- workers()
[17:43:36.090]                     workers <- structure(as.integer(workers), 
[17:43:36.090]                       class = class(workers))
[17:43:36.090]                     stop_if_not(is.finite(workers), workers >= 
[17:43:36.090]                       1L)
[17:43:36.090]                     if ((workers == 1L && !inherits(workers, 
[17:43:36.090]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:36.090]                       if (default_workers) 
[17:43:36.090]                         supportsMulticore(warn = TRUE)
[17:43:36.090]                       return(sequential(..., envir = envir))
[17:43:36.090]                     }
[17:43:36.090]                     oopts <- options(mc.cores = workers)
[17:43:36.090]                     on.exit(options(oopts))
[17:43:36.090]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:36.090]                       envir = envir)
[17:43:36.090]                     if (!future$lazy) 
[17:43:36.090]                       future <- run(future)
[17:43:36.090]                     invisible(future)
[17:43:36.090]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:36.090]                 }
[17:43:36.090]             }
[17:43:36.090]         }
[17:43:36.090]     })
[17:43:36.090]     if (TRUE) {
[17:43:36.090]         base::sink(type = "output", split = FALSE)
[17:43:36.090]         if (TRUE) {
[17:43:36.090]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:36.090]         }
[17:43:36.090]         else {
[17:43:36.090]             ...future.result["stdout"] <- base::list(NULL)
[17:43:36.090]         }
[17:43:36.090]         base::close(...future.stdout)
[17:43:36.090]         ...future.stdout <- NULL
[17:43:36.090]     }
[17:43:36.090]     ...future.result$conditions <- ...future.conditions
[17:43:36.090]     ...future.result$finished <- base::Sys.time()
[17:43:36.090]     ...future.result
[17:43:36.090] }
[17:43:36.094] requestCore(): workers = 2
[17:43:36.094] Poll #1 (0): usedCores() = 2, workers = 2
[17:43:36.108] MulticoreFuture started
[17:43:36.109] - Launch lazy future ... done
[17:43:36.109] run() for ‘MulticoreFuture’ ... done
[17:43:36.110] getGlobalsAndPackages() ...
[17:43:36.110] plan(): Setting new future strategy stack:
[17:43:36.110] Searching for globals...
[17:43:36.110] List of future strategies:
[17:43:36.110] 1. sequential:
[17:43:36.110]    - args: function (..., envir = parent.frame())
[17:43:36.110]    - tweaked: FALSE
[17:43:36.110]    - call: NULL
[17:43:36.111] 
[17:43:36.111] Searching for globals ... DONE
[17:43:36.111] plan(): nbrOfWorkers() = 1
[17:43:36.112] - globals: [0] <none>
[17:43:36.112] getGlobalsAndPackages() ... DONE
[17:43:36.113] run() for ‘Future’ ...
[17:43:36.113] - state: ‘created’
[17:43:36.113] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:36.114] plan(): Setting new future strategy stack:
[17:43:36.114] List of future strategies:
[17:43:36.114] 1. multicore:
[17:43:36.114]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:36.114]    - tweaked: FALSE
[17:43:36.114]    - call: plan(strategy)
[17:43:36.120] plan(): nbrOfWorkers() = 2
[17:43:36.120] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:36.121] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:36.121]   - Field: ‘label’
[17:43:36.121]   - Field: ‘local’
[17:43:36.121]   - Field: ‘owner’
[17:43:36.121]   - Field: ‘envir’
[17:43:36.121]   - Field: ‘workers’
[17:43:36.122]   - Field: ‘packages’
[17:43:36.122]   - Field: ‘gc’
[17:43:36.122]   - Field: ‘job’
[17:43:36.122]   - Field: ‘conditions’
[17:43:36.122]   - Field: ‘expr’
[17:43:36.122]   - Field: ‘uuid’
[17:43:36.123]   - Field: ‘seed’
[17:43:36.123]   - Field: ‘version’
[17:43:36.123]   - Field: ‘result’
[17:43:36.123]   - Field: ‘asynchronous’
[17:43:36.123]   - Field: ‘calls’
[17:43:36.123]   - Field: ‘globals’
[17:43:36.124]   - Field: ‘stdout’
[17:43:36.124]   - Field: ‘earlySignal’
[17:43:36.124]   - Field: ‘lazy’
[17:43:36.124]   - Field: ‘state’
[17:43:36.124] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:36.124] - Launch lazy future ...
[17:43:36.125] Packages needed by the future expression (n = 0): <none>
[17:43:36.125] Packages needed by future strategies (n = 0): <none>
[17:43:36.126] {
[17:43:36.126]     {
[17:43:36.126]         {
[17:43:36.126]             ...future.startTime <- base::Sys.time()
[17:43:36.126]             {
[17:43:36.126]                 {
[17:43:36.126]                   {
[17:43:36.126]                     {
[17:43:36.126]                       base::local({
[17:43:36.126]                         has_future <- base::requireNamespace("future", 
[17:43:36.126]                           quietly = TRUE)
[17:43:36.126]                         if (has_future) {
[17:43:36.126]                           ns <- base::getNamespace("future")
[17:43:36.126]                           version <- ns[[".package"]][["version"]]
[17:43:36.126]                           if (is.null(version)) 
[17:43:36.126]                             version <- utils::packageVersion("future")
[17:43:36.126]                         }
[17:43:36.126]                         else {
[17:43:36.126]                           version <- NULL
[17:43:36.126]                         }
[17:43:36.126]                         if (!has_future || version < "1.8.0") {
[17:43:36.126]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:36.126]                             "", base::R.version$version.string), 
[17:43:36.126]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:36.126]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:36.126]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:36.126]                               "release", "version")], collapse = " "), 
[17:43:36.126]                             hostname = base::Sys.info()[["nodename"]])
[17:43:36.126]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:36.126]                             info)
[17:43:36.126]                           info <- base::paste(info, collapse = "; ")
[17:43:36.126]                           if (!has_future) {
[17:43:36.126]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:36.126]                               info)
[17:43:36.126]                           }
[17:43:36.126]                           else {
[17:43:36.126]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:36.126]                               info, version)
[17:43:36.126]                           }
[17:43:36.126]                           base::stop(msg)
[17:43:36.126]                         }
[17:43:36.126]                       })
[17:43:36.126]                     }
[17:43:36.126]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:36.126]                     base::options(mc.cores = 1L)
[17:43:36.126]                   }
[17:43:36.126]                   options(future.plan = NULL)
[17:43:36.126]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:36.126]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:36.126]                 }
[17:43:36.126]                 ...future.workdir <- getwd()
[17:43:36.126]             }
[17:43:36.126]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:36.126]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:36.126]         }
[17:43:36.126]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:36.126]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:36.126]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:36.126]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:36.126]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:36.126]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:36.126]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:36.126]             base::names(...future.oldOptions))
[17:43:36.126]     }
[17:43:36.126]     if (FALSE) {
[17:43:36.126]     }
[17:43:36.126]     else {
[17:43:36.126]         if (TRUE) {
[17:43:36.126]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:36.126]                 open = "w")
[17:43:36.126]         }
[17:43:36.126]         else {
[17:43:36.126]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:36.126]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:36.126]         }
[17:43:36.126]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:36.126]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:36.126]             base::sink(type = "output", split = FALSE)
[17:43:36.126]             base::close(...future.stdout)
[17:43:36.126]         }, add = TRUE)
[17:43:36.126]     }
[17:43:36.126]     ...future.frame <- base::sys.nframe()
[17:43:36.126]     ...future.conditions <- base::list()
[17:43:36.126]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:36.126]     if (FALSE) {
[17:43:36.126]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:36.126]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:36.126]     }
[17:43:36.126]     ...future.result <- base::tryCatch({
[17:43:36.126]         base::withCallingHandlers({
[17:43:36.126]             ...future.value <- base::withVisible(base::local({
[17:43:36.126]                 withCallingHandlers({
[17:43:36.126]                   2
[17:43:36.126]                 }, immediateCondition = function(cond) {
[17:43:36.126]                   save_rds <- function (object, pathname, ...) 
[17:43:36.126]                   {
[17:43:36.126]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:36.126]                     if (file_test("-f", pathname_tmp)) {
[17:43:36.126]                       fi_tmp <- file.info(pathname_tmp)
[17:43:36.126]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:36.126]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:36.126]                         fi_tmp[["mtime"]])
[17:43:36.126]                     }
[17:43:36.126]                     tryCatch({
[17:43:36.126]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:36.126]                     }, error = function(ex) {
[17:43:36.126]                       msg <- conditionMessage(ex)
[17:43:36.126]                       fi_tmp <- file.info(pathname_tmp)
[17:43:36.126]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:36.126]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:36.126]                         fi_tmp[["mtime"]], msg)
[17:43:36.126]                       ex$message <- msg
[17:43:36.126]                       stop(ex)
[17:43:36.126]                     })
[17:43:36.126]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:36.126]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:36.126]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:36.126]                       fi_tmp <- file.info(pathname_tmp)
[17:43:36.126]                       fi <- file.info(pathname)
[17:43:36.126]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:36.126]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:36.126]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:36.126]                         fi[["size"]], fi[["mtime"]])
[17:43:36.126]                       stop(msg)
[17:43:36.126]                     }
[17:43:36.126]                     invisible(pathname)
[17:43:36.126]                   }
[17:43:36.126]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:36.126]                     rootPath = tempdir()) 
[17:43:36.126]                   {
[17:43:36.126]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:36.126]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:36.126]                       tmpdir = path, fileext = ".rds")
[17:43:36.126]                     save_rds(obj, file)
[17:43:36.126]                   }
[17:43:36.126]                   saveImmediateCondition(cond, path = "/tmp/RtmpLaOb2h/.future/immediateConditions")
[17:43:36.126]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:36.126]                   {
[17:43:36.126]                     inherits <- base::inherits
[17:43:36.126]                     invokeRestart <- base::invokeRestart
[17:43:36.126]                     is.null <- base::is.null
[17:43:36.126]                     muffled <- FALSE
[17:43:36.126]                     if (inherits(cond, "message")) {
[17:43:36.126]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:36.126]                       if (muffled) 
[17:43:36.126]                         invokeRestart("muffleMessage")
[17:43:36.126]                     }
[17:43:36.126]                     else if (inherits(cond, "warning")) {
[17:43:36.126]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:36.126]                       if (muffled) 
[17:43:36.126]                         invokeRestart("muffleWarning")
[17:43:36.126]                     }
[17:43:36.126]                     else if (inherits(cond, "condition")) {
[17:43:36.126]                       if (!is.null(pattern)) {
[17:43:36.126]                         computeRestarts <- base::computeRestarts
[17:43:36.126]                         grepl <- base::grepl
[17:43:36.126]                         restarts <- computeRestarts(cond)
[17:43:36.126]                         for (restart in restarts) {
[17:43:36.126]                           name <- restart$name
[17:43:36.126]                           if (is.null(name)) 
[17:43:36.126]                             next
[17:43:36.126]                           if (!grepl(pattern, name)) 
[17:43:36.126]                             next
[17:43:36.126]                           invokeRestart(restart)
[17:43:36.126]                           muffled <- TRUE
[17:43:36.126]                           break
[17:43:36.126]                         }
[17:43:36.126]                       }
[17:43:36.126]                     }
[17:43:36.126]                     invisible(muffled)
[17:43:36.126]                   }
[17:43:36.126]                   muffleCondition(cond)
[17:43:36.126]                 })
[17:43:36.126]             }))
[17:43:36.126]             future::FutureResult(value = ...future.value$value, 
[17:43:36.126]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:36.126]                   ...future.rng), globalenv = if (FALSE) 
[17:43:36.126]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:36.126]                     ...future.globalenv.names))
[17:43:36.126]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:36.126]         }, condition = base::local({
[17:43:36.126]             c <- base::c
[17:43:36.126]             inherits <- base::inherits
[17:43:36.126]             invokeRestart <- base::invokeRestart
[17:43:36.126]             length <- base::length
[17:43:36.126]             list <- base::list
[17:43:36.126]             seq.int <- base::seq.int
[17:43:36.126]             signalCondition <- base::signalCondition
[17:43:36.126]             sys.calls <- base::sys.calls
[17:43:36.126]             `[[` <- base::`[[`
[17:43:36.126]             `+` <- base::`+`
[17:43:36.126]             `<<-` <- base::`<<-`
[17:43:36.126]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:36.126]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:36.126]                   3L)]
[17:43:36.126]             }
[17:43:36.126]             function(cond) {
[17:43:36.126]                 is_error <- inherits(cond, "error")
[17:43:36.126]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:36.126]                   NULL)
[17:43:36.126]                 if (is_error) {
[17:43:36.126]                   sessionInformation <- function() {
[17:43:36.126]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:36.126]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:36.126]                       search = base::search(), system = base::Sys.info())
[17:43:36.126]                   }
[17:43:36.126]                   ...future.conditions[[length(...future.conditions) + 
[17:43:36.126]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:36.126]                     cond$call), session = sessionInformation(), 
[17:43:36.126]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:36.126]                   signalCondition(cond)
[17:43:36.126]                 }
[17:43:36.126]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:36.126]                 "immediateCondition"))) {
[17:43:36.126]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:36.126]                   ...future.conditions[[length(...future.conditions) + 
[17:43:36.126]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:36.126]                   if (TRUE && !signal) {
[17:43:36.126]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:36.126]                     {
[17:43:36.126]                       inherits <- base::inherits
[17:43:36.126]                       invokeRestart <- base::invokeRestart
[17:43:36.126]                       is.null <- base::is.null
[17:43:36.126]                       muffled <- FALSE
[17:43:36.126]                       if (inherits(cond, "message")) {
[17:43:36.126]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:36.126]                         if (muffled) 
[17:43:36.126]                           invokeRestart("muffleMessage")
[17:43:36.126]                       }
[17:43:36.126]                       else if (inherits(cond, "warning")) {
[17:43:36.126]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:36.126]                         if (muffled) 
[17:43:36.126]                           invokeRestart("muffleWarning")
[17:43:36.126]                       }
[17:43:36.126]                       else if (inherits(cond, "condition")) {
[17:43:36.126]                         if (!is.null(pattern)) {
[17:43:36.126]                           computeRestarts <- base::computeRestarts
[17:43:36.126]                           grepl <- base::grepl
[17:43:36.126]                           restarts <- computeRestarts(cond)
[17:43:36.126]                           for (restart in restarts) {
[17:43:36.126]                             name <- restart$name
[17:43:36.126]                             if (is.null(name)) 
[17:43:36.126]                               next
[17:43:36.126]                             if (!grepl(pattern, name)) 
[17:43:36.126]                               next
[17:43:36.126]                             invokeRestart(restart)
[17:43:36.126]                             muffled <- TRUE
[17:43:36.126]                             break
[17:43:36.126]                           }
[17:43:36.126]                         }
[17:43:36.126]                       }
[17:43:36.126]                       invisible(muffled)
[17:43:36.126]                     }
[17:43:36.126]                     muffleCondition(cond, pattern = "^muffle")
[17:43:36.126]                   }
[17:43:36.126]                 }
[17:43:36.126]                 else {
[17:43:36.126]                   if (TRUE) {
[17:43:36.126]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:36.126]                     {
[17:43:36.126]                       inherits <- base::inherits
[17:43:36.126]                       invokeRestart <- base::invokeRestart
[17:43:36.126]                       is.null <- base::is.null
[17:43:36.126]                       muffled <- FALSE
[17:43:36.126]                       if (inherits(cond, "message")) {
[17:43:36.126]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:36.126]                         if (muffled) 
[17:43:36.126]                           invokeRestart("muffleMessage")
[17:43:36.126]                       }
[17:43:36.126]                       else if (inherits(cond, "warning")) {
[17:43:36.126]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:36.126]                         if (muffled) 
[17:43:36.126]                           invokeRestart("muffleWarning")
[17:43:36.126]                       }
[17:43:36.126]                       else if (inherits(cond, "condition")) {
[17:43:36.126]                         if (!is.null(pattern)) {
[17:43:36.126]                           computeRestarts <- base::computeRestarts
[17:43:36.126]                           grepl <- base::grepl
[17:43:36.126]                           restarts <- computeRestarts(cond)
[17:43:36.126]                           for (restart in restarts) {
[17:43:36.126]                             name <- restart$name
[17:43:36.126]                             if (is.null(name)) 
[17:43:36.126]                               next
[17:43:36.126]                             if (!grepl(pattern, name)) 
[17:43:36.126]                               next
[17:43:36.126]                             invokeRestart(restart)
[17:43:36.126]                             muffled <- TRUE
[17:43:36.126]                             break
[17:43:36.126]                           }
[17:43:36.126]                         }
[17:43:36.126]                       }
[17:43:36.126]                       invisible(muffled)
[17:43:36.126]                     }
[17:43:36.126]                     muffleCondition(cond, pattern = "^muffle")
[17:43:36.126]                   }
[17:43:36.126]                 }
[17:43:36.126]             }
[17:43:36.126]         }))
[17:43:36.126]     }, error = function(ex) {
[17:43:36.126]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:36.126]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:36.126]                 ...future.rng), started = ...future.startTime, 
[17:43:36.126]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:36.126]             version = "1.8"), class = "FutureResult")
[17:43:36.126]     }, finally = {
[17:43:36.126]         if (!identical(...future.workdir, getwd())) 
[17:43:36.126]             setwd(...future.workdir)
[17:43:36.126]         {
[17:43:36.126]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:36.126]                 ...future.oldOptions$nwarnings <- NULL
[17:43:36.126]             }
[17:43:36.126]             base::options(...future.oldOptions)
[17:43:36.126]             if (.Platform$OS.type == "windows") {
[17:43:36.126]                 old_names <- names(...future.oldEnvVars)
[17:43:36.126]                 envs <- base::Sys.getenv()
[17:43:36.126]                 names <- names(envs)
[17:43:36.126]                 common <- intersect(names, old_names)
[17:43:36.126]                 added <- setdiff(names, old_names)
[17:43:36.126]                 removed <- setdiff(old_names, names)
[17:43:36.126]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:36.126]                   envs[common]]
[17:43:36.126]                 NAMES <- toupper(changed)
[17:43:36.126]                 args <- list()
[17:43:36.126]                 for (kk in seq_along(NAMES)) {
[17:43:36.126]                   name <- changed[[kk]]
[17:43:36.126]                   NAME <- NAMES[[kk]]
[17:43:36.126]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:36.126]                     next
[17:43:36.126]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:36.126]                 }
[17:43:36.126]                 NAMES <- toupper(added)
[17:43:36.126]                 for (kk in seq_along(NAMES)) {
[17:43:36.126]                   name <- added[[kk]]
[17:43:36.126]                   NAME <- NAMES[[kk]]
[17:43:36.126]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:36.126]                     next
[17:43:36.126]                   args[[name]] <- ""
[17:43:36.126]                 }
[17:43:36.126]                 NAMES <- toupper(removed)
[17:43:36.126]                 for (kk in seq_along(NAMES)) {
[17:43:36.126]                   name <- removed[[kk]]
[17:43:36.126]                   NAME <- NAMES[[kk]]
[17:43:36.126]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:36.126]                     next
[17:43:36.126]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:36.126]                 }
[17:43:36.126]                 if (length(args) > 0) 
[17:43:36.126]                   base::do.call(base::Sys.setenv, args = args)
[17:43:36.126]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:36.126]             }
[17:43:36.126]             else {
[17:43:36.126]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:36.126]             }
[17:43:36.126]             {
[17:43:36.126]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:36.126]                   0L) {
[17:43:36.126]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:36.126]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:36.126]                   base::options(opts)
[17:43:36.126]                 }
[17:43:36.126]                 {
[17:43:36.126]                   {
[17:43:36.126]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:36.126]                     NULL
[17:43:36.126]                   }
[17:43:36.126]                   options(future.plan = NULL)
[17:43:36.126]                   if (is.na(NA_character_)) 
[17:43:36.126]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:36.126]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:36.126]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:43:36.126]                     envir = parent.frame()) 
[17:43:36.126]                   {
[17:43:36.126]                     default_workers <- missing(workers)
[17:43:36.126]                     if (is.function(workers)) 
[17:43:36.126]                       workers <- workers()
[17:43:36.126]                     workers <- structure(as.integer(workers), 
[17:43:36.126]                       class = class(workers))
[17:43:36.126]                     stop_if_not(is.finite(workers), workers >= 
[17:43:36.126]                       1L)
[17:43:36.126]                     if ((workers == 1L && !inherits(workers, 
[17:43:36.126]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:36.126]                       if (default_workers) 
[17:43:36.126]                         supportsMulticore(warn = TRUE)
[17:43:36.126]                       return(sequential(..., envir = envir))
[17:43:36.126]                     }
[17:43:36.126]                     oopts <- options(mc.cores = workers)
[17:43:36.126]                     on.exit(options(oopts))
[17:43:36.126]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:36.126]                       envir = envir)
[17:43:36.126]                     if (!future$lazy) 
[17:43:36.126]                       future <- run(future)
[17:43:36.126]                     invisible(future)
[17:43:36.126]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:36.126]                 }
[17:43:36.126]             }
[17:43:36.126]         }
[17:43:36.126]     })
[17:43:36.126]     if (TRUE) {
[17:43:36.126]         base::sink(type = "output", split = FALSE)
[17:43:36.126]         if (TRUE) {
[17:43:36.126]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:36.126]         }
[17:43:36.126]         else {
[17:43:36.126]             ...future.result["stdout"] <- base::list(NULL)
[17:43:36.126]         }
[17:43:36.126]         base::close(...future.stdout)
[17:43:36.126]         ...future.stdout <- NULL
[17:43:36.126]     }
[17:43:36.126]     ...future.result$conditions <- ...future.conditions
[17:43:36.126]     ...future.result$finished <- base::Sys.time()
[17:43:36.126]     ...future.result
[17:43:36.126] }
[17:43:36.129] requestCore(): workers = 2
[17:43:36.130] Poll #1 (0): usedCores() = 2, workers = 2
[17:43:36.144] MulticoreFuture started
[17:43:36.145] - Launch lazy future ... done
[17:43:36.145] run() for ‘MulticoreFuture’ ... done
[17:43:36.147] plan(): Setting new future strategy stack:
[17:43:36.154] List of future strategies:
[17:43:36.154] 1. sequential:
[17:43:36.154]    - args: function (..., envir = parent.frame())
[17:43:36.154]    - tweaked: FALSE
[17:43:36.154]    - call: NULL
[17:43:36.155] resolve() on environment ...
[17:43:36.156]  recursive: 0
[17:43:36.156] plan(): nbrOfWorkers() = 1
[17:43:36.158]  elements: [3] ‘a’, ‘b’, ‘c’
[17:43:36.159] Future #1
[17:43:36.159]  length: 2 (resolved future 1)
[17:43:36.160] plan(): Setting new future strategy stack:
[17:43:36.160] List of future strategies:
[17:43:36.160] 1. multicore:
[17:43:36.160]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:36.160]    - tweaked: FALSE
[17:43:36.160]    - call: plan(strategy)
[17:43:36.168] plan(): nbrOfWorkers() = 2
[17:43:36.169] Future #2
[17:43:36.169]  length: 1 (resolved future 2)
[17:43:36.169]  length: 0 (resolved future 3)
[17:43:36.169] resolve() on environment ... DONE
[17:43:36.172] getGlobalsAndPackages() ...
[17:43:36.172] Searching for globals...
[17:43:36.173] - globals found: [1] ‘{’
[17:43:36.174] Searching for globals ... DONE
[17:43:36.174] Resolving globals: FALSE
[17:43:36.174] 
[17:43:36.175] 
[17:43:36.175] getGlobalsAndPackages() ... DONE
[17:43:36.176] run() for ‘Future’ ...
[17:43:36.176] - state: ‘created’
[17:43:36.177] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:36.182] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:36.182] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:36.182]   - Field: ‘label’
[17:43:36.183]   - Field: ‘local’
[17:43:36.183]   - Field: ‘owner’
[17:43:36.183]   - Field: ‘envir’
[17:43:36.183]   - Field: ‘workers’
[17:43:36.183]   - Field: ‘packages’
[17:43:36.184]   - Field: ‘gc’
[17:43:36.184]   - Field: ‘job’
[17:43:36.184]   - Field: ‘conditions’
[17:43:36.184]   - Field: ‘expr’
[17:43:36.184]   - Field: ‘uuid’
[17:43:36.184]   - Field: ‘seed’
[17:43:36.185]   - Field: ‘version’
[17:43:36.185]   - Field: ‘result’
[17:43:36.185]   - Field: ‘asynchronous’
[17:43:36.185]   - Field: ‘calls’
[17:43:36.185]   - Field: ‘globals’
[17:43:36.185]   - Field: ‘stdout’
[17:43:36.186]   - Field: ‘earlySignal’
[17:43:36.186]   - Field: ‘lazy’
[17:43:36.186]   - Field: ‘state’
[17:43:36.186] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:36.186] - Launch lazy future ...
[17:43:36.187] Packages needed by the future expression (n = 0): <none>
[17:43:36.187] Packages needed by future strategies (n = 0): <none>
[17:43:36.188] {
[17:43:36.188]     {
[17:43:36.188]         {
[17:43:36.188]             ...future.startTime <- base::Sys.time()
[17:43:36.188]             {
[17:43:36.188]                 {
[17:43:36.188]                   {
[17:43:36.188]                     {
[17:43:36.188]                       base::local({
[17:43:36.188]                         has_future <- base::requireNamespace("future", 
[17:43:36.188]                           quietly = TRUE)
[17:43:36.188]                         if (has_future) {
[17:43:36.188]                           ns <- base::getNamespace("future")
[17:43:36.188]                           version <- ns[[".package"]][["version"]]
[17:43:36.188]                           if (is.null(version)) 
[17:43:36.188]                             version <- utils::packageVersion("future")
[17:43:36.188]                         }
[17:43:36.188]                         else {
[17:43:36.188]                           version <- NULL
[17:43:36.188]                         }
[17:43:36.188]                         if (!has_future || version < "1.8.0") {
[17:43:36.188]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:36.188]                             "", base::R.version$version.string), 
[17:43:36.188]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:36.188]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:36.188]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:36.188]                               "release", "version")], collapse = " "), 
[17:43:36.188]                             hostname = base::Sys.info()[["nodename"]])
[17:43:36.188]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:36.188]                             info)
[17:43:36.188]                           info <- base::paste(info, collapse = "; ")
[17:43:36.188]                           if (!has_future) {
[17:43:36.188]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:36.188]                               info)
[17:43:36.188]                           }
[17:43:36.188]                           else {
[17:43:36.188]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:36.188]                               info, version)
[17:43:36.188]                           }
[17:43:36.188]                           base::stop(msg)
[17:43:36.188]                         }
[17:43:36.188]                       })
[17:43:36.188]                     }
[17:43:36.188]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:36.188]                     base::options(mc.cores = 1L)
[17:43:36.188]                   }
[17:43:36.188]                   options(future.plan = NULL)
[17:43:36.188]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:36.188]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:36.188]                 }
[17:43:36.188]                 ...future.workdir <- getwd()
[17:43:36.188]             }
[17:43:36.188]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:36.188]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:36.188]         }
[17:43:36.188]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:36.188]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:36.188]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:36.188]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:36.188]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:36.188]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:36.188]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:36.188]             base::names(...future.oldOptions))
[17:43:36.188]     }
[17:43:36.188]     if (FALSE) {
[17:43:36.188]     }
[17:43:36.188]     else {
[17:43:36.188]         if (TRUE) {
[17:43:36.188]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:36.188]                 open = "w")
[17:43:36.188]         }
[17:43:36.188]         else {
[17:43:36.188]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:36.188]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:36.188]         }
[17:43:36.188]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:36.188]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:36.188]             base::sink(type = "output", split = FALSE)
[17:43:36.188]             base::close(...future.stdout)
[17:43:36.188]         }, add = TRUE)
[17:43:36.188]     }
[17:43:36.188]     ...future.frame <- base::sys.nframe()
[17:43:36.188]     ...future.conditions <- base::list()
[17:43:36.188]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:36.188]     if (FALSE) {
[17:43:36.188]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:36.188]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:36.188]     }
[17:43:36.188]     ...future.result <- base::tryCatch({
[17:43:36.188]         base::withCallingHandlers({
[17:43:36.188]             ...future.value <- base::withVisible(base::local({
[17:43:36.188]                 withCallingHandlers({
[17:43:36.188]                   {
[17:43:36.188]                     1
[17:43:36.188]                   }
[17:43:36.188]                 }, immediateCondition = function(cond) {
[17:43:36.188]                   save_rds <- function (object, pathname, ...) 
[17:43:36.188]                   {
[17:43:36.188]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:36.188]                     if (file_test("-f", pathname_tmp)) {
[17:43:36.188]                       fi_tmp <- file.info(pathname_tmp)
[17:43:36.188]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:36.188]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:36.188]                         fi_tmp[["mtime"]])
[17:43:36.188]                     }
[17:43:36.188]                     tryCatch({
[17:43:36.188]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:36.188]                     }, error = function(ex) {
[17:43:36.188]                       msg <- conditionMessage(ex)
[17:43:36.188]                       fi_tmp <- file.info(pathname_tmp)
[17:43:36.188]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:36.188]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:36.188]                         fi_tmp[["mtime"]], msg)
[17:43:36.188]                       ex$message <- msg
[17:43:36.188]                       stop(ex)
[17:43:36.188]                     })
[17:43:36.188]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:36.188]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:36.188]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:36.188]                       fi_tmp <- file.info(pathname_tmp)
[17:43:36.188]                       fi <- file.info(pathname)
[17:43:36.188]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:36.188]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:36.188]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:36.188]                         fi[["size"]], fi[["mtime"]])
[17:43:36.188]                       stop(msg)
[17:43:36.188]                     }
[17:43:36.188]                     invisible(pathname)
[17:43:36.188]                   }
[17:43:36.188]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:36.188]                     rootPath = tempdir()) 
[17:43:36.188]                   {
[17:43:36.188]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:36.188]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:36.188]                       tmpdir = path, fileext = ".rds")
[17:43:36.188]                     save_rds(obj, file)
[17:43:36.188]                   }
[17:43:36.188]                   saveImmediateCondition(cond, path = "/tmp/RtmpLaOb2h/.future/immediateConditions")
[17:43:36.188]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:36.188]                   {
[17:43:36.188]                     inherits <- base::inherits
[17:43:36.188]                     invokeRestart <- base::invokeRestart
[17:43:36.188]                     is.null <- base::is.null
[17:43:36.188]                     muffled <- FALSE
[17:43:36.188]                     if (inherits(cond, "message")) {
[17:43:36.188]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:36.188]                       if (muffled) 
[17:43:36.188]                         invokeRestart("muffleMessage")
[17:43:36.188]                     }
[17:43:36.188]                     else if (inherits(cond, "warning")) {
[17:43:36.188]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:36.188]                       if (muffled) 
[17:43:36.188]                         invokeRestart("muffleWarning")
[17:43:36.188]                     }
[17:43:36.188]                     else if (inherits(cond, "condition")) {
[17:43:36.188]                       if (!is.null(pattern)) {
[17:43:36.188]                         computeRestarts <- base::computeRestarts
[17:43:36.188]                         grepl <- base::grepl
[17:43:36.188]                         restarts <- computeRestarts(cond)
[17:43:36.188]                         for (restart in restarts) {
[17:43:36.188]                           name <- restart$name
[17:43:36.188]                           if (is.null(name)) 
[17:43:36.188]                             next
[17:43:36.188]                           if (!grepl(pattern, name)) 
[17:43:36.188]                             next
[17:43:36.188]                           invokeRestart(restart)
[17:43:36.188]                           muffled <- TRUE
[17:43:36.188]                           break
[17:43:36.188]                         }
[17:43:36.188]                       }
[17:43:36.188]                     }
[17:43:36.188]                     invisible(muffled)
[17:43:36.188]                   }
[17:43:36.188]                   muffleCondition(cond)
[17:43:36.188]                 })
[17:43:36.188]             }))
[17:43:36.188]             future::FutureResult(value = ...future.value$value, 
[17:43:36.188]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:36.188]                   ...future.rng), globalenv = if (FALSE) 
[17:43:36.188]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:36.188]                     ...future.globalenv.names))
[17:43:36.188]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:36.188]         }, condition = base::local({
[17:43:36.188]             c <- base::c
[17:43:36.188]             inherits <- base::inherits
[17:43:36.188]             invokeRestart <- base::invokeRestart
[17:43:36.188]             length <- base::length
[17:43:36.188]             list <- base::list
[17:43:36.188]             seq.int <- base::seq.int
[17:43:36.188]             signalCondition <- base::signalCondition
[17:43:36.188]             sys.calls <- base::sys.calls
[17:43:36.188]             `[[` <- base::`[[`
[17:43:36.188]             `+` <- base::`+`
[17:43:36.188]             `<<-` <- base::`<<-`
[17:43:36.188]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:36.188]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:36.188]                   3L)]
[17:43:36.188]             }
[17:43:36.188]             function(cond) {
[17:43:36.188]                 is_error <- inherits(cond, "error")
[17:43:36.188]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:36.188]                   NULL)
[17:43:36.188]                 if (is_error) {
[17:43:36.188]                   sessionInformation <- function() {
[17:43:36.188]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:36.188]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:36.188]                       search = base::search(), system = base::Sys.info())
[17:43:36.188]                   }
[17:43:36.188]                   ...future.conditions[[length(...future.conditions) + 
[17:43:36.188]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:36.188]                     cond$call), session = sessionInformation(), 
[17:43:36.188]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:36.188]                   signalCondition(cond)
[17:43:36.188]                 }
[17:43:36.188]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:36.188]                 "immediateCondition"))) {
[17:43:36.188]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:36.188]                   ...future.conditions[[length(...future.conditions) + 
[17:43:36.188]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:36.188]                   if (TRUE && !signal) {
[17:43:36.188]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:36.188]                     {
[17:43:36.188]                       inherits <- base::inherits
[17:43:36.188]                       invokeRestart <- base::invokeRestart
[17:43:36.188]                       is.null <- base::is.null
[17:43:36.188]                       muffled <- FALSE
[17:43:36.188]                       if (inherits(cond, "message")) {
[17:43:36.188]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:36.188]                         if (muffled) 
[17:43:36.188]                           invokeRestart("muffleMessage")
[17:43:36.188]                       }
[17:43:36.188]                       else if (inherits(cond, "warning")) {
[17:43:36.188]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:36.188]                         if (muffled) 
[17:43:36.188]                           invokeRestart("muffleWarning")
[17:43:36.188]                       }
[17:43:36.188]                       else if (inherits(cond, "condition")) {
[17:43:36.188]                         if (!is.null(pattern)) {
[17:43:36.188]                           computeRestarts <- base::computeRestarts
[17:43:36.188]                           grepl <- base::grepl
[17:43:36.188]                           restarts <- computeRestarts(cond)
[17:43:36.188]                           for (restart in restarts) {
[17:43:36.188]                             name <- restart$name
[17:43:36.188]                             if (is.null(name)) 
[17:43:36.188]                               next
[17:43:36.188]                             if (!grepl(pattern, name)) 
[17:43:36.188]                               next
[17:43:36.188]                             invokeRestart(restart)
[17:43:36.188]                             muffled <- TRUE
[17:43:36.188]                             break
[17:43:36.188]                           }
[17:43:36.188]                         }
[17:43:36.188]                       }
[17:43:36.188]                       invisible(muffled)
[17:43:36.188]                     }
[17:43:36.188]                     muffleCondition(cond, pattern = "^muffle")
[17:43:36.188]                   }
[17:43:36.188]                 }
[17:43:36.188]                 else {
[17:43:36.188]                   if (TRUE) {
[17:43:36.188]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:36.188]                     {
[17:43:36.188]                       inherits <- base::inherits
[17:43:36.188]                       invokeRestart <- base::invokeRestart
[17:43:36.188]                       is.null <- base::is.null
[17:43:36.188]                       muffled <- FALSE
[17:43:36.188]                       if (inherits(cond, "message")) {
[17:43:36.188]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:36.188]                         if (muffled) 
[17:43:36.188]                           invokeRestart("muffleMessage")
[17:43:36.188]                       }
[17:43:36.188]                       else if (inherits(cond, "warning")) {
[17:43:36.188]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:36.188]                         if (muffled) 
[17:43:36.188]                           invokeRestart("muffleWarning")
[17:43:36.188]                       }
[17:43:36.188]                       else if (inherits(cond, "condition")) {
[17:43:36.188]                         if (!is.null(pattern)) {
[17:43:36.188]                           computeRestarts <- base::computeRestarts
[17:43:36.188]                           grepl <- base::grepl
[17:43:36.188]                           restarts <- computeRestarts(cond)
[17:43:36.188]                           for (restart in restarts) {
[17:43:36.188]                             name <- restart$name
[17:43:36.188]                             if (is.null(name)) 
[17:43:36.188]                               next
[17:43:36.188]                             if (!grepl(pattern, name)) 
[17:43:36.188]                               next
[17:43:36.188]                             invokeRestart(restart)
[17:43:36.188]                             muffled <- TRUE
[17:43:36.188]                             break
[17:43:36.188]                           }
[17:43:36.188]                         }
[17:43:36.188]                       }
[17:43:36.188]                       invisible(muffled)
[17:43:36.188]                     }
[17:43:36.188]                     muffleCondition(cond, pattern = "^muffle")
[17:43:36.188]                   }
[17:43:36.188]                 }
[17:43:36.188]             }
[17:43:36.188]         }))
[17:43:36.188]     }, error = function(ex) {
[17:43:36.188]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:36.188]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:36.188]                 ...future.rng), started = ...future.startTime, 
[17:43:36.188]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:36.188]             version = "1.8"), class = "FutureResult")
[17:43:36.188]     }, finally = {
[17:43:36.188]         if (!identical(...future.workdir, getwd())) 
[17:43:36.188]             setwd(...future.workdir)
[17:43:36.188]         {
[17:43:36.188]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:36.188]                 ...future.oldOptions$nwarnings <- NULL
[17:43:36.188]             }
[17:43:36.188]             base::options(...future.oldOptions)
[17:43:36.188]             if (.Platform$OS.type == "windows") {
[17:43:36.188]                 old_names <- names(...future.oldEnvVars)
[17:43:36.188]                 envs <- base::Sys.getenv()
[17:43:36.188]                 names <- names(envs)
[17:43:36.188]                 common <- intersect(names, old_names)
[17:43:36.188]                 added <- setdiff(names, old_names)
[17:43:36.188]                 removed <- setdiff(old_names, names)
[17:43:36.188]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:36.188]                   envs[common]]
[17:43:36.188]                 NAMES <- toupper(changed)
[17:43:36.188]                 args <- list()
[17:43:36.188]                 for (kk in seq_along(NAMES)) {
[17:43:36.188]                   name <- changed[[kk]]
[17:43:36.188]                   NAME <- NAMES[[kk]]
[17:43:36.188]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:36.188]                     next
[17:43:36.188]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:36.188]                 }
[17:43:36.188]                 NAMES <- toupper(added)
[17:43:36.188]                 for (kk in seq_along(NAMES)) {
[17:43:36.188]                   name <- added[[kk]]
[17:43:36.188]                   NAME <- NAMES[[kk]]
[17:43:36.188]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:36.188]                     next
[17:43:36.188]                   args[[name]] <- ""
[17:43:36.188]                 }
[17:43:36.188]                 NAMES <- toupper(removed)
[17:43:36.188]                 for (kk in seq_along(NAMES)) {
[17:43:36.188]                   name <- removed[[kk]]
[17:43:36.188]                   NAME <- NAMES[[kk]]
[17:43:36.188]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:36.188]                     next
[17:43:36.188]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:36.188]                 }
[17:43:36.188]                 if (length(args) > 0) 
[17:43:36.188]                   base::do.call(base::Sys.setenv, args = args)
[17:43:36.188]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:36.188]             }
[17:43:36.188]             else {
[17:43:36.188]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:36.188]             }
[17:43:36.188]             {
[17:43:36.188]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:36.188]                   0L) {
[17:43:36.188]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:36.188]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:36.188]                   base::options(opts)
[17:43:36.188]                 }
[17:43:36.188]                 {
[17:43:36.188]                   {
[17:43:36.188]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:36.188]                     NULL
[17:43:36.188]                   }
[17:43:36.188]                   options(future.plan = NULL)
[17:43:36.188]                   if (is.na(NA_character_)) 
[17:43:36.188]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:36.188]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:36.188]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:43:36.188]                     envir = parent.frame()) 
[17:43:36.188]                   {
[17:43:36.188]                     default_workers <- missing(workers)
[17:43:36.188]                     if (is.function(workers)) 
[17:43:36.188]                       workers <- workers()
[17:43:36.188]                     workers <- structure(as.integer(workers), 
[17:43:36.188]                       class = class(workers))
[17:43:36.188]                     stop_if_not(is.finite(workers), workers >= 
[17:43:36.188]                       1L)
[17:43:36.188]                     if ((workers == 1L && !inherits(workers, 
[17:43:36.188]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:36.188]                       if (default_workers) 
[17:43:36.188]                         supportsMulticore(warn = TRUE)
[17:43:36.188]                       return(sequential(..., envir = envir))
[17:43:36.188]                     }
[17:43:36.188]                     oopts <- options(mc.cores = workers)
[17:43:36.188]                     on.exit(options(oopts))
[17:43:36.188]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:36.188]                       envir = envir)
[17:43:36.188]                     if (!future$lazy) 
[17:43:36.188]                       future <- run(future)
[17:43:36.188]                     invisible(future)
[17:43:36.188]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:36.188]                 }
[17:43:36.188]             }
[17:43:36.188]         }
[17:43:36.188]     })
[17:43:36.188]     if (TRUE) {
[17:43:36.188]         base::sink(type = "output", split = FALSE)
[17:43:36.188]         if (TRUE) {
[17:43:36.188]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:36.188]         }
[17:43:36.188]         else {
[17:43:36.188]             ...future.result["stdout"] <- base::list(NULL)
[17:43:36.188]         }
[17:43:36.188]         base::close(...future.stdout)
[17:43:36.188]         ...future.stdout <- NULL
[17:43:36.188]     }
[17:43:36.188]     ...future.result$conditions <- ...future.conditions
[17:43:36.188]     ...future.result$finished <- base::Sys.time()
[17:43:36.188]     ...future.result
[17:43:36.188] }
[17:43:36.191] requestCore(): workers = 2
[17:43:36.191] Poll #1 (0): usedCores() = 2, workers = 2
[17:43:36.205] MulticoreFuture started
[17:43:36.206] - Launch lazy future ... done
[17:43:36.206] run() for ‘MulticoreFuture’ ... done
[17:43:36.208] plan(): Setting new future strategy stack:
[17:43:36.208] getGlobalsAndPackages() ...
[17:43:36.208] Searching for globals...
[17:43:36.208] List of future strategies:
[17:43:36.208] 1. sequential:
[17:43:36.208]    - args: function (..., envir = parent.frame())
[17:43:36.208]    - tweaked: FALSE
[17:43:36.208]    - call: NULL
[17:43:36.209] plan(): nbrOfWorkers() = 1
[17:43:36.211] - globals found: [1] ‘{’
[17:43:36.212] Searching for globals ... DONE
[17:43:36.212] Resolving globals: FALSE
[17:43:36.212] plan(): Setting new future strategy stack:
[17:43:36.213] 
[17:43:36.213] List of future strategies:
[17:43:36.213] 1. multicore:
[17:43:36.213]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:36.213]    - tweaked: FALSE
[17:43:36.213]    - call: plan(strategy)
[17:43:36.213] 
[17:43:36.214] getGlobalsAndPackages() ... DONE
[17:43:36.214] run() for ‘Future’ ...
[17:43:36.215] - state: ‘created’
[17:43:36.215] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:36.220] plan(): nbrOfWorkers() = 2
[17:43:36.222] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:36.222] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:36.223]   - Field: ‘label’
[17:43:36.223]   - Field: ‘local’
[17:43:36.223]   - Field: ‘owner’
[17:43:36.223]   - Field: ‘envir’
[17:43:36.223]   - Field: ‘workers’
[17:43:36.223]   - Field: ‘packages’
[17:43:36.224]   - Field: ‘gc’
[17:43:36.224]   - Field: ‘job’
[17:43:36.224]   - Field: ‘conditions’
[17:43:36.224]   - Field: ‘expr’
[17:43:36.224]   - Field: ‘uuid’
[17:43:36.224]   - Field: ‘seed’
[17:43:36.225]   - Field: ‘version’
[17:43:36.225]   - Field: ‘result’
[17:43:36.225]   - Field: ‘asynchronous’
[17:43:36.225]   - Field: ‘calls’
[17:43:36.225]   - Field: ‘globals’
[17:43:36.225]   - Field: ‘stdout’
[17:43:36.225]   - Field: ‘earlySignal’
[17:43:36.226]   - Field: ‘lazy’
[17:43:36.226]   - Field: ‘state’
[17:43:36.226] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:36.226] - Launch lazy future ...
[17:43:36.226] Packages needed by the future expression (n = 0): <none>
[17:43:36.227] Packages needed by future strategies (n = 0): <none>
[17:43:36.227] {
[17:43:36.227]     {
[17:43:36.227]         {
[17:43:36.227]             ...future.startTime <- base::Sys.time()
[17:43:36.227]             {
[17:43:36.227]                 {
[17:43:36.227]                   {
[17:43:36.227]                     {
[17:43:36.227]                       base::local({
[17:43:36.227]                         has_future <- base::requireNamespace("future", 
[17:43:36.227]                           quietly = TRUE)
[17:43:36.227]                         if (has_future) {
[17:43:36.227]                           ns <- base::getNamespace("future")
[17:43:36.227]                           version <- ns[[".package"]][["version"]]
[17:43:36.227]                           if (is.null(version)) 
[17:43:36.227]                             version <- utils::packageVersion("future")
[17:43:36.227]                         }
[17:43:36.227]                         else {
[17:43:36.227]                           version <- NULL
[17:43:36.227]                         }
[17:43:36.227]                         if (!has_future || version < "1.8.0") {
[17:43:36.227]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:36.227]                             "", base::R.version$version.string), 
[17:43:36.227]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:36.227]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:36.227]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:36.227]                               "release", "version")], collapse = " "), 
[17:43:36.227]                             hostname = base::Sys.info()[["nodename"]])
[17:43:36.227]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:36.227]                             info)
[17:43:36.227]                           info <- base::paste(info, collapse = "; ")
[17:43:36.227]                           if (!has_future) {
[17:43:36.227]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:36.227]                               info)
[17:43:36.227]                           }
[17:43:36.227]                           else {
[17:43:36.227]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:36.227]                               info, version)
[17:43:36.227]                           }
[17:43:36.227]                           base::stop(msg)
[17:43:36.227]                         }
[17:43:36.227]                       })
[17:43:36.227]                     }
[17:43:36.227]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:36.227]                     base::options(mc.cores = 1L)
[17:43:36.227]                   }
[17:43:36.227]                   options(future.plan = NULL)
[17:43:36.227]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:36.227]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:36.227]                 }
[17:43:36.227]                 ...future.workdir <- getwd()
[17:43:36.227]             }
[17:43:36.227]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:36.227]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:36.227]         }
[17:43:36.227]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:36.227]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:36.227]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:36.227]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:36.227]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:36.227]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:36.227]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:36.227]             base::names(...future.oldOptions))
[17:43:36.227]     }
[17:43:36.227]     if (FALSE) {
[17:43:36.227]     }
[17:43:36.227]     else {
[17:43:36.227]         if (TRUE) {
[17:43:36.227]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:36.227]                 open = "w")
[17:43:36.227]         }
[17:43:36.227]         else {
[17:43:36.227]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:36.227]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:36.227]         }
[17:43:36.227]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:36.227]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:36.227]             base::sink(type = "output", split = FALSE)
[17:43:36.227]             base::close(...future.stdout)
[17:43:36.227]         }, add = TRUE)
[17:43:36.227]     }
[17:43:36.227]     ...future.frame <- base::sys.nframe()
[17:43:36.227]     ...future.conditions <- base::list()
[17:43:36.227]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:36.227]     if (FALSE) {
[17:43:36.227]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:36.227]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:36.227]     }
[17:43:36.227]     ...future.result <- base::tryCatch({
[17:43:36.227]         base::withCallingHandlers({
[17:43:36.227]             ...future.value <- base::withVisible(base::local({
[17:43:36.227]                 withCallingHandlers({
[17:43:36.227]                   {
[17:43:36.227]                     2
[17:43:36.227]                   }
[17:43:36.227]                 }, immediateCondition = function(cond) {
[17:43:36.227]                   save_rds <- function (object, pathname, ...) 
[17:43:36.227]                   {
[17:43:36.227]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:36.227]                     if (file_test("-f", pathname_tmp)) {
[17:43:36.227]                       fi_tmp <- file.info(pathname_tmp)
[17:43:36.227]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:36.227]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:36.227]                         fi_tmp[["mtime"]])
[17:43:36.227]                     }
[17:43:36.227]                     tryCatch({
[17:43:36.227]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:36.227]                     }, error = function(ex) {
[17:43:36.227]                       msg <- conditionMessage(ex)
[17:43:36.227]                       fi_tmp <- file.info(pathname_tmp)
[17:43:36.227]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:36.227]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:36.227]                         fi_tmp[["mtime"]], msg)
[17:43:36.227]                       ex$message <- msg
[17:43:36.227]                       stop(ex)
[17:43:36.227]                     })
[17:43:36.227]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:36.227]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:36.227]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:36.227]                       fi_tmp <- file.info(pathname_tmp)
[17:43:36.227]                       fi <- file.info(pathname)
[17:43:36.227]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:36.227]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:36.227]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:36.227]                         fi[["size"]], fi[["mtime"]])
[17:43:36.227]                       stop(msg)
[17:43:36.227]                     }
[17:43:36.227]                     invisible(pathname)
[17:43:36.227]                   }
[17:43:36.227]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:36.227]                     rootPath = tempdir()) 
[17:43:36.227]                   {
[17:43:36.227]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:36.227]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:36.227]                       tmpdir = path, fileext = ".rds")
[17:43:36.227]                     save_rds(obj, file)
[17:43:36.227]                   }
[17:43:36.227]                   saveImmediateCondition(cond, path = "/tmp/RtmpLaOb2h/.future/immediateConditions")
[17:43:36.227]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:36.227]                   {
[17:43:36.227]                     inherits <- base::inherits
[17:43:36.227]                     invokeRestart <- base::invokeRestart
[17:43:36.227]                     is.null <- base::is.null
[17:43:36.227]                     muffled <- FALSE
[17:43:36.227]                     if (inherits(cond, "message")) {
[17:43:36.227]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:36.227]                       if (muffled) 
[17:43:36.227]                         invokeRestart("muffleMessage")
[17:43:36.227]                     }
[17:43:36.227]                     else if (inherits(cond, "warning")) {
[17:43:36.227]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:36.227]                       if (muffled) 
[17:43:36.227]                         invokeRestart("muffleWarning")
[17:43:36.227]                     }
[17:43:36.227]                     else if (inherits(cond, "condition")) {
[17:43:36.227]                       if (!is.null(pattern)) {
[17:43:36.227]                         computeRestarts <- base::computeRestarts
[17:43:36.227]                         grepl <- base::grepl
[17:43:36.227]                         restarts <- computeRestarts(cond)
[17:43:36.227]                         for (restart in restarts) {
[17:43:36.227]                           name <- restart$name
[17:43:36.227]                           if (is.null(name)) 
[17:43:36.227]                             next
[17:43:36.227]                           if (!grepl(pattern, name)) 
[17:43:36.227]                             next
[17:43:36.227]                           invokeRestart(restart)
[17:43:36.227]                           muffled <- TRUE
[17:43:36.227]                           break
[17:43:36.227]                         }
[17:43:36.227]                       }
[17:43:36.227]                     }
[17:43:36.227]                     invisible(muffled)
[17:43:36.227]                   }
[17:43:36.227]                   muffleCondition(cond)
[17:43:36.227]                 })
[17:43:36.227]             }))
[17:43:36.227]             future::FutureResult(value = ...future.value$value, 
[17:43:36.227]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:36.227]                   ...future.rng), globalenv = if (FALSE) 
[17:43:36.227]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:36.227]                     ...future.globalenv.names))
[17:43:36.227]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:36.227]         }, condition = base::local({
[17:43:36.227]             c <- base::c
[17:43:36.227]             inherits <- base::inherits
[17:43:36.227]             invokeRestart <- base::invokeRestart
[17:43:36.227]             length <- base::length
[17:43:36.227]             list <- base::list
[17:43:36.227]             seq.int <- base::seq.int
[17:43:36.227]             signalCondition <- base::signalCondition
[17:43:36.227]             sys.calls <- base::sys.calls
[17:43:36.227]             `[[` <- base::`[[`
[17:43:36.227]             `+` <- base::`+`
[17:43:36.227]             `<<-` <- base::`<<-`
[17:43:36.227]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:36.227]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:36.227]                   3L)]
[17:43:36.227]             }
[17:43:36.227]             function(cond) {
[17:43:36.227]                 is_error <- inherits(cond, "error")
[17:43:36.227]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:36.227]                   NULL)
[17:43:36.227]                 if (is_error) {
[17:43:36.227]                   sessionInformation <- function() {
[17:43:36.227]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:36.227]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:36.227]                       search = base::search(), system = base::Sys.info())
[17:43:36.227]                   }
[17:43:36.227]                   ...future.conditions[[length(...future.conditions) + 
[17:43:36.227]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:36.227]                     cond$call), session = sessionInformation(), 
[17:43:36.227]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:36.227]                   signalCondition(cond)
[17:43:36.227]                 }
[17:43:36.227]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:36.227]                 "immediateCondition"))) {
[17:43:36.227]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:36.227]                   ...future.conditions[[length(...future.conditions) + 
[17:43:36.227]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:36.227]                   if (TRUE && !signal) {
[17:43:36.227]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:36.227]                     {
[17:43:36.227]                       inherits <- base::inherits
[17:43:36.227]                       invokeRestart <- base::invokeRestart
[17:43:36.227]                       is.null <- base::is.null
[17:43:36.227]                       muffled <- FALSE
[17:43:36.227]                       if (inherits(cond, "message")) {
[17:43:36.227]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:36.227]                         if (muffled) 
[17:43:36.227]                           invokeRestart("muffleMessage")
[17:43:36.227]                       }
[17:43:36.227]                       else if (inherits(cond, "warning")) {
[17:43:36.227]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:36.227]                         if (muffled) 
[17:43:36.227]                           invokeRestart("muffleWarning")
[17:43:36.227]                       }
[17:43:36.227]                       else if (inherits(cond, "condition")) {
[17:43:36.227]                         if (!is.null(pattern)) {
[17:43:36.227]                           computeRestarts <- base::computeRestarts
[17:43:36.227]                           grepl <- base::grepl
[17:43:36.227]                           restarts <- computeRestarts(cond)
[17:43:36.227]                           for (restart in restarts) {
[17:43:36.227]                             name <- restart$name
[17:43:36.227]                             if (is.null(name)) 
[17:43:36.227]                               next
[17:43:36.227]                             if (!grepl(pattern, name)) 
[17:43:36.227]                               next
[17:43:36.227]                             invokeRestart(restart)
[17:43:36.227]                             muffled <- TRUE
[17:43:36.227]                             break
[17:43:36.227]                           }
[17:43:36.227]                         }
[17:43:36.227]                       }
[17:43:36.227]                       invisible(muffled)
[17:43:36.227]                     }
[17:43:36.227]                     muffleCondition(cond, pattern = "^muffle")
[17:43:36.227]                   }
[17:43:36.227]                 }
[17:43:36.227]                 else {
[17:43:36.227]                   if (TRUE) {
[17:43:36.227]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:36.227]                     {
[17:43:36.227]                       inherits <- base::inherits
[17:43:36.227]                       invokeRestart <- base::invokeRestart
[17:43:36.227]                       is.null <- base::is.null
[17:43:36.227]                       muffled <- FALSE
[17:43:36.227]                       if (inherits(cond, "message")) {
[17:43:36.227]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:36.227]                         if (muffled) 
[17:43:36.227]                           invokeRestart("muffleMessage")
[17:43:36.227]                       }
[17:43:36.227]                       else if (inherits(cond, "warning")) {
[17:43:36.227]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:36.227]                         if (muffled) 
[17:43:36.227]                           invokeRestart("muffleWarning")
[17:43:36.227]                       }
[17:43:36.227]                       else if (inherits(cond, "condition")) {
[17:43:36.227]                         if (!is.null(pattern)) {
[17:43:36.227]                           computeRestarts <- base::computeRestarts
[17:43:36.227]                           grepl <- base::grepl
[17:43:36.227]                           restarts <- computeRestarts(cond)
[17:43:36.227]                           for (restart in restarts) {
[17:43:36.227]                             name <- restart$name
[17:43:36.227]                             if (is.null(name)) 
[17:43:36.227]                               next
[17:43:36.227]                             if (!grepl(pattern, name)) 
[17:43:36.227]                               next
[17:43:36.227]                             invokeRestart(restart)
[17:43:36.227]                             muffled <- TRUE
[17:43:36.227]                             break
[17:43:36.227]                           }
[17:43:36.227]                         }
[17:43:36.227]                       }
[17:43:36.227]                       invisible(muffled)
[17:43:36.227]                     }
[17:43:36.227]                     muffleCondition(cond, pattern = "^muffle")
[17:43:36.227]                   }
[17:43:36.227]                 }
[17:43:36.227]             }
[17:43:36.227]         }))
[17:43:36.227]     }, error = function(ex) {
[17:43:36.227]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:36.227]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:36.227]                 ...future.rng), started = ...future.startTime, 
[17:43:36.227]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:36.227]             version = "1.8"), class = "FutureResult")
[17:43:36.227]     }, finally = {
[17:43:36.227]         if (!identical(...future.workdir, getwd())) 
[17:43:36.227]             setwd(...future.workdir)
[17:43:36.227]         {
[17:43:36.227]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:36.227]                 ...future.oldOptions$nwarnings <- NULL
[17:43:36.227]             }
[17:43:36.227]             base::options(...future.oldOptions)
[17:43:36.227]             if (.Platform$OS.type == "windows") {
[17:43:36.227]                 old_names <- names(...future.oldEnvVars)
[17:43:36.227]                 envs <- base::Sys.getenv()
[17:43:36.227]                 names <- names(envs)
[17:43:36.227]                 common <- intersect(names, old_names)
[17:43:36.227]                 added <- setdiff(names, old_names)
[17:43:36.227]                 removed <- setdiff(old_names, names)
[17:43:36.227]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:36.227]                   envs[common]]
[17:43:36.227]                 NAMES <- toupper(changed)
[17:43:36.227]                 args <- list()
[17:43:36.227]                 for (kk in seq_along(NAMES)) {
[17:43:36.227]                   name <- changed[[kk]]
[17:43:36.227]                   NAME <- NAMES[[kk]]
[17:43:36.227]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:36.227]                     next
[17:43:36.227]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:36.227]                 }
[17:43:36.227]                 NAMES <- toupper(added)
[17:43:36.227]                 for (kk in seq_along(NAMES)) {
[17:43:36.227]                   name <- added[[kk]]
[17:43:36.227]                   NAME <- NAMES[[kk]]
[17:43:36.227]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:36.227]                     next
[17:43:36.227]                   args[[name]] <- ""
[17:43:36.227]                 }
[17:43:36.227]                 NAMES <- toupper(removed)
[17:43:36.227]                 for (kk in seq_along(NAMES)) {
[17:43:36.227]                   name <- removed[[kk]]
[17:43:36.227]                   NAME <- NAMES[[kk]]
[17:43:36.227]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:36.227]                     next
[17:43:36.227]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:36.227]                 }
[17:43:36.227]                 if (length(args) > 0) 
[17:43:36.227]                   base::do.call(base::Sys.setenv, args = args)
[17:43:36.227]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:36.227]             }
[17:43:36.227]             else {
[17:43:36.227]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:36.227]             }
[17:43:36.227]             {
[17:43:36.227]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:36.227]                   0L) {
[17:43:36.227]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:36.227]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:36.227]                   base::options(opts)
[17:43:36.227]                 }
[17:43:36.227]                 {
[17:43:36.227]                   {
[17:43:36.227]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:36.227]                     NULL
[17:43:36.227]                   }
[17:43:36.227]                   options(future.plan = NULL)
[17:43:36.227]                   if (is.na(NA_character_)) 
[17:43:36.227]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:36.227]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:36.227]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:43:36.227]                     envir = parent.frame()) 
[17:43:36.227]                   {
[17:43:36.227]                     default_workers <- missing(workers)
[17:43:36.227]                     if (is.function(workers)) 
[17:43:36.227]                       workers <- workers()
[17:43:36.227]                     workers <- structure(as.integer(workers), 
[17:43:36.227]                       class = class(workers))
[17:43:36.227]                     stop_if_not(is.finite(workers), workers >= 
[17:43:36.227]                       1L)
[17:43:36.227]                     if ((workers == 1L && !inherits(workers, 
[17:43:36.227]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:36.227]                       if (default_workers) 
[17:43:36.227]                         supportsMulticore(warn = TRUE)
[17:43:36.227]                       return(sequential(..., envir = envir))
[17:43:36.227]                     }
[17:43:36.227]                     oopts <- options(mc.cores = workers)
[17:43:36.227]                     on.exit(options(oopts))
[17:43:36.227]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:36.227]                       envir = envir)
[17:43:36.227]                     if (!future$lazy) 
[17:43:36.227]                       future <- run(future)
[17:43:36.227]                     invisible(future)
[17:43:36.227]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:36.227]                 }
[17:43:36.227]             }
[17:43:36.227]         }
[17:43:36.227]     })
[17:43:36.227]     if (TRUE) {
[17:43:36.227]         base::sink(type = "output", split = FALSE)
[17:43:36.227]         if (TRUE) {
[17:43:36.227]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:36.227]         }
[17:43:36.227]         else {
[17:43:36.227]             ...future.result["stdout"] <- base::list(NULL)
[17:43:36.227]         }
[17:43:36.227]         base::close(...future.stdout)
[17:43:36.227]         ...future.stdout <- NULL
[17:43:36.227]     }
[17:43:36.227]     ...future.result$conditions <- ...future.conditions
[17:43:36.227]     ...future.result$finished <- base::Sys.time()
[17:43:36.227]     ...future.result
[17:43:36.227] }
[17:43:36.231] requestCore(): workers = 2
[17:43:36.232] Poll #1 (0): usedCores() = 2, workers = 2
[17:43:36.246] MulticoreFuture started
[17:43:36.246] - Launch lazy future ... done
[17:43:36.247] run() for ‘MulticoreFuture’ ... done
[17:43:36.247] plan(): Setting new future strategy stack:
[17:43:36.248] List of future strategies:
[17:43:36.248] 1. sequential:
[17:43:36.248]    - args: function (..., envir = parent.frame())
[17:43:36.248]    - tweaked: FALSE
[17:43:36.248]    - call: NULL
[17:43:36.249] plan(): nbrOfWorkers() = 1
[17:43:36.249] resolve() on environment ...
[17:43:36.249]  recursive: 0
[17:43:36.251]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[17:43:36.251] Future #1
[17:43:36.252]  length: 2 (resolved future 1)
[17:43:36.252] plan(): Setting new future strategy stack:
[17:43:36.252] List of future strategies:
[17:43:36.252] 1. multicore:
[17:43:36.252]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:36.252]    - tweaked: FALSE
[17:43:36.252]    - call: plan(strategy)
[17:43:36.257] plan(): nbrOfWorkers() = 2
[17:43:36.258] Future #2
[17:43:36.258]  length: 1 (resolved future 2)
[17:43:36.258]  length: 0 (resolved future 3)
[17:43:36.259] resolve() on environment ... DONE
[17:43:36.259] getGlobalsAndPackages() ...
[17:43:36.260] Searching for globals...
[17:43:36.261] - globals found: [1] ‘{’
[17:43:36.261] Searching for globals ... DONE
[17:43:36.261] Resolving globals: FALSE
[17:43:36.262] 
[17:43:36.262] 
[17:43:36.262] getGlobalsAndPackages() ... DONE
[17:43:36.267] run() for ‘Future’ ...
[17:43:36.268] - state: ‘created’
[17:43:36.268] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:36.275] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:36.275] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:36.275]   - Field: ‘label’
[17:43:36.276]   - Field: ‘local’
[17:43:36.276]   - Field: ‘owner’
[17:43:36.276]   - Field: ‘envir’
[17:43:36.276]   - Field: ‘workers’
[17:43:36.276]   - Field: ‘packages’
[17:43:36.276]   - Field: ‘gc’
[17:43:36.277]   - Field: ‘job’
[17:43:36.277]   - Field: ‘conditions’
[17:43:36.277]   - Field: ‘expr’
[17:43:36.277]   - Field: ‘uuid’
[17:43:36.277]   - Field: ‘seed’
[17:43:36.278]   - Field: ‘version’
[17:43:36.278]   - Field: ‘result’
[17:43:36.278]   - Field: ‘asynchronous’
[17:43:36.278]   - Field: ‘calls’
[17:43:36.278]   - Field: ‘globals’
[17:43:36.278]   - Field: ‘stdout’
[17:43:36.278]   - Field: ‘earlySignal’
[17:43:36.279]   - Field: ‘lazy’
[17:43:36.279]   - Field: ‘state’
[17:43:36.279] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:36.279] - Launch lazy future ...
[17:43:36.280] Packages needed by the future expression (n = 0): <none>
[17:43:36.280] Packages needed by future strategies (n = 0): <none>
[17:43:36.281] {
[17:43:36.281]     {
[17:43:36.281]         {
[17:43:36.281]             ...future.startTime <- base::Sys.time()
[17:43:36.281]             {
[17:43:36.281]                 {
[17:43:36.281]                   {
[17:43:36.281]                     {
[17:43:36.281]                       base::local({
[17:43:36.281]                         has_future <- base::requireNamespace("future", 
[17:43:36.281]                           quietly = TRUE)
[17:43:36.281]                         if (has_future) {
[17:43:36.281]                           ns <- base::getNamespace("future")
[17:43:36.281]                           version <- ns[[".package"]][["version"]]
[17:43:36.281]                           if (is.null(version)) 
[17:43:36.281]                             version <- utils::packageVersion("future")
[17:43:36.281]                         }
[17:43:36.281]                         else {
[17:43:36.281]                           version <- NULL
[17:43:36.281]                         }
[17:43:36.281]                         if (!has_future || version < "1.8.0") {
[17:43:36.281]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:36.281]                             "", base::R.version$version.string), 
[17:43:36.281]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:36.281]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:36.281]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:36.281]                               "release", "version")], collapse = " "), 
[17:43:36.281]                             hostname = base::Sys.info()[["nodename"]])
[17:43:36.281]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:36.281]                             info)
[17:43:36.281]                           info <- base::paste(info, collapse = "; ")
[17:43:36.281]                           if (!has_future) {
[17:43:36.281]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:36.281]                               info)
[17:43:36.281]                           }
[17:43:36.281]                           else {
[17:43:36.281]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:36.281]                               info, version)
[17:43:36.281]                           }
[17:43:36.281]                           base::stop(msg)
[17:43:36.281]                         }
[17:43:36.281]                       })
[17:43:36.281]                     }
[17:43:36.281]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:36.281]                     base::options(mc.cores = 1L)
[17:43:36.281]                   }
[17:43:36.281]                   options(future.plan = NULL)
[17:43:36.281]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:36.281]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:36.281]                 }
[17:43:36.281]                 ...future.workdir <- getwd()
[17:43:36.281]             }
[17:43:36.281]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:36.281]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:36.281]         }
[17:43:36.281]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:36.281]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:36.281]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:36.281]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:36.281]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:36.281]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:36.281]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:36.281]             base::names(...future.oldOptions))
[17:43:36.281]     }
[17:43:36.281]     if (FALSE) {
[17:43:36.281]     }
[17:43:36.281]     else {
[17:43:36.281]         if (TRUE) {
[17:43:36.281]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:36.281]                 open = "w")
[17:43:36.281]         }
[17:43:36.281]         else {
[17:43:36.281]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:36.281]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:36.281]         }
[17:43:36.281]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:36.281]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:36.281]             base::sink(type = "output", split = FALSE)
[17:43:36.281]             base::close(...future.stdout)
[17:43:36.281]         }, add = TRUE)
[17:43:36.281]     }
[17:43:36.281]     ...future.frame <- base::sys.nframe()
[17:43:36.281]     ...future.conditions <- base::list()
[17:43:36.281]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:36.281]     if (FALSE) {
[17:43:36.281]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:36.281]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:36.281]     }
[17:43:36.281]     ...future.result <- base::tryCatch({
[17:43:36.281]         base::withCallingHandlers({
[17:43:36.281]             ...future.value <- base::withVisible(base::local({
[17:43:36.281]                 withCallingHandlers({
[17:43:36.281]                   {
[17:43:36.281]                     1
[17:43:36.281]                   }
[17:43:36.281]                 }, immediateCondition = function(cond) {
[17:43:36.281]                   save_rds <- function (object, pathname, ...) 
[17:43:36.281]                   {
[17:43:36.281]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:36.281]                     if (file_test("-f", pathname_tmp)) {
[17:43:36.281]                       fi_tmp <- file.info(pathname_tmp)
[17:43:36.281]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:36.281]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:36.281]                         fi_tmp[["mtime"]])
[17:43:36.281]                     }
[17:43:36.281]                     tryCatch({
[17:43:36.281]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:36.281]                     }, error = function(ex) {
[17:43:36.281]                       msg <- conditionMessage(ex)
[17:43:36.281]                       fi_tmp <- file.info(pathname_tmp)
[17:43:36.281]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:36.281]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:36.281]                         fi_tmp[["mtime"]], msg)
[17:43:36.281]                       ex$message <- msg
[17:43:36.281]                       stop(ex)
[17:43:36.281]                     })
[17:43:36.281]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:36.281]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:36.281]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:36.281]                       fi_tmp <- file.info(pathname_tmp)
[17:43:36.281]                       fi <- file.info(pathname)
[17:43:36.281]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:36.281]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:36.281]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:36.281]                         fi[["size"]], fi[["mtime"]])
[17:43:36.281]                       stop(msg)
[17:43:36.281]                     }
[17:43:36.281]                     invisible(pathname)
[17:43:36.281]                   }
[17:43:36.281]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:36.281]                     rootPath = tempdir()) 
[17:43:36.281]                   {
[17:43:36.281]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:36.281]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:36.281]                       tmpdir = path, fileext = ".rds")
[17:43:36.281]                     save_rds(obj, file)
[17:43:36.281]                   }
[17:43:36.281]                   saveImmediateCondition(cond, path = "/tmp/RtmpLaOb2h/.future/immediateConditions")
[17:43:36.281]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:36.281]                   {
[17:43:36.281]                     inherits <- base::inherits
[17:43:36.281]                     invokeRestart <- base::invokeRestart
[17:43:36.281]                     is.null <- base::is.null
[17:43:36.281]                     muffled <- FALSE
[17:43:36.281]                     if (inherits(cond, "message")) {
[17:43:36.281]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:36.281]                       if (muffled) 
[17:43:36.281]                         invokeRestart("muffleMessage")
[17:43:36.281]                     }
[17:43:36.281]                     else if (inherits(cond, "warning")) {
[17:43:36.281]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:36.281]                       if (muffled) 
[17:43:36.281]                         invokeRestart("muffleWarning")
[17:43:36.281]                     }
[17:43:36.281]                     else if (inherits(cond, "condition")) {
[17:43:36.281]                       if (!is.null(pattern)) {
[17:43:36.281]                         computeRestarts <- base::computeRestarts
[17:43:36.281]                         grepl <- base::grepl
[17:43:36.281]                         restarts <- computeRestarts(cond)
[17:43:36.281]                         for (restart in restarts) {
[17:43:36.281]                           name <- restart$name
[17:43:36.281]                           if (is.null(name)) 
[17:43:36.281]                             next
[17:43:36.281]                           if (!grepl(pattern, name)) 
[17:43:36.281]                             next
[17:43:36.281]                           invokeRestart(restart)
[17:43:36.281]                           muffled <- TRUE
[17:43:36.281]                           break
[17:43:36.281]                         }
[17:43:36.281]                       }
[17:43:36.281]                     }
[17:43:36.281]                     invisible(muffled)
[17:43:36.281]                   }
[17:43:36.281]                   muffleCondition(cond)
[17:43:36.281]                 })
[17:43:36.281]             }))
[17:43:36.281]             future::FutureResult(value = ...future.value$value, 
[17:43:36.281]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:36.281]                   ...future.rng), globalenv = if (FALSE) 
[17:43:36.281]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:36.281]                     ...future.globalenv.names))
[17:43:36.281]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:36.281]         }, condition = base::local({
[17:43:36.281]             c <- base::c
[17:43:36.281]             inherits <- base::inherits
[17:43:36.281]             invokeRestart <- base::invokeRestart
[17:43:36.281]             length <- base::length
[17:43:36.281]             list <- base::list
[17:43:36.281]             seq.int <- base::seq.int
[17:43:36.281]             signalCondition <- base::signalCondition
[17:43:36.281]             sys.calls <- base::sys.calls
[17:43:36.281]             `[[` <- base::`[[`
[17:43:36.281]             `+` <- base::`+`
[17:43:36.281]             `<<-` <- base::`<<-`
[17:43:36.281]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:36.281]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:36.281]                   3L)]
[17:43:36.281]             }
[17:43:36.281]             function(cond) {
[17:43:36.281]                 is_error <- inherits(cond, "error")
[17:43:36.281]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:36.281]                   NULL)
[17:43:36.281]                 if (is_error) {
[17:43:36.281]                   sessionInformation <- function() {
[17:43:36.281]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:36.281]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:36.281]                       search = base::search(), system = base::Sys.info())
[17:43:36.281]                   }
[17:43:36.281]                   ...future.conditions[[length(...future.conditions) + 
[17:43:36.281]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:36.281]                     cond$call), session = sessionInformation(), 
[17:43:36.281]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:36.281]                   signalCondition(cond)
[17:43:36.281]                 }
[17:43:36.281]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:36.281]                 "immediateCondition"))) {
[17:43:36.281]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:36.281]                   ...future.conditions[[length(...future.conditions) + 
[17:43:36.281]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:36.281]                   if (TRUE && !signal) {
[17:43:36.281]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:36.281]                     {
[17:43:36.281]                       inherits <- base::inherits
[17:43:36.281]                       invokeRestart <- base::invokeRestart
[17:43:36.281]                       is.null <- base::is.null
[17:43:36.281]                       muffled <- FALSE
[17:43:36.281]                       if (inherits(cond, "message")) {
[17:43:36.281]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:36.281]                         if (muffled) 
[17:43:36.281]                           invokeRestart("muffleMessage")
[17:43:36.281]                       }
[17:43:36.281]                       else if (inherits(cond, "warning")) {
[17:43:36.281]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:36.281]                         if (muffled) 
[17:43:36.281]                           invokeRestart("muffleWarning")
[17:43:36.281]                       }
[17:43:36.281]                       else if (inherits(cond, "condition")) {
[17:43:36.281]                         if (!is.null(pattern)) {
[17:43:36.281]                           computeRestarts <- base::computeRestarts
[17:43:36.281]                           grepl <- base::grepl
[17:43:36.281]                           restarts <- computeRestarts(cond)
[17:43:36.281]                           for (restart in restarts) {
[17:43:36.281]                             name <- restart$name
[17:43:36.281]                             if (is.null(name)) 
[17:43:36.281]                               next
[17:43:36.281]                             if (!grepl(pattern, name)) 
[17:43:36.281]                               next
[17:43:36.281]                             invokeRestart(restart)
[17:43:36.281]                             muffled <- TRUE
[17:43:36.281]                             break
[17:43:36.281]                           }
[17:43:36.281]                         }
[17:43:36.281]                       }
[17:43:36.281]                       invisible(muffled)
[17:43:36.281]                     }
[17:43:36.281]                     muffleCondition(cond, pattern = "^muffle")
[17:43:36.281]                   }
[17:43:36.281]                 }
[17:43:36.281]                 else {
[17:43:36.281]                   if (TRUE) {
[17:43:36.281]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:36.281]                     {
[17:43:36.281]                       inherits <- base::inherits
[17:43:36.281]                       invokeRestart <- base::invokeRestart
[17:43:36.281]                       is.null <- base::is.null
[17:43:36.281]                       muffled <- FALSE
[17:43:36.281]                       if (inherits(cond, "message")) {
[17:43:36.281]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:36.281]                         if (muffled) 
[17:43:36.281]                           invokeRestart("muffleMessage")
[17:43:36.281]                       }
[17:43:36.281]                       else if (inherits(cond, "warning")) {
[17:43:36.281]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:36.281]                         if (muffled) 
[17:43:36.281]                           invokeRestart("muffleWarning")
[17:43:36.281]                       }
[17:43:36.281]                       else if (inherits(cond, "condition")) {
[17:43:36.281]                         if (!is.null(pattern)) {
[17:43:36.281]                           computeRestarts <- base::computeRestarts
[17:43:36.281]                           grepl <- base::grepl
[17:43:36.281]                           restarts <- computeRestarts(cond)
[17:43:36.281]                           for (restart in restarts) {
[17:43:36.281]                             name <- restart$name
[17:43:36.281]                             if (is.null(name)) 
[17:43:36.281]                               next
[17:43:36.281]                             if (!grepl(pattern, name)) 
[17:43:36.281]                               next
[17:43:36.281]                             invokeRestart(restart)
[17:43:36.281]                             muffled <- TRUE
[17:43:36.281]                             break
[17:43:36.281]                           }
[17:43:36.281]                         }
[17:43:36.281]                       }
[17:43:36.281]                       invisible(muffled)
[17:43:36.281]                     }
[17:43:36.281]                     muffleCondition(cond, pattern = "^muffle")
[17:43:36.281]                   }
[17:43:36.281]                 }
[17:43:36.281]             }
[17:43:36.281]         }))
[17:43:36.281]     }, error = function(ex) {
[17:43:36.281]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:36.281]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:36.281]                 ...future.rng), started = ...future.startTime, 
[17:43:36.281]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:36.281]             version = "1.8"), class = "FutureResult")
[17:43:36.281]     }, finally = {
[17:43:36.281]         if (!identical(...future.workdir, getwd())) 
[17:43:36.281]             setwd(...future.workdir)
[17:43:36.281]         {
[17:43:36.281]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:36.281]                 ...future.oldOptions$nwarnings <- NULL
[17:43:36.281]             }
[17:43:36.281]             base::options(...future.oldOptions)
[17:43:36.281]             if (.Platform$OS.type == "windows") {
[17:43:36.281]                 old_names <- names(...future.oldEnvVars)
[17:43:36.281]                 envs <- base::Sys.getenv()
[17:43:36.281]                 names <- names(envs)
[17:43:36.281]                 common <- intersect(names, old_names)
[17:43:36.281]                 added <- setdiff(names, old_names)
[17:43:36.281]                 removed <- setdiff(old_names, names)
[17:43:36.281]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:36.281]                   envs[common]]
[17:43:36.281]                 NAMES <- toupper(changed)
[17:43:36.281]                 args <- list()
[17:43:36.281]                 for (kk in seq_along(NAMES)) {
[17:43:36.281]                   name <- changed[[kk]]
[17:43:36.281]                   NAME <- NAMES[[kk]]
[17:43:36.281]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:36.281]                     next
[17:43:36.281]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:36.281]                 }
[17:43:36.281]                 NAMES <- toupper(added)
[17:43:36.281]                 for (kk in seq_along(NAMES)) {
[17:43:36.281]                   name <- added[[kk]]
[17:43:36.281]                   NAME <- NAMES[[kk]]
[17:43:36.281]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:36.281]                     next
[17:43:36.281]                   args[[name]] <- ""
[17:43:36.281]                 }
[17:43:36.281]                 NAMES <- toupper(removed)
[17:43:36.281]                 for (kk in seq_along(NAMES)) {
[17:43:36.281]                   name <- removed[[kk]]
[17:43:36.281]                   NAME <- NAMES[[kk]]
[17:43:36.281]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:36.281]                     next
[17:43:36.281]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:36.281]                 }
[17:43:36.281]                 if (length(args) > 0) 
[17:43:36.281]                   base::do.call(base::Sys.setenv, args = args)
[17:43:36.281]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:36.281]             }
[17:43:36.281]             else {
[17:43:36.281]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:36.281]             }
[17:43:36.281]             {
[17:43:36.281]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:36.281]                   0L) {
[17:43:36.281]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:36.281]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:36.281]                   base::options(opts)
[17:43:36.281]                 }
[17:43:36.281]                 {
[17:43:36.281]                   {
[17:43:36.281]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:36.281]                     NULL
[17:43:36.281]                   }
[17:43:36.281]                   options(future.plan = NULL)
[17:43:36.281]                   if (is.na(NA_character_)) 
[17:43:36.281]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:36.281]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:36.281]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:43:36.281]                     envir = parent.frame()) 
[17:43:36.281]                   {
[17:43:36.281]                     default_workers <- missing(workers)
[17:43:36.281]                     if (is.function(workers)) 
[17:43:36.281]                       workers <- workers()
[17:43:36.281]                     workers <- structure(as.integer(workers), 
[17:43:36.281]                       class = class(workers))
[17:43:36.281]                     stop_if_not(is.finite(workers), workers >= 
[17:43:36.281]                       1L)
[17:43:36.281]                     if ((workers == 1L && !inherits(workers, 
[17:43:36.281]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:36.281]                       if (default_workers) 
[17:43:36.281]                         supportsMulticore(warn = TRUE)
[17:43:36.281]                       return(sequential(..., envir = envir))
[17:43:36.281]                     }
[17:43:36.281]                     oopts <- options(mc.cores = workers)
[17:43:36.281]                     on.exit(options(oopts))
[17:43:36.281]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:36.281]                       envir = envir)
[17:43:36.281]                     if (!future$lazy) 
[17:43:36.281]                       future <- run(future)
[17:43:36.281]                     invisible(future)
[17:43:36.281]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:36.281]                 }
[17:43:36.281]             }
[17:43:36.281]         }
[17:43:36.281]     })
[17:43:36.281]     if (TRUE) {
[17:43:36.281]         base::sink(type = "output", split = FALSE)
[17:43:36.281]         if (TRUE) {
[17:43:36.281]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:36.281]         }
[17:43:36.281]         else {
[17:43:36.281]             ...future.result["stdout"] <- base::list(NULL)
[17:43:36.281]         }
[17:43:36.281]         base::close(...future.stdout)
[17:43:36.281]         ...future.stdout <- NULL
[17:43:36.281]     }
[17:43:36.281]     ...future.result$conditions <- ...future.conditions
[17:43:36.281]     ...future.result$finished <- base::Sys.time()
[17:43:36.281]     ...future.result
[17:43:36.281] }
[17:43:36.284] requestCore(): workers = 2
[17:43:36.285] Poll #1 (0): usedCores() = 2, workers = 2
[17:43:36.298] MulticoreFuture started
[17:43:36.299] - Launch lazy future ... done
[17:43:36.299] run() for ‘MulticoreFuture’ ... done
[17:43:36.300] plan(): Setting new future strategy stack:
[17:43:36.301] getGlobalsAndPackages() ...
[17:43:36.301] Searching for globals...
[17:43:36.300] List of future strategies:
[17:43:36.300] 1. sequential:
[17:43:36.300]    - args: function (..., envir = parent.frame())
[17:43:36.300]    - tweaked: FALSE
[17:43:36.300]    - call: NULL
[17:43:36.302] plan(): nbrOfWorkers() = 1
[17:43:36.303] - globals found: [1] ‘{’
[17:43:36.303] Searching for globals ... DONE
[17:43:36.304] Resolving globals: FALSE
[17:43:36.304] plan(): Setting new future strategy stack:
[17:43:36.305] 
[17:43:36.305] 
[17:43:36.305] getGlobalsAndPackages() ... DONE
[17:43:36.305] List of future strategies:
[17:43:36.305] 1. multicore:
[17:43:36.305]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:36.305]    - tweaked: FALSE
[17:43:36.305]    - call: plan(strategy)
[17:43:36.306] run() for ‘Future’ ...
[17:43:36.306] - state: ‘created’
[17:43:36.306] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:36.311] plan(): nbrOfWorkers() = 2
[17:43:36.312] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:36.312] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:36.312]   - Field: ‘label’
[17:43:36.313]   - Field: ‘local’
[17:43:36.313]   - Field: ‘owner’
[17:43:36.313]   - Field: ‘envir’
[17:43:36.313]   - Field: ‘workers’
[17:43:36.313]   - Field: ‘packages’
[17:43:36.313]   - Field: ‘gc’
[17:43:36.314]   - Field: ‘job’
[17:43:36.314]   - Field: ‘conditions’
[17:43:36.314]   - Field: ‘expr’
[17:43:36.314]   - Field: ‘uuid’
[17:43:36.314]   - Field: ‘seed’
[17:43:36.314]   - Field: ‘version’
[17:43:36.314]   - Field: ‘result’
[17:43:36.315]   - Field: ‘asynchronous’
[17:43:36.315]   - Field: ‘calls’
[17:43:36.315]   - Field: ‘globals’
[17:43:36.315]   - Field: ‘stdout’
[17:43:36.315]   - Field: ‘earlySignal’
[17:43:36.315]   - Field: ‘lazy’
[17:43:36.316]   - Field: ‘state’
[17:43:36.316] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:36.316] - Launch lazy future ...
[17:43:36.316] Packages needed by the future expression (n = 0): <none>
[17:43:36.317] Packages needed by future strategies (n = 0): <none>
[17:43:36.317] {
[17:43:36.317]     {
[17:43:36.317]         {
[17:43:36.317]             ...future.startTime <- base::Sys.time()
[17:43:36.317]             {
[17:43:36.317]                 {
[17:43:36.317]                   {
[17:43:36.317]                     {
[17:43:36.317]                       base::local({
[17:43:36.317]                         has_future <- base::requireNamespace("future", 
[17:43:36.317]                           quietly = TRUE)
[17:43:36.317]                         if (has_future) {
[17:43:36.317]                           ns <- base::getNamespace("future")
[17:43:36.317]                           version <- ns[[".package"]][["version"]]
[17:43:36.317]                           if (is.null(version)) 
[17:43:36.317]                             version <- utils::packageVersion("future")
[17:43:36.317]                         }
[17:43:36.317]                         else {
[17:43:36.317]                           version <- NULL
[17:43:36.317]                         }
[17:43:36.317]                         if (!has_future || version < "1.8.0") {
[17:43:36.317]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:36.317]                             "", base::R.version$version.string), 
[17:43:36.317]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:36.317]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:36.317]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:36.317]                               "release", "version")], collapse = " "), 
[17:43:36.317]                             hostname = base::Sys.info()[["nodename"]])
[17:43:36.317]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:36.317]                             info)
[17:43:36.317]                           info <- base::paste(info, collapse = "; ")
[17:43:36.317]                           if (!has_future) {
[17:43:36.317]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:36.317]                               info)
[17:43:36.317]                           }
[17:43:36.317]                           else {
[17:43:36.317]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:36.317]                               info, version)
[17:43:36.317]                           }
[17:43:36.317]                           base::stop(msg)
[17:43:36.317]                         }
[17:43:36.317]                       })
[17:43:36.317]                     }
[17:43:36.317]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:36.317]                     base::options(mc.cores = 1L)
[17:43:36.317]                   }
[17:43:36.317]                   options(future.plan = NULL)
[17:43:36.317]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:36.317]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:36.317]                 }
[17:43:36.317]                 ...future.workdir <- getwd()
[17:43:36.317]             }
[17:43:36.317]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:36.317]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:36.317]         }
[17:43:36.317]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:36.317]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:36.317]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:36.317]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:36.317]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:36.317]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:36.317]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:36.317]             base::names(...future.oldOptions))
[17:43:36.317]     }
[17:43:36.317]     if (FALSE) {
[17:43:36.317]     }
[17:43:36.317]     else {
[17:43:36.317]         if (TRUE) {
[17:43:36.317]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:36.317]                 open = "w")
[17:43:36.317]         }
[17:43:36.317]         else {
[17:43:36.317]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:36.317]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:36.317]         }
[17:43:36.317]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:36.317]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:36.317]             base::sink(type = "output", split = FALSE)
[17:43:36.317]             base::close(...future.stdout)
[17:43:36.317]         }, add = TRUE)
[17:43:36.317]     }
[17:43:36.317]     ...future.frame <- base::sys.nframe()
[17:43:36.317]     ...future.conditions <- base::list()
[17:43:36.317]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:36.317]     if (FALSE) {
[17:43:36.317]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:36.317]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:36.317]     }
[17:43:36.317]     ...future.result <- base::tryCatch({
[17:43:36.317]         base::withCallingHandlers({
[17:43:36.317]             ...future.value <- base::withVisible(base::local({
[17:43:36.317]                 withCallingHandlers({
[17:43:36.317]                   {
[17:43:36.317]                     2
[17:43:36.317]                   }
[17:43:36.317]                 }, immediateCondition = function(cond) {
[17:43:36.317]                   save_rds <- function (object, pathname, ...) 
[17:43:36.317]                   {
[17:43:36.317]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:36.317]                     if (file_test("-f", pathname_tmp)) {
[17:43:36.317]                       fi_tmp <- file.info(pathname_tmp)
[17:43:36.317]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:36.317]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:36.317]                         fi_tmp[["mtime"]])
[17:43:36.317]                     }
[17:43:36.317]                     tryCatch({
[17:43:36.317]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:36.317]                     }, error = function(ex) {
[17:43:36.317]                       msg <- conditionMessage(ex)
[17:43:36.317]                       fi_tmp <- file.info(pathname_tmp)
[17:43:36.317]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:36.317]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:36.317]                         fi_tmp[["mtime"]], msg)
[17:43:36.317]                       ex$message <- msg
[17:43:36.317]                       stop(ex)
[17:43:36.317]                     })
[17:43:36.317]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:36.317]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:36.317]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:36.317]                       fi_tmp <- file.info(pathname_tmp)
[17:43:36.317]                       fi <- file.info(pathname)
[17:43:36.317]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:36.317]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:36.317]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:36.317]                         fi[["size"]], fi[["mtime"]])
[17:43:36.317]                       stop(msg)
[17:43:36.317]                     }
[17:43:36.317]                     invisible(pathname)
[17:43:36.317]                   }
[17:43:36.317]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:36.317]                     rootPath = tempdir()) 
[17:43:36.317]                   {
[17:43:36.317]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:36.317]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:36.317]                       tmpdir = path, fileext = ".rds")
[17:43:36.317]                     save_rds(obj, file)
[17:43:36.317]                   }
[17:43:36.317]                   saveImmediateCondition(cond, path = "/tmp/RtmpLaOb2h/.future/immediateConditions")
[17:43:36.317]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:36.317]                   {
[17:43:36.317]                     inherits <- base::inherits
[17:43:36.317]                     invokeRestart <- base::invokeRestart
[17:43:36.317]                     is.null <- base::is.null
[17:43:36.317]                     muffled <- FALSE
[17:43:36.317]                     if (inherits(cond, "message")) {
[17:43:36.317]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:36.317]                       if (muffled) 
[17:43:36.317]                         invokeRestart("muffleMessage")
[17:43:36.317]                     }
[17:43:36.317]                     else if (inherits(cond, "warning")) {
[17:43:36.317]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:36.317]                       if (muffled) 
[17:43:36.317]                         invokeRestart("muffleWarning")
[17:43:36.317]                     }
[17:43:36.317]                     else if (inherits(cond, "condition")) {
[17:43:36.317]                       if (!is.null(pattern)) {
[17:43:36.317]                         computeRestarts <- base::computeRestarts
[17:43:36.317]                         grepl <- base::grepl
[17:43:36.317]                         restarts <- computeRestarts(cond)
[17:43:36.317]                         for (restart in restarts) {
[17:43:36.317]                           name <- restart$name
[17:43:36.317]                           if (is.null(name)) 
[17:43:36.317]                             next
[17:43:36.317]                           if (!grepl(pattern, name)) 
[17:43:36.317]                             next
[17:43:36.317]                           invokeRestart(restart)
[17:43:36.317]                           muffled <- TRUE
[17:43:36.317]                           break
[17:43:36.317]                         }
[17:43:36.317]                       }
[17:43:36.317]                     }
[17:43:36.317]                     invisible(muffled)
[17:43:36.317]                   }
[17:43:36.317]                   muffleCondition(cond)
[17:43:36.317]                 })
[17:43:36.317]             }))
[17:43:36.317]             future::FutureResult(value = ...future.value$value, 
[17:43:36.317]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:36.317]                   ...future.rng), globalenv = if (FALSE) 
[17:43:36.317]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:36.317]                     ...future.globalenv.names))
[17:43:36.317]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:36.317]         }, condition = base::local({
[17:43:36.317]             c <- base::c
[17:43:36.317]             inherits <- base::inherits
[17:43:36.317]             invokeRestart <- base::invokeRestart
[17:43:36.317]             length <- base::length
[17:43:36.317]             list <- base::list
[17:43:36.317]             seq.int <- base::seq.int
[17:43:36.317]             signalCondition <- base::signalCondition
[17:43:36.317]             sys.calls <- base::sys.calls
[17:43:36.317]             `[[` <- base::`[[`
[17:43:36.317]             `+` <- base::`+`
[17:43:36.317]             `<<-` <- base::`<<-`
[17:43:36.317]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:36.317]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:36.317]                   3L)]
[17:43:36.317]             }
[17:43:36.317]             function(cond) {
[17:43:36.317]                 is_error <- inherits(cond, "error")
[17:43:36.317]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:36.317]                   NULL)
[17:43:36.317]                 if (is_error) {
[17:43:36.317]                   sessionInformation <- function() {
[17:43:36.317]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:36.317]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:36.317]                       search = base::search(), system = base::Sys.info())
[17:43:36.317]                   }
[17:43:36.317]                   ...future.conditions[[length(...future.conditions) + 
[17:43:36.317]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:36.317]                     cond$call), session = sessionInformation(), 
[17:43:36.317]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:36.317]                   signalCondition(cond)
[17:43:36.317]                 }
[17:43:36.317]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:36.317]                 "immediateCondition"))) {
[17:43:36.317]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:36.317]                   ...future.conditions[[length(...future.conditions) + 
[17:43:36.317]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:36.317]                   if (TRUE && !signal) {
[17:43:36.317]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:36.317]                     {
[17:43:36.317]                       inherits <- base::inherits
[17:43:36.317]                       invokeRestart <- base::invokeRestart
[17:43:36.317]                       is.null <- base::is.null
[17:43:36.317]                       muffled <- FALSE
[17:43:36.317]                       if (inherits(cond, "message")) {
[17:43:36.317]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:36.317]                         if (muffled) 
[17:43:36.317]                           invokeRestart("muffleMessage")
[17:43:36.317]                       }
[17:43:36.317]                       else if (inherits(cond, "warning")) {
[17:43:36.317]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:36.317]                         if (muffled) 
[17:43:36.317]                           invokeRestart("muffleWarning")
[17:43:36.317]                       }
[17:43:36.317]                       else if (inherits(cond, "condition")) {
[17:43:36.317]                         if (!is.null(pattern)) {
[17:43:36.317]                           computeRestarts <- base::computeRestarts
[17:43:36.317]                           grepl <- base::grepl
[17:43:36.317]                           restarts <- computeRestarts(cond)
[17:43:36.317]                           for (restart in restarts) {
[17:43:36.317]                             name <- restart$name
[17:43:36.317]                             if (is.null(name)) 
[17:43:36.317]                               next
[17:43:36.317]                             if (!grepl(pattern, name)) 
[17:43:36.317]                               next
[17:43:36.317]                             invokeRestart(restart)
[17:43:36.317]                             muffled <- TRUE
[17:43:36.317]                             break
[17:43:36.317]                           }
[17:43:36.317]                         }
[17:43:36.317]                       }
[17:43:36.317]                       invisible(muffled)
[17:43:36.317]                     }
[17:43:36.317]                     muffleCondition(cond, pattern = "^muffle")
[17:43:36.317]                   }
[17:43:36.317]                 }
[17:43:36.317]                 else {
[17:43:36.317]                   if (TRUE) {
[17:43:36.317]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:36.317]                     {
[17:43:36.317]                       inherits <- base::inherits
[17:43:36.317]                       invokeRestart <- base::invokeRestart
[17:43:36.317]                       is.null <- base::is.null
[17:43:36.317]                       muffled <- FALSE
[17:43:36.317]                       if (inherits(cond, "message")) {
[17:43:36.317]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:36.317]                         if (muffled) 
[17:43:36.317]                           invokeRestart("muffleMessage")
[17:43:36.317]                       }
[17:43:36.317]                       else if (inherits(cond, "warning")) {
[17:43:36.317]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:36.317]                         if (muffled) 
[17:43:36.317]                           invokeRestart("muffleWarning")
[17:43:36.317]                       }
[17:43:36.317]                       else if (inherits(cond, "condition")) {
[17:43:36.317]                         if (!is.null(pattern)) {
[17:43:36.317]                           computeRestarts <- base::computeRestarts
[17:43:36.317]                           grepl <- base::grepl
[17:43:36.317]                           restarts <- computeRestarts(cond)
[17:43:36.317]                           for (restart in restarts) {
[17:43:36.317]                             name <- restart$name
[17:43:36.317]                             if (is.null(name)) 
[17:43:36.317]                               next
[17:43:36.317]                             if (!grepl(pattern, name)) 
[17:43:36.317]                               next
[17:43:36.317]                             invokeRestart(restart)
[17:43:36.317]                             muffled <- TRUE
[17:43:36.317]                             break
[17:43:36.317]                           }
[17:43:36.317]                         }
[17:43:36.317]                       }
[17:43:36.317]                       invisible(muffled)
[17:43:36.317]                     }
[17:43:36.317]                     muffleCondition(cond, pattern = "^muffle")
[17:43:36.317]                   }
[17:43:36.317]                 }
[17:43:36.317]             }
[17:43:36.317]         }))
[17:43:36.317]     }, error = function(ex) {
[17:43:36.317]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:36.317]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:36.317]                 ...future.rng), started = ...future.startTime, 
[17:43:36.317]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:36.317]             version = "1.8"), class = "FutureResult")
[17:43:36.317]     }, finally = {
[17:43:36.317]         if (!identical(...future.workdir, getwd())) 
[17:43:36.317]             setwd(...future.workdir)
[17:43:36.317]         {
[17:43:36.317]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:36.317]                 ...future.oldOptions$nwarnings <- NULL
[17:43:36.317]             }
[17:43:36.317]             base::options(...future.oldOptions)
[17:43:36.317]             if (.Platform$OS.type == "windows") {
[17:43:36.317]                 old_names <- names(...future.oldEnvVars)
[17:43:36.317]                 envs <- base::Sys.getenv()
[17:43:36.317]                 names <- names(envs)
[17:43:36.317]                 common <- intersect(names, old_names)
[17:43:36.317]                 added <- setdiff(names, old_names)
[17:43:36.317]                 removed <- setdiff(old_names, names)
[17:43:36.317]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:36.317]                   envs[common]]
[17:43:36.317]                 NAMES <- toupper(changed)
[17:43:36.317]                 args <- list()
[17:43:36.317]                 for (kk in seq_along(NAMES)) {
[17:43:36.317]                   name <- changed[[kk]]
[17:43:36.317]                   NAME <- NAMES[[kk]]
[17:43:36.317]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:36.317]                     next
[17:43:36.317]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:36.317]                 }
[17:43:36.317]                 NAMES <- toupper(added)
[17:43:36.317]                 for (kk in seq_along(NAMES)) {
[17:43:36.317]                   name <- added[[kk]]
[17:43:36.317]                   NAME <- NAMES[[kk]]
[17:43:36.317]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:36.317]                     next
[17:43:36.317]                   args[[name]] <- ""
[17:43:36.317]                 }
[17:43:36.317]                 NAMES <- toupper(removed)
[17:43:36.317]                 for (kk in seq_along(NAMES)) {
[17:43:36.317]                   name <- removed[[kk]]
[17:43:36.317]                   NAME <- NAMES[[kk]]
[17:43:36.317]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:36.317]                     next
[17:43:36.317]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:36.317]                 }
[17:43:36.317]                 if (length(args) > 0) 
[17:43:36.317]                   base::do.call(base::Sys.setenv, args = args)
[17:43:36.317]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:36.317]             }
[17:43:36.317]             else {
[17:43:36.317]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:36.317]             }
[17:43:36.317]             {
[17:43:36.317]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:36.317]                   0L) {
[17:43:36.317]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:36.317]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:36.317]                   base::options(opts)
[17:43:36.317]                 }
[17:43:36.317]                 {
[17:43:36.317]                   {
[17:43:36.317]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:36.317]                     NULL
[17:43:36.317]                   }
[17:43:36.317]                   options(future.plan = NULL)
[17:43:36.317]                   if (is.na(NA_character_)) 
[17:43:36.317]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:36.317]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:36.317]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:43:36.317]                     envir = parent.frame()) 
[17:43:36.317]                   {
[17:43:36.317]                     default_workers <- missing(workers)
[17:43:36.317]                     if (is.function(workers)) 
[17:43:36.317]                       workers <- workers()
[17:43:36.317]                     workers <- structure(as.integer(workers), 
[17:43:36.317]                       class = class(workers))
[17:43:36.317]                     stop_if_not(is.finite(workers), workers >= 
[17:43:36.317]                       1L)
[17:43:36.317]                     if ((workers == 1L && !inherits(workers, 
[17:43:36.317]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:36.317]                       if (default_workers) 
[17:43:36.317]                         supportsMulticore(warn = TRUE)
[17:43:36.317]                       return(sequential(..., envir = envir))
[17:43:36.317]                     }
[17:43:36.317]                     oopts <- options(mc.cores = workers)
[17:43:36.317]                     on.exit(options(oopts))
[17:43:36.317]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:36.317]                       envir = envir)
[17:43:36.317]                     if (!future$lazy) 
[17:43:36.317]                       future <- run(future)
[17:43:36.317]                     invisible(future)
[17:43:36.317]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:36.317]                 }
[17:43:36.317]             }
[17:43:36.317]         }
[17:43:36.317]     })
[17:43:36.317]     if (TRUE) {
[17:43:36.317]         base::sink(type = "output", split = FALSE)
[17:43:36.317]         if (TRUE) {
[17:43:36.317]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:36.317]         }
[17:43:36.317]         else {
[17:43:36.317]             ...future.result["stdout"] <- base::list(NULL)
[17:43:36.317]         }
[17:43:36.317]         base::close(...future.stdout)
[17:43:36.317]         ...future.stdout <- NULL
[17:43:36.317]     }
[17:43:36.317]     ...future.result$conditions <- ...future.conditions
[17:43:36.317]     ...future.result$finished <- base::Sys.time()
[17:43:36.317]     ...future.result
[17:43:36.317] }
[17:43:36.321] requestCore(): workers = 2
[17:43:36.321] Poll #1 (0): usedCores() = 2, workers = 2
[17:43:36.335] MulticoreFuture started
[17:43:36.336] - Launch lazy future ... done
[17:43:36.336] run() for ‘MulticoreFuture’ ... done
[17:43:36.337] plan(): Setting new future strategy stack:
[17:43:36.337] List of future strategies:
[17:43:36.337] 1. sequential:
[17:43:36.337]    - args: function (..., envir = parent.frame())
[17:43:36.337]    - tweaked: FALSE
[17:43:36.337]    - call: NULL
[17:43:36.338] resolve() on environment ...
[17:43:36.338] plan(): nbrOfWorkers() = 1
[17:43:36.339]  recursive: 0
[17:43:36.340]  elements: [3] ‘a’
[17:43:36.340] Future #1
[17:43:36.341]  length: 2 (resolved future 1)
[17:43:36.341] plan(): Setting new future strategy stack:
[17:43:36.341] List of future strategies:
[17:43:36.341] 1. multicore:
[17:43:36.341]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:36.341]    - tweaked: FALSE
[17:43:36.341]    - call: plan(strategy)
[17:43:36.348] plan(): nbrOfWorkers() = 2
[17:43:36.348] Future #2
[17:43:36.348]  length: 1 (resolved future 2)
[17:43:36.349]  length: 0 (resolved future 3)
[17:43:36.349] resolve() on environment ... DONE
[17:43:36.350] resolve() on environment ...
[17:43:36.350]  recursive: 0
[17:43:36.350]  elements: [3] ‘b’
[17:43:36.351] Future #1
[17:43:36.351]  length: 2 (resolved future 1)
[17:43:36.351] Future #2
[17:43:36.351]  length: 1 (resolved future 2)
[17:43:36.352]  length: 0 (resolved future 3)
[17:43:36.352] resolve() on environment ... DONE
[17:43:36.353] resolve() on environment ...
[17:43:36.353]  recursive: 0
[17:43:36.353]  elements: [3] ‘c’
[17:43:36.354] Future #1
[17:43:36.354]  length: 2 (resolved future 1)
[17:43:36.354] Future #2
[17:43:36.354]  length: 1 (resolved future 2)
[17:43:36.355]  length: 0 (resolved future 3)
[17:43:36.355] resolve() on environment ... DONE
[17:43:36.356] resolve() on environment ...
[17:43:36.356]  recursive: 0
[17:43:36.356]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[17:43:36.357] Future #1
[17:43:36.358]  length: 2 (resolved future 1)
[17:43:36.358] Future #2
[17:43:36.365]  length: 1 (resolved future 2)
[17:43:36.365]  length: 0 (resolved future 3)
[17:43:36.366] resolve() on environment ... DONE
[17:43:36.367] resolve() on environment ...
[17:43:36.367]  recursive: 99
[17:43:36.368]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[17:43:36.368] Future #1
[17:43:36.369] A MulticoreFuture was resolved
[17:43:36.369]  length: 2 (resolved future 1)
[17:43:36.369] Future #2
[17:43:36.369] A MulticoreFuture was resolved
[17:43:36.369]  length: 1 (resolved future 2)
[17:43:36.369]  length: 0 (resolved future 3)
[17:43:36.369] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[17:43:36.371] resolve() on list environment ...
[17:43:36.371]  recursive: 0
[17:43:36.371]  length: 2
[17:43:36.371]  elements: ‘a’, ‘b’
[17:43:36.372]  length: 1 (resolved future 1)
[17:43:36.372]  length: 0 (resolved future 2)
[17:43:36.372] resolve() on list environment ... DONE
[17:43:36.372] getGlobalsAndPackages() ...
[17:43:36.372] Searching for globals...
[17:43:36.373] 
[17:43:36.373] Searching for globals ... DONE
[17:43:36.373] - globals: [0] <none>
[17:43:36.373] getGlobalsAndPackages() ... DONE
[17:43:36.373] run() for ‘Future’ ...
[17:43:36.374] - state: ‘created’
[17:43:36.374] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:36.378] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:36.378] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:36.378]   - Field: ‘label’
[17:43:36.378]   - Field: ‘local’
[17:43:36.378]   - Field: ‘owner’
[17:43:36.379]   - Field: ‘envir’
[17:43:36.379]   - Field: ‘workers’
[17:43:36.379]   - Field: ‘packages’
[17:43:36.379]   - Field: ‘gc’
[17:43:36.379]   - Field: ‘job’
[17:43:36.379]   - Field: ‘conditions’
[17:43:36.379]   - Field: ‘expr’
[17:43:36.379]   - Field: ‘uuid’
[17:43:36.380]   - Field: ‘seed’
[17:43:36.380]   - Field: ‘version’
[17:43:36.380]   - Field: ‘result’
[17:43:36.380]   - Field: ‘asynchronous’
[17:43:36.380]   - Field: ‘calls’
[17:43:36.380]   - Field: ‘globals’
[17:43:36.380]   - Field: ‘stdout’
[17:43:36.380]   - Field: ‘earlySignal’
[17:43:36.380]   - Field: ‘lazy’
[17:43:36.381]   - Field: ‘state’
[17:43:36.381] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:36.381] - Launch lazy future ...
[17:43:36.381] Packages needed by the future expression (n = 0): <none>
[17:43:36.381] Packages needed by future strategies (n = 0): <none>
[17:43:36.382] {
[17:43:36.382]     {
[17:43:36.382]         {
[17:43:36.382]             ...future.startTime <- base::Sys.time()
[17:43:36.382]             {
[17:43:36.382]                 {
[17:43:36.382]                   {
[17:43:36.382]                     {
[17:43:36.382]                       base::local({
[17:43:36.382]                         has_future <- base::requireNamespace("future", 
[17:43:36.382]                           quietly = TRUE)
[17:43:36.382]                         if (has_future) {
[17:43:36.382]                           ns <- base::getNamespace("future")
[17:43:36.382]                           version <- ns[[".package"]][["version"]]
[17:43:36.382]                           if (is.null(version)) 
[17:43:36.382]                             version <- utils::packageVersion("future")
[17:43:36.382]                         }
[17:43:36.382]                         else {
[17:43:36.382]                           version <- NULL
[17:43:36.382]                         }
[17:43:36.382]                         if (!has_future || version < "1.8.0") {
[17:43:36.382]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:36.382]                             "", base::R.version$version.string), 
[17:43:36.382]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:36.382]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:36.382]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:36.382]                               "release", "version")], collapse = " "), 
[17:43:36.382]                             hostname = base::Sys.info()[["nodename"]])
[17:43:36.382]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:36.382]                             info)
[17:43:36.382]                           info <- base::paste(info, collapse = "; ")
[17:43:36.382]                           if (!has_future) {
[17:43:36.382]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:36.382]                               info)
[17:43:36.382]                           }
[17:43:36.382]                           else {
[17:43:36.382]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:36.382]                               info, version)
[17:43:36.382]                           }
[17:43:36.382]                           base::stop(msg)
[17:43:36.382]                         }
[17:43:36.382]                       })
[17:43:36.382]                     }
[17:43:36.382]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:36.382]                     base::options(mc.cores = 1L)
[17:43:36.382]                   }
[17:43:36.382]                   options(future.plan = NULL)
[17:43:36.382]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:36.382]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:36.382]                 }
[17:43:36.382]                 ...future.workdir <- getwd()
[17:43:36.382]             }
[17:43:36.382]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:36.382]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:36.382]         }
[17:43:36.382]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:36.382]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:36.382]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:36.382]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:36.382]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:36.382]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:36.382]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:36.382]             base::names(...future.oldOptions))
[17:43:36.382]     }
[17:43:36.382]     if (FALSE) {
[17:43:36.382]     }
[17:43:36.382]     else {
[17:43:36.382]         if (TRUE) {
[17:43:36.382]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:36.382]                 open = "w")
[17:43:36.382]         }
[17:43:36.382]         else {
[17:43:36.382]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:36.382]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:36.382]         }
[17:43:36.382]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:36.382]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:36.382]             base::sink(type = "output", split = FALSE)
[17:43:36.382]             base::close(...future.stdout)
[17:43:36.382]         }, add = TRUE)
[17:43:36.382]     }
[17:43:36.382]     ...future.frame <- base::sys.nframe()
[17:43:36.382]     ...future.conditions <- base::list()
[17:43:36.382]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:36.382]     if (FALSE) {
[17:43:36.382]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:36.382]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:36.382]     }
[17:43:36.382]     ...future.result <- base::tryCatch({
[17:43:36.382]         base::withCallingHandlers({
[17:43:36.382]             ...future.value <- base::withVisible(base::local({
[17:43:36.382]                 withCallingHandlers({
[17:43:36.382]                   1
[17:43:36.382]                 }, immediateCondition = function(cond) {
[17:43:36.382]                   save_rds <- function (object, pathname, ...) 
[17:43:36.382]                   {
[17:43:36.382]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:36.382]                     if (file_test("-f", pathname_tmp)) {
[17:43:36.382]                       fi_tmp <- file.info(pathname_tmp)
[17:43:36.382]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:36.382]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:36.382]                         fi_tmp[["mtime"]])
[17:43:36.382]                     }
[17:43:36.382]                     tryCatch({
[17:43:36.382]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:36.382]                     }, error = function(ex) {
[17:43:36.382]                       msg <- conditionMessage(ex)
[17:43:36.382]                       fi_tmp <- file.info(pathname_tmp)
[17:43:36.382]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:36.382]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:36.382]                         fi_tmp[["mtime"]], msg)
[17:43:36.382]                       ex$message <- msg
[17:43:36.382]                       stop(ex)
[17:43:36.382]                     })
[17:43:36.382]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:36.382]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:36.382]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:36.382]                       fi_tmp <- file.info(pathname_tmp)
[17:43:36.382]                       fi <- file.info(pathname)
[17:43:36.382]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:36.382]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:36.382]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:36.382]                         fi[["size"]], fi[["mtime"]])
[17:43:36.382]                       stop(msg)
[17:43:36.382]                     }
[17:43:36.382]                     invisible(pathname)
[17:43:36.382]                   }
[17:43:36.382]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:36.382]                     rootPath = tempdir()) 
[17:43:36.382]                   {
[17:43:36.382]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:36.382]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:36.382]                       tmpdir = path, fileext = ".rds")
[17:43:36.382]                     save_rds(obj, file)
[17:43:36.382]                   }
[17:43:36.382]                   saveImmediateCondition(cond, path = "/tmp/RtmpLaOb2h/.future/immediateConditions")
[17:43:36.382]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:36.382]                   {
[17:43:36.382]                     inherits <- base::inherits
[17:43:36.382]                     invokeRestart <- base::invokeRestart
[17:43:36.382]                     is.null <- base::is.null
[17:43:36.382]                     muffled <- FALSE
[17:43:36.382]                     if (inherits(cond, "message")) {
[17:43:36.382]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:36.382]                       if (muffled) 
[17:43:36.382]                         invokeRestart("muffleMessage")
[17:43:36.382]                     }
[17:43:36.382]                     else if (inherits(cond, "warning")) {
[17:43:36.382]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:36.382]                       if (muffled) 
[17:43:36.382]                         invokeRestart("muffleWarning")
[17:43:36.382]                     }
[17:43:36.382]                     else if (inherits(cond, "condition")) {
[17:43:36.382]                       if (!is.null(pattern)) {
[17:43:36.382]                         computeRestarts <- base::computeRestarts
[17:43:36.382]                         grepl <- base::grepl
[17:43:36.382]                         restarts <- computeRestarts(cond)
[17:43:36.382]                         for (restart in restarts) {
[17:43:36.382]                           name <- restart$name
[17:43:36.382]                           if (is.null(name)) 
[17:43:36.382]                             next
[17:43:36.382]                           if (!grepl(pattern, name)) 
[17:43:36.382]                             next
[17:43:36.382]                           invokeRestart(restart)
[17:43:36.382]                           muffled <- TRUE
[17:43:36.382]                           break
[17:43:36.382]                         }
[17:43:36.382]                       }
[17:43:36.382]                     }
[17:43:36.382]                     invisible(muffled)
[17:43:36.382]                   }
[17:43:36.382]                   muffleCondition(cond)
[17:43:36.382]                 })
[17:43:36.382]             }))
[17:43:36.382]             future::FutureResult(value = ...future.value$value, 
[17:43:36.382]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:36.382]                   ...future.rng), globalenv = if (FALSE) 
[17:43:36.382]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:36.382]                     ...future.globalenv.names))
[17:43:36.382]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:36.382]         }, condition = base::local({
[17:43:36.382]             c <- base::c
[17:43:36.382]             inherits <- base::inherits
[17:43:36.382]             invokeRestart <- base::invokeRestart
[17:43:36.382]             length <- base::length
[17:43:36.382]             list <- base::list
[17:43:36.382]             seq.int <- base::seq.int
[17:43:36.382]             signalCondition <- base::signalCondition
[17:43:36.382]             sys.calls <- base::sys.calls
[17:43:36.382]             `[[` <- base::`[[`
[17:43:36.382]             `+` <- base::`+`
[17:43:36.382]             `<<-` <- base::`<<-`
[17:43:36.382]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:36.382]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:36.382]                   3L)]
[17:43:36.382]             }
[17:43:36.382]             function(cond) {
[17:43:36.382]                 is_error <- inherits(cond, "error")
[17:43:36.382]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:36.382]                   NULL)
[17:43:36.382]                 if (is_error) {
[17:43:36.382]                   sessionInformation <- function() {
[17:43:36.382]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:36.382]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:36.382]                       search = base::search(), system = base::Sys.info())
[17:43:36.382]                   }
[17:43:36.382]                   ...future.conditions[[length(...future.conditions) + 
[17:43:36.382]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:36.382]                     cond$call), session = sessionInformation(), 
[17:43:36.382]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:36.382]                   signalCondition(cond)
[17:43:36.382]                 }
[17:43:36.382]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:36.382]                 "immediateCondition"))) {
[17:43:36.382]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:36.382]                   ...future.conditions[[length(...future.conditions) + 
[17:43:36.382]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:36.382]                   if (TRUE && !signal) {
[17:43:36.382]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:36.382]                     {
[17:43:36.382]                       inherits <- base::inherits
[17:43:36.382]                       invokeRestart <- base::invokeRestart
[17:43:36.382]                       is.null <- base::is.null
[17:43:36.382]                       muffled <- FALSE
[17:43:36.382]                       if (inherits(cond, "message")) {
[17:43:36.382]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:36.382]                         if (muffled) 
[17:43:36.382]                           invokeRestart("muffleMessage")
[17:43:36.382]                       }
[17:43:36.382]                       else if (inherits(cond, "warning")) {
[17:43:36.382]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:36.382]                         if (muffled) 
[17:43:36.382]                           invokeRestart("muffleWarning")
[17:43:36.382]                       }
[17:43:36.382]                       else if (inherits(cond, "condition")) {
[17:43:36.382]                         if (!is.null(pattern)) {
[17:43:36.382]                           computeRestarts <- base::computeRestarts
[17:43:36.382]                           grepl <- base::grepl
[17:43:36.382]                           restarts <- computeRestarts(cond)
[17:43:36.382]                           for (restart in restarts) {
[17:43:36.382]                             name <- restart$name
[17:43:36.382]                             if (is.null(name)) 
[17:43:36.382]                               next
[17:43:36.382]                             if (!grepl(pattern, name)) 
[17:43:36.382]                               next
[17:43:36.382]                             invokeRestart(restart)
[17:43:36.382]                             muffled <- TRUE
[17:43:36.382]                             break
[17:43:36.382]                           }
[17:43:36.382]                         }
[17:43:36.382]                       }
[17:43:36.382]                       invisible(muffled)
[17:43:36.382]                     }
[17:43:36.382]                     muffleCondition(cond, pattern = "^muffle")
[17:43:36.382]                   }
[17:43:36.382]                 }
[17:43:36.382]                 else {
[17:43:36.382]                   if (TRUE) {
[17:43:36.382]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:36.382]                     {
[17:43:36.382]                       inherits <- base::inherits
[17:43:36.382]                       invokeRestart <- base::invokeRestart
[17:43:36.382]                       is.null <- base::is.null
[17:43:36.382]                       muffled <- FALSE
[17:43:36.382]                       if (inherits(cond, "message")) {
[17:43:36.382]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:36.382]                         if (muffled) 
[17:43:36.382]                           invokeRestart("muffleMessage")
[17:43:36.382]                       }
[17:43:36.382]                       else if (inherits(cond, "warning")) {
[17:43:36.382]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:36.382]                         if (muffled) 
[17:43:36.382]                           invokeRestart("muffleWarning")
[17:43:36.382]                       }
[17:43:36.382]                       else if (inherits(cond, "condition")) {
[17:43:36.382]                         if (!is.null(pattern)) {
[17:43:36.382]                           computeRestarts <- base::computeRestarts
[17:43:36.382]                           grepl <- base::grepl
[17:43:36.382]                           restarts <- computeRestarts(cond)
[17:43:36.382]                           for (restart in restarts) {
[17:43:36.382]                             name <- restart$name
[17:43:36.382]                             if (is.null(name)) 
[17:43:36.382]                               next
[17:43:36.382]                             if (!grepl(pattern, name)) 
[17:43:36.382]                               next
[17:43:36.382]                             invokeRestart(restart)
[17:43:36.382]                             muffled <- TRUE
[17:43:36.382]                             break
[17:43:36.382]                           }
[17:43:36.382]                         }
[17:43:36.382]                       }
[17:43:36.382]                       invisible(muffled)
[17:43:36.382]                     }
[17:43:36.382]                     muffleCondition(cond, pattern = "^muffle")
[17:43:36.382]                   }
[17:43:36.382]                 }
[17:43:36.382]             }
[17:43:36.382]         }))
[17:43:36.382]     }, error = function(ex) {
[17:43:36.382]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:36.382]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:36.382]                 ...future.rng), started = ...future.startTime, 
[17:43:36.382]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:36.382]             version = "1.8"), class = "FutureResult")
[17:43:36.382]     }, finally = {
[17:43:36.382]         if (!identical(...future.workdir, getwd())) 
[17:43:36.382]             setwd(...future.workdir)
[17:43:36.382]         {
[17:43:36.382]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:36.382]                 ...future.oldOptions$nwarnings <- NULL
[17:43:36.382]             }
[17:43:36.382]             base::options(...future.oldOptions)
[17:43:36.382]             if (.Platform$OS.type == "windows") {
[17:43:36.382]                 old_names <- names(...future.oldEnvVars)
[17:43:36.382]                 envs <- base::Sys.getenv()
[17:43:36.382]                 names <- names(envs)
[17:43:36.382]                 common <- intersect(names, old_names)
[17:43:36.382]                 added <- setdiff(names, old_names)
[17:43:36.382]                 removed <- setdiff(old_names, names)
[17:43:36.382]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:36.382]                   envs[common]]
[17:43:36.382]                 NAMES <- toupper(changed)
[17:43:36.382]                 args <- list()
[17:43:36.382]                 for (kk in seq_along(NAMES)) {
[17:43:36.382]                   name <- changed[[kk]]
[17:43:36.382]                   NAME <- NAMES[[kk]]
[17:43:36.382]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:36.382]                     next
[17:43:36.382]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:36.382]                 }
[17:43:36.382]                 NAMES <- toupper(added)
[17:43:36.382]                 for (kk in seq_along(NAMES)) {
[17:43:36.382]                   name <- added[[kk]]
[17:43:36.382]                   NAME <- NAMES[[kk]]
[17:43:36.382]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:36.382]                     next
[17:43:36.382]                   args[[name]] <- ""
[17:43:36.382]                 }
[17:43:36.382]                 NAMES <- toupper(removed)
[17:43:36.382]                 for (kk in seq_along(NAMES)) {
[17:43:36.382]                   name <- removed[[kk]]
[17:43:36.382]                   NAME <- NAMES[[kk]]
[17:43:36.382]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:36.382]                     next
[17:43:36.382]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:36.382]                 }
[17:43:36.382]                 if (length(args) > 0) 
[17:43:36.382]                   base::do.call(base::Sys.setenv, args = args)
[17:43:36.382]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:36.382]             }
[17:43:36.382]             else {
[17:43:36.382]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:36.382]             }
[17:43:36.382]             {
[17:43:36.382]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:36.382]                   0L) {
[17:43:36.382]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:36.382]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:36.382]                   base::options(opts)
[17:43:36.382]                 }
[17:43:36.382]                 {
[17:43:36.382]                   {
[17:43:36.382]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:36.382]                     NULL
[17:43:36.382]                   }
[17:43:36.382]                   options(future.plan = NULL)
[17:43:36.382]                   if (is.na(NA_character_)) 
[17:43:36.382]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:36.382]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:36.382]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:43:36.382]                     envir = parent.frame()) 
[17:43:36.382]                   {
[17:43:36.382]                     default_workers <- missing(workers)
[17:43:36.382]                     if (is.function(workers)) 
[17:43:36.382]                       workers <- workers()
[17:43:36.382]                     workers <- structure(as.integer(workers), 
[17:43:36.382]                       class = class(workers))
[17:43:36.382]                     stop_if_not(is.finite(workers), workers >= 
[17:43:36.382]                       1L)
[17:43:36.382]                     if ((workers == 1L && !inherits(workers, 
[17:43:36.382]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:36.382]                       if (default_workers) 
[17:43:36.382]                         supportsMulticore(warn = TRUE)
[17:43:36.382]                       return(sequential(..., envir = envir))
[17:43:36.382]                     }
[17:43:36.382]                     oopts <- options(mc.cores = workers)
[17:43:36.382]                     on.exit(options(oopts))
[17:43:36.382]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:36.382]                       envir = envir)
[17:43:36.382]                     if (!future$lazy) 
[17:43:36.382]                       future <- run(future)
[17:43:36.382]                     invisible(future)
[17:43:36.382]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:36.382]                 }
[17:43:36.382]             }
[17:43:36.382]         }
[17:43:36.382]     })
[17:43:36.382]     if (TRUE) {
[17:43:36.382]         base::sink(type = "output", split = FALSE)
[17:43:36.382]         if (TRUE) {
[17:43:36.382]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:36.382]         }
[17:43:36.382]         else {
[17:43:36.382]             ...future.result["stdout"] <- base::list(NULL)
[17:43:36.382]         }
[17:43:36.382]         base::close(...future.stdout)
[17:43:36.382]         ...future.stdout <- NULL
[17:43:36.382]     }
[17:43:36.382]     ...future.result$conditions <- ...future.conditions
[17:43:36.382]     ...future.result$finished <- base::Sys.time()
[17:43:36.382]     ...future.result
[17:43:36.382] }
[17:43:36.384] requestCore(): workers = 2
[17:43:36.387] MulticoreFuture started
[17:43:36.387] - Launch lazy future ... done
[17:43:36.387] run() for ‘MulticoreFuture’ ... done
[17:43:36.388] getGlobalsAndPackages() ...
[17:43:36.388] Searching for globals...
[17:43:36.388] plan(): Setting new future strategy stack:
[17:43:36.389] 
[17:43:36.388] List of future strategies:
[17:43:36.388] 1. sequential:
[17:43:36.388]    - args: function (..., envir = parent.frame())
[17:43:36.388]    - tweaked: FALSE
[17:43:36.388]    - call: NULL
[17:43:36.389] Searching for globals ... DONE
[17:43:36.389] plan(): nbrOfWorkers() = 1
[17:43:36.389] - globals: [0] <none>
[17:43:36.389] getGlobalsAndPackages() ... DONE
[17:43:36.390] run() for ‘Future’ ...
[17:43:36.390] - state: ‘created’
[17:43:36.390] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:36.391] plan(): Setting new future strategy stack:
[17:43:36.391] List of future strategies:
[17:43:36.391] 1. multicore:
[17:43:36.391]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:36.391]    - tweaked: FALSE
[17:43:36.391]    - call: plan(strategy)
[17:43:36.396] plan(): nbrOfWorkers() = 2
[17:43:36.397] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:36.397] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:36.397]   - Field: ‘label’
[17:43:36.397]   - Field: ‘local’
[17:43:36.397]   - Field: ‘owner’
[17:43:36.398]   - Field: ‘envir’
[17:43:36.398]   - Field: ‘workers’
[17:43:36.398]   - Field: ‘packages’
[17:43:36.398]   - Field: ‘gc’
[17:43:36.398]   - Field: ‘job’
[17:43:36.398]   - Field: ‘conditions’
[17:43:36.399]   - Field: ‘expr’
[17:43:36.399]   - Field: ‘uuid’
[17:43:36.399]   - Field: ‘seed’
[17:43:36.399]   - Field: ‘version’
[17:43:36.399]   - Field: ‘result’
[17:43:36.399]   - Field: ‘asynchronous’
[17:43:36.400]   - Field: ‘calls’
[17:43:36.400]   - Field: ‘globals’
[17:43:36.400]   - Field: ‘stdout’
[17:43:36.400]   - Field: ‘earlySignal’
[17:43:36.400]   - Field: ‘lazy’
[17:43:36.400]   - Field: ‘state’
[17:43:36.400] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:36.401] - Launch lazy future ...
[17:43:36.401] Packages needed by the future expression (n = 0): <none>
[17:43:36.401] Packages needed by future strategies (n = 0): <none>
[17:43:36.402] {
[17:43:36.402]     {
[17:43:36.402]         {
[17:43:36.402]             ...future.startTime <- base::Sys.time()
[17:43:36.402]             {
[17:43:36.402]                 {
[17:43:36.402]                   {
[17:43:36.402]                     {
[17:43:36.402]                       base::local({
[17:43:36.402]                         has_future <- base::requireNamespace("future", 
[17:43:36.402]                           quietly = TRUE)
[17:43:36.402]                         if (has_future) {
[17:43:36.402]                           ns <- base::getNamespace("future")
[17:43:36.402]                           version <- ns[[".package"]][["version"]]
[17:43:36.402]                           if (is.null(version)) 
[17:43:36.402]                             version <- utils::packageVersion("future")
[17:43:36.402]                         }
[17:43:36.402]                         else {
[17:43:36.402]                           version <- NULL
[17:43:36.402]                         }
[17:43:36.402]                         if (!has_future || version < "1.8.0") {
[17:43:36.402]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:36.402]                             "", base::R.version$version.string), 
[17:43:36.402]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:36.402]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:36.402]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:36.402]                               "release", "version")], collapse = " "), 
[17:43:36.402]                             hostname = base::Sys.info()[["nodename"]])
[17:43:36.402]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:36.402]                             info)
[17:43:36.402]                           info <- base::paste(info, collapse = "; ")
[17:43:36.402]                           if (!has_future) {
[17:43:36.402]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:36.402]                               info)
[17:43:36.402]                           }
[17:43:36.402]                           else {
[17:43:36.402]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:36.402]                               info, version)
[17:43:36.402]                           }
[17:43:36.402]                           base::stop(msg)
[17:43:36.402]                         }
[17:43:36.402]                       })
[17:43:36.402]                     }
[17:43:36.402]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:36.402]                     base::options(mc.cores = 1L)
[17:43:36.402]                   }
[17:43:36.402]                   options(future.plan = NULL)
[17:43:36.402]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:36.402]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:36.402]                 }
[17:43:36.402]                 ...future.workdir <- getwd()
[17:43:36.402]             }
[17:43:36.402]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:36.402]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:36.402]         }
[17:43:36.402]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:36.402]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:36.402]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:36.402]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:36.402]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:36.402]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:36.402]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:36.402]             base::names(...future.oldOptions))
[17:43:36.402]     }
[17:43:36.402]     if (FALSE) {
[17:43:36.402]     }
[17:43:36.402]     else {
[17:43:36.402]         if (TRUE) {
[17:43:36.402]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:36.402]                 open = "w")
[17:43:36.402]         }
[17:43:36.402]         else {
[17:43:36.402]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:36.402]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:36.402]         }
[17:43:36.402]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:36.402]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:36.402]             base::sink(type = "output", split = FALSE)
[17:43:36.402]             base::close(...future.stdout)
[17:43:36.402]         }, add = TRUE)
[17:43:36.402]     }
[17:43:36.402]     ...future.frame <- base::sys.nframe()
[17:43:36.402]     ...future.conditions <- base::list()
[17:43:36.402]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:36.402]     if (FALSE) {
[17:43:36.402]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:36.402]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:36.402]     }
[17:43:36.402]     ...future.result <- base::tryCatch({
[17:43:36.402]         base::withCallingHandlers({
[17:43:36.402]             ...future.value <- base::withVisible(base::local({
[17:43:36.402]                 withCallingHandlers({
[17:43:36.402]                   2
[17:43:36.402]                 }, immediateCondition = function(cond) {
[17:43:36.402]                   save_rds <- function (object, pathname, ...) 
[17:43:36.402]                   {
[17:43:36.402]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:36.402]                     if (file_test("-f", pathname_tmp)) {
[17:43:36.402]                       fi_tmp <- file.info(pathname_tmp)
[17:43:36.402]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:36.402]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:36.402]                         fi_tmp[["mtime"]])
[17:43:36.402]                     }
[17:43:36.402]                     tryCatch({
[17:43:36.402]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:36.402]                     }, error = function(ex) {
[17:43:36.402]                       msg <- conditionMessage(ex)
[17:43:36.402]                       fi_tmp <- file.info(pathname_tmp)
[17:43:36.402]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:36.402]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:36.402]                         fi_tmp[["mtime"]], msg)
[17:43:36.402]                       ex$message <- msg
[17:43:36.402]                       stop(ex)
[17:43:36.402]                     })
[17:43:36.402]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:36.402]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:36.402]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:36.402]                       fi_tmp <- file.info(pathname_tmp)
[17:43:36.402]                       fi <- file.info(pathname)
[17:43:36.402]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:36.402]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:36.402]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:36.402]                         fi[["size"]], fi[["mtime"]])
[17:43:36.402]                       stop(msg)
[17:43:36.402]                     }
[17:43:36.402]                     invisible(pathname)
[17:43:36.402]                   }
[17:43:36.402]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:36.402]                     rootPath = tempdir()) 
[17:43:36.402]                   {
[17:43:36.402]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:36.402]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:36.402]                       tmpdir = path, fileext = ".rds")
[17:43:36.402]                     save_rds(obj, file)
[17:43:36.402]                   }
[17:43:36.402]                   saveImmediateCondition(cond, path = "/tmp/RtmpLaOb2h/.future/immediateConditions")
[17:43:36.402]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:36.402]                   {
[17:43:36.402]                     inherits <- base::inherits
[17:43:36.402]                     invokeRestart <- base::invokeRestart
[17:43:36.402]                     is.null <- base::is.null
[17:43:36.402]                     muffled <- FALSE
[17:43:36.402]                     if (inherits(cond, "message")) {
[17:43:36.402]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:36.402]                       if (muffled) 
[17:43:36.402]                         invokeRestart("muffleMessage")
[17:43:36.402]                     }
[17:43:36.402]                     else if (inherits(cond, "warning")) {
[17:43:36.402]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:36.402]                       if (muffled) 
[17:43:36.402]                         invokeRestart("muffleWarning")
[17:43:36.402]                     }
[17:43:36.402]                     else if (inherits(cond, "condition")) {
[17:43:36.402]                       if (!is.null(pattern)) {
[17:43:36.402]                         computeRestarts <- base::computeRestarts
[17:43:36.402]                         grepl <- base::grepl
[17:43:36.402]                         restarts <- computeRestarts(cond)
[17:43:36.402]                         for (restart in restarts) {
[17:43:36.402]                           name <- restart$name
[17:43:36.402]                           if (is.null(name)) 
[17:43:36.402]                             next
[17:43:36.402]                           if (!grepl(pattern, name)) 
[17:43:36.402]                             next
[17:43:36.402]                           invokeRestart(restart)
[17:43:36.402]                           muffled <- TRUE
[17:43:36.402]                           break
[17:43:36.402]                         }
[17:43:36.402]                       }
[17:43:36.402]                     }
[17:43:36.402]                     invisible(muffled)
[17:43:36.402]                   }
[17:43:36.402]                   muffleCondition(cond)
[17:43:36.402]                 })
[17:43:36.402]             }))
[17:43:36.402]             future::FutureResult(value = ...future.value$value, 
[17:43:36.402]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:36.402]                   ...future.rng), globalenv = if (FALSE) 
[17:43:36.402]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:36.402]                     ...future.globalenv.names))
[17:43:36.402]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:36.402]         }, condition = base::local({
[17:43:36.402]             c <- base::c
[17:43:36.402]             inherits <- base::inherits
[17:43:36.402]             invokeRestart <- base::invokeRestart
[17:43:36.402]             length <- base::length
[17:43:36.402]             list <- base::list
[17:43:36.402]             seq.int <- base::seq.int
[17:43:36.402]             signalCondition <- base::signalCondition
[17:43:36.402]             sys.calls <- base::sys.calls
[17:43:36.402]             `[[` <- base::`[[`
[17:43:36.402]             `+` <- base::`+`
[17:43:36.402]             `<<-` <- base::`<<-`
[17:43:36.402]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:36.402]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:36.402]                   3L)]
[17:43:36.402]             }
[17:43:36.402]             function(cond) {
[17:43:36.402]                 is_error <- inherits(cond, "error")
[17:43:36.402]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:36.402]                   NULL)
[17:43:36.402]                 if (is_error) {
[17:43:36.402]                   sessionInformation <- function() {
[17:43:36.402]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:36.402]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:36.402]                       search = base::search(), system = base::Sys.info())
[17:43:36.402]                   }
[17:43:36.402]                   ...future.conditions[[length(...future.conditions) + 
[17:43:36.402]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:36.402]                     cond$call), session = sessionInformation(), 
[17:43:36.402]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:36.402]                   signalCondition(cond)
[17:43:36.402]                 }
[17:43:36.402]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:36.402]                 "immediateCondition"))) {
[17:43:36.402]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:36.402]                   ...future.conditions[[length(...future.conditions) + 
[17:43:36.402]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:36.402]                   if (TRUE && !signal) {
[17:43:36.402]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:36.402]                     {
[17:43:36.402]                       inherits <- base::inherits
[17:43:36.402]                       invokeRestart <- base::invokeRestart
[17:43:36.402]                       is.null <- base::is.null
[17:43:36.402]                       muffled <- FALSE
[17:43:36.402]                       if (inherits(cond, "message")) {
[17:43:36.402]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:36.402]                         if (muffled) 
[17:43:36.402]                           invokeRestart("muffleMessage")
[17:43:36.402]                       }
[17:43:36.402]                       else if (inherits(cond, "warning")) {
[17:43:36.402]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:36.402]                         if (muffled) 
[17:43:36.402]                           invokeRestart("muffleWarning")
[17:43:36.402]                       }
[17:43:36.402]                       else if (inherits(cond, "condition")) {
[17:43:36.402]                         if (!is.null(pattern)) {
[17:43:36.402]                           computeRestarts <- base::computeRestarts
[17:43:36.402]                           grepl <- base::grepl
[17:43:36.402]                           restarts <- computeRestarts(cond)
[17:43:36.402]                           for (restart in restarts) {
[17:43:36.402]                             name <- restart$name
[17:43:36.402]                             if (is.null(name)) 
[17:43:36.402]                               next
[17:43:36.402]                             if (!grepl(pattern, name)) 
[17:43:36.402]                               next
[17:43:36.402]                             invokeRestart(restart)
[17:43:36.402]                             muffled <- TRUE
[17:43:36.402]                             break
[17:43:36.402]                           }
[17:43:36.402]                         }
[17:43:36.402]                       }
[17:43:36.402]                       invisible(muffled)
[17:43:36.402]                     }
[17:43:36.402]                     muffleCondition(cond, pattern = "^muffle")
[17:43:36.402]                   }
[17:43:36.402]                 }
[17:43:36.402]                 else {
[17:43:36.402]                   if (TRUE) {
[17:43:36.402]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:36.402]                     {
[17:43:36.402]                       inherits <- base::inherits
[17:43:36.402]                       invokeRestart <- base::invokeRestart
[17:43:36.402]                       is.null <- base::is.null
[17:43:36.402]                       muffled <- FALSE
[17:43:36.402]                       if (inherits(cond, "message")) {
[17:43:36.402]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:36.402]                         if (muffled) 
[17:43:36.402]                           invokeRestart("muffleMessage")
[17:43:36.402]                       }
[17:43:36.402]                       else if (inherits(cond, "warning")) {
[17:43:36.402]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:36.402]                         if (muffled) 
[17:43:36.402]                           invokeRestart("muffleWarning")
[17:43:36.402]                       }
[17:43:36.402]                       else if (inherits(cond, "condition")) {
[17:43:36.402]                         if (!is.null(pattern)) {
[17:43:36.402]                           computeRestarts <- base::computeRestarts
[17:43:36.402]                           grepl <- base::grepl
[17:43:36.402]                           restarts <- computeRestarts(cond)
[17:43:36.402]                           for (restart in restarts) {
[17:43:36.402]                             name <- restart$name
[17:43:36.402]                             if (is.null(name)) 
[17:43:36.402]                               next
[17:43:36.402]                             if (!grepl(pattern, name)) 
[17:43:36.402]                               next
[17:43:36.402]                             invokeRestart(restart)
[17:43:36.402]                             muffled <- TRUE
[17:43:36.402]                             break
[17:43:36.402]                           }
[17:43:36.402]                         }
[17:43:36.402]                       }
[17:43:36.402]                       invisible(muffled)
[17:43:36.402]                     }
[17:43:36.402]                     muffleCondition(cond, pattern = "^muffle")
[17:43:36.402]                   }
[17:43:36.402]                 }
[17:43:36.402]             }
[17:43:36.402]         }))
[17:43:36.402]     }, error = function(ex) {
[17:43:36.402]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:36.402]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:36.402]                 ...future.rng), started = ...future.startTime, 
[17:43:36.402]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:36.402]             version = "1.8"), class = "FutureResult")
[17:43:36.402]     }, finally = {
[17:43:36.402]         if (!identical(...future.workdir, getwd())) 
[17:43:36.402]             setwd(...future.workdir)
[17:43:36.402]         {
[17:43:36.402]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:36.402]                 ...future.oldOptions$nwarnings <- NULL
[17:43:36.402]             }
[17:43:36.402]             base::options(...future.oldOptions)
[17:43:36.402]             if (.Platform$OS.type == "windows") {
[17:43:36.402]                 old_names <- names(...future.oldEnvVars)
[17:43:36.402]                 envs <- base::Sys.getenv()
[17:43:36.402]                 names <- names(envs)
[17:43:36.402]                 common <- intersect(names, old_names)
[17:43:36.402]                 added <- setdiff(names, old_names)
[17:43:36.402]                 removed <- setdiff(old_names, names)
[17:43:36.402]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:36.402]                   envs[common]]
[17:43:36.402]                 NAMES <- toupper(changed)
[17:43:36.402]                 args <- list()
[17:43:36.402]                 for (kk in seq_along(NAMES)) {
[17:43:36.402]                   name <- changed[[kk]]
[17:43:36.402]                   NAME <- NAMES[[kk]]
[17:43:36.402]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:36.402]                     next
[17:43:36.402]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:36.402]                 }
[17:43:36.402]                 NAMES <- toupper(added)
[17:43:36.402]                 for (kk in seq_along(NAMES)) {
[17:43:36.402]                   name <- added[[kk]]
[17:43:36.402]                   NAME <- NAMES[[kk]]
[17:43:36.402]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:36.402]                     next
[17:43:36.402]                   args[[name]] <- ""
[17:43:36.402]                 }
[17:43:36.402]                 NAMES <- toupper(removed)
[17:43:36.402]                 for (kk in seq_along(NAMES)) {
[17:43:36.402]                   name <- removed[[kk]]
[17:43:36.402]                   NAME <- NAMES[[kk]]
[17:43:36.402]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:36.402]                     next
[17:43:36.402]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:36.402]                 }
[17:43:36.402]                 if (length(args) > 0) 
[17:43:36.402]                   base::do.call(base::Sys.setenv, args = args)
[17:43:36.402]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:36.402]             }
[17:43:36.402]             else {
[17:43:36.402]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:36.402]             }
[17:43:36.402]             {
[17:43:36.402]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:36.402]                   0L) {
[17:43:36.402]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:36.402]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:36.402]                   base::options(opts)
[17:43:36.402]                 }
[17:43:36.402]                 {
[17:43:36.402]                   {
[17:43:36.402]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:36.402]                     NULL
[17:43:36.402]                   }
[17:43:36.402]                   options(future.plan = NULL)
[17:43:36.402]                   if (is.na(NA_character_)) 
[17:43:36.402]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:36.402]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:36.402]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:43:36.402]                     envir = parent.frame()) 
[17:43:36.402]                   {
[17:43:36.402]                     default_workers <- missing(workers)
[17:43:36.402]                     if (is.function(workers)) 
[17:43:36.402]                       workers <- workers()
[17:43:36.402]                     workers <- structure(as.integer(workers), 
[17:43:36.402]                       class = class(workers))
[17:43:36.402]                     stop_if_not(is.finite(workers), workers >= 
[17:43:36.402]                       1L)
[17:43:36.402]                     if ((workers == 1L && !inherits(workers, 
[17:43:36.402]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:36.402]                       if (default_workers) 
[17:43:36.402]                         supportsMulticore(warn = TRUE)
[17:43:36.402]                       return(sequential(..., envir = envir))
[17:43:36.402]                     }
[17:43:36.402]                     oopts <- options(mc.cores = workers)
[17:43:36.402]                     on.exit(options(oopts))
[17:43:36.402]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:36.402]                       envir = envir)
[17:43:36.402]                     if (!future$lazy) 
[17:43:36.402]                       future <- run(future)
[17:43:36.402]                     invisible(future)
[17:43:36.402]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:36.402]                 }
[17:43:36.402]             }
[17:43:36.402]         }
[17:43:36.402]     })
[17:43:36.402]     if (TRUE) {
[17:43:36.402]         base::sink(type = "output", split = FALSE)
[17:43:36.402]         if (TRUE) {
[17:43:36.402]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:36.402]         }
[17:43:36.402]         else {
[17:43:36.402]             ...future.result["stdout"] <- base::list(NULL)
[17:43:36.402]         }
[17:43:36.402]         base::close(...future.stdout)
[17:43:36.402]         ...future.stdout <- NULL
[17:43:36.402]     }
[17:43:36.402]     ...future.result$conditions <- ...future.conditions
[17:43:36.402]     ...future.result$finished <- base::Sys.time()
[17:43:36.402]     ...future.result
[17:43:36.402] }
[17:43:36.406] requestCore(): workers = 2
[17:43:36.408] MulticoreFuture started
[17:43:36.408] - Launch lazy future ... done
[17:43:36.408] run() for ‘MulticoreFuture’ ... done
[17:43:36.409] plan(): Setting new future strategy stack:
[17:43:36.410] resolve() on list environment ...
[17:43:36.409] List of future strategies:
[17:43:36.409] 1. sequential:
[17:43:36.409]    - args: function (..., envir = parent.frame())
[17:43:36.409]    - tweaked: FALSE
[17:43:36.409]    - call: NULL
[17:43:36.410]  recursive: 0
[17:43:36.410] plan(): nbrOfWorkers() = 1
[17:43:36.411]  length: 3
[17:43:36.411]  elements: ‘a’, ‘b’, ‘c’
[17:43:36.412] Future #1
[17:43:36.412]  length: 2 (resolved future 1)
[17:43:36.412] plan(): Setting new future strategy stack:
[17:43:36.412] List of future strategies:
[17:43:36.412] 1. multicore:
[17:43:36.412]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:36.412]    - tweaked: FALSE
[17:43:36.412]    - call: plan(strategy)
[17:43:36.418] plan(): nbrOfWorkers() = 2
[17:43:36.419] Future #2
[17:43:36.419]  length: 1 (resolved future 2)
[17:43:36.419]  length: 0 (resolved future 3)
[17:43:36.419] resolve() on list environment ... DONE
[17:43:36.420] getGlobalsAndPackages() ...
[17:43:36.421] Searching for globals...
[17:43:36.422] - globals found: [1] ‘{’
[17:43:36.422] Searching for globals ... DONE
[17:43:36.422] Resolving globals: FALSE
[17:43:36.423] 
[17:43:36.423] 
[17:43:36.427] getGlobalsAndPackages() ... DONE
[17:43:36.428] run() for ‘Future’ ...
[17:43:36.429] - state: ‘created’
[17:43:36.429] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:36.436] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:36.436] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:36.437]   - Field: ‘label’
[17:43:36.437]   - Field: ‘local’
[17:43:36.437]   - Field: ‘owner’
[17:43:36.437]   - Field: ‘envir’
[17:43:36.437]   - Field: ‘workers’
[17:43:36.437]   - Field: ‘packages’
[17:43:36.438]   - Field: ‘gc’
[17:43:36.438]   - Field: ‘job’
[17:43:36.438]   - Field: ‘conditions’
[17:43:36.438]   - Field: ‘expr’
[17:43:36.438]   - Field: ‘uuid’
[17:43:36.439]   - Field: ‘seed’
[17:43:36.439]   - Field: ‘version’
[17:43:36.439]   - Field: ‘result’
[17:43:36.439]   - Field: ‘asynchronous’
[17:43:36.439]   - Field: ‘calls’
[17:43:36.439]   - Field: ‘globals’
[17:43:36.439]   - Field: ‘stdout’
[17:43:36.440]   - Field: ‘earlySignal’
[17:43:36.440]   - Field: ‘lazy’
[17:43:36.440]   - Field: ‘state’
[17:43:36.440] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:36.440] - Launch lazy future ...
[17:43:36.441] Packages needed by the future expression (n = 0): <none>
[17:43:36.441] Packages needed by future strategies (n = 0): <none>
[17:43:36.442] {
[17:43:36.442]     {
[17:43:36.442]         {
[17:43:36.442]             ...future.startTime <- base::Sys.time()
[17:43:36.442]             {
[17:43:36.442]                 {
[17:43:36.442]                   {
[17:43:36.442]                     {
[17:43:36.442]                       base::local({
[17:43:36.442]                         has_future <- base::requireNamespace("future", 
[17:43:36.442]                           quietly = TRUE)
[17:43:36.442]                         if (has_future) {
[17:43:36.442]                           ns <- base::getNamespace("future")
[17:43:36.442]                           version <- ns[[".package"]][["version"]]
[17:43:36.442]                           if (is.null(version)) 
[17:43:36.442]                             version <- utils::packageVersion("future")
[17:43:36.442]                         }
[17:43:36.442]                         else {
[17:43:36.442]                           version <- NULL
[17:43:36.442]                         }
[17:43:36.442]                         if (!has_future || version < "1.8.0") {
[17:43:36.442]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:36.442]                             "", base::R.version$version.string), 
[17:43:36.442]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:36.442]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:36.442]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:36.442]                               "release", "version")], collapse = " "), 
[17:43:36.442]                             hostname = base::Sys.info()[["nodename"]])
[17:43:36.442]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:36.442]                             info)
[17:43:36.442]                           info <- base::paste(info, collapse = "; ")
[17:43:36.442]                           if (!has_future) {
[17:43:36.442]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:36.442]                               info)
[17:43:36.442]                           }
[17:43:36.442]                           else {
[17:43:36.442]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:36.442]                               info, version)
[17:43:36.442]                           }
[17:43:36.442]                           base::stop(msg)
[17:43:36.442]                         }
[17:43:36.442]                       })
[17:43:36.442]                     }
[17:43:36.442]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:36.442]                     base::options(mc.cores = 1L)
[17:43:36.442]                   }
[17:43:36.442]                   options(future.plan = NULL)
[17:43:36.442]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:36.442]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:36.442]                 }
[17:43:36.442]                 ...future.workdir <- getwd()
[17:43:36.442]             }
[17:43:36.442]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:36.442]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:36.442]         }
[17:43:36.442]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:36.442]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:36.442]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:36.442]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:36.442]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:36.442]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:36.442]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:36.442]             base::names(...future.oldOptions))
[17:43:36.442]     }
[17:43:36.442]     if (FALSE) {
[17:43:36.442]     }
[17:43:36.442]     else {
[17:43:36.442]         if (TRUE) {
[17:43:36.442]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:36.442]                 open = "w")
[17:43:36.442]         }
[17:43:36.442]         else {
[17:43:36.442]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:36.442]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:36.442]         }
[17:43:36.442]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:36.442]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:36.442]             base::sink(type = "output", split = FALSE)
[17:43:36.442]             base::close(...future.stdout)
[17:43:36.442]         }, add = TRUE)
[17:43:36.442]     }
[17:43:36.442]     ...future.frame <- base::sys.nframe()
[17:43:36.442]     ...future.conditions <- base::list()
[17:43:36.442]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:36.442]     if (FALSE) {
[17:43:36.442]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:36.442]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:36.442]     }
[17:43:36.442]     ...future.result <- base::tryCatch({
[17:43:36.442]         base::withCallingHandlers({
[17:43:36.442]             ...future.value <- base::withVisible(base::local({
[17:43:36.442]                 withCallingHandlers({
[17:43:36.442]                   {
[17:43:36.442]                     1
[17:43:36.442]                   }
[17:43:36.442]                 }, immediateCondition = function(cond) {
[17:43:36.442]                   save_rds <- function (object, pathname, ...) 
[17:43:36.442]                   {
[17:43:36.442]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:36.442]                     if (file_test("-f", pathname_tmp)) {
[17:43:36.442]                       fi_tmp <- file.info(pathname_tmp)
[17:43:36.442]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:36.442]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:36.442]                         fi_tmp[["mtime"]])
[17:43:36.442]                     }
[17:43:36.442]                     tryCatch({
[17:43:36.442]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:36.442]                     }, error = function(ex) {
[17:43:36.442]                       msg <- conditionMessage(ex)
[17:43:36.442]                       fi_tmp <- file.info(pathname_tmp)
[17:43:36.442]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:36.442]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:36.442]                         fi_tmp[["mtime"]], msg)
[17:43:36.442]                       ex$message <- msg
[17:43:36.442]                       stop(ex)
[17:43:36.442]                     })
[17:43:36.442]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:36.442]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:36.442]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:36.442]                       fi_tmp <- file.info(pathname_tmp)
[17:43:36.442]                       fi <- file.info(pathname)
[17:43:36.442]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:36.442]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:36.442]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:36.442]                         fi[["size"]], fi[["mtime"]])
[17:43:36.442]                       stop(msg)
[17:43:36.442]                     }
[17:43:36.442]                     invisible(pathname)
[17:43:36.442]                   }
[17:43:36.442]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:36.442]                     rootPath = tempdir()) 
[17:43:36.442]                   {
[17:43:36.442]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:36.442]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:36.442]                       tmpdir = path, fileext = ".rds")
[17:43:36.442]                     save_rds(obj, file)
[17:43:36.442]                   }
[17:43:36.442]                   saveImmediateCondition(cond, path = "/tmp/RtmpLaOb2h/.future/immediateConditions")
[17:43:36.442]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:36.442]                   {
[17:43:36.442]                     inherits <- base::inherits
[17:43:36.442]                     invokeRestart <- base::invokeRestart
[17:43:36.442]                     is.null <- base::is.null
[17:43:36.442]                     muffled <- FALSE
[17:43:36.442]                     if (inherits(cond, "message")) {
[17:43:36.442]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:36.442]                       if (muffled) 
[17:43:36.442]                         invokeRestart("muffleMessage")
[17:43:36.442]                     }
[17:43:36.442]                     else if (inherits(cond, "warning")) {
[17:43:36.442]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:36.442]                       if (muffled) 
[17:43:36.442]                         invokeRestart("muffleWarning")
[17:43:36.442]                     }
[17:43:36.442]                     else if (inherits(cond, "condition")) {
[17:43:36.442]                       if (!is.null(pattern)) {
[17:43:36.442]                         computeRestarts <- base::computeRestarts
[17:43:36.442]                         grepl <- base::grepl
[17:43:36.442]                         restarts <- computeRestarts(cond)
[17:43:36.442]                         for (restart in restarts) {
[17:43:36.442]                           name <- restart$name
[17:43:36.442]                           if (is.null(name)) 
[17:43:36.442]                             next
[17:43:36.442]                           if (!grepl(pattern, name)) 
[17:43:36.442]                             next
[17:43:36.442]                           invokeRestart(restart)
[17:43:36.442]                           muffled <- TRUE
[17:43:36.442]                           break
[17:43:36.442]                         }
[17:43:36.442]                       }
[17:43:36.442]                     }
[17:43:36.442]                     invisible(muffled)
[17:43:36.442]                   }
[17:43:36.442]                   muffleCondition(cond)
[17:43:36.442]                 })
[17:43:36.442]             }))
[17:43:36.442]             future::FutureResult(value = ...future.value$value, 
[17:43:36.442]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:36.442]                   ...future.rng), globalenv = if (FALSE) 
[17:43:36.442]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:36.442]                     ...future.globalenv.names))
[17:43:36.442]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:36.442]         }, condition = base::local({
[17:43:36.442]             c <- base::c
[17:43:36.442]             inherits <- base::inherits
[17:43:36.442]             invokeRestart <- base::invokeRestart
[17:43:36.442]             length <- base::length
[17:43:36.442]             list <- base::list
[17:43:36.442]             seq.int <- base::seq.int
[17:43:36.442]             signalCondition <- base::signalCondition
[17:43:36.442]             sys.calls <- base::sys.calls
[17:43:36.442]             `[[` <- base::`[[`
[17:43:36.442]             `+` <- base::`+`
[17:43:36.442]             `<<-` <- base::`<<-`
[17:43:36.442]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:36.442]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:36.442]                   3L)]
[17:43:36.442]             }
[17:43:36.442]             function(cond) {
[17:43:36.442]                 is_error <- inherits(cond, "error")
[17:43:36.442]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:36.442]                   NULL)
[17:43:36.442]                 if (is_error) {
[17:43:36.442]                   sessionInformation <- function() {
[17:43:36.442]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:36.442]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:36.442]                       search = base::search(), system = base::Sys.info())
[17:43:36.442]                   }
[17:43:36.442]                   ...future.conditions[[length(...future.conditions) + 
[17:43:36.442]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:36.442]                     cond$call), session = sessionInformation(), 
[17:43:36.442]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:36.442]                   signalCondition(cond)
[17:43:36.442]                 }
[17:43:36.442]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:36.442]                 "immediateCondition"))) {
[17:43:36.442]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:36.442]                   ...future.conditions[[length(...future.conditions) + 
[17:43:36.442]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:36.442]                   if (TRUE && !signal) {
[17:43:36.442]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:36.442]                     {
[17:43:36.442]                       inherits <- base::inherits
[17:43:36.442]                       invokeRestart <- base::invokeRestart
[17:43:36.442]                       is.null <- base::is.null
[17:43:36.442]                       muffled <- FALSE
[17:43:36.442]                       if (inherits(cond, "message")) {
[17:43:36.442]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:36.442]                         if (muffled) 
[17:43:36.442]                           invokeRestart("muffleMessage")
[17:43:36.442]                       }
[17:43:36.442]                       else if (inherits(cond, "warning")) {
[17:43:36.442]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:36.442]                         if (muffled) 
[17:43:36.442]                           invokeRestart("muffleWarning")
[17:43:36.442]                       }
[17:43:36.442]                       else if (inherits(cond, "condition")) {
[17:43:36.442]                         if (!is.null(pattern)) {
[17:43:36.442]                           computeRestarts <- base::computeRestarts
[17:43:36.442]                           grepl <- base::grepl
[17:43:36.442]                           restarts <- computeRestarts(cond)
[17:43:36.442]                           for (restart in restarts) {
[17:43:36.442]                             name <- restart$name
[17:43:36.442]                             if (is.null(name)) 
[17:43:36.442]                               next
[17:43:36.442]                             if (!grepl(pattern, name)) 
[17:43:36.442]                               next
[17:43:36.442]                             invokeRestart(restart)
[17:43:36.442]                             muffled <- TRUE
[17:43:36.442]                             break
[17:43:36.442]                           }
[17:43:36.442]                         }
[17:43:36.442]                       }
[17:43:36.442]                       invisible(muffled)
[17:43:36.442]                     }
[17:43:36.442]                     muffleCondition(cond, pattern = "^muffle")
[17:43:36.442]                   }
[17:43:36.442]                 }
[17:43:36.442]                 else {
[17:43:36.442]                   if (TRUE) {
[17:43:36.442]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:36.442]                     {
[17:43:36.442]                       inherits <- base::inherits
[17:43:36.442]                       invokeRestart <- base::invokeRestart
[17:43:36.442]                       is.null <- base::is.null
[17:43:36.442]                       muffled <- FALSE
[17:43:36.442]                       if (inherits(cond, "message")) {
[17:43:36.442]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:36.442]                         if (muffled) 
[17:43:36.442]                           invokeRestart("muffleMessage")
[17:43:36.442]                       }
[17:43:36.442]                       else if (inherits(cond, "warning")) {
[17:43:36.442]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:36.442]                         if (muffled) 
[17:43:36.442]                           invokeRestart("muffleWarning")
[17:43:36.442]                       }
[17:43:36.442]                       else if (inherits(cond, "condition")) {
[17:43:36.442]                         if (!is.null(pattern)) {
[17:43:36.442]                           computeRestarts <- base::computeRestarts
[17:43:36.442]                           grepl <- base::grepl
[17:43:36.442]                           restarts <- computeRestarts(cond)
[17:43:36.442]                           for (restart in restarts) {
[17:43:36.442]                             name <- restart$name
[17:43:36.442]                             if (is.null(name)) 
[17:43:36.442]                               next
[17:43:36.442]                             if (!grepl(pattern, name)) 
[17:43:36.442]                               next
[17:43:36.442]                             invokeRestart(restart)
[17:43:36.442]                             muffled <- TRUE
[17:43:36.442]                             break
[17:43:36.442]                           }
[17:43:36.442]                         }
[17:43:36.442]                       }
[17:43:36.442]                       invisible(muffled)
[17:43:36.442]                     }
[17:43:36.442]                     muffleCondition(cond, pattern = "^muffle")
[17:43:36.442]                   }
[17:43:36.442]                 }
[17:43:36.442]             }
[17:43:36.442]         }))
[17:43:36.442]     }, error = function(ex) {
[17:43:36.442]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:36.442]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:36.442]                 ...future.rng), started = ...future.startTime, 
[17:43:36.442]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:36.442]             version = "1.8"), class = "FutureResult")
[17:43:36.442]     }, finally = {
[17:43:36.442]         if (!identical(...future.workdir, getwd())) 
[17:43:36.442]             setwd(...future.workdir)
[17:43:36.442]         {
[17:43:36.442]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:36.442]                 ...future.oldOptions$nwarnings <- NULL
[17:43:36.442]             }
[17:43:36.442]             base::options(...future.oldOptions)
[17:43:36.442]             if (.Platform$OS.type == "windows") {
[17:43:36.442]                 old_names <- names(...future.oldEnvVars)
[17:43:36.442]                 envs <- base::Sys.getenv()
[17:43:36.442]                 names <- names(envs)
[17:43:36.442]                 common <- intersect(names, old_names)
[17:43:36.442]                 added <- setdiff(names, old_names)
[17:43:36.442]                 removed <- setdiff(old_names, names)
[17:43:36.442]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:36.442]                   envs[common]]
[17:43:36.442]                 NAMES <- toupper(changed)
[17:43:36.442]                 args <- list()
[17:43:36.442]                 for (kk in seq_along(NAMES)) {
[17:43:36.442]                   name <- changed[[kk]]
[17:43:36.442]                   NAME <- NAMES[[kk]]
[17:43:36.442]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:36.442]                     next
[17:43:36.442]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:36.442]                 }
[17:43:36.442]                 NAMES <- toupper(added)
[17:43:36.442]                 for (kk in seq_along(NAMES)) {
[17:43:36.442]                   name <- added[[kk]]
[17:43:36.442]                   NAME <- NAMES[[kk]]
[17:43:36.442]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:36.442]                     next
[17:43:36.442]                   args[[name]] <- ""
[17:43:36.442]                 }
[17:43:36.442]                 NAMES <- toupper(removed)
[17:43:36.442]                 for (kk in seq_along(NAMES)) {
[17:43:36.442]                   name <- removed[[kk]]
[17:43:36.442]                   NAME <- NAMES[[kk]]
[17:43:36.442]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:36.442]                     next
[17:43:36.442]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:36.442]                 }
[17:43:36.442]                 if (length(args) > 0) 
[17:43:36.442]                   base::do.call(base::Sys.setenv, args = args)
[17:43:36.442]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:36.442]             }
[17:43:36.442]             else {
[17:43:36.442]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:36.442]             }
[17:43:36.442]             {
[17:43:36.442]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:36.442]                   0L) {
[17:43:36.442]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:36.442]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:36.442]                   base::options(opts)
[17:43:36.442]                 }
[17:43:36.442]                 {
[17:43:36.442]                   {
[17:43:36.442]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:36.442]                     NULL
[17:43:36.442]                   }
[17:43:36.442]                   options(future.plan = NULL)
[17:43:36.442]                   if (is.na(NA_character_)) 
[17:43:36.442]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:36.442]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:36.442]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:43:36.442]                     envir = parent.frame()) 
[17:43:36.442]                   {
[17:43:36.442]                     default_workers <- missing(workers)
[17:43:36.442]                     if (is.function(workers)) 
[17:43:36.442]                       workers <- workers()
[17:43:36.442]                     workers <- structure(as.integer(workers), 
[17:43:36.442]                       class = class(workers))
[17:43:36.442]                     stop_if_not(is.finite(workers), workers >= 
[17:43:36.442]                       1L)
[17:43:36.442]                     if ((workers == 1L && !inherits(workers, 
[17:43:36.442]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:36.442]                       if (default_workers) 
[17:43:36.442]                         supportsMulticore(warn = TRUE)
[17:43:36.442]                       return(sequential(..., envir = envir))
[17:43:36.442]                     }
[17:43:36.442]                     oopts <- options(mc.cores = workers)
[17:43:36.442]                     on.exit(options(oopts))
[17:43:36.442]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:36.442]                       envir = envir)
[17:43:36.442]                     if (!future$lazy) 
[17:43:36.442]                       future <- run(future)
[17:43:36.442]                     invisible(future)
[17:43:36.442]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:36.442]                 }
[17:43:36.442]             }
[17:43:36.442]         }
[17:43:36.442]     })
[17:43:36.442]     if (TRUE) {
[17:43:36.442]         base::sink(type = "output", split = FALSE)
[17:43:36.442]         if (TRUE) {
[17:43:36.442]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:36.442]         }
[17:43:36.442]         else {
[17:43:36.442]             ...future.result["stdout"] <- base::list(NULL)
[17:43:36.442]         }
[17:43:36.442]         base::close(...future.stdout)
[17:43:36.442]         ...future.stdout <- NULL
[17:43:36.442]     }
[17:43:36.442]     ...future.result$conditions <- ...future.conditions
[17:43:36.442]     ...future.result$finished <- base::Sys.time()
[17:43:36.442]     ...future.result
[17:43:36.442] }
[17:43:36.445] requestCore(): workers = 2
[17:43:36.446] Poll #1 (0): usedCores() = 2, workers = 2
[17:43:36.459] MulticoreFuture started
[17:43:36.460] - Launch lazy future ... done
[17:43:36.460] run() for ‘MulticoreFuture’ ... done
[17:43:36.461] plan(): Setting new future strategy stack:
[17:43:36.462] getGlobalsAndPackages() ...
[17:43:36.461] List of future strategies:
[17:43:36.461] 1. sequential:
[17:43:36.461]    - args: function (..., envir = parent.frame())
[17:43:36.461]    - tweaked: FALSE
[17:43:36.461]    - call: NULL
[17:43:36.462] Searching for globals...
[17:43:36.462] plan(): nbrOfWorkers() = 1
[17:43:36.464] - globals found: [1] ‘{’
[17:43:36.464] Searching for globals ... DONE
[17:43:36.465] Resolving globals: FALSE
[17:43:36.465] plan(): Setting new future strategy stack:
[17:43:36.465] 
[17:43:36.466] 
[17:43:36.466] getGlobalsAndPackages() ... DONE
[17:43:36.465] List of future strategies:
[17:43:36.465] 1. multicore:
[17:43:36.465]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:36.465]    - tweaked: FALSE
[17:43:36.465]    - call: plan(strategy)
[17:43:36.467] run() for ‘Future’ ...
[17:43:36.467] - state: ‘created’
[17:43:36.467] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:36.471] plan(): nbrOfWorkers() = 2
[17:43:36.472] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:36.473] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:36.473]   - Field: ‘label’
[17:43:36.473]   - Field: ‘local’
[17:43:36.473]   - Field: ‘owner’
[17:43:36.473]   - Field: ‘envir’
[17:43:36.474]   - Field: ‘workers’
[17:43:36.474]   - Field: ‘packages’
[17:43:36.474]   - Field: ‘gc’
[17:43:36.474]   - Field: ‘job’
[17:43:36.474]   - Field: ‘conditions’
[17:43:36.474]   - Field: ‘expr’
[17:43:36.475]   - Field: ‘uuid’
[17:43:36.475]   - Field: ‘seed’
[17:43:36.475]   - Field: ‘version’
[17:43:36.475]   - Field: ‘result’
[17:43:36.475]   - Field: ‘asynchronous’
[17:43:36.475]   - Field: ‘calls’
[17:43:36.476]   - Field: ‘globals’
[17:43:36.476]   - Field: ‘stdout’
[17:43:36.476]   - Field: ‘earlySignal’
[17:43:36.476]   - Field: ‘lazy’
[17:43:36.476]   - Field: ‘state’
[17:43:36.476] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:36.476] - Launch lazy future ...
[17:43:36.477] Packages needed by the future expression (n = 0): <none>
[17:43:36.477] Packages needed by future strategies (n = 0): <none>
[17:43:36.478] {
[17:43:36.478]     {
[17:43:36.478]         {
[17:43:36.478]             ...future.startTime <- base::Sys.time()
[17:43:36.478]             {
[17:43:36.478]                 {
[17:43:36.478]                   {
[17:43:36.478]                     {
[17:43:36.478]                       base::local({
[17:43:36.478]                         has_future <- base::requireNamespace("future", 
[17:43:36.478]                           quietly = TRUE)
[17:43:36.478]                         if (has_future) {
[17:43:36.478]                           ns <- base::getNamespace("future")
[17:43:36.478]                           version <- ns[[".package"]][["version"]]
[17:43:36.478]                           if (is.null(version)) 
[17:43:36.478]                             version <- utils::packageVersion("future")
[17:43:36.478]                         }
[17:43:36.478]                         else {
[17:43:36.478]                           version <- NULL
[17:43:36.478]                         }
[17:43:36.478]                         if (!has_future || version < "1.8.0") {
[17:43:36.478]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:36.478]                             "", base::R.version$version.string), 
[17:43:36.478]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:36.478]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:36.478]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:36.478]                               "release", "version")], collapse = " "), 
[17:43:36.478]                             hostname = base::Sys.info()[["nodename"]])
[17:43:36.478]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:36.478]                             info)
[17:43:36.478]                           info <- base::paste(info, collapse = "; ")
[17:43:36.478]                           if (!has_future) {
[17:43:36.478]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:36.478]                               info)
[17:43:36.478]                           }
[17:43:36.478]                           else {
[17:43:36.478]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:36.478]                               info, version)
[17:43:36.478]                           }
[17:43:36.478]                           base::stop(msg)
[17:43:36.478]                         }
[17:43:36.478]                       })
[17:43:36.478]                     }
[17:43:36.478]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:36.478]                     base::options(mc.cores = 1L)
[17:43:36.478]                   }
[17:43:36.478]                   options(future.plan = NULL)
[17:43:36.478]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:36.478]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:36.478]                 }
[17:43:36.478]                 ...future.workdir <- getwd()
[17:43:36.478]             }
[17:43:36.478]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:36.478]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:36.478]         }
[17:43:36.478]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:36.478]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:36.478]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:36.478]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:36.478]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:36.478]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:36.478]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:36.478]             base::names(...future.oldOptions))
[17:43:36.478]     }
[17:43:36.478]     if (FALSE) {
[17:43:36.478]     }
[17:43:36.478]     else {
[17:43:36.478]         if (TRUE) {
[17:43:36.478]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:36.478]                 open = "w")
[17:43:36.478]         }
[17:43:36.478]         else {
[17:43:36.478]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:36.478]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:36.478]         }
[17:43:36.478]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:36.478]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:36.478]             base::sink(type = "output", split = FALSE)
[17:43:36.478]             base::close(...future.stdout)
[17:43:36.478]         }, add = TRUE)
[17:43:36.478]     }
[17:43:36.478]     ...future.frame <- base::sys.nframe()
[17:43:36.478]     ...future.conditions <- base::list()
[17:43:36.478]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:36.478]     if (FALSE) {
[17:43:36.478]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:36.478]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:36.478]     }
[17:43:36.478]     ...future.result <- base::tryCatch({
[17:43:36.478]         base::withCallingHandlers({
[17:43:36.478]             ...future.value <- base::withVisible(base::local({
[17:43:36.478]                 withCallingHandlers({
[17:43:36.478]                   {
[17:43:36.478]                     2
[17:43:36.478]                   }
[17:43:36.478]                 }, immediateCondition = function(cond) {
[17:43:36.478]                   save_rds <- function (object, pathname, ...) 
[17:43:36.478]                   {
[17:43:36.478]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:36.478]                     if (file_test("-f", pathname_tmp)) {
[17:43:36.478]                       fi_tmp <- file.info(pathname_tmp)
[17:43:36.478]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:36.478]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:36.478]                         fi_tmp[["mtime"]])
[17:43:36.478]                     }
[17:43:36.478]                     tryCatch({
[17:43:36.478]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:36.478]                     }, error = function(ex) {
[17:43:36.478]                       msg <- conditionMessage(ex)
[17:43:36.478]                       fi_tmp <- file.info(pathname_tmp)
[17:43:36.478]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:36.478]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:36.478]                         fi_tmp[["mtime"]], msg)
[17:43:36.478]                       ex$message <- msg
[17:43:36.478]                       stop(ex)
[17:43:36.478]                     })
[17:43:36.478]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:36.478]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:36.478]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:36.478]                       fi_tmp <- file.info(pathname_tmp)
[17:43:36.478]                       fi <- file.info(pathname)
[17:43:36.478]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:36.478]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:36.478]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:36.478]                         fi[["size"]], fi[["mtime"]])
[17:43:36.478]                       stop(msg)
[17:43:36.478]                     }
[17:43:36.478]                     invisible(pathname)
[17:43:36.478]                   }
[17:43:36.478]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:36.478]                     rootPath = tempdir()) 
[17:43:36.478]                   {
[17:43:36.478]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:36.478]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:36.478]                       tmpdir = path, fileext = ".rds")
[17:43:36.478]                     save_rds(obj, file)
[17:43:36.478]                   }
[17:43:36.478]                   saveImmediateCondition(cond, path = "/tmp/RtmpLaOb2h/.future/immediateConditions")
[17:43:36.478]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:36.478]                   {
[17:43:36.478]                     inherits <- base::inherits
[17:43:36.478]                     invokeRestart <- base::invokeRestart
[17:43:36.478]                     is.null <- base::is.null
[17:43:36.478]                     muffled <- FALSE
[17:43:36.478]                     if (inherits(cond, "message")) {
[17:43:36.478]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:36.478]                       if (muffled) 
[17:43:36.478]                         invokeRestart("muffleMessage")
[17:43:36.478]                     }
[17:43:36.478]                     else if (inherits(cond, "warning")) {
[17:43:36.478]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:36.478]                       if (muffled) 
[17:43:36.478]                         invokeRestart("muffleWarning")
[17:43:36.478]                     }
[17:43:36.478]                     else if (inherits(cond, "condition")) {
[17:43:36.478]                       if (!is.null(pattern)) {
[17:43:36.478]                         computeRestarts <- base::computeRestarts
[17:43:36.478]                         grepl <- base::grepl
[17:43:36.478]                         restarts <- computeRestarts(cond)
[17:43:36.478]                         for (restart in restarts) {
[17:43:36.478]                           name <- restart$name
[17:43:36.478]                           if (is.null(name)) 
[17:43:36.478]                             next
[17:43:36.478]                           if (!grepl(pattern, name)) 
[17:43:36.478]                             next
[17:43:36.478]                           invokeRestart(restart)
[17:43:36.478]                           muffled <- TRUE
[17:43:36.478]                           break
[17:43:36.478]                         }
[17:43:36.478]                       }
[17:43:36.478]                     }
[17:43:36.478]                     invisible(muffled)
[17:43:36.478]                   }
[17:43:36.478]                   muffleCondition(cond)
[17:43:36.478]                 })
[17:43:36.478]             }))
[17:43:36.478]             future::FutureResult(value = ...future.value$value, 
[17:43:36.478]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:36.478]                   ...future.rng), globalenv = if (FALSE) 
[17:43:36.478]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:36.478]                     ...future.globalenv.names))
[17:43:36.478]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:36.478]         }, condition = base::local({
[17:43:36.478]             c <- base::c
[17:43:36.478]             inherits <- base::inherits
[17:43:36.478]             invokeRestart <- base::invokeRestart
[17:43:36.478]             length <- base::length
[17:43:36.478]             list <- base::list
[17:43:36.478]             seq.int <- base::seq.int
[17:43:36.478]             signalCondition <- base::signalCondition
[17:43:36.478]             sys.calls <- base::sys.calls
[17:43:36.478]             `[[` <- base::`[[`
[17:43:36.478]             `+` <- base::`+`
[17:43:36.478]             `<<-` <- base::`<<-`
[17:43:36.478]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:36.478]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:36.478]                   3L)]
[17:43:36.478]             }
[17:43:36.478]             function(cond) {
[17:43:36.478]                 is_error <- inherits(cond, "error")
[17:43:36.478]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:36.478]                   NULL)
[17:43:36.478]                 if (is_error) {
[17:43:36.478]                   sessionInformation <- function() {
[17:43:36.478]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:36.478]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:36.478]                       search = base::search(), system = base::Sys.info())
[17:43:36.478]                   }
[17:43:36.478]                   ...future.conditions[[length(...future.conditions) + 
[17:43:36.478]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:36.478]                     cond$call), session = sessionInformation(), 
[17:43:36.478]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:36.478]                   signalCondition(cond)
[17:43:36.478]                 }
[17:43:36.478]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:36.478]                 "immediateCondition"))) {
[17:43:36.478]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:36.478]                   ...future.conditions[[length(...future.conditions) + 
[17:43:36.478]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:36.478]                   if (TRUE && !signal) {
[17:43:36.478]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:36.478]                     {
[17:43:36.478]                       inherits <- base::inherits
[17:43:36.478]                       invokeRestart <- base::invokeRestart
[17:43:36.478]                       is.null <- base::is.null
[17:43:36.478]                       muffled <- FALSE
[17:43:36.478]                       if (inherits(cond, "message")) {
[17:43:36.478]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:36.478]                         if (muffled) 
[17:43:36.478]                           invokeRestart("muffleMessage")
[17:43:36.478]                       }
[17:43:36.478]                       else if (inherits(cond, "warning")) {
[17:43:36.478]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:36.478]                         if (muffled) 
[17:43:36.478]                           invokeRestart("muffleWarning")
[17:43:36.478]                       }
[17:43:36.478]                       else if (inherits(cond, "condition")) {
[17:43:36.478]                         if (!is.null(pattern)) {
[17:43:36.478]                           computeRestarts <- base::computeRestarts
[17:43:36.478]                           grepl <- base::grepl
[17:43:36.478]                           restarts <- computeRestarts(cond)
[17:43:36.478]                           for (restart in restarts) {
[17:43:36.478]                             name <- restart$name
[17:43:36.478]                             if (is.null(name)) 
[17:43:36.478]                               next
[17:43:36.478]                             if (!grepl(pattern, name)) 
[17:43:36.478]                               next
[17:43:36.478]                             invokeRestart(restart)
[17:43:36.478]                             muffled <- TRUE
[17:43:36.478]                             break
[17:43:36.478]                           }
[17:43:36.478]                         }
[17:43:36.478]                       }
[17:43:36.478]                       invisible(muffled)
[17:43:36.478]                     }
[17:43:36.478]                     muffleCondition(cond, pattern = "^muffle")
[17:43:36.478]                   }
[17:43:36.478]                 }
[17:43:36.478]                 else {
[17:43:36.478]                   if (TRUE) {
[17:43:36.478]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:36.478]                     {
[17:43:36.478]                       inherits <- base::inherits
[17:43:36.478]                       invokeRestart <- base::invokeRestart
[17:43:36.478]                       is.null <- base::is.null
[17:43:36.478]                       muffled <- FALSE
[17:43:36.478]                       if (inherits(cond, "message")) {
[17:43:36.478]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:36.478]                         if (muffled) 
[17:43:36.478]                           invokeRestart("muffleMessage")
[17:43:36.478]                       }
[17:43:36.478]                       else if (inherits(cond, "warning")) {
[17:43:36.478]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:36.478]                         if (muffled) 
[17:43:36.478]                           invokeRestart("muffleWarning")
[17:43:36.478]                       }
[17:43:36.478]                       else if (inherits(cond, "condition")) {
[17:43:36.478]                         if (!is.null(pattern)) {
[17:43:36.478]                           computeRestarts <- base::computeRestarts
[17:43:36.478]                           grepl <- base::grepl
[17:43:36.478]                           restarts <- computeRestarts(cond)
[17:43:36.478]                           for (restart in restarts) {
[17:43:36.478]                             name <- restart$name
[17:43:36.478]                             if (is.null(name)) 
[17:43:36.478]                               next
[17:43:36.478]                             if (!grepl(pattern, name)) 
[17:43:36.478]                               next
[17:43:36.478]                             invokeRestart(restart)
[17:43:36.478]                             muffled <- TRUE
[17:43:36.478]                             break
[17:43:36.478]                           }
[17:43:36.478]                         }
[17:43:36.478]                       }
[17:43:36.478]                       invisible(muffled)
[17:43:36.478]                     }
[17:43:36.478]                     muffleCondition(cond, pattern = "^muffle")
[17:43:36.478]                   }
[17:43:36.478]                 }
[17:43:36.478]             }
[17:43:36.478]         }))
[17:43:36.478]     }, error = function(ex) {
[17:43:36.478]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:36.478]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:36.478]                 ...future.rng), started = ...future.startTime, 
[17:43:36.478]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:36.478]             version = "1.8"), class = "FutureResult")
[17:43:36.478]     }, finally = {
[17:43:36.478]         if (!identical(...future.workdir, getwd())) 
[17:43:36.478]             setwd(...future.workdir)
[17:43:36.478]         {
[17:43:36.478]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:36.478]                 ...future.oldOptions$nwarnings <- NULL
[17:43:36.478]             }
[17:43:36.478]             base::options(...future.oldOptions)
[17:43:36.478]             if (.Platform$OS.type == "windows") {
[17:43:36.478]                 old_names <- names(...future.oldEnvVars)
[17:43:36.478]                 envs <- base::Sys.getenv()
[17:43:36.478]                 names <- names(envs)
[17:43:36.478]                 common <- intersect(names, old_names)
[17:43:36.478]                 added <- setdiff(names, old_names)
[17:43:36.478]                 removed <- setdiff(old_names, names)
[17:43:36.478]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:36.478]                   envs[common]]
[17:43:36.478]                 NAMES <- toupper(changed)
[17:43:36.478]                 args <- list()
[17:43:36.478]                 for (kk in seq_along(NAMES)) {
[17:43:36.478]                   name <- changed[[kk]]
[17:43:36.478]                   NAME <- NAMES[[kk]]
[17:43:36.478]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:36.478]                     next
[17:43:36.478]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:36.478]                 }
[17:43:36.478]                 NAMES <- toupper(added)
[17:43:36.478]                 for (kk in seq_along(NAMES)) {
[17:43:36.478]                   name <- added[[kk]]
[17:43:36.478]                   NAME <- NAMES[[kk]]
[17:43:36.478]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:36.478]                     next
[17:43:36.478]                   args[[name]] <- ""
[17:43:36.478]                 }
[17:43:36.478]                 NAMES <- toupper(removed)
[17:43:36.478]                 for (kk in seq_along(NAMES)) {
[17:43:36.478]                   name <- removed[[kk]]
[17:43:36.478]                   NAME <- NAMES[[kk]]
[17:43:36.478]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:36.478]                     next
[17:43:36.478]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:36.478]                 }
[17:43:36.478]                 if (length(args) > 0) 
[17:43:36.478]                   base::do.call(base::Sys.setenv, args = args)
[17:43:36.478]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:36.478]             }
[17:43:36.478]             else {
[17:43:36.478]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:36.478]             }
[17:43:36.478]             {
[17:43:36.478]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:36.478]                   0L) {
[17:43:36.478]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:36.478]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:36.478]                   base::options(opts)
[17:43:36.478]                 }
[17:43:36.478]                 {
[17:43:36.478]                   {
[17:43:36.478]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:36.478]                     NULL
[17:43:36.478]                   }
[17:43:36.478]                   options(future.plan = NULL)
[17:43:36.478]                   if (is.na(NA_character_)) 
[17:43:36.478]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:36.478]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:36.478]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:43:36.478]                     envir = parent.frame()) 
[17:43:36.478]                   {
[17:43:36.478]                     default_workers <- missing(workers)
[17:43:36.478]                     if (is.function(workers)) 
[17:43:36.478]                       workers <- workers()
[17:43:36.478]                     workers <- structure(as.integer(workers), 
[17:43:36.478]                       class = class(workers))
[17:43:36.478]                     stop_if_not(is.finite(workers), workers >= 
[17:43:36.478]                       1L)
[17:43:36.478]                     if ((workers == 1L && !inherits(workers, 
[17:43:36.478]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:36.478]                       if (default_workers) 
[17:43:36.478]                         supportsMulticore(warn = TRUE)
[17:43:36.478]                       return(sequential(..., envir = envir))
[17:43:36.478]                     }
[17:43:36.478]                     oopts <- options(mc.cores = workers)
[17:43:36.478]                     on.exit(options(oopts))
[17:43:36.478]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:36.478]                       envir = envir)
[17:43:36.478]                     if (!future$lazy) 
[17:43:36.478]                       future <- run(future)
[17:43:36.478]                     invisible(future)
[17:43:36.478]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:36.478]                 }
[17:43:36.478]             }
[17:43:36.478]         }
[17:43:36.478]     })
[17:43:36.478]     if (TRUE) {
[17:43:36.478]         base::sink(type = "output", split = FALSE)
[17:43:36.478]         if (TRUE) {
[17:43:36.478]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:36.478]         }
[17:43:36.478]         else {
[17:43:36.478]             ...future.result["stdout"] <- base::list(NULL)
[17:43:36.478]         }
[17:43:36.478]         base::close(...future.stdout)
[17:43:36.478]         ...future.stdout <- NULL
[17:43:36.478]     }
[17:43:36.478]     ...future.result$conditions <- ...future.conditions
[17:43:36.478]     ...future.result$finished <- base::Sys.time()
[17:43:36.478]     ...future.result
[17:43:36.478] }
[17:43:36.482] requestCore(): workers = 2
[17:43:36.482] Poll #1 (0): usedCores() = 2, workers = 2
[17:43:36.496] MulticoreFuture started
[17:43:36.497] - Launch lazy future ... done
[17:43:36.497] run() for ‘MulticoreFuture’ ... done
[17:43:36.498] plan(): Setting new future strategy stack:
[17:43:36.498] List of future strategies:
[17:43:36.498] 1. sequential:
[17:43:36.498]    - args: function (..., envir = parent.frame())
[17:43:36.498]    - tweaked: FALSE
[17:43:36.498]    - call: NULL
[17:43:36.499] resolve() on list environment ...
[17:43:36.499]  recursive: 0
[17:43:36.499] plan(): nbrOfWorkers() = 1
[17:43:36.501]  length: 3
[17:43:36.501]  elements: ‘a’, ‘b’, ‘c’
[17:43:36.502] Future #1
[17:43:36.502]  length: 2 (resolved future 1)
[17:43:36.502] plan(): Setting new future strategy stack:
[17:43:36.502] List of future strategies:
[17:43:36.502] 1. multicore:
[17:43:36.502]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:36.502]    - tweaked: FALSE
[17:43:36.502]    - call: plan(strategy)
[17:43:36.508] plan(): nbrOfWorkers() = 2
[17:43:36.508] Future #2
[17:43:36.509]  length: 1 (resolved future 2)
[17:43:36.509]  length: 0 (resolved future 3)
[17:43:36.509] resolve() on list environment ... DONE
[17:43:36.510] getGlobalsAndPackages() ...
[17:43:36.510] Searching for globals...
[17:43:36.511] - globals found: [1] ‘{’
[17:43:36.512] Searching for globals ... DONE
[17:43:36.512] Resolving globals: FALSE
[17:43:36.512] 
[17:43:36.512] 
[17:43:36.513] getGlobalsAndPackages() ... DONE
[17:43:36.513] run() for ‘Future’ ...
[17:43:36.513] - state: ‘created’
[17:43:36.514] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:36.518] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:36.518] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:36.519]   - Field: ‘label’
[17:43:36.519]   - Field: ‘local’
[17:43:36.519]   - Field: ‘owner’
[17:43:36.519]   - Field: ‘envir’
[17:43:36.519]   - Field: ‘workers’
[17:43:36.519]   - Field: ‘packages’
[17:43:36.520]   - Field: ‘gc’
[17:43:36.520]   - Field: ‘job’
[17:43:36.520]   - Field: ‘conditions’
[17:43:36.520]   - Field: ‘expr’
[17:43:36.520]   - Field: ‘uuid’
[17:43:36.520]   - Field: ‘seed’
[17:43:36.520]   - Field: ‘version’
[17:43:36.525]   - Field: ‘result’
[17:43:36.525]   - Field: ‘asynchronous’
[17:43:36.526]   - Field: ‘calls’
[17:43:36.526]   - Field: ‘globals’
[17:43:36.526]   - Field: ‘stdout’
[17:43:36.526]   - Field: ‘earlySignal’
[17:43:36.527]   - Field: ‘lazy’
[17:43:36.527]   - Field: ‘state’
[17:43:36.527] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:36.528] - Launch lazy future ...
[17:43:36.528] Packages needed by the future expression (n = 0): <none>
[17:43:36.529] Packages needed by future strategies (n = 0): <none>
[17:43:36.529] {
[17:43:36.529]     {
[17:43:36.529]         {
[17:43:36.529]             ...future.startTime <- base::Sys.time()
[17:43:36.529]             {
[17:43:36.529]                 {
[17:43:36.529]                   {
[17:43:36.529]                     {
[17:43:36.529]                       base::local({
[17:43:36.529]                         has_future <- base::requireNamespace("future", 
[17:43:36.529]                           quietly = TRUE)
[17:43:36.529]                         if (has_future) {
[17:43:36.529]                           ns <- base::getNamespace("future")
[17:43:36.529]                           version <- ns[[".package"]][["version"]]
[17:43:36.529]                           if (is.null(version)) 
[17:43:36.529]                             version <- utils::packageVersion("future")
[17:43:36.529]                         }
[17:43:36.529]                         else {
[17:43:36.529]                           version <- NULL
[17:43:36.529]                         }
[17:43:36.529]                         if (!has_future || version < "1.8.0") {
[17:43:36.529]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:36.529]                             "", base::R.version$version.string), 
[17:43:36.529]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:36.529]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:36.529]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:36.529]                               "release", "version")], collapse = " "), 
[17:43:36.529]                             hostname = base::Sys.info()[["nodename"]])
[17:43:36.529]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:36.529]                             info)
[17:43:36.529]                           info <- base::paste(info, collapse = "; ")
[17:43:36.529]                           if (!has_future) {
[17:43:36.529]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:36.529]                               info)
[17:43:36.529]                           }
[17:43:36.529]                           else {
[17:43:36.529]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:36.529]                               info, version)
[17:43:36.529]                           }
[17:43:36.529]                           base::stop(msg)
[17:43:36.529]                         }
[17:43:36.529]                       })
[17:43:36.529]                     }
[17:43:36.529]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:36.529]                     base::options(mc.cores = 1L)
[17:43:36.529]                   }
[17:43:36.529]                   options(future.plan = NULL)
[17:43:36.529]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:36.529]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:36.529]                 }
[17:43:36.529]                 ...future.workdir <- getwd()
[17:43:36.529]             }
[17:43:36.529]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:36.529]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:36.529]         }
[17:43:36.529]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:36.529]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:36.529]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:36.529]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:36.529]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:36.529]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:36.529]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:36.529]             base::names(...future.oldOptions))
[17:43:36.529]     }
[17:43:36.529]     if (FALSE) {
[17:43:36.529]     }
[17:43:36.529]     else {
[17:43:36.529]         if (TRUE) {
[17:43:36.529]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:36.529]                 open = "w")
[17:43:36.529]         }
[17:43:36.529]         else {
[17:43:36.529]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:36.529]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:36.529]         }
[17:43:36.529]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:36.529]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:36.529]             base::sink(type = "output", split = FALSE)
[17:43:36.529]             base::close(...future.stdout)
[17:43:36.529]         }, add = TRUE)
[17:43:36.529]     }
[17:43:36.529]     ...future.frame <- base::sys.nframe()
[17:43:36.529]     ...future.conditions <- base::list()
[17:43:36.529]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:36.529]     if (FALSE) {
[17:43:36.529]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:36.529]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:36.529]     }
[17:43:36.529]     ...future.result <- base::tryCatch({
[17:43:36.529]         base::withCallingHandlers({
[17:43:36.529]             ...future.value <- base::withVisible(base::local({
[17:43:36.529]                 withCallingHandlers({
[17:43:36.529]                   {
[17:43:36.529]                     1
[17:43:36.529]                   }
[17:43:36.529]                 }, immediateCondition = function(cond) {
[17:43:36.529]                   save_rds <- function (object, pathname, ...) 
[17:43:36.529]                   {
[17:43:36.529]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:36.529]                     if (file_test("-f", pathname_tmp)) {
[17:43:36.529]                       fi_tmp <- file.info(pathname_tmp)
[17:43:36.529]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:36.529]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:36.529]                         fi_tmp[["mtime"]])
[17:43:36.529]                     }
[17:43:36.529]                     tryCatch({
[17:43:36.529]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:36.529]                     }, error = function(ex) {
[17:43:36.529]                       msg <- conditionMessage(ex)
[17:43:36.529]                       fi_tmp <- file.info(pathname_tmp)
[17:43:36.529]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:36.529]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:36.529]                         fi_tmp[["mtime"]], msg)
[17:43:36.529]                       ex$message <- msg
[17:43:36.529]                       stop(ex)
[17:43:36.529]                     })
[17:43:36.529]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:36.529]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:36.529]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:36.529]                       fi_tmp <- file.info(pathname_tmp)
[17:43:36.529]                       fi <- file.info(pathname)
[17:43:36.529]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:36.529]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:36.529]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:36.529]                         fi[["size"]], fi[["mtime"]])
[17:43:36.529]                       stop(msg)
[17:43:36.529]                     }
[17:43:36.529]                     invisible(pathname)
[17:43:36.529]                   }
[17:43:36.529]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:36.529]                     rootPath = tempdir()) 
[17:43:36.529]                   {
[17:43:36.529]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:36.529]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:36.529]                       tmpdir = path, fileext = ".rds")
[17:43:36.529]                     save_rds(obj, file)
[17:43:36.529]                   }
[17:43:36.529]                   saveImmediateCondition(cond, path = "/tmp/RtmpLaOb2h/.future/immediateConditions")
[17:43:36.529]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:36.529]                   {
[17:43:36.529]                     inherits <- base::inherits
[17:43:36.529]                     invokeRestart <- base::invokeRestart
[17:43:36.529]                     is.null <- base::is.null
[17:43:36.529]                     muffled <- FALSE
[17:43:36.529]                     if (inherits(cond, "message")) {
[17:43:36.529]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:36.529]                       if (muffled) 
[17:43:36.529]                         invokeRestart("muffleMessage")
[17:43:36.529]                     }
[17:43:36.529]                     else if (inherits(cond, "warning")) {
[17:43:36.529]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:36.529]                       if (muffled) 
[17:43:36.529]                         invokeRestart("muffleWarning")
[17:43:36.529]                     }
[17:43:36.529]                     else if (inherits(cond, "condition")) {
[17:43:36.529]                       if (!is.null(pattern)) {
[17:43:36.529]                         computeRestarts <- base::computeRestarts
[17:43:36.529]                         grepl <- base::grepl
[17:43:36.529]                         restarts <- computeRestarts(cond)
[17:43:36.529]                         for (restart in restarts) {
[17:43:36.529]                           name <- restart$name
[17:43:36.529]                           if (is.null(name)) 
[17:43:36.529]                             next
[17:43:36.529]                           if (!grepl(pattern, name)) 
[17:43:36.529]                             next
[17:43:36.529]                           invokeRestart(restart)
[17:43:36.529]                           muffled <- TRUE
[17:43:36.529]                           break
[17:43:36.529]                         }
[17:43:36.529]                       }
[17:43:36.529]                     }
[17:43:36.529]                     invisible(muffled)
[17:43:36.529]                   }
[17:43:36.529]                   muffleCondition(cond)
[17:43:36.529]                 })
[17:43:36.529]             }))
[17:43:36.529]             future::FutureResult(value = ...future.value$value, 
[17:43:36.529]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:36.529]                   ...future.rng), globalenv = if (FALSE) 
[17:43:36.529]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:36.529]                     ...future.globalenv.names))
[17:43:36.529]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:36.529]         }, condition = base::local({
[17:43:36.529]             c <- base::c
[17:43:36.529]             inherits <- base::inherits
[17:43:36.529]             invokeRestart <- base::invokeRestart
[17:43:36.529]             length <- base::length
[17:43:36.529]             list <- base::list
[17:43:36.529]             seq.int <- base::seq.int
[17:43:36.529]             signalCondition <- base::signalCondition
[17:43:36.529]             sys.calls <- base::sys.calls
[17:43:36.529]             `[[` <- base::`[[`
[17:43:36.529]             `+` <- base::`+`
[17:43:36.529]             `<<-` <- base::`<<-`
[17:43:36.529]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:36.529]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:36.529]                   3L)]
[17:43:36.529]             }
[17:43:36.529]             function(cond) {
[17:43:36.529]                 is_error <- inherits(cond, "error")
[17:43:36.529]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:36.529]                   NULL)
[17:43:36.529]                 if (is_error) {
[17:43:36.529]                   sessionInformation <- function() {
[17:43:36.529]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:36.529]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:36.529]                       search = base::search(), system = base::Sys.info())
[17:43:36.529]                   }
[17:43:36.529]                   ...future.conditions[[length(...future.conditions) + 
[17:43:36.529]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:36.529]                     cond$call), session = sessionInformation(), 
[17:43:36.529]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:36.529]                   signalCondition(cond)
[17:43:36.529]                 }
[17:43:36.529]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:36.529]                 "immediateCondition"))) {
[17:43:36.529]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:36.529]                   ...future.conditions[[length(...future.conditions) + 
[17:43:36.529]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:36.529]                   if (TRUE && !signal) {
[17:43:36.529]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:36.529]                     {
[17:43:36.529]                       inherits <- base::inherits
[17:43:36.529]                       invokeRestart <- base::invokeRestart
[17:43:36.529]                       is.null <- base::is.null
[17:43:36.529]                       muffled <- FALSE
[17:43:36.529]                       if (inherits(cond, "message")) {
[17:43:36.529]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:36.529]                         if (muffled) 
[17:43:36.529]                           invokeRestart("muffleMessage")
[17:43:36.529]                       }
[17:43:36.529]                       else if (inherits(cond, "warning")) {
[17:43:36.529]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:36.529]                         if (muffled) 
[17:43:36.529]                           invokeRestart("muffleWarning")
[17:43:36.529]                       }
[17:43:36.529]                       else if (inherits(cond, "condition")) {
[17:43:36.529]                         if (!is.null(pattern)) {
[17:43:36.529]                           computeRestarts <- base::computeRestarts
[17:43:36.529]                           grepl <- base::grepl
[17:43:36.529]                           restarts <- computeRestarts(cond)
[17:43:36.529]                           for (restart in restarts) {
[17:43:36.529]                             name <- restart$name
[17:43:36.529]                             if (is.null(name)) 
[17:43:36.529]                               next
[17:43:36.529]                             if (!grepl(pattern, name)) 
[17:43:36.529]                               next
[17:43:36.529]                             invokeRestart(restart)
[17:43:36.529]                             muffled <- TRUE
[17:43:36.529]                             break
[17:43:36.529]                           }
[17:43:36.529]                         }
[17:43:36.529]                       }
[17:43:36.529]                       invisible(muffled)
[17:43:36.529]                     }
[17:43:36.529]                     muffleCondition(cond, pattern = "^muffle")
[17:43:36.529]                   }
[17:43:36.529]                 }
[17:43:36.529]                 else {
[17:43:36.529]                   if (TRUE) {
[17:43:36.529]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:36.529]                     {
[17:43:36.529]                       inherits <- base::inherits
[17:43:36.529]                       invokeRestart <- base::invokeRestart
[17:43:36.529]                       is.null <- base::is.null
[17:43:36.529]                       muffled <- FALSE
[17:43:36.529]                       if (inherits(cond, "message")) {
[17:43:36.529]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:36.529]                         if (muffled) 
[17:43:36.529]                           invokeRestart("muffleMessage")
[17:43:36.529]                       }
[17:43:36.529]                       else if (inherits(cond, "warning")) {
[17:43:36.529]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:36.529]                         if (muffled) 
[17:43:36.529]                           invokeRestart("muffleWarning")
[17:43:36.529]                       }
[17:43:36.529]                       else if (inherits(cond, "condition")) {
[17:43:36.529]                         if (!is.null(pattern)) {
[17:43:36.529]                           computeRestarts <- base::computeRestarts
[17:43:36.529]                           grepl <- base::grepl
[17:43:36.529]                           restarts <- computeRestarts(cond)
[17:43:36.529]                           for (restart in restarts) {
[17:43:36.529]                             name <- restart$name
[17:43:36.529]                             if (is.null(name)) 
[17:43:36.529]                               next
[17:43:36.529]                             if (!grepl(pattern, name)) 
[17:43:36.529]                               next
[17:43:36.529]                             invokeRestart(restart)
[17:43:36.529]                             muffled <- TRUE
[17:43:36.529]                             break
[17:43:36.529]                           }
[17:43:36.529]                         }
[17:43:36.529]                       }
[17:43:36.529]                       invisible(muffled)
[17:43:36.529]                     }
[17:43:36.529]                     muffleCondition(cond, pattern = "^muffle")
[17:43:36.529]                   }
[17:43:36.529]                 }
[17:43:36.529]             }
[17:43:36.529]         }))
[17:43:36.529]     }, error = function(ex) {
[17:43:36.529]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:36.529]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:36.529]                 ...future.rng), started = ...future.startTime, 
[17:43:36.529]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:36.529]             version = "1.8"), class = "FutureResult")
[17:43:36.529]     }, finally = {
[17:43:36.529]         if (!identical(...future.workdir, getwd())) 
[17:43:36.529]             setwd(...future.workdir)
[17:43:36.529]         {
[17:43:36.529]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:36.529]                 ...future.oldOptions$nwarnings <- NULL
[17:43:36.529]             }
[17:43:36.529]             base::options(...future.oldOptions)
[17:43:36.529]             if (.Platform$OS.type == "windows") {
[17:43:36.529]                 old_names <- names(...future.oldEnvVars)
[17:43:36.529]                 envs <- base::Sys.getenv()
[17:43:36.529]                 names <- names(envs)
[17:43:36.529]                 common <- intersect(names, old_names)
[17:43:36.529]                 added <- setdiff(names, old_names)
[17:43:36.529]                 removed <- setdiff(old_names, names)
[17:43:36.529]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:36.529]                   envs[common]]
[17:43:36.529]                 NAMES <- toupper(changed)
[17:43:36.529]                 args <- list()
[17:43:36.529]                 for (kk in seq_along(NAMES)) {
[17:43:36.529]                   name <- changed[[kk]]
[17:43:36.529]                   NAME <- NAMES[[kk]]
[17:43:36.529]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:36.529]                     next
[17:43:36.529]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:36.529]                 }
[17:43:36.529]                 NAMES <- toupper(added)
[17:43:36.529]                 for (kk in seq_along(NAMES)) {
[17:43:36.529]                   name <- added[[kk]]
[17:43:36.529]                   NAME <- NAMES[[kk]]
[17:43:36.529]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:36.529]                     next
[17:43:36.529]                   args[[name]] <- ""
[17:43:36.529]                 }
[17:43:36.529]                 NAMES <- toupper(removed)
[17:43:36.529]                 for (kk in seq_along(NAMES)) {
[17:43:36.529]                   name <- removed[[kk]]
[17:43:36.529]                   NAME <- NAMES[[kk]]
[17:43:36.529]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:36.529]                     next
[17:43:36.529]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:36.529]                 }
[17:43:36.529]                 if (length(args) > 0) 
[17:43:36.529]                   base::do.call(base::Sys.setenv, args = args)
[17:43:36.529]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:36.529]             }
[17:43:36.529]             else {
[17:43:36.529]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:36.529]             }
[17:43:36.529]             {
[17:43:36.529]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:36.529]                   0L) {
[17:43:36.529]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:36.529]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:36.529]                   base::options(opts)
[17:43:36.529]                 }
[17:43:36.529]                 {
[17:43:36.529]                   {
[17:43:36.529]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:36.529]                     NULL
[17:43:36.529]                   }
[17:43:36.529]                   options(future.plan = NULL)
[17:43:36.529]                   if (is.na(NA_character_)) 
[17:43:36.529]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:36.529]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:36.529]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:43:36.529]                     envir = parent.frame()) 
[17:43:36.529]                   {
[17:43:36.529]                     default_workers <- missing(workers)
[17:43:36.529]                     if (is.function(workers)) 
[17:43:36.529]                       workers <- workers()
[17:43:36.529]                     workers <- structure(as.integer(workers), 
[17:43:36.529]                       class = class(workers))
[17:43:36.529]                     stop_if_not(is.finite(workers), workers >= 
[17:43:36.529]                       1L)
[17:43:36.529]                     if ((workers == 1L && !inherits(workers, 
[17:43:36.529]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:36.529]                       if (default_workers) 
[17:43:36.529]                         supportsMulticore(warn = TRUE)
[17:43:36.529]                       return(sequential(..., envir = envir))
[17:43:36.529]                     }
[17:43:36.529]                     oopts <- options(mc.cores = workers)
[17:43:36.529]                     on.exit(options(oopts))
[17:43:36.529]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:36.529]                       envir = envir)
[17:43:36.529]                     if (!future$lazy) 
[17:43:36.529]                       future <- run(future)
[17:43:36.529]                     invisible(future)
[17:43:36.529]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:36.529]                 }
[17:43:36.529]             }
[17:43:36.529]         }
[17:43:36.529]     })
[17:43:36.529]     if (TRUE) {
[17:43:36.529]         base::sink(type = "output", split = FALSE)
[17:43:36.529]         if (TRUE) {
[17:43:36.529]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:36.529]         }
[17:43:36.529]         else {
[17:43:36.529]             ...future.result["stdout"] <- base::list(NULL)
[17:43:36.529]         }
[17:43:36.529]         base::close(...future.stdout)
[17:43:36.529]         ...future.stdout <- NULL
[17:43:36.529]     }
[17:43:36.529]     ...future.result$conditions <- ...future.conditions
[17:43:36.529]     ...future.result$finished <- base::Sys.time()
[17:43:36.529]     ...future.result
[17:43:36.529] }
[17:43:36.532] requestCore(): workers = 2
[17:43:36.533] Poll #1 (0): usedCores() = 2, workers = 2
[17:43:36.548] MulticoreFuture started
[17:43:36.548] - Launch lazy future ... done
[17:43:36.549] run() for ‘MulticoreFuture’ ... done
[17:43:36.549] plan(): Setting new future strategy stack:
[17:43:36.550] getGlobalsAndPackages() ...
[17:43:36.549] List of future strategies:
[17:43:36.549] 1. sequential:
[17:43:36.549]    - args: function (..., envir = parent.frame())
[17:43:36.549]    - tweaked: FALSE
[17:43:36.549]    - call: NULL
[17:43:36.550] Searching for globals...
[17:43:36.550] plan(): nbrOfWorkers() = 1
[17:43:36.552] plan(): Setting new future strategy stack:
[17:43:36.553] - globals found: [2] ‘{’, ‘Sys.sleep’
[17:43:36.553] Searching for globals ... DONE
[17:43:36.553] List of future strategies:
[17:43:36.553] 1. multicore:
[17:43:36.553]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:36.553]    - tweaked: FALSE
[17:43:36.553]    - call: plan(strategy)
[17:43:36.554] Resolving globals: FALSE
[17:43:36.554] 
[17:43:36.554] 
[17:43:36.555] getGlobalsAndPackages() ... DONE
[17:43:36.555] run() for ‘Future’ ...
[17:43:36.555] - state: ‘created’
[17:43:36.556] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:36.558] plan(): nbrOfWorkers() = 2
[17:43:36.561] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:36.561] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:36.561]   - Field: ‘label’
[17:43:36.561]   - Field: ‘local’
[17:43:36.561]   - Field: ‘owner’
[17:43:36.561]   - Field: ‘envir’
[17:43:36.562]   - Field: ‘workers’
[17:43:36.562]   - Field: ‘packages’
[17:43:36.562]   - Field: ‘gc’
[17:43:36.562]   - Field: ‘job’
[17:43:36.562]   - Field: ‘conditions’
[17:43:36.562]   - Field: ‘expr’
[17:43:36.563]   - Field: ‘uuid’
[17:43:36.563]   - Field: ‘seed’
[17:43:36.563]   - Field: ‘version’
[17:43:36.563]   - Field: ‘result’
[17:43:36.563]   - Field: ‘asynchronous’
[17:43:36.563]   - Field: ‘calls’
[17:43:36.563]   - Field: ‘globals’
[17:43:36.564]   - Field: ‘stdout’
[17:43:36.564]   - Field: ‘earlySignal’
[17:43:36.564]   - Field: ‘lazy’
[17:43:36.564]   - Field: ‘state’
[17:43:36.564] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:36.564] - Launch lazy future ...
[17:43:36.565] Packages needed by the future expression (n = 0): <none>
[17:43:36.565] Packages needed by future strategies (n = 0): <none>
[17:43:36.566] {
[17:43:36.566]     {
[17:43:36.566]         {
[17:43:36.566]             ...future.startTime <- base::Sys.time()
[17:43:36.566]             {
[17:43:36.566]                 {
[17:43:36.566]                   {
[17:43:36.566]                     {
[17:43:36.566]                       base::local({
[17:43:36.566]                         has_future <- base::requireNamespace("future", 
[17:43:36.566]                           quietly = TRUE)
[17:43:36.566]                         if (has_future) {
[17:43:36.566]                           ns <- base::getNamespace("future")
[17:43:36.566]                           version <- ns[[".package"]][["version"]]
[17:43:36.566]                           if (is.null(version)) 
[17:43:36.566]                             version <- utils::packageVersion("future")
[17:43:36.566]                         }
[17:43:36.566]                         else {
[17:43:36.566]                           version <- NULL
[17:43:36.566]                         }
[17:43:36.566]                         if (!has_future || version < "1.8.0") {
[17:43:36.566]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:36.566]                             "", base::R.version$version.string), 
[17:43:36.566]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:36.566]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:36.566]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:36.566]                               "release", "version")], collapse = " "), 
[17:43:36.566]                             hostname = base::Sys.info()[["nodename"]])
[17:43:36.566]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:36.566]                             info)
[17:43:36.566]                           info <- base::paste(info, collapse = "; ")
[17:43:36.566]                           if (!has_future) {
[17:43:36.566]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:36.566]                               info)
[17:43:36.566]                           }
[17:43:36.566]                           else {
[17:43:36.566]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:36.566]                               info, version)
[17:43:36.566]                           }
[17:43:36.566]                           base::stop(msg)
[17:43:36.566]                         }
[17:43:36.566]                       })
[17:43:36.566]                     }
[17:43:36.566]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:36.566]                     base::options(mc.cores = 1L)
[17:43:36.566]                   }
[17:43:36.566]                   options(future.plan = NULL)
[17:43:36.566]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:36.566]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:36.566]                 }
[17:43:36.566]                 ...future.workdir <- getwd()
[17:43:36.566]             }
[17:43:36.566]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:36.566]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:36.566]         }
[17:43:36.566]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:36.566]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:36.566]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:36.566]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:36.566]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:36.566]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:36.566]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:36.566]             base::names(...future.oldOptions))
[17:43:36.566]     }
[17:43:36.566]     if (FALSE) {
[17:43:36.566]     }
[17:43:36.566]     else {
[17:43:36.566]         if (TRUE) {
[17:43:36.566]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:36.566]                 open = "w")
[17:43:36.566]         }
[17:43:36.566]         else {
[17:43:36.566]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:36.566]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:36.566]         }
[17:43:36.566]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:36.566]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:36.566]             base::sink(type = "output", split = FALSE)
[17:43:36.566]             base::close(...future.stdout)
[17:43:36.566]         }, add = TRUE)
[17:43:36.566]     }
[17:43:36.566]     ...future.frame <- base::sys.nframe()
[17:43:36.566]     ...future.conditions <- base::list()
[17:43:36.566]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:36.566]     if (FALSE) {
[17:43:36.566]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:36.566]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:36.566]     }
[17:43:36.566]     ...future.result <- base::tryCatch({
[17:43:36.566]         base::withCallingHandlers({
[17:43:36.566]             ...future.value <- base::withVisible(base::local({
[17:43:36.566]                 withCallingHandlers({
[17:43:36.566]                   {
[17:43:36.566]                     Sys.sleep(0.5)
[17:43:36.566]                     2
[17:43:36.566]                   }
[17:43:36.566]                 }, immediateCondition = function(cond) {
[17:43:36.566]                   save_rds <- function (object, pathname, ...) 
[17:43:36.566]                   {
[17:43:36.566]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:36.566]                     if (file_test("-f", pathname_tmp)) {
[17:43:36.566]                       fi_tmp <- file.info(pathname_tmp)
[17:43:36.566]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:36.566]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:36.566]                         fi_tmp[["mtime"]])
[17:43:36.566]                     }
[17:43:36.566]                     tryCatch({
[17:43:36.566]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:36.566]                     }, error = function(ex) {
[17:43:36.566]                       msg <- conditionMessage(ex)
[17:43:36.566]                       fi_tmp <- file.info(pathname_tmp)
[17:43:36.566]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:36.566]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:36.566]                         fi_tmp[["mtime"]], msg)
[17:43:36.566]                       ex$message <- msg
[17:43:36.566]                       stop(ex)
[17:43:36.566]                     })
[17:43:36.566]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:36.566]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:36.566]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:36.566]                       fi_tmp <- file.info(pathname_tmp)
[17:43:36.566]                       fi <- file.info(pathname)
[17:43:36.566]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:36.566]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:36.566]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:36.566]                         fi[["size"]], fi[["mtime"]])
[17:43:36.566]                       stop(msg)
[17:43:36.566]                     }
[17:43:36.566]                     invisible(pathname)
[17:43:36.566]                   }
[17:43:36.566]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:36.566]                     rootPath = tempdir()) 
[17:43:36.566]                   {
[17:43:36.566]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:36.566]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:36.566]                       tmpdir = path, fileext = ".rds")
[17:43:36.566]                     save_rds(obj, file)
[17:43:36.566]                   }
[17:43:36.566]                   saveImmediateCondition(cond, path = "/tmp/RtmpLaOb2h/.future/immediateConditions")
[17:43:36.566]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:36.566]                   {
[17:43:36.566]                     inherits <- base::inherits
[17:43:36.566]                     invokeRestart <- base::invokeRestart
[17:43:36.566]                     is.null <- base::is.null
[17:43:36.566]                     muffled <- FALSE
[17:43:36.566]                     if (inherits(cond, "message")) {
[17:43:36.566]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:36.566]                       if (muffled) 
[17:43:36.566]                         invokeRestart("muffleMessage")
[17:43:36.566]                     }
[17:43:36.566]                     else if (inherits(cond, "warning")) {
[17:43:36.566]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:36.566]                       if (muffled) 
[17:43:36.566]                         invokeRestart("muffleWarning")
[17:43:36.566]                     }
[17:43:36.566]                     else if (inherits(cond, "condition")) {
[17:43:36.566]                       if (!is.null(pattern)) {
[17:43:36.566]                         computeRestarts <- base::computeRestarts
[17:43:36.566]                         grepl <- base::grepl
[17:43:36.566]                         restarts <- computeRestarts(cond)
[17:43:36.566]                         for (restart in restarts) {
[17:43:36.566]                           name <- restart$name
[17:43:36.566]                           if (is.null(name)) 
[17:43:36.566]                             next
[17:43:36.566]                           if (!grepl(pattern, name)) 
[17:43:36.566]                             next
[17:43:36.566]                           invokeRestart(restart)
[17:43:36.566]                           muffled <- TRUE
[17:43:36.566]                           break
[17:43:36.566]                         }
[17:43:36.566]                       }
[17:43:36.566]                     }
[17:43:36.566]                     invisible(muffled)
[17:43:36.566]                   }
[17:43:36.566]                   muffleCondition(cond)
[17:43:36.566]                 })
[17:43:36.566]             }))
[17:43:36.566]             future::FutureResult(value = ...future.value$value, 
[17:43:36.566]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:36.566]                   ...future.rng), globalenv = if (FALSE) 
[17:43:36.566]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:36.566]                     ...future.globalenv.names))
[17:43:36.566]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:36.566]         }, condition = base::local({
[17:43:36.566]             c <- base::c
[17:43:36.566]             inherits <- base::inherits
[17:43:36.566]             invokeRestart <- base::invokeRestart
[17:43:36.566]             length <- base::length
[17:43:36.566]             list <- base::list
[17:43:36.566]             seq.int <- base::seq.int
[17:43:36.566]             signalCondition <- base::signalCondition
[17:43:36.566]             sys.calls <- base::sys.calls
[17:43:36.566]             `[[` <- base::`[[`
[17:43:36.566]             `+` <- base::`+`
[17:43:36.566]             `<<-` <- base::`<<-`
[17:43:36.566]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:36.566]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:36.566]                   3L)]
[17:43:36.566]             }
[17:43:36.566]             function(cond) {
[17:43:36.566]                 is_error <- inherits(cond, "error")
[17:43:36.566]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:36.566]                   NULL)
[17:43:36.566]                 if (is_error) {
[17:43:36.566]                   sessionInformation <- function() {
[17:43:36.566]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:36.566]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:36.566]                       search = base::search(), system = base::Sys.info())
[17:43:36.566]                   }
[17:43:36.566]                   ...future.conditions[[length(...future.conditions) + 
[17:43:36.566]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:36.566]                     cond$call), session = sessionInformation(), 
[17:43:36.566]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:36.566]                   signalCondition(cond)
[17:43:36.566]                 }
[17:43:36.566]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:36.566]                 "immediateCondition"))) {
[17:43:36.566]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:36.566]                   ...future.conditions[[length(...future.conditions) + 
[17:43:36.566]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:36.566]                   if (TRUE && !signal) {
[17:43:36.566]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:36.566]                     {
[17:43:36.566]                       inherits <- base::inherits
[17:43:36.566]                       invokeRestart <- base::invokeRestart
[17:43:36.566]                       is.null <- base::is.null
[17:43:36.566]                       muffled <- FALSE
[17:43:36.566]                       if (inherits(cond, "message")) {
[17:43:36.566]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:36.566]                         if (muffled) 
[17:43:36.566]                           invokeRestart("muffleMessage")
[17:43:36.566]                       }
[17:43:36.566]                       else if (inherits(cond, "warning")) {
[17:43:36.566]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:36.566]                         if (muffled) 
[17:43:36.566]                           invokeRestart("muffleWarning")
[17:43:36.566]                       }
[17:43:36.566]                       else if (inherits(cond, "condition")) {
[17:43:36.566]                         if (!is.null(pattern)) {
[17:43:36.566]                           computeRestarts <- base::computeRestarts
[17:43:36.566]                           grepl <- base::grepl
[17:43:36.566]                           restarts <- computeRestarts(cond)
[17:43:36.566]                           for (restart in restarts) {
[17:43:36.566]                             name <- restart$name
[17:43:36.566]                             if (is.null(name)) 
[17:43:36.566]                               next
[17:43:36.566]                             if (!grepl(pattern, name)) 
[17:43:36.566]                               next
[17:43:36.566]                             invokeRestart(restart)
[17:43:36.566]                             muffled <- TRUE
[17:43:36.566]                             break
[17:43:36.566]                           }
[17:43:36.566]                         }
[17:43:36.566]                       }
[17:43:36.566]                       invisible(muffled)
[17:43:36.566]                     }
[17:43:36.566]                     muffleCondition(cond, pattern = "^muffle")
[17:43:36.566]                   }
[17:43:36.566]                 }
[17:43:36.566]                 else {
[17:43:36.566]                   if (TRUE) {
[17:43:36.566]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:36.566]                     {
[17:43:36.566]                       inherits <- base::inherits
[17:43:36.566]                       invokeRestart <- base::invokeRestart
[17:43:36.566]                       is.null <- base::is.null
[17:43:36.566]                       muffled <- FALSE
[17:43:36.566]                       if (inherits(cond, "message")) {
[17:43:36.566]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:36.566]                         if (muffled) 
[17:43:36.566]                           invokeRestart("muffleMessage")
[17:43:36.566]                       }
[17:43:36.566]                       else if (inherits(cond, "warning")) {
[17:43:36.566]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:36.566]                         if (muffled) 
[17:43:36.566]                           invokeRestart("muffleWarning")
[17:43:36.566]                       }
[17:43:36.566]                       else if (inherits(cond, "condition")) {
[17:43:36.566]                         if (!is.null(pattern)) {
[17:43:36.566]                           computeRestarts <- base::computeRestarts
[17:43:36.566]                           grepl <- base::grepl
[17:43:36.566]                           restarts <- computeRestarts(cond)
[17:43:36.566]                           for (restart in restarts) {
[17:43:36.566]                             name <- restart$name
[17:43:36.566]                             if (is.null(name)) 
[17:43:36.566]                               next
[17:43:36.566]                             if (!grepl(pattern, name)) 
[17:43:36.566]                               next
[17:43:36.566]                             invokeRestart(restart)
[17:43:36.566]                             muffled <- TRUE
[17:43:36.566]                             break
[17:43:36.566]                           }
[17:43:36.566]                         }
[17:43:36.566]                       }
[17:43:36.566]                       invisible(muffled)
[17:43:36.566]                     }
[17:43:36.566]                     muffleCondition(cond, pattern = "^muffle")
[17:43:36.566]                   }
[17:43:36.566]                 }
[17:43:36.566]             }
[17:43:36.566]         }))
[17:43:36.566]     }, error = function(ex) {
[17:43:36.566]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:36.566]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:36.566]                 ...future.rng), started = ...future.startTime, 
[17:43:36.566]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:36.566]             version = "1.8"), class = "FutureResult")
[17:43:36.566]     }, finally = {
[17:43:36.566]         if (!identical(...future.workdir, getwd())) 
[17:43:36.566]             setwd(...future.workdir)
[17:43:36.566]         {
[17:43:36.566]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:36.566]                 ...future.oldOptions$nwarnings <- NULL
[17:43:36.566]             }
[17:43:36.566]             base::options(...future.oldOptions)
[17:43:36.566]             if (.Platform$OS.type == "windows") {
[17:43:36.566]                 old_names <- names(...future.oldEnvVars)
[17:43:36.566]                 envs <- base::Sys.getenv()
[17:43:36.566]                 names <- names(envs)
[17:43:36.566]                 common <- intersect(names, old_names)
[17:43:36.566]                 added <- setdiff(names, old_names)
[17:43:36.566]                 removed <- setdiff(old_names, names)
[17:43:36.566]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:36.566]                   envs[common]]
[17:43:36.566]                 NAMES <- toupper(changed)
[17:43:36.566]                 args <- list()
[17:43:36.566]                 for (kk in seq_along(NAMES)) {
[17:43:36.566]                   name <- changed[[kk]]
[17:43:36.566]                   NAME <- NAMES[[kk]]
[17:43:36.566]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:36.566]                     next
[17:43:36.566]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:36.566]                 }
[17:43:36.566]                 NAMES <- toupper(added)
[17:43:36.566]                 for (kk in seq_along(NAMES)) {
[17:43:36.566]                   name <- added[[kk]]
[17:43:36.566]                   NAME <- NAMES[[kk]]
[17:43:36.566]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:36.566]                     next
[17:43:36.566]                   args[[name]] <- ""
[17:43:36.566]                 }
[17:43:36.566]                 NAMES <- toupper(removed)
[17:43:36.566]                 for (kk in seq_along(NAMES)) {
[17:43:36.566]                   name <- removed[[kk]]
[17:43:36.566]                   NAME <- NAMES[[kk]]
[17:43:36.566]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:36.566]                     next
[17:43:36.566]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:36.566]                 }
[17:43:36.566]                 if (length(args) > 0) 
[17:43:36.566]                   base::do.call(base::Sys.setenv, args = args)
[17:43:36.566]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:36.566]             }
[17:43:36.566]             else {
[17:43:36.566]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:36.566]             }
[17:43:36.566]             {
[17:43:36.566]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:36.566]                   0L) {
[17:43:36.566]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:36.566]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:36.566]                   base::options(opts)
[17:43:36.566]                 }
[17:43:36.566]                 {
[17:43:36.566]                   {
[17:43:36.566]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:36.566]                     NULL
[17:43:36.566]                   }
[17:43:36.566]                   options(future.plan = NULL)
[17:43:36.566]                   if (is.na(NA_character_)) 
[17:43:36.566]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:36.566]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:36.566]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:43:36.566]                     envir = parent.frame()) 
[17:43:36.566]                   {
[17:43:36.566]                     default_workers <- missing(workers)
[17:43:36.566]                     if (is.function(workers)) 
[17:43:36.566]                       workers <- workers()
[17:43:36.566]                     workers <- structure(as.integer(workers), 
[17:43:36.566]                       class = class(workers))
[17:43:36.566]                     stop_if_not(is.finite(workers), workers >= 
[17:43:36.566]                       1L)
[17:43:36.566]                     if ((workers == 1L && !inherits(workers, 
[17:43:36.566]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:36.566]                       if (default_workers) 
[17:43:36.566]                         supportsMulticore(warn = TRUE)
[17:43:36.566]                       return(sequential(..., envir = envir))
[17:43:36.566]                     }
[17:43:36.566]                     oopts <- options(mc.cores = workers)
[17:43:36.566]                     on.exit(options(oopts))
[17:43:36.566]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:36.566]                       envir = envir)
[17:43:36.566]                     if (!future$lazy) 
[17:43:36.566]                       future <- run(future)
[17:43:36.566]                     invisible(future)
[17:43:36.566]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:36.566]                 }
[17:43:36.566]             }
[17:43:36.566]         }
[17:43:36.566]     })
[17:43:36.566]     if (TRUE) {
[17:43:36.566]         base::sink(type = "output", split = FALSE)
[17:43:36.566]         if (TRUE) {
[17:43:36.566]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:36.566]         }
[17:43:36.566]         else {
[17:43:36.566]             ...future.result["stdout"] <- base::list(NULL)
[17:43:36.566]         }
[17:43:36.566]         base::close(...future.stdout)
[17:43:36.566]         ...future.stdout <- NULL
[17:43:36.566]     }
[17:43:36.566]     ...future.result$conditions <- ...future.conditions
[17:43:36.566]     ...future.result$finished <- base::Sys.time()
[17:43:36.566]     ...future.result
[17:43:36.566] }
[17:43:36.570] requestCore(): workers = 2
[17:43:36.570] Poll #1 (0): usedCores() = 2, workers = 2
[17:43:36.585] MulticoreFuture started
[17:43:36.585] - Launch lazy future ... done
[17:43:36.586] run() for ‘MulticoreFuture’ ... done
[17:43:36.586] plan(): Setting new future strategy stack:
[17:43:36.587] getGlobalsAndPackages() ...
[17:43:36.587] Searching for globals...
[17:43:36.587] List of future strategies:
[17:43:36.587] 1. sequential:
[17:43:36.587]    - args: function (..., envir = parent.frame())
[17:43:36.587]    - tweaked: FALSE
[17:43:36.587]    - call: NULL
[17:43:36.588] plan(): nbrOfWorkers() = 1
[17:43:36.589] - globals found: [1] ‘{’
[17:43:36.590] Searching for globals ... DONE
[17:43:36.590] Resolving globals: FALSE
[17:43:36.590] 
[17:43:36.590] 
[17:43:36.591] getGlobalsAndPackages() ... DONE
[17:43:36.591] run() for ‘Future’ ...
[17:43:36.591] - state: ‘created’
[17:43:36.592] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:43:36.597] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:36.597] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:43:36.597]   - Field: ‘label’
[17:43:36.597]   - Field: ‘local’
[17:43:36.598]   - Field: ‘owner’
[17:43:36.598]   - Field: ‘envir’
[17:43:36.598]   - Field: ‘workers’
[17:43:36.598]   - Field: ‘packages’
[17:43:36.598]   - Field: ‘gc’
[17:43:36.598]   - Field: ‘job’
[17:43:36.598]   - Field: ‘conditions’
[17:43:36.599]   - Field: ‘expr’
[17:43:36.599]   - Field: ‘uuid’
[17:43:36.599]   - Field: ‘seed’
[17:43:36.599]   - Field: ‘version’
[17:43:36.599]   - Field: ‘result’
[17:43:36.599]   - Field: ‘asynchronous’
[17:43:36.600]   - Field: ‘calls’
[17:43:36.600]   - Field: ‘globals’
[17:43:36.600]   - Field: ‘stdout’
[17:43:36.600]   - Field: ‘earlySignal’
[17:43:36.600]   - Field: ‘lazy’
[17:43:36.600]   - Field: ‘state’
[17:43:36.600] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:43:36.601] - Launch lazy future ...
[17:43:36.601] Packages needed by the future expression (n = 0): <none>
[17:43:36.601] Packages needed by future strategies (n = 0): <none>
[17:43:36.602] {
[17:43:36.602]     {
[17:43:36.602]         {
[17:43:36.602]             ...future.startTime <- base::Sys.time()
[17:43:36.602]             {
[17:43:36.602]                 {
[17:43:36.602]                   {
[17:43:36.602]                     {
[17:43:36.602]                       base::local({
[17:43:36.602]                         has_future <- base::requireNamespace("future", 
[17:43:36.602]                           quietly = TRUE)
[17:43:36.602]                         if (has_future) {
[17:43:36.602]                           ns <- base::getNamespace("future")
[17:43:36.602]                           version <- ns[[".package"]][["version"]]
[17:43:36.602]                           if (is.null(version)) 
[17:43:36.602]                             version <- utils::packageVersion("future")
[17:43:36.602]                         }
[17:43:36.602]                         else {
[17:43:36.602]                           version <- NULL
[17:43:36.602]                         }
[17:43:36.602]                         if (!has_future || version < "1.8.0") {
[17:43:36.602]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:36.602]                             "", base::R.version$version.string), 
[17:43:36.602]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:36.602]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:36.602]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:36.602]                               "release", "version")], collapse = " "), 
[17:43:36.602]                             hostname = base::Sys.info()[["nodename"]])
[17:43:36.602]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:36.602]                             info)
[17:43:36.602]                           info <- base::paste(info, collapse = "; ")
[17:43:36.602]                           if (!has_future) {
[17:43:36.602]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:36.602]                               info)
[17:43:36.602]                           }
[17:43:36.602]                           else {
[17:43:36.602]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:36.602]                               info, version)
[17:43:36.602]                           }
[17:43:36.602]                           base::stop(msg)
[17:43:36.602]                         }
[17:43:36.602]                       })
[17:43:36.602]                     }
[17:43:36.602]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:36.602]                     base::options(mc.cores = 1L)
[17:43:36.602]                   }
[17:43:36.602]                   options(future.plan = NULL)
[17:43:36.602]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:36.602]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:36.602]                 }
[17:43:36.602]                 ...future.workdir <- getwd()
[17:43:36.602]             }
[17:43:36.602]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:36.602]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:36.602]         }
[17:43:36.602]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:36.602]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:36.602]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:36.602]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:36.602]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:36.602]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:36.602]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:36.602]             base::names(...future.oldOptions))
[17:43:36.602]     }
[17:43:36.602]     if (FALSE) {
[17:43:36.602]     }
[17:43:36.602]     else {
[17:43:36.602]         if (TRUE) {
[17:43:36.602]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:36.602]                 open = "w")
[17:43:36.602]         }
[17:43:36.602]         else {
[17:43:36.602]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:36.602]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:36.602]         }
[17:43:36.602]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:36.602]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:36.602]             base::sink(type = "output", split = FALSE)
[17:43:36.602]             base::close(...future.stdout)
[17:43:36.602]         }, add = TRUE)
[17:43:36.602]     }
[17:43:36.602]     ...future.frame <- base::sys.nframe()
[17:43:36.602]     ...future.conditions <- base::list()
[17:43:36.602]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:36.602]     if (FALSE) {
[17:43:36.602]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:36.602]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:36.602]     }
[17:43:36.602]     ...future.result <- base::tryCatch({
[17:43:36.602]         base::withCallingHandlers({
[17:43:36.602]             ...future.value <- base::withVisible(base::local({
[17:43:36.602]                 withCallingHandlers({
[17:43:36.602]                   {
[17:43:36.602]                     3
[17:43:36.602]                   }
[17:43:36.602]                 }, immediateCondition = function(cond) {
[17:43:36.602]                   save_rds <- function (object, pathname, ...) 
[17:43:36.602]                   {
[17:43:36.602]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:43:36.602]                     if (file_test("-f", pathname_tmp)) {
[17:43:36.602]                       fi_tmp <- file.info(pathname_tmp)
[17:43:36.602]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:43:36.602]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:36.602]                         fi_tmp[["mtime"]])
[17:43:36.602]                     }
[17:43:36.602]                     tryCatch({
[17:43:36.602]                       saveRDS(object, file = pathname_tmp, ...)
[17:43:36.602]                     }, error = function(ex) {
[17:43:36.602]                       msg <- conditionMessage(ex)
[17:43:36.602]                       fi_tmp <- file.info(pathname_tmp)
[17:43:36.602]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:43:36.602]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:36.602]                         fi_tmp[["mtime"]], msg)
[17:43:36.602]                       ex$message <- msg
[17:43:36.602]                       stop(ex)
[17:43:36.602]                     })
[17:43:36.602]                     stopifnot(file_test("-f", pathname_tmp))
[17:43:36.602]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:43:36.602]                     if (!res || file_test("-f", pathname_tmp)) {
[17:43:36.602]                       fi_tmp <- file.info(pathname_tmp)
[17:43:36.602]                       fi <- file.info(pathname)
[17:43:36.602]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:43:36.602]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:43:36.602]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:43:36.602]                         fi[["size"]], fi[["mtime"]])
[17:43:36.602]                       stop(msg)
[17:43:36.602]                     }
[17:43:36.602]                     invisible(pathname)
[17:43:36.602]                   }
[17:43:36.602]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:43:36.602]                     rootPath = tempdir()) 
[17:43:36.602]                   {
[17:43:36.602]                     obj <- list(time = Sys.time(), condition = cond)
[17:43:36.602]                     file <- tempfile(pattern = class(cond)[1], 
[17:43:36.602]                       tmpdir = path, fileext = ".rds")
[17:43:36.602]                     save_rds(obj, file)
[17:43:36.602]                   }
[17:43:36.602]                   saveImmediateCondition(cond, path = "/tmp/RtmpLaOb2h/.future/immediateConditions")
[17:43:36.602]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:36.602]                   {
[17:43:36.602]                     inherits <- base::inherits
[17:43:36.602]                     invokeRestart <- base::invokeRestart
[17:43:36.602]                     is.null <- base::is.null
[17:43:36.602]                     muffled <- FALSE
[17:43:36.602]                     if (inherits(cond, "message")) {
[17:43:36.602]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:36.602]                       if (muffled) 
[17:43:36.602]                         invokeRestart("muffleMessage")
[17:43:36.602]                     }
[17:43:36.602]                     else if (inherits(cond, "warning")) {
[17:43:36.602]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:36.602]                       if (muffled) 
[17:43:36.602]                         invokeRestart("muffleWarning")
[17:43:36.602]                     }
[17:43:36.602]                     else if (inherits(cond, "condition")) {
[17:43:36.602]                       if (!is.null(pattern)) {
[17:43:36.602]                         computeRestarts <- base::computeRestarts
[17:43:36.602]                         grepl <- base::grepl
[17:43:36.602]                         restarts <- computeRestarts(cond)
[17:43:36.602]                         for (restart in restarts) {
[17:43:36.602]                           name <- restart$name
[17:43:36.602]                           if (is.null(name)) 
[17:43:36.602]                             next
[17:43:36.602]                           if (!grepl(pattern, name)) 
[17:43:36.602]                             next
[17:43:36.602]                           invokeRestart(restart)
[17:43:36.602]                           muffled <- TRUE
[17:43:36.602]                           break
[17:43:36.602]                         }
[17:43:36.602]                       }
[17:43:36.602]                     }
[17:43:36.602]                     invisible(muffled)
[17:43:36.602]                   }
[17:43:36.602]                   muffleCondition(cond)
[17:43:36.602]                 })
[17:43:36.602]             }))
[17:43:36.602]             future::FutureResult(value = ...future.value$value, 
[17:43:36.602]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:36.602]                   ...future.rng), globalenv = if (FALSE) 
[17:43:36.602]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:36.602]                     ...future.globalenv.names))
[17:43:36.602]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:36.602]         }, condition = base::local({
[17:43:36.602]             c <- base::c
[17:43:36.602]             inherits <- base::inherits
[17:43:36.602]             invokeRestart <- base::invokeRestart
[17:43:36.602]             length <- base::length
[17:43:36.602]             list <- base::list
[17:43:36.602]             seq.int <- base::seq.int
[17:43:36.602]             signalCondition <- base::signalCondition
[17:43:36.602]             sys.calls <- base::sys.calls
[17:43:36.602]             `[[` <- base::`[[`
[17:43:36.602]             `+` <- base::`+`
[17:43:36.602]             `<<-` <- base::`<<-`
[17:43:36.602]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:36.602]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:36.602]                   3L)]
[17:43:36.602]             }
[17:43:36.602]             function(cond) {
[17:43:36.602]                 is_error <- inherits(cond, "error")
[17:43:36.602]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:36.602]                   NULL)
[17:43:36.602]                 if (is_error) {
[17:43:36.602]                   sessionInformation <- function() {
[17:43:36.602]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:36.602]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:36.602]                       search = base::search(), system = base::Sys.info())
[17:43:36.602]                   }
[17:43:36.602]                   ...future.conditions[[length(...future.conditions) + 
[17:43:36.602]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:36.602]                     cond$call), session = sessionInformation(), 
[17:43:36.602]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:36.602]                   signalCondition(cond)
[17:43:36.602]                 }
[17:43:36.602]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:36.602]                 "immediateCondition"))) {
[17:43:36.602]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:36.602]                   ...future.conditions[[length(...future.conditions) + 
[17:43:36.602]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:36.602]                   if (TRUE && !signal) {
[17:43:36.602]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:36.602]                     {
[17:43:36.602]                       inherits <- base::inherits
[17:43:36.602]                       invokeRestart <- base::invokeRestart
[17:43:36.602]                       is.null <- base::is.null
[17:43:36.602]                       muffled <- FALSE
[17:43:36.602]                       if (inherits(cond, "message")) {
[17:43:36.602]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:36.602]                         if (muffled) 
[17:43:36.602]                           invokeRestart("muffleMessage")
[17:43:36.602]                       }
[17:43:36.602]                       else if (inherits(cond, "warning")) {
[17:43:36.602]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:36.602]                         if (muffled) 
[17:43:36.602]                           invokeRestart("muffleWarning")
[17:43:36.602]                       }
[17:43:36.602]                       else if (inherits(cond, "condition")) {
[17:43:36.602]                         if (!is.null(pattern)) {
[17:43:36.602]                           computeRestarts <- base::computeRestarts
[17:43:36.602]                           grepl <- base::grepl
[17:43:36.602]                           restarts <- computeRestarts(cond)
[17:43:36.602]                           for (restart in restarts) {
[17:43:36.602]                             name <- restart$name
[17:43:36.602]                             if (is.null(name)) 
[17:43:36.602]                               next
[17:43:36.602]                             if (!grepl(pattern, name)) 
[17:43:36.602]                               next
[17:43:36.602]                             invokeRestart(restart)
[17:43:36.602]                             muffled <- TRUE
[17:43:36.602]                             break
[17:43:36.602]                           }
[17:43:36.602]                         }
[17:43:36.602]                       }
[17:43:36.602]                       invisible(muffled)
[17:43:36.602]                     }
[17:43:36.602]                     muffleCondition(cond, pattern = "^muffle")
[17:43:36.602]                   }
[17:43:36.602]                 }
[17:43:36.602]                 else {
[17:43:36.602]                   if (TRUE) {
[17:43:36.602]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:36.602]                     {
[17:43:36.602]                       inherits <- base::inherits
[17:43:36.602]                       invokeRestart <- base::invokeRestart
[17:43:36.602]                       is.null <- base::is.null
[17:43:36.602]                       muffled <- FALSE
[17:43:36.602]                       if (inherits(cond, "message")) {
[17:43:36.602]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:36.602]                         if (muffled) 
[17:43:36.602]                           invokeRestart("muffleMessage")
[17:43:36.602]                       }
[17:43:36.602]                       else if (inherits(cond, "warning")) {
[17:43:36.602]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:36.602]                         if (muffled) 
[17:43:36.602]                           invokeRestart("muffleWarning")
[17:43:36.602]                       }
[17:43:36.602]                       else if (inherits(cond, "condition")) {
[17:43:36.602]                         if (!is.null(pattern)) {
[17:43:36.602]                           computeRestarts <- base::computeRestarts
[17:43:36.602]                           grepl <- base::grepl
[17:43:36.602]                           restarts <- computeRestarts(cond)
[17:43:36.602]                           for (restart in restarts) {
[17:43:36.602]                             name <- restart$name
[17:43:36.602]                             if (is.null(name)) 
[17:43:36.602]                               next
[17:43:36.602]                             if (!grepl(pattern, name)) 
[17:43:36.602]                               next
[17:43:36.602]                             invokeRestart(restart)
[17:43:36.602]                             muffled <- TRUE
[17:43:36.602]                             break
[17:43:36.602]                           }
[17:43:36.602]                         }
[17:43:36.602]                       }
[17:43:36.602]                       invisible(muffled)
[17:43:36.602]                     }
[17:43:36.602]                     muffleCondition(cond, pattern = "^muffle")
[17:43:36.602]                   }
[17:43:36.602]                 }
[17:43:36.602]             }
[17:43:36.602]         }))
[17:43:36.602]     }, error = function(ex) {
[17:43:36.602]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:36.602]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:36.602]                 ...future.rng), started = ...future.startTime, 
[17:43:36.602]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:36.602]             version = "1.8"), class = "FutureResult")
[17:43:36.602]     }, finally = {
[17:43:36.602]         if (!identical(...future.workdir, getwd())) 
[17:43:36.602]             setwd(...future.workdir)
[17:43:36.602]         {
[17:43:36.602]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:36.602]                 ...future.oldOptions$nwarnings <- NULL
[17:43:36.602]             }
[17:43:36.602]             base::options(...future.oldOptions)
[17:43:36.602]             if (.Platform$OS.type == "windows") {
[17:43:36.602]                 old_names <- names(...future.oldEnvVars)
[17:43:36.602]                 envs <- base::Sys.getenv()
[17:43:36.602]                 names <- names(envs)
[17:43:36.602]                 common <- intersect(names, old_names)
[17:43:36.602]                 added <- setdiff(names, old_names)
[17:43:36.602]                 removed <- setdiff(old_names, names)
[17:43:36.602]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:36.602]                   envs[common]]
[17:43:36.602]                 NAMES <- toupper(changed)
[17:43:36.602]                 args <- list()
[17:43:36.602]                 for (kk in seq_along(NAMES)) {
[17:43:36.602]                   name <- changed[[kk]]
[17:43:36.602]                   NAME <- NAMES[[kk]]
[17:43:36.602]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:36.602]                     next
[17:43:36.602]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:36.602]                 }
[17:43:36.602]                 NAMES <- toupper(added)
[17:43:36.602]                 for (kk in seq_along(NAMES)) {
[17:43:36.602]                   name <- added[[kk]]
[17:43:36.602]                   NAME <- NAMES[[kk]]
[17:43:36.602]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:36.602]                     next
[17:43:36.602]                   args[[name]] <- ""
[17:43:36.602]                 }
[17:43:36.602]                 NAMES <- toupper(removed)
[17:43:36.602]                 for (kk in seq_along(NAMES)) {
[17:43:36.602]                   name <- removed[[kk]]
[17:43:36.602]                   NAME <- NAMES[[kk]]
[17:43:36.602]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:36.602]                     next
[17:43:36.602]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:36.602]                 }
[17:43:36.602]                 if (length(args) > 0) 
[17:43:36.602]                   base::do.call(base::Sys.setenv, args = args)
[17:43:36.602]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:36.602]             }
[17:43:36.602]             else {
[17:43:36.602]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:36.602]             }
[17:43:36.602]             {
[17:43:36.602]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:36.602]                   0L) {
[17:43:36.602]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:36.602]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:36.602]                   base::options(opts)
[17:43:36.602]                 }
[17:43:36.602]                 {
[17:43:36.602]                   {
[17:43:36.602]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:36.602]                     NULL
[17:43:36.602]                   }
[17:43:36.602]                   options(future.plan = NULL)
[17:43:36.602]                   if (is.na(NA_character_)) 
[17:43:36.602]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:36.602]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:36.602]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:43:36.602]                     envir = parent.frame()) 
[17:43:36.602]                   {
[17:43:36.602]                     default_workers <- missing(workers)
[17:43:36.602]                     if (is.function(workers)) 
[17:43:36.602]                       workers <- workers()
[17:43:36.602]                     workers <- structure(as.integer(workers), 
[17:43:36.602]                       class = class(workers))
[17:43:36.602]                     stop_if_not(is.finite(workers), workers >= 
[17:43:36.602]                       1L)
[17:43:36.602]                     if ((workers == 1L && !inherits(workers, 
[17:43:36.602]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:43:36.602]                       if (default_workers) 
[17:43:36.602]                         supportsMulticore(warn = TRUE)
[17:43:36.602]                       return(sequential(..., envir = envir))
[17:43:36.602]                     }
[17:43:36.602]                     oopts <- options(mc.cores = workers)
[17:43:36.602]                     on.exit(options(oopts))
[17:43:36.602]                     future <- MulticoreFuture(..., workers = workers, 
[17:43:36.602]                       envir = envir)
[17:43:36.602]                     if (!future$lazy) 
[17:43:36.602]                       future <- run(future)
[17:43:36.602]                     invisible(future)
[17:43:36.602]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:36.602]                 }
[17:43:36.602]             }
[17:43:36.602]         }
[17:43:36.602]     })
[17:43:36.602]     if (TRUE) {
[17:43:36.602]         base::sink(type = "output", split = FALSE)
[17:43:36.602]         if (TRUE) {
[17:43:36.602]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:36.602]         }
[17:43:36.602]         else {
[17:43:36.602]             ...future.result["stdout"] <- base::list(NULL)
[17:43:36.602]         }
[17:43:36.602]         base::close(...future.stdout)
[17:43:36.602]         ...future.stdout <- NULL
[17:43:36.602]     }
[17:43:36.602]     ...future.result$conditions <- ...future.conditions
[17:43:36.602]     ...future.result$finished <- base::Sys.time()
[17:43:36.602]     ...future.result
[17:43:36.602] }
[17:43:36.606] requestCore(): workers = 2
[17:43:36.606] Poll #1 (0): usedCores() = 2, workers = 2
[17:43:36.620] MulticoreFuture started
[17:43:36.621] - Launch lazy future ... done
[17:43:36.621] run() for ‘MulticoreFuture’ ... done
[17:43:36.622] plan(): Setting new future strategy stack:
[17:43:36.622] List of future strategies:
[17:43:36.622] 1. sequential:
[17:43:36.622]    - args: function (..., envir = parent.frame())
[17:43:36.622]    - tweaked: FALSE
[17:43:36.622]    - call: NULL
[17:43:36.623] plan(): nbrOfWorkers() = 1
[17:43:36.624] resolve() on list environment ...
[17:43:36.624]  recursive: 0
[17:43:36.626] plan(): Setting new future strategy stack:
[17:43:36.626] List of future strategies:
[17:43:36.626] 1. multicore:
[17:43:36.626]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:36.626]    - tweaked: FALSE
[17:43:36.626]    - call: plan(strategy)
[17:43:36.633]  length: 4
[17:43:36.633]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:43:36.634] Future #1
[17:43:36.635]  length: 3 (resolved future 1)
[17:43:36.640] plan(): nbrOfWorkers() = 2
[17:43:36.646] Future #3
[17:43:36.647]  length: 2 (resolved future 3)
[17:43:36.647]  length: 1 (resolved future 4)
[17:43:37.091] plan(): Setting new future strategy stack:
[17:43:37.091] List of future strategies:
[17:43:37.091] 1. multicore:
[17:43:37.091]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:43:37.091]    - tweaked: FALSE
[17:43:37.091]    - call: plan(strategy)
[17:43:37.096] plan(): nbrOfWorkers() = 2
[17:43:37.096] Future #2
[17:43:37.096]  length: 0 (resolved future 2)
[17:43:37.097] resolve() on list environment ... DONE
[17:43:37.097] resolve() on list environment ...
[17:43:37.097]  recursive: 0
[17:43:37.099]  length: 4
[17:43:37.099]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:43:37.100] Future #1
[17:43:37.100]  length: 3 (resolved future 1)
[17:43:37.100] Future #2
[17:43:37.100]  length: 2 (resolved future 2)
[17:43:37.101] Future #3
[17:43:37.101]  length: 1 (resolved future 3)
[17:43:37.101]  length: 0 (resolved future 4)
[17:43:37.101] resolve() on list environment ... DONE
[17:43:37.102] resolve() on list environment ...
[17:43:37.103]  recursive: 0
[17:43:37.104]  length: 4
[17:43:37.104]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:43:37.104] Future #1
[17:43:37.104]  length: 3 (resolved future 1)
[17:43:37.105] Future #2
[17:43:37.105]  length: 2 (resolved future 2)
[17:43:37.105] Future #3
[17:43:37.105]  length: 1 (resolved future 3)
[17:43:37.105]  length: 0 (resolved future 4)
[17:43:37.105] resolve() on list environment ... DONE
[17:43:37.106] resolve() on list environment ...
[17:43:37.106]  recursive: 0
[17:43:37.107]  length: 4
[17:43:37.107]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:43:37.108] Future #1
[17:43:37.108]  length: 3 (resolved future 1)
[17:43:37.108] Future #2
[17:43:37.108]  length: 2 (resolved future 2)
[17:43:37.108] Future #3
[17:43:37.109]  length: 1 (resolved future 3)
[17:43:37.109]  length: 0 (resolved future 4)
[17:43:37.109] resolve() on list environment ... DONE
[17:43:37.110] resolve() on list environment ...
[17:43:37.110]  recursive: 0
[17:43:37.110]  length: 4
[17:43:37.111]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:43:37.111] Future #1
[17:43:37.111]  length: 3 (resolved future 1)
[17:43:37.111] Future #2
[17:43:37.112]  length: 2 (resolved future 2)
[17:43:37.113] Future #3
[17:43:37.114]  length: 1 (resolved future 3)
[17:43:37.114]  length: 0 (resolved future 4)
[17:43:37.114] resolve() on list environment ... DONE
[17:43:37.115] resolve() on list environment ...
[17:43:37.115]  recursive: 99
[17:43:37.116]  length: 4
[17:43:37.116]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:43:37.116] Future #1
[17:43:37.117] A MulticoreFuture was resolved
[17:43:37.117]  length: 3 (resolved future 1)
[17:43:37.117] Future #2
[17:43:37.117] A MulticoreFuture was resolved
[17:43:37.117]  length: 2 (resolved future 2)
[17:43:37.117] Future #3
[17:43:37.118] A MulticoreFuture was resolved
[17:43:37.118]  length: 1 (resolved future 3)
[17:43:37.118]  length: 0 (resolved future 4)
[17:43:37.118] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('multicore') ...
- plan('multisession') ...
[17:43:37.119] plan(): Setting new future strategy stack:
[17:43:37.119] List of future strategies:
[17:43:37.119] 1. multisession:
[17:43:37.119]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:43:37.119]    - tweaked: FALSE
[17:43:37.119]    - call: plan(strategy)
[17:43:37.119] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:43:37.119] multisession:
[17:43:37.119] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:43:37.119] - tweaked: FALSE
[17:43:37.119] - call: plan(strategy)
[17:43:37.126] getGlobalsAndPackages() ...
[17:43:37.126] Not searching for globals
[17:43:37.126] - globals: [0] <none>
[17:43:37.126] getGlobalsAndPackages() ... DONE
[17:43:37.127] [local output] makeClusterPSOCK() ...
[17:43:37.169] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:43:37.175] [local output] Base port: 11857
[17:43:37.175] [local output] Getting setup options for 2 cluster nodes ...
[17:43:37.175] [local output]  - Node 1 of 2 ...
[17:43:37.175] [local output] localMachine=TRUE => revtunnel=FALSE

[17:43:37.176] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpLaOb2h/worker.rank=1.parallelly.parent=51751.ca271c69464.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpLaOb2h/worker.rank=1.parallelly.parent=51751.ca271c69464.pid")'’
[17:43:37.372] - Possible to infer worker's PID: TRUE
[17:43:37.373] [local output] Rscript port: 11857

[17:43:37.373] [local output]  - Node 2 of 2 ...
[17:43:37.373] [local output] localMachine=TRUE => revtunnel=FALSE

[17:43:37.374] [local output] Rscript port: 11857

[17:43:37.374] [local output] Getting setup options for 2 cluster nodes ... done
[17:43:37.374] [local output]  - Parallel setup requested for some PSOCK nodes
[17:43:37.375] [local output] Setting up PSOCK nodes in parallel
[17:43:37.375] List of 36
[17:43:37.375]  $ worker          : chr "localhost"
[17:43:37.375]   ..- attr(*, "localhost")= logi TRUE
[17:43:37.375]  $ master          : chr "localhost"
[17:43:37.375]  $ port            : int 11857
[17:43:37.375]  $ connectTimeout  : num 120
[17:43:37.375]  $ timeout         : num 2592000
[17:43:37.375]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:43:37.375]  $ homogeneous     : logi TRUE
[17:43:37.375]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:43:37.375]  $ rscript_envs    : NULL
[17:43:37.375]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:43:37.375]  $ rscript_startup : NULL
[17:43:37.375]  $ rscript_sh      : chr "sh"
[17:43:37.375]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:43:37.375]  $ methods         : logi TRUE
[17:43:37.375]  $ socketOptions   : chr "no-delay"
[17:43:37.375]  $ useXDR          : logi FALSE
[17:43:37.375]  $ outfile         : chr "/dev/null"
[17:43:37.375]  $ renice          : int NA
[17:43:37.375]  $ rshcmd          : NULL
[17:43:37.375]  $ user            : chr(0) 
[17:43:37.375]  $ revtunnel       : logi FALSE
[17:43:37.375]  $ rshlogfile      : NULL
[17:43:37.375]  $ rshopts         : chr(0) 
[17:43:37.375]  $ rank            : int 1
[17:43:37.375]  $ manual          : logi FALSE
[17:43:37.375]  $ dryrun          : logi FALSE
[17:43:37.375]  $ quiet           : logi FALSE
[17:43:37.375]  $ setup_strategy  : chr "parallel"
[17:43:37.375]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:43:37.375]  $ pidfile         : chr "/tmp/RtmpLaOb2h/worker.rank=1.parallelly.parent=51751.ca271c69464.pid"
[17:43:37.375]  $ rshcmd_label    : NULL
[17:43:37.375]  $ rsh_call        : NULL
[17:43:37.375]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:43:37.375]  $ localMachine    : logi TRUE
[17:43:37.375]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:43:37.375]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:43:37.375]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:43:37.375]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:43:37.375]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:43:37.375]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:43:37.375]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:43:37.375]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:43:37.375]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:43:37.375]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:43:37.375]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:43:37.375]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:43:37.375]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:43:37.375]  $ arguments       :List of 28
[17:43:37.375]   ..$ worker          : chr "localhost"
[17:43:37.375]   ..$ master          : NULL
[17:43:37.375]   ..$ port            : int 11857
[17:43:37.375]   ..$ connectTimeout  : num 120
[17:43:37.375]   ..$ timeout         : num 2592000
[17:43:37.375]   ..$ rscript         : NULL
[17:43:37.375]   ..$ homogeneous     : NULL
[17:43:37.375]   ..$ rscript_args    : NULL
[17:43:37.375]   ..$ rscript_envs    : NULL
[17:43:37.375]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:43:37.375]   ..$ rscript_startup : NULL
[17:43:37.375]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:43:37.375]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:43:37.375]   ..$ methods         : logi TRUE
[17:43:37.375]   ..$ socketOptions   : chr "no-delay"
[17:43:37.375]   ..$ useXDR          : logi FALSE
[17:43:37.375]   ..$ outfile         : chr "/dev/null"
[17:43:37.375]   ..$ renice          : int NA
[17:43:37.375]   ..$ rshcmd          : NULL
[17:43:37.375]   ..$ user            : NULL
[17:43:37.375]   ..$ revtunnel       : logi NA
[17:43:37.375]   ..$ rshlogfile      : NULL
[17:43:37.375]   ..$ rshopts         : NULL
[17:43:37.375]   ..$ rank            : int 1
[17:43:37.375]   ..$ manual          : logi FALSE
[17:43:37.375]   ..$ dryrun          : logi FALSE
[17:43:37.375]   ..$ quiet           : logi FALSE
[17:43:37.375]   ..$ setup_strategy  : chr "parallel"
[17:43:37.375]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:43:37.392] [local output] System call to launch all workers:
[17:43:37.392] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpLaOb2h/worker.rank=1.parallelly.parent=51751.ca271c69464.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11857 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:43:37.392] [local output] Starting PSOCK main server
[17:43:37.394] [local output] Workers launched
[17:43:37.394] [local output] Waiting for workers to connect back
[17:43:37.394]  - [local output] 0 workers out of 2 ready
[17:43:37.661]  - [local output] 0 workers out of 2 ready
[17:43:37.662]  - [local output] 1 workers out of 2 ready
[17:43:37.670]  - [local output] 1 workers out of 2 ready
[17:43:37.671]  - [local output] 2 workers out of 2 ready
[17:43:37.671] [local output] Launching of workers completed
[17:43:37.671] [local output] Collecting session information from workers
[17:43:37.672] [local output]  - Worker #1 of 2
[17:43:37.673] [local output]  - Worker #2 of 2
[17:43:37.673] [local output] makeClusterPSOCK() ... done
[17:43:37.685] Packages needed by the future expression (n = 0): <none>
[17:43:37.685] Packages needed by future strategies (n = 0): <none>
[17:43:37.685] {
[17:43:37.685]     {
[17:43:37.685]         {
[17:43:37.685]             ...future.startTime <- base::Sys.time()
[17:43:37.685]             {
[17:43:37.685]                 {
[17:43:37.685]                   {
[17:43:37.685]                     {
[17:43:37.685]                       base::local({
[17:43:37.685]                         has_future <- base::requireNamespace("future", 
[17:43:37.685]                           quietly = TRUE)
[17:43:37.685]                         if (has_future) {
[17:43:37.685]                           ns <- base::getNamespace("future")
[17:43:37.685]                           version <- ns[[".package"]][["version"]]
[17:43:37.685]                           if (is.null(version)) 
[17:43:37.685]                             version <- utils::packageVersion("future")
[17:43:37.685]                         }
[17:43:37.685]                         else {
[17:43:37.685]                           version <- NULL
[17:43:37.685]                         }
[17:43:37.685]                         if (!has_future || version < "1.8.0") {
[17:43:37.685]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:37.685]                             "", base::R.version$version.string), 
[17:43:37.685]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:37.685]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:37.685]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:37.685]                               "release", "version")], collapse = " "), 
[17:43:37.685]                             hostname = base::Sys.info()[["nodename"]])
[17:43:37.685]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:37.685]                             info)
[17:43:37.685]                           info <- base::paste(info, collapse = "; ")
[17:43:37.685]                           if (!has_future) {
[17:43:37.685]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:37.685]                               info)
[17:43:37.685]                           }
[17:43:37.685]                           else {
[17:43:37.685]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:37.685]                               info, version)
[17:43:37.685]                           }
[17:43:37.685]                           base::stop(msg)
[17:43:37.685]                         }
[17:43:37.685]                       })
[17:43:37.685]                     }
[17:43:37.685]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:37.685]                     base::options(mc.cores = 1L)
[17:43:37.685]                   }
[17:43:37.685]                   options(future.plan = NULL)
[17:43:37.685]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:37.685]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:37.685]                 }
[17:43:37.685]                 ...future.workdir <- getwd()
[17:43:37.685]             }
[17:43:37.685]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:37.685]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:37.685]         }
[17:43:37.685]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:37.685]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:37.685]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:37.685]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:37.685]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:37.685]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:37.685]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:37.685]             base::names(...future.oldOptions))
[17:43:37.685]     }
[17:43:37.685]     if (FALSE) {
[17:43:37.685]     }
[17:43:37.685]     else {
[17:43:37.685]         if (TRUE) {
[17:43:37.685]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:37.685]                 open = "w")
[17:43:37.685]         }
[17:43:37.685]         else {
[17:43:37.685]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:37.685]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:37.685]         }
[17:43:37.685]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:37.685]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:37.685]             base::sink(type = "output", split = FALSE)
[17:43:37.685]             base::close(...future.stdout)
[17:43:37.685]         }, add = TRUE)
[17:43:37.685]     }
[17:43:37.685]     ...future.frame <- base::sys.nframe()
[17:43:37.685]     ...future.conditions <- base::list()
[17:43:37.685]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:37.685]     if (FALSE) {
[17:43:37.685]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:37.685]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:37.685]     }
[17:43:37.685]     ...future.result <- base::tryCatch({
[17:43:37.685]         base::withCallingHandlers({
[17:43:37.685]             ...future.value <- base::withVisible(base::local({
[17:43:37.685]                 ...future.makeSendCondition <- local({
[17:43:37.685]                   sendCondition <- NULL
[17:43:37.685]                   function(frame = 1L) {
[17:43:37.685]                     if (is.function(sendCondition)) 
[17:43:37.685]                       return(sendCondition)
[17:43:37.685]                     ns <- getNamespace("parallel")
[17:43:37.685]                     if (exists("sendData", mode = "function", 
[17:43:37.685]                       envir = ns)) {
[17:43:37.685]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:37.685]                         envir = ns)
[17:43:37.685]                       envir <- sys.frame(frame)
[17:43:37.685]                       master <- NULL
[17:43:37.685]                       while (!identical(envir, .GlobalEnv) && 
[17:43:37.685]                         !identical(envir, emptyenv())) {
[17:43:37.685]                         if (exists("master", mode = "list", envir = envir, 
[17:43:37.685]                           inherits = FALSE)) {
[17:43:37.685]                           master <- get("master", mode = "list", 
[17:43:37.685]                             envir = envir, inherits = FALSE)
[17:43:37.685]                           if (inherits(master, c("SOCKnode", 
[17:43:37.685]                             "SOCK0node"))) {
[17:43:37.685]                             sendCondition <<- function(cond) {
[17:43:37.685]                               data <- list(type = "VALUE", value = cond, 
[17:43:37.685]                                 success = TRUE)
[17:43:37.685]                               parallel_sendData(master, data)
[17:43:37.685]                             }
[17:43:37.685]                             return(sendCondition)
[17:43:37.685]                           }
[17:43:37.685]                         }
[17:43:37.685]                         frame <- frame + 1L
[17:43:37.685]                         envir <- sys.frame(frame)
[17:43:37.685]                       }
[17:43:37.685]                     }
[17:43:37.685]                     sendCondition <<- function(cond) NULL
[17:43:37.685]                   }
[17:43:37.685]                 })
[17:43:37.685]                 withCallingHandlers({
[17:43:37.685]                   NA
[17:43:37.685]                 }, immediateCondition = function(cond) {
[17:43:37.685]                   sendCondition <- ...future.makeSendCondition()
[17:43:37.685]                   sendCondition(cond)
[17:43:37.685]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:37.685]                   {
[17:43:37.685]                     inherits <- base::inherits
[17:43:37.685]                     invokeRestart <- base::invokeRestart
[17:43:37.685]                     is.null <- base::is.null
[17:43:37.685]                     muffled <- FALSE
[17:43:37.685]                     if (inherits(cond, "message")) {
[17:43:37.685]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:37.685]                       if (muffled) 
[17:43:37.685]                         invokeRestart("muffleMessage")
[17:43:37.685]                     }
[17:43:37.685]                     else if (inherits(cond, "warning")) {
[17:43:37.685]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:37.685]                       if (muffled) 
[17:43:37.685]                         invokeRestart("muffleWarning")
[17:43:37.685]                     }
[17:43:37.685]                     else if (inherits(cond, "condition")) {
[17:43:37.685]                       if (!is.null(pattern)) {
[17:43:37.685]                         computeRestarts <- base::computeRestarts
[17:43:37.685]                         grepl <- base::grepl
[17:43:37.685]                         restarts <- computeRestarts(cond)
[17:43:37.685]                         for (restart in restarts) {
[17:43:37.685]                           name <- restart$name
[17:43:37.685]                           if (is.null(name)) 
[17:43:37.685]                             next
[17:43:37.685]                           if (!grepl(pattern, name)) 
[17:43:37.685]                             next
[17:43:37.685]                           invokeRestart(restart)
[17:43:37.685]                           muffled <- TRUE
[17:43:37.685]                           break
[17:43:37.685]                         }
[17:43:37.685]                       }
[17:43:37.685]                     }
[17:43:37.685]                     invisible(muffled)
[17:43:37.685]                   }
[17:43:37.685]                   muffleCondition(cond)
[17:43:37.685]                 })
[17:43:37.685]             }))
[17:43:37.685]             future::FutureResult(value = ...future.value$value, 
[17:43:37.685]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:37.685]                   ...future.rng), globalenv = if (FALSE) 
[17:43:37.685]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:37.685]                     ...future.globalenv.names))
[17:43:37.685]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:37.685]         }, condition = base::local({
[17:43:37.685]             c <- base::c
[17:43:37.685]             inherits <- base::inherits
[17:43:37.685]             invokeRestart <- base::invokeRestart
[17:43:37.685]             length <- base::length
[17:43:37.685]             list <- base::list
[17:43:37.685]             seq.int <- base::seq.int
[17:43:37.685]             signalCondition <- base::signalCondition
[17:43:37.685]             sys.calls <- base::sys.calls
[17:43:37.685]             `[[` <- base::`[[`
[17:43:37.685]             `+` <- base::`+`
[17:43:37.685]             `<<-` <- base::`<<-`
[17:43:37.685]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:37.685]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:37.685]                   3L)]
[17:43:37.685]             }
[17:43:37.685]             function(cond) {
[17:43:37.685]                 is_error <- inherits(cond, "error")
[17:43:37.685]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:37.685]                   NULL)
[17:43:37.685]                 if (is_error) {
[17:43:37.685]                   sessionInformation <- function() {
[17:43:37.685]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:37.685]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:37.685]                       search = base::search(), system = base::Sys.info())
[17:43:37.685]                   }
[17:43:37.685]                   ...future.conditions[[length(...future.conditions) + 
[17:43:37.685]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:37.685]                     cond$call), session = sessionInformation(), 
[17:43:37.685]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:37.685]                   signalCondition(cond)
[17:43:37.685]                 }
[17:43:37.685]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:37.685]                 "immediateCondition"))) {
[17:43:37.685]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:37.685]                   ...future.conditions[[length(...future.conditions) + 
[17:43:37.685]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:37.685]                   if (TRUE && !signal) {
[17:43:37.685]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:37.685]                     {
[17:43:37.685]                       inherits <- base::inherits
[17:43:37.685]                       invokeRestart <- base::invokeRestart
[17:43:37.685]                       is.null <- base::is.null
[17:43:37.685]                       muffled <- FALSE
[17:43:37.685]                       if (inherits(cond, "message")) {
[17:43:37.685]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:37.685]                         if (muffled) 
[17:43:37.685]                           invokeRestart("muffleMessage")
[17:43:37.685]                       }
[17:43:37.685]                       else if (inherits(cond, "warning")) {
[17:43:37.685]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:37.685]                         if (muffled) 
[17:43:37.685]                           invokeRestart("muffleWarning")
[17:43:37.685]                       }
[17:43:37.685]                       else if (inherits(cond, "condition")) {
[17:43:37.685]                         if (!is.null(pattern)) {
[17:43:37.685]                           computeRestarts <- base::computeRestarts
[17:43:37.685]                           grepl <- base::grepl
[17:43:37.685]                           restarts <- computeRestarts(cond)
[17:43:37.685]                           for (restart in restarts) {
[17:43:37.685]                             name <- restart$name
[17:43:37.685]                             if (is.null(name)) 
[17:43:37.685]                               next
[17:43:37.685]                             if (!grepl(pattern, name)) 
[17:43:37.685]                               next
[17:43:37.685]                             invokeRestart(restart)
[17:43:37.685]                             muffled <- TRUE
[17:43:37.685]                             break
[17:43:37.685]                           }
[17:43:37.685]                         }
[17:43:37.685]                       }
[17:43:37.685]                       invisible(muffled)
[17:43:37.685]                     }
[17:43:37.685]                     muffleCondition(cond, pattern = "^muffle")
[17:43:37.685]                   }
[17:43:37.685]                 }
[17:43:37.685]                 else {
[17:43:37.685]                   if (TRUE) {
[17:43:37.685]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:37.685]                     {
[17:43:37.685]                       inherits <- base::inherits
[17:43:37.685]                       invokeRestart <- base::invokeRestart
[17:43:37.685]                       is.null <- base::is.null
[17:43:37.685]                       muffled <- FALSE
[17:43:37.685]                       if (inherits(cond, "message")) {
[17:43:37.685]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:37.685]                         if (muffled) 
[17:43:37.685]                           invokeRestart("muffleMessage")
[17:43:37.685]                       }
[17:43:37.685]                       else if (inherits(cond, "warning")) {
[17:43:37.685]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:37.685]                         if (muffled) 
[17:43:37.685]                           invokeRestart("muffleWarning")
[17:43:37.685]                       }
[17:43:37.685]                       else if (inherits(cond, "condition")) {
[17:43:37.685]                         if (!is.null(pattern)) {
[17:43:37.685]                           computeRestarts <- base::computeRestarts
[17:43:37.685]                           grepl <- base::grepl
[17:43:37.685]                           restarts <- computeRestarts(cond)
[17:43:37.685]                           for (restart in restarts) {
[17:43:37.685]                             name <- restart$name
[17:43:37.685]                             if (is.null(name)) 
[17:43:37.685]                               next
[17:43:37.685]                             if (!grepl(pattern, name)) 
[17:43:37.685]                               next
[17:43:37.685]                             invokeRestart(restart)
[17:43:37.685]                             muffled <- TRUE
[17:43:37.685]                             break
[17:43:37.685]                           }
[17:43:37.685]                         }
[17:43:37.685]                       }
[17:43:37.685]                       invisible(muffled)
[17:43:37.685]                     }
[17:43:37.685]                     muffleCondition(cond, pattern = "^muffle")
[17:43:37.685]                   }
[17:43:37.685]                 }
[17:43:37.685]             }
[17:43:37.685]         }))
[17:43:37.685]     }, error = function(ex) {
[17:43:37.685]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:37.685]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:37.685]                 ...future.rng), started = ...future.startTime, 
[17:43:37.685]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:37.685]             version = "1.8"), class = "FutureResult")
[17:43:37.685]     }, finally = {
[17:43:37.685]         if (!identical(...future.workdir, getwd())) 
[17:43:37.685]             setwd(...future.workdir)
[17:43:37.685]         {
[17:43:37.685]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:37.685]                 ...future.oldOptions$nwarnings <- NULL
[17:43:37.685]             }
[17:43:37.685]             base::options(...future.oldOptions)
[17:43:37.685]             if (.Platform$OS.type == "windows") {
[17:43:37.685]                 old_names <- names(...future.oldEnvVars)
[17:43:37.685]                 envs <- base::Sys.getenv()
[17:43:37.685]                 names <- names(envs)
[17:43:37.685]                 common <- intersect(names, old_names)
[17:43:37.685]                 added <- setdiff(names, old_names)
[17:43:37.685]                 removed <- setdiff(old_names, names)
[17:43:37.685]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:37.685]                   envs[common]]
[17:43:37.685]                 NAMES <- toupper(changed)
[17:43:37.685]                 args <- list()
[17:43:37.685]                 for (kk in seq_along(NAMES)) {
[17:43:37.685]                   name <- changed[[kk]]
[17:43:37.685]                   NAME <- NAMES[[kk]]
[17:43:37.685]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:37.685]                     next
[17:43:37.685]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:37.685]                 }
[17:43:37.685]                 NAMES <- toupper(added)
[17:43:37.685]                 for (kk in seq_along(NAMES)) {
[17:43:37.685]                   name <- added[[kk]]
[17:43:37.685]                   NAME <- NAMES[[kk]]
[17:43:37.685]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:37.685]                     next
[17:43:37.685]                   args[[name]] <- ""
[17:43:37.685]                 }
[17:43:37.685]                 NAMES <- toupper(removed)
[17:43:37.685]                 for (kk in seq_along(NAMES)) {
[17:43:37.685]                   name <- removed[[kk]]
[17:43:37.685]                   NAME <- NAMES[[kk]]
[17:43:37.685]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:37.685]                     next
[17:43:37.685]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:37.685]                 }
[17:43:37.685]                 if (length(args) > 0) 
[17:43:37.685]                   base::do.call(base::Sys.setenv, args = args)
[17:43:37.685]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:37.685]             }
[17:43:37.685]             else {
[17:43:37.685]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:37.685]             }
[17:43:37.685]             {
[17:43:37.685]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:37.685]                   0L) {
[17:43:37.685]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:37.685]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:37.685]                   base::options(opts)
[17:43:37.685]                 }
[17:43:37.685]                 {
[17:43:37.685]                   {
[17:43:37.685]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:37.685]                     NULL
[17:43:37.685]                   }
[17:43:37.685]                   options(future.plan = NULL)
[17:43:37.685]                   if (is.na(NA_character_)) 
[17:43:37.685]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:37.685]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:37.685]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:37.685]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:37.685]                     envir = parent.frame()) 
[17:43:37.685]                   {
[17:43:37.685]                     if (is.function(workers)) 
[17:43:37.685]                       workers <- workers()
[17:43:37.685]                     workers <- structure(as.integer(workers), 
[17:43:37.685]                       class = class(workers))
[17:43:37.685]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:37.685]                       workers >= 1)
[17:43:37.685]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:37.685]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:37.685]                     }
[17:43:37.685]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:37.685]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:37.685]                       envir = envir)
[17:43:37.685]                     if (!future$lazy) 
[17:43:37.685]                       future <- run(future)
[17:43:37.685]                     invisible(future)
[17:43:37.685]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:37.685]                 }
[17:43:37.685]             }
[17:43:37.685]         }
[17:43:37.685]     })
[17:43:37.685]     if (TRUE) {
[17:43:37.685]         base::sink(type = "output", split = FALSE)
[17:43:37.685]         if (TRUE) {
[17:43:37.685]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:37.685]         }
[17:43:37.685]         else {
[17:43:37.685]             ...future.result["stdout"] <- base::list(NULL)
[17:43:37.685]         }
[17:43:37.685]         base::close(...future.stdout)
[17:43:37.685]         ...future.stdout <- NULL
[17:43:37.685]     }
[17:43:37.685]     ...future.result$conditions <- ...future.conditions
[17:43:37.685]     ...future.result$finished <- base::Sys.time()
[17:43:37.685]     ...future.result
[17:43:37.685] }
[17:43:37.759] MultisessionFuture started
[17:43:37.759] result() for ClusterFuture ...
[17:43:37.760] receiveMessageFromWorker() for ClusterFuture ...
[17:43:37.760] - Validating connection of MultisessionFuture
[17:43:37.792] - received message: FutureResult
[17:43:37.792] - Received FutureResult
[17:43:37.792] - Erased future from FutureRegistry
[17:43:37.793] result() for ClusterFuture ...
[17:43:37.793] - result already collected: FutureResult
[17:43:37.793] result() for ClusterFuture ... done
[17:43:37.793] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:37.793] result() for ClusterFuture ... done
[17:43:37.793] result() for ClusterFuture ...
[17:43:37.793] - result already collected: FutureResult
[17:43:37.793] result() for ClusterFuture ... done
[17:43:37.794] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:43:37.797] plan(): nbrOfWorkers() = 2
*** resolve() for Future objects ...
- result = FALSE, recursive = FALSE ...
[17:43:37.801] getGlobalsAndPackages() ...
[17:43:37.801] Searching for globals...
[17:43:37.802] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:43:37.802] Searching for globals ... DONE
[17:43:37.803] Resolving globals: FALSE
[17:43:37.803] 
[17:43:37.803] 
[17:43:37.803] getGlobalsAndPackages() ... DONE
[17:43:37.804] run() for ‘Future’ ...
[17:43:37.804] - state: ‘created’
[17:43:37.804] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:37.819] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:37.819] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:37.819]   - Field: ‘node’
[17:43:37.820]   - Field: ‘label’
[17:43:37.820]   - Field: ‘local’
[17:43:37.820]   - Field: ‘owner’
[17:43:37.820]   - Field: ‘envir’
[17:43:37.820]   - Field: ‘workers’
[17:43:37.820]   - Field: ‘packages’
[17:43:37.820]   - Field: ‘gc’
[17:43:37.820]   - Field: ‘conditions’
[17:43:37.820]   - Field: ‘persistent’
[17:43:37.820]   - Field: ‘expr’
[17:43:37.821]   - Field: ‘uuid’
[17:43:37.821]   - Field: ‘seed’
[17:43:37.821]   - Field: ‘version’
[17:43:37.821]   - Field: ‘result’
[17:43:37.821]   - Field: ‘asynchronous’
[17:43:37.821]   - Field: ‘calls’
[17:43:37.821]   - Field: ‘globals’
[17:43:37.821]   - Field: ‘stdout’
[17:43:37.821]   - Field: ‘earlySignal’
[17:43:37.822]   - Field: ‘lazy’
[17:43:37.822]   - Field: ‘state’
[17:43:37.822] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:37.822] - Launch lazy future ...
[17:43:37.822] Packages needed by the future expression (n = 0): <none>
[17:43:37.822] Packages needed by future strategies (n = 0): <none>
[17:43:37.823] {
[17:43:37.823]     {
[17:43:37.823]         {
[17:43:37.823]             ...future.startTime <- base::Sys.time()
[17:43:37.823]             {
[17:43:37.823]                 {
[17:43:37.823]                   {
[17:43:37.823]                     {
[17:43:37.823]                       base::local({
[17:43:37.823]                         has_future <- base::requireNamespace("future", 
[17:43:37.823]                           quietly = TRUE)
[17:43:37.823]                         if (has_future) {
[17:43:37.823]                           ns <- base::getNamespace("future")
[17:43:37.823]                           version <- ns[[".package"]][["version"]]
[17:43:37.823]                           if (is.null(version)) 
[17:43:37.823]                             version <- utils::packageVersion("future")
[17:43:37.823]                         }
[17:43:37.823]                         else {
[17:43:37.823]                           version <- NULL
[17:43:37.823]                         }
[17:43:37.823]                         if (!has_future || version < "1.8.0") {
[17:43:37.823]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:37.823]                             "", base::R.version$version.string), 
[17:43:37.823]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:37.823]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:37.823]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:37.823]                               "release", "version")], collapse = " "), 
[17:43:37.823]                             hostname = base::Sys.info()[["nodename"]])
[17:43:37.823]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:37.823]                             info)
[17:43:37.823]                           info <- base::paste(info, collapse = "; ")
[17:43:37.823]                           if (!has_future) {
[17:43:37.823]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:37.823]                               info)
[17:43:37.823]                           }
[17:43:37.823]                           else {
[17:43:37.823]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:37.823]                               info, version)
[17:43:37.823]                           }
[17:43:37.823]                           base::stop(msg)
[17:43:37.823]                         }
[17:43:37.823]                       })
[17:43:37.823]                     }
[17:43:37.823]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:37.823]                     base::options(mc.cores = 1L)
[17:43:37.823]                   }
[17:43:37.823]                   options(future.plan = NULL)
[17:43:37.823]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:37.823]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:37.823]                 }
[17:43:37.823]                 ...future.workdir <- getwd()
[17:43:37.823]             }
[17:43:37.823]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:37.823]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:37.823]         }
[17:43:37.823]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:37.823]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:37.823]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:37.823]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:37.823]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:37.823]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:37.823]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:37.823]             base::names(...future.oldOptions))
[17:43:37.823]     }
[17:43:37.823]     if (FALSE) {
[17:43:37.823]     }
[17:43:37.823]     else {
[17:43:37.823]         if (TRUE) {
[17:43:37.823]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:37.823]                 open = "w")
[17:43:37.823]         }
[17:43:37.823]         else {
[17:43:37.823]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:37.823]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:37.823]         }
[17:43:37.823]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:37.823]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:37.823]             base::sink(type = "output", split = FALSE)
[17:43:37.823]             base::close(...future.stdout)
[17:43:37.823]         }, add = TRUE)
[17:43:37.823]     }
[17:43:37.823]     ...future.frame <- base::sys.nframe()
[17:43:37.823]     ...future.conditions <- base::list()
[17:43:37.823]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:37.823]     if (FALSE) {
[17:43:37.823]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:37.823]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:37.823]     }
[17:43:37.823]     ...future.result <- base::tryCatch({
[17:43:37.823]         base::withCallingHandlers({
[17:43:37.823]             ...future.value <- base::withVisible(base::local({
[17:43:37.823]                 ...future.makeSendCondition <- local({
[17:43:37.823]                   sendCondition <- NULL
[17:43:37.823]                   function(frame = 1L) {
[17:43:37.823]                     if (is.function(sendCondition)) 
[17:43:37.823]                       return(sendCondition)
[17:43:37.823]                     ns <- getNamespace("parallel")
[17:43:37.823]                     if (exists("sendData", mode = "function", 
[17:43:37.823]                       envir = ns)) {
[17:43:37.823]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:37.823]                         envir = ns)
[17:43:37.823]                       envir <- sys.frame(frame)
[17:43:37.823]                       master <- NULL
[17:43:37.823]                       while (!identical(envir, .GlobalEnv) && 
[17:43:37.823]                         !identical(envir, emptyenv())) {
[17:43:37.823]                         if (exists("master", mode = "list", envir = envir, 
[17:43:37.823]                           inherits = FALSE)) {
[17:43:37.823]                           master <- get("master", mode = "list", 
[17:43:37.823]                             envir = envir, inherits = FALSE)
[17:43:37.823]                           if (inherits(master, c("SOCKnode", 
[17:43:37.823]                             "SOCK0node"))) {
[17:43:37.823]                             sendCondition <<- function(cond) {
[17:43:37.823]                               data <- list(type = "VALUE", value = cond, 
[17:43:37.823]                                 success = TRUE)
[17:43:37.823]                               parallel_sendData(master, data)
[17:43:37.823]                             }
[17:43:37.823]                             return(sendCondition)
[17:43:37.823]                           }
[17:43:37.823]                         }
[17:43:37.823]                         frame <- frame + 1L
[17:43:37.823]                         envir <- sys.frame(frame)
[17:43:37.823]                       }
[17:43:37.823]                     }
[17:43:37.823]                     sendCondition <<- function(cond) NULL
[17:43:37.823]                   }
[17:43:37.823]                 })
[17:43:37.823]                 withCallingHandlers({
[17:43:37.823]                   {
[17:43:37.823]                     Sys.sleep(0.5)
[17:43:37.823]                     list(a = 1, b = 42L)
[17:43:37.823]                   }
[17:43:37.823]                 }, immediateCondition = function(cond) {
[17:43:37.823]                   sendCondition <- ...future.makeSendCondition()
[17:43:37.823]                   sendCondition(cond)
[17:43:37.823]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:37.823]                   {
[17:43:37.823]                     inherits <- base::inherits
[17:43:37.823]                     invokeRestart <- base::invokeRestart
[17:43:37.823]                     is.null <- base::is.null
[17:43:37.823]                     muffled <- FALSE
[17:43:37.823]                     if (inherits(cond, "message")) {
[17:43:37.823]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:37.823]                       if (muffled) 
[17:43:37.823]                         invokeRestart("muffleMessage")
[17:43:37.823]                     }
[17:43:37.823]                     else if (inherits(cond, "warning")) {
[17:43:37.823]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:37.823]                       if (muffled) 
[17:43:37.823]                         invokeRestart("muffleWarning")
[17:43:37.823]                     }
[17:43:37.823]                     else if (inherits(cond, "condition")) {
[17:43:37.823]                       if (!is.null(pattern)) {
[17:43:37.823]                         computeRestarts <- base::computeRestarts
[17:43:37.823]                         grepl <- base::grepl
[17:43:37.823]                         restarts <- computeRestarts(cond)
[17:43:37.823]                         for (restart in restarts) {
[17:43:37.823]                           name <- restart$name
[17:43:37.823]                           if (is.null(name)) 
[17:43:37.823]                             next
[17:43:37.823]                           if (!grepl(pattern, name)) 
[17:43:37.823]                             next
[17:43:37.823]                           invokeRestart(restart)
[17:43:37.823]                           muffled <- TRUE
[17:43:37.823]                           break
[17:43:37.823]                         }
[17:43:37.823]                       }
[17:43:37.823]                     }
[17:43:37.823]                     invisible(muffled)
[17:43:37.823]                   }
[17:43:37.823]                   muffleCondition(cond)
[17:43:37.823]                 })
[17:43:37.823]             }))
[17:43:37.823]             future::FutureResult(value = ...future.value$value, 
[17:43:37.823]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:37.823]                   ...future.rng), globalenv = if (FALSE) 
[17:43:37.823]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:37.823]                     ...future.globalenv.names))
[17:43:37.823]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:37.823]         }, condition = base::local({
[17:43:37.823]             c <- base::c
[17:43:37.823]             inherits <- base::inherits
[17:43:37.823]             invokeRestart <- base::invokeRestart
[17:43:37.823]             length <- base::length
[17:43:37.823]             list <- base::list
[17:43:37.823]             seq.int <- base::seq.int
[17:43:37.823]             signalCondition <- base::signalCondition
[17:43:37.823]             sys.calls <- base::sys.calls
[17:43:37.823]             `[[` <- base::`[[`
[17:43:37.823]             `+` <- base::`+`
[17:43:37.823]             `<<-` <- base::`<<-`
[17:43:37.823]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:37.823]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:37.823]                   3L)]
[17:43:37.823]             }
[17:43:37.823]             function(cond) {
[17:43:37.823]                 is_error <- inherits(cond, "error")
[17:43:37.823]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:37.823]                   NULL)
[17:43:37.823]                 if (is_error) {
[17:43:37.823]                   sessionInformation <- function() {
[17:43:37.823]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:37.823]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:37.823]                       search = base::search(), system = base::Sys.info())
[17:43:37.823]                   }
[17:43:37.823]                   ...future.conditions[[length(...future.conditions) + 
[17:43:37.823]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:37.823]                     cond$call), session = sessionInformation(), 
[17:43:37.823]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:37.823]                   signalCondition(cond)
[17:43:37.823]                 }
[17:43:37.823]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:37.823]                 "immediateCondition"))) {
[17:43:37.823]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:37.823]                   ...future.conditions[[length(...future.conditions) + 
[17:43:37.823]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:37.823]                   if (TRUE && !signal) {
[17:43:37.823]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:37.823]                     {
[17:43:37.823]                       inherits <- base::inherits
[17:43:37.823]                       invokeRestart <- base::invokeRestart
[17:43:37.823]                       is.null <- base::is.null
[17:43:37.823]                       muffled <- FALSE
[17:43:37.823]                       if (inherits(cond, "message")) {
[17:43:37.823]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:37.823]                         if (muffled) 
[17:43:37.823]                           invokeRestart("muffleMessage")
[17:43:37.823]                       }
[17:43:37.823]                       else if (inherits(cond, "warning")) {
[17:43:37.823]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:37.823]                         if (muffled) 
[17:43:37.823]                           invokeRestart("muffleWarning")
[17:43:37.823]                       }
[17:43:37.823]                       else if (inherits(cond, "condition")) {
[17:43:37.823]                         if (!is.null(pattern)) {
[17:43:37.823]                           computeRestarts <- base::computeRestarts
[17:43:37.823]                           grepl <- base::grepl
[17:43:37.823]                           restarts <- computeRestarts(cond)
[17:43:37.823]                           for (restart in restarts) {
[17:43:37.823]                             name <- restart$name
[17:43:37.823]                             if (is.null(name)) 
[17:43:37.823]                               next
[17:43:37.823]                             if (!grepl(pattern, name)) 
[17:43:37.823]                               next
[17:43:37.823]                             invokeRestart(restart)
[17:43:37.823]                             muffled <- TRUE
[17:43:37.823]                             break
[17:43:37.823]                           }
[17:43:37.823]                         }
[17:43:37.823]                       }
[17:43:37.823]                       invisible(muffled)
[17:43:37.823]                     }
[17:43:37.823]                     muffleCondition(cond, pattern = "^muffle")
[17:43:37.823]                   }
[17:43:37.823]                 }
[17:43:37.823]                 else {
[17:43:37.823]                   if (TRUE) {
[17:43:37.823]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:37.823]                     {
[17:43:37.823]                       inherits <- base::inherits
[17:43:37.823]                       invokeRestart <- base::invokeRestart
[17:43:37.823]                       is.null <- base::is.null
[17:43:37.823]                       muffled <- FALSE
[17:43:37.823]                       if (inherits(cond, "message")) {
[17:43:37.823]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:37.823]                         if (muffled) 
[17:43:37.823]                           invokeRestart("muffleMessage")
[17:43:37.823]                       }
[17:43:37.823]                       else if (inherits(cond, "warning")) {
[17:43:37.823]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:37.823]                         if (muffled) 
[17:43:37.823]                           invokeRestart("muffleWarning")
[17:43:37.823]                       }
[17:43:37.823]                       else if (inherits(cond, "condition")) {
[17:43:37.823]                         if (!is.null(pattern)) {
[17:43:37.823]                           computeRestarts <- base::computeRestarts
[17:43:37.823]                           grepl <- base::grepl
[17:43:37.823]                           restarts <- computeRestarts(cond)
[17:43:37.823]                           for (restart in restarts) {
[17:43:37.823]                             name <- restart$name
[17:43:37.823]                             if (is.null(name)) 
[17:43:37.823]                               next
[17:43:37.823]                             if (!grepl(pattern, name)) 
[17:43:37.823]                               next
[17:43:37.823]                             invokeRestart(restart)
[17:43:37.823]                             muffled <- TRUE
[17:43:37.823]                             break
[17:43:37.823]                           }
[17:43:37.823]                         }
[17:43:37.823]                       }
[17:43:37.823]                       invisible(muffled)
[17:43:37.823]                     }
[17:43:37.823]                     muffleCondition(cond, pattern = "^muffle")
[17:43:37.823]                   }
[17:43:37.823]                 }
[17:43:37.823]             }
[17:43:37.823]         }))
[17:43:37.823]     }, error = function(ex) {
[17:43:37.823]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:37.823]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:37.823]                 ...future.rng), started = ...future.startTime, 
[17:43:37.823]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:37.823]             version = "1.8"), class = "FutureResult")
[17:43:37.823]     }, finally = {
[17:43:37.823]         if (!identical(...future.workdir, getwd())) 
[17:43:37.823]             setwd(...future.workdir)
[17:43:37.823]         {
[17:43:37.823]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:37.823]                 ...future.oldOptions$nwarnings <- NULL
[17:43:37.823]             }
[17:43:37.823]             base::options(...future.oldOptions)
[17:43:37.823]             if (.Platform$OS.type == "windows") {
[17:43:37.823]                 old_names <- names(...future.oldEnvVars)
[17:43:37.823]                 envs <- base::Sys.getenv()
[17:43:37.823]                 names <- names(envs)
[17:43:37.823]                 common <- intersect(names, old_names)
[17:43:37.823]                 added <- setdiff(names, old_names)
[17:43:37.823]                 removed <- setdiff(old_names, names)
[17:43:37.823]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:37.823]                   envs[common]]
[17:43:37.823]                 NAMES <- toupper(changed)
[17:43:37.823]                 args <- list()
[17:43:37.823]                 for (kk in seq_along(NAMES)) {
[17:43:37.823]                   name <- changed[[kk]]
[17:43:37.823]                   NAME <- NAMES[[kk]]
[17:43:37.823]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:37.823]                     next
[17:43:37.823]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:37.823]                 }
[17:43:37.823]                 NAMES <- toupper(added)
[17:43:37.823]                 for (kk in seq_along(NAMES)) {
[17:43:37.823]                   name <- added[[kk]]
[17:43:37.823]                   NAME <- NAMES[[kk]]
[17:43:37.823]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:37.823]                     next
[17:43:37.823]                   args[[name]] <- ""
[17:43:37.823]                 }
[17:43:37.823]                 NAMES <- toupper(removed)
[17:43:37.823]                 for (kk in seq_along(NAMES)) {
[17:43:37.823]                   name <- removed[[kk]]
[17:43:37.823]                   NAME <- NAMES[[kk]]
[17:43:37.823]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:37.823]                     next
[17:43:37.823]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:37.823]                 }
[17:43:37.823]                 if (length(args) > 0) 
[17:43:37.823]                   base::do.call(base::Sys.setenv, args = args)
[17:43:37.823]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:37.823]             }
[17:43:37.823]             else {
[17:43:37.823]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:37.823]             }
[17:43:37.823]             {
[17:43:37.823]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:37.823]                   0L) {
[17:43:37.823]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:37.823]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:37.823]                   base::options(opts)
[17:43:37.823]                 }
[17:43:37.823]                 {
[17:43:37.823]                   {
[17:43:37.823]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:37.823]                     NULL
[17:43:37.823]                   }
[17:43:37.823]                   options(future.plan = NULL)
[17:43:37.823]                   if (is.na(NA_character_)) 
[17:43:37.823]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:37.823]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:37.823]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:37.823]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:37.823]                     envir = parent.frame()) 
[17:43:37.823]                   {
[17:43:37.823]                     if (is.function(workers)) 
[17:43:37.823]                       workers <- workers()
[17:43:37.823]                     workers <- structure(as.integer(workers), 
[17:43:37.823]                       class = class(workers))
[17:43:37.823]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:37.823]                       workers >= 1)
[17:43:37.823]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:37.823]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:37.823]                     }
[17:43:37.823]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:37.823]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:37.823]                       envir = envir)
[17:43:37.823]                     if (!future$lazy) 
[17:43:37.823]                       future <- run(future)
[17:43:37.823]                     invisible(future)
[17:43:37.823]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:37.823]                 }
[17:43:37.823]             }
[17:43:37.823]         }
[17:43:37.823]     })
[17:43:37.823]     if (TRUE) {
[17:43:37.823]         base::sink(type = "output", split = FALSE)
[17:43:37.823]         if (TRUE) {
[17:43:37.823]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:37.823]         }
[17:43:37.823]         else {
[17:43:37.823]             ...future.result["stdout"] <- base::list(NULL)
[17:43:37.823]         }
[17:43:37.823]         base::close(...future.stdout)
[17:43:37.823]         ...future.stdout <- NULL
[17:43:37.823]     }
[17:43:37.823]     ...future.result$conditions <- ...future.conditions
[17:43:37.823]     ...future.result$finished <- base::Sys.time()
[17:43:37.823]     ...future.result
[17:43:37.823] }
[17:43:37.827] MultisessionFuture started
[17:43:37.827] - Launch lazy future ... done
[17:43:37.827] run() for ‘MultisessionFuture’ ... done
[17:43:38.377] receiveMessageFromWorker() for ClusterFuture ...
[17:43:38.377] - Validating connection of MultisessionFuture
[17:43:38.378] - received message: FutureResult
[17:43:38.378] - Received FutureResult
[17:43:38.378] - Erased future from FutureRegistry
[17:43:38.378] result() for ClusterFuture ...
[17:43:38.378] - result already collected: FutureResult
[17:43:38.378] result() for ClusterFuture ... done
[17:43:38.378] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:38.378] A MultisessionFuture was resolved (result was not collected)
[17:43:38.379] getGlobalsAndPackages() ...
[17:43:38.379] Searching for globals...
[17:43:38.380] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:43:38.380] Searching for globals ... DONE
[17:43:38.380] Resolving globals: FALSE
[17:43:38.381] 
[17:43:38.381] 
[17:43:38.381] getGlobalsAndPackages() ... DONE
[17:43:38.381] run() for ‘Future’ ...
[17:43:38.382] - state: ‘created’
[17:43:38.382] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:38.397] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:38.397] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:38.397]   - Field: ‘node’
[17:43:38.397]   - Field: ‘label’
[17:43:38.397]   - Field: ‘local’
[17:43:38.397]   - Field: ‘owner’
[17:43:38.397]   - Field: ‘envir’
[17:43:38.398]   - Field: ‘workers’
[17:43:38.398]   - Field: ‘packages’
[17:43:38.398]   - Field: ‘gc’
[17:43:38.398]   - Field: ‘conditions’
[17:43:38.398]   - Field: ‘persistent’
[17:43:38.398]   - Field: ‘expr’
[17:43:38.398]   - Field: ‘uuid’
[17:43:38.398]   - Field: ‘seed’
[17:43:38.398]   - Field: ‘version’
[17:43:38.399]   - Field: ‘result’
[17:43:38.399]   - Field: ‘asynchronous’
[17:43:38.399]   - Field: ‘calls’
[17:43:38.399]   - Field: ‘globals’
[17:43:38.399]   - Field: ‘stdout’
[17:43:38.399]   - Field: ‘earlySignal’
[17:43:38.399]   - Field: ‘lazy’
[17:43:38.399]   - Field: ‘state’
[17:43:38.400] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:38.400] - Launch lazy future ...
[17:43:38.400] Packages needed by the future expression (n = 0): <none>
[17:43:38.400] Packages needed by future strategies (n = 0): <none>
[17:43:38.401] {
[17:43:38.401]     {
[17:43:38.401]         {
[17:43:38.401]             ...future.startTime <- base::Sys.time()
[17:43:38.401]             {
[17:43:38.401]                 {
[17:43:38.401]                   {
[17:43:38.401]                     {
[17:43:38.401]                       base::local({
[17:43:38.401]                         has_future <- base::requireNamespace("future", 
[17:43:38.401]                           quietly = TRUE)
[17:43:38.401]                         if (has_future) {
[17:43:38.401]                           ns <- base::getNamespace("future")
[17:43:38.401]                           version <- ns[[".package"]][["version"]]
[17:43:38.401]                           if (is.null(version)) 
[17:43:38.401]                             version <- utils::packageVersion("future")
[17:43:38.401]                         }
[17:43:38.401]                         else {
[17:43:38.401]                           version <- NULL
[17:43:38.401]                         }
[17:43:38.401]                         if (!has_future || version < "1.8.0") {
[17:43:38.401]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:38.401]                             "", base::R.version$version.string), 
[17:43:38.401]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:38.401]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:38.401]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:38.401]                               "release", "version")], collapse = " "), 
[17:43:38.401]                             hostname = base::Sys.info()[["nodename"]])
[17:43:38.401]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:38.401]                             info)
[17:43:38.401]                           info <- base::paste(info, collapse = "; ")
[17:43:38.401]                           if (!has_future) {
[17:43:38.401]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:38.401]                               info)
[17:43:38.401]                           }
[17:43:38.401]                           else {
[17:43:38.401]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:38.401]                               info, version)
[17:43:38.401]                           }
[17:43:38.401]                           base::stop(msg)
[17:43:38.401]                         }
[17:43:38.401]                       })
[17:43:38.401]                     }
[17:43:38.401]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:38.401]                     base::options(mc.cores = 1L)
[17:43:38.401]                   }
[17:43:38.401]                   options(future.plan = NULL)
[17:43:38.401]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:38.401]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:38.401]                 }
[17:43:38.401]                 ...future.workdir <- getwd()
[17:43:38.401]             }
[17:43:38.401]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:38.401]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:38.401]         }
[17:43:38.401]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:38.401]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:38.401]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:38.401]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:38.401]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:38.401]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:38.401]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:38.401]             base::names(...future.oldOptions))
[17:43:38.401]     }
[17:43:38.401]     if (FALSE) {
[17:43:38.401]     }
[17:43:38.401]     else {
[17:43:38.401]         if (TRUE) {
[17:43:38.401]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:38.401]                 open = "w")
[17:43:38.401]         }
[17:43:38.401]         else {
[17:43:38.401]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:38.401]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:38.401]         }
[17:43:38.401]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:38.401]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:38.401]             base::sink(type = "output", split = FALSE)
[17:43:38.401]             base::close(...future.stdout)
[17:43:38.401]         }, add = TRUE)
[17:43:38.401]     }
[17:43:38.401]     ...future.frame <- base::sys.nframe()
[17:43:38.401]     ...future.conditions <- base::list()
[17:43:38.401]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:38.401]     if (FALSE) {
[17:43:38.401]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:38.401]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:38.401]     }
[17:43:38.401]     ...future.result <- base::tryCatch({
[17:43:38.401]         base::withCallingHandlers({
[17:43:38.401]             ...future.value <- base::withVisible(base::local({
[17:43:38.401]                 ...future.makeSendCondition <- local({
[17:43:38.401]                   sendCondition <- NULL
[17:43:38.401]                   function(frame = 1L) {
[17:43:38.401]                     if (is.function(sendCondition)) 
[17:43:38.401]                       return(sendCondition)
[17:43:38.401]                     ns <- getNamespace("parallel")
[17:43:38.401]                     if (exists("sendData", mode = "function", 
[17:43:38.401]                       envir = ns)) {
[17:43:38.401]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:38.401]                         envir = ns)
[17:43:38.401]                       envir <- sys.frame(frame)
[17:43:38.401]                       master <- NULL
[17:43:38.401]                       while (!identical(envir, .GlobalEnv) && 
[17:43:38.401]                         !identical(envir, emptyenv())) {
[17:43:38.401]                         if (exists("master", mode = "list", envir = envir, 
[17:43:38.401]                           inherits = FALSE)) {
[17:43:38.401]                           master <- get("master", mode = "list", 
[17:43:38.401]                             envir = envir, inherits = FALSE)
[17:43:38.401]                           if (inherits(master, c("SOCKnode", 
[17:43:38.401]                             "SOCK0node"))) {
[17:43:38.401]                             sendCondition <<- function(cond) {
[17:43:38.401]                               data <- list(type = "VALUE", value = cond, 
[17:43:38.401]                                 success = TRUE)
[17:43:38.401]                               parallel_sendData(master, data)
[17:43:38.401]                             }
[17:43:38.401]                             return(sendCondition)
[17:43:38.401]                           }
[17:43:38.401]                         }
[17:43:38.401]                         frame <- frame + 1L
[17:43:38.401]                         envir <- sys.frame(frame)
[17:43:38.401]                       }
[17:43:38.401]                     }
[17:43:38.401]                     sendCondition <<- function(cond) NULL
[17:43:38.401]                   }
[17:43:38.401]                 })
[17:43:38.401]                 withCallingHandlers({
[17:43:38.401]                   {
[17:43:38.401]                     Sys.sleep(0.5)
[17:43:38.401]                     list(a = 1, b = 42L)
[17:43:38.401]                   }
[17:43:38.401]                 }, immediateCondition = function(cond) {
[17:43:38.401]                   sendCondition <- ...future.makeSendCondition()
[17:43:38.401]                   sendCondition(cond)
[17:43:38.401]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:38.401]                   {
[17:43:38.401]                     inherits <- base::inherits
[17:43:38.401]                     invokeRestart <- base::invokeRestart
[17:43:38.401]                     is.null <- base::is.null
[17:43:38.401]                     muffled <- FALSE
[17:43:38.401]                     if (inherits(cond, "message")) {
[17:43:38.401]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:38.401]                       if (muffled) 
[17:43:38.401]                         invokeRestart("muffleMessage")
[17:43:38.401]                     }
[17:43:38.401]                     else if (inherits(cond, "warning")) {
[17:43:38.401]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:38.401]                       if (muffled) 
[17:43:38.401]                         invokeRestart("muffleWarning")
[17:43:38.401]                     }
[17:43:38.401]                     else if (inherits(cond, "condition")) {
[17:43:38.401]                       if (!is.null(pattern)) {
[17:43:38.401]                         computeRestarts <- base::computeRestarts
[17:43:38.401]                         grepl <- base::grepl
[17:43:38.401]                         restarts <- computeRestarts(cond)
[17:43:38.401]                         for (restart in restarts) {
[17:43:38.401]                           name <- restart$name
[17:43:38.401]                           if (is.null(name)) 
[17:43:38.401]                             next
[17:43:38.401]                           if (!grepl(pattern, name)) 
[17:43:38.401]                             next
[17:43:38.401]                           invokeRestart(restart)
[17:43:38.401]                           muffled <- TRUE
[17:43:38.401]                           break
[17:43:38.401]                         }
[17:43:38.401]                       }
[17:43:38.401]                     }
[17:43:38.401]                     invisible(muffled)
[17:43:38.401]                   }
[17:43:38.401]                   muffleCondition(cond)
[17:43:38.401]                 })
[17:43:38.401]             }))
[17:43:38.401]             future::FutureResult(value = ...future.value$value, 
[17:43:38.401]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:38.401]                   ...future.rng), globalenv = if (FALSE) 
[17:43:38.401]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:38.401]                     ...future.globalenv.names))
[17:43:38.401]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:38.401]         }, condition = base::local({
[17:43:38.401]             c <- base::c
[17:43:38.401]             inherits <- base::inherits
[17:43:38.401]             invokeRestart <- base::invokeRestart
[17:43:38.401]             length <- base::length
[17:43:38.401]             list <- base::list
[17:43:38.401]             seq.int <- base::seq.int
[17:43:38.401]             signalCondition <- base::signalCondition
[17:43:38.401]             sys.calls <- base::sys.calls
[17:43:38.401]             `[[` <- base::`[[`
[17:43:38.401]             `+` <- base::`+`
[17:43:38.401]             `<<-` <- base::`<<-`
[17:43:38.401]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:38.401]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:38.401]                   3L)]
[17:43:38.401]             }
[17:43:38.401]             function(cond) {
[17:43:38.401]                 is_error <- inherits(cond, "error")
[17:43:38.401]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:38.401]                   NULL)
[17:43:38.401]                 if (is_error) {
[17:43:38.401]                   sessionInformation <- function() {
[17:43:38.401]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:38.401]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:38.401]                       search = base::search(), system = base::Sys.info())
[17:43:38.401]                   }
[17:43:38.401]                   ...future.conditions[[length(...future.conditions) + 
[17:43:38.401]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:38.401]                     cond$call), session = sessionInformation(), 
[17:43:38.401]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:38.401]                   signalCondition(cond)
[17:43:38.401]                 }
[17:43:38.401]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:38.401]                 "immediateCondition"))) {
[17:43:38.401]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:38.401]                   ...future.conditions[[length(...future.conditions) + 
[17:43:38.401]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:38.401]                   if (TRUE && !signal) {
[17:43:38.401]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:38.401]                     {
[17:43:38.401]                       inherits <- base::inherits
[17:43:38.401]                       invokeRestart <- base::invokeRestart
[17:43:38.401]                       is.null <- base::is.null
[17:43:38.401]                       muffled <- FALSE
[17:43:38.401]                       if (inherits(cond, "message")) {
[17:43:38.401]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:38.401]                         if (muffled) 
[17:43:38.401]                           invokeRestart("muffleMessage")
[17:43:38.401]                       }
[17:43:38.401]                       else if (inherits(cond, "warning")) {
[17:43:38.401]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:38.401]                         if (muffled) 
[17:43:38.401]                           invokeRestart("muffleWarning")
[17:43:38.401]                       }
[17:43:38.401]                       else if (inherits(cond, "condition")) {
[17:43:38.401]                         if (!is.null(pattern)) {
[17:43:38.401]                           computeRestarts <- base::computeRestarts
[17:43:38.401]                           grepl <- base::grepl
[17:43:38.401]                           restarts <- computeRestarts(cond)
[17:43:38.401]                           for (restart in restarts) {
[17:43:38.401]                             name <- restart$name
[17:43:38.401]                             if (is.null(name)) 
[17:43:38.401]                               next
[17:43:38.401]                             if (!grepl(pattern, name)) 
[17:43:38.401]                               next
[17:43:38.401]                             invokeRestart(restart)
[17:43:38.401]                             muffled <- TRUE
[17:43:38.401]                             break
[17:43:38.401]                           }
[17:43:38.401]                         }
[17:43:38.401]                       }
[17:43:38.401]                       invisible(muffled)
[17:43:38.401]                     }
[17:43:38.401]                     muffleCondition(cond, pattern = "^muffle")
[17:43:38.401]                   }
[17:43:38.401]                 }
[17:43:38.401]                 else {
[17:43:38.401]                   if (TRUE) {
[17:43:38.401]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:38.401]                     {
[17:43:38.401]                       inherits <- base::inherits
[17:43:38.401]                       invokeRestart <- base::invokeRestart
[17:43:38.401]                       is.null <- base::is.null
[17:43:38.401]                       muffled <- FALSE
[17:43:38.401]                       if (inherits(cond, "message")) {
[17:43:38.401]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:38.401]                         if (muffled) 
[17:43:38.401]                           invokeRestart("muffleMessage")
[17:43:38.401]                       }
[17:43:38.401]                       else if (inherits(cond, "warning")) {
[17:43:38.401]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:38.401]                         if (muffled) 
[17:43:38.401]                           invokeRestart("muffleWarning")
[17:43:38.401]                       }
[17:43:38.401]                       else if (inherits(cond, "condition")) {
[17:43:38.401]                         if (!is.null(pattern)) {
[17:43:38.401]                           computeRestarts <- base::computeRestarts
[17:43:38.401]                           grepl <- base::grepl
[17:43:38.401]                           restarts <- computeRestarts(cond)
[17:43:38.401]                           for (restart in restarts) {
[17:43:38.401]                             name <- restart$name
[17:43:38.401]                             if (is.null(name)) 
[17:43:38.401]                               next
[17:43:38.401]                             if (!grepl(pattern, name)) 
[17:43:38.401]                               next
[17:43:38.401]                             invokeRestart(restart)
[17:43:38.401]                             muffled <- TRUE
[17:43:38.401]                             break
[17:43:38.401]                           }
[17:43:38.401]                         }
[17:43:38.401]                       }
[17:43:38.401]                       invisible(muffled)
[17:43:38.401]                     }
[17:43:38.401]                     muffleCondition(cond, pattern = "^muffle")
[17:43:38.401]                   }
[17:43:38.401]                 }
[17:43:38.401]             }
[17:43:38.401]         }))
[17:43:38.401]     }, error = function(ex) {
[17:43:38.401]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:38.401]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:38.401]                 ...future.rng), started = ...future.startTime, 
[17:43:38.401]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:38.401]             version = "1.8"), class = "FutureResult")
[17:43:38.401]     }, finally = {
[17:43:38.401]         if (!identical(...future.workdir, getwd())) 
[17:43:38.401]             setwd(...future.workdir)
[17:43:38.401]         {
[17:43:38.401]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:38.401]                 ...future.oldOptions$nwarnings <- NULL
[17:43:38.401]             }
[17:43:38.401]             base::options(...future.oldOptions)
[17:43:38.401]             if (.Platform$OS.type == "windows") {
[17:43:38.401]                 old_names <- names(...future.oldEnvVars)
[17:43:38.401]                 envs <- base::Sys.getenv()
[17:43:38.401]                 names <- names(envs)
[17:43:38.401]                 common <- intersect(names, old_names)
[17:43:38.401]                 added <- setdiff(names, old_names)
[17:43:38.401]                 removed <- setdiff(old_names, names)
[17:43:38.401]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:38.401]                   envs[common]]
[17:43:38.401]                 NAMES <- toupper(changed)
[17:43:38.401]                 args <- list()
[17:43:38.401]                 for (kk in seq_along(NAMES)) {
[17:43:38.401]                   name <- changed[[kk]]
[17:43:38.401]                   NAME <- NAMES[[kk]]
[17:43:38.401]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:38.401]                     next
[17:43:38.401]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:38.401]                 }
[17:43:38.401]                 NAMES <- toupper(added)
[17:43:38.401]                 for (kk in seq_along(NAMES)) {
[17:43:38.401]                   name <- added[[kk]]
[17:43:38.401]                   NAME <- NAMES[[kk]]
[17:43:38.401]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:38.401]                     next
[17:43:38.401]                   args[[name]] <- ""
[17:43:38.401]                 }
[17:43:38.401]                 NAMES <- toupper(removed)
[17:43:38.401]                 for (kk in seq_along(NAMES)) {
[17:43:38.401]                   name <- removed[[kk]]
[17:43:38.401]                   NAME <- NAMES[[kk]]
[17:43:38.401]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:38.401]                     next
[17:43:38.401]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:38.401]                 }
[17:43:38.401]                 if (length(args) > 0) 
[17:43:38.401]                   base::do.call(base::Sys.setenv, args = args)
[17:43:38.401]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:38.401]             }
[17:43:38.401]             else {
[17:43:38.401]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:38.401]             }
[17:43:38.401]             {
[17:43:38.401]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:38.401]                   0L) {
[17:43:38.401]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:38.401]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:38.401]                   base::options(opts)
[17:43:38.401]                 }
[17:43:38.401]                 {
[17:43:38.401]                   {
[17:43:38.401]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:38.401]                     NULL
[17:43:38.401]                   }
[17:43:38.401]                   options(future.plan = NULL)
[17:43:38.401]                   if (is.na(NA_character_)) 
[17:43:38.401]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:38.401]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:38.401]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:38.401]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:38.401]                     envir = parent.frame()) 
[17:43:38.401]                   {
[17:43:38.401]                     if (is.function(workers)) 
[17:43:38.401]                       workers <- workers()
[17:43:38.401]                     workers <- structure(as.integer(workers), 
[17:43:38.401]                       class = class(workers))
[17:43:38.401]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:38.401]                       workers >= 1)
[17:43:38.401]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:38.401]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:38.401]                     }
[17:43:38.401]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:38.401]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:38.401]                       envir = envir)
[17:43:38.401]                     if (!future$lazy) 
[17:43:38.401]                       future <- run(future)
[17:43:38.401]                     invisible(future)
[17:43:38.401]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:38.401]                 }
[17:43:38.401]             }
[17:43:38.401]         }
[17:43:38.401]     })
[17:43:38.401]     if (TRUE) {
[17:43:38.401]         base::sink(type = "output", split = FALSE)
[17:43:38.401]         if (TRUE) {
[17:43:38.401]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:38.401]         }
[17:43:38.401]         else {
[17:43:38.401]             ...future.result["stdout"] <- base::list(NULL)
[17:43:38.401]         }
[17:43:38.401]         base::close(...future.stdout)
[17:43:38.401]         ...future.stdout <- NULL
[17:43:38.401]     }
[17:43:38.401]     ...future.result$conditions <- ...future.conditions
[17:43:38.401]     ...future.result$finished <- base::Sys.time()
[17:43:38.401]     ...future.result
[17:43:38.401] }
[17:43:38.404] MultisessionFuture started
[17:43:38.405] - Launch lazy future ... done
[17:43:38.405] run() for ‘MultisessionFuture’ ... done
[17:43:38.953] receiveMessageFromWorker() for ClusterFuture ...
[17:43:38.953] - Validating connection of MultisessionFuture
[17:43:38.954] - received message: FutureResult
[17:43:38.954] - Received FutureResult
[17:43:38.954] - Erased future from FutureRegistry
[17:43:38.954] result() for ClusterFuture ...
[17:43:38.954] - result already collected: FutureResult
[17:43:38.954] result() for ClusterFuture ... done
[17:43:38.955] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:38.955] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[17:43:38.955] getGlobalsAndPackages() ...
[17:43:38.955] Searching for globals...
[17:43:38.956] - globals found: [2] ‘list’, ‘stop’
[17:43:38.956] Searching for globals ... DONE
[17:43:38.956] Resolving globals: FALSE
[17:43:38.957] 
[17:43:38.957] 
[17:43:38.957] getGlobalsAndPackages() ... DONE
[17:43:38.957] run() for ‘Future’ ...
[17:43:38.957] - state: ‘created’
[17:43:38.957] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:38.974] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:38.974] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:38.974]   - Field: ‘node’
[17:43:38.974]   - Field: ‘label’
[17:43:38.975]   - Field: ‘local’
[17:43:38.975]   - Field: ‘owner’
[17:43:38.975]   - Field: ‘envir’
[17:43:38.975]   - Field: ‘workers’
[17:43:38.975]   - Field: ‘packages’
[17:43:38.975]   - Field: ‘gc’
[17:43:38.975]   - Field: ‘conditions’
[17:43:38.975]   - Field: ‘persistent’
[17:43:38.975]   - Field: ‘expr’
[17:43:38.975]   - Field: ‘uuid’
[17:43:38.975]   - Field: ‘seed’
[17:43:38.976]   - Field: ‘version’
[17:43:38.976]   - Field: ‘result’
[17:43:38.976]   - Field: ‘asynchronous’
[17:43:38.976]   - Field: ‘calls’
[17:43:38.976]   - Field: ‘globals’
[17:43:38.976]   - Field: ‘stdout’
[17:43:38.976]   - Field: ‘earlySignal’
[17:43:38.976]   - Field: ‘lazy’
[17:43:38.976]   - Field: ‘state’
[17:43:38.976] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:38.976] - Launch lazy future ...
[17:43:38.977] Packages needed by the future expression (n = 0): <none>
[17:43:38.977] Packages needed by future strategies (n = 0): <none>
[17:43:38.977] {
[17:43:38.977]     {
[17:43:38.977]         {
[17:43:38.977]             ...future.startTime <- base::Sys.time()
[17:43:38.977]             {
[17:43:38.977]                 {
[17:43:38.977]                   {
[17:43:38.977]                     {
[17:43:38.977]                       base::local({
[17:43:38.977]                         has_future <- base::requireNamespace("future", 
[17:43:38.977]                           quietly = TRUE)
[17:43:38.977]                         if (has_future) {
[17:43:38.977]                           ns <- base::getNamespace("future")
[17:43:38.977]                           version <- ns[[".package"]][["version"]]
[17:43:38.977]                           if (is.null(version)) 
[17:43:38.977]                             version <- utils::packageVersion("future")
[17:43:38.977]                         }
[17:43:38.977]                         else {
[17:43:38.977]                           version <- NULL
[17:43:38.977]                         }
[17:43:38.977]                         if (!has_future || version < "1.8.0") {
[17:43:38.977]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:38.977]                             "", base::R.version$version.string), 
[17:43:38.977]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:38.977]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:38.977]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:38.977]                               "release", "version")], collapse = " "), 
[17:43:38.977]                             hostname = base::Sys.info()[["nodename"]])
[17:43:38.977]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:38.977]                             info)
[17:43:38.977]                           info <- base::paste(info, collapse = "; ")
[17:43:38.977]                           if (!has_future) {
[17:43:38.977]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:38.977]                               info)
[17:43:38.977]                           }
[17:43:38.977]                           else {
[17:43:38.977]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:38.977]                               info, version)
[17:43:38.977]                           }
[17:43:38.977]                           base::stop(msg)
[17:43:38.977]                         }
[17:43:38.977]                       })
[17:43:38.977]                     }
[17:43:38.977]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:38.977]                     base::options(mc.cores = 1L)
[17:43:38.977]                   }
[17:43:38.977]                   options(future.plan = NULL)
[17:43:38.977]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:38.977]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:38.977]                 }
[17:43:38.977]                 ...future.workdir <- getwd()
[17:43:38.977]             }
[17:43:38.977]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:38.977]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:38.977]         }
[17:43:38.977]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:38.977]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:38.977]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:38.977]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:38.977]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:38.977]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:38.977]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:38.977]             base::names(...future.oldOptions))
[17:43:38.977]     }
[17:43:38.977]     if (FALSE) {
[17:43:38.977]     }
[17:43:38.977]     else {
[17:43:38.977]         if (TRUE) {
[17:43:38.977]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:38.977]                 open = "w")
[17:43:38.977]         }
[17:43:38.977]         else {
[17:43:38.977]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:38.977]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:38.977]         }
[17:43:38.977]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:38.977]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:38.977]             base::sink(type = "output", split = FALSE)
[17:43:38.977]             base::close(...future.stdout)
[17:43:38.977]         }, add = TRUE)
[17:43:38.977]     }
[17:43:38.977]     ...future.frame <- base::sys.nframe()
[17:43:38.977]     ...future.conditions <- base::list()
[17:43:38.977]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:38.977]     if (FALSE) {
[17:43:38.977]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:38.977]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:38.977]     }
[17:43:38.977]     ...future.result <- base::tryCatch({
[17:43:38.977]         base::withCallingHandlers({
[17:43:38.977]             ...future.value <- base::withVisible(base::local({
[17:43:38.977]                 ...future.makeSendCondition <- local({
[17:43:38.977]                   sendCondition <- NULL
[17:43:38.977]                   function(frame = 1L) {
[17:43:38.977]                     if (is.function(sendCondition)) 
[17:43:38.977]                       return(sendCondition)
[17:43:38.977]                     ns <- getNamespace("parallel")
[17:43:38.977]                     if (exists("sendData", mode = "function", 
[17:43:38.977]                       envir = ns)) {
[17:43:38.977]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:38.977]                         envir = ns)
[17:43:38.977]                       envir <- sys.frame(frame)
[17:43:38.977]                       master <- NULL
[17:43:38.977]                       while (!identical(envir, .GlobalEnv) && 
[17:43:38.977]                         !identical(envir, emptyenv())) {
[17:43:38.977]                         if (exists("master", mode = "list", envir = envir, 
[17:43:38.977]                           inherits = FALSE)) {
[17:43:38.977]                           master <- get("master", mode = "list", 
[17:43:38.977]                             envir = envir, inherits = FALSE)
[17:43:38.977]                           if (inherits(master, c("SOCKnode", 
[17:43:38.977]                             "SOCK0node"))) {
[17:43:38.977]                             sendCondition <<- function(cond) {
[17:43:38.977]                               data <- list(type = "VALUE", value = cond, 
[17:43:38.977]                                 success = TRUE)
[17:43:38.977]                               parallel_sendData(master, data)
[17:43:38.977]                             }
[17:43:38.977]                             return(sendCondition)
[17:43:38.977]                           }
[17:43:38.977]                         }
[17:43:38.977]                         frame <- frame + 1L
[17:43:38.977]                         envir <- sys.frame(frame)
[17:43:38.977]                       }
[17:43:38.977]                     }
[17:43:38.977]                     sendCondition <<- function(cond) NULL
[17:43:38.977]                   }
[17:43:38.977]                 })
[17:43:38.977]                 withCallingHandlers({
[17:43:38.977]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:43:38.977]                 }, immediateCondition = function(cond) {
[17:43:38.977]                   sendCondition <- ...future.makeSendCondition()
[17:43:38.977]                   sendCondition(cond)
[17:43:38.977]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:38.977]                   {
[17:43:38.977]                     inherits <- base::inherits
[17:43:38.977]                     invokeRestart <- base::invokeRestart
[17:43:38.977]                     is.null <- base::is.null
[17:43:38.977]                     muffled <- FALSE
[17:43:38.977]                     if (inherits(cond, "message")) {
[17:43:38.977]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:38.977]                       if (muffled) 
[17:43:38.977]                         invokeRestart("muffleMessage")
[17:43:38.977]                     }
[17:43:38.977]                     else if (inherits(cond, "warning")) {
[17:43:38.977]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:38.977]                       if (muffled) 
[17:43:38.977]                         invokeRestart("muffleWarning")
[17:43:38.977]                     }
[17:43:38.977]                     else if (inherits(cond, "condition")) {
[17:43:38.977]                       if (!is.null(pattern)) {
[17:43:38.977]                         computeRestarts <- base::computeRestarts
[17:43:38.977]                         grepl <- base::grepl
[17:43:38.977]                         restarts <- computeRestarts(cond)
[17:43:38.977]                         for (restart in restarts) {
[17:43:38.977]                           name <- restart$name
[17:43:38.977]                           if (is.null(name)) 
[17:43:38.977]                             next
[17:43:38.977]                           if (!grepl(pattern, name)) 
[17:43:38.977]                             next
[17:43:38.977]                           invokeRestart(restart)
[17:43:38.977]                           muffled <- TRUE
[17:43:38.977]                           break
[17:43:38.977]                         }
[17:43:38.977]                       }
[17:43:38.977]                     }
[17:43:38.977]                     invisible(muffled)
[17:43:38.977]                   }
[17:43:38.977]                   muffleCondition(cond)
[17:43:38.977]                 })
[17:43:38.977]             }))
[17:43:38.977]             future::FutureResult(value = ...future.value$value, 
[17:43:38.977]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:38.977]                   ...future.rng), globalenv = if (FALSE) 
[17:43:38.977]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:38.977]                     ...future.globalenv.names))
[17:43:38.977]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:38.977]         }, condition = base::local({
[17:43:38.977]             c <- base::c
[17:43:38.977]             inherits <- base::inherits
[17:43:38.977]             invokeRestart <- base::invokeRestart
[17:43:38.977]             length <- base::length
[17:43:38.977]             list <- base::list
[17:43:38.977]             seq.int <- base::seq.int
[17:43:38.977]             signalCondition <- base::signalCondition
[17:43:38.977]             sys.calls <- base::sys.calls
[17:43:38.977]             `[[` <- base::`[[`
[17:43:38.977]             `+` <- base::`+`
[17:43:38.977]             `<<-` <- base::`<<-`
[17:43:38.977]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:38.977]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:38.977]                   3L)]
[17:43:38.977]             }
[17:43:38.977]             function(cond) {
[17:43:38.977]                 is_error <- inherits(cond, "error")
[17:43:38.977]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:38.977]                   NULL)
[17:43:38.977]                 if (is_error) {
[17:43:38.977]                   sessionInformation <- function() {
[17:43:38.977]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:38.977]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:38.977]                       search = base::search(), system = base::Sys.info())
[17:43:38.977]                   }
[17:43:38.977]                   ...future.conditions[[length(...future.conditions) + 
[17:43:38.977]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:38.977]                     cond$call), session = sessionInformation(), 
[17:43:38.977]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:38.977]                   signalCondition(cond)
[17:43:38.977]                 }
[17:43:38.977]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:38.977]                 "immediateCondition"))) {
[17:43:38.977]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:38.977]                   ...future.conditions[[length(...future.conditions) + 
[17:43:38.977]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:38.977]                   if (TRUE && !signal) {
[17:43:38.977]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:38.977]                     {
[17:43:38.977]                       inherits <- base::inherits
[17:43:38.977]                       invokeRestart <- base::invokeRestart
[17:43:38.977]                       is.null <- base::is.null
[17:43:38.977]                       muffled <- FALSE
[17:43:38.977]                       if (inherits(cond, "message")) {
[17:43:38.977]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:38.977]                         if (muffled) 
[17:43:38.977]                           invokeRestart("muffleMessage")
[17:43:38.977]                       }
[17:43:38.977]                       else if (inherits(cond, "warning")) {
[17:43:38.977]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:38.977]                         if (muffled) 
[17:43:38.977]                           invokeRestart("muffleWarning")
[17:43:38.977]                       }
[17:43:38.977]                       else if (inherits(cond, "condition")) {
[17:43:38.977]                         if (!is.null(pattern)) {
[17:43:38.977]                           computeRestarts <- base::computeRestarts
[17:43:38.977]                           grepl <- base::grepl
[17:43:38.977]                           restarts <- computeRestarts(cond)
[17:43:38.977]                           for (restart in restarts) {
[17:43:38.977]                             name <- restart$name
[17:43:38.977]                             if (is.null(name)) 
[17:43:38.977]                               next
[17:43:38.977]                             if (!grepl(pattern, name)) 
[17:43:38.977]                               next
[17:43:38.977]                             invokeRestart(restart)
[17:43:38.977]                             muffled <- TRUE
[17:43:38.977]                             break
[17:43:38.977]                           }
[17:43:38.977]                         }
[17:43:38.977]                       }
[17:43:38.977]                       invisible(muffled)
[17:43:38.977]                     }
[17:43:38.977]                     muffleCondition(cond, pattern = "^muffle")
[17:43:38.977]                   }
[17:43:38.977]                 }
[17:43:38.977]                 else {
[17:43:38.977]                   if (TRUE) {
[17:43:38.977]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:38.977]                     {
[17:43:38.977]                       inherits <- base::inherits
[17:43:38.977]                       invokeRestart <- base::invokeRestart
[17:43:38.977]                       is.null <- base::is.null
[17:43:38.977]                       muffled <- FALSE
[17:43:38.977]                       if (inherits(cond, "message")) {
[17:43:38.977]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:38.977]                         if (muffled) 
[17:43:38.977]                           invokeRestart("muffleMessage")
[17:43:38.977]                       }
[17:43:38.977]                       else if (inherits(cond, "warning")) {
[17:43:38.977]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:38.977]                         if (muffled) 
[17:43:38.977]                           invokeRestart("muffleWarning")
[17:43:38.977]                       }
[17:43:38.977]                       else if (inherits(cond, "condition")) {
[17:43:38.977]                         if (!is.null(pattern)) {
[17:43:38.977]                           computeRestarts <- base::computeRestarts
[17:43:38.977]                           grepl <- base::grepl
[17:43:38.977]                           restarts <- computeRestarts(cond)
[17:43:38.977]                           for (restart in restarts) {
[17:43:38.977]                             name <- restart$name
[17:43:38.977]                             if (is.null(name)) 
[17:43:38.977]                               next
[17:43:38.977]                             if (!grepl(pattern, name)) 
[17:43:38.977]                               next
[17:43:38.977]                             invokeRestart(restart)
[17:43:38.977]                             muffled <- TRUE
[17:43:38.977]                             break
[17:43:38.977]                           }
[17:43:38.977]                         }
[17:43:38.977]                       }
[17:43:38.977]                       invisible(muffled)
[17:43:38.977]                     }
[17:43:38.977]                     muffleCondition(cond, pattern = "^muffle")
[17:43:38.977]                   }
[17:43:38.977]                 }
[17:43:38.977]             }
[17:43:38.977]         }))
[17:43:38.977]     }, error = function(ex) {
[17:43:38.977]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:38.977]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:38.977]                 ...future.rng), started = ...future.startTime, 
[17:43:38.977]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:38.977]             version = "1.8"), class = "FutureResult")
[17:43:38.977]     }, finally = {
[17:43:38.977]         if (!identical(...future.workdir, getwd())) 
[17:43:38.977]             setwd(...future.workdir)
[17:43:38.977]         {
[17:43:38.977]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:38.977]                 ...future.oldOptions$nwarnings <- NULL
[17:43:38.977]             }
[17:43:38.977]             base::options(...future.oldOptions)
[17:43:38.977]             if (.Platform$OS.type == "windows") {
[17:43:38.977]                 old_names <- names(...future.oldEnvVars)
[17:43:38.977]                 envs <- base::Sys.getenv()
[17:43:38.977]                 names <- names(envs)
[17:43:38.977]                 common <- intersect(names, old_names)
[17:43:38.977]                 added <- setdiff(names, old_names)
[17:43:38.977]                 removed <- setdiff(old_names, names)
[17:43:38.977]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:38.977]                   envs[common]]
[17:43:38.977]                 NAMES <- toupper(changed)
[17:43:38.977]                 args <- list()
[17:43:38.977]                 for (kk in seq_along(NAMES)) {
[17:43:38.977]                   name <- changed[[kk]]
[17:43:38.977]                   NAME <- NAMES[[kk]]
[17:43:38.977]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:38.977]                     next
[17:43:38.977]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:38.977]                 }
[17:43:38.977]                 NAMES <- toupper(added)
[17:43:38.977]                 for (kk in seq_along(NAMES)) {
[17:43:38.977]                   name <- added[[kk]]
[17:43:38.977]                   NAME <- NAMES[[kk]]
[17:43:38.977]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:38.977]                     next
[17:43:38.977]                   args[[name]] <- ""
[17:43:38.977]                 }
[17:43:38.977]                 NAMES <- toupper(removed)
[17:43:38.977]                 for (kk in seq_along(NAMES)) {
[17:43:38.977]                   name <- removed[[kk]]
[17:43:38.977]                   NAME <- NAMES[[kk]]
[17:43:38.977]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:38.977]                     next
[17:43:38.977]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:38.977]                 }
[17:43:38.977]                 if (length(args) > 0) 
[17:43:38.977]                   base::do.call(base::Sys.setenv, args = args)
[17:43:38.977]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:38.977]             }
[17:43:38.977]             else {
[17:43:38.977]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:38.977]             }
[17:43:38.977]             {
[17:43:38.977]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:38.977]                   0L) {
[17:43:38.977]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:38.977]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:38.977]                   base::options(opts)
[17:43:38.977]                 }
[17:43:38.977]                 {
[17:43:38.977]                   {
[17:43:38.977]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:38.977]                     NULL
[17:43:38.977]                   }
[17:43:38.977]                   options(future.plan = NULL)
[17:43:38.977]                   if (is.na(NA_character_)) 
[17:43:38.977]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:38.977]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:38.977]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:38.977]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:38.977]                     envir = parent.frame()) 
[17:43:38.977]                   {
[17:43:38.977]                     if (is.function(workers)) 
[17:43:38.977]                       workers <- workers()
[17:43:38.977]                     workers <- structure(as.integer(workers), 
[17:43:38.977]                       class = class(workers))
[17:43:38.977]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:38.977]                       workers >= 1)
[17:43:38.977]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:38.977]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:38.977]                     }
[17:43:38.977]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:38.977]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:38.977]                       envir = envir)
[17:43:38.977]                     if (!future$lazy) 
[17:43:38.977]                       future <- run(future)
[17:43:38.977]                     invisible(future)
[17:43:38.977]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:38.977]                 }
[17:43:38.977]             }
[17:43:38.977]         }
[17:43:38.977]     })
[17:43:38.977]     if (TRUE) {
[17:43:38.977]         base::sink(type = "output", split = FALSE)
[17:43:38.977]         if (TRUE) {
[17:43:38.977]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:38.977]         }
[17:43:38.977]         else {
[17:43:38.977]             ...future.result["stdout"] <- base::list(NULL)
[17:43:38.977]         }
[17:43:38.977]         base::close(...future.stdout)
[17:43:38.977]         ...future.stdout <- NULL
[17:43:38.977]     }
[17:43:38.977]     ...future.result$conditions <- ...future.conditions
[17:43:38.977]     ...future.result$finished <- base::Sys.time()
[17:43:38.977]     ...future.result
[17:43:38.977] }
[17:43:38.980] MultisessionFuture started
[17:43:38.980] - Launch lazy future ... done
[17:43:38.981] run() for ‘MultisessionFuture’ ... done
[17:43:39.028] receiveMessageFromWorker() for ClusterFuture ...
[17:43:39.028] - Validating connection of MultisessionFuture
[17:43:39.029] - received message: FutureResult
[17:43:39.029] - Received FutureResult
[17:43:39.029] - Erased future from FutureRegistry
[17:43:39.029] result() for ClusterFuture ...
[17:43:39.029] - result already collected: FutureResult
[17:43:39.029] result() for ClusterFuture ... done
[17:43:39.030] signalConditions() ...
[17:43:39.030]  - include = ‘immediateCondition’
[17:43:39.030]  - exclude = 
[17:43:39.030]  - resignal = FALSE
[17:43:39.030]  - Number of conditions: 1
[17:43:39.030] signalConditions() ... done
[17:43:39.030] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:39.030] A MultisessionFuture was resolved (result was not collected)
[17:43:39.030] getGlobalsAndPackages() ...
[17:43:39.030] Searching for globals...
[17:43:39.031] - globals found: [2] ‘list’, ‘stop’
[17:43:39.031] Searching for globals ... DONE
[17:43:39.031] Resolving globals: FALSE
[17:43:39.032] 
[17:43:39.032] 
[17:43:39.032] getGlobalsAndPackages() ... DONE
[17:43:39.032] run() for ‘Future’ ...
[17:43:39.032] - state: ‘created’
[17:43:39.032] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:39.047] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:39.047] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:39.047]   - Field: ‘node’
[17:43:39.047]   - Field: ‘label’
[17:43:39.047]   - Field: ‘local’
[17:43:39.047]   - Field: ‘owner’
[17:43:39.048]   - Field: ‘envir’
[17:43:39.048]   - Field: ‘workers’
[17:43:39.048]   - Field: ‘packages’
[17:43:39.048]   - Field: ‘gc’
[17:43:39.048]   - Field: ‘conditions’
[17:43:39.048]   - Field: ‘persistent’
[17:43:39.048]   - Field: ‘expr’
[17:43:39.048]   - Field: ‘uuid’
[17:43:39.048]   - Field: ‘seed’
[17:43:39.048]   - Field: ‘version’
[17:43:39.048]   - Field: ‘result’
[17:43:39.048]   - Field: ‘asynchronous’
[17:43:39.049]   - Field: ‘calls’
[17:43:39.049]   - Field: ‘globals’
[17:43:39.049]   - Field: ‘stdout’
[17:43:39.049]   - Field: ‘earlySignal’
[17:43:39.049]   - Field: ‘lazy’
[17:43:39.049]   - Field: ‘state’
[17:43:39.049] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:39.049] - Launch lazy future ...
[17:43:39.050] Packages needed by the future expression (n = 0): <none>
[17:43:39.050] Packages needed by future strategies (n = 0): <none>
[17:43:39.050] {
[17:43:39.050]     {
[17:43:39.050]         {
[17:43:39.050]             ...future.startTime <- base::Sys.time()
[17:43:39.050]             {
[17:43:39.050]                 {
[17:43:39.050]                   {
[17:43:39.050]                     {
[17:43:39.050]                       base::local({
[17:43:39.050]                         has_future <- base::requireNamespace("future", 
[17:43:39.050]                           quietly = TRUE)
[17:43:39.050]                         if (has_future) {
[17:43:39.050]                           ns <- base::getNamespace("future")
[17:43:39.050]                           version <- ns[[".package"]][["version"]]
[17:43:39.050]                           if (is.null(version)) 
[17:43:39.050]                             version <- utils::packageVersion("future")
[17:43:39.050]                         }
[17:43:39.050]                         else {
[17:43:39.050]                           version <- NULL
[17:43:39.050]                         }
[17:43:39.050]                         if (!has_future || version < "1.8.0") {
[17:43:39.050]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:39.050]                             "", base::R.version$version.string), 
[17:43:39.050]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:39.050]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:39.050]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:39.050]                               "release", "version")], collapse = " "), 
[17:43:39.050]                             hostname = base::Sys.info()[["nodename"]])
[17:43:39.050]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:39.050]                             info)
[17:43:39.050]                           info <- base::paste(info, collapse = "; ")
[17:43:39.050]                           if (!has_future) {
[17:43:39.050]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:39.050]                               info)
[17:43:39.050]                           }
[17:43:39.050]                           else {
[17:43:39.050]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:39.050]                               info, version)
[17:43:39.050]                           }
[17:43:39.050]                           base::stop(msg)
[17:43:39.050]                         }
[17:43:39.050]                       })
[17:43:39.050]                     }
[17:43:39.050]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:39.050]                     base::options(mc.cores = 1L)
[17:43:39.050]                   }
[17:43:39.050]                   options(future.plan = NULL)
[17:43:39.050]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:39.050]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:39.050]                 }
[17:43:39.050]                 ...future.workdir <- getwd()
[17:43:39.050]             }
[17:43:39.050]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:39.050]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:39.050]         }
[17:43:39.050]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:39.050]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:39.050]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:39.050]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:39.050]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:39.050]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:39.050]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:39.050]             base::names(...future.oldOptions))
[17:43:39.050]     }
[17:43:39.050]     if (FALSE) {
[17:43:39.050]     }
[17:43:39.050]     else {
[17:43:39.050]         if (TRUE) {
[17:43:39.050]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:39.050]                 open = "w")
[17:43:39.050]         }
[17:43:39.050]         else {
[17:43:39.050]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:39.050]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:39.050]         }
[17:43:39.050]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:39.050]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:39.050]             base::sink(type = "output", split = FALSE)
[17:43:39.050]             base::close(...future.stdout)
[17:43:39.050]         }, add = TRUE)
[17:43:39.050]     }
[17:43:39.050]     ...future.frame <- base::sys.nframe()
[17:43:39.050]     ...future.conditions <- base::list()
[17:43:39.050]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:39.050]     if (FALSE) {
[17:43:39.050]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:39.050]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:39.050]     }
[17:43:39.050]     ...future.result <- base::tryCatch({
[17:43:39.050]         base::withCallingHandlers({
[17:43:39.050]             ...future.value <- base::withVisible(base::local({
[17:43:39.050]                 ...future.makeSendCondition <- local({
[17:43:39.050]                   sendCondition <- NULL
[17:43:39.050]                   function(frame = 1L) {
[17:43:39.050]                     if (is.function(sendCondition)) 
[17:43:39.050]                       return(sendCondition)
[17:43:39.050]                     ns <- getNamespace("parallel")
[17:43:39.050]                     if (exists("sendData", mode = "function", 
[17:43:39.050]                       envir = ns)) {
[17:43:39.050]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:39.050]                         envir = ns)
[17:43:39.050]                       envir <- sys.frame(frame)
[17:43:39.050]                       master <- NULL
[17:43:39.050]                       while (!identical(envir, .GlobalEnv) && 
[17:43:39.050]                         !identical(envir, emptyenv())) {
[17:43:39.050]                         if (exists("master", mode = "list", envir = envir, 
[17:43:39.050]                           inherits = FALSE)) {
[17:43:39.050]                           master <- get("master", mode = "list", 
[17:43:39.050]                             envir = envir, inherits = FALSE)
[17:43:39.050]                           if (inherits(master, c("SOCKnode", 
[17:43:39.050]                             "SOCK0node"))) {
[17:43:39.050]                             sendCondition <<- function(cond) {
[17:43:39.050]                               data <- list(type = "VALUE", value = cond, 
[17:43:39.050]                                 success = TRUE)
[17:43:39.050]                               parallel_sendData(master, data)
[17:43:39.050]                             }
[17:43:39.050]                             return(sendCondition)
[17:43:39.050]                           }
[17:43:39.050]                         }
[17:43:39.050]                         frame <- frame + 1L
[17:43:39.050]                         envir <- sys.frame(frame)
[17:43:39.050]                       }
[17:43:39.050]                     }
[17:43:39.050]                     sendCondition <<- function(cond) NULL
[17:43:39.050]                   }
[17:43:39.050]                 })
[17:43:39.050]                 withCallingHandlers({
[17:43:39.050]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:43:39.050]                 }, immediateCondition = function(cond) {
[17:43:39.050]                   sendCondition <- ...future.makeSendCondition()
[17:43:39.050]                   sendCondition(cond)
[17:43:39.050]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:39.050]                   {
[17:43:39.050]                     inherits <- base::inherits
[17:43:39.050]                     invokeRestart <- base::invokeRestart
[17:43:39.050]                     is.null <- base::is.null
[17:43:39.050]                     muffled <- FALSE
[17:43:39.050]                     if (inherits(cond, "message")) {
[17:43:39.050]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:39.050]                       if (muffled) 
[17:43:39.050]                         invokeRestart("muffleMessage")
[17:43:39.050]                     }
[17:43:39.050]                     else if (inherits(cond, "warning")) {
[17:43:39.050]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:39.050]                       if (muffled) 
[17:43:39.050]                         invokeRestart("muffleWarning")
[17:43:39.050]                     }
[17:43:39.050]                     else if (inherits(cond, "condition")) {
[17:43:39.050]                       if (!is.null(pattern)) {
[17:43:39.050]                         computeRestarts <- base::computeRestarts
[17:43:39.050]                         grepl <- base::grepl
[17:43:39.050]                         restarts <- computeRestarts(cond)
[17:43:39.050]                         for (restart in restarts) {
[17:43:39.050]                           name <- restart$name
[17:43:39.050]                           if (is.null(name)) 
[17:43:39.050]                             next
[17:43:39.050]                           if (!grepl(pattern, name)) 
[17:43:39.050]                             next
[17:43:39.050]                           invokeRestart(restart)
[17:43:39.050]                           muffled <- TRUE
[17:43:39.050]                           break
[17:43:39.050]                         }
[17:43:39.050]                       }
[17:43:39.050]                     }
[17:43:39.050]                     invisible(muffled)
[17:43:39.050]                   }
[17:43:39.050]                   muffleCondition(cond)
[17:43:39.050]                 })
[17:43:39.050]             }))
[17:43:39.050]             future::FutureResult(value = ...future.value$value, 
[17:43:39.050]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:39.050]                   ...future.rng), globalenv = if (FALSE) 
[17:43:39.050]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:39.050]                     ...future.globalenv.names))
[17:43:39.050]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:39.050]         }, condition = base::local({
[17:43:39.050]             c <- base::c
[17:43:39.050]             inherits <- base::inherits
[17:43:39.050]             invokeRestart <- base::invokeRestart
[17:43:39.050]             length <- base::length
[17:43:39.050]             list <- base::list
[17:43:39.050]             seq.int <- base::seq.int
[17:43:39.050]             signalCondition <- base::signalCondition
[17:43:39.050]             sys.calls <- base::sys.calls
[17:43:39.050]             `[[` <- base::`[[`
[17:43:39.050]             `+` <- base::`+`
[17:43:39.050]             `<<-` <- base::`<<-`
[17:43:39.050]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:39.050]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:39.050]                   3L)]
[17:43:39.050]             }
[17:43:39.050]             function(cond) {
[17:43:39.050]                 is_error <- inherits(cond, "error")
[17:43:39.050]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:39.050]                   NULL)
[17:43:39.050]                 if (is_error) {
[17:43:39.050]                   sessionInformation <- function() {
[17:43:39.050]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:39.050]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:39.050]                       search = base::search(), system = base::Sys.info())
[17:43:39.050]                   }
[17:43:39.050]                   ...future.conditions[[length(...future.conditions) + 
[17:43:39.050]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:39.050]                     cond$call), session = sessionInformation(), 
[17:43:39.050]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:39.050]                   signalCondition(cond)
[17:43:39.050]                 }
[17:43:39.050]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:39.050]                 "immediateCondition"))) {
[17:43:39.050]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:39.050]                   ...future.conditions[[length(...future.conditions) + 
[17:43:39.050]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:39.050]                   if (TRUE && !signal) {
[17:43:39.050]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:39.050]                     {
[17:43:39.050]                       inherits <- base::inherits
[17:43:39.050]                       invokeRestart <- base::invokeRestart
[17:43:39.050]                       is.null <- base::is.null
[17:43:39.050]                       muffled <- FALSE
[17:43:39.050]                       if (inherits(cond, "message")) {
[17:43:39.050]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:39.050]                         if (muffled) 
[17:43:39.050]                           invokeRestart("muffleMessage")
[17:43:39.050]                       }
[17:43:39.050]                       else if (inherits(cond, "warning")) {
[17:43:39.050]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:39.050]                         if (muffled) 
[17:43:39.050]                           invokeRestart("muffleWarning")
[17:43:39.050]                       }
[17:43:39.050]                       else if (inherits(cond, "condition")) {
[17:43:39.050]                         if (!is.null(pattern)) {
[17:43:39.050]                           computeRestarts <- base::computeRestarts
[17:43:39.050]                           grepl <- base::grepl
[17:43:39.050]                           restarts <- computeRestarts(cond)
[17:43:39.050]                           for (restart in restarts) {
[17:43:39.050]                             name <- restart$name
[17:43:39.050]                             if (is.null(name)) 
[17:43:39.050]                               next
[17:43:39.050]                             if (!grepl(pattern, name)) 
[17:43:39.050]                               next
[17:43:39.050]                             invokeRestart(restart)
[17:43:39.050]                             muffled <- TRUE
[17:43:39.050]                             break
[17:43:39.050]                           }
[17:43:39.050]                         }
[17:43:39.050]                       }
[17:43:39.050]                       invisible(muffled)
[17:43:39.050]                     }
[17:43:39.050]                     muffleCondition(cond, pattern = "^muffle")
[17:43:39.050]                   }
[17:43:39.050]                 }
[17:43:39.050]                 else {
[17:43:39.050]                   if (TRUE) {
[17:43:39.050]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:39.050]                     {
[17:43:39.050]                       inherits <- base::inherits
[17:43:39.050]                       invokeRestart <- base::invokeRestart
[17:43:39.050]                       is.null <- base::is.null
[17:43:39.050]                       muffled <- FALSE
[17:43:39.050]                       if (inherits(cond, "message")) {
[17:43:39.050]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:39.050]                         if (muffled) 
[17:43:39.050]                           invokeRestart("muffleMessage")
[17:43:39.050]                       }
[17:43:39.050]                       else if (inherits(cond, "warning")) {
[17:43:39.050]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:39.050]                         if (muffled) 
[17:43:39.050]                           invokeRestart("muffleWarning")
[17:43:39.050]                       }
[17:43:39.050]                       else if (inherits(cond, "condition")) {
[17:43:39.050]                         if (!is.null(pattern)) {
[17:43:39.050]                           computeRestarts <- base::computeRestarts
[17:43:39.050]                           grepl <- base::grepl
[17:43:39.050]                           restarts <- computeRestarts(cond)
[17:43:39.050]                           for (restart in restarts) {
[17:43:39.050]                             name <- restart$name
[17:43:39.050]                             if (is.null(name)) 
[17:43:39.050]                               next
[17:43:39.050]                             if (!grepl(pattern, name)) 
[17:43:39.050]                               next
[17:43:39.050]                             invokeRestart(restart)
[17:43:39.050]                             muffled <- TRUE
[17:43:39.050]                             break
[17:43:39.050]                           }
[17:43:39.050]                         }
[17:43:39.050]                       }
[17:43:39.050]                       invisible(muffled)
[17:43:39.050]                     }
[17:43:39.050]                     muffleCondition(cond, pattern = "^muffle")
[17:43:39.050]                   }
[17:43:39.050]                 }
[17:43:39.050]             }
[17:43:39.050]         }))
[17:43:39.050]     }, error = function(ex) {
[17:43:39.050]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:39.050]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:39.050]                 ...future.rng), started = ...future.startTime, 
[17:43:39.050]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:39.050]             version = "1.8"), class = "FutureResult")
[17:43:39.050]     }, finally = {
[17:43:39.050]         if (!identical(...future.workdir, getwd())) 
[17:43:39.050]             setwd(...future.workdir)
[17:43:39.050]         {
[17:43:39.050]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:39.050]                 ...future.oldOptions$nwarnings <- NULL
[17:43:39.050]             }
[17:43:39.050]             base::options(...future.oldOptions)
[17:43:39.050]             if (.Platform$OS.type == "windows") {
[17:43:39.050]                 old_names <- names(...future.oldEnvVars)
[17:43:39.050]                 envs <- base::Sys.getenv()
[17:43:39.050]                 names <- names(envs)
[17:43:39.050]                 common <- intersect(names, old_names)
[17:43:39.050]                 added <- setdiff(names, old_names)
[17:43:39.050]                 removed <- setdiff(old_names, names)
[17:43:39.050]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:39.050]                   envs[common]]
[17:43:39.050]                 NAMES <- toupper(changed)
[17:43:39.050]                 args <- list()
[17:43:39.050]                 for (kk in seq_along(NAMES)) {
[17:43:39.050]                   name <- changed[[kk]]
[17:43:39.050]                   NAME <- NAMES[[kk]]
[17:43:39.050]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:39.050]                     next
[17:43:39.050]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:39.050]                 }
[17:43:39.050]                 NAMES <- toupper(added)
[17:43:39.050]                 for (kk in seq_along(NAMES)) {
[17:43:39.050]                   name <- added[[kk]]
[17:43:39.050]                   NAME <- NAMES[[kk]]
[17:43:39.050]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:39.050]                     next
[17:43:39.050]                   args[[name]] <- ""
[17:43:39.050]                 }
[17:43:39.050]                 NAMES <- toupper(removed)
[17:43:39.050]                 for (kk in seq_along(NAMES)) {
[17:43:39.050]                   name <- removed[[kk]]
[17:43:39.050]                   NAME <- NAMES[[kk]]
[17:43:39.050]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:39.050]                     next
[17:43:39.050]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:39.050]                 }
[17:43:39.050]                 if (length(args) > 0) 
[17:43:39.050]                   base::do.call(base::Sys.setenv, args = args)
[17:43:39.050]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:39.050]             }
[17:43:39.050]             else {
[17:43:39.050]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:39.050]             }
[17:43:39.050]             {
[17:43:39.050]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:39.050]                   0L) {
[17:43:39.050]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:39.050]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:39.050]                   base::options(opts)
[17:43:39.050]                 }
[17:43:39.050]                 {
[17:43:39.050]                   {
[17:43:39.050]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:39.050]                     NULL
[17:43:39.050]                   }
[17:43:39.050]                   options(future.plan = NULL)
[17:43:39.050]                   if (is.na(NA_character_)) 
[17:43:39.050]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:39.050]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:39.050]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:39.050]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:39.050]                     envir = parent.frame()) 
[17:43:39.050]                   {
[17:43:39.050]                     if (is.function(workers)) 
[17:43:39.050]                       workers <- workers()
[17:43:39.050]                     workers <- structure(as.integer(workers), 
[17:43:39.050]                       class = class(workers))
[17:43:39.050]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:39.050]                       workers >= 1)
[17:43:39.050]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:39.050]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:39.050]                     }
[17:43:39.050]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:39.050]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:39.050]                       envir = envir)
[17:43:39.050]                     if (!future$lazy) 
[17:43:39.050]                       future <- run(future)
[17:43:39.050]                     invisible(future)
[17:43:39.050]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:39.050]                 }
[17:43:39.050]             }
[17:43:39.050]         }
[17:43:39.050]     })
[17:43:39.050]     if (TRUE) {
[17:43:39.050]         base::sink(type = "output", split = FALSE)
[17:43:39.050]         if (TRUE) {
[17:43:39.050]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:39.050]         }
[17:43:39.050]         else {
[17:43:39.050]             ...future.result["stdout"] <- base::list(NULL)
[17:43:39.050]         }
[17:43:39.050]         base::close(...future.stdout)
[17:43:39.050]         ...future.stdout <- NULL
[17:43:39.050]     }
[17:43:39.050]     ...future.result$conditions <- ...future.conditions
[17:43:39.050]     ...future.result$finished <- base::Sys.time()
[17:43:39.050]     ...future.result
[17:43:39.050] }
[17:43:39.054] MultisessionFuture started
[17:43:39.054] - Launch lazy future ... done
[17:43:39.054] run() for ‘MultisessionFuture’ ... done
[17:43:39.100] receiveMessageFromWorker() for ClusterFuture ...
[17:43:39.100] - Validating connection of MultisessionFuture
[17:43:39.101] - received message: FutureResult
[17:43:39.101] - Received FutureResult
[17:43:39.101] - Erased future from FutureRegistry
[17:43:39.101] result() for ClusterFuture ...
[17:43:39.101] - result already collected: FutureResult
[17:43:39.101] result() for ClusterFuture ... done
[17:43:39.102] signalConditions() ...
[17:43:39.102]  - include = ‘immediateCondition’
[17:43:39.102]  - exclude = 
[17:43:39.102]  - resignal = FALSE
[17:43:39.102]  - Number of conditions: 1
[17:43:39.102] signalConditions() ... done
[17:43:39.102] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:39.102] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = FALSE ... DONE
- result = FALSE, recursive = TRUE ...
[17:43:39.102] getGlobalsAndPackages() ...
[17:43:39.103] Searching for globals...
[17:43:39.104] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:43:39.104] Searching for globals ... DONE
[17:43:39.104] Resolving globals: FALSE
[17:43:39.104] 
[17:43:39.105] 
[17:43:39.105] getGlobalsAndPackages() ... DONE
[17:43:39.105] run() for ‘Future’ ...
[17:43:39.105] - state: ‘created’
[17:43:39.105] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:39.120] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:39.120] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:39.120]   - Field: ‘node’
[17:43:39.120]   - Field: ‘label’
[17:43:39.121]   - Field: ‘local’
[17:43:39.121]   - Field: ‘owner’
[17:43:39.121]   - Field: ‘envir’
[17:43:39.121]   - Field: ‘workers’
[17:43:39.121]   - Field: ‘packages’
[17:43:39.121]   - Field: ‘gc’
[17:43:39.121]   - Field: ‘conditions’
[17:43:39.121]   - Field: ‘persistent’
[17:43:39.121]   - Field: ‘expr’
[17:43:39.121]   - Field: ‘uuid’
[17:43:39.121]   - Field: ‘seed’
[17:43:39.122]   - Field: ‘version’
[17:43:39.122]   - Field: ‘result’
[17:43:39.122]   - Field: ‘asynchronous’
[17:43:39.122]   - Field: ‘calls’
[17:43:39.122]   - Field: ‘globals’
[17:43:39.122]   - Field: ‘stdout’
[17:43:39.122]   - Field: ‘earlySignal’
[17:43:39.122]   - Field: ‘lazy’
[17:43:39.122]   - Field: ‘state’
[17:43:39.122] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:39.123] - Launch lazy future ...
[17:43:39.123] Packages needed by the future expression (n = 0): <none>
[17:43:39.123] Packages needed by future strategies (n = 0): <none>
[17:43:39.123] {
[17:43:39.123]     {
[17:43:39.123]         {
[17:43:39.123]             ...future.startTime <- base::Sys.time()
[17:43:39.123]             {
[17:43:39.123]                 {
[17:43:39.123]                   {
[17:43:39.123]                     {
[17:43:39.123]                       base::local({
[17:43:39.123]                         has_future <- base::requireNamespace("future", 
[17:43:39.123]                           quietly = TRUE)
[17:43:39.123]                         if (has_future) {
[17:43:39.123]                           ns <- base::getNamespace("future")
[17:43:39.123]                           version <- ns[[".package"]][["version"]]
[17:43:39.123]                           if (is.null(version)) 
[17:43:39.123]                             version <- utils::packageVersion("future")
[17:43:39.123]                         }
[17:43:39.123]                         else {
[17:43:39.123]                           version <- NULL
[17:43:39.123]                         }
[17:43:39.123]                         if (!has_future || version < "1.8.0") {
[17:43:39.123]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:39.123]                             "", base::R.version$version.string), 
[17:43:39.123]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:39.123]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:39.123]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:39.123]                               "release", "version")], collapse = " "), 
[17:43:39.123]                             hostname = base::Sys.info()[["nodename"]])
[17:43:39.123]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:39.123]                             info)
[17:43:39.123]                           info <- base::paste(info, collapse = "; ")
[17:43:39.123]                           if (!has_future) {
[17:43:39.123]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:39.123]                               info)
[17:43:39.123]                           }
[17:43:39.123]                           else {
[17:43:39.123]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:39.123]                               info, version)
[17:43:39.123]                           }
[17:43:39.123]                           base::stop(msg)
[17:43:39.123]                         }
[17:43:39.123]                       })
[17:43:39.123]                     }
[17:43:39.123]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:39.123]                     base::options(mc.cores = 1L)
[17:43:39.123]                   }
[17:43:39.123]                   options(future.plan = NULL)
[17:43:39.123]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:39.123]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:39.123]                 }
[17:43:39.123]                 ...future.workdir <- getwd()
[17:43:39.123]             }
[17:43:39.123]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:39.123]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:39.123]         }
[17:43:39.123]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:39.123]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:39.123]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:39.123]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:39.123]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:39.123]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:39.123]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:39.123]             base::names(...future.oldOptions))
[17:43:39.123]     }
[17:43:39.123]     if (FALSE) {
[17:43:39.123]     }
[17:43:39.123]     else {
[17:43:39.123]         if (TRUE) {
[17:43:39.123]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:39.123]                 open = "w")
[17:43:39.123]         }
[17:43:39.123]         else {
[17:43:39.123]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:39.123]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:39.123]         }
[17:43:39.123]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:39.123]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:39.123]             base::sink(type = "output", split = FALSE)
[17:43:39.123]             base::close(...future.stdout)
[17:43:39.123]         }, add = TRUE)
[17:43:39.123]     }
[17:43:39.123]     ...future.frame <- base::sys.nframe()
[17:43:39.123]     ...future.conditions <- base::list()
[17:43:39.123]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:39.123]     if (FALSE) {
[17:43:39.123]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:39.123]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:39.123]     }
[17:43:39.123]     ...future.result <- base::tryCatch({
[17:43:39.123]         base::withCallingHandlers({
[17:43:39.123]             ...future.value <- base::withVisible(base::local({
[17:43:39.123]                 ...future.makeSendCondition <- local({
[17:43:39.123]                   sendCondition <- NULL
[17:43:39.123]                   function(frame = 1L) {
[17:43:39.123]                     if (is.function(sendCondition)) 
[17:43:39.123]                       return(sendCondition)
[17:43:39.123]                     ns <- getNamespace("parallel")
[17:43:39.123]                     if (exists("sendData", mode = "function", 
[17:43:39.123]                       envir = ns)) {
[17:43:39.123]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:39.123]                         envir = ns)
[17:43:39.123]                       envir <- sys.frame(frame)
[17:43:39.123]                       master <- NULL
[17:43:39.123]                       while (!identical(envir, .GlobalEnv) && 
[17:43:39.123]                         !identical(envir, emptyenv())) {
[17:43:39.123]                         if (exists("master", mode = "list", envir = envir, 
[17:43:39.123]                           inherits = FALSE)) {
[17:43:39.123]                           master <- get("master", mode = "list", 
[17:43:39.123]                             envir = envir, inherits = FALSE)
[17:43:39.123]                           if (inherits(master, c("SOCKnode", 
[17:43:39.123]                             "SOCK0node"))) {
[17:43:39.123]                             sendCondition <<- function(cond) {
[17:43:39.123]                               data <- list(type = "VALUE", value = cond, 
[17:43:39.123]                                 success = TRUE)
[17:43:39.123]                               parallel_sendData(master, data)
[17:43:39.123]                             }
[17:43:39.123]                             return(sendCondition)
[17:43:39.123]                           }
[17:43:39.123]                         }
[17:43:39.123]                         frame <- frame + 1L
[17:43:39.123]                         envir <- sys.frame(frame)
[17:43:39.123]                       }
[17:43:39.123]                     }
[17:43:39.123]                     sendCondition <<- function(cond) NULL
[17:43:39.123]                   }
[17:43:39.123]                 })
[17:43:39.123]                 withCallingHandlers({
[17:43:39.123]                   {
[17:43:39.123]                     Sys.sleep(0.5)
[17:43:39.123]                     list(a = 1, b = 42L)
[17:43:39.123]                   }
[17:43:39.123]                 }, immediateCondition = function(cond) {
[17:43:39.123]                   sendCondition <- ...future.makeSendCondition()
[17:43:39.123]                   sendCondition(cond)
[17:43:39.123]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:39.123]                   {
[17:43:39.123]                     inherits <- base::inherits
[17:43:39.123]                     invokeRestart <- base::invokeRestart
[17:43:39.123]                     is.null <- base::is.null
[17:43:39.123]                     muffled <- FALSE
[17:43:39.123]                     if (inherits(cond, "message")) {
[17:43:39.123]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:39.123]                       if (muffled) 
[17:43:39.123]                         invokeRestart("muffleMessage")
[17:43:39.123]                     }
[17:43:39.123]                     else if (inherits(cond, "warning")) {
[17:43:39.123]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:39.123]                       if (muffled) 
[17:43:39.123]                         invokeRestart("muffleWarning")
[17:43:39.123]                     }
[17:43:39.123]                     else if (inherits(cond, "condition")) {
[17:43:39.123]                       if (!is.null(pattern)) {
[17:43:39.123]                         computeRestarts <- base::computeRestarts
[17:43:39.123]                         grepl <- base::grepl
[17:43:39.123]                         restarts <- computeRestarts(cond)
[17:43:39.123]                         for (restart in restarts) {
[17:43:39.123]                           name <- restart$name
[17:43:39.123]                           if (is.null(name)) 
[17:43:39.123]                             next
[17:43:39.123]                           if (!grepl(pattern, name)) 
[17:43:39.123]                             next
[17:43:39.123]                           invokeRestart(restart)
[17:43:39.123]                           muffled <- TRUE
[17:43:39.123]                           break
[17:43:39.123]                         }
[17:43:39.123]                       }
[17:43:39.123]                     }
[17:43:39.123]                     invisible(muffled)
[17:43:39.123]                   }
[17:43:39.123]                   muffleCondition(cond)
[17:43:39.123]                 })
[17:43:39.123]             }))
[17:43:39.123]             future::FutureResult(value = ...future.value$value, 
[17:43:39.123]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:39.123]                   ...future.rng), globalenv = if (FALSE) 
[17:43:39.123]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:39.123]                     ...future.globalenv.names))
[17:43:39.123]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:39.123]         }, condition = base::local({
[17:43:39.123]             c <- base::c
[17:43:39.123]             inherits <- base::inherits
[17:43:39.123]             invokeRestart <- base::invokeRestart
[17:43:39.123]             length <- base::length
[17:43:39.123]             list <- base::list
[17:43:39.123]             seq.int <- base::seq.int
[17:43:39.123]             signalCondition <- base::signalCondition
[17:43:39.123]             sys.calls <- base::sys.calls
[17:43:39.123]             `[[` <- base::`[[`
[17:43:39.123]             `+` <- base::`+`
[17:43:39.123]             `<<-` <- base::`<<-`
[17:43:39.123]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:39.123]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:39.123]                   3L)]
[17:43:39.123]             }
[17:43:39.123]             function(cond) {
[17:43:39.123]                 is_error <- inherits(cond, "error")
[17:43:39.123]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:39.123]                   NULL)
[17:43:39.123]                 if (is_error) {
[17:43:39.123]                   sessionInformation <- function() {
[17:43:39.123]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:39.123]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:39.123]                       search = base::search(), system = base::Sys.info())
[17:43:39.123]                   }
[17:43:39.123]                   ...future.conditions[[length(...future.conditions) + 
[17:43:39.123]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:39.123]                     cond$call), session = sessionInformation(), 
[17:43:39.123]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:39.123]                   signalCondition(cond)
[17:43:39.123]                 }
[17:43:39.123]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:39.123]                 "immediateCondition"))) {
[17:43:39.123]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:39.123]                   ...future.conditions[[length(...future.conditions) + 
[17:43:39.123]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:39.123]                   if (TRUE && !signal) {
[17:43:39.123]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:39.123]                     {
[17:43:39.123]                       inherits <- base::inherits
[17:43:39.123]                       invokeRestart <- base::invokeRestart
[17:43:39.123]                       is.null <- base::is.null
[17:43:39.123]                       muffled <- FALSE
[17:43:39.123]                       if (inherits(cond, "message")) {
[17:43:39.123]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:39.123]                         if (muffled) 
[17:43:39.123]                           invokeRestart("muffleMessage")
[17:43:39.123]                       }
[17:43:39.123]                       else if (inherits(cond, "warning")) {
[17:43:39.123]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:39.123]                         if (muffled) 
[17:43:39.123]                           invokeRestart("muffleWarning")
[17:43:39.123]                       }
[17:43:39.123]                       else if (inherits(cond, "condition")) {
[17:43:39.123]                         if (!is.null(pattern)) {
[17:43:39.123]                           computeRestarts <- base::computeRestarts
[17:43:39.123]                           grepl <- base::grepl
[17:43:39.123]                           restarts <- computeRestarts(cond)
[17:43:39.123]                           for (restart in restarts) {
[17:43:39.123]                             name <- restart$name
[17:43:39.123]                             if (is.null(name)) 
[17:43:39.123]                               next
[17:43:39.123]                             if (!grepl(pattern, name)) 
[17:43:39.123]                               next
[17:43:39.123]                             invokeRestart(restart)
[17:43:39.123]                             muffled <- TRUE
[17:43:39.123]                             break
[17:43:39.123]                           }
[17:43:39.123]                         }
[17:43:39.123]                       }
[17:43:39.123]                       invisible(muffled)
[17:43:39.123]                     }
[17:43:39.123]                     muffleCondition(cond, pattern = "^muffle")
[17:43:39.123]                   }
[17:43:39.123]                 }
[17:43:39.123]                 else {
[17:43:39.123]                   if (TRUE) {
[17:43:39.123]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:39.123]                     {
[17:43:39.123]                       inherits <- base::inherits
[17:43:39.123]                       invokeRestart <- base::invokeRestart
[17:43:39.123]                       is.null <- base::is.null
[17:43:39.123]                       muffled <- FALSE
[17:43:39.123]                       if (inherits(cond, "message")) {
[17:43:39.123]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:39.123]                         if (muffled) 
[17:43:39.123]                           invokeRestart("muffleMessage")
[17:43:39.123]                       }
[17:43:39.123]                       else if (inherits(cond, "warning")) {
[17:43:39.123]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:39.123]                         if (muffled) 
[17:43:39.123]                           invokeRestart("muffleWarning")
[17:43:39.123]                       }
[17:43:39.123]                       else if (inherits(cond, "condition")) {
[17:43:39.123]                         if (!is.null(pattern)) {
[17:43:39.123]                           computeRestarts <- base::computeRestarts
[17:43:39.123]                           grepl <- base::grepl
[17:43:39.123]                           restarts <- computeRestarts(cond)
[17:43:39.123]                           for (restart in restarts) {
[17:43:39.123]                             name <- restart$name
[17:43:39.123]                             if (is.null(name)) 
[17:43:39.123]                               next
[17:43:39.123]                             if (!grepl(pattern, name)) 
[17:43:39.123]                               next
[17:43:39.123]                             invokeRestart(restart)
[17:43:39.123]                             muffled <- TRUE
[17:43:39.123]                             break
[17:43:39.123]                           }
[17:43:39.123]                         }
[17:43:39.123]                       }
[17:43:39.123]                       invisible(muffled)
[17:43:39.123]                     }
[17:43:39.123]                     muffleCondition(cond, pattern = "^muffle")
[17:43:39.123]                   }
[17:43:39.123]                 }
[17:43:39.123]             }
[17:43:39.123]         }))
[17:43:39.123]     }, error = function(ex) {
[17:43:39.123]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:39.123]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:39.123]                 ...future.rng), started = ...future.startTime, 
[17:43:39.123]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:39.123]             version = "1.8"), class = "FutureResult")
[17:43:39.123]     }, finally = {
[17:43:39.123]         if (!identical(...future.workdir, getwd())) 
[17:43:39.123]             setwd(...future.workdir)
[17:43:39.123]         {
[17:43:39.123]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:39.123]                 ...future.oldOptions$nwarnings <- NULL
[17:43:39.123]             }
[17:43:39.123]             base::options(...future.oldOptions)
[17:43:39.123]             if (.Platform$OS.type == "windows") {
[17:43:39.123]                 old_names <- names(...future.oldEnvVars)
[17:43:39.123]                 envs <- base::Sys.getenv()
[17:43:39.123]                 names <- names(envs)
[17:43:39.123]                 common <- intersect(names, old_names)
[17:43:39.123]                 added <- setdiff(names, old_names)
[17:43:39.123]                 removed <- setdiff(old_names, names)
[17:43:39.123]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:39.123]                   envs[common]]
[17:43:39.123]                 NAMES <- toupper(changed)
[17:43:39.123]                 args <- list()
[17:43:39.123]                 for (kk in seq_along(NAMES)) {
[17:43:39.123]                   name <- changed[[kk]]
[17:43:39.123]                   NAME <- NAMES[[kk]]
[17:43:39.123]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:39.123]                     next
[17:43:39.123]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:39.123]                 }
[17:43:39.123]                 NAMES <- toupper(added)
[17:43:39.123]                 for (kk in seq_along(NAMES)) {
[17:43:39.123]                   name <- added[[kk]]
[17:43:39.123]                   NAME <- NAMES[[kk]]
[17:43:39.123]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:39.123]                     next
[17:43:39.123]                   args[[name]] <- ""
[17:43:39.123]                 }
[17:43:39.123]                 NAMES <- toupper(removed)
[17:43:39.123]                 for (kk in seq_along(NAMES)) {
[17:43:39.123]                   name <- removed[[kk]]
[17:43:39.123]                   NAME <- NAMES[[kk]]
[17:43:39.123]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:39.123]                     next
[17:43:39.123]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:39.123]                 }
[17:43:39.123]                 if (length(args) > 0) 
[17:43:39.123]                   base::do.call(base::Sys.setenv, args = args)
[17:43:39.123]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:39.123]             }
[17:43:39.123]             else {
[17:43:39.123]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:39.123]             }
[17:43:39.123]             {
[17:43:39.123]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:39.123]                   0L) {
[17:43:39.123]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:39.123]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:39.123]                   base::options(opts)
[17:43:39.123]                 }
[17:43:39.123]                 {
[17:43:39.123]                   {
[17:43:39.123]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:39.123]                     NULL
[17:43:39.123]                   }
[17:43:39.123]                   options(future.plan = NULL)
[17:43:39.123]                   if (is.na(NA_character_)) 
[17:43:39.123]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:39.123]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:39.123]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:39.123]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:39.123]                     envir = parent.frame()) 
[17:43:39.123]                   {
[17:43:39.123]                     if (is.function(workers)) 
[17:43:39.123]                       workers <- workers()
[17:43:39.123]                     workers <- structure(as.integer(workers), 
[17:43:39.123]                       class = class(workers))
[17:43:39.123]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:39.123]                       workers >= 1)
[17:43:39.123]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:39.123]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:39.123]                     }
[17:43:39.123]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:39.123]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:39.123]                       envir = envir)
[17:43:39.123]                     if (!future$lazy) 
[17:43:39.123]                       future <- run(future)
[17:43:39.123]                     invisible(future)
[17:43:39.123]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:39.123]                 }
[17:43:39.123]             }
[17:43:39.123]         }
[17:43:39.123]     })
[17:43:39.123]     if (TRUE) {
[17:43:39.123]         base::sink(type = "output", split = FALSE)
[17:43:39.123]         if (TRUE) {
[17:43:39.123]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:39.123]         }
[17:43:39.123]         else {
[17:43:39.123]             ...future.result["stdout"] <- base::list(NULL)
[17:43:39.123]         }
[17:43:39.123]         base::close(...future.stdout)
[17:43:39.123]         ...future.stdout <- NULL
[17:43:39.123]     }
[17:43:39.123]     ...future.result$conditions <- ...future.conditions
[17:43:39.123]     ...future.result$finished <- base::Sys.time()
[17:43:39.123]     ...future.result
[17:43:39.123] }
[17:43:39.127] MultisessionFuture started
[17:43:39.127] - Launch lazy future ... done
[17:43:39.127] run() for ‘MultisessionFuture’ ... done
[17:43:39.673] receiveMessageFromWorker() for ClusterFuture ...
[17:43:39.673] - Validating connection of MultisessionFuture
[17:43:39.673] - received message: FutureResult
[17:43:39.673] - Received FutureResult
[17:43:39.673] - Erased future from FutureRegistry
[17:43:39.674] result() for ClusterFuture ...
[17:43:39.674] - result already collected: FutureResult
[17:43:39.674] result() for ClusterFuture ... done
[17:43:39.674] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:39.674] A MultisessionFuture was resolved (result was not collected)
[17:43:39.674] getGlobalsAndPackages() ...
[17:43:39.674] Searching for globals...
[17:43:39.675] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:43:39.675] Searching for globals ... DONE
[17:43:39.676] Resolving globals: FALSE
[17:43:39.676] 
[17:43:39.676] 
[17:43:39.676] getGlobalsAndPackages() ... DONE
[17:43:39.676] run() for ‘Future’ ...
[17:43:39.676] - state: ‘created’
[17:43:39.677] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:39.691] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:39.692] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:39.692]   - Field: ‘node’
[17:43:39.692]   - Field: ‘label’
[17:43:39.692]   - Field: ‘local’
[17:43:39.692]   - Field: ‘owner’
[17:43:39.692]   - Field: ‘envir’
[17:43:39.692]   - Field: ‘workers’
[17:43:39.693]   - Field: ‘packages’
[17:43:39.693]   - Field: ‘gc’
[17:43:39.693]   - Field: ‘conditions’
[17:43:39.693]   - Field: ‘persistent’
[17:43:39.693]   - Field: ‘expr’
[17:43:39.693]   - Field: ‘uuid’
[17:43:39.693]   - Field: ‘seed’
[17:43:39.693]   - Field: ‘version’
[17:43:39.693]   - Field: ‘result’
[17:43:39.693]   - Field: ‘asynchronous’
[17:43:39.693]   - Field: ‘calls’
[17:43:39.694]   - Field: ‘globals’
[17:43:39.694]   - Field: ‘stdout’
[17:43:39.694]   - Field: ‘earlySignal’
[17:43:39.694]   - Field: ‘lazy’
[17:43:39.694]   - Field: ‘state’
[17:43:39.694] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:39.694] - Launch lazy future ...
[17:43:39.694] Packages needed by the future expression (n = 0): <none>
[17:43:39.695] Packages needed by future strategies (n = 0): <none>
[17:43:39.695] {
[17:43:39.695]     {
[17:43:39.695]         {
[17:43:39.695]             ...future.startTime <- base::Sys.time()
[17:43:39.695]             {
[17:43:39.695]                 {
[17:43:39.695]                   {
[17:43:39.695]                     {
[17:43:39.695]                       base::local({
[17:43:39.695]                         has_future <- base::requireNamespace("future", 
[17:43:39.695]                           quietly = TRUE)
[17:43:39.695]                         if (has_future) {
[17:43:39.695]                           ns <- base::getNamespace("future")
[17:43:39.695]                           version <- ns[[".package"]][["version"]]
[17:43:39.695]                           if (is.null(version)) 
[17:43:39.695]                             version <- utils::packageVersion("future")
[17:43:39.695]                         }
[17:43:39.695]                         else {
[17:43:39.695]                           version <- NULL
[17:43:39.695]                         }
[17:43:39.695]                         if (!has_future || version < "1.8.0") {
[17:43:39.695]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:39.695]                             "", base::R.version$version.string), 
[17:43:39.695]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:39.695]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:39.695]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:39.695]                               "release", "version")], collapse = " "), 
[17:43:39.695]                             hostname = base::Sys.info()[["nodename"]])
[17:43:39.695]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:39.695]                             info)
[17:43:39.695]                           info <- base::paste(info, collapse = "; ")
[17:43:39.695]                           if (!has_future) {
[17:43:39.695]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:39.695]                               info)
[17:43:39.695]                           }
[17:43:39.695]                           else {
[17:43:39.695]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:39.695]                               info, version)
[17:43:39.695]                           }
[17:43:39.695]                           base::stop(msg)
[17:43:39.695]                         }
[17:43:39.695]                       })
[17:43:39.695]                     }
[17:43:39.695]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:39.695]                     base::options(mc.cores = 1L)
[17:43:39.695]                   }
[17:43:39.695]                   options(future.plan = NULL)
[17:43:39.695]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:39.695]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:39.695]                 }
[17:43:39.695]                 ...future.workdir <- getwd()
[17:43:39.695]             }
[17:43:39.695]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:39.695]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:39.695]         }
[17:43:39.695]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:39.695]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:39.695]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:39.695]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:39.695]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:39.695]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:39.695]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:39.695]             base::names(...future.oldOptions))
[17:43:39.695]     }
[17:43:39.695]     if (FALSE) {
[17:43:39.695]     }
[17:43:39.695]     else {
[17:43:39.695]         if (TRUE) {
[17:43:39.695]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:39.695]                 open = "w")
[17:43:39.695]         }
[17:43:39.695]         else {
[17:43:39.695]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:39.695]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:39.695]         }
[17:43:39.695]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:39.695]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:39.695]             base::sink(type = "output", split = FALSE)
[17:43:39.695]             base::close(...future.stdout)
[17:43:39.695]         }, add = TRUE)
[17:43:39.695]     }
[17:43:39.695]     ...future.frame <- base::sys.nframe()
[17:43:39.695]     ...future.conditions <- base::list()
[17:43:39.695]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:39.695]     if (FALSE) {
[17:43:39.695]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:39.695]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:39.695]     }
[17:43:39.695]     ...future.result <- base::tryCatch({
[17:43:39.695]         base::withCallingHandlers({
[17:43:39.695]             ...future.value <- base::withVisible(base::local({
[17:43:39.695]                 ...future.makeSendCondition <- local({
[17:43:39.695]                   sendCondition <- NULL
[17:43:39.695]                   function(frame = 1L) {
[17:43:39.695]                     if (is.function(sendCondition)) 
[17:43:39.695]                       return(sendCondition)
[17:43:39.695]                     ns <- getNamespace("parallel")
[17:43:39.695]                     if (exists("sendData", mode = "function", 
[17:43:39.695]                       envir = ns)) {
[17:43:39.695]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:39.695]                         envir = ns)
[17:43:39.695]                       envir <- sys.frame(frame)
[17:43:39.695]                       master <- NULL
[17:43:39.695]                       while (!identical(envir, .GlobalEnv) && 
[17:43:39.695]                         !identical(envir, emptyenv())) {
[17:43:39.695]                         if (exists("master", mode = "list", envir = envir, 
[17:43:39.695]                           inherits = FALSE)) {
[17:43:39.695]                           master <- get("master", mode = "list", 
[17:43:39.695]                             envir = envir, inherits = FALSE)
[17:43:39.695]                           if (inherits(master, c("SOCKnode", 
[17:43:39.695]                             "SOCK0node"))) {
[17:43:39.695]                             sendCondition <<- function(cond) {
[17:43:39.695]                               data <- list(type = "VALUE", value = cond, 
[17:43:39.695]                                 success = TRUE)
[17:43:39.695]                               parallel_sendData(master, data)
[17:43:39.695]                             }
[17:43:39.695]                             return(sendCondition)
[17:43:39.695]                           }
[17:43:39.695]                         }
[17:43:39.695]                         frame <- frame + 1L
[17:43:39.695]                         envir <- sys.frame(frame)
[17:43:39.695]                       }
[17:43:39.695]                     }
[17:43:39.695]                     sendCondition <<- function(cond) NULL
[17:43:39.695]                   }
[17:43:39.695]                 })
[17:43:39.695]                 withCallingHandlers({
[17:43:39.695]                   {
[17:43:39.695]                     Sys.sleep(0.5)
[17:43:39.695]                     list(a = 1, b = 42L)
[17:43:39.695]                   }
[17:43:39.695]                 }, immediateCondition = function(cond) {
[17:43:39.695]                   sendCondition <- ...future.makeSendCondition()
[17:43:39.695]                   sendCondition(cond)
[17:43:39.695]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:39.695]                   {
[17:43:39.695]                     inherits <- base::inherits
[17:43:39.695]                     invokeRestart <- base::invokeRestart
[17:43:39.695]                     is.null <- base::is.null
[17:43:39.695]                     muffled <- FALSE
[17:43:39.695]                     if (inherits(cond, "message")) {
[17:43:39.695]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:39.695]                       if (muffled) 
[17:43:39.695]                         invokeRestart("muffleMessage")
[17:43:39.695]                     }
[17:43:39.695]                     else if (inherits(cond, "warning")) {
[17:43:39.695]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:39.695]                       if (muffled) 
[17:43:39.695]                         invokeRestart("muffleWarning")
[17:43:39.695]                     }
[17:43:39.695]                     else if (inherits(cond, "condition")) {
[17:43:39.695]                       if (!is.null(pattern)) {
[17:43:39.695]                         computeRestarts <- base::computeRestarts
[17:43:39.695]                         grepl <- base::grepl
[17:43:39.695]                         restarts <- computeRestarts(cond)
[17:43:39.695]                         for (restart in restarts) {
[17:43:39.695]                           name <- restart$name
[17:43:39.695]                           if (is.null(name)) 
[17:43:39.695]                             next
[17:43:39.695]                           if (!grepl(pattern, name)) 
[17:43:39.695]                             next
[17:43:39.695]                           invokeRestart(restart)
[17:43:39.695]                           muffled <- TRUE
[17:43:39.695]                           break
[17:43:39.695]                         }
[17:43:39.695]                       }
[17:43:39.695]                     }
[17:43:39.695]                     invisible(muffled)
[17:43:39.695]                   }
[17:43:39.695]                   muffleCondition(cond)
[17:43:39.695]                 })
[17:43:39.695]             }))
[17:43:39.695]             future::FutureResult(value = ...future.value$value, 
[17:43:39.695]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:39.695]                   ...future.rng), globalenv = if (FALSE) 
[17:43:39.695]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:39.695]                     ...future.globalenv.names))
[17:43:39.695]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:39.695]         }, condition = base::local({
[17:43:39.695]             c <- base::c
[17:43:39.695]             inherits <- base::inherits
[17:43:39.695]             invokeRestart <- base::invokeRestart
[17:43:39.695]             length <- base::length
[17:43:39.695]             list <- base::list
[17:43:39.695]             seq.int <- base::seq.int
[17:43:39.695]             signalCondition <- base::signalCondition
[17:43:39.695]             sys.calls <- base::sys.calls
[17:43:39.695]             `[[` <- base::`[[`
[17:43:39.695]             `+` <- base::`+`
[17:43:39.695]             `<<-` <- base::`<<-`
[17:43:39.695]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:39.695]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:39.695]                   3L)]
[17:43:39.695]             }
[17:43:39.695]             function(cond) {
[17:43:39.695]                 is_error <- inherits(cond, "error")
[17:43:39.695]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:39.695]                   NULL)
[17:43:39.695]                 if (is_error) {
[17:43:39.695]                   sessionInformation <- function() {
[17:43:39.695]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:39.695]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:39.695]                       search = base::search(), system = base::Sys.info())
[17:43:39.695]                   }
[17:43:39.695]                   ...future.conditions[[length(...future.conditions) + 
[17:43:39.695]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:39.695]                     cond$call), session = sessionInformation(), 
[17:43:39.695]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:39.695]                   signalCondition(cond)
[17:43:39.695]                 }
[17:43:39.695]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:39.695]                 "immediateCondition"))) {
[17:43:39.695]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:39.695]                   ...future.conditions[[length(...future.conditions) + 
[17:43:39.695]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:39.695]                   if (TRUE && !signal) {
[17:43:39.695]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:39.695]                     {
[17:43:39.695]                       inherits <- base::inherits
[17:43:39.695]                       invokeRestart <- base::invokeRestart
[17:43:39.695]                       is.null <- base::is.null
[17:43:39.695]                       muffled <- FALSE
[17:43:39.695]                       if (inherits(cond, "message")) {
[17:43:39.695]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:39.695]                         if (muffled) 
[17:43:39.695]                           invokeRestart("muffleMessage")
[17:43:39.695]                       }
[17:43:39.695]                       else if (inherits(cond, "warning")) {
[17:43:39.695]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:39.695]                         if (muffled) 
[17:43:39.695]                           invokeRestart("muffleWarning")
[17:43:39.695]                       }
[17:43:39.695]                       else if (inherits(cond, "condition")) {
[17:43:39.695]                         if (!is.null(pattern)) {
[17:43:39.695]                           computeRestarts <- base::computeRestarts
[17:43:39.695]                           grepl <- base::grepl
[17:43:39.695]                           restarts <- computeRestarts(cond)
[17:43:39.695]                           for (restart in restarts) {
[17:43:39.695]                             name <- restart$name
[17:43:39.695]                             if (is.null(name)) 
[17:43:39.695]                               next
[17:43:39.695]                             if (!grepl(pattern, name)) 
[17:43:39.695]                               next
[17:43:39.695]                             invokeRestart(restart)
[17:43:39.695]                             muffled <- TRUE
[17:43:39.695]                             break
[17:43:39.695]                           }
[17:43:39.695]                         }
[17:43:39.695]                       }
[17:43:39.695]                       invisible(muffled)
[17:43:39.695]                     }
[17:43:39.695]                     muffleCondition(cond, pattern = "^muffle")
[17:43:39.695]                   }
[17:43:39.695]                 }
[17:43:39.695]                 else {
[17:43:39.695]                   if (TRUE) {
[17:43:39.695]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:39.695]                     {
[17:43:39.695]                       inherits <- base::inherits
[17:43:39.695]                       invokeRestart <- base::invokeRestart
[17:43:39.695]                       is.null <- base::is.null
[17:43:39.695]                       muffled <- FALSE
[17:43:39.695]                       if (inherits(cond, "message")) {
[17:43:39.695]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:39.695]                         if (muffled) 
[17:43:39.695]                           invokeRestart("muffleMessage")
[17:43:39.695]                       }
[17:43:39.695]                       else if (inherits(cond, "warning")) {
[17:43:39.695]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:39.695]                         if (muffled) 
[17:43:39.695]                           invokeRestart("muffleWarning")
[17:43:39.695]                       }
[17:43:39.695]                       else if (inherits(cond, "condition")) {
[17:43:39.695]                         if (!is.null(pattern)) {
[17:43:39.695]                           computeRestarts <- base::computeRestarts
[17:43:39.695]                           grepl <- base::grepl
[17:43:39.695]                           restarts <- computeRestarts(cond)
[17:43:39.695]                           for (restart in restarts) {
[17:43:39.695]                             name <- restart$name
[17:43:39.695]                             if (is.null(name)) 
[17:43:39.695]                               next
[17:43:39.695]                             if (!grepl(pattern, name)) 
[17:43:39.695]                               next
[17:43:39.695]                             invokeRestart(restart)
[17:43:39.695]                             muffled <- TRUE
[17:43:39.695]                             break
[17:43:39.695]                           }
[17:43:39.695]                         }
[17:43:39.695]                       }
[17:43:39.695]                       invisible(muffled)
[17:43:39.695]                     }
[17:43:39.695]                     muffleCondition(cond, pattern = "^muffle")
[17:43:39.695]                   }
[17:43:39.695]                 }
[17:43:39.695]             }
[17:43:39.695]         }))
[17:43:39.695]     }, error = function(ex) {
[17:43:39.695]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:39.695]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:39.695]                 ...future.rng), started = ...future.startTime, 
[17:43:39.695]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:39.695]             version = "1.8"), class = "FutureResult")
[17:43:39.695]     }, finally = {
[17:43:39.695]         if (!identical(...future.workdir, getwd())) 
[17:43:39.695]             setwd(...future.workdir)
[17:43:39.695]         {
[17:43:39.695]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:39.695]                 ...future.oldOptions$nwarnings <- NULL
[17:43:39.695]             }
[17:43:39.695]             base::options(...future.oldOptions)
[17:43:39.695]             if (.Platform$OS.type == "windows") {
[17:43:39.695]                 old_names <- names(...future.oldEnvVars)
[17:43:39.695]                 envs <- base::Sys.getenv()
[17:43:39.695]                 names <- names(envs)
[17:43:39.695]                 common <- intersect(names, old_names)
[17:43:39.695]                 added <- setdiff(names, old_names)
[17:43:39.695]                 removed <- setdiff(old_names, names)
[17:43:39.695]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:39.695]                   envs[common]]
[17:43:39.695]                 NAMES <- toupper(changed)
[17:43:39.695]                 args <- list()
[17:43:39.695]                 for (kk in seq_along(NAMES)) {
[17:43:39.695]                   name <- changed[[kk]]
[17:43:39.695]                   NAME <- NAMES[[kk]]
[17:43:39.695]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:39.695]                     next
[17:43:39.695]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:39.695]                 }
[17:43:39.695]                 NAMES <- toupper(added)
[17:43:39.695]                 for (kk in seq_along(NAMES)) {
[17:43:39.695]                   name <- added[[kk]]
[17:43:39.695]                   NAME <- NAMES[[kk]]
[17:43:39.695]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:39.695]                     next
[17:43:39.695]                   args[[name]] <- ""
[17:43:39.695]                 }
[17:43:39.695]                 NAMES <- toupper(removed)
[17:43:39.695]                 for (kk in seq_along(NAMES)) {
[17:43:39.695]                   name <- removed[[kk]]
[17:43:39.695]                   NAME <- NAMES[[kk]]
[17:43:39.695]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:39.695]                     next
[17:43:39.695]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:39.695]                 }
[17:43:39.695]                 if (length(args) > 0) 
[17:43:39.695]                   base::do.call(base::Sys.setenv, args = args)
[17:43:39.695]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:39.695]             }
[17:43:39.695]             else {
[17:43:39.695]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:39.695]             }
[17:43:39.695]             {
[17:43:39.695]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:39.695]                   0L) {
[17:43:39.695]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:39.695]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:39.695]                   base::options(opts)
[17:43:39.695]                 }
[17:43:39.695]                 {
[17:43:39.695]                   {
[17:43:39.695]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:39.695]                     NULL
[17:43:39.695]                   }
[17:43:39.695]                   options(future.plan = NULL)
[17:43:39.695]                   if (is.na(NA_character_)) 
[17:43:39.695]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:39.695]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:39.695]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:39.695]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:39.695]                     envir = parent.frame()) 
[17:43:39.695]                   {
[17:43:39.695]                     if (is.function(workers)) 
[17:43:39.695]                       workers <- workers()
[17:43:39.695]                     workers <- structure(as.integer(workers), 
[17:43:39.695]                       class = class(workers))
[17:43:39.695]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:39.695]                       workers >= 1)
[17:43:39.695]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:39.695]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:39.695]                     }
[17:43:39.695]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:39.695]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:39.695]                       envir = envir)
[17:43:39.695]                     if (!future$lazy) 
[17:43:39.695]                       future <- run(future)
[17:43:39.695]                     invisible(future)
[17:43:39.695]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:39.695]                 }
[17:43:39.695]             }
[17:43:39.695]         }
[17:43:39.695]     })
[17:43:39.695]     if (TRUE) {
[17:43:39.695]         base::sink(type = "output", split = FALSE)
[17:43:39.695]         if (TRUE) {
[17:43:39.695]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:39.695]         }
[17:43:39.695]         else {
[17:43:39.695]             ...future.result["stdout"] <- base::list(NULL)
[17:43:39.695]         }
[17:43:39.695]         base::close(...future.stdout)
[17:43:39.695]         ...future.stdout <- NULL
[17:43:39.695]     }
[17:43:39.695]     ...future.result$conditions <- ...future.conditions
[17:43:39.695]     ...future.result$finished <- base::Sys.time()
[17:43:39.695]     ...future.result
[17:43:39.695] }
[17:43:39.698] MultisessionFuture started
[17:43:39.698] - Launch lazy future ... done
[17:43:39.699] run() for ‘MultisessionFuture’ ... done
[17:43:40.205] receiveMessageFromWorker() for ClusterFuture ...
[17:43:40.205] - Validating connection of MultisessionFuture
[17:43:40.205] - received message: FutureResult
[17:43:40.205] - Received FutureResult
[17:43:40.205] - Erased future from FutureRegistry
[17:43:40.205] result() for ClusterFuture ...
[17:43:40.205] - result already collected: FutureResult
[17:43:40.205] result() for ClusterFuture ... done
[17:43:40.206] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:40.206] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[17:43:40.206] getGlobalsAndPackages() ...
[17:43:40.206] Searching for globals...
[17:43:40.207] - globals found: [2] ‘list’, ‘stop’
[17:43:40.207] Searching for globals ... DONE
[17:43:40.207] Resolving globals: FALSE
[17:43:40.207] 
[17:43:40.207] 
[17:43:40.207] getGlobalsAndPackages() ... DONE
[17:43:40.208] run() for ‘Future’ ...
[17:43:40.208] - state: ‘created’
[17:43:40.208] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:40.223] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:40.223] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:40.223]   - Field: ‘node’
[17:43:40.223]   - Field: ‘label’
[17:43:40.223]   - Field: ‘local’
[17:43:40.223]   - Field: ‘owner’
[17:43:40.224]   - Field: ‘envir’
[17:43:40.224]   - Field: ‘workers’
[17:43:40.224]   - Field: ‘packages’
[17:43:40.224]   - Field: ‘gc’
[17:43:40.224]   - Field: ‘conditions’
[17:43:40.224]   - Field: ‘persistent’
[17:43:40.224]   - Field: ‘expr’
[17:43:40.224]   - Field: ‘uuid’
[17:43:40.224]   - Field: ‘seed’
[17:43:40.224]   - Field: ‘version’
[17:43:40.224]   - Field: ‘result’
[17:43:40.225]   - Field: ‘asynchronous’
[17:43:40.225]   - Field: ‘calls’
[17:43:40.225]   - Field: ‘globals’
[17:43:40.225]   - Field: ‘stdout’
[17:43:40.225]   - Field: ‘earlySignal’
[17:43:40.225]   - Field: ‘lazy’
[17:43:40.225]   - Field: ‘state’
[17:43:40.225] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:40.225] - Launch lazy future ...
[17:43:40.226] Packages needed by the future expression (n = 0): <none>
[17:43:40.226] Packages needed by future strategies (n = 0): <none>
[17:43:40.226] {
[17:43:40.226]     {
[17:43:40.226]         {
[17:43:40.226]             ...future.startTime <- base::Sys.time()
[17:43:40.226]             {
[17:43:40.226]                 {
[17:43:40.226]                   {
[17:43:40.226]                     {
[17:43:40.226]                       base::local({
[17:43:40.226]                         has_future <- base::requireNamespace("future", 
[17:43:40.226]                           quietly = TRUE)
[17:43:40.226]                         if (has_future) {
[17:43:40.226]                           ns <- base::getNamespace("future")
[17:43:40.226]                           version <- ns[[".package"]][["version"]]
[17:43:40.226]                           if (is.null(version)) 
[17:43:40.226]                             version <- utils::packageVersion("future")
[17:43:40.226]                         }
[17:43:40.226]                         else {
[17:43:40.226]                           version <- NULL
[17:43:40.226]                         }
[17:43:40.226]                         if (!has_future || version < "1.8.0") {
[17:43:40.226]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:40.226]                             "", base::R.version$version.string), 
[17:43:40.226]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:40.226]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:40.226]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:40.226]                               "release", "version")], collapse = " "), 
[17:43:40.226]                             hostname = base::Sys.info()[["nodename"]])
[17:43:40.226]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:40.226]                             info)
[17:43:40.226]                           info <- base::paste(info, collapse = "; ")
[17:43:40.226]                           if (!has_future) {
[17:43:40.226]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:40.226]                               info)
[17:43:40.226]                           }
[17:43:40.226]                           else {
[17:43:40.226]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:40.226]                               info, version)
[17:43:40.226]                           }
[17:43:40.226]                           base::stop(msg)
[17:43:40.226]                         }
[17:43:40.226]                       })
[17:43:40.226]                     }
[17:43:40.226]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:40.226]                     base::options(mc.cores = 1L)
[17:43:40.226]                   }
[17:43:40.226]                   options(future.plan = NULL)
[17:43:40.226]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:40.226]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:40.226]                 }
[17:43:40.226]                 ...future.workdir <- getwd()
[17:43:40.226]             }
[17:43:40.226]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:40.226]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:40.226]         }
[17:43:40.226]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:40.226]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:40.226]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:40.226]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:40.226]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:40.226]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:40.226]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:40.226]             base::names(...future.oldOptions))
[17:43:40.226]     }
[17:43:40.226]     if (FALSE) {
[17:43:40.226]     }
[17:43:40.226]     else {
[17:43:40.226]         if (TRUE) {
[17:43:40.226]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:40.226]                 open = "w")
[17:43:40.226]         }
[17:43:40.226]         else {
[17:43:40.226]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:40.226]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:40.226]         }
[17:43:40.226]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:40.226]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:40.226]             base::sink(type = "output", split = FALSE)
[17:43:40.226]             base::close(...future.stdout)
[17:43:40.226]         }, add = TRUE)
[17:43:40.226]     }
[17:43:40.226]     ...future.frame <- base::sys.nframe()
[17:43:40.226]     ...future.conditions <- base::list()
[17:43:40.226]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:40.226]     if (FALSE) {
[17:43:40.226]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:40.226]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:40.226]     }
[17:43:40.226]     ...future.result <- base::tryCatch({
[17:43:40.226]         base::withCallingHandlers({
[17:43:40.226]             ...future.value <- base::withVisible(base::local({
[17:43:40.226]                 ...future.makeSendCondition <- local({
[17:43:40.226]                   sendCondition <- NULL
[17:43:40.226]                   function(frame = 1L) {
[17:43:40.226]                     if (is.function(sendCondition)) 
[17:43:40.226]                       return(sendCondition)
[17:43:40.226]                     ns <- getNamespace("parallel")
[17:43:40.226]                     if (exists("sendData", mode = "function", 
[17:43:40.226]                       envir = ns)) {
[17:43:40.226]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:40.226]                         envir = ns)
[17:43:40.226]                       envir <- sys.frame(frame)
[17:43:40.226]                       master <- NULL
[17:43:40.226]                       while (!identical(envir, .GlobalEnv) && 
[17:43:40.226]                         !identical(envir, emptyenv())) {
[17:43:40.226]                         if (exists("master", mode = "list", envir = envir, 
[17:43:40.226]                           inherits = FALSE)) {
[17:43:40.226]                           master <- get("master", mode = "list", 
[17:43:40.226]                             envir = envir, inherits = FALSE)
[17:43:40.226]                           if (inherits(master, c("SOCKnode", 
[17:43:40.226]                             "SOCK0node"))) {
[17:43:40.226]                             sendCondition <<- function(cond) {
[17:43:40.226]                               data <- list(type = "VALUE", value = cond, 
[17:43:40.226]                                 success = TRUE)
[17:43:40.226]                               parallel_sendData(master, data)
[17:43:40.226]                             }
[17:43:40.226]                             return(sendCondition)
[17:43:40.226]                           }
[17:43:40.226]                         }
[17:43:40.226]                         frame <- frame + 1L
[17:43:40.226]                         envir <- sys.frame(frame)
[17:43:40.226]                       }
[17:43:40.226]                     }
[17:43:40.226]                     sendCondition <<- function(cond) NULL
[17:43:40.226]                   }
[17:43:40.226]                 })
[17:43:40.226]                 withCallingHandlers({
[17:43:40.226]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:43:40.226]                 }, immediateCondition = function(cond) {
[17:43:40.226]                   sendCondition <- ...future.makeSendCondition()
[17:43:40.226]                   sendCondition(cond)
[17:43:40.226]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:40.226]                   {
[17:43:40.226]                     inherits <- base::inherits
[17:43:40.226]                     invokeRestart <- base::invokeRestart
[17:43:40.226]                     is.null <- base::is.null
[17:43:40.226]                     muffled <- FALSE
[17:43:40.226]                     if (inherits(cond, "message")) {
[17:43:40.226]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:40.226]                       if (muffled) 
[17:43:40.226]                         invokeRestart("muffleMessage")
[17:43:40.226]                     }
[17:43:40.226]                     else if (inherits(cond, "warning")) {
[17:43:40.226]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:40.226]                       if (muffled) 
[17:43:40.226]                         invokeRestart("muffleWarning")
[17:43:40.226]                     }
[17:43:40.226]                     else if (inherits(cond, "condition")) {
[17:43:40.226]                       if (!is.null(pattern)) {
[17:43:40.226]                         computeRestarts <- base::computeRestarts
[17:43:40.226]                         grepl <- base::grepl
[17:43:40.226]                         restarts <- computeRestarts(cond)
[17:43:40.226]                         for (restart in restarts) {
[17:43:40.226]                           name <- restart$name
[17:43:40.226]                           if (is.null(name)) 
[17:43:40.226]                             next
[17:43:40.226]                           if (!grepl(pattern, name)) 
[17:43:40.226]                             next
[17:43:40.226]                           invokeRestart(restart)
[17:43:40.226]                           muffled <- TRUE
[17:43:40.226]                           break
[17:43:40.226]                         }
[17:43:40.226]                       }
[17:43:40.226]                     }
[17:43:40.226]                     invisible(muffled)
[17:43:40.226]                   }
[17:43:40.226]                   muffleCondition(cond)
[17:43:40.226]                 })
[17:43:40.226]             }))
[17:43:40.226]             future::FutureResult(value = ...future.value$value, 
[17:43:40.226]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:40.226]                   ...future.rng), globalenv = if (FALSE) 
[17:43:40.226]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:40.226]                     ...future.globalenv.names))
[17:43:40.226]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:40.226]         }, condition = base::local({
[17:43:40.226]             c <- base::c
[17:43:40.226]             inherits <- base::inherits
[17:43:40.226]             invokeRestart <- base::invokeRestart
[17:43:40.226]             length <- base::length
[17:43:40.226]             list <- base::list
[17:43:40.226]             seq.int <- base::seq.int
[17:43:40.226]             signalCondition <- base::signalCondition
[17:43:40.226]             sys.calls <- base::sys.calls
[17:43:40.226]             `[[` <- base::`[[`
[17:43:40.226]             `+` <- base::`+`
[17:43:40.226]             `<<-` <- base::`<<-`
[17:43:40.226]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:40.226]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:40.226]                   3L)]
[17:43:40.226]             }
[17:43:40.226]             function(cond) {
[17:43:40.226]                 is_error <- inherits(cond, "error")
[17:43:40.226]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:40.226]                   NULL)
[17:43:40.226]                 if (is_error) {
[17:43:40.226]                   sessionInformation <- function() {
[17:43:40.226]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:40.226]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:40.226]                       search = base::search(), system = base::Sys.info())
[17:43:40.226]                   }
[17:43:40.226]                   ...future.conditions[[length(...future.conditions) + 
[17:43:40.226]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:40.226]                     cond$call), session = sessionInformation(), 
[17:43:40.226]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:40.226]                   signalCondition(cond)
[17:43:40.226]                 }
[17:43:40.226]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:40.226]                 "immediateCondition"))) {
[17:43:40.226]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:40.226]                   ...future.conditions[[length(...future.conditions) + 
[17:43:40.226]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:40.226]                   if (TRUE && !signal) {
[17:43:40.226]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:40.226]                     {
[17:43:40.226]                       inherits <- base::inherits
[17:43:40.226]                       invokeRestart <- base::invokeRestart
[17:43:40.226]                       is.null <- base::is.null
[17:43:40.226]                       muffled <- FALSE
[17:43:40.226]                       if (inherits(cond, "message")) {
[17:43:40.226]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:40.226]                         if (muffled) 
[17:43:40.226]                           invokeRestart("muffleMessage")
[17:43:40.226]                       }
[17:43:40.226]                       else if (inherits(cond, "warning")) {
[17:43:40.226]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:40.226]                         if (muffled) 
[17:43:40.226]                           invokeRestart("muffleWarning")
[17:43:40.226]                       }
[17:43:40.226]                       else if (inherits(cond, "condition")) {
[17:43:40.226]                         if (!is.null(pattern)) {
[17:43:40.226]                           computeRestarts <- base::computeRestarts
[17:43:40.226]                           grepl <- base::grepl
[17:43:40.226]                           restarts <- computeRestarts(cond)
[17:43:40.226]                           for (restart in restarts) {
[17:43:40.226]                             name <- restart$name
[17:43:40.226]                             if (is.null(name)) 
[17:43:40.226]                               next
[17:43:40.226]                             if (!grepl(pattern, name)) 
[17:43:40.226]                               next
[17:43:40.226]                             invokeRestart(restart)
[17:43:40.226]                             muffled <- TRUE
[17:43:40.226]                             break
[17:43:40.226]                           }
[17:43:40.226]                         }
[17:43:40.226]                       }
[17:43:40.226]                       invisible(muffled)
[17:43:40.226]                     }
[17:43:40.226]                     muffleCondition(cond, pattern = "^muffle")
[17:43:40.226]                   }
[17:43:40.226]                 }
[17:43:40.226]                 else {
[17:43:40.226]                   if (TRUE) {
[17:43:40.226]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:40.226]                     {
[17:43:40.226]                       inherits <- base::inherits
[17:43:40.226]                       invokeRestart <- base::invokeRestart
[17:43:40.226]                       is.null <- base::is.null
[17:43:40.226]                       muffled <- FALSE
[17:43:40.226]                       if (inherits(cond, "message")) {
[17:43:40.226]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:40.226]                         if (muffled) 
[17:43:40.226]                           invokeRestart("muffleMessage")
[17:43:40.226]                       }
[17:43:40.226]                       else if (inherits(cond, "warning")) {
[17:43:40.226]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:40.226]                         if (muffled) 
[17:43:40.226]                           invokeRestart("muffleWarning")
[17:43:40.226]                       }
[17:43:40.226]                       else if (inherits(cond, "condition")) {
[17:43:40.226]                         if (!is.null(pattern)) {
[17:43:40.226]                           computeRestarts <- base::computeRestarts
[17:43:40.226]                           grepl <- base::grepl
[17:43:40.226]                           restarts <- computeRestarts(cond)
[17:43:40.226]                           for (restart in restarts) {
[17:43:40.226]                             name <- restart$name
[17:43:40.226]                             if (is.null(name)) 
[17:43:40.226]                               next
[17:43:40.226]                             if (!grepl(pattern, name)) 
[17:43:40.226]                               next
[17:43:40.226]                             invokeRestart(restart)
[17:43:40.226]                             muffled <- TRUE
[17:43:40.226]                             break
[17:43:40.226]                           }
[17:43:40.226]                         }
[17:43:40.226]                       }
[17:43:40.226]                       invisible(muffled)
[17:43:40.226]                     }
[17:43:40.226]                     muffleCondition(cond, pattern = "^muffle")
[17:43:40.226]                   }
[17:43:40.226]                 }
[17:43:40.226]             }
[17:43:40.226]         }))
[17:43:40.226]     }, error = function(ex) {
[17:43:40.226]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:40.226]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:40.226]                 ...future.rng), started = ...future.startTime, 
[17:43:40.226]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:40.226]             version = "1.8"), class = "FutureResult")
[17:43:40.226]     }, finally = {
[17:43:40.226]         if (!identical(...future.workdir, getwd())) 
[17:43:40.226]             setwd(...future.workdir)
[17:43:40.226]         {
[17:43:40.226]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:40.226]                 ...future.oldOptions$nwarnings <- NULL
[17:43:40.226]             }
[17:43:40.226]             base::options(...future.oldOptions)
[17:43:40.226]             if (.Platform$OS.type == "windows") {
[17:43:40.226]                 old_names <- names(...future.oldEnvVars)
[17:43:40.226]                 envs <- base::Sys.getenv()
[17:43:40.226]                 names <- names(envs)
[17:43:40.226]                 common <- intersect(names, old_names)
[17:43:40.226]                 added <- setdiff(names, old_names)
[17:43:40.226]                 removed <- setdiff(old_names, names)
[17:43:40.226]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:40.226]                   envs[common]]
[17:43:40.226]                 NAMES <- toupper(changed)
[17:43:40.226]                 args <- list()
[17:43:40.226]                 for (kk in seq_along(NAMES)) {
[17:43:40.226]                   name <- changed[[kk]]
[17:43:40.226]                   NAME <- NAMES[[kk]]
[17:43:40.226]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:40.226]                     next
[17:43:40.226]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:40.226]                 }
[17:43:40.226]                 NAMES <- toupper(added)
[17:43:40.226]                 for (kk in seq_along(NAMES)) {
[17:43:40.226]                   name <- added[[kk]]
[17:43:40.226]                   NAME <- NAMES[[kk]]
[17:43:40.226]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:40.226]                     next
[17:43:40.226]                   args[[name]] <- ""
[17:43:40.226]                 }
[17:43:40.226]                 NAMES <- toupper(removed)
[17:43:40.226]                 for (kk in seq_along(NAMES)) {
[17:43:40.226]                   name <- removed[[kk]]
[17:43:40.226]                   NAME <- NAMES[[kk]]
[17:43:40.226]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:40.226]                     next
[17:43:40.226]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:40.226]                 }
[17:43:40.226]                 if (length(args) > 0) 
[17:43:40.226]                   base::do.call(base::Sys.setenv, args = args)
[17:43:40.226]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:40.226]             }
[17:43:40.226]             else {
[17:43:40.226]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:40.226]             }
[17:43:40.226]             {
[17:43:40.226]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:40.226]                   0L) {
[17:43:40.226]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:40.226]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:40.226]                   base::options(opts)
[17:43:40.226]                 }
[17:43:40.226]                 {
[17:43:40.226]                   {
[17:43:40.226]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:40.226]                     NULL
[17:43:40.226]                   }
[17:43:40.226]                   options(future.plan = NULL)
[17:43:40.226]                   if (is.na(NA_character_)) 
[17:43:40.226]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:40.226]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:40.226]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:40.226]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:40.226]                     envir = parent.frame()) 
[17:43:40.226]                   {
[17:43:40.226]                     if (is.function(workers)) 
[17:43:40.226]                       workers <- workers()
[17:43:40.226]                     workers <- structure(as.integer(workers), 
[17:43:40.226]                       class = class(workers))
[17:43:40.226]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:40.226]                       workers >= 1)
[17:43:40.226]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:40.226]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:40.226]                     }
[17:43:40.226]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:40.226]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:40.226]                       envir = envir)
[17:43:40.226]                     if (!future$lazy) 
[17:43:40.226]                       future <- run(future)
[17:43:40.226]                     invisible(future)
[17:43:40.226]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:40.226]                 }
[17:43:40.226]             }
[17:43:40.226]         }
[17:43:40.226]     })
[17:43:40.226]     if (TRUE) {
[17:43:40.226]         base::sink(type = "output", split = FALSE)
[17:43:40.226]         if (TRUE) {
[17:43:40.226]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:40.226]         }
[17:43:40.226]         else {
[17:43:40.226]             ...future.result["stdout"] <- base::list(NULL)
[17:43:40.226]         }
[17:43:40.226]         base::close(...future.stdout)
[17:43:40.226]         ...future.stdout <- NULL
[17:43:40.226]     }
[17:43:40.226]     ...future.result$conditions <- ...future.conditions
[17:43:40.226]     ...future.result$finished <- base::Sys.time()
[17:43:40.226]     ...future.result
[17:43:40.226] }
[17:43:40.229] MultisessionFuture started
[17:43:40.230] - Launch lazy future ... done
[17:43:40.230] run() for ‘MultisessionFuture’ ... done
[17:43:40.276] receiveMessageFromWorker() for ClusterFuture ...
[17:43:40.276] - Validating connection of MultisessionFuture
[17:43:40.277] - received message: FutureResult
[17:43:40.277] - Received FutureResult
[17:43:40.277] - Erased future from FutureRegistry
[17:43:40.277] result() for ClusterFuture ...
[17:43:40.277] - result already collected: FutureResult
[17:43:40.277] result() for ClusterFuture ... done
[17:43:40.278] signalConditions() ...
[17:43:40.278]  - include = ‘immediateCondition’
[17:43:40.278]  - exclude = 
[17:43:40.278]  - resignal = FALSE
[17:43:40.278]  - Number of conditions: 1
[17:43:40.278] signalConditions() ... done
[17:43:40.278] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:40.278] A MultisessionFuture was resolved (result was not collected)
[17:43:40.278] getGlobalsAndPackages() ...
[17:43:40.278] Searching for globals...
[17:43:40.279] - globals found: [2] ‘list’, ‘stop’
[17:43:40.279] Searching for globals ... DONE
[17:43:40.279] Resolving globals: FALSE
[17:43:40.280] 
[17:43:40.280] 
[17:43:40.280] getGlobalsAndPackages() ... DONE
[17:43:40.280] run() for ‘Future’ ...
[17:43:40.280] - state: ‘created’
[17:43:40.281] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:40.295] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:40.295] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:40.296]   - Field: ‘node’
[17:43:40.296]   - Field: ‘label’
[17:43:40.296]   - Field: ‘local’
[17:43:40.296]   - Field: ‘owner’
[17:43:40.296]   - Field: ‘envir’
[17:43:40.296]   - Field: ‘workers’
[17:43:40.296]   - Field: ‘packages’
[17:43:40.298]   - Field: ‘gc’
[17:43:40.298]   - Field: ‘conditions’
[17:43:40.298]   - Field: ‘persistent’
[17:43:40.298]   - Field: ‘expr’
[17:43:40.299]   - Field: ‘uuid’
[17:43:40.299]   - Field: ‘seed’
[17:43:40.299]   - Field: ‘version’
[17:43:40.299]   - Field: ‘result’
[17:43:40.299]   - Field: ‘asynchronous’
[17:43:40.299]   - Field: ‘calls’
[17:43:40.299]   - Field: ‘globals’
[17:43:40.299]   - Field: ‘stdout’
[17:43:40.299]   - Field: ‘earlySignal’
[17:43:40.299]   - Field: ‘lazy’
[17:43:40.299]   - Field: ‘state’
[17:43:40.300] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:40.300] - Launch lazy future ...
[17:43:40.300] Packages needed by the future expression (n = 0): <none>
[17:43:40.300] Packages needed by future strategies (n = 0): <none>
[17:43:40.300] {
[17:43:40.300]     {
[17:43:40.300]         {
[17:43:40.300]             ...future.startTime <- base::Sys.time()
[17:43:40.300]             {
[17:43:40.300]                 {
[17:43:40.300]                   {
[17:43:40.300]                     {
[17:43:40.300]                       base::local({
[17:43:40.300]                         has_future <- base::requireNamespace("future", 
[17:43:40.300]                           quietly = TRUE)
[17:43:40.300]                         if (has_future) {
[17:43:40.300]                           ns <- base::getNamespace("future")
[17:43:40.300]                           version <- ns[[".package"]][["version"]]
[17:43:40.300]                           if (is.null(version)) 
[17:43:40.300]                             version <- utils::packageVersion("future")
[17:43:40.300]                         }
[17:43:40.300]                         else {
[17:43:40.300]                           version <- NULL
[17:43:40.300]                         }
[17:43:40.300]                         if (!has_future || version < "1.8.0") {
[17:43:40.300]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:40.300]                             "", base::R.version$version.string), 
[17:43:40.300]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:40.300]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:40.300]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:40.300]                               "release", "version")], collapse = " "), 
[17:43:40.300]                             hostname = base::Sys.info()[["nodename"]])
[17:43:40.300]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:40.300]                             info)
[17:43:40.300]                           info <- base::paste(info, collapse = "; ")
[17:43:40.300]                           if (!has_future) {
[17:43:40.300]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:40.300]                               info)
[17:43:40.300]                           }
[17:43:40.300]                           else {
[17:43:40.300]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:40.300]                               info, version)
[17:43:40.300]                           }
[17:43:40.300]                           base::stop(msg)
[17:43:40.300]                         }
[17:43:40.300]                       })
[17:43:40.300]                     }
[17:43:40.300]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:40.300]                     base::options(mc.cores = 1L)
[17:43:40.300]                   }
[17:43:40.300]                   options(future.plan = NULL)
[17:43:40.300]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:40.300]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:40.300]                 }
[17:43:40.300]                 ...future.workdir <- getwd()
[17:43:40.300]             }
[17:43:40.300]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:40.300]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:40.300]         }
[17:43:40.300]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:40.300]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:40.300]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:40.300]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:40.300]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:40.300]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:40.300]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:40.300]             base::names(...future.oldOptions))
[17:43:40.300]     }
[17:43:40.300]     if (FALSE) {
[17:43:40.300]     }
[17:43:40.300]     else {
[17:43:40.300]         if (TRUE) {
[17:43:40.300]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:40.300]                 open = "w")
[17:43:40.300]         }
[17:43:40.300]         else {
[17:43:40.300]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:40.300]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:40.300]         }
[17:43:40.300]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:40.300]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:40.300]             base::sink(type = "output", split = FALSE)
[17:43:40.300]             base::close(...future.stdout)
[17:43:40.300]         }, add = TRUE)
[17:43:40.300]     }
[17:43:40.300]     ...future.frame <- base::sys.nframe()
[17:43:40.300]     ...future.conditions <- base::list()
[17:43:40.300]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:40.300]     if (FALSE) {
[17:43:40.300]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:40.300]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:40.300]     }
[17:43:40.300]     ...future.result <- base::tryCatch({
[17:43:40.300]         base::withCallingHandlers({
[17:43:40.300]             ...future.value <- base::withVisible(base::local({
[17:43:40.300]                 ...future.makeSendCondition <- local({
[17:43:40.300]                   sendCondition <- NULL
[17:43:40.300]                   function(frame = 1L) {
[17:43:40.300]                     if (is.function(sendCondition)) 
[17:43:40.300]                       return(sendCondition)
[17:43:40.300]                     ns <- getNamespace("parallel")
[17:43:40.300]                     if (exists("sendData", mode = "function", 
[17:43:40.300]                       envir = ns)) {
[17:43:40.300]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:40.300]                         envir = ns)
[17:43:40.300]                       envir <- sys.frame(frame)
[17:43:40.300]                       master <- NULL
[17:43:40.300]                       while (!identical(envir, .GlobalEnv) && 
[17:43:40.300]                         !identical(envir, emptyenv())) {
[17:43:40.300]                         if (exists("master", mode = "list", envir = envir, 
[17:43:40.300]                           inherits = FALSE)) {
[17:43:40.300]                           master <- get("master", mode = "list", 
[17:43:40.300]                             envir = envir, inherits = FALSE)
[17:43:40.300]                           if (inherits(master, c("SOCKnode", 
[17:43:40.300]                             "SOCK0node"))) {
[17:43:40.300]                             sendCondition <<- function(cond) {
[17:43:40.300]                               data <- list(type = "VALUE", value = cond, 
[17:43:40.300]                                 success = TRUE)
[17:43:40.300]                               parallel_sendData(master, data)
[17:43:40.300]                             }
[17:43:40.300]                             return(sendCondition)
[17:43:40.300]                           }
[17:43:40.300]                         }
[17:43:40.300]                         frame <- frame + 1L
[17:43:40.300]                         envir <- sys.frame(frame)
[17:43:40.300]                       }
[17:43:40.300]                     }
[17:43:40.300]                     sendCondition <<- function(cond) NULL
[17:43:40.300]                   }
[17:43:40.300]                 })
[17:43:40.300]                 withCallingHandlers({
[17:43:40.300]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:43:40.300]                 }, immediateCondition = function(cond) {
[17:43:40.300]                   sendCondition <- ...future.makeSendCondition()
[17:43:40.300]                   sendCondition(cond)
[17:43:40.300]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:40.300]                   {
[17:43:40.300]                     inherits <- base::inherits
[17:43:40.300]                     invokeRestart <- base::invokeRestart
[17:43:40.300]                     is.null <- base::is.null
[17:43:40.300]                     muffled <- FALSE
[17:43:40.300]                     if (inherits(cond, "message")) {
[17:43:40.300]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:40.300]                       if (muffled) 
[17:43:40.300]                         invokeRestart("muffleMessage")
[17:43:40.300]                     }
[17:43:40.300]                     else if (inherits(cond, "warning")) {
[17:43:40.300]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:40.300]                       if (muffled) 
[17:43:40.300]                         invokeRestart("muffleWarning")
[17:43:40.300]                     }
[17:43:40.300]                     else if (inherits(cond, "condition")) {
[17:43:40.300]                       if (!is.null(pattern)) {
[17:43:40.300]                         computeRestarts <- base::computeRestarts
[17:43:40.300]                         grepl <- base::grepl
[17:43:40.300]                         restarts <- computeRestarts(cond)
[17:43:40.300]                         for (restart in restarts) {
[17:43:40.300]                           name <- restart$name
[17:43:40.300]                           if (is.null(name)) 
[17:43:40.300]                             next
[17:43:40.300]                           if (!grepl(pattern, name)) 
[17:43:40.300]                             next
[17:43:40.300]                           invokeRestart(restart)
[17:43:40.300]                           muffled <- TRUE
[17:43:40.300]                           break
[17:43:40.300]                         }
[17:43:40.300]                       }
[17:43:40.300]                     }
[17:43:40.300]                     invisible(muffled)
[17:43:40.300]                   }
[17:43:40.300]                   muffleCondition(cond)
[17:43:40.300]                 })
[17:43:40.300]             }))
[17:43:40.300]             future::FutureResult(value = ...future.value$value, 
[17:43:40.300]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:40.300]                   ...future.rng), globalenv = if (FALSE) 
[17:43:40.300]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:40.300]                     ...future.globalenv.names))
[17:43:40.300]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:40.300]         }, condition = base::local({
[17:43:40.300]             c <- base::c
[17:43:40.300]             inherits <- base::inherits
[17:43:40.300]             invokeRestart <- base::invokeRestart
[17:43:40.300]             length <- base::length
[17:43:40.300]             list <- base::list
[17:43:40.300]             seq.int <- base::seq.int
[17:43:40.300]             signalCondition <- base::signalCondition
[17:43:40.300]             sys.calls <- base::sys.calls
[17:43:40.300]             `[[` <- base::`[[`
[17:43:40.300]             `+` <- base::`+`
[17:43:40.300]             `<<-` <- base::`<<-`
[17:43:40.300]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:40.300]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:40.300]                   3L)]
[17:43:40.300]             }
[17:43:40.300]             function(cond) {
[17:43:40.300]                 is_error <- inherits(cond, "error")
[17:43:40.300]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:40.300]                   NULL)
[17:43:40.300]                 if (is_error) {
[17:43:40.300]                   sessionInformation <- function() {
[17:43:40.300]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:40.300]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:40.300]                       search = base::search(), system = base::Sys.info())
[17:43:40.300]                   }
[17:43:40.300]                   ...future.conditions[[length(...future.conditions) + 
[17:43:40.300]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:40.300]                     cond$call), session = sessionInformation(), 
[17:43:40.300]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:40.300]                   signalCondition(cond)
[17:43:40.300]                 }
[17:43:40.300]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:40.300]                 "immediateCondition"))) {
[17:43:40.300]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:40.300]                   ...future.conditions[[length(...future.conditions) + 
[17:43:40.300]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:40.300]                   if (TRUE && !signal) {
[17:43:40.300]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:40.300]                     {
[17:43:40.300]                       inherits <- base::inherits
[17:43:40.300]                       invokeRestart <- base::invokeRestart
[17:43:40.300]                       is.null <- base::is.null
[17:43:40.300]                       muffled <- FALSE
[17:43:40.300]                       if (inherits(cond, "message")) {
[17:43:40.300]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:40.300]                         if (muffled) 
[17:43:40.300]                           invokeRestart("muffleMessage")
[17:43:40.300]                       }
[17:43:40.300]                       else if (inherits(cond, "warning")) {
[17:43:40.300]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:40.300]                         if (muffled) 
[17:43:40.300]                           invokeRestart("muffleWarning")
[17:43:40.300]                       }
[17:43:40.300]                       else if (inherits(cond, "condition")) {
[17:43:40.300]                         if (!is.null(pattern)) {
[17:43:40.300]                           computeRestarts <- base::computeRestarts
[17:43:40.300]                           grepl <- base::grepl
[17:43:40.300]                           restarts <- computeRestarts(cond)
[17:43:40.300]                           for (restart in restarts) {
[17:43:40.300]                             name <- restart$name
[17:43:40.300]                             if (is.null(name)) 
[17:43:40.300]                               next
[17:43:40.300]                             if (!grepl(pattern, name)) 
[17:43:40.300]                               next
[17:43:40.300]                             invokeRestart(restart)
[17:43:40.300]                             muffled <- TRUE
[17:43:40.300]                             break
[17:43:40.300]                           }
[17:43:40.300]                         }
[17:43:40.300]                       }
[17:43:40.300]                       invisible(muffled)
[17:43:40.300]                     }
[17:43:40.300]                     muffleCondition(cond, pattern = "^muffle")
[17:43:40.300]                   }
[17:43:40.300]                 }
[17:43:40.300]                 else {
[17:43:40.300]                   if (TRUE) {
[17:43:40.300]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:40.300]                     {
[17:43:40.300]                       inherits <- base::inherits
[17:43:40.300]                       invokeRestart <- base::invokeRestart
[17:43:40.300]                       is.null <- base::is.null
[17:43:40.300]                       muffled <- FALSE
[17:43:40.300]                       if (inherits(cond, "message")) {
[17:43:40.300]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:40.300]                         if (muffled) 
[17:43:40.300]                           invokeRestart("muffleMessage")
[17:43:40.300]                       }
[17:43:40.300]                       else if (inherits(cond, "warning")) {
[17:43:40.300]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:40.300]                         if (muffled) 
[17:43:40.300]                           invokeRestart("muffleWarning")
[17:43:40.300]                       }
[17:43:40.300]                       else if (inherits(cond, "condition")) {
[17:43:40.300]                         if (!is.null(pattern)) {
[17:43:40.300]                           computeRestarts <- base::computeRestarts
[17:43:40.300]                           grepl <- base::grepl
[17:43:40.300]                           restarts <- computeRestarts(cond)
[17:43:40.300]                           for (restart in restarts) {
[17:43:40.300]                             name <- restart$name
[17:43:40.300]                             if (is.null(name)) 
[17:43:40.300]                               next
[17:43:40.300]                             if (!grepl(pattern, name)) 
[17:43:40.300]                               next
[17:43:40.300]                             invokeRestart(restart)
[17:43:40.300]                             muffled <- TRUE
[17:43:40.300]                             break
[17:43:40.300]                           }
[17:43:40.300]                         }
[17:43:40.300]                       }
[17:43:40.300]                       invisible(muffled)
[17:43:40.300]                     }
[17:43:40.300]                     muffleCondition(cond, pattern = "^muffle")
[17:43:40.300]                   }
[17:43:40.300]                 }
[17:43:40.300]             }
[17:43:40.300]         }))
[17:43:40.300]     }, error = function(ex) {
[17:43:40.300]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:40.300]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:40.300]                 ...future.rng), started = ...future.startTime, 
[17:43:40.300]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:40.300]             version = "1.8"), class = "FutureResult")
[17:43:40.300]     }, finally = {
[17:43:40.300]         if (!identical(...future.workdir, getwd())) 
[17:43:40.300]             setwd(...future.workdir)
[17:43:40.300]         {
[17:43:40.300]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:40.300]                 ...future.oldOptions$nwarnings <- NULL
[17:43:40.300]             }
[17:43:40.300]             base::options(...future.oldOptions)
[17:43:40.300]             if (.Platform$OS.type == "windows") {
[17:43:40.300]                 old_names <- names(...future.oldEnvVars)
[17:43:40.300]                 envs <- base::Sys.getenv()
[17:43:40.300]                 names <- names(envs)
[17:43:40.300]                 common <- intersect(names, old_names)
[17:43:40.300]                 added <- setdiff(names, old_names)
[17:43:40.300]                 removed <- setdiff(old_names, names)
[17:43:40.300]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:40.300]                   envs[common]]
[17:43:40.300]                 NAMES <- toupper(changed)
[17:43:40.300]                 args <- list()
[17:43:40.300]                 for (kk in seq_along(NAMES)) {
[17:43:40.300]                   name <- changed[[kk]]
[17:43:40.300]                   NAME <- NAMES[[kk]]
[17:43:40.300]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:40.300]                     next
[17:43:40.300]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:40.300]                 }
[17:43:40.300]                 NAMES <- toupper(added)
[17:43:40.300]                 for (kk in seq_along(NAMES)) {
[17:43:40.300]                   name <- added[[kk]]
[17:43:40.300]                   NAME <- NAMES[[kk]]
[17:43:40.300]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:40.300]                     next
[17:43:40.300]                   args[[name]] <- ""
[17:43:40.300]                 }
[17:43:40.300]                 NAMES <- toupper(removed)
[17:43:40.300]                 for (kk in seq_along(NAMES)) {
[17:43:40.300]                   name <- removed[[kk]]
[17:43:40.300]                   NAME <- NAMES[[kk]]
[17:43:40.300]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:40.300]                     next
[17:43:40.300]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:40.300]                 }
[17:43:40.300]                 if (length(args) > 0) 
[17:43:40.300]                   base::do.call(base::Sys.setenv, args = args)
[17:43:40.300]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:40.300]             }
[17:43:40.300]             else {
[17:43:40.300]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:40.300]             }
[17:43:40.300]             {
[17:43:40.300]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:40.300]                   0L) {
[17:43:40.300]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:40.300]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:40.300]                   base::options(opts)
[17:43:40.300]                 }
[17:43:40.300]                 {
[17:43:40.300]                   {
[17:43:40.300]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:40.300]                     NULL
[17:43:40.300]                   }
[17:43:40.300]                   options(future.plan = NULL)
[17:43:40.300]                   if (is.na(NA_character_)) 
[17:43:40.300]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:40.300]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:40.300]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:40.300]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:40.300]                     envir = parent.frame()) 
[17:43:40.300]                   {
[17:43:40.300]                     if (is.function(workers)) 
[17:43:40.300]                       workers <- workers()
[17:43:40.300]                     workers <- structure(as.integer(workers), 
[17:43:40.300]                       class = class(workers))
[17:43:40.300]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:40.300]                       workers >= 1)
[17:43:40.300]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:40.300]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:40.300]                     }
[17:43:40.300]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:40.300]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:40.300]                       envir = envir)
[17:43:40.300]                     if (!future$lazy) 
[17:43:40.300]                       future <- run(future)
[17:43:40.300]                     invisible(future)
[17:43:40.300]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:40.300]                 }
[17:43:40.300]             }
[17:43:40.300]         }
[17:43:40.300]     })
[17:43:40.300]     if (TRUE) {
[17:43:40.300]         base::sink(type = "output", split = FALSE)
[17:43:40.300]         if (TRUE) {
[17:43:40.300]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:40.300]         }
[17:43:40.300]         else {
[17:43:40.300]             ...future.result["stdout"] <- base::list(NULL)
[17:43:40.300]         }
[17:43:40.300]         base::close(...future.stdout)
[17:43:40.300]         ...future.stdout <- NULL
[17:43:40.300]     }
[17:43:40.300]     ...future.result$conditions <- ...future.conditions
[17:43:40.300]     ...future.result$finished <- base::Sys.time()
[17:43:40.300]     ...future.result
[17:43:40.300] }
[17:43:40.303] MultisessionFuture started
[17:43:40.303] - Launch lazy future ... done
[17:43:40.304] run() for ‘MultisessionFuture’ ... done
[17:43:40.352] receiveMessageFromWorker() for ClusterFuture ...
[17:43:40.352] - Validating connection of MultisessionFuture
[17:43:40.352] - received message: FutureResult
[17:43:40.353] - Received FutureResult
[17:43:40.353] - Erased future from FutureRegistry
[17:43:40.353] result() for ClusterFuture ...
[17:43:40.353] - result already collected: FutureResult
[17:43:40.353] result() for ClusterFuture ... done
[17:43:40.353] signalConditions() ...
[17:43:40.353]  - include = ‘immediateCondition’
[17:43:40.353]  - exclude = 
[17:43:40.354]  - resignal = FALSE
[17:43:40.354]  - Number of conditions: 1
[17:43:40.354] signalConditions() ... done
[17:43:40.354] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:40.354] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = TRUE ... DONE
- result = FALSE, recursive = -1 ...
[17:43:40.354] getGlobalsAndPackages() ...
[17:43:40.354] Searching for globals...
[17:43:40.355] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:43:40.356] Searching for globals ... DONE
[17:43:40.356] Resolving globals: FALSE
[17:43:40.356] 
[17:43:40.356] 
[17:43:40.356] getGlobalsAndPackages() ... DONE
[17:43:40.356] run() for ‘Future’ ...
[17:43:40.357] - state: ‘created’
[17:43:40.357] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:40.371] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:40.371] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:40.371]   - Field: ‘node’
[17:43:40.371]   - Field: ‘label’
[17:43:40.372]   - Field: ‘local’
[17:43:40.372]   - Field: ‘owner’
[17:43:40.372]   - Field: ‘envir’
[17:43:40.372]   - Field: ‘workers’
[17:43:40.372]   - Field: ‘packages’
[17:43:40.372]   - Field: ‘gc’
[17:43:40.372]   - Field: ‘conditions’
[17:43:40.372]   - Field: ‘persistent’
[17:43:40.372]   - Field: ‘expr’
[17:43:40.372]   - Field: ‘uuid’
[17:43:40.372]   - Field: ‘seed’
[17:43:40.373]   - Field: ‘version’
[17:43:40.373]   - Field: ‘result’
[17:43:40.373]   - Field: ‘asynchronous’
[17:43:40.373]   - Field: ‘calls’
[17:43:40.373]   - Field: ‘globals’
[17:43:40.373]   - Field: ‘stdout’
[17:43:40.373]   - Field: ‘earlySignal’
[17:43:40.373]   - Field: ‘lazy’
[17:43:40.373]   - Field: ‘state’
[17:43:40.373] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:40.374] - Launch lazy future ...
[17:43:40.374] Packages needed by the future expression (n = 0): <none>
[17:43:40.374] Packages needed by future strategies (n = 0): <none>
[17:43:40.374] {
[17:43:40.374]     {
[17:43:40.374]         {
[17:43:40.374]             ...future.startTime <- base::Sys.time()
[17:43:40.374]             {
[17:43:40.374]                 {
[17:43:40.374]                   {
[17:43:40.374]                     {
[17:43:40.374]                       base::local({
[17:43:40.374]                         has_future <- base::requireNamespace("future", 
[17:43:40.374]                           quietly = TRUE)
[17:43:40.374]                         if (has_future) {
[17:43:40.374]                           ns <- base::getNamespace("future")
[17:43:40.374]                           version <- ns[[".package"]][["version"]]
[17:43:40.374]                           if (is.null(version)) 
[17:43:40.374]                             version <- utils::packageVersion("future")
[17:43:40.374]                         }
[17:43:40.374]                         else {
[17:43:40.374]                           version <- NULL
[17:43:40.374]                         }
[17:43:40.374]                         if (!has_future || version < "1.8.0") {
[17:43:40.374]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:40.374]                             "", base::R.version$version.string), 
[17:43:40.374]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:40.374]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:40.374]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:40.374]                               "release", "version")], collapse = " "), 
[17:43:40.374]                             hostname = base::Sys.info()[["nodename"]])
[17:43:40.374]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:40.374]                             info)
[17:43:40.374]                           info <- base::paste(info, collapse = "; ")
[17:43:40.374]                           if (!has_future) {
[17:43:40.374]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:40.374]                               info)
[17:43:40.374]                           }
[17:43:40.374]                           else {
[17:43:40.374]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:40.374]                               info, version)
[17:43:40.374]                           }
[17:43:40.374]                           base::stop(msg)
[17:43:40.374]                         }
[17:43:40.374]                       })
[17:43:40.374]                     }
[17:43:40.374]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:40.374]                     base::options(mc.cores = 1L)
[17:43:40.374]                   }
[17:43:40.374]                   options(future.plan = NULL)
[17:43:40.374]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:40.374]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:40.374]                 }
[17:43:40.374]                 ...future.workdir <- getwd()
[17:43:40.374]             }
[17:43:40.374]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:40.374]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:40.374]         }
[17:43:40.374]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:40.374]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:40.374]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:40.374]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:40.374]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:40.374]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:40.374]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:40.374]             base::names(...future.oldOptions))
[17:43:40.374]     }
[17:43:40.374]     if (FALSE) {
[17:43:40.374]     }
[17:43:40.374]     else {
[17:43:40.374]         if (TRUE) {
[17:43:40.374]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:40.374]                 open = "w")
[17:43:40.374]         }
[17:43:40.374]         else {
[17:43:40.374]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:40.374]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:40.374]         }
[17:43:40.374]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:40.374]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:40.374]             base::sink(type = "output", split = FALSE)
[17:43:40.374]             base::close(...future.stdout)
[17:43:40.374]         }, add = TRUE)
[17:43:40.374]     }
[17:43:40.374]     ...future.frame <- base::sys.nframe()
[17:43:40.374]     ...future.conditions <- base::list()
[17:43:40.374]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:40.374]     if (FALSE) {
[17:43:40.374]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:40.374]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:40.374]     }
[17:43:40.374]     ...future.result <- base::tryCatch({
[17:43:40.374]         base::withCallingHandlers({
[17:43:40.374]             ...future.value <- base::withVisible(base::local({
[17:43:40.374]                 ...future.makeSendCondition <- local({
[17:43:40.374]                   sendCondition <- NULL
[17:43:40.374]                   function(frame = 1L) {
[17:43:40.374]                     if (is.function(sendCondition)) 
[17:43:40.374]                       return(sendCondition)
[17:43:40.374]                     ns <- getNamespace("parallel")
[17:43:40.374]                     if (exists("sendData", mode = "function", 
[17:43:40.374]                       envir = ns)) {
[17:43:40.374]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:40.374]                         envir = ns)
[17:43:40.374]                       envir <- sys.frame(frame)
[17:43:40.374]                       master <- NULL
[17:43:40.374]                       while (!identical(envir, .GlobalEnv) && 
[17:43:40.374]                         !identical(envir, emptyenv())) {
[17:43:40.374]                         if (exists("master", mode = "list", envir = envir, 
[17:43:40.374]                           inherits = FALSE)) {
[17:43:40.374]                           master <- get("master", mode = "list", 
[17:43:40.374]                             envir = envir, inherits = FALSE)
[17:43:40.374]                           if (inherits(master, c("SOCKnode", 
[17:43:40.374]                             "SOCK0node"))) {
[17:43:40.374]                             sendCondition <<- function(cond) {
[17:43:40.374]                               data <- list(type = "VALUE", value = cond, 
[17:43:40.374]                                 success = TRUE)
[17:43:40.374]                               parallel_sendData(master, data)
[17:43:40.374]                             }
[17:43:40.374]                             return(sendCondition)
[17:43:40.374]                           }
[17:43:40.374]                         }
[17:43:40.374]                         frame <- frame + 1L
[17:43:40.374]                         envir <- sys.frame(frame)
[17:43:40.374]                       }
[17:43:40.374]                     }
[17:43:40.374]                     sendCondition <<- function(cond) NULL
[17:43:40.374]                   }
[17:43:40.374]                 })
[17:43:40.374]                 withCallingHandlers({
[17:43:40.374]                   {
[17:43:40.374]                     Sys.sleep(0.5)
[17:43:40.374]                     list(a = 1, b = 42L)
[17:43:40.374]                   }
[17:43:40.374]                 }, immediateCondition = function(cond) {
[17:43:40.374]                   sendCondition <- ...future.makeSendCondition()
[17:43:40.374]                   sendCondition(cond)
[17:43:40.374]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:40.374]                   {
[17:43:40.374]                     inherits <- base::inherits
[17:43:40.374]                     invokeRestart <- base::invokeRestart
[17:43:40.374]                     is.null <- base::is.null
[17:43:40.374]                     muffled <- FALSE
[17:43:40.374]                     if (inherits(cond, "message")) {
[17:43:40.374]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:40.374]                       if (muffled) 
[17:43:40.374]                         invokeRestart("muffleMessage")
[17:43:40.374]                     }
[17:43:40.374]                     else if (inherits(cond, "warning")) {
[17:43:40.374]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:40.374]                       if (muffled) 
[17:43:40.374]                         invokeRestart("muffleWarning")
[17:43:40.374]                     }
[17:43:40.374]                     else if (inherits(cond, "condition")) {
[17:43:40.374]                       if (!is.null(pattern)) {
[17:43:40.374]                         computeRestarts <- base::computeRestarts
[17:43:40.374]                         grepl <- base::grepl
[17:43:40.374]                         restarts <- computeRestarts(cond)
[17:43:40.374]                         for (restart in restarts) {
[17:43:40.374]                           name <- restart$name
[17:43:40.374]                           if (is.null(name)) 
[17:43:40.374]                             next
[17:43:40.374]                           if (!grepl(pattern, name)) 
[17:43:40.374]                             next
[17:43:40.374]                           invokeRestart(restart)
[17:43:40.374]                           muffled <- TRUE
[17:43:40.374]                           break
[17:43:40.374]                         }
[17:43:40.374]                       }
[17:43:40.374]                     }
[17:43:40.374]                     invisible(muffled)
[17:43:40.374]                   }
[17:43:40.374]                   muffleCondition(cond)
[17:43:40.374]                 })
[17:43:40.374]             }))
[17:43:40.374]             future::FutureResult(value = ...future.value$value, 
[17:43:40.374]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:40.374]                   ...future.rng), globalenv = if (FALSE) 
[17:43:40.374]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:40.374]                     ...future.globalenv.names))
[17:43:40.374]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:40.374]         }, condition = base::local({
[17:43:40.374]             c <- base::c
[17:43:40.374]             inherits <- base::inherits
[17:43:40.374]             invokeRestart <- base::invokeRestart
[17:43:40.374]             length <- base::length
[17:43:40.374]             list <- base::list
[17:43:40.374]             seq.int <- base::seq.int
[17:43:40.374]             signalCondition <- base::signalCondition
[17:43:40.374]             sys.calls <- base::sys.calls
[17:43:40.374]             `[[` <- base::`[[`
[17:43:40.374]             `+` <- base::`+`
[17:43:40.374]             `<<-` <- base::`<<-`
[17:43:40.374]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:40.374]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:40.374]                   3L)]
[17:43:40.374]             }
[17:43:40.374]             function(cond) {
[17:43:40.374]                 is_error <- inherits(cond, "error")
[17:43:40.374]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:40.374]                   NULL)
[17:43:40.374]                 if (is_error) {
[17:43:40.374]                   sessionInformation <- function() {
[17:43:40.374]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:40.374]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:40.374]                       search = base::search(), system = base::Sys.info())
[17:43:40.374]                   }
[17:43:40.374]                   ...future.conditions[[length(...future.conditions) + 
[17:43:40.374]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:40.374]                     cond$call), session = sessionInformation(), 
[17:43:40.374]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:40.374]                   signalCondition(cond)
[17:43:40.374]                 }
[17:43:40.374]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:40.374]                 "immediateCondition"))) {
[17:43:40.374]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:40.374]                   ...future.conditions[[length(...future.conditions) + 
[17:43:40.374]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:40.374]                   if (TRUE && !signal) {
[17:43:40.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:40.374]                     {
[17:43:40.374]                       inherits <- base::inherits
[17:43:40.374]                       invokeRestart <- base::invokeRestart
[17:43:40.374]                       is.null <- base::is.null
[17:43:40.374]                       muffled <- FALSE
[17:43:40.374]                       if (inherits(cond, "message")) {
[17:43:40.374]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:40.374]                         if (muffled) 
[17:43:40.374]                           invokeRestart("muffleMessage")
[17:43:40.374]                       }
[17:43:40.374]                       else if (inherits(cond, "warning")) {
[17:43:40.374]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:40.374]                         if (muffled) 
[17:43:40.374]                           invokeRestart("muffleWarning")
[17:43:40.374]                       }
[17:43:40.374]                       else if (inherits(cond, "condition")) {
[17:43:40.374]                         if (!is.null(pattern)) {
[17:43:40.374]                           computeRestarts <- base::computeRestarts
[17:43:40.374]                           grepl <- base::grepl
[17:43:40.374]                           restarts <- computeRestarts(cond)
[17:43:40.374]                           for (restart in restarts) {
[17:43:40.374]                             name <- restart$name
[17:43:40.374]                             if (is.null(name)) 
[17:43:40.374]                               next
[17:43:40.374]                             if (!grepl(pattern, name)) 
[17:43:40.374]                               next
[17:43:40.374]                             invokeRestart(restart)
[17:43:40.374]                             muffled <- TRUE
[17:43:40.374]                             break
[17:43:40.374]                           }
[17:43:40.374]                         }
[17:43:40.374]                       }
[17:43:40.374]                       invisible(muffled)
[17:43:40.374]                     }
[17:43:40.374]                     muffleCondition(cond, pattern = "^muffle")
[17:43:40.374]                   }
[17:43:40.374]                 }
[17:43:40.374]                 else {
[17:43:40.374]                   if (TRUE) {
[17:43:40.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:40.374]                     {
[17:43:40.374]                       inherits <- base::inherits
[17:43:40.374]                       invokeRestart <- base::invokeRestart
[17:43:40.374]                       is.null <- base::is.null
[17:43:40.374]                       muffled <- FALSE
[17:43:40.374]                       if (inherits(cond, "message")) {
[17:43:40.374]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:40.374]                         if (muffled) 
[17:43:40.374]                           invokeRestart("muffleMessage")
[17:43:40.374]                       }
[17:43:40.374]                       else if (inherits(cond, "warning")) {
[17:43:40.374]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:40.374]                         if (muffled) 
[17:43:40.374]                           invokeRestart("muffleWarning")
[17:43:40.374]                       }
[17:43:40.374]                       else if (inherits(cond, "condition")) {
[17:43:40.374]                         if (!is.null(pattern)) {
[17:43:40.374]                           computeRestarts <- base::computeRestarts
[17:43:40.374]                           grepl <- base::grepl
[17:43:40.374]                           restarts <- computeRestarts(cond)
[17:43:40.374]                           for (restart in restarts) {
[17:43:40.374]                             name <- restart$name
[17:43:40.374]                             if (is.null(name)) 
[17:43:40.374]                               next
[17:43:40.374]                             if (!grepl(pattern, name)) 
[17:43:40.374]                               next
[17:43:40.374]                             invokeRestart(restart)
[17:43:40.374]                             muffled <- TRUE
[17:43:40.374]                             break
[17:43:40.374]                           }
[17:43:40.374]                         }
[17:43:40.374]                       }
[17:43:40.374]                       invisible(muffled)
[17:43:40.374]                     }
[17:43:40.374]                     muffleCondition(cond, pattern = "^muffle")
[17:43:40.374]                   }
[17:43:40.374]                 }
[17:43:40.374]             }
[17:43:40.374]         }))
[17:43:40.374]     }, error = function(ex) {
[17:43:40.374]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:40.374]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:40.374]                 ...future.rng), started = ...future.startTime, 
[17:43:40.374]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:40.374]             version = "1.8"), class = "FutureResult")
[17:43:40.374]     }, finally = {
[17:43:40.374]         if (!identical(...future.workdir, getwd())) 
[17:43:40.374]             setwd(...future.workdir)
[17:43:40.374]         {
[17:43:40.374]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:40.374]                 ...future.oldOptions$nwarnings <- NULL
[17:43:40.374]             }
[17:43:40.374]             base::options(...future.oldOptions)
[17:43:40.374]             if (.Platform$OS.type == "windows") {
[17:43:40.374]                 old_names <- names(...future.oldEnvVars)
[17:43:40.374]                 envs <- base::Sys.getenv()
[17:43:40.374]                 names <- names(envs)
[17:43:40.374]                 common <- intersect(names, old_names)
[17:43:40.374]                 added <- setdiff(names, old_names)
[17:43:40.374]                 removed <- setdiff(old_names, names)
[17:43:40.374]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:40.374]                   envs[common]]
[17:43:40.374]                 NAMES <- toupper(changed)
[17:43:40.374]                 args <- list()
[17:43:40.374]                 for (kk in seq_along(NAMES)) {
[17:43:40.374]                   name <- changed[[kk]]
[17:43:40.374]                   NAME <- NAMES[[kk]]
[17:43:40.374]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:40.374]                     next
[17:43:40.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:40.374]                 }
[17:43:40.374]                 NAMES <- toupper(added)
[17:43:40.374]                 for (kk in seq_along(NAMES)) {
[17:43:40.374]                   name <- added[[kk]]
[17:43:40.374]                   NAME <- NAMES[[kk]]
[17:43:40.374]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:40.374]                     next
[17:43:40.374]                   args[[name]] <- ""
[17:43:40.374]                 }
[17:43:40.374]                 NAMES <- toupper(removed)
[17:43:40.374]                 for (kk in seq_along(NAMES)) {
[17:43:40.374]                   name <- removed[[kk]]
[17:43:40.374]                   NAME <- NAMES[[kk]]
[17:43:40.374]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:40.374]                     next
[17:43:40.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:40.374]                 }
[17:43:40.374]                 if (length(args) > 0) 
[17:43:40.374]                   base::do.call(base::Sys.setenv, args = args)
[17:43:40.374]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:40.374]             }
[17:43:40.374]             else {
[17:43:40.374]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:40.374]             }
[17:43:40.374]             {
[17:43:40.374]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:40.374]                   0L) {
[17:43:40.374]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:40.374]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:40.374]                   base::options(opts)
[17:43:40.374]                 }
[17:43:40.374]                 {
[17:43:40.374]                   {
[17:43:40.374]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:40.374]                     NULL
[17:43:40.374]                   }
[17:43:40.374]                   options(future.plan = NULL)
[17:43:40.374]                   if (is.na(NA_character_)) 
[17:43:40.374]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:40.374]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:40.374]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:40.374]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:40.374]                     envir = parent.frame()) 
[17:43:40.374]                   {
[17:43:40.374]                     if (is.function(workers)) 
[17:43:40.374]                       workers <- workers()
[17:43:40.374]                     workers <- structure(as.integer(workers), 
[17:43:40.374]                       class = class(workers))
[17:43:40.374]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:40.374]                       workers >= 1)
[17:43:40.374]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:40.374]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:40.374]                     }
[17:43:40.374]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:40.374]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:40.374]                       envir = envir)
[17:43:40.374]                     if (!future$lazy) 
[17:43:40.374]                       future <- run(future)
[17:43:40.374]                     invisible(future)
[17:43:40.374]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:40.374]                 }
[17:43:40.374]             }
[17:43:40.374]         }
[17:43:40.374]     })
[17:43:40.374]     if (TRUE) {
[17:43:40.374]         base::sink(type = "output", split = FALSE)
[17:43:40.374]         if (TRUE) {
[17:43:40.374]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:40.374]         }
[17:43:40.374]         else {
[17:43:40.374]             ...future.result["stdout"] <- base::list(NULL)
[17:43:40.374]         }
[17:43:40.374]         base::close(...future.stdout)
[17:43:40.374]         ...future.stdout <- NULL
[17:43:40.374]     }
[17:43:40.374]     ...future.result$conditions <- ...future.conditions
[17:43:40.374]     ...future.result$finished <- base::Sys.time()
[17:43:40.374]     ...future.result
[17:43:40.374] }
[17:43:40.378] MultisessionFuture started
[17:43:40.378] - Launch lazy future ... done
[17:43:40.378] run() for ‘MultisessionFuture’ ... done
[17:43:40.378] getGlobalsAndPackages() ...
[17:43:40.378] Searching for globals...
[17:43:40.379] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:43:40.379] Searching for globals ... DONE
[17:43:40.379] Resolving globals: FALSE
[17:43:40.380] 
[17:43:40.380] 
[17:43:40.380] getGlobalsAndPackages() ... DONE
- w/ exception ...
[17:43:40.380] getGlobalsAndPackages() ...
[17:43:40.380] Searching for globals...
[17:43:40.381] - globals found: [2] ‘list’, ‘stop’
[17:43:40.381] Searching for globals ... DONE
[17:43:40.381] Resolving globals: FALSE
[17:43:40.381] 
[17:43:40.382] 
[17:43:40.382] getGlobalsAndPackages() ... DONE
[17:43:40.382] run() for ‘Future’ ...
[17:43:40.382] - state: ‘created’
[17:43:40.382] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:40.397] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:40.397] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:40.398]   - Field: ‘node’
[17:43:40.398]   - Field: ‘label’
[17:43:40.398]   - Field: ‘local’
[17:43:40.398]   - Field: ‘owner’
[17:43:40.398]   - Field: ‘envir’
[17:43:40.398]   - Field: ‘workers’
[17:43:40.398]   - Field: ‘packages’
[17:43:40.398]   - Field: ‘gc’
[17:43:40.398]   - Field: ‘conditions’
[17:43:40.399]   - Field: ‘persistent’
[17:43:40.399]   - Field: ‘expr’
[17:43:40.399]   - Field: ‘uuid’
[17:43:40.399]   - Field: ‘seed’
[17:43:40.399]   - Field: ‘version’
[17:43:40.399]   - Field: ‘result’
[17:43:40.399]   - Field: ‘asynchronous’
[17:43:40.399]   - Field: ‘calls’
[17:43:40.399]   - Field: ‘globals’
[17:43:40.399]   - Field: ‘stdout’
[17:43:40.399]   - Field: ‘earlySignal’
[17:43:40.400]   - Field: ‘lazy’
[17:43:40.400]   - Field: ‘state’
[17:43:40.400] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:40.400] - Launch lazy future ...
[17:43:40.400] Packages needed by the future expression (n = 0): <none>
[17:43:40.400] Packages needed by future strategies (n = 0): <none>
[17:43:40.401] {
[17:43:40.401]     {
[17:43:40.401]         {
[17:43:40.401]             ...future.startTime <- base::Sys.time()
[17:43:40.401]             {
[17:43:40.401]                 {
[17:43:40.401]                   {
[17:43:40.401]                     {
[17:43:40.401]                       base::local({
[17:43:40.401]                         has_future <- base::requireNamespace("future", 
[17:43:40.401]                           quietly = TRUE)
[17:43:40.401]                         if (has_future) {
[17:43:40.401]                           ns <- base::getNamespace("future")
[17:43:40.401]                           version <- ns[[".package"]][["version"]]
[17:43:40.401]                           if (is.null(version)) 
[17:43:40.401]                             version <- utils::packageVersion("future")
[17:43:40.401]                         }
[17:43:40.401]                         else {
[17:43:40.401]                           version <- NULL
[17:43:40.401]                         }
[17:43:40.401]                         if (!has_future || version < "1.8.0") {
[17:43:40.401]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:40.401]                             "", base::R.version$version.string), 
[17:43:40.401]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:40.401]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:40.401]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:40.401]                               "release", "version")], collapse = " "), 
[17:43:40.401]                             hostname = base::Sys.info()[["nodename"]])
[17:43:40.401]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:40.401]                             info)
[17:43:40.401]                           info <- base::paste(info, collapse = "; ")
[17:43:40.401]                           if (!has_future) {
[17:43:40.401]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:40.401]                               info)
[17:43:40.401]                           }
[17:43:40.401]                           else {
[17:43:40.401]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:40.401]                               info, version)
[17:43:40.401]                           }
[17:43:40.401]                           base::stop(msg)
[17:43:40.401]                         }
[17:43:40.401]                       })
[17:43:40.401]                     }
[17:43:40.401]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:40.401]                     base::options(mc.cores = 1L)
[17:43:40.401]                   }
[17:43:40.401]                   options(future.plan = NULL)
[17:43:40.401]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:40.401]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:40.401]                 }
[17:43:40.401]                 ...future.workdir <- getwd()
[17:43:40.401]             }
[17:43:40.401]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:40.401]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:40.401]         }
[17:43:40.401]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:40.401]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:40.401]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:40.401]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:40.401]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:40.401]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:40.401]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:40.401]             base::names(...future.oldOptions))
[17:43:40.401]     }
[17:43:40.401]     if (FALSE) {
[17:43:40.401]     }
[17:43:40.401]     else {
[17:43:40.401]         if (TRUE) {
[17:43:40.401]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:40.401]                 open = "w")
[17:43:40.401]         }
[17:43:40.401]         else {
[17:43:40.401]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:40.401]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:40.401]         }
[17:43:40.401]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:40.401]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:40.401]             base::sink(type = "output", split = FALSE)
[17:43:40.401]             base::close(...future.stdout)
[17:43:40.401]         }, add = TRUE)
[17:43:40.401]     }
[17:43:40.401]     ...future.frame <- base::sys.nframe()
[17:43:40.401]     ...future.conditions <- base::list()
[17:43:40.401]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:40.401]     if (FALSE) {
[17:43:40.401]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:40.401]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:40.401]     }
[17:43:40.401]     ...future.result <- base::tryCatch({
[17:43:40.401]         base::withCallingHandlers({
[17:43:40.401]             ...future.value <- base::withVisible(base::local({
[17:43:40.401]                 ...future.makeSendCondition <- local({
[17:43:40.401]                   sendCondition <- NULL
[17:43:40.401]                   function(frame = 1L) {
[17:43:40.401]                     if (is.function(sendCondition)) 
[17:43:40.401]                       return(sendCondition)
[17:43:40.401]                     ns <- getNamespace("parallel")
[17:43:40.401]                     if (exists("sendData", mode = "function", 
[17:43:40.401]                       envir = ns)) {
[17:43:40.401]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:40.401]                         envir = ns)
[17:43:40.401]                       envir <- sys.frame(frame)
[17:43:40.401]                       master <- NULL
[17:43:40.401]                       while (!identical(envir, .GlobalEnv) && 
[17:43:40.401]                         !identical(envir, emptyenv())) {
[17:43:40.401]                         if (exists("master", mode = "list", envir = envir, 
[17:43:40.401]                           inherits = FALSE)) {
[17:43:40.401]                           master <- get("master", mode = "list", 
[17:43:40.401]                             envir = envir, inherits = FALSE)
[17:43:40.401]                           if (inherits(master, c("SOCKnode", 
[17:43:40.401]                             "SOCK0node"))) {
[17:43:40.401]                             sendCondition <<- function(cond) {
[17:43:40.401]                               data <- list(type = "VALUE", value = cond, 
[17:43:40.401]                                 success = TRUE)
[17:43:40.401]                               parallel_sendData(master, data)
[17:43:40.401]                             }
[17:43:40.401]                             return(sendCondition)
[17:43:40.401]                           }
[17:43:40.401]                         }
[17:43:40.401]                         frame <- frame + 1L
[17:43:40.401]                         envir <- sys.frame(frame)
[17:43:40.401]                       }
[17:43:40.401]                     }
[17:43:40.401]                     sendCondition <<- function(cond) NULL
[17:43:40.401]                   }
[17:43:40.401]                 })
[17:43:40.401]                 withCallingHandlers({
[17:43:40.401]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:43:40.401]                 }, immediateCondition = function(cond) {
[17:43:40.401]                   sendCondition <- ...future.makeSendCondition()
[17:43:40.401]                   sendCondition(cond)
[17:43:40.401]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:40.401]                   {
[17:43:40.401]                     inherits <- base::inherits
[17:43:40.401]                     invokeRestart <- base::invokeRestart
[17:43:40.401]                     is.null <- base::is.null
[17:43:40.401]                     muffled <- FALSE
[17:43:40.401]                     if (inherits(cond, "message")) {
[17:43:40.401]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:40.401]                       if (muffled) 
[17:43:40.401]                         invokeRestart("muffleMessage")
[17:43:40.401]                     }
[17:43:40.401]                     else if (inherits(cond, "warning")) {
[17:43:40.401]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:40.401]                       if (muffled) 
[17:43:40.401]                         invokeRestart("muffleWarning")
[17:43:40.401]                     }
[17:43:40.401]                     else if (inherits(cond, "condition")) {
[17:43:40.401]                       if (!is.null(pattern)) {
[17:43:40.401]                         computeRestarts <- base::computeRestarts
[17:43:40.401]                         grepl <- base::grepl
[17:43:40.401]                         restarts <- computeRestarts(cond)
[17:43:40.401]                         for (restart in restarts) {
[17:43:40.401]                           name <- restart$name
[17:43:40.401]                           if (is.null(name)) 
[17:43:40.401]                             next
[17:43:40.401]                           if (!grepl(pattern, name)) 
[17:43:40.401]                             next
[17:43:40.401]                           invokeRestart(restart)
[17:43:40.401]                           muffled <- TRUE
[17:43:40.401]                           break
[17:43:40.401]                         }
[17:43:40.401]                       }
[17:43:40.401]                     }
[17:43:40.401]                     invisible(muffled)
[17:43:40.401]                   }
[17:43:40.401]                   muffleCondition(cond)
[17:43:40.401]                 })
[17:43:40.401]             }))
[17:43:40.401]             future::FutureResult(value = ...future.value$value, 
[17:43:40.401]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:40.401]                   ...future.rng), globalenv = if (FALSE) 
[17:43:40.401]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:40.401]                     ...future.globalenv.names))
[17:43:40.401]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:40.401]         }, condition = base::local({
[17:43:40.401]             c <- base::c
[17:43:40.401]             inherits <- base::inherits
[17:43:40.401]             invokeRestart <- base::invokeRestart
[17:43:40.401]             length <- base::length
[17:43:40.401]             list <- base::list
[17:43:40.401]             seq.int <- base::seq.int
[17:43:40.401]             signalCondition <- base::signalCondition
[17:43:40.401]             sys.calls <- base::sys.calls
[17:43:40.401]             `[[` <- base::`[[`
[17:43:40.401]             `+` <- base::`+`
[17:43:40.401]             `<<-` <- base::`<<-`
[17:43:40.401]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:40.401]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:40.401]                   3L)]
[17:43:40.401]             }
[17:43:40.401]             function(cond) {
[17:43:40.401]                 is_error <- inherits(cond, "error")
[17:43:40.401]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:40.401]                   NULL)
[17:43:40.401]                 if (is_error) {
[17:43:40.401]                   sessionInformation <- function() {
[17:43:40.401]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:40.401]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:40.401]                       search = base::search(), system = base::Sys.info())
[17:43:40.401]                   }
[17:43:40.401]                   ...future.conditions[[length(...future.conditions) + 
[17:43:40.401]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:40.401]                     cond$call), session = sessionInformation(), 
[17:43:40.401]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:40.401]                   signalCondition(cond)
[17:43:40.401]                 }
[17:43:40.401]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:40.401]                 "immediateCondition"))) {
[17:43:40.401]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:40.401]                   ...future.conditions[[length(...future.conditions) + 
[17:43:40.401]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:40.401]                   if (TRUE && !signal) {
[17:43:40.401]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:40.401]                     {
[17:43:40.401]                       inherits <- base::inherits
[17:43:40.401]                       invokeRestart <- base::invokeRestart
[17:43:40.401]                       is.null <- base::is.null
[17:43:40.401]                       muffled <- FALSE
[17:43:40.401]                       if (inherits(cond, "message")) {
[17:43:40.401]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:40.401]                         if (muffled) 
[17:43:40.401]                           invokeRestart("muffleMessage")
[17:43:40.401]                       }
[17:43:40.401]                       else if (inherits(cond, "warning")) {
[17:43:40.401]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:40.401]                         if (muffled) 
[17:43:40.401]                           invokeRestart("muffleWarning")
[17:43:40.401]                       }
[17:43:40.401]                       else if (inherits(cond, "condition")) {
[17:43:40.401]                         if (!is.null(pattern)) {
[17:43:40.401]                           computeRestarts <- base::computeRestarts
[17:43:40.401]                           grepl <- base::grepl
[17:43:40.401]                           restarts <- computeRestarts(cond)
[17:43:40.401]                           for (restart in restarts) {
[17:43:40.401]                             name <- restart$name
[17:43:40.401]                             if (is.null(name)) 
[17:43:40.401]                               next
[17:43:40.401]                             if (!grepl(pattern, name)) 
[17:43:40.401]                               next
[17:43:40.401]                             invokeRestart(restart)
[17:43:40.401]                             muffled <- TRUE
[17:43:40.401]                             break
[17:43:40.401]                           }
[17:43:40.401]                         }
[17:43:40.401]                       }
[17:43:40.401]                       invisible(muffled)
[17:43:40.401]                     }
[17:43:40.401]                     muffleCondition(cond, pattern = "^muffle")
[17:43:40.401]                   }
[17:43:40.401]                 }
[17:43:40.401]                 else {
[17:43:40.401]                   if (TRUE) {
[17:43:40.401]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:40.401]                     {
[17:43:40.401]                       inherits <- base::inherits
[17:43:40.401]                       invokeRestart <- base::invokeRestart
[17:43:40.401]                       is.null <- base::is.null
[17:43:40.401]                       muffled <- FALSE
[17:43:40.401]                       if (inherits(cond, "message")) {
[17:43:40.401]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:40.401]                         if (muffled) 
[17:43:40.401]                           invokeRestart("muffleMessage")
[17:43:40.401]                       }
[17:43:40.401]                       else if (inherits(cond, "warning")) {
[17:43:40.401]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:40.401]                         if (muffled) 
[17:43:40.401]                           invokeRestart("muffleWarning")
[17:43:40.401]                       }
[17:43:40.401]                       else if (inherits(cond, "condition")) {
[17:43:40.401]                         if (!is.null(pattern)) {
[17:43:40.401]                           computeRestarts <- base::computeRestarts
[17:43:40.401]                           grepl <- base::grepl
[17:43:40.401]                           restarts <- computeRestarts(cond)
[17:43:40.401]                           for (restart in restarts) {
[17:43:40.401]                             name <- restart$name
[17:43:40.401]                             if (is.null(name)) 
[17:43:40.401]                               next
[17:43:40.401]                             if (!grepl(pattern, name)) 
[17:43:40.401]                               next
[17:43:40.401]                             invokeRestart(restart)
[17:43:40.401]                             muffled <- TRUE
[17:43:40.401]                             break
[17:43:40.401]                           }
[17:43:40.401]                         }
[17:43:40.401]                       }
[17:43:40.401]                       invisible(muffled)
[17:43:40.401]                     }
[17:43:40.401]                     muffleCondition(cond, pattern = "^muffle")
[17:43:40.401]                   }
[17:43:40.401]                 }
[17:43:40.401]             }
[17:43:40.401]         }))
[17:43:40.401]     }, error = function(ex) {
[17:43:40.401]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:40.401]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:40.401]                 ...future.rng), started = ...future.startTime, 
[17:43:40.401]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:40.401]             version = "1.8"), class = "FutureResult")
[17:43:40.401]     }, finally = {
[17:43:40.401]         if (!identical(...future.workdir, getwd())) 
[17:43:40.401]             setwd(...future.workdir)
[17:43:40.401]         {
[17:43:40.401]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:40.401]                 ...future.oldOptions$nwarnings <- NULL
[17:43:40.401]             }
[17:43:40.401]             base::options(...future.oldOptions)
[17:43:40.401]             if (.Platform$OS.type == "windows") {
[17:43:40.401]                 old_names <- names(...future.oldEnvVars)
[17:43:40.401]                 envs <- base::Sys.getenv()
[17:43:40.401]                 names <- names(envs)
[17:43:40.401]                 common <- intersect(names, old_names)
[17:43:40.401]                 added <- setdiff(names, old_names)
[17:43:40.401]                 removed <- setdiff(old_names, names)
[17:43:40.401]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:40.401]                   envs[common]]
[17:43:40.401]                 NAMES <- toupper(changed)
[17:43:40.401]                 args <- list()
[17:43:40.401]                 for (kk in seq_along(NAMES)) {
[17:43:40.401]                   name <- changed[[kk]]
[17:43:40.401]                   NAME <- NAMES[[kk]]
[17:43:40.401]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:40.401]                     next
[17:43:40.401]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:40.401]                 }
[17:43:40.401]                 NAMES <- toupper(added)
[17:43:40.401]                 for (kk in seq_along(NAMES)) {
[17:43:40.401]                   name <- added[[kk]]
[17:43:40.401]                   NAME <- NAMES[[kk]]
[17:43:40.401]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:40.401]                     next
[17:43:40.401]                   args[[name]] <- ""
[17:43:40.401]                 }
[17:43:40.401]                 NAMES <- toupper(removed)
[17:43:40.401]                 for (kk in seq_along(NAMES)) {
[17:43:40.401]                   name <- removed[[kk]]
[17:43:40.401]                   NAME <- NAMES[[kk]]
[17:43:40.401]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:40.401]                     next
[17:43:40.401]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:40.401]                 }
[17:43:40.401]                 if (length(args) > 0) 
[17:43:40.401]                   base::do.call(base::Sys.setenv, args = args)
[17:43:40.401]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:40.401]             }
[17:43:40.401]             else {
[17:43:40.401]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:40.401]             }
[17:43:40.401]             {
[17:43:40.401]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:40.401]                   0L) {
[17:43:40.401]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:40.401]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:40.401]                   base::options(opts)
[17:43:40.401]                 }
[17:43:40.401]                 {
[17:43:40.401]                   {
[17:43:40.401]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:40.401]                     NULL
[17:43:40.401]                   }
[17:43:40.401]                   options(future.plan = NULL)
[17:43:40.401]                   if (is.na(NA_character_)) 
[17:43:40.401]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:40.401]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:40.401]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:40.401]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:40.401]                     envir = parent.frame()) 
[17:43:40.401]                   {
[17:43:40.401]                     if (is.function(workers)) 
[17:43:40.401]                       workers <- workers()
[17:43:40.401]                     workers <- structure(as.integer(workers), 
[17:43:40.401]                       class = class(workers))
[17:43:40.401]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:40.401]                       workers >= 1)
[17:43:40.401]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:40.401]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:40.401]                     }
[17:43:40.401]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:40.401]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:40.401]                       envir = envir)
[17:43:40.401]                     if (!future$lazy) 
[17:43:40.401]                       future <- run(future)
[17:43:40.401]                     invisible(future)
[17:43:40.401]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:40.401]                 }
[17:43:40.401]             }
[17:43:40.401]         }
[17:43:40.401]     })
[17:43:40.401]     if (TRUE) {
[17:43:40.401]         base::sink(type = "output", split = FALSE)
[17:43:40.401]         if (TRUE) {
[17:43:40.401]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:40.401]         }
[17:43:40.401]         else {
[17:43:40.401]             ...future.result["stdout"] <- base::list(NULL)
[17:43:40.401]         }
[17:43:40.401]         base::close(...future.stdout)
[17:43:40.401]         ...future.stdout <- NULL
[17:43:40.401]     }
[17:43:40.401]     ...future.result$conditions <- ...future.conditions
[17:43:40.401]     ...future.result$finished <- base::Sys.time()
[17:43:40.401]     ...future.result
[17:43:40.401] }
[17:43:40.473] MultisessionFuture started
[17:43:40.474] - Launch lazy future ... done
[17:43:40.474] run() for ‘MultisessionFuture’ ... done
[17:43:40.474] getGlobalsAndPackages() ...
[17:43:40.474] Searching for globals...
[17:43:40.475] - globals found: [2] ‘list’, ‘stop’
[17:43:40.476] Searching for globals ... DONE
[17:43:40.476] Resolving globals: FALSE
[17:43:40.476] 
[17:43:40.476] 
[17:43:40.477] getGlobalsAndPackages() ... DONE
- result = FALSE, recursive = -1 ... DONE
- result = FALSE, recursive = 0 ...
[17:43:40.477] getGlobalsAndPackages() ...
[17:43:40.477] Searching for globals...
[17:43:40.479] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:43:40.479] Searching for globals ... DONE
[17:43:40.480] Resolving globals: FALSE
[17:43:40.480] 
[17:43:40.480] 
[17:43:40.480] getGlobalsAndPackages() ... DONE
[17:43:40.481] run() for ‘Future’ ...
[17:43:40.481] - state: ‘created’
[17:43:40.481] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:40.499] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:40.500] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:40.500]   - Field: ‘node’
[17:43:40.500]   - Field: ‘label’
[17:43:40.500]   - Field: ‘local’
[17:43:40.500]   - Field: ‘owner’
[17:43:40.501]   - Field: ‘envir’
[17:43:40.501]   - Field: ‘workers’
[17:43:40.501]   - Field: ‘packages’
[17:43:40.501]   - Field: ‘gc’
[17:43:40.501]   - Field: ‘conditions’
[17:43:40.501]   - Field: ‘persistent’
[17:43:40.501]   - Field: ‘expr’
[17:43:40.501]   - Field: ‘uuid’
[17:43:40.502]   - Field: ‘seed’
[17:43:40.502]   - Field: ‘version’
[17:43:40.502]   - Field: ‘result’
[17:43:40.502]   - Field: ‘asynchronous’
[17:43:40.502]   - Field: ‘calls’
[17:43:40.502]   - Field: ‘globals’
[17:43:40.503]   - Field: ‘stdout’
[17:43:40.503]   - Field: ‘earlySignal’
[17:43:40.503]   - Field: ‘lazy’
[17:43:40.503]   - Field: ‘state’
[17:43:40.503] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:40.503] - Launch lazy future ...
[17:43:40.504] Packages needed by the future expression (n = 0): <none>
[17:43:40.504] Packages needed by future strategies (n = 0): <none>
[17:43:40.504] {
[17:43:40.504]     {
[17:43:40.504]         {
[17:43:40.504]             ...future.startTime <- base::Sys.time()
[17:43:40.504]             {
[17:43:40.504]                 {
[17:43:40.504]                   {
[17:43:40.504]                     {
[17:43:40.504]                       base::local({
[17:43:40.504]                         has_future <- base::requireNamespace("future", 
[17:43:40.504]                           quietly = TRUE)
[17:43:40.504]                         if (has_future) {
[17:43:40.504]                           ns <- base::getNamespace("future")
[17:43:40.504]                           version <- ns[[".package"]][["version"]]
[17:43:40.504]                           if (is.null(version)) 
[17:43:40.504]                             version <- utils::packageVersion("future")
[17:43:40.504]                         }
[17:43:40.504]                         else {
[17:43:40.504]                           version <- NULL
[17:43:40.504]                         }
[17:43:40.504]                         if (!has_future || version < "1.8.0") {
[17:43:40.504]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:40.504]                             "", base::R.version$version.string), 
[17:43:40.504]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:40.504]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:40.504]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:40.504]                               "release", "version")], collapse = " "), 
[17:43:40.504]                             hostname = base::Sys.info()[["nodename"]])
[17:43:40.504]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:40.504]                             info)
[17:43:40.504]                           info <- base::paste(info, collapse = "; ")
[17:43:40.504]                           if (!has_future) {
[17:43:40.504]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:40.504]                               info)
[17:43:40.504]                           }
[17:43:40.504]                           else {
[17:43:40.504]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:40.504]                               info, version)
[17:43:40.504]                           }
[17:43:40.504]                           base::stop(msg)
[17:43:40.504]                         }
[17:43:40.504]                       })
[17:43:40.504]                     }
[17:43:40.504]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:40.504]                     base::options(mc.cores = 1L)
[17:43:40.504]                   }
[17:43:40.504]                   options(future.plan = NULL)
[17:43:40.504]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:40.504]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:40.504]                 }
[17:43:40.504]                 ...future.workdir <- getwd()
[17:43:40.504]             }
[17:43:40.504]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:40.504]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:40.504]         }
[17:43:40.504]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:40.504]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:40.504]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:40.504]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:40.504]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:40.504]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:40.504]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:40.504]             base::names(...future.oldOptions))
[17:43:40.504]     }
[17:43:40.504]     if (FALSE) {
[17:43:40.504]     }
[17:43:40.504]     else {
[17:43:40.504]         if (TRUE) {
[17:43:40.504]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:40.504]                 open = "w")
[17:43:40.504]         }
[17:43:40.504]         else {
[17:43:40.504]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:40.504]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:40.504]         }
[17:43:40.504]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:40.504]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:40.504]             base::sink(type = "output", split = FALSE)
[17:43:40.504]             base::close(...future.stdout)
[17:43:40.504]         }, add = TRUE)
[17:43:40.504]     }
[17:43:40.504]     ...future.frame <- base::sys.nframe()
[17:43:40.504]     ...future.conditions <- base::list()
[17:43:40.504]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:40.504]     if (FALSE) {
[17:43:40.504]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:40.504]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:40.504]     }
[17:43:40.504]     ...future.result <- base::tryCatch({
[17:43:40.504]         base::withCallingHandlers({
[17:43:40.504]             ...future.value <- base::withVisible(base::local({
[17:43:40.504]                 ...future.makeSendCondition <- local({
[17:43:40.504]                   sendCondition <- NULL
[17:43:40.504]                   function(frame = 1L) {
[17:43:40.504]                     if (is.function(sendCondition)) 
[17:43:40.504]                       return(sendCondition)
[17:43:40.504]                     ns <- getNamespace("parallel")
[17:43:40.504]                     if (exists("sendData", mode = "function", 
[17:43:40.504]                       envir = ns)) {
[17:43:40.504]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:40.504]                         envir = ns)
[17:43:40.504]                       envir <- sys.frame(frame)
[17:43:40.504]                       master <- NULL
[17:43:40.504]                       while (!identical(envir, .GlobalEnv) && 
[17:43:40.504]                         !identical(envir, emptyenv())) {
[17:43:40.504]                         if (exists("master", mode = "list", envir = envir, 
[17:43:40.504]                           inherits = FALSE)) {
[17:43:40.504]                           master <- get("master", mode = "list", 
[17:43:40.504]                             envir = envir, inherits = FALSE)
[17:43:40.504]                           if (inherits(master, c("SOCKnode", 
[17:43:40.504]                             "SOCK0node"))) {
[17:43:40.504]                             sendCondition <<- function(cond) {
[17:43:40.504]                               data <- list(type = "VALUE", value = cond, 
[17:43:40.504]                                 success = TRUE)
[17:43:40.504]                               parallel_sendData(master, data)
[17:43:40.504]                             }
[17:43:40.504]                             return(sendCondition)
[17:43:40.504]                           }
[17:43:40.504]                         }
[17:43:40.504]                         frame <- frame + 1L
[17:43:40.504]                         envir <- sys.frame(frame)
[17:43:40.504]                       }
[17:43:40.504]                     }
[17:43:40.504]                     sendCondition <<- function(cond) NULL
[17:43:40.504]                   }
[17:43:40.504]                 })
[17:43:40.504]                 withCallingHandlers({
[17:43:40.504]                   {
[17:43:40.504]                     Sys.sleep(0.5)
[17:43:40.504]                     list(a = 1, b = 42L)
[17:43:40.504]                   }
[17:43:40.504]                 }, immediateCondition = function(cond) {
[17:43:40.504]                   sendCondition <- ...future.makeSendCondition()
[17:43:40.504]                   sendCondition(cond)
[17:43:40.504]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:40.504]                   {
[17:43:40.504]                     inherits <- base::inherits
[17:43:40.504]                     invokeRestart <- base::invokeRestart
[17:43:40.504]                     is.null <- base::is.null
[17:43:40.504]                     muffled <- FALSE
[17:43:40.504]                     if (inherits(cond, "message")) {
[17:43:40.504]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:40.504]                       if (muffled) 
[17:43:40.504]                         invokeRestart("muffleMessage")
[17:43:40.504]                     }
[17:43:40.504]                     else if (inherits(cond, "warning")) {
[17:43:40.504]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:40.504]                       if (muffled) 
[17:43:40.504]                         invokeRestart("muffleWarning")
[17:43:40.504]                     }
[17:43:40.504]                     else if (inherits(cond, "condition")) {
[17:43:40.504]                       if (!is.null(pattern)) {
[17:43:40.504]                         computeRestarts <- base::computeRestarts
[17:43:40.504]                         grepl <- base::grepl
[17:43:40.504]                         restarts <- computeRestarts(cond)
[17:43:40.504]                         for (restart in restarts) {
[17:43:40.504]                           name <- restart$name
[17:43:40.504]                           if (is.null(name)) 
[17:43:40.504]                             next
[17:43:40.504]                           if (!grepl(pattern, name)) 
[17:43:40.504]                             next
[17:43:40.504]                           invokeRestart(restart)
[17:43:40.504]                           muffled <- TRUE
[17:43:40.504]                           break
[17:43:40.504]                         }
[17:43:40.504]                       }
[17:43:40.504]                     }
[17:43:40.504]                     invisible(muffled)
[17:43:40.504]                   }
[17:43:40.504]                   muffleCondition(cond)
[17:43:40.504]                 })
[17:43:40.504]             }))
[17:43:40.504]             future::FutureResult(value = ...future.value$value, 
[17:43:40.504]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:40.504]                   ...future.rng), globalenv = if (FALSE) 
[17:43:40.504]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:40.504]                     ...future.globalenv.names))
[17:43:40.504]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:40.504]         }, condition = base::local({
[17:43:40.504]             c <- base::c
[17:43:40.504]             inherits <- base::inherits
[17:43:40.504]             invokeRestart <- base::invokeRestart
[17:43:40.504]             length <- base::length
[17:43:40.504]             list <- base::list
[17:43:40.504]             seq.int <- base::seq.int
[17:43:40.504]             signalCondition <- base::signalCondition
[17:43:40.504]             sys.calls <- base::sys.calls
[17:43:40.504]             `[[` <- base::`[[`
[17:43:40.504]             `+` <- base::`+`
[17:43:40.504]             `<<-` <- base::`<<-`
[17:43:40.504]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:40.504]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:40.504]                   3L)]
[17:43:40.504]             }
[17:43:40.504]             function(cond) {
[17:43:40.504]                 is_error <- inherits(cond, "error")
[17:43:40.504]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:40.504]                   NULL)
[17:43:40.504]                 if (is_error) {
[17:43:40.504]                   sessionInformation <- function() {
[17:43:40.504]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:40.504]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:40.504]                       search = base::search(), system = base::Sys.info())
[17:43:40.504]                   }
[17:43:40.504]                   ...future.conditions[[length(...future.conditions) + 
[17:43:40.504]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:40.504]                     cond$call), session = sessionInformation(), 
[17:43:40.504]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:40.504]                   signalCondition(cond)
[17:43:40.504]                 }
[17:43:40.504]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:40.504]                 "immediateCondition"))) {
[17:43:40.504]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:40.504]                   ...future.conditions[[length(...future.conditions) + 
[17:43:40.504]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:40.504]                   if (TRUE && !signal) {
[17:43:40.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:40.504]                     {
[17:43:40.504]                       inherits <- base::inherits
[17:43:40.504]                       invokeRestart <- base::invokeRestart
[17:43:40.504]                       is.null <- base::is.null
[17:43:40.504]                       muffled <- FALSE
[17:43:40.504]                       if (inherits(cond, "message")) {
[17:43:40.504]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:40.504]                         if (muffled) 
[17:43:40.504]                           invokeRestart("muffleMessage")
[17:43:40.504]                       }
[17:43:40.504]                       else if (inherits(cond, "warning")) {
[17:43:40.504]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:40.504]                         if (muffled) 
[17:43:40.504]                           invokeRestart("muffleWarning")
[17:43:40.504]                       }
[17:43:40.504]                       else if (inherits(cond, "condition")) {
[17:43:40.504]                         if (!is.null(pattern)) {
[17:43:40.504]                           computeRestarts <- base::computeRestarts
[17:43:40.504]                           grepl <- base::grepl
[17:43:40.504]                           restarts <- computeRestarts(cond)
[17:43:40.504]                           for (restart in restarts) {
[17:43:40.504]                             name <- restart$name
[17:43:40.504]                             if (is.null(name)) 
[17:43:40.504]                               next
[17:43:40.504]                             if (!grepl(pattern, name)) 
[17:43:40.504]                               next
[17:43:40.504]                             invokeRestart(restart)
[17:43:40.504]                             muffled <- TRUE
[17:43:40.504]                             break
[17:43:40.504]                           }
[17:43:40.504]                         }
[17:43:40.504]                       }
[17:43:40.504]                       invisible(muffled)
[17:43:40.504]                     }
[17:43:40.504]                     muffleCondition(cond, pattern = "^muffle")
[17:43:40.504]                   }
[17:43:40.504]                 }
[17:43:40.504]                 else {
[17:43:40.504]                   if (TRUE) {
[17:43:40.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:40.504]                     {
[17:43:40.504]                       inherits <- base::inherits
[17:43:40.504]                       invokeRestart <- base::invokeRestart
[17:43:40.504]                       is.null <- base::is.null
[17:43:40.504]                       muffled <- FALSE
[17:43:40.504]                       if (inherits(cond, "message")) {
[17:43:40.504]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:40.504]                         if (muffled) 
[17:43:40.504]                           invokeRestart("muffleMessage")
[17:43:40.504]                       }
[17:43:40.504]                       else if (inherits(cond, "warning")) {
[17:43:40.504]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:40.504]                         if (muffled) 
[17:43:40.504]                           invokeRestart("muffleWarning")
[17:43:40.504]                       }
[17:43:40.504]                       else if (inherits(cond, "condition")) {
[17:43:40.504]                         if (!is.null(pattern)) {
[17:43:40.504]                           computeRestarts <- base::computeRestarts
[17:43:40.504]                           grepl <- base::grepl
[17:43:40.504]                           restarts <- computeRestarts(cond)
[17:43:40.504]                           for (restart in restarts) {
[17:43:40.504]                             name <- restart$name
[17:43:40.504]                             if (is.null(name)) 
[17:43:40.504]                               next
[17:43:40.504]                             if (!grepl(pattern, name)) 
[17:43:40.504]                               next
[17:43:40.504]                             invokeRestart(restart)
[17:43:40.504]                             muffled <- TRUE
[17:43:40.504]                             break
[17:43:40.504]                           }
[17:43:40.504]                         }
[17:43:40.504]                       }
[17:43:40.504]                       invisible(muffled)
[17:43:40.504]                     }
[17:43:40.504]                     muffleCondition(cond, pattern = "^muffle")
[17:43:40.504]                   }
[17:43:40.504]                 }
[17:43:40.504]             }
[17:43:40.504]         }))
[17:43:40.504]     }, error = function(ex) {
[17:43:40.504]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:40.504]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:40.504]                 ...future.rng), started = ...future.startTime, 
[17:43:40.504]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:40.504]             version = "1.8"), class = "FutureResult")
[17:43:40.504]     }, finally = {
[17:43:40.504]         if (!identical(...future.workdir, getwd())) 
[17:43:40.504]             setwd(...future.workdir)
[17:43:40.504]         {
[17:43:40.504]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:40.504]                 ...future.oldOptions$nwarnings <- NULL
[17:43:40.504]             }
[17:43:40.504]             base::options(...future.oldOptions)
[17:43:40.504]             if (.Platform$OS.type == "windows") {
[17:43:40.504]                 old_names <- names(...future.oldEnvVars)
[17:43:40.504]                 envs <- base::Sys.getenv()
[17:43:40.504]                 names <- names(envs)
[17:43:40.504]                 common <- intersect(names, old_names)
[17:43:40.504]                 added <- setdiff(names, old_names)
[17:43:40.504]                 removed <- setdiff(old_names, names)
[17:43:40.504]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:40.504]                   envs[common]]
[17:43:40.504]                 NAMES <- toupper(changed)
[17:43:40.504]                 args <- list()
[17:43:40.504]                 for (kk in seq_along(NAMES)) {
[17:43:40.504]                   name <- changed[[kk]]
[17:43:40.504]                   NAME <- NAMES[[kk]]
[17:43:40.504]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:40.504]                     next
[17:43:40.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:40.504]                 }
[17:43:40.504]                 NAMES <- toupper(added)
[17:43:40.504]                 for (kk in seq_along(NAMES)) {
[17:43:40.504]                   name <- added[[kk]]
[17:43:40.504]                   NAME <- NAMES[[kk]]
[17:43:40.504]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:40.504]                     next
[17:43:40.504]                   args[[name]] <- ""
[17:43:40.504]                 }
[17:43:40.504]                 NAMES <- toupper(removed)
[17:43:40.504]                 for (kk in seq_along(NAMES)) {
[17:43:40.504]                   name <- removed[[kk]]
[17:43:40.504]                   NAME <- NAMES[[kk]]
[17:43:40.504]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:40.504]                     next
[17:43:40.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:40.504]                 }
[17:43:40.504]                 if (length(args) > 0) 
[17:43:40.504]                   base::do.call(base::Sys.setenv, args = args)
[17:43:40.504]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:40.504]             }
[17:43:40.504]             else {
[17:43:40.504]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:40.504]             }
[17:43:40.504]             {
[17:43:40.504]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:40.504]                   0L) {
[17:43:40.504]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:40.504]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:40.504]                   base::options(opts)
[17:43:40.504]                 }
[17:43:40.504]                 {
[17:43:40.504]                   {
[17:43:40.504]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:40.504]                     NULL
[17:43:40.504]                   }
[17:43:40.504]                   options(future.plan = NULL)
[17:43:40.504]                   if (is.na(NA_character_)) 
[17:43:40.504]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:40.504]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:40.504]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:40.504]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:40.504]                     envir = parent.frame()) 
[17:43:40.504]                   {
[17:43:40.504]                     if (is.function(workers)) 
[17:43:40.504]                       workers <- workers()
[17:43:40.504]                     workers <- structure(as.integer(workers), 
[17:43:40.504]                       class = class(workers))
[17:43:40.504]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:40.504]                       workers >= 1)
[17:43:40.504]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:40.504]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:40.504]                     }
[17:43:40.504]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:40.504]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:40.504]                       envir = envir)
[17:43:40.504]                     if (!future$lazy) 
[17:43:40.504]                       future <- run(future)
[17:43:40.504]                     invisible(future)
[17:43:40.504]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:40.504]                 }
[17:43:40.504]             }
[17:43:40.504]         }
[17:43:40.504]     })
[17:43:40.504]     if (TRUE) {
[17:43:40.504]         base::sink(type = "output", split = FALSE)
[17:43:40.504]         if (TRUE) {
[17:43:40.504]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:40.504]         }
[17:43:40.504]         else {
[17:43:40.504]             ...future.result["stdout"] <- base::list(NULL)
[17:43:40.504]         }
[17:43:40.504]         base::close(...future.stdout)
[17:43:40.504]         ...future.stdout <- NULL
[17:43:40.504]     }
[17:43:40.504]     ...future.result$conditions <- ...future.conditions
[17:43:40.504]     ...future.result$finished <- base::Sys.time()
[17:43:40.504]     ...future.result
[17:43:40.504] }
[17:43:40.506] Poll #1 (0): usedNodes() = 2, workers = 2
[17:43:40.528] receiveMessageFromWorker() for ClusterFuture ...
[17:43:40.528] - Validating connection of MultisessionFuture
[17:43:40.528] - received message: FutureResult
[17:43:40.528] - Received FutureResult
[17:43:40.529] - Erased future from FutureRegistry
[17:43:40.529] result() for ClusterFuture ...
[17:43:40.529] - result already collected: FutureResult
[17:43:40.529] result() for ClusterFuture ... done
[17:43:40.529] signalConditions() ...
[17:43:40.529]  - include = ‘immediateCondition’
[17:43:40.529]  - exclude = 
[17:43:40.529]  - resignal = FALSE
[17:43:40.529]  - Number of conditions: 1
[17:43:40.529] signalConditions() ... done
[17:43:40.529] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:40.530] result() for ClusterFuture ...
[17:43:40.530] - result already collected: FutureResult
[17:43:40.530] result() for ClusterFuture ... done
[17:43:40.530] result() for ClusterFuture ...
[17:43:40.530] - result already collected: FutureResult
[17:43:40.530] result() for ClusterFuture ... done
[17:43:40.530] signalConditions() ...
[17:43:40.530]  - include = ‘immediateCondition’
[17:43:40.530]  - exclude = 
[17:43:40.530]  - resignal = FALSE
[17:43:40.530]  - Number of conditions: 1
[17:43:40.531] signalConditions() ... done
[17:43:40.532] MultisessionFuture started
[17:43:40.532] - Launch lazy future ... done
[17:43:40.532] run() for ‘MultisessionFuture’ ... done
[17:43:41.091] receiveMessageFromWorker() for ClusterFuture ...
[17:43:41.092] - Validating connection of MultisessionFuture
[17:43:41.092] - received message: FutureResult
[17:43:41.092] - Received FutureResult
[17:43:41.092] - Erased future from FutureRegistry
[17:43:41.092] result() for ClusterFuture ...
[17:43:41.092] - result already collected: FutureResult
[17:43:41.092] result() for ClusterFuture ... done
[17:43:41.092] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:41.093] A MultisessionFuture was resolved (result was not collected)
[17:43:41.093] getGlobalsAndPackages() ...
[17:43:41.093] Searching for globals...
[17:43:41.094] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:43:41.094] Searching for globals ... DONE
[17:43:41.094] Resolving globals: FALSE
[17:43:41.094] 
[17:43:41.095] 
[17:43:41.095] getGlobalsAndPackages() ... DONE
[17:43:41.095] run() for ‘Future’ ...
[17:43:41.095] - state: ‘created’
[17:43:41.095] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:41.110] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:41.110] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:41.110]   - Field: ‘node’
[17:43:41.110]   - Field: ‘label’
[17:43:41.110]   - Field: ‘local’
[17:43:41.110]   - Field: ‘owner’
[17:43:41.111]   - Field: ‘envir’
[17:43:41.111]   - Field: ‘workers’
[17:43:41.111]   - Field: ‘packages’
[17:43:41.111]   - Field: ‘gc’
[17:43:41.111]   - Field: ‘conditions’
[17:43:41.111]   - Field: ‘persistent’
[17:43:41.111]   - Field: ‘expr’
[17:43:41.111]   - Field: ‘uuid’
[17:43:41.111]   - Field: ‘seed’
[17:43:41.111]   - Field: ‘version’
[17:43:41.112]   - Field: ‘result’
[17:43:41.112]   - Field: ‘asynchronous’
[17:43:41.112]   - Field: ‘calls’
[17:43:41.112]   - Field: ‘globals’
[17:43:41.112]   - Field: ‘stdout’
[17:43:41.112]   - Field: ‘earlySignal’
[17:43:41.112]   - Field: ‘lazy’
[17:43:41.112]   - Field: ‘state’
[17:43:41.112] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:41.112] - Launch lazy future ...
[17:43:41.113] Packages needed by the future expression (n = 0): <none>
[17:43:41.113] Packages needed by future strategies (n = 0): <none>
[17:43:41.113] {
[17:43:41.113]     {
[17:43:41.113]         {
[17:43:41.113]             ...future.startTime <- base::Sys.time()
[17:43:41.113]             {
[17:43:41.113]                 {
[17:43:41.113]                   {
[17:43:41.113]                     {
[17:43:41.113]                       base::local({
[17:43:41.113]                         has_future <- base::requireNamespace("future", 
[17:43:41.113]                           quietly = TRUE)
[17:43:41.113]                         if (has_future) {
[17:43:41.113]                           ns <- base::getNamespace("future")
[17:43:41.113]                           version <- ns[[".package"]][["version"]]
[17:43:41.113]                           if (is.null(version)) 
[17:43:41.113]                             version <- utils::packageVersion("future")
[17:43:41.113]                         }
[17:43:41.113]                         else {
[17:43:41.113]                           version <- NULL
[17:43:41.113]                         }
[17:43:41.113]                         if (!has_future || version < "1.8.0") {
[17:43:41.113]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:41.113]                             "", base::R.version$version.string), 
[17:43:41.113]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:41.113]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:41.113]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:41.113]                               "release", "version")], collapse = " "), 
[17:43:41.113]                             hostname = base::Sys.info()[["nodename"]])
[17:43:41.113]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:41.113]                             info)
[17:43:41.113]                           info <- base::paste(info, collapse = "; ")
[17:43:41.113]                           if (!has_future) {
[17:43:41.113]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:41.113]                               info)
[17:43:41.113]                           }
[17:43:41.113]                           else {
[17:43:41.113]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:41.113]                               info, version)
[17:43:41.113]                           }
[17:43:41.113]                           base::stop(msg)
[17:43:41.113]                         }
[17:43:41.113]                       })
[17:43:41.113]                     }
[17:43:41.113]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:41.113]                     base::options(mc.cores = 1L)
[17:43:41.113]                   }
[17:43:41.113]                   options(future.plan = NULL)
[17:43:41.113]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:41.113]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:41.113]                 }
[17:43:41.113]                 ...future.workdir <- getwd()
[17:43:41.113]             }
[17:43:41.113]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:41.113]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:41.113]         }
[17:43:41.113]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:41.113]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:41.113]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:41.113]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:41.113]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:41.113]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:41.113]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:41.113]             base::names(...future.oldOptions))
[17:43:41.113]     }
[17:43:41.113]     if (FALSE) {
[17:43:41.113]     }
[17:43:41.113]     else {
[17:43:41.113]         if (TRUE) {
[17:43:41.113]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:41.113]                 open = "w")
[17:43:41.113]         }
[17:43:41.113]         else {
[17:43:41.113]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:41.113]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:41.113]         }
[17:43:41.113]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:41.113]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:41.113]             base::sink(type = "output", split = FALSE)
[17:43:41.113]             base::close(...future.stdout)
[17:43:41.113]         }, add = TRUE)
[17:43:41.113]     }
[17:43:41.113]     ...future.frame <- base::sys.nframe()
[17:43:41.113]     ...future.conditions <- base::list()
[17:43:41.113]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:41.113]     if (FALSE) {
[17:43:41.113]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:41.113]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:41.113]     }
[17:43:41.113]     ...future.result <- base::tryCatch({
[17:43:41.113]         base::withCallingHandlers({
[17:43:41.113]             ...future.value <- base::withVisible(base::local({
[17:43:41.113]                 ...future.makeSendCondition <- local({
[17:43:41.113]                   sendCondition <- NULL
[17:43:41.113]                   function(frame = 1L) {
[17:43:41.113]                     if (is.function(sendCondition)) 
[17:43:41.113]                       return(sendCondition)
[17:43:41.113]                     ns <- getNamespace("parallel")
[17:43:41.113]                     if (exists("sendData", mode = "function", 
[17:43:41.113]                       envir = ns)) {
[17:43:41.113]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:41.113]                         envir = ns)
[17:43:41.113]                       envir <- sys.frame(frame)
[17:43:41.113]                       master <- NULL
[17:43:41.113]                       while (!identical(envir, .GlobalEnv) && 
[17:43:41.113]                         !identical(envir, emptyenv())) {
[17:43:41.113]                         if (exists("master", mode = "list", envir = envir, 
[17:43:41.113]                           inherits = FALSE)) {
[17:43:41.113]                           master <- get("master", mode = "list", 
[17:43:41.113]                             envir = envir, inherits = FALSE)
[17:43:41.113]                           if (inherits(master, c("SOCKnode", 
[17:43:41.113]                             "SOCK0node"))) {
[17:43:41.113]                             sendCondition <<- function(cond) {
[17:43:41.113]                               data <- list(type = "VALUE", value = cond, 
[17:43:41.113]                                 success = TRUE)
[17:43:41.113]                               parallel_sendData(master, data)
[17:43:41.113]                             }
[17:43:41.113]                             return(sendCondition)
[17:43:41.113]                           }
[17:43:41.113]                         }
[17:43:41.113]                         frame <- frame + 1L
[17:43:41.113]                         envir <- sys.frame(frame)
[17:43:41.113]                       }
[17:43:41.113]                     }
[17:43:41.113]                     sendCondition <<- function(cond) NULL
[17:43:41.113]                   }
[17:43:41.113]                 })
[17:43:41.113]                 withCallingHandlers({
[17:43:41.113]                   {
[17:43:41.113]                     Sys.sleep(0.5)
[17:43:41.113]                     list(a = 1, b = 42L)
[17:43:41.113]                   }
[17:43:41.113]                 }, immediateCondition = function(cond) {
[17:43:41.113]                   sendCondition <- ...future.makeSendCondition()
[17:43:41.113]                   sendCondition(cond)
[17:43:41.113]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:41.113]                   {
[17:43:41.113]                     inherits <- base::inherits
[17:43:41.113]                     invokeRestart <- base::invokeRestart
[17:43:41.113]                     is.null <- base::is.null
[17:43:41.113]                     muffled <- FALSE
[17:43:41.113]                     if (inherits(cond, "message")) {
[17:43:41.113]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:41.113]                       if (muffled) 
[17:43:41.113]                         invokeRestart("muffleMessage")
[17:43:41.113]                     }
[17:43:41.113]                     else if (inherits(cond, "warning")) {
[17:43:41.113]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:41.113]                       if (muffled) 
[17:43:41.113]                         invokeRestart("muffleWarning")
[17:43:41.113]                     }
[17:43:41.113]                     else if (inherits(cond, "condition")) {
[17:43:41.113]                       if (!is.null(pattern)) {
[17:43:41.113]                         computeRestarts <- base::computeRestarts
[17:43:41.113]                         grepl <- base::grepl
[17:43:41.113]                         restarts <- computeRestarts(cond)
[17:43:41.113]                         for (restart in restarts) {
[17:43:41.113]                           name <- restart$name
[17:43:41.113]                           if (is.null(name)) 
[17:43:41.113]                             next
[17:43:41.113]                           if (!grepl(pattern, name)) 
[17:43:41.113]                             next
[17:43:41.113]                           invokeRestart(restart)
[17:43:41.113]                           muffled <- TRUE
[17:43:41.113]                           break
[17:43:41.113]                         }
[17:43:41.113]                       }
[17:43:41.113]                     }
[17:43:41.113]                     invisible(muffled)
[17:43:41.113]                   }
[17:43:41.113]                   muffleCondition(cond)
[17:43:41.113]                 })
[17:43:41.113]             }))
[17:43:41.113]             future::FutureResult(value = ...future.value$value, 
[17:43:41.113]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:41.113]                   ...future.rng), globalenv = if (FALSE) 
[17:43:41.113]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:41.113]                     ...future.globalenv.names))
[17:43:41.113]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:41.113]         }, condition = base::local({
[17:43:41.113]             c <- base::c
[17:43:41.113]             inherits <- base::inherits
[17:43:41.113]             invokeRestart <- base::invokeRestart
[17:43:41.113]             length <- base::length
[17:43:41.113]             list <- base::list
[17:43:41.113]             seq.int <- base::seq.int
[17:43:41.113]             signalCondition <- base::signalCondition
[17:43:41.113]             sys.calls <- base::sys.calls
[17:43:41.113]             `[[` <- base::`[[`
[17:43:41.113]             `+` <- base::`+`
[17:43:41.113]             `<<-` <- base::`<<-`
[17:43:41.113]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:41.113]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:41.113]                   3L)]
[17:43:41.113]             }
[17:43:41.113]             function(cond) {
[17:43:41.113]                 is_error <- inherits(cond, "error")
[17:43:41.113]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:41.113]                   NULL)
[17:43:41.113]                 if (is_error) {
[17:43:41.113]                   sessionInformation <- function() {
[17:43:41.113]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:41.113]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:41.113]                       search = base::search(), system = base::Sys.info())
[17:43:41.113]                   }
[17:43:41.113]                   ...future.conditions[[length(...future.conditions) + 
[17:43:41.113]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:41.113]                     cond$call), session = sessionInformation(), 
[17:43:41.113]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:41.113]                   signalCondition(cond)
[17:43:41.113]                 }
[17:43:41.113]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:41.113]                 "immediateCondition"))) {
[17:43:41.113]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:41.113]                   ...future.conditions[[length(...future.conditions) + 
[17:43:41.113]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:41.113]                   if (TRUE && !signal) {
[17:43:41.113]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:41.113]                     {
[17:43:41.113]                       inherits <- base::inherits
[17:43:41.113]                       invokeRestart <- base::invokeRestart
[17:43:41.113]                       is.null <- base::is.null
[17:43:41.113]                       muffled <- FALSE
[17:43:41.113]                       if (inherits(cond, "message")) {
[17:43:41.113]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:41.113]                         if (muffled) 
[17:43:41.113]                           invokeRestart("muffleMessage")
[17:43:41.113]                       }
[17:43:41.113]                       else if (inherits(cond, "warning")) {
[17:43:41.113]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:41.113]                         if (muffled) 
[17:43:41.113]                           invokeRestart("muffleWarning")
[17:43:41.113]                       }
[17:43:41.113]                       else if (inherits(cond, "condition")) {
[17:43:41.113]                         if (!is.null(pattern)) {
[17:43:41.113]                           computeRestarts <- base::computeRestarts
[17:43:41.113]                           grepl <- base::grepl
[17:43:41.113]                           restarts <- computeRestarts(cond)
[17:43:41.113]                           for (restart in restarts) {
[17:43:41.113]                             name <- restart$name
[17:43:41.113]                             if (is.null(name)) 
[17:43:41.113]                               next
[17:43:41.113]                             if (!grepl(pattern, name)) 
[17:43:41.113]                               next
[17:43:41.113]                             invokeRestart(restart)
[17:43:41.113]                             muffled <- TRUE
[17:43:41.113]                             break
[17:43:41.113]                           }
[17:43:41.113]                         }
[17:43:41.113]                       }
[17:43:41.113]                       invisible(muffled)
[17:43:41.113]                     }
[17:43:41.113]                     muffleCondition(cond, pattern = "^muffle")
[17:43:41.113]                   }
[17:43:41.113]                 }
[17:43:41.113]                 else {
[17:43:41.113]                   if (TRUE) {
[17:43:41.113]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:41.113]                     {
[17:43:41.113]                       inherits <- base::inherits
[17:43:41.113]                       invokeRestart <- base::invokeRestart
[17:43:41.113]                       is.null <- base::is.null
[17:43:41.113]                       muffled <- FALSE
[17:43:41.113]                       if (inherits(cond, "message")) {
[17:43:41.113]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:41.113]                         if (muffled) 
[17:43:41.113]                           invokeRestart("muffleMessage")
[17:43:41.113]                       }
[17:43:41.113]                       else if (inherits(cond, "warning")) {
[17:43:41.113]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:41.113]                         if (muffled) 
[17:43:41.113]                           invokeRestart("muffleWarning")
[17:43:41.113]                       }
[17:43:41.113]                       else if (inherits(cond, "condition")) {
[17:43:41.113]                         if (!is.null(pattern)) {
[17:43:41.113]                           computeRestarts <- base::computeRestarts
[17:43:41.113]                           grepl <- base::grepl
[17:43:41.113]                           restarts <- computeRestarts(cond)
[17:43:41.113]                           for (restart in restarts) {
[17:43:41.113]                             name <- restart$name
[17:43:41.113]                             if (is.null(name)) 
[17:43:41.113]                               next
[17:43:41.113]                             if (!grepl(pattern, name)) 
[17:43:41.113]                               next
[17:43:41.113]                             invokeRestart(restart)
[17:43:41.113]                             muffled <- TRUE
[17:43:41.113]                             break
[17:43:41.113]                           }
[17:43:41.113]                         }
[17:43:41.113]                       }
[17:43:41.113]                       invisible(muffled)
[17:43:41.113]                     }
[17:43:41.113]                     muffleCondition(cond, pattern = "^muffle")
[17:43:41.113]                   }
[17:43:41.113]                 }
[17:43:41.113]             }
[17:43:41.113]         }))
[17:43:41.113]     }, error = function(ex) {
[17:43:41.113]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:41.113]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:41.113]                 ...future.rng), started = ...future.startTime, 
[17:43:41.113]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:41.113]             version = "1.8"), class = "FutureResult")
[17:43:41.113]     }, finally = {
[17:43:41.113]         if (!identical(...future.workdir, getwd())) 
[17:43:41.113]             setwd(...future.workdir)
[17:43:41.113]         {
[17:43:41.113]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:41.113]                 ...future.oldOptions$nwarnings <- NULL
[17:43:41.113]             }
[17:43:41.113]             base::options(...future.oldOptions)
[17:43:41.113]             if (.Platform$OS.type == "windows") {
[17:43:41.113]                 old_names <- names(...future.oldEnvVars)
[17:43:41.113]                 envs <- base::Sys.getenv()
[17:43:41.113]                 names <- names(envs)
[17:43:41.113]                 common <- intersect(names, old_names)
[17:43:41.113]                 added <- setdiff(names, old_names)
[17:43:41.113]                 removed <- setdiff(old_names, names)
[17:43:41.113]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:41.113]                   envs[common]]
[17:43:41.113]                 NAMES <- toupper(changed)
[17:43:41.113]                 args <- list()
[17:43:41.113]                 for (kk in seq_along(NAMES)) {
[17:43:41.113]                   name <- changed[[kk]]
[17:43:41.113]                   NAME <- NAMES[[kk]]
[17:43:41.113]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:41.113]                     next
[17:43:41.113]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:41.113]                 }
[17:43:41.113]                 NAMES <- toupper(added)
[17:43:41.113]                 for (kk in seq_along(NAMES)) {
[17:43:41.113]                   name <- added[[kk]]
[17:43:41.113]                   NAME <- NAMES[[kk]]
[17:43:41.113]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:41.113]                     next
[17:43:41.113]                   args[[name]] <- ""
[17:43:41.113]                 }
[17:43:41.113]                 NAMES <- toupper(removed)
[17:43:41.113]                 for (kk in seq_along(NAMES)) {
[17:43:41.113]                   name <- removed[[kk]]
[17:43:41.113]                   NAME <- NAMES[[kk]]
[17:43:41.113]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:41.113]                     next
[17:43:41.113]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:41.113]                 }
[17:43:41.113]                 if (length(args) > 0) 
[17:43:41.113]                   base::do.call(base::Sys.setenv, args = args)
[17:43:41.113]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:41.113]             }
[17:43:41.113]             else {
[17:43:41.113]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:41.113]             }
[17:43:41.113]             {
[17:43:41.113]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:41.113]                   0L) {
[17:43:41.113]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:41.113]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:41.113]                   base::options(opts)
[17:43:41.113]                 }
[17:43:41.113]                 {
[17:43:41.113]                   {
[17:43:41.113]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:41.113]                     NULL
[17:43:41.113]                   }
[17:43:41.113]                   options(future.plan = NULL)
[17:43:41.113]                   if (is.na(NA_character_)) 
[17:43:41.113]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:41.113]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:41.113]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:41.113]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:41.113]                     envir = parent.frame()) 
[17:43:41.113]                   {
[17:43:41.113]                     if (is.function(workers)) 
[17:43:41.113]                       workers <- workers()
[17:43:41.113]                     workers <- structure(as.integer(workers), 
[17:43:41.113]                       class = class(workers))
[17:43:41.113]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:41.113]                       workers >= 1)
[17:43:41.113]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:41.113]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:41.113]                     }
[17:43:41.113]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:41.113]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:41.113]                       envir = envir)
[17:43:41.113]                     if (!future$lazy) 
[17:43:41.113]                       future <- run(future)
[17:43:41.113]                     invisible(future)
[17:43:41.113]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:41.113]                 }
[17:43:41.113]             }
[17:43:41.113]         }
[17:43:41.113]     })
[17:43:41.113]     if (TRUE) {
[17:43:41.113]         base::sink(type = "output", split = FALSE)
[17:43:41.113]         if (TRUE) {
[17:43:41.113]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:41.113]         }
[17:43:41.113]         else {
[17:43:41.113]             ...future.result["stdout"] <- base::list(NULL)
[17:43:41.113]         }
[17:43:41.113]         base::close(...future.stdout)
[17:43:41.113]         ...future.stdout <- NULL
[17:43:41.113]     }
[17:43:41.113]     ...future.result$conditions <- ...future.conditions
[17:43:41.113]     ...future.result$finished <- base::Sys.time()
[17:43:41.113]     ...future.result
[17:43:41.113] }
[17:43:41.116] MultisessionFuture started
[17:43:41.116] - Launch lazy future ... done
[17:43:41.117] run() for ‘MultisessionFuture’ ... done
[17:43:41.665] receiveMessageFromWorker() for ClusterFuture ...
[17:43:41.665] - Validating connection of MultisessionFuture
[17:43:41.666] - received message: FutureResult
[17:43:41.666] - Received FutureResult
[17:43:41.666] - Erased future from FutureRegistry
[17:43:41.666] result() for ClusterFuture ...
[17:43:41.666] - result already collected: FutureResult
[17:43:41.666] result() for ClusterFuture ... done
[17:43:41.666] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:41.667] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[17:43:41.667] getGlobalsAndPackages() ...
[17:43:41.667] Searching for globals...
[17:43:41.668] - globals found: [2] ‘list’, ‘stop’
[17:43:41.668] Searching for globals ... DONE
[17:43:41.668] Resolving globals: FALSE
[17:43:41.668] 
[17:43:41.668] 
[17:43:41.668] getGlobalsAndPackages() ... DONE
[17:43:41.668] run() for ‘Future’ ...
[17:43:41.669] - state: ‘created’
[17:43:41.669] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:41.685] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:41.685] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:41.686]   - Field: ‘node’
[17:43:41.686]   - Field: ‘label’
[17:43:41.686]   - Field: ‘local’
[17:43:41.686]   - Field: ‘owner’
[17:43:41.686]   - Field: ‘envir’
[17:43:41.686]   - Field: ‘workers’
[17:43:41.686]   - Field: ‘packages’
[17:43:41.686]   - Field: ‘gc’
[17:43:41.686]   - Field: ‘conditions’
[17:43:41.686]   - Field: ‘persistent’
[17:43:41.686]   - Field: ‘expr’
[17:43:41.687]   - Field: ‘uuid’
[17:43:41.687]   - Field: ‘seed’
[17:43:41.687]   - Field: ‘version’
[17:43:41.687]   - Field: ‘result’
[17:43:41.687]   - Field: ‘asynchronous’
[17:43:41.687]   - Field: ‘calls’
[17:43:41.687]   - Field: ‘globals’
[17:43:41.687]   - Field: ‘stdout’
[17:43:41.687]   - Field: ‘earlySignal’
[17:43:41.687]   - Field: ‘lazy’
[17:43:41.687]   - Field: ‘state’
[17:43:41.688] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:41.688] - Launch lazy future ...
[17:43:41.688] Packages needed by the future expression (n = 0): <none>
[17:43:41.688] Packages needed by future strategies (n = 0): <none>
[17:43:41.688] {
[17:43:41.688]     {
[17:43:41.688]         {
[17:43:41.688]             ...future.startTime <- base::Sys.time()
[17:43:41.688]             {
[17:43:41.688]                 {
[17:43:41.688]                   {
[17:43:41.688]                     {
[17:43:41.688]                       base::local({
[17:43:41.688]                         has_future <- base::requireNamespace("future", 
[17:43:41.688]                           quietly = TRUE)
[17:43:41.688]                         if (has_future) {
[17:43:41.688]                           ns <- base::getNamespace("future")
[17:43:41.688]                           version <- ns[[".package"]][["version"]]
[17:43:41.688]                           if (is.null(version)) 
[17:43:41.688]                             version <- utils::packageVersion("future")
[17:43:41.688]                         }
[17:43:41.688]                         else {
[17:43:41.688]                           version <- NULL
[17:43:41.688]                         }
[17:43:41.688]                         if (!has_future || version < "1.8.0") {
[17:43:41.688]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:41.688]                             "", base::R.version$version.string), 
[17:43:41.688]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:41.688]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:41.688]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:41.688]                               "release", "version")], collapse = " "), 
[17:43:41.688]                             hostname = base::Sys.info()[["nodename"]])
[17:43:41.688]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:41.688]                             info)
[17:43:41.688]                           info <- base::paste(info, collapse = "; ")
[17:43:41.688]                           if (!has_future) {
[17:43:41.688]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:41.688]                               info)
[17:43:41.688]                           }
[17:43:41.688]                           else {
[17:43:41.688]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:41.688]                               info, version)
[17:43:41.688]                           }
[17:43:41.688]                           base::stop(msg)
[17:43:41.688]                         }
[17:43:41.688]                       })
[17:43:41.688]                     }
[17:43:41.688]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:41.688]                     base::options(mc.cores = 1L)
[17:43:41.688]                   }
[17:43:41.688]                   options(future.plan = NULL)
[17:43:41.688]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:41.688]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:41.688]                 }
[17:43:41.688]                 ...future.workdir <- getwd()
[17:43:41.688]             }
[17:43:41.688]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:41.688]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:41.688]         }
[17:43:41.688]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:41.688]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:41.688]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:41.688]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:41.688]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:41.688]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:41.688]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:41.688]             base::names(...future.oldOptions))
[17:43:41.688]     }
[17:43:41.688]     if (FALSE) {
[17:43:41.688]     }
[17:43:41.688]     else {
[17:43:41.688]         if (TRUE) {
[17:43:41.688]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:41.688]                 open = "w")
[17:43:41.688]         }
[17:43:41.688]         else {
[17:43:41.688]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:41.688]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:41.688]         }
[17:43:41.688]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:41.688]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:41.688]             base::sink(type = "output", split = FALSE)
[17:43:41.688]             base::close(...future.stdout)
[17:43:41.688]         }, add = TRUE)
[17:43:41.688]     }
[17:43:41.688]     ...future.frame <- base::sys.nframe()
[17:43:41.688]     ...future.conditions <- base::list()
[17:43:41.688]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:41.688]     if (FALSE) {
[17:43:41.688]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:41.688]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:41.688]     }
[17:43:41.688]     ...future.result <- base::tryCatch({
[17:43:41.688]         base::withCallingHandlers({
[17:43:41.688]             ...future.value <- base::withVisible(base::local({
[17:43:41.688]                 ...future.makeSendCondition <- local({
[17:43:41.688]                   sendCondition <- NULL
[17:43:41.688]                   function(frame = 1L) {
[17:43:41.688]                     if (is.function(sendCondition)) 
[17:43:41.688]                       return(sendCondition)
[17:43:41.688]                     ns <- getNamespace("parallel")
[17:43:41.688]                     if (exists("sendData", mode = "function", 
[17:43:41.688]                       envir = ns)) {
[17:43:41.688]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:41.688]                         envir = ns)
[17:43:41.688]                       envir <- sys.frame(frame)
[17:43:41.688]                       master <- NULL
[17:43:41.688]                       while (!identical(envir, .GlobalEnv) && 
[17:43:41.688]                         !identical(envir, emptyenv())) {
[17:43:41.688]                         if (exists("master", mode = "list", envir = envir, 
[17:43:41.688]                           inherits = FALSE)) {
[17:43:41.688]                           master <- get("master", mode = "list", 
[17:43:41.688]                             envir = envir, inherits = FALSE)
[17:43:41.688]                           if (inherits(master, c("SOCKnode", 
[17:43:41.688]                             "SOCK0node"))) {
[17:43:41.688]                             sendCondition <<- function(cond) {
[17:43:41.688]                               data <- list(type = "VALUE", value = cond, 
[17:43:41.688]                                 success = TRUE)
[17:43:41.688]                               parallel_sendData(master, data)
[17:43:41.688]                             }
[17:43:41.688]                             return(sendCondition)
[17:43:41.688]                           }
[17:43:41.688]                         }
[17:43:41.688]                         frame <- frame + 1L
[17:43:41.688]                         envir <- sys.frame(frame)
[17:43:41.688]                       }
[17:43:41.688]                     }
[17:43:41.688]                     sendCondition <<- function(cond) NULL
[17:43:41.688]                   }
[17:43:41.688]                 })
[17:43:41.688]                 withCallingHandlers({
[17:43:41.688]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:43:41.688]                 }, immediateCondition = function(cond) {
[17:43:41.688]                   sendCondition <- ...future.makeSendCondition()
[17:43:41.688]                   sendCondition(cond)
[17:43:41.688]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:41.688]                   {
[17:43:41.688]                     inherits <- base::inherits
[17:43:41.688]                     invokeRestart <- base::invokeRestart
[17:43:41.688]                     is.null <- base::is.null
[17:43:41.688]                     muffled <- FALSE
[17:43:41.688]                     if (inherits(cond, "message")) {
[17:43:41.688]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:41.688]                       if (muffled) 
[17:43:41.688]                         invokeRestart("muffleMessage")
[17:43:41.688]                     }
[17:43:41.688]                     else if (inherits(cond, "warning")) {
[17:43:41.688]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:41.688]                       if (muffled) 
[17:43:41.688]                         invokeRestart("muffleWarning")
[17:43:41.688]                     }
[17:43:41.688]                     else if (inherits(cond, "condition")) {
[17:43:41.688]                       if (!is.null(pattern)) {
[17:43:41.688]                         computeRestarts <- base::computeRestarts
[17:43:41.688]                         grepl <- base::grepl
[17:43:41.688]                         restarts <- computeRestarts(cond)
[17:43:41.688]                         for (restart in restarts) {
[17:43:41.688]                           name <- restart$name
[17:43:41.688]                           if (is.null(name)) 
[17:43:41.688]                             next
[17:43:41.688]                           if (!grepl(pattern, name)) 
[17:43:41.688]                             next
[17:43:41.688]                           invokeRestart(restart)
[17:43:41.688]                           muffled <- TRUE
[17:43:41.688]                           break
[17:43:41.688]                         }
[17:43:41.688]                       }
[17:43:41.688]                     }
[17:43:41.688]                     invisible(muffled)
[17:43:41.688]                   }
[17:43:41.688]                   muffleCondition(cond)
[17:43:41.688]                 })
[17:43:41.688]             }))
[17:43:41.688]             future::FutureResult(value = ...future.value$value, 
[17:43:41.688]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:41.688]                   ...future.rng), globalenv = if (FALSE) 
[17:43:41.688]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:41.688]                     ...future.globalenv.names))
[17:43:41.688]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:41.688]         }, condition = base::local({
[17:43:41.688]             c <- base::c
[17:43:41.688]             inherits <- base::inherits
[17:43:41.688]             invokeRestart <- base::invokeRestart
[17:43:41.688]             length <- base::length
[17:43:41.688]             list <- base::list
[17:43:41.688]             seq.int <- base::seq.int
[17:43:41.688]             signalCondition <- base::signalCondition
[17:43:41.688]             sys.calls <- base::sys.calls
[17:43:41.688]             `[[` <- base::`[[`
[17:43:41.688]             `+` <- base::`+`
[17:43:41.688]             `<<-` <- base::`<<-`
[17:43:41.688]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:41.688]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:41.688]                   3L)]
[17:43:41.688]             }
[17:43:41.688]             function(cond) {
[17:43:41.688]                 is_error <- inherits(cond, "error")
[17:43:41.688]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:41.688]                   NULL)
[17:43:41.688]                 if (is_error) {
[17:43:41.688]                   sessionInformation <- function() {
[17:43:41.688]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:41.688]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:41.688]                       search = base::search(), system = base::Sys.info())
[17:43:41.688]                   }
[17:43:41.688]                   ...future.conditions[[length(...future.conditions) + 
[17:43:41.688]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:41.688]                     cond$call), session = sessionInformation(), 
[17:43:41.688]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:41.688]                   signalCondition(cond)
[17:43:41.688]                 }
[17:43:41.688]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:41.688]                 "immediateCondition"))) {
[17:43:41.688]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:41.688]                   ...future.conditions[[length(...future.conditions) + 
[17:43:41.688]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:41.688]                   if (TRUE && !signal) {
[17:43:41.688]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:41.688]                     {
[17:43:41.688]                       inherits <- base::inherits
[17:43:41.688]                       invokeRestart <- base::invokeRestart
[17:43:41.688]                       is.null <- base::is.null
[17:43:41.688]                       muffled <- FALSE
[17:43:41.688]                       if (inherits(cond, "message")) {
[17:43:41.688]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:41.688]                         if (muffled) 
[17:43:41.688]                           invokeRestart("muffleMessage")
[17:43:41.688]                       }
[17:43:41.688]                       else if (inherits(cond, "warning")) {
[17:43:41.688]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:41.688]                         if (muffled) 
[17:43:41.688]                           invokeRestart("muffleWarning")
[17:43:41.688]                       }
[17:43:41.688]                       else if (inherits(cond, "condition")) {
[17:43:41.688]                         if (!is.null(pattern)) {
[17:43:41.688]                           computeRestarts <- base::computeRestarts
[17:43:41.688]                           grepl <- base::grepl
[17:43:41.688]                           restarts <- computeRestarts(cond)
[17:43:41.688]                           for (restart in restarts) {
[17:43:41.688]                             name <- restart$name
[17:43:41.688]                             if (is.null(name)) 
[17:43:41.688]                               next
[17:43:41.688]                             if (!grepl(pattern, name)) 
[17:43:41.688]                               next
[17:43:41.688]                             invokeRestart(restart)
[17:43:41.688]                             muffled <- TRUE
[17:43:41.688]                             break
[17:43:41.688]                           }
[17:43:41.688]                         }
[17:43:41.688]                       }
[17:43:41.688]                       invisible(muffled)
[17:43:41.688]                     }
[17:43:41.688]                     muffleCondition(cond, pattern = "^muffle")
[17:43:41.688]                   }
[17:43:41.688]                 }
[17:43:41.688]                 else {
[17:43:41.688]                   if (TRUE) {
[17:43:41.688]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:41.688]                     {
[17:43:41.688]                       inherits <- base::inherits
[17:43:41.688]                       invokeRestart <- base::invokeRestart
[17:43:41.688]                       is.null <- base::is.null
[17:43:41.688]                       muffled <- FALSE
[17:43:41.688]                       if (inherits(cond, "message")) {
[17:43:41.688]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:41.688]                         if (muffled) 
[17:43:41.688]                           invokeRestart("muffleMessage")
[17:43:41.688]                       }
[17:43:41.688]                       else if (inherits(cond, "warning")) {
[17:43:41.688]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:41.688]                         if (muffled) 
[17:43:41.688]                           invokeRestart("muffleWarning")
[17:43:41.688]                       }
[17:43:41.688]                       else if (inherits(cond, "condition")) {
[17:43:41.688]                         if (!is.null(pattern)) {
[17:43:41.688]                           computeRestarts <- base::computeRestarts
[17:43:41.688]                           grepl <- base::grepl
[17:43:41.688]                           restarts <- computeRestarts(cond)
[17:43:41.688]                           for (restart in restarts) {
[17:43:41.688]                             name <- restart$name
[17:43:41.688]                             if (is.null(name)) 
[17:43:41.688]                               next
[17:43:41.688]                             if (!grepl(pattern, name)) 
[17:43:41.688]                               next
[17:43:41.688]                             invokeRestart(restart)
[17:43:41.688]                             muffled <- TRUE
[17:43:41.688]                             break
[17:43:41.688]                           }
[17:43:41.688]                         }
[17:43:41.688]                       }
[17:43:41.688]                       invisible(muffled)
[17:43:41.688]                     }
[17:43:41.688]                     muffleCondition(cond, pattern = "^muffle")
[17:43:41.688]                   }
[17:43:41.688]                 }
[17:43:41.688]             }
[17:43:41.688]         }))
[17:43:41.688]     }, error = function(ex) {
[17:43:41.688]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:41.688]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:41.688]                 ...future.rng), started = ...future.startTime, 
[17:43:41.688]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:41.688]             version = "1.8"), class = "FutureResult")
[17:43:41.688]     }, finally = {
[17:43:41.688]         if (!identical(...future.workdir, getwd())) 
[17:43:41.688]             setwd(...future.workdir)
[17:43:41.688]         {
[17:43:41.688]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:41.688]                 ...future.oldOptions$nwarnings <- NULL
[17:43:41.688]             }
[17:43:41.688]             base::options(...future.oldOptions)
[17:43:41.688]             if (.Platform$OS.type == "windows") {
[17:43:41.688]                 old_names <- names(...future.oldEnvVars)
[17:43:41.688]                 envs <- base::Sys.getenv()
[17:43:41.688]                 names <- names(envs)
[17:43:41.688]                 common <- intersect(names, old_names)
[17:43:41.688]                 added <- setdiff(names, old_names)
[17:43:41.688]                 removed <- setdiff(old_names, names)
[17:43:41.688]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:41.688]                   envs[common]]
[17:43:41.688]                 NAMES <- toupper(changed)
[17:43:41.688]                 args <- list()
[17:43:41.688]                 for (kk in seq_along(NAMES)) {
[17:43:41.688]                   name <- changed[[kk]]
[17:43:41.688]                   NAME <- NAMES[[kk]]
[17:43:41.688]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:41.688]                     next
[17:43:41.688]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:41.688]                 }
[17:43:41.688]                 NAMES <- toupper(added)
[17:43:41.688]                 for (kk in seq_along(NAMES)) {
[17:43:41.688]                   name <- added[[kk]]
[17:43:41.688]                   NAME <- NAMES[[kk]]
[17:43:41.688]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:41.688]                     next
[17:43:41.688]                   args[[name]] <- ""
[17:43:41.688]                 }
[17:43:41.688]                 NAMES <- toupper(removed)
[17:43:41.688]                 for (kk in seq_along(NAMES)) {
[17:43:41.688]                   name <- removed[[kk]]
[17:43:41.688]                   NAME <- NAMES[[kk]]
[17:43:41.688]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:41.688]                     next
[17:43:41.688]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:41.688]                 }
[17:43:41.688]                 if (length(args) > 0) 
[17:43:41.688]                   base::do.call(base::Sys.setenv, args = args)
[17:43:41.688]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:41.688]             }
[17:43:41.688]             else {
[17:43:41.688]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:41.688]             }
[17:43:41.688]             {
[17:43:41.688]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:41.688]                   0L) {
[17:43:41.688]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:41.688]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:41.688]                   base::options(opts)
[17:43:41.688]                 }
[17:43:41.688]                 {
[17:43:41.688]                   {
[17:43:41.688]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:41.688]                     NULL
[17:43:41.688]                   }
[17:43:41.688]                   options(future.plan = NULL)
[17:43:41.688]                   if (is.na(NA_character_)) 
[17:43:41.688]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:41.688]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:41.688]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:41.688]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:41.688]                     envir = parent.frame()) 
[17:43:41.688]                   {
[17:43:41.688]                     if (is.function(workers)) 
[17:43:41.688]                       workers <- workers()
[17:43:41.688]                     workers <- structure(as.integer(workers), 
[17:43:41.688]                       class = class(workers))
[17:43:41.688]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:41.688]                       workers >= 1)
[17:43:41.688]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:41.688]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:41.688]                     }
[17:43:41.688]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:41.688]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:41.688]                       envir = envir)
[17:43:41.688]                     if (!future$lazy) 
[17:43:41.688]                       future <- run(future)
[17:43:41.688]                     invisible(future)
[17:43:41.688]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:41.688]                 }
[17:43:41.688]             }
[17:43:41.688]         }
[17:43:41.688]     })
[17:43:41.688]     if (TRUE) {
[17:43:41.688]         base::sink(type = "output", split = FALSE)
[17:43:41.688]         if (TRUE) {
[17:43:41.688]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:41.688]         }
[17:43:41.688]         else {
[17:43:41.688]             ...future.result["stdout"] <- base::list(NULL)
[17:43:41.688]         }
[17:43:41.688]         base::close(...future.stdout)
[17:43:41.688]         ...future.stdout <- NULL
[17:43:41.688]     }
[17:43:41.688]     ...future.result$conditions <- ...future.conditions
[17:43:41.688]     ...future.result$finished <- base::Sys.time()
[17:43:41.688]     ...future.result
[17:43:41.688] }
[17:43:41.691] MultisessionFuture started
[17:43:41.692] - Launch lazy future ... done
[17:43:41.692] run() for ‘MultisessionFuture’ ... done
[17:43:41.740] receiveMessageFromWorker() for ClusterFuture ...
[17:43:41.741] - Validating connection of MultisessionFuture
[17:43:41.741] - received message: FutureResult
[17:43:41.741] - Received FutureResult
[17:43:41.741] - Erased future from FutureRegistry
[17:43:41.741] result() for ClusterFuture ...
[17:43:41.741] - result already collected: FutureResult
[17:43:41.742] result() for ClusterFuture ... done
[17:43:41.742] signalConditions() ...
[17:43:41.742]  - include = ‘immediateCondition’
[17:43:41.742]  - exclude = 
[17:43:41.742]  - resignal = FALSE
[17:43:41.742]  - Number of conditions: 1
[17:43:41.742] signalConditions() ... done
[17:43:41.742] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:41.742] A MultisessionFuture was resolved (result was not collected)
[17:43:41.742] getGlobalsAndPackages() ...
[17:43:41.743] Searching for globals...
[17:43:41.743] - globals found: [2] ‘list’, ‘stop’
[17:43:41.743] Searching for globals ... DONE
[17:43:41.743] Resolving globals: FALSE
[17:43:41.744] 
[17:43:41.744] 
[17:43:41.744] getGlobalsAndPackages() ... DONE
[17:43:41.744] run() for ‘Future’ ...
[17:43:41.744] - state: ‘created’
[17:43:41.744] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:41.759] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:41.760] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:41.760]   - Field: ‘node’
[17:43:41.760]   - Field: ‘label’
[17:43:41.760]   - Field: ‘local’
[17:43:41.760]   - Field: ‘owner’
[17:43:41.760]   - Field: ‘envir’
[17:43:41.760]   - Field: ‘workers’
[17:43:41.760]   - Field: ‘packages’
[17:43:41.760]   - Field: ‘gc’
[17:43:41.760]   - Field: ‘conditions’
[17:43:41.760]   - Field: ‘persistent’
[17:43:41.761]   - Field: ‘expr’
[17:43:41.761]   - Field: ‘uuid’
[17:43:41.761]   - Field: ‘seed’
[17:43:41.761]   - Field: ‘version’
[17:43:41.761]   - Field: ‘result’
[17:43:41.761]   - Field: ‘asynchronous’
[17:43:41.761]   - Field: ‘calls’
[17:43:41.761]   - Field: ‘globals’
[17:43:41.761]   - Field: ‘stdout’
[17:43:41.761]   - Field: ‘earlySignal’
[17:43:41.761]   - Field: ‘lazy’
[17:43:41.762]   - Field: ‘state’
[17:43:41.762] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:41.762] - Launch lazy future ...
[17:43:41.762] Packages needed by the future expression (n = 0): <none>
[17:43:41.762] Packages needed by future strategies (n = 0): <none>
[17:43:41.763] {
[17:43:41.763]     {
[17:43:41.763]         {
[17:43:41.763]             ...future.startTime <- base::Sys.time()
[17:43:41.763]             {
[17:43:41.763]                 {
[17:43:41.763]                   {
[17:43:41.763]                     {
[17:43:41.763]                       base::local({
[17:43:41.763]                         has_future <- base::requireNamespace("future", 
[17:43:41.763]                           quietly = TRUE)
[17:43:41.763]                         if (has_future) {
[17:43:41.763]                           ns <- base::getNamespace("future")
[17:43:41.763]                           version <- ns[[".package"]][["version"]]
[17:43:41.763]                           if (is.null(version)) 
[17:43:41.763]                             version <- utils::packageVersion("future")
[17:43:41.763]                         }
[17:43:41.763]                         else {
[17:43:41.763]                           version <- NULL
[17:43:41.763]                         }
[17:43:41.763]                         if (!has_future || version < "1.8.0") {
[17:43:41.763]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:41.763]                             "", base::R.version$version.string), 
[17:43:41.763]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:41.763]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:41.763]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:41.763]                               "release", "version")], collapse = " "), 
[17:43:41.763]                             hostname = base::Sys.info()[["nodename"]])
[17:43:41.763]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:41.763]                             info)
[17:43:41.763]                           info <- base::paste(info, collapse = "; ")
[17:43:41.763]                           if (!has_future) {
[17:43:41.763]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:41.763]                               info)
[17:43:41.763]                           }
[17:43:41.763]                           else {
[17:43:41.763]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:41.763]                               info, version)
[17:43:41.763]                           }
[17:43:41.763]                           base::stop(msg)
[17:43:41.763]                         }
[17:43:41.763]                       })
[17:43:41.763]                     }
[17:43:41.763]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:41.763]                     base::options(mc.cores = 1L)
[17:43:41.763]                   }
[17:43:41.763]                   options(future.plan = NULL)
[17:43:41.763]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:41.763]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:41.763]                 }
[17:43:41.763]                 ...future.workdir <- getwd()
[17:43:41.763]             }
[17:43:41.763]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:41.763]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:41.763]         }
[17:43:41.763]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:41.763]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:41.763]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:41.763]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:41.763]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:41.763]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:41.763]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:41.763]             base::names(...future.oldOptions))
[17:43:41.763]     }
[17:43:41.763]     if (FALSE) {
[17:43:41.763]     }
[17:43:41.763]     else {
[17:43:41.763]         if (TRUE) {
[17:43:41.763]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:41.763]                 open = "w")
[17:43:41.763]         }
[17:43:41.763]         else {
[17:43:41.763]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:41.763]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:41.763]         }
[17:43:41.763]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:41.763]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:41.763]             base::sink(type = "output", split = FALSE)
[17:43:41.763]             base::close(...future.stdout)
[17:43:41.763]         }, add = TRUE)
[17:43:41.763]     }
[17:43:41.763]     ...future.frame <- base::sys.nframe()
[17:43:41.763]     ...future.conditions <- base::list()
[17:43:41.763]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:41.763]     if (FALSE) {
[17:43:41.763]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:41.763]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:41.763]     }
[17:43:41.763]     ...future.result <- base::tryCatch({
[17:43:41.763]         base::withCallingHandlers({
[17:43:41.763]             ...future.value <- base::withVisible(base::local({
[17:43:41.763]                 ...future.makeSendCondition <- local({
[17:43:41.763]                   sendCondition <- NULL
[17:43:41.763]                   function(frame = 1L) {
[17:43:41.763]                     if (is.function(sendCondition)) 
[17:43:41.763]                       return(sendCondition)
[17:43:41.763]                     ns <- getNamespace("parallel")
[17:43:41.763]                     if (exists("sendData", mode = "function", 
[17:43:41.763]                       envir = ns)) {
[17:43:41.763]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:41.763]                         envir = ns)
[17:43:41.763]                       envir <- sys.frame(frame)
[17:43:41.763]                       master <- NULL
[17:43:41.763]                       while (!identical(envir, .GlobalEnv) && 
[17:43:41.763]                         !identical(envir, emptyenv())) {
[17:43:41.763]                         if (exists("master", mode = "list", envir = envir, 
[17:43:41.763]                           inherits = FALSE)) {
[17:43:41.763]                           master <- get("master", mode = "list", 
[17:43:41.763]                             envir = envir, inherits = FALSE)
[17:43:41.763]                           if (inherits(master, c("SOCKnode", 
[17:43:41.763]                             "SOCK0node"))) {
[17:43:41.763]                             sendCondition <<- function(cond) {
[17:43:41.763]                               data <- list(type = "VALUE", value = cond, 
[17:43:41.763]                                 success = TRUE)
[17:43:41.763]                               parallel_sendData(master, data)
[17:43:41.763]                             }
[17:43:41.763]                             return(sendCondition)
[17:43:41.763]                           }
[17:43:41.763]                         }
[17:43:41.763]                         frame <- frame + 1L
[17:43:41.763]                         envir <- sys.frame(frame)
[17:43:41.763]                       }
[17:43:41.763]                     }
[17:43:41.763]                     sendCondition <<- function(cond) NULL
[17:43:41.763]                   }
[17:43:41.763]                 })
[17:43:41.763]                 withCallingHandlers({
[17:43:41.763]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:43:41.763]                 }, immediateCondition = function(cond) {
[17:43:41.763]                   sendCondition <- ...future.makeSendCondition()
[17:43:41.763]                   sendCondition(cond)
[17:43:41.763]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:41.763]                   {
[17:43:41.763]                     inherits <- base::inherits
[17:43:41.763]                     invokeRestart <- base::invokeRestart
[17:43:41.763]                     is.null <- base::is.null
[17:43:41.763]                     muffled <- FALSE
[17:43:41.763]                     if (inherits(cond, "message")) {
[17:43:41.763]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:41.763]                       if (muffled) 
[17:43:41.763]                         invokeRestart("muffleMessage")
[17:43:41.763]                     }
[17:43:41.763]                     else if (inherits(cond, "warning")) {
[17:43:41.763]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:41.763]                       if (muffled) 
[17:43:41.763]                         invokeRestart("muffleWarning")
[17:43:41.763]                     }
[17:43:41.763]                     else if (inherits(cond, "condition")) {
[17:43:41.763]                       if (!is.null(pattern)) {
[17:43:41.763]                         computeRestarts <- base::computeRestarts
[17:43:41.763]                         grepl <- base::grepl
[17:43:41.763]                         restarts <- computeRestarts(cond)
[17:43:41.763]                         for (restart in restarts) {
[17:43:41.763]                           name <- restart$name
[17:43:41.763]                           if (is.null(name)) 
[17:43:41.763]                             next
[17:43:41.763]                           if (!grepl(pattern, name)) 
[17:43:41.763]                             next
[17:43:41.763]                           invokeRestart(restart)
[17:43:41.763]                           muffled <- TRUE
[17:43:41.763]                           break
[17:43:41.763]                         }
[17:43:41.763]                       }
[17:43:41.763]                     }
[17:43:41.763]                     invisible(muffled)
[17:43:41.763]                   }
[17:43:41.763]                   muffleCondition(cond)
[17:43:41.763]                 })
[17:43:41.763]             }))
[17:43:41.763]             future::FutureResult(value = ...future.value$value, 
[17:43:41.763]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:41.763]                   ...future.rng), globalenv = if (FALSE) 
[17:43:41.763]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:41.763]                     ...future.globalenv.names))
[17:43:41.763]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:41.763]         }, condition = base::local({
[17:43:41.763]             c <- base::c
[17:43:41.763]             inherits <- base::inherits
[17:43:41.763]             invokeRestart <- base::invokeRestart
[17:43:41.763]             length <- base::length
[17:43:41.763]             list <- base::list
[17:43:41.763]             seq.int <- base::seq.int
[17:43:41.763]             signalCondition <- base::signalCondition
[17:43:41.763]             sys.calls <- base::sys.calls
[17:43:41.763]             `[[` <- base::`[[`
[17:43:41.763]             `+` <- base::`+`
[17:43:41.763]             `<<-` <- base::`<<-`
[17:43:41.763]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:41.763]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:41.763]                   3L)]
[17:43:41.763]             }
[17:43:41.763]             function(cond) {
[17:43:41.763]                 is_error <- inherits(cond, "error")
[17:43:41.763]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:41.763]                   NULL)
[17:43:41.763]                 if (is_error) {
[17:43:41.763]                   sessionInformation <- function() {
[17:43:41.763]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:41.763]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:41.763]                       search = base::search(), system = base::Sys.info())
[17:43:41.763]                   }
[17:43:41.763]                   ...future.conditions[[length(...future.conditions) + 
[17:43:41.763]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:41.763]                     cond$call), session = sessionInformation(), 
[17:43:41.763]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:41.763]                   signalCondition(cond)
[17:43:41.763]                 }
[17:43:41.763]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:41.763]                 "immediateCondition"))) {
[17:43:41.763]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:41.763]                   ...future.conditions[[length(...future.conditions) + 
[17:43:41.763]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:41.763]                   if (TRUE && !signal) {
[17:43:41.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:41.763]                     {
[17:43:41.763]                       inherits <- base::inherits
[17:43:41.763]                       invokeRestart <- base::invokeRestart
[17:43:41.763]                       is.null <- base::is.null
[17:43:41.763]                       muffled <- FALSE
[17:43:41.763]                       if (inherits(cond, "message")) {
[17:43:41.763]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:41.763]                         if (muffled) 
[17:43:41.763]                           invokeRestart("muffleMessage")
[17:43:41.763]                       }
[17:43:41.763]                       else if (inherits(cond, "warning")) {
[17:43:41.763]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:41.763]                         if (muffled) 
[17:43:41.763]                           invokeRestart("muffleWarning")
[17:43:41.763]                       }
[17:43:41.763]                       else if (inherits(cond, "condition")) {
[17:43:41.763]                         if (!is.null(pattern)) {
[17:43:41.763]                           computeRestarts <- base::computeRestarts
[17:43:41.763]                           grepl <- base::grepl
[17:43:41.763]                           restarts <- computeRestarts(cond)
[17:43:41.763]                           for (restart in restarts) {
[17:43:41.763]                             name <- restart$name
[17:43:41.763]                             if (is.null(name)) 
[17:43:41.763]                               next
[17:43:41.763]                             if (!grepl(pattern, name)) 
[17:43:41.763]                               next
[17:43:41.763]                             invokeRestart(restart)
[17:43:41.763]                             muffled <- TRUE
[17:43:41.763]                             break
[17:43:41.763]                           }
[17:43:41.763]                         }
[17:43:41.763]                       }
[17:43:41.763]                       invisible(muffled)
[17:43:41.763]                     }
[17:43:41.763]                     muffleCondition(cond, pattern = "^muffle")
[17:43:41.763]                   }
[17:43:41.763]                 }
[17:43:41.763]                 else {
[17:43:41.763]                   if (TRUE) {
[17:43:41.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:41.763]                     {
[17:43:41.763]                       inherits <- base::inherits
[17:43:41.763]                       invokeRestart <- base::invokeRestart
[17:43:41.763]                       is.null <- base::is.null
[17:43:41.763]                       muffled <- FALSE
[17:43:41.763]                       if (inherits(cond, "message")) {
[17:43:41.763]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:41.763]                         if (muffled) 
[17:43:41.763]                           invokeRestart("muffleMessage")
[17:43:41.763]                       }
[17:43:41.763]                       else if (inherits(cond, "warning")) {
[17:43:41.763]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:41.763]                         if (muffled) 
[17:43:41.763]                           invokeRestart("muffleWarning")
[17:43:41.763]                       }
[17:43:41.763]                       else if (inherits(cond, "condition")) {
[17:43:41.763]                         if (!is.null(pattern)) {
[17:43:41.763]                           computeRestarts <- base::computeRestarts
[17:43:41.763]                           grepl <- base::grepl
[17:43:41.763]                           restarts <- computeRestarts(cond)
[17:43:41.763]                           for (restart in restarts) {
[17:43:41.763]                             name <- restart$name
[17:43:41.763]                             if (is.null(name)) 
[17:43:41.763]                               next
[17:43:41.763]                             if (!grepl(pattern, name)) 
[17:43:41.763]                               next
[17:43:41.763]                             invokeRestart(restart)
[17:43:41.763]                             muffled <- TRUE
[17:43:41.763]                             break
[17:43:41.763]                           }
[17:43:41.763]                         }
[17:43:41.763]                       }
[17:43:41.763]                       invisible(muffled)
[17:43:41.763]                     }
[17:43:41.763]                     muffleCondition(cond, pattern = "^muffle")
[17:43:41.763]                   }
[17:43:41.763]                 }
[17:43:41.763]             }
[17:43:41.763]         }))
[17:43:41.763]     }, error = function(ex) {
[17:43:41.763]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:41.763]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:41.763]                 ...future.rng), started = ...future.startTime, 
[17:43:41.763]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:41.763]             version = "1.8"), class = "FutureResult")
[17:43:41.763]     }, finally = {
[17:43:41.763]         if (!identical(...future.workdir, getwd())) 
[17:43:41.763]             setwd(...future.workdir)
[17:43:41.763]         {
[17:43:41.763]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:41.763]                 ...future.oldOptions$nwarnings <- NULL
[17:43:41.763]             }
[17:43:41.763]             base::options(...future.oldOptions)
[17:43:41.763]             if (.Platform$OS.type == "windows") {
[17:43:41.763]                 old_names <- names(...future.oldEnvVars)
[17:43:41.763]                 envs <- base::Sys.getenv()
[17:43:41.763]                 names <- names(envs)
[17:43:41.763]                 common <- intersect(names, old_names)
[17:43:41.763]                 added <- setdiff(names, old_names)
[17:43:41.763]                 removed <- setdiff(old_names, names)
[17:43:41.763]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:41.763]                   envs[common]]
[17:43:41.763]                 NAMES <- toupper(changed)
[17:43:41.763]                 args <- list()
[17:43:41.763]                 for (kk in seq_along(NAMES)) {
[17:43:41.763]                   name <- changed[[kk]]
[17:43:41.763]                   NAME <- NAMES[[kk]]
[17:43:41.763]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:41.763]                     next
[17:43:41.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:41.763]                 }
[17:43:41.763]                 NAMES <- toupper(added)
[17:43:41.763]                 for (kk in seq_along(NAMES)) {
[17:43:41.763]                   name <- added[[kk]]
[17:43:41.763]                   NAME <- NAMES[[kk]]
[17:43:41.763]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:41.763]                     next
[17:43:41.763]                   args[[name]] <- ""
[17:43:41.763]                 }
[17:43:41.763]                 NAMES <- toupper(removed)
[17:43:41.763]                 for (kk in seq_along(NAMES)) {
[17:43:41.763]                   name <- removed[[kk]]
[17:43:41.763]                   NAME <- NAMES[[kk]]
[17:43:41.763]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:41.763]                     next
[17:43:41.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:41.763]                 }
[17:43:41.763]                 if (length(args) > 0) 
[17:43:41.763]                   base::do.call(base::Sys.setenv, args = args)
[17:43:41.763]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:41.763]             }
[17:43:41.763]             else {
[17:43:41.763]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:41.763]             }
[17:43:41.763]             {
[17:43:41.763]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:41.763]                   0L) {
[17:43:41.763]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:41.763]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:41.763]                   base::options(opts)
[17:43:41.763]                 }
[17:43:41.763]                 {
[17:43:41.763]                   {
[17:43:41.763]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:41.763]                     NULL
[17:43:41.763]                   }
[17:43:41.763]                   options(future.plan = NULL)
[17:43:41.763]                   if (is.na(NA_character_)) 
[17:43:41.763]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:41.763]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:41.763]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:41.763]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:41.763]                     envir = parent.frame()) 
[17:43:41.763]                   {
[17:43:41.763]                     if (is.function(workers)) 
[17:43:41.763]                       workers <- workers()
[17:43:41.763]                     workers <- structure(as.integer(workers), 
[17:43:41.763]                       class = class(workers))
[17:43:41.763]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:41.763]                       workers >= 1)
[17:43:41.763]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:41.763]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:41.763]                     }
[17:43:41.763]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:41.763]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:41.763]                       envir = envir)
[17:43:41.763]                     if (!future$lazy) 
[17:43:41.763]                       future <- run(future)
[17:43:41.763]                     invisible(future)
[17:43:41.763]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:41.763]                 }
[17:43:41.763]             }
[17:43:41.763]         }
[17:43:41.763]     })
[17:43:41.763]     if (TRUE) {
[17:43:41.763]         base::sink(type = "output", split = FALSE)
[17:43:41.763]         if (TRUE) {
[17:43:41.763]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:41.763]         }
[17:43:41.763]         else {
[17:43:41.763]             ...future.result["stdout"] <- base::list(NULL)
[17:43:41.763]         }
[17:43:41.763]         base::close(...future.stdout)
[17:43:41.763]         ...future.stdout <- NULL
[17:43:41.763]     }
[17:43:41.763]     ...future.result$conditions <- ...future.conditions
[17:43:41.763]     ...future.result$finished <- base::Sys.time()
[17:43:41.763]     ...future.result
[17:43:41.763] }
[17:43:41.766] MultisessionFuture started
[17:43:41.766] - Launch lazy future ... done
[17:43:41.766] run() for ‘MultisessionFuture’ ... done
[17:43:41.812] receiveMessageFromWorker() for ClusterFuture ...
[17:43:41.812] - Validating connection of MultisessionFuture
[17:43:41.813] - received message: FutureResult
[17:43:41.813] - Received FutureResult
[17:43:41.813] - Erased future from FutureRegistry
[17:43:41.813] result() for ClusterFuture ...
[17:43:41.813] - result already collected: FutureResult
[17:43:41.813] result() for ClusterFuture ... done
[17:43:41.813] signalConditions() ...
[17:43:41.813]  - include = ‘immediateCondition’
[17:43:41.814]  - exclude = 
[17:43:41.814]  - resignal = FALSE
[17:43:41.814]  - Number of conditions: 1
[17:43:41.814] signalConditions() ... done
[17:43:41.814] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:41.814] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 0 ... DONE
- result = FALSE, recursive = 1 ...
[17:43:41.814] getGlobalsAndPackages() ...
[17:43:41.814] Searching for globals...
[17:43:41.816] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:43:41.816] Searching for globals ... DONE
[17:43:41.816] Resolving globals: FALSE
[17:43:41.816] 
[17:43:41.816] 
[17:43:41.816] getGlobalsAndPackages() ... DONE
[17:43:41.817] run() for ‘Future’ ...
[17:43:41.817] - state: ‘created’
[17:43:41.817] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:41.832] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:41.833] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:41.833]   - Field: ‘node’
[17:43:41.833]   - Field: ‘label’
[17:43:41.833]   - Field: ‘local’
[17:43:41.833]   - Field: ‘owner’
[17:43:41.833]   - Field: ‘envir’
[17:43:41.833]   - Field: ‘workers’
[17:43:41.833]   - Field: ‘packages’
[17:43:41.833]   - Field: ‘gc’
[17:43:41.834]   - Field: ‘conditions’
[17:43:41.834]   - Field: ‘persistent’
[17:43:41.834]   - Field: ‘expr’
[17:43:41.834]   - Field: ‘uuid’
[17:43:41.834]   - Field: ‘seed’
[17:43:41.834]   - Field: ‘version’
[17:43:41.834]   - Field: ‘result’
[17:43:41.834]   - Field: ‘asynchronous’
[17:43:41.834]   - Field: ‘calls’
[17:43:41.834]   - Field: ‘globals’
[17:43:41.834]   - Field: ‘stdout’
[17:43:41.835]   - Field: ‘earlySignal’
[17:43:41.835]   - Field: ‘lazy’
[17:43:41.835]   - Field: ‘state’
[17:43:41.835] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:41.835] - Launch lazy future ...
[17:43:41.835] Packages needed by the future expression (n = 0): <none>
[17:43:41.835] Packages needed by future strategies (n = 0): <none>
[17:43:41.836] {
[17:43:41.836]     {
[17:43:41.836]         {
[17:43:41.836]             ...future.startTime <- base::Sys.time()
[17:43:41.836]             {
[17:43:41.836]                 {
[17:43:41.836]                   {
[17:43:41.836]                     {
[17:43:41.836]                       base::local({
[17:43:41.836]                         has_future <- base::requireNamespace("future", 
[17:43:41.836]                           quietly = TRUE)
[17:43:41.836]                         if (has_future) {
[17:43:41.836]                           ns <- base::getNamespace("future")
[17:43:41.836]                           version <- ns[[".package"]][["version"]]
[17:43:41.836]                           if (is.null(version)) 
[17:43:41.836]                             version <- utils::packageVersion("future")
[17:43:41.836]                         }
[17:43:41.836]                         else {
[17:43:41.836]                           version <- NULL
[17:43:41.836]                         }
[17:43:41.836]                         if (!has_future || version < "1.8.0") {
[17:43:41.836]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:41.836]                             "", base::R.version$version.string), 
[17:43:41.836]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:41.836]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:41.836]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:41.836]                               "release", "version")], collapse = " "), 
[17:43:41.836]                             hostname = base::Sys.info()[["nodename"]])
[17:43:41.836]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:41.836]                             info)
[17:43:41.836]                           info <- base::paste(info, collapse = "; ")
[17:43:41.836]                           if (!has_future) {
[17:43:41.836]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:41.836]                               info)
[17:43:41.836]                           }
[17:43:41.836]                           else {
[17:43:41.836]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:41.836]                               info, version)
[17:43:41.836]                           }
[17:43:41.836]                           base::stop(msg)
[17:43:41.836]                         }
[17:43:41.836]                       })
[17:43:41.836]                     }
[17:43:41.836]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:41.836]                     base::options(mc.cores = 1L)
[17:43:41.836]                   }
[17:43:41.836]                   options(future.plan = NULL)
[17:43:41.836]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:41.836]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:41.836]                 }
[17:43:41.836]                 ...future.workdir <- getwd()
[17:43:41.836]             }
[17:43:41.836]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:41.836]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:41.836]         }
[17:43:41.836]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:41.836]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:41.836]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:41.836]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:41.836]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:41.836]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:41.836]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:41.836]             base::names(...future.oldOptions))
[17:43:41.836]     }
[17:43:41.836]     if (FALSE) {
[17:43:41.836]     }
[17:43:41.836]     else {
[17:43:41.836]         if (TRUE) {
[17:43:41.836]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:41.836]                 open = "w")
[17:43:41.836]         }
[17:43:41.836]         else {
[17:43:41.836]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:41.836]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:41.836]         }
[17:43:41.836]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:41.836]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:41.836]             base::sink(type = "output", split = FALSE)
[17:43:41.836]             base::close(...future.stdout)
[17:43:41.836]         }, add = TRUE)
[17:43:41.836]     }
[17:43:41.836]     ...future.frame <- base::sys.nframe()
[17:43:41.836]     ...future.conditions <- base::list()
[17:43:41.836]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:41.836]     if (FALSE) {
[17:43:41.836]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:41.836]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:41.836]     }
[17:43:41.836]     ...future.result <- base::tryCatch({
[17:43:41.836]         base::withCallingHandlers({
[17:43:41.836]             ...future.value <- base::withVisible(base::local({
[17:43:41.836]                 ...future.makeSendCondition <- local({
[17:43:41.836]                   sendCondition <- NULL
[17:43:41.836]                   function(frame = 1L) {
[17:43:41.836]                     if (is.function(sendCondition)) 
[17:43:41.836]                       return(sendCondition)
[17:43:41.836]                     ns <- getNamespace("parallel")
[17:43:41.836]                     if (exists("sendData", mode = "function", 
[17:43:41.836]                       envir = ns)) {
[17:43:41.836]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:41.836]                         envir = ns)
[17:43:41.836]                       envir <- sys.frame(frame)
[17:43:41.836]                       master <- NULL
[17:43:41.836]                       while (!identical(envir, .GlobalEnv) && 
[17:43:41.836]                         !identical(envir, emptyenv())) {
[17:43:41.836]                         if (exists("master", mode = "list", envir = envir, 
[17:43:41.836]                           inherits = FALSE)) {
[17:43:41.836]                           master <- get("master", mode = "list", 
[17:43:41.836]                             envir = envir, inherits = FALSE)
[17:43:41.836]                           if (inherits(master, c("SOCKnode", 
[17:43:41.836]                             "SOCK0node"))) {
[17:43:41.836]                             sendCondition <<- function(cond) {
[17:43:41.836]                               data <- list(type = "VALUE", value = cond, 
[17:43:41.836]                                 success = TRUE)
[17:43:41.836]                               parallel_sendData(master, data)
[17:43:41.836]                             }
[17:43:41.836]                             return(sendCondition)
[17:43:41.836]                           }
[17:43:41.836]                         }
[17:43:41.836]                         frame <- frame + 1L
[17:43:41.836]                         envir <- sys.frame(frame)
[17:43:41.836]                       }
[17:43:41.836]                     }
[17:43:41.836]                     sendCondition <<- function(cond) NULL
[17:43:41.836]                   }
[17:43:41.836]                 })
[17:43:41.836]                 withCallingHandlers({
[17:43:41.836]                   {
[17:43:41.836]                     Sys.sleep(0.5)
[17:43:41.836]                     list(a = 1, b = 42L)
[17:43:41.836]                   }
[17:43:41.836]                 }, immediateCondition = function(cond) {
[17:43:41.836]                   sendCondition <- ...future.makeSendCondition()
[17:43:41.836]                   sendCondition(cond)
[17:43:41.836]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:41.836]                   {
[17:43:41.836]                     inherits <- base::inherits
[17:43:41.836]                     invokeRestart <- base::invokeRestart
[17:43:41.836]                     is.null <- base::is.null
[17:43:41.836]                     muffled <- FALSE
[17:43:41.836]                     if (inherits(cond, "message")) {
[17:43:41.836]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:41.836]                       if (muffled) 
[17:43:41.836]                         invokeRestart("muffleMessage")
[17:43:41.836]                     }
[17:43:41.836]                     else if (inherits(cond, "warning")) {
[17:43:41.836]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:41.836]                       if (muffled) 
[17:43:41.836]                         invokeRestart("muffleWarning")
[17:43:41.836]                     }
[17:43:41.836]                     else if (inherits(cond, "condition")) {
[17:43:41.836]                       if (!is.null(pattern)) {
[17:43:41.836]                         computeRestarts <- base::computeRestarts
[17:43:41.836]                         grepl <- base::grepl
[17:43:41.836]                         restarts <- computeRestarts(cond)
[17:43:41.836]                         for (restart in restarts) {
[17:43:41.836]                           name <- restart$name
[17:43:41.836]                           if (is.null(name)) 
[17:43:41.836]                             next
[17:43:41.836]                           if (!grepl(pattern, name)) 
[17:43:41.836]                             next
[17:43:41.836]                           invokeRestart(restart)
[17:43:41.836]                           muffled <- TRUE
[17:43:41.836]                           break
[17:43:41.836]                         }
[17:43:41.836]                       }
[17:43:41.836]                     }
[17:43:41.836]                     invisible(muffled)
[17:43:41.836]                   }
[17:43:41.836]                   muffleCondition(cond)
[17:43:41.836]                 })
[17:43:41.836]             }))
[17:43:41.836]             future::FutureResult(value = ...future.value$value, 
[17:43:41.836]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:41.836]                   ...future.rng), globalenv = if (FALSE) 
[17:43:41.836]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:41.836]                     ...future.globalenv.names))
[17:43:41.836]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:41.836]         }, condition = base::local({
[17:43:41.836]             c <- base::c
[17:43:41.836]             inherits <- base::inherits
[17:43:41.836]             invokeRestart <- base::invokeRestart
[17:43:41.836]             length <- base::length
[17:43:41.836]             list <- base::list
[17:43:41.836]             seq.int <- base::seq.int
[17:43:41.836]             signalCondition <- base::signalCondition
[17:43:41.836]             sys.calls <- base::sys.calls
[17:43:41.836]             `[[` <- base::`[[`
[17:43:41.836]             `+` <- base::`+`
[17:43:41.836]             `<<-` <- base::`<<-`
[17:43:41.836]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:41.836]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:41.836]                   3L)]
[17:43:41.836]             }
[17:43:41.836]             function(cond) {
[17:43:41.836]                 is_error <- inherits(cond, "error")
[17:43:41.836]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:41.836]                   NULL)
[17:43:41.836]                 if (is_error) {
[17:43:41.836]                   sessionInformation <- function() {
[17:43:41.836]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:41.836]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:41.836]                       search = base::search(), system = base::Sys.info())
[17:43:41.836]                   }
[17:43:41.836]                   ...future.conditions[[length(...future.conditions) + 
[17:43:41.836]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:41.836]                     cond$call), session = sessionInformation(), 
[17:43:41.836]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:41.836]                   signalCondition(cond)
[17:43:41.836]                 }
[17:43:41.836]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:41.836]                 "immediateCondition"))) {
[17:43:41.836]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:41.836]                   ...future.conditions[[length(...future.conditions) + 
[17:43:41.836]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:41.836]                   if (TRUE && !signal) {
[17:43:41.836]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:41.836]                     {
[17:43:41.836]                       inherits <- base::inherits
[17:43:41.836]                       invokeRestart <- base::invokeRestart
[17:43:41.836]                       is.null <- base::is.null
[17:43:41.836]                       muffled <- FALSE
[17:43:41.836]                       if (inherits(cond, "message")) {
[17:43:41.836]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:41.836]                         if (muffled) 
[17:43:41.836]                           invokeRestart("muffleMessage")
[17:43:41.836]                       }
[17:43:41.836]                       else if (inherits(cond, "warning")) {
[17:43:41.836]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:41.836]                         if (muffled) 
[17:43:41.836]                           invokeRestart("muffleWarning")
[17:43:41.836]                       }
[17:43:41.836]                       else if (inherits(cond, "condition")) {
[17:43:41.836]                         if (!is.null(pattern)) {
[17:43:41.836]                           computeRestarts <- base::computeRestarts
[17:43:41.836]                           grepl <- base::grepl
[17:43:41.836]                           restarts <- computeRestarts(cond)
[17:43:41.836]                           for (restart in restarts) {
[17:43:41.836]                             name <- restart$name
[17:43:41.836]                             if (is.null(name)) 
[17:43:41.836]                               next
[17:43:41.836]                             if (!grepl(pattern, name)) 
[17:43:41.836]                               next
[17:43:41.836]                             invokeRestart(restart)
[17:43:41.836]                             muffled <- TRUE
[17:43:41.836]                             break
[17:43:41.836]                           }
[17:43:41.836]                         }
[17:43:41.836]                       }
[17:43:41.836]                       invisible(muffled)
[17:43:41.836]                     }
[17:43:41.836]                     muffleCondition(cond, pattern = "^muffle")
[17:43:41.836]                   }
[17:43:41.836]                 }
[17:43:41.836]                 else {
[17:43:41.836]                   if (TRUE) {
[17:43:41.836]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:41.836]                     {
[17:43:41.836]                       inherits <- base::inherits
[17:43:41.836]                       invokeRestart <- base::invokeRestart
[17:43:41.836]                       is.null <- base::is.null
[17:43:41.836]                       muffled <- FALSE
[17:43:41.836]                       if (inherits(cond, "message")) {
[17:43:41.836]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:41.836]                         if (muffled) 
[17:43:41.836]                           invokeRestart("muffleMessage")
[17:43:41.836]                       }
[17:43:41.836]                       else if (inherits(cond, "warning")) {
[17:43:41.836]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:41.836]                         if (muffled) 
[17:43:41.836]                           invokeRestart("muffleWarning")
[17:43:41.836]                       }
[17:43:41.836]                       else if (inherits(cond, "condition")) {
[17:43:41.836]                         if (!is.null(pattern)) {
[17:43:41.836]                           computeRestarts <- base::computeRestarts
[17:43:41.836]                           grepl <- base::grepl
[17:43:41.836]                           restarts <- computeRestarts(cond)
[17:43:41.836]                           for (restart in restarts) {
[17:43:41.836]                             name <- restart$name
[17:43:41.836]                             if (is.null(name)) 
[17:43:41.836]                               next
[17:43:41.836]                             if (!grepl(pattern, name)) 
[17:43:41.836]                               next
[17:43:41.836]                             invokeRestart(restart)
[17:43:41.836]                             muffled <- TRUE
[17:43:41.836]                             break
[17:43:41.836]                           }
[17:43:41.836]                         }
[17:43:41.836]                       }
[17:43:41.836]                       invisible(muffled)
[17:43:41.836]                     }
[17:43:41.836]                     muffleCondition(cond, pattern = "^muffle")
[17:43:41.836]                   }
[17:43:41.836]                 }
[17:43:41.836]             }
[17:43:41.836]         }))
[17:43:41.836]     }, error = function(ex) {
[17:43:41.836]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:41.836]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:41.836]                 ...future.rng), started = ...future.startTime, 
[17:43:41.836]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:41.836]             version = "1.8"), class = "FutureResult")
[17:43:41.836]     }, finally = {
[17:43:41.836]         if (!identical(...future.workdir, getwd())) 
[17:43:41.836]             setwd(...future.workdir)
[17:43:41.836]         {
[17:43:41.836]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:41.836]                 ...future.oldOptions$nwarnings <- NULL
[17:43:41.836]             }
[17:43:41.836]             base::options(...future.oldOptions)
[17:43:41.836]             if (.Platform$OS.type == "windows") {
[17:43:41.836]                 old_names <- names(...future.oldEnvVars)
[17:43:41.836]                 envs <- base::Sys.getenv()
[17:43:41.836]                 names <- names(envs)
[17:43:41.836]                 common <- intersect(names, old_names)
[17:43:41.836]                 added <- setdiff(names, old_names)
[17:43:41.836]                 removed <- setdiff(old_names, names)
[17:43:41.836]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:41.836]                   envs[common]]
[17:43:41.836]                 NAMES <- toupper(changed)
[17:43:41.836]                 args <- list()
[17:43:41.836]                 for (kk in seq_along(NAMES)) {
[17:43:41.836]                   name <- changed[[kk]]
[17:43:41.836]                   NAME <- NAMES[[kk]]
[17:43:41.836]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:41.836]                     next
[17:43:41.836]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:41.836]                 }
[17:43:41.836]                 NAMES <- toupper(added)
[17:43:41.836]                 for (kk in seq_along(NAMES)) {
[17:43:41.836]                   name <- added[[kk]]
[17:43:41.836]                   NAME <- NAMES[[kk]]
[17:43:41.836]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:41.836]                     next
[17:43:41.836]                   args[[name]] <- ""
[17:43:41.836]                 }
[17:43:41.836]                 NAMES <- toupper(removed)
[17:43:41.836]                 for (kk in seq_along(NAMES)) {
[17:43:41.836]                   name <- removed[[kk]]
[17:43:41.836]                   NAME <- NAMES[[kk]]
[17:43:41.836]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:41.836]                     next
[17:43:41.836]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:41.836]                 }
[17:43:41.836]                 if (length(args) > 0) 
[17:43:41.836]                   base::do.call(base::Sys.setenv, args = args)
[17:43:41.836]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:41.836]             }
[17:43:41.836]             else {
[17:43:41.836]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:41.836]             }
[17:43:41.836]             {
[17:43:41.836]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:41.836]                   0L) {
[17:43:41.836]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:41.836]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:41.836]                   base::options(opts)
[17:43:41.836]                 }
[17:43:41.836]                 {
[17:43:41.836]                   {
[17:43:41.836]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:41.836]                     NULL
[17:43:41.836]                   }
[17:43:41.836]                   options(future.plan = NULL)
[17:43:41.836]                   if (is.na(NA_character_)) 
[17:43:41.836]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:41.836]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:41.836]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:41.836]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:41.836]                     envir = parent.frame()) 
[17:43:41.836]                   {
[17:43:41.836]                     if (is.function(workers)) 
[17:43:41.836]                       workers <- workers()
[17:43:41.836]                     workers <- structure(as.integer(workers), 
[17:43:41.836]                       class = class(workers))
[17:43:41.836]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:41.836]                       workers >= 1)
[17:43:41.836]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:41.836]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:41.836]                     }
[17:43:41.836]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:41.836]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:41.836]                       envir = envir)
[17:43:41.836]                     if (!future$lazy) 
[17:43:41.836]                       future <- run(future)
[17:43:41.836]                     invisible(future)
[17:43:41.836]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:41.836]                 }
[17:43:41.836]             }
[17:43:41.836]         }
[17:43:41.836]     })
[17:43:41.836]     if (TRUE) {
[17:43:41.836]         base::sink(type = "output", split = FALSE)
[17:43:41.836]         if (TRUE) {
[17:43:41.836]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:41.836]         }
[17:43:41.836]         else {
[17:43:41.836]             ...future.result["stdout"] <- base::list(NULL)
[17:43:41.836]         }
[17:43:41.836]         base::close(...future.stdout)
[17:43:41.836]         ...future.stdout <- NULL
[17:43:41.836]     }
[17:43:41.836]     ...future.result$conditions <- ...future.conditions
[17:43:41.836]     ...future.result$finished <- base::Sys.time()
[17:43:41.836]     ...future.result
[17:43:41.836] }
[17:43:41.839] MultisessionFuture started
[17:43:41.840] - Launch lazy future ... done
[17:43:41.840] run() for ‘MultisessionFuture’ ... done
[17:43:42.400] receiveMessageFromWorker() for ClusterFuture ...
[17:43:42.400] - Validating connection of MultisessionFuture
[17:43:42.400] - received message: FutureResult
[17:43:42.400] - Received FutureResult
[17:43:42.400] - Erased future from FutureRegistry
[17:43:42.400] result() for ClusterFuture ...
[17:43:42.400] - result already collected: FutureResult
[17:43:42.401] result() for ClusterFuture ... done
[17:43:42.401] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:42.401] A MultisessionFuture was resolved (result was not collected)
[17:43:42.401] getGlobalsAndPackages() ...
[17:43:42.401] Searching for globals...
[17:43:42.402] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:43:42.402] Searching for globals ... DONE
[17:43:42.402] Resolving globals: FALSE
[17:43:42.403] 
[17:43:42.403] 
[17:43:42.403] getGlobalsAndPackages() ... DONE
[17:43:42.403] run() for ‘Future’ ...
[17:43:42.403] - state: ‘created’
[17:43:42.403] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:42.418] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:42.419] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:42.419]   - Field: ‘node’
[17:43:42.419]   - Field: ‘label’
[17:43:42.419]   - Field: ‘local’
[17:43:42.419]   - Field: ‘owner’
[17:43:42.419]   - Field: ‘envir’
[17:43:42.419]   - Field: ‘workers’
[17:43:42.419]   - Field: ‘packages’
[17:43:42.420]   - Field: ‘gc’
[17:43:42.420]   - Field: ‘conditions’
[17:43:42.420]   - Field: ‘persistent’
[17:43:42.420]   - Field: ‘expr’
[17:43:42.420]   - Field: ‘uuid’
[17:43:42.420]   - Field: ‘seed’
[17:43:42.420]   - Field: ‘version’
[17:43:42.420]   - Field: ‘result’
[17:43:42.420]   - Field: ‘asynchronous’
[17:43:42.420]   - Field: ‘calls’
[17:43:42.420]   - Field: ‘globals’
[17:43:42.421]   - Field: ‘stdout’
[17:43:42.421]   - Field: ‘earlySignal’
[17:43:42.421]   - Field: ‘lazy’
[17:43:42.421]   - Field: ‘state’
[17:43:42.421] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:42.421] - Launch lazy future ...
[17:43:42.421] Packages needed by the future expression (n = 0): <none>
[17:43:42.421] Packages needed by future strategies (n = 0): <none>
[17:43:42.422] {
[17:43:42.422]     {
[17:43:42.422]         {
[17:43:42.422]             ...future.startTime <- base::Sys.time()
[17:43:42.422]             {
[17:43:42.422]                 {
[17:43:42.422]                   {
[17:43:42.422]                     {
[17:43:42.422]                       base::local({
[17:43:42.422]                         has_future <- base::requireNamespace("future", 
[17:43:42.422]                           quietly = TRUE)
[17:43:42.422]                         if (has_future) {
[17:43:42.422]                           ns <- base::getNamespace("future")
[17:43:42.422]                           version <- ns[[".package"]][["version"]]
[17:43:42.422]                           if (is.null(version)) 
[17:43:42.422]                             version <- utils::packageVersion("future")
[17:43:42.422]                         }
[17:43:42.422]                         else {
[17:43:42.422]                           version <- NULL
[17:43:42.422]                         }
[17:43:42.422]                         if (!has_future || version < "1.8.0") {
[17:43:42.422]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:42.422]                             "", base::R.version$version.string), 
[17:43:42.422]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:42.422]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:42.422]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:42.422]                               "release", "version")], collapse = " "), 
[17:43:42.422]                             hostname = base::Sys.info()[["nodename"]])
[17:43:42.422]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:42.422]                             info)
[17:43:42.422]                           info <- base::paste(info, collapse = "; ")
[17:43:42.422]                           if (!has_future) {
[17:43:42.422]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:42.422]                               info)
[17:43:42.422]                           }
[17:43:42.422]                           else {
[17:43:42.422]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:42.422]                               info, version)
[17:43:42.422]                           }
[17:43:42.422]                           base::stop(msg)
[17:43:42.422]                         }
[17:43:42.422]                       })
[17:43:42.422]                     }
[17:43:42.422]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:42.422]                     base::options(mc.cores = 1L)
[17:43:42.422]                   }
[17:43:42.422]                   options(future.plan = NULL)
[17:43:42.422]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:42.422]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:42.422]                 }
[17:43:42.422]                 ...future.workdir <- getwd()
[17:43:42.422]             }
[17:43:42.422]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:42.422]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:42.422]         }
[17:43:42.422]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:42.422]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:42.422]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:42.422]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:42.422]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:42.422]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:42.422]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:42.422]             base::names(...future.oldOptions))
[17:43:42.422]     }
[17:43:42.422]     if (FALSE) {
[17:43:42.422]     }
[17:43:42.422]     else {
[17:43:42.422]         if (TRUE) {
[17:43:42.422]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:42.422]                 open = "w")
[17:43:42.422]         }
[17:43:42.422]         else {
[17:43:42.422]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:42.422]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:42.422]         }
[17:43:42.422]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:42.422]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:42.422]             base::sink(type = "output", split = FALSE)
[17:43:42.422]             base::close(...future.stdout)
[17:43:42.422]         }, add = TRUE)
[17:43:42.422]     }
[17:43:42.422]     ...future.frame <- base::sys.nframe()
[17:43:42.422]     ...future.conditions <- base::list()
[17:43:42.422]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:42.422]     if (FALSE) {
[17:43:42.422]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:42.422]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:42.422]     }
[17:43:42.422]     ...future.result <- base::tryCatch({
[17:43:42.422]         base::withCallingHandlers({
[17:43:42.422]             ...future.value <- base::withVisible(base::local({
[17:43:42.422]                 ...future.makeSendCondition <- local({
[17:43:42.422]                   sendCondition <- NULL
[17:43:42.422]                   function(frame = 1L) {
[17:43:42.422]                     if (is.function(sendCondition)) 
[17:43:42.422]                       return(sendCondition)
[17:43:42.422]                     ns <- getNamespace("parallel")
[17:43:42.422]                     if (exists("sendData", mode = "function", 
[17:43:42.422]                       envir = ns)) {
[17:43:42.422]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:42.422]                         envir = ns)
[17:43:42.422]                       envir <- sys.frame(frame)
[17:43:42.422]                       master <- NULL
[17:43:42.422]                       while (!identical(envir, .GlobalEnv) && 
[17:43:42.422]                         !identical(envir, emptyenv())) {
[17:43:42.422]                         if (exists("master", mode = "list", envir = envir, 
[17:43:42.422]                           inherits = FALSE)) {
[17:43:42.422]                           master <- get("master", mode = "list", 
[17:43:42.422]                             envir = envir, inherits = FALSE)
[17:43:42.422]                           if (inherits(master, c("SOCKnode", 
[17:43:42.422]                             "SOCK0node"))) {
[17:43:42.422]                             sendCondition <<- function(cond) {
[17:43:42.422]                               data <- list(type = "VALUE", value = cond, 
[17:43:42.422]                                 success = TRUE)
[17:43:42.422]                               parallel_sendData(master, data)
[17:43:42.422]                             }
[17:43:42.422]                             return(sendCondition)
[17:43:42.422]                           }
[17:43:42.422]                         }
[17:43:42.422]                         frame <- frame + 1L
[17:43:42.422]                         envir <- sys.frame(frame)
[17:43:42.422]                       }
[17:43:42.422]                     }
[17:43:42.422]                     sendCondition <<- function(cond) NULL
[17:43:42.422]                   }
[17:43:42.422]                 })
[17:43:42.422]                 withCallingHandlers({
[17:43:42.422]                   {
[17:43:42.422]                     Sys.sleep(0.5)
[17:43:42.422]                     list(a = 1, b = 42L)
[17:43:42.422]                   }
[17:43:42.422]                 }, immediateCondition = function(cond) {
[17:43:42.422]                   sendCondition <- ...future.makeSendCondition()
[17:43:42.422]                   sendCondition(cond)
[17:43:42.422]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:42.422]                   {
[17:43:42.422]                     inherits <- base::inherits
[17:43:42.422]                     invokeRestart <- base::invokeRestart
[17:43:42.422]                     is.null <- base::is.null
[17:43:42.422]                     muffled <- FALSE
[17:43:42.422]                     if (inherits(cond, "message")) {
[17:43:42.422]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:42.422]                       if (muffled) 
[17:43:42.422]                         invokeRestart("muffleMessage")
[17:43:42.422]                     }
[17:43:42.422]                     else if (inherits(cond, "warning")) {
[17:43:42.422]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:42.422]                       if (muffled) 
[17:43:42.422]                         invokeRestart("muffleWarning")
[17:43:42.422]                     }
[17:43:42.422]                     else if (inherits(cond, "condition")) {
[17:43:42.422]                       if (!is.null(pattern)) {
[17:43:42.422]                         computeRestarts <- base::computeRestarts
[17:43:42.422]                         grepl <- base::grepl
[17:43:42.422]                         restarts <- computeRestarts(cond)
[17:43:42.422]                         for (restart in restarts) {
[17:43:42.422]                           name <- restart$name
[17:43:42.422]                           if (is.null(name)) 
[17:43:42.422]                             next
[17:43:42.422]                           if (!grepl(pattern, name)) 
[17:43:42.422]                             next
[17:43:42.422]                           invokeRestart(restart)
[17:43:42.422]                           muffled <- TRUE
[17:43:42.422]                           break
[17:43:42.422]                         }
[17:43:42.422]                       }
[17:43:42.422]                     }
[17:43:42.422]                     invisible(muffled)
[17:43:42.422]                   }
[17:43:42.422]                   muffleCondition(cond)
[17:43:42.422]                 })
[17:43:42.422]             }))
[17:43:42.422]             future::FutureResult(value = ...future.value$value, 
[17:43:42.422]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:42.422]                   ...future.rng), globalenv = if (FALSE) 
[17:43:42.422]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:42.422]                     ...future.globalenv.names))
[17:43:42.422]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:42.422]         }, condition = base::local({
[17:43:42.422]             c <- base::c
[17:43:42.422]             inherits <- base::inherits
[17:43:42.422]             invokeRestart <- base::invokeRestart
[17:43:42.422]             length <- base::length
[17:43:42.422]             list <- base::list
[17:43:42.422]             seq.int <- base::seq.int
[17:43:42.422]             signalCondition <- base::signalCondition
[17:43:42.422]             sys.calls <- base::sys.calls
[17:43:42.422]             `[[` <- base::`[[`
[17:43:42.422]             `+` <- base::`+`
[17:43:42.422]             `<<-` <- base::`<<-`
[17:43:42.422]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:42.422]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:42.422]                   3L)]
[17:43:42.422]             }
[17:43:42.422]             function(cond) {
[17:43:42.422]                 is_error <- inherits(cond, "error")
[17:43:42.422]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:42.422]                   NULL)
[17:43:42.422]                 if (is_error) {
[17:43:42.422]                   sessionInformation <- function() {
[17:43:42.422]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:42.422]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:42.422]                       search = base::search(), system = base::Sys.info())
[17:43:42.422]                   }
[17:43:42.422]                   ...future.conditions[[length(...future.conditions) + 
[17:43:42.422]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:42.422]                     cond$call), session = sessionInformation(), 
[17:43:42.422]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:42.422]                   signalCondition(cond)
[17:43:42.422]                 }
[17:43:42.422]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:42.422]                 "immediateCondition"))) {
[17:43:42.422]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:42.422]                   ...future.conditions[[length(...future.conditions) + 
[17:43:42.422]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:42.422]                   if (TRUE && !signal) {
[17:43:42.422]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:42.422]                     {
[17:43:42.422]                       inherits <- base::inherits
[17:43:42.422]                       invokeRestart <- base::invokeRestart
[17:43:42.422]                       is.null <- base::is.null
[17:43:42.422]                       muffled <- FALSE
[17:43:42.422]                       if (inherits(cond, "message")) {
[17:43:42.422]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:42.422]                         if (muffled) 
[17:43:42.422]                           invokeRestart("muffleMessage")
[17:43:42.422]                       }
[17:43:42.422]                       else if (inherits(cond, "warning")) {
[17:43:42.422]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:42.422]                         if (muffled) 
[17:43:42.422]                           invokeRestart("muffleWarning")
[17:43:42.422]                       }
[17:43:42.422]                       else if (inherits(cond, "condition")) {
[17:43:42.422]                         if (!is.null(pattern)) {
[17:43:42.422]                           computeRestarts <- base::computeRestarts
[17:43:42.422]                           grepl <- base::grepl
[17:43:42.422]                           restarts <- computeRestarts(cond)
[17:43:42.422]                           for (restart in restarts) {
[17:43:42.422]                             name <- restart$name
[17:43:42.422]                             if (is.null(name)) 
[17:43:42.422]                               next
[17:43:42.422]                             if (!grepl(pattern, name)) 
[17:43:42.422]                               next
[17:43:42.422]                             invokeRestart(restart)
[17:43:42.422]                             muffled <- TRUE
[17:43:42.422]                             break
[17:43:42.422]                           }
[17:43:42.422]                         }
[17:43:42.422]                       }
[17:43:42.422]                       invisible(muffled)
[17:43:42.422]                     }
[17:43:42.422]                     muffleCondition(cond, pattern = "^muffle")
[17:43:42.422]                   }
[17:43:42.422]                 }
[17:43:42.422]                 else {
[17:43:42.422]                   if (TRUE) {
[17:43:42.422]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:42.422]                     {
[17:43:42.422]                       inherits <- base::inherits
[17:43:42.422]                       invokeRestart <- base::invokeRestart
[17:43:42.422]                       is.null <- base::is.null
[17:43:42.422]                       muffled <- FALSE
[17:43:42.422]                       if (inherits(cond, "message")) {
[17:43:42.422]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:42.422]                         if (muffled) 
[17:43:42.422]                           invokeRestart("muffleMessage")
[17:43:42.422]                       }
[17:43:42.422]                       else if (inherits(cond, "warning")) {
[17:43:42.422]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:42.422]                         if (muffled) 
[17:43:42.422]                           invokeRestart("muffleWarning")
[17:43:42.422]                       }
[17:43:42.422]                       else if (inherits(cond, "condition")) {
[17:43:42.422]                         if (!is.null(pattern)) {
[17:43:42.422]                           computeRestarts <- base::computeRestarts
[17:43:42.422]                           grepl <- base::grepl
[17:43:42.422]                           restarts <- computeRestarts(cond)
[17:43:42.422]                           for (restart in restarts) {
[17:43:42.422]                             name <- restart$name
[17:43:42.422]                             if (is.null(name)) 
[17:43:42.422]                               next
[17:43:42.422]                             if (!grepl(pattern, name)) 
[17:43:42.422]                               next
[17:43:42.422]                             invokeRestart(restart)
[17:43:42.422]                             muffled <- TRUE
[17:43:42.422]                             break
[17:43:42.422]                           }
[17:43:42.422]                         }
[17:43:42.422]                       }
[17:43:42.422]                       invisible(muffled)
[17:43:42.422]                     }
[17:43:42.422]                     muffleCondition(cond, pattern = "^muffle")
[17:43:42.422]                   }
[17:43:42.422]                 }
[17:43:42.422]             }
[17:43:42.422]         }))
[17:43:42.422]     }, error = function(ex) {
[17:43:42.422]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:42.422]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:42.422]                 ...future.rng), started = ...future.startTime, 
[17:43:42.422]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:42.422]             version = "1.8"), class = "FutureResult")
[17:43:42.422]     }, finally = {
[17:43:42.422]         if (!identical(...future.workdir, getwd())) 
[17:43:42.422]             setwd(...future.workdir)
[17:43:42.422]         {
[17:43:42.422]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:42.422]                 ...future.oldOptions$nwarnings <- NULL
[17:43:42.422]             }
[17:43:42.422]             base::options(...future.oldOptions)
[17:43:42.422]             if (.Platform$OS.type == "windows") {
[17:43:42.422]                 old_names <- names(...future.oldEnvVars)
[17:43:42.422]                 envs <- base::Sys.getenv()
[17:43:42.422]                 names <- names(envs)
[17:43:42.422]                 common <- intersect(names, old_names)
[17:43:42.422]                 added <- setdiff(names, old_names)
[17:43:42.422]                 removed <- setdiff(old_names, names)
[17:43:42.422]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:42.422]                   envs[common]]
[17:43:42.422]                 NAMES <- toupper(changed)
[17:43:42.422]                 args <- list()
[17:43:42.422]                 for (kk in seq_along(NAMES)) {
[17:43:42.422]                   name <- changed[[kk]]
[17:43:42.422]                   NAME <- NAMES[[kk]]
[17:43:42.422]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:42.422]                     next
[17:43:42.422]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:42.422]                 }
[17:43:42.422]                 NAMES <- toupper(added)
[17:43:42.422]                 for (kk in seq_along(NAMES)) {
[17:43:42.422]                   name <- added[[kk]]
[17:43:42.422]                   NAME <- NAMES[[kk]]
[17:43:42.422]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:42.422]                     next
[17:43:42.422]                   args[[name]] <- ""
[17:43:42.422]                 }
[17:43:42.422]                 NAMES <- toupper(removed)
[17:43:42.422]                 for (kk in seq_along(NAMES)) {
[17:43:42.422]                   name <- removed[[kk]]
[17:43:42.422]                   NAME <- NAMES[[kk]]
[17:43:42.422]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:42.422]                     next
[17:43:42.422]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:42.422]                 }
[17:43:42.422]                 if (length(args) > 0) 
[17:43:42.422]                   base::do.call(base::Sys.setenv, args = args)
[17:43:42.422]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:42.422]             }
[17:43:42.422]             else {
[17:43:42.422]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:42.422]             }
[17:43:42.422]             {
[17:43:42.422]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:42.422]                   0L) {
[17:43:42.422]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:42.422]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:42.422]                   base::options(opts)
[17:43:42.422]                 }
[17:43:42.422]                 {
[17:43:42.422]                   {
[17:43:42.422]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:42.422]                     NULL
[17:43:42.422]                   }
[17:43:42.422]                   options(future.plan = NULL)
[17:43:42.422]                   if (is.na(NA_character_)) 
[17:43:42.422]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:42.422]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:42.422]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:42.422]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:42.422]                     envir = parent.frame()) 
[17:43:42.422]                   {
[17:43:42.422]                     if (is.function(workers)) 
[17:43:42.422]                       workers <- workers()
[17:43:42.422]                     workers <- structure(as.integer(workers), 
[17:43:42.422]                       class = class(workers))
[17:43:42.422]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:42.422]                       workers >= 1)
[17:43:42.422]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:42.422]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:42.422]                     }
[17:43:42.422]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:42.422]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:42.422]                       envir = envir)
[17:43:42.422]                     if (!future$lazy) 
[17:43:42.422]                       future <- run(future)
[17:43:42.422]                     invisible(future)
[17:43:42.422]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:42.422]                 }
[17:43:42.422]             }
[17:43:42.422]         }
[17:43:42.422]     })
[17:43:42.422]     if (TRUE) {
[17:43:42.422]         base::sink(type = "output", split = FALSE)
[17:43:42.422]         if (TRUE) {
[17:43:42.422]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:42.422]         }
[17:43:42.422]         else {
[17:43:42.422]             ...future.result["stdout"] <- base::list(NULL)
[17:43:42.422]         }
[17:43:42.422]         base::close(...future.stdout)
[17:43:42.422]         ...future.stdout <- NULL
[17:43:42.422]     }
[17:43:42.422]     ...future.result$conditions <- ...future.conditions
[17:43:42.422]     ...future.result$finished <- base::Sys.time()
[17:43:42.422]     ...future.result
[17:43:42.422] }
[17:43:42.425] MultisessionFuture started
[17:43:42.425] - Launch lazy future ... done
[17:43:42.425] run() for ‘MultisessionFuture’ ... done
[17:43:42.973] receiveMessageFromWorker() for ClusterFuture ...
[17:43:42.973] - Validating connection of MultisessionFuture
[17:43:42.973] - received message: FutureResult
[17:43:42.974] - Received FutureResult
[17:43:42.974] - Erased future from FutureRegistry
[17:43:42.974] result() for ClusterFuture ...
[17:43:42.974] - result already collected: FutureResult
[17:43:42.974] result() for ClusterFuture ... done
[17:43:42.974] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:42.974] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[17:43:42.974] getGlobalsAndPackages() ...
[17:43:42.974] Searching for globals...
[17:43:42.975] - globals found: [2] ‘list’, ‘stop’
[17:43:42.975] Searching for globals ... DONE
[17:43:42.975] Resolving globals: FALSE
[17:43:42.976] 
[17:43:42.976] 
[17:43:42.976] getGlobalsAndPackages() ... DONE
[17:43:42.976] run() for ‘Future’ ...
[17:43:42.976] - state: ‘created’
[17:43:42.976] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:42.991] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:42.991] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:42.991]   - Field: ‘node’
[17:43:42.991]   - Field: ‘label’
[17:43:42.991]   - Field: ‘local’
[17:43:42.991]   - Field: ‘owner’
[17:43:42.991]   - Field: ‘envir’
[17:43:42.991]   - Field: ‘workers’
[17:43:42.992]   - Field: ‘packages’
[17:43:42.992]   - Field: ‘gc’
[17:43:42.992]   - Field: ‘conditions’
[17:43:42.992]   - Field: ‘persistent’
[17:43:42.992]   - Field: ‘expr’
[17:43:42.992]   - Field: ‘uuid’
[17:43:42.992]   - Field: ‘seed’
[17:43:42.992]   - Field: ‘version’
[17:43:42.992]   - Field: ‘result’
[17:43:42.992]   - Field: ‘asynchronous’
[17:43:42.992]   - Field: ‘calls’
[17:43:42.992]   - Field: ‘globals’
[17:43:42.993]   - Field: ‘stdout’
[17:43:42.993]   - Field: ‘earlySignal’
[17:43:42.993]   - Field: ‘lazy’
[17:43:42.993]   - Field: ‘state’
[17:43:42.993] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:42.993] - Launch lazy future ...
[17:43:42.993] Packages needed by the future expression (n = 0): <none>
[17:43:42.993] Packages needed by future strategies (n = 0): <none>
[17:43:42.994] {
[17:43:42.994]     {
[17:43:42.994]         {
[17:43:42.994]             ...future.startTime <- base::Sys.time()
[17:43:42.994]             {
[17:43:42.994]                 {
[17:43:42.994]                   {
[17:43:42.994]                     {
[17:43:42.994]                       base::local({
[17:43:42.994]                         has_future <- base::requireNamespace("future", 
[17:43:42.994]                           quietly = TRUE)
[17:43:42.994]                         if (has_future) {
[17:43:42.994]                           ns <- base::getNamespace("future")
[17:43:42.994]                           version <- ns[[".package"]][["version"]]
[17:43:42.994]                           if (is.null(version)) 
[17:43:42.994]                             version <- utils::packageVersion("future")
[17:43:42.994]                         }
[17:43:42.994]                         else {
[17:43:42.994]                           version <- NULL
[17:43:42.994]                         }
[17:43:42.994]                         if (!has_future || version < "1.8.0") {
[17:43:42.994]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:42.994]                             "", base::R.version$version.string), 
[17:43:42.994]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:42.994]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:42.994]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:42.994]                               "release", "version")], collapse = " "), 
[17:43:42.994]                             hostname = base::Sys.info()[["nodename"]])
[17:43:42.994]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:42.994]                             info)
[17:43:42.994]                           info <- base::paste(info, collapse = "; ")
[17:43:42.994]                           if (!has_future) {
[17:43:42.994]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:42.994]                               info)
[17:43:42.994]                           }
[17:43:42.994]                           else {
[17:43:42.994]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:42.994]                               info, version)
[17:43:42.994]                           }
[17:43:42.994]                           base::stop(msg)
[17:43:42.994]                         }
[17:43:42.994]                       })
[17:43:42.994]                     }
[17:43:42.994]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:42.994]                     base::options(mc.cores = 1L)
[17:43:42.994]                   }
[17:43:42.994]                   options(future.plan = NULL)
[17:43:42.994]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:42.994]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:42.994]                 }
[17:43:42.994]                 ...future.workdir <- getwd()
[17:43:42.994]             }
[17:43:42.994]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:42.994]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:42.994]         }
[17:43:42.994]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:42.994]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:42.994]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:42.994]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:42.994]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:42.994]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:42.994]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:42.994]             base::names(...future.oldOptions))
[17:43:42.994]     }
[17:43:42.994]     if (FALSE) {
[17:43:42.994]     }
[17:43:42.994]     else {
[17:43:42.994]         if (TRUE) {
[17:43:42.994]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:42.994]                 open = "w")
[17:43:42.994]         }
[17:43:42.994]         else {
[17:43:42.994]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:42.994]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:42.994]         }
[17:43:42.994]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:42.994]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:42.994]             base::sink(type = "output", split = FALSE)
[17:43:42.994]             base::close(...future.stdout)
[17:43:42.994]         }, add = TRUE)
[17:43:42.994]     }
[17:43:42.994]     ...future.frame <- base::sys.nframe()
[17:43:42.994]     ...future.conditions <- base::list()
[17:43:42.994]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:42.994]     if (FALSE) {
[17:43:42.994]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:42.994]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:42.994]     }
[17:43:42.994]     ...future.result <- base::tryCatch({
[17:43:42.994]         base::withCallingHandlers({
[17:43:42.994]             ...future.value <- base::withVisible(base::local({
[17:43:42.994]                 ...future.makeSendCondition <- local({
[17:43:42.994]                   sendCondition <- NULL
[17:43:42.994]                   function(frame = 1L) {
[17:43:42.994]                     if (is.function(sendCondition)) 
[17:43:42.994]                       return(sendCondition)
[17:43:42.994]                     ns <- getNamespace("parallel")
[17:43:42.994]                     if (exists("sendData", mode = "function", 
[17:43:42.994]                       envir = ns)) {
[17:43:42.994]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:42.994]                         envir = ns)
[17:43:42.994]                       envir <- sys.frame(frame)
[17:43:42.994]                       master <- NULL
[17:43:42.994]                       while (!identical(envir, .GlobalEnv) && 
[17:43:42.994]                         !identical(envir, emptyenv())) {
[17:43:42.994]                         if (exists("master", mode = "list", envir = envir, 
[17:43:42.994]                           inherits = FALSE)) {
[17:43:42.994]                           master <- get("master", mode = "list", 
[17:43:42.994]                             envir = envir, inherits = FALSE)
[17:43:42.994]                           if (inherits(master, c("SOCKnode", 
[17:43:42.994]                             "SOCK0node"))) {
[17:43:42.994]                             sendCondition <<- function(cond) {
[17:43:42.994]                               data <- list(type = "VALUE", value = cond, 
[17:43:42.994]                                 success = TRUE)
[17:43:42.994]                               parallel_sendData(master, data)
[17:43:42.994]                             }
[17:43:42.994]                             return(sendCondition)
[17:43:42.994]                           }
[17:43:42.994]                         }
[17:43:42.994]                         frame <- frame + 1L
[17:43:42.994]                         envir <- sys.frame(frame)
[17:43:42.994]                       }
[17:43:42.994]                     }
[17:43:42.994]                     sendCondition <<- function(cond) NULL
[17:43:42.994]                   }
[17:43:42.994]                 })
[17:43:42.994]                 withCallingHandlers({
[17:43:42.994]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:43:42.994]                 }, immediateCondition = function(cond) {
[17:43:42.994]                   sendCondition <- ...future.makeSendCondition()
[17:43:42.994]                   sendCondition(cond)
[17:43:42.994]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:42.994]                   {
[17:43:42.994]                     inherits <- base::inherits
[17:43:42.994]                     invokeRestart <- base::invokeRestart
[17:43:42.994]                     is.null <- base::is.null
[17:43:42.994]                     muffled <- FALSE
[17:43:42.994]                     if (inherits(cond, "message")) {
[17:43:42.994]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:42.994]                       if (muffled) 
[17:43:42.994]                         invokeRestart("muffleMessage")
[17:43:42.994]                     }
[17:43:42.994]                     else if (inherits(cond, "warning")) {
[17:43:42.994]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:42.994]                       if (muffled) 
[17:43:42.994]                         invokeRestart("muffleWarning")
[17:43:42.994]                     }
[17:43:42.994]                     else if (inherits(cond, "condition")) {
[17:43:42.994]                       if (!is.null(pattern)) {
[17:43:42.994]                         computeRestarts <- base::computeRestarts
[17:43:42.994]                         grepl <- base::grepl
[17:43:42.994]                         restarts <- computeRestarts(cond)
[17:43:42.994]                         for (restart in restarts) {
[17:43:42.994]                           name <- restart$name
[17:43:42.994]                           if (is.null(name)) 
[17:43:42.994]                             next
[17:43:42.994]                           if (!grepl(pattern, name)) 
[17:43:42.994]                             next
[17:43:42.994]                           invokeRestart(restart)
[17:43:42.994]                           muffled <- TRUE
[17:43:42.994]                           break
[17:43:42.994]                         }
[17:43:42.994]                       }
[17:43:42.994]                     }
[17:43:42.994]                     invisible(muffled)
[17:43:42.994]                   }
[17:43:42.994]                   muffleCondition(cond)
[17:43:42.994]                 })
[17:43:42.994]             }))
[17:43:42.994]             future::FutureResult(value = ...future.value$value, 
[17:43:42.994]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:42.994]                   ...future.rng), globalenv = if (FALSE) 
[17:43:42.994]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:42.994]                     ...future.globalenv.names))
[17:43:42.994]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:42.994]         }, condition = base::local({
[17:43:42.994]             c <- base::c
[17:43:42.994]             inherits <- base::inherits
[17:43:42.994]             invokeRestart <- base::invokeRestart
[17:43:42.994]             length <- base::length
[17:43:42.994]             list <- base::list
[17:43:42.994]             seq.int <- base::seq.int
[17:43:42.994]             signalCondition <- base::signalCondition
[17:43:42.994]             sys.calls <- base::sys.calls
[17:43:42.994]             `[[` <- base::`[[`
[17:43:42.994]             `+` <- base::`+`
[17:43:42.994]             `<<-` <- base::`<<-`
[17:43:42.994]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:42.994]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:42.994]                   3L)]
[17:43:42.994]             }
[17:43:42.994]             function(cond) {
[17:43:42.994]                 is_error <- inherits(cond, "error")
[17:43:42.994]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:42.994]                   NULL)
[17:43:42.994]                 if (is_error) {
[17:43:42.994]                   sessionInformation <- function() {
[17:43:42.994]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:42.994]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:42.994]                       search = base::search(), system = base::Sys.info())
[17:43:42.994]                   }
[17:43:42.994]                   ...future.conditions[[length(...future.conditions) + 
[17:43:42.994]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:42.994]                     cond$call), session = sessionInformation(), 
[17:43:42.994]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:42.994]                   signalCondition(cond)
[17:43:42.994]                 }
[17:43:42.994]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:42.994]                 "immediateCondition"))) {
[17:43:42.994]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:42.994]                   ...future.conditions[[length(...future.conditions) + 
[17:43:42.994]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:42.994]                   if (TRUE && !signal) {
[17:43:42.994]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:42.994]                     {
[17:43:42.994]                       inherits <- base::inherits
[17:43:42.994]                       invokeRestart <- base::invokeRestart
[17:43:42.994]                       is.null <- base::is.null
[17:43:42.994]                       muffled <- FALSE
[17:43:42.994]                       if (inherits(cond, "message")) {
[17:43:42.994]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:42.994]                         if (muffled) 
[17:43:42.994]                           invokeRestart("muffleMessage")
[17:43:42.994]                       }
[17:43:42.994]                       else if (inherits(cond, "warning")) {
[17:43:42.994]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:42.994]                         if (muffled) 
[17:43:42.994]                           invokeRestart("muffleWarning")
[17:43:42.994]                       }
[17:43:42.994]                       else if (inherits(cond, "condition")) {
[17:43:42.994]                         if (!is.null(pattern)) {
[17:43:42.994]                           computeRestarts <- base::computeRestarts
[17:43:42.994]                           grepl <- base::grepl
[17:43:42.994]                           restarts <- computeRestarts(cond)
[17:43:42.994]                           for (restart in restarts) {
[17:43:42.994]                             name <- restart$name
[17:43:42.994]                             if (is.null(name)) 
[17:43:42.994]                               next
[17:43:42.994]                             if (!grepl(pattern, name)) 
[17:43:42.994]                               next
[17:43:42.994]                             invokeRestart(restart)
[17:43:42.994]                             muffled <- TRUE
[17:43:42.994]                             break
[17:43:42.994]                           }
[17:43:42.994]                         }
[17:43:42.994]                       }
[17:43:42.994]                       invisible(muffled)
[17:43:42.994]                     }
[17:43:42.994]                     muffleCondition(cond, pattern = "^muffle")
[17:43:42.994]                   }
[17:43:42.994]                 }
[17:43:42.994]                 else {
[17:43:42.994]                   if (TRUE) {
[17:43:42.994]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:42.994]                     {
[17:43:42.994]                       inherits <- base::inherits
[17:43:42.994]                       invokeRestart <- base::invokeRestart
[17:43:42.994]                       is.null <- base::is.null
[17:43:42.994]                       muffled <- FALSE
[17:43:42.994]                       if (inherits(cond, "message")) {
[17:43:42.994]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:42.994]                         if (muffled) 
[17:43:42.994]                           invokeRestart("muffleMessage")
[17:43:42.994]                       }
[17:43:42.994]                       else if (inherits(cond, "warning")) {
[17:43:42.994]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:42.994]                         if (muffled) 
[17:43:42.994]                           invokeRestart("muffleWarning")
[17:43:42.994]                       }
[17:43:42.994]                       else if (inherits(cond, "condition")) {
[17:43:42.994]                         if (!is.null(pattern)) {
[17:43:42.994]                           computeRestarts <- base::computeRestarts
[17:43:42.994]                           grepl <- base::grepl
[17:43:42.994]                           restarts <- computeRestarts(cond)
[17:43:42.994]                           for (restart in restarts) {
[17:43:42.994]                             name <- restart$name
[17:43:42.994]                             if (is.null(name)) 
[17:43:42.994]                               next
[17:43:42.994]                             if (!grepl(pattern, name)) 
[17:43:42.994]                               next
[17:43:42.994]                             invokeRestart(restart)
[17:43:42.994]                             muffled <- TRUE
[17:43:42.994]                             break
[17:43:42.994]                           }
[17:43:42.994]                         }
[17:43:42.994]                       }
[17:43:42.994]                       invisible(muffled)
[17:43:42.994]                     }
[17:43:42.994]                     muffleCondition(cond, pattern = "^muffle")
[17:43:42.994]                   }
[17:43:42.994]                 }
[17:43:42.994]             }
[17:43:42.994]         }))
[17:43:42.994]     }, error = function(ex) {
[17:43:42.994]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:42.994]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:42.994]                 ...future.rng), started = ...future.startTime, 
[17:43:42.994]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:42.994]             version = "1.8"), class = "FutureResult")
[17:43:42.994]     }, finally = {
[17:43:42.994]         if (!identical(...future.workdir, getwd())) 
[17:43:42.994]             setwd(...future.workdir)
[17:43:42.994]         {
[17:43:42.994]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:42.994]                 ...future.oldOptions$nwarnings <- NULL
[17:43:42.994]             }
[17:43:42.994]             base::options(...future.oldOptions)
[17:43:42.994]             if (.Platform$OS.type == "windows") {
[17:43:42.994]                 old_names <- names(...future.oldEnvVars)
[17:43:42.994]                 envs <- base::Sys.getenv()
[17:43:42.994]                 names <- names(envs)
[17:43:42.994]                 common <- intersect(names, old_names)
[17:43:42.994]                 added <- setdiff(names, old_names)
[17:43:42.994]                 removed <- setdiff(old_names, names)
[17:43:42.994]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:42.994]                   envs[common]]
[17:43:42.994]                 NAMES <- toupper(changed)
[17:43:42.994]                 args <- list()
[17:43:42.994]                 for (kk in seq_along(NAMES)) {
[17:43:42.994]                   name <- changed[[kk]]
[17:43:42.994]                   NAME <- NAMES[[kk]]
[17:43:42.994]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:42.994]                     next
[17:43:42.994]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:42.994]                 }
[17:43:42.994]                 NAMES <- toupper(added)
[17:43:42.994]                 for (kk in seq_along(NAMES)) {
[17:43:42.994]                   name <- added[[kk]]
[17:43:42.994]                   NAME <- NAMES[[kk]]
[17:43:42.994]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:42.994]                     next
[17:43:42.994]                   args[[name]] <- ""
[17:43:42.994]                 }
[17:43:42.994]                 NAMES <- toupper(removed)
[17:43:42.994]                 for (kk in seq_along(NAMES)) {
[17:43:42.994]                   name <- removed[[kk]]
[17:43:42.994]                   NAME <- NAMES[[kk]]
[17:43:42.994]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:42.994]                     next
[17:43:42.994]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:42.994]                 }
[17:43:42.994]                 if (length(args) > 0) 
[17:43:42.994]                   base::do.call(base::Sys.setenv, args = args)
[17:43:42.994]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:42.994]             }
[17:43:42.994]             else {
[17:43:42.994]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:42.994]             }
[17:43:42.994]             {
[17:43:42.994]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:42.994]                   0L) {
[17:43:42.994]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:42.994]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:42.994]                   base::options(opts)
[17:43:42.994]                 }
[17:43:42.994]                 {
[17:43:42.994]                   {
[17:43:42.994]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:42.994]                     NULL
[17:43:42.994]                   }
[17:43:42.994]                   options(future.plan = NULL)
[17:43:42.994]                   if (is.na(NA_character_)) 
[17:43:42.994]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:42.994]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:42.994]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:42.994]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:42.994]                     envir = parent.frame()) 
[17:43:42.994]                   {
[17:43:42.994]                     if (is.function(workers)) 
[17:43:42.994]                       workers <- workers()
[17:43:42.994]                     workers <- structure(as.integer(workers), 
[17:43:42.994]                       class = class(workers))
[17:43:42.994]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:42.994]                       workers >= 1)
[17:43:42.994]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:42.994]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:42.994]                     }
[17:43:42.994]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:42.994]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:42.994]                       envir = envir)
[17:43:42.994]                     if (!future$lazy) 
[17:43:42.994]                       future <- run(future)
[17:43:42.994]                     invisible(future)
[17:43:42.994]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:42.994]                 }
[17:43:42.994]             }
[17:43:42.994]         }
[17:43:42.994]     })
[17:43:42.994]     if (TRUE) {
[17:43:42.994]         base::sink(type = "output", split = FALSE)
[17:43:42.994]         if (TRUE) {
[17:43:42.994]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:42.994]         }
[17:43:42.994]         else {
[17:43:42.994]             ...future.result["stdout"] <- base::list(NULL)
[17:43:42.994]         }
[17:43:42.994]         base::close(...future.stdout)
[17:43:42.994]         ...future.stdout <- NULL
[17:43:42.994]     }
[17:43:42.994]     ...future.result$conditions <- ...future.conditions
[17:43:42.994]     ...future.result$finished <- base::Sys.time()
[17:43:42.994]     ...future.result
[17:43:42.994] }
[17:43:42.997] MultisessionFuture started
[17:43:42.997] - Launch lazy future ... done
[17:43:42.997] run() for ‘MultisessionFuture’ ... done
[17:43:43.002] receiveMessageFromWorker() for ClusterFuture ...
[17:43:43.002] - Validating connection of MultisessionFuture
[17:43:43.002] - received message: FutureResult
[17:43:43.002] - Received FutureResult
[17:43:43.003] - Erased future from FutureRegistry
[17:43:43.003] result() for ClusterFuture ...
[17:43:43.003] - result already collected: FutureResult
[17:43:43.003] result() for ClusterFuture ... done
[17:43:43.003] signalConditions() ...
[17:43:43.003]  - include = ‘immediateCondition’
[17:43:43.003]  - exclude = 
[17:43:43.003]  - resignal = FALSE
[17:43:43.003]  - Number of conditions: 1
[17:43:43.003] signalConditions() ... done
[17:43:43.003] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:43.004] A MultisessionFuture was resolved (result was not collected)
[17:43:43.004] getGlobalsAndPackages() ...
[17:43:43.004] Searching for globals...
[17:43:43.004] - globals found: [2] ‘list’, ‘stop’
[17:43:43.005] Searching for globals ... DONE
[17:43:43.005] Resolving globals: FALSE
[17:43:43.005] 
[17:43:43.005] 
[17:43:43.005] getGlobalsAndPackages() ... DONE
[17:43:43.005] run() for ‘Future’ ...
[17:43:43.005] - state: ‘created’
[17:43:43.006] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:43.022] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:43.023] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:43.023]   - Field: ‘node’
[17:43:43.023]   - Field: ‘label’
[17:43:43.023]   - Field: ‘local’
[17:43:43.023]   - Field: ‘owner’
[17:43:43.023]   - Field: ‘envir’
[17:43:43.023]   - Field: ‘workers’
[17:43:43.023]   - Field: ‘packages’
[17:43:43.023]   - Field: ‘gc’
[17:43:43.023]   - Field: ‘conditions’
[17:43:43.024]   - Field: ‘persistent’
[17:43:43.024]   - Field: ‘expr’
[17:43:43.024]   - Field: ‘uuid’
[17:43:43.024]   - Field: ‘seed’
[17:43:43.024]   - Field: ‘version’
[17:43:43.024]   - Field: ‘result’
[17:43:43.024]   - Field: ‘asynchronous’
[17:43:43.024]   - Field: ‘calls’
[17:43:43.024]   - Field: ‘globals’
[17:43:43.024]   - Field: ‘stdout’
[17:43:43.024]   - Field: ‘earlySignal’
[17:43:43.025]   - Field: ‘lazy’
[17:43:43.025]   - Field: ‘state’
[17:43:43.025] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:43.025] - Launch lazy future ...
[17:43:43.025] Packages needed by the future expression (n = 0): <none>
[17:43:43.025] Packages needed by future strategies (n = 0): <none>
[17:43:43.026] {
[17:43:43.026]     {
[17:43:43.026]         {
[17:43:43.026]             ...future.startTime <- base::Sys.time()
[17:43:43.026]             {
[17:43:43.026]                 {
[17:43:43.026]                   {
[17:43:43.026]                     {
[17:43:43.026]                       base::local({
[17:43:43.026]                         has_future <- base::requireNamespace("future", 
[17:43:43.026]                           quietly = TRUE)
[17:43:43.026]                         if (has_future) {
[17:43:43.026]                           ns <- base::getNamespace("future")
[17:43:43.026]                           version <- ns[[".package"]][["version"]]
[17:43:43.026]                           if (is.null(version)) 
[17:43:43.026]                             version <- utils::packageVersion("future")
[17:43:43.026]                         }
[17:43:43.026]                         else {
[17:43:43.026]                           version <- NULL
[17:43:43.026]                         }
[17:43:43.026]                         if (!has_future || version < "1.8.0") {
[17:43:43.026]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:43.026]                             "", base::R.version$version.string), 
[17:43:43.026]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:43.026]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:43.026]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:43.026]                               "release", "version")], collapse = " "), 
[17:43:43.026]                             hostname = base::Sys.info()[["nodename"]])
[17:43:43.026]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:43.026]                             info)
[17:43:43.026]                           info <- base::paste(info, collapse = "; ")
[17:43:43.026]                           if (!has_future) {
[17:43:43.026]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:43.026]                               info)
[17:43:43.026]                           }
[17:43:43.026]                           else {
[17:43:43.026]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:43.026]                               info, version)
[17:43:43.026]                           }
[17:43:43.026]                           base::stop(msg)
[17:43:43.026]                         }
[17:43:43.026]                       })
[17:43:43.026]                     }
[17:43:43.026]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:43.026]                     base::options(mc.cores = 1L)
[17:43:43.026]                   }
[17:43:43.026]                   options(future.plan = NULL)
[17:43:43.026]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:43.026]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:43.026]                 }
[17:43:43.026]                 ...future.workdir <- getwd()
[17:43:43.026]             }
[17:43:43.026]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:43.026]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:43.026]         }
[17:43:43.026]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:43.026]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:43.026]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:43.026]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:43.026]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:43.026]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:43.026]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:43.026]             base::names(...future.oldOptions))
[17:43:43.026]     }
[17:43:43.026]     if (FALSE) {
[17:43:43.026]     }
[17:43:43.026]     else {
[17:43:43.026]         if (TRUE) {
[17:43:43.026]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:43.026]                 open = "w")
[17:43:43.026]         }
[17:43:43.026]         else {
[17:43:43.026]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:43.026]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:43.026]         }
[17:43:43.026]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:43.026]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:43.026]             base::sink(type = "output", split = FALSE)
[17:43:43.026]             base::close(...future.stdout)
[17:43:43.026]         }, add = TRUE)
[17:43:43.026]     }
[17:43:43.026]     ...future.frame <- base::sys.nframe()
[17:43:43.026]     ...future.conditions <- base::list()
[17:43:43.026]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:43.026]     if (FALSE) {
[17:43:43.026]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:43.026]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:43.026]     }
[17:43:43.026]     ...future.result <- base::tryCatch({
[17:43:43.026]         base::withCallingHandlers({
[17:43:43.026]             ...future.value <- base::withVisible(base::local({
[17:43:43.026]                 ...future.makeSendCondition <- local({
[17:43:43.026]                   sendCondition <- NULL
[17:43:43.026]                   function(frame = 1L) {
[17:43:43.026]                     if (is.function(sendCondition)) 
[17:43:43.026]                       return(sendCondition)
[17:43:43.026]                     ns <- getNamespace("parallel")
[17:43:43.026]                     if (exists("sendData", mode = "function", 
[17:43:43.026]                       envir = ns)) {
[17:43:43.026]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:43.026]                         envir = ns)
[17:43:43.026]                       envir <- sys.frame(frame)
[17:43:43.026]                       master <- NULL
[17:43:43.026]                       while (!identical(envir, .GlobalEnv) && 
[17:43:43.026]                         !identical(envir, emptyenv())) {
[17:43:43.026]                         if (exists("master", mode = "list", envir = envir, 
[17:43:43.026]                           inherits = FALSE)) {
[17:43:43.026]                           master <- get("master", mode = "list", 
[17:43:43.026]                             envir = envir, inherits = FALSE)
[17:43:43.026]                           if (inherits(master, c("SOCKnode", 
[17:43:43.026]                             "SOCK0node"))) {
[17:43:43.026]                             sendCondition <<- function(cond) {
[17:43:43.026]                               data <- list(type = "VALUE", value = cond, 
[17:43:43.026]                                 success = TRUE)
[17:43:43.026]                               parallel_sendData(master, data)
[17:43:43.026]                             }
[17:43:43.026]                             return(sendCondition)
[17:43:43.026]                           }
[17:43:43.026]                         }
[17:43:43.026]                         frame <- frame + 1L
[17:43:43.026]                         envir <- sys.frame(frame)
[17:43:43.026]                       }
[17:43:43.026]                     }
[17:43:43.026]                     sendCondition <<- function(cond) NULL
[17:43:43.026]                   }
[17:43:43.026]                 })
[17:43:43.026]                 withCallingHandlers({
[17:43:43.026]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:43:43.026]                 }, immediateCondition = function(cond) {
[17:43:43.026]                   sendCondition <- ...future.makeSendCondition()
[17:43:43.026]                   sendCondition(cond)
[17:43:43.026]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:43.026]                   {
[17:43:43.026]                     inherits <- base::inherits
[17:43:43.026]                     invokeRestart <- base::invokeRestart
[17:43:43.026]                     is.null <- base::is.null
[17:43:43.026]                     muffled <- FALSE
[17:43:43.026]                     if (inherits(cond, "message")) {
[17:43:43.026]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:43.026]                       if (muffled) 
[17:43:43.026]                         invokeRestart("muffleMessage")
[17:43:43.026]                     }
[17:43:43.026]                     else if (inherits(cond, "warning")) {
[17:43:43.026]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:43.026]                       if (muffled) 
[17:43:43.026]                         invokeRestart("muffleWarning")
[17:43:43.026]                     }
[17:43:43.026]                     else if (inherits(cond, "condition")) {
[17:43:43.026]                       if (!is.null(pattern)) {
[17:43:43.026]                         computeRestarts <- base::computeRestarts
[17:43:43.026]                         grepl <- base::grepl
[17:43:43.026]                         restarts <- computeRestarts(cond)
[17:43:43.026]                         for (restart in restarts) {
[17:43:43.026]                           name <- restart$name
[17:43:43.026]                           if (is.null(name)) 
[17:43:43.026]                             next
[17:43:43.026]                           if (!grepl(pattern, name)) 
[17:43:43.026]                             next
[17:43:43.026]                           invokeRestart(restart)
[17:43:43.026]                           muffled <- TRUE
[17:43:43.026]                           break
[17:43:43.026]                         }
[17:43:43.026]                       }
[17:43:43.026]                     }
[17:43:43.026]                     invisible(muffled)
[17:43:43.026]                   }
[17:43:43.026]                   muffleCondition(cond)
[17:43:43.026]                 })
[17:43:43.026]             }))
[17:43:43.026]             future::FutureResult(value = ...future.value$value, 
[17:43:43.026]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:43.026]                   ...future.rng), globalenv = if (FALSE) 
[17:43:43.026]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:43.026]                     ...future.globalenv.names))
[17:43:43.026]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:43.026]         }, condition = base::local({
[17:43:43.026]             c <- base::c
[17:43:43.026]             inherits <- base::inherits
[17:43:43.026]             invokeRestart <- base::invokeRestart
[17:43:43.026]             length <- base::length
[17:43:43.026]             list <- base::list
[17:43:43.026]             seq.int <- base::seq.int
[17:43:43.026]             signalCondition <- base::signalCondition
[17:43:43.026]             sys.calls <- base::sys.calls
[17:43:43.026]             `[[` <- base::`[[`
[17:43:43.026]             `+` <- base::`+`
[17:43:43.026]             `<<-` <- base::`<<-`
[17:43:43.026]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:43.026]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:43.026]                   3L)]
[17:43:43.026]             }
[17:43:43.026]             function(cond) {
[17:43:43.026]                 is_error <- inherits(cond, "error")
[17:43:43.026]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:43.026]                   NULL)
[17:43:43.026]                 if (is_error) {
[17:43:43.026]                   sessionInformation <- function() {
[17:43:43.026]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:43.026]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:43.026]                       search = base::search(), system = base::Sys.info())
[17:43:43.026]                   }
[17:43:43.026]                   ...future.conditions[[length(...future.conditions) + 
[17:43:43.026]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:43.026]                     cond$call), session = sessionInformation(), 
[17:43:43.026]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:43.026]                   signalCondition(cond)
[17:43:43.026]                 }
[17:43:43.026]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:43.026]                 "immediateCondition"))) {
[17:43:43.026]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:43.026]                   ...future.conditions[[length(...future.conditions) + 
[17:43:43.026]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:43.026]                   if (TRUE && !signal) {
[17:43:43.026]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:43.026]                     {
[17:43:43.026]                       inherits <- base::inherits
[17:43:43.026]                       invokeRestart <- base::invokeRestart
[17:43:43.026]                       is.null <- base::is.null
[17:43:43.026]                       muffled <- FALSE
[17:43:43.026]                       if (inherits(cond, "message")) {
[17:43:43.026]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:43.026]                         if (muffled) 
[17:43:43.026]                           invokeRestart("muffleMessage")
[17:43:43.026]                       }
[17:43:43.026]                       else if (inherits(cond, "warning")) {
[17:43:43.026]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:43.026]                         if (muffled) 
[17:43:43.026]                           invokeRestart("muffleWarning")
[17:43:43.026]                       }
[17:43:43.026]                       else if (inherits(cond, "condition")) {
[17:43:43.026]                         if (!is.null(pattern)) {
[17:43:43.026]                           computeRestarts <- base::computeRestarts
[17:43:43.026]                           grepl <- base::grepl
[17:43:43.026]                           restarts <- computeRestarts(cond)
[17:43:43.026]                           for (restart in restarts) {
[17:43:43.026]                             name <- restart$name
[17:43:43.026]                             if (is.null(name)) 
[17:43:43.026]                               next
[17:43:43.026]                             if (!grepl(pattern, name)) 
[17:43:43.026]                               next
[17:43:43.026]                             invokeRestart(restart)
[17:43:43.026]                             muffled <- TRUE
[17:43:43.026]                             break
[17:43:43.026]                           }
[17:43:43.026]                         }
[17:43:43.026]                       }
[17:43:43.026]                       invisible(muffled)
[17:43:43.026]                     }
[17:43:43.026]                     muffleCondition(cond, pattern = "^muffle")
[17:43:43.026]                   }
[17:43:43.026]                 }
[17:43:43.026]                 else {
[17:43:43.026]                   if (TRUE) {
[17:43:43.026]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:43.026]                     {
[17:43:43.026]                       inherits <- base::inherits
[17:43:43.026]                       invokeRestart <- base::invokeRestart
[17:43:43.026]                       is.null <- base::is.null
[17:43:43.026]                       muffled <- FALSE
[17:43:43.026]                       if (inherits(cond, "message")) {
[17:43:43.026]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:43.026]                         if (muffled) 
[17:43:43.026]                           invokeRestart("muffleMessage")
[17:43:43.026]                       }
[17:43:43.026]                       else if (inherits(cond, "warning")) {
[17:43:43.026]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:43.026]                         if (muffled) 
[17:43:43.026]                           invokeRestart("muffleWarning")
[17:43:43.026]                       }
[17:43:43.026]                       else if (inherits(cond, "condition")) {
[17:43:43.026]                         if (!is.null(pattern)) {
[17:43:43.026]                           computeRestarts <- base::computeRestarts
[17:43:43.026]                           grepl <- base::grepl
[17:43:43.026]                           restarts <- computeRestarts(cond)
[17:43:43.026]                           for (restart in restarts) {
[17:43:43.026]                             name <- restart$name
[17:43:43.026]                             if (is.null(name)) 
[17:43:43.026]                               next
[17:43:43.026]                             if (!grepl(pattern, name)) 
[17:43:43.026]                               next
[17:43:43.026]                             invokeRestart(restart)
[17:43:43.026]                             muffled <- TRUE
[17:43:43.026]                             break
[17:43:43.026]                           }
[17:43:43.026]                         }
[17:43:43.026]                       }
[17:43:43.026]                       invisible(muffled)
[17:43:43.026]                     }
[17:43:43.026]                     muffleCondition(cond, pattern = "^muffle")
[17:43:43.026]                   }
[17:43:43.026]                 }
[17:43:43.026]             }
[17:43:43.026]         }))
[17:43:43.026]     }, error = function(ex) {
[17:43:43.026]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:43.026]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:43.026]                 ...future.rng), started = ...future.startTime, 
[17:43:43.026]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:43.026]             version = "1.8"), class = "FutureResult")
[17:43:43.026]     }, finally = {
[17:43:43.026]         if (!identical(...future.workdir, getwd())) 
[17:43:43.026]             setwd(...future.workdir)
[17:43:43.026]         {
[17:43:43.026]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:43.026]                 ...future.oldOptions$nwarnings <- NULL
[17:43:43.026]             }
[17:43:43.026]             base::options(...future.oldOptions)
[17:43:43.026]             if (.Platform$OS.type == "windows") {
[17:43:43.026]                 old_names <- names(...future.oldEnvVars)
[17:43:43.026]                 envs <- base::Sys.getenv()
[17:43:43.026]                 names <- names(envs)
[17:43:43.026]                 common <- intersect(names, old_names)
[17:43:43.026]                 added <- setdiff(names, old_names)
[17:43:43.026]                 removed <- setdiff(old_names, names)
[17:43:43.026]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:43.026]                   envs[common]]
[17:43:43.026]                 NAMES <- toupper(changed)
[17:43:43.026]                 args <- list()
[17:43:43.026]                 for (kk in seq_along(NAMES)) {
[17:43:43.026]                   name <- changed[[kk]]
[17:43:43.026]                   NAME <- NAMES[[kk]]
[17:43:43.026]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:43.026]                     next
[17:43:43.026]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:43.026]                 }
[17:43:43.026]                 NAMES <- toupper(added)
[17:43:43.026]                 for (kk in seq_along(NAMES)) {
[17:43:43.026]                   name <- added[[kk]]
[17:43:43.026]                   NAME <- NAMES[[kk]]
[17:43:43.026]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:43.026]                     next
[17:43:43.026]                   args[[name]] <- ""
[17:43:43.026]                 }
[17:43:43.026]                 NAMES <- toupper(removed)
[17:43:43.026]                 for (kk in seq_along(NAMES)) {
[17:43:43.026]                   name <- removed[[kk]]
[17:43:43.026]                   NAME <- NAMES[[kk]]
[17:43:43.026]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:43.026]                     next
[17:43:43.026]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:43.026]                 }
[17:43:43.026]                 if (length(args) > 0) 
[17:43:43.026]                   base::do.call(base::Sys.setenv, args = args)
[17:43:43.026]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:43.026]             }
[17:43:43.026]             else {
[17:43:43.026]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:43.026]             }
[17:43:43.026]             {
[17:43:43.026]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:43.026]                   0L) {
[17:43:43.026]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:43.026]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:43.026]                   base::options(opts)
[17:43:43.026]                 }
[17:43:43.026]                 {
[17:43:43.026]                   {
[17:43:43.026]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:43.026]                     NULL
[17:43:43.026]                   }
[17:43:43.026]                   options(future.plan = NULL)
[17:43:43.026]                   if (is.na(NA_character_)) 
[17:43:43.026]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:43.026]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:43.026]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:43.026]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:43.026]                     envir = parent.frame()) 
[17:43:43.026]                   {
[17:43:43.026]                     if (is.function(workers)) 
[17:43:43.026]                       workers <- workers()
[17:43:43.026]                     workers <- structure(as.integer(workers), 
[17:43:43.026]                       class = class(workers))
[17:43:43.026]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:43.026]                       workers >= 1)
[17:43:43.026]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:43.026]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:43.026]                     }
[17:43:43.026]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:43.026]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:43.026]                       envir = envir)
[17:43:43.026]                     if (!future$lazy) 
[17:43:43.026]                       future <- run(future)
[17:43:43.026]                     invisible(future)
[17:43:43.026]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:43.026]                 }
[17:43:43.026]             }
[17:43:43.026]         }
[17:43:43.026]     })
[17:43:43.026]     if (TRUE) {
[17:43:43.026]         base::sink(type = "output", split = FALSE)
[17:43:43.026]         if (TRUE) {
[17:43:43.026]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:43.026]         }
[17:43:43.026]         else {
[17:43:43.026]             ...future.result["stdout"] <- base::list(NULL)
[17:43:43.026]         }
[17:43:43.026]         base::close(...future.stdout)
[17:43:43.026]         ...future.stdout <- NULL
[17:43:43.026]     }
[17:43:43.026]     ...future.result$conditions <- ...future.conditions
[17:43:43.026]     ...future.result$finished <- base::Sys.time()
[17:43:43.026]     ...future.result
[17:43:43.026] }
[17:43:43.029] MultisessionFuture started
[17:43:43.029] - Launch lazy future ... done
[17:43:43.029] run() for ‘MultisessionFuture’ ... done
[17:43:43.080] receiveMessageFromWorker() for ClusterFuture ...
[17:43:43.080] - Validating connection of MultisessionFuture
[17:43:43.080] - received message: FutureResult
[17:43:43.081] - Received FutureResult
[17:43:43.081] - Erased future from FutureRegistry
[17:43:43.081] result() for ClusterFuture ...
[17:43:43.081] - result already collected: FutureResult
[17:43:43.081] result() for ClusterFuture ... done
[17:43:43.081] signalConditions() ...
[17:43:43.081]  - include = ‘immediateCondition’
[17:43:43.081]  - exclude = 
[17:43:43.081]  - resignal = FALSE
[17:43:43.081]  - Number of conditions: 1
[17:43:43.082] signalConditions() ... done
[17:43:43.082] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:43.082] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 1 ... DONE
- result = FALSE, recursive = 2 ...
[17:43:43.082] getGlobalsAndPackages() ...
[17:43:43.082] Searching for globals...
[17:43:43.083] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:43:43.083] Searching for globals ... DONE
[17:43:43.083] Resolving globals: FALSE
[17:43:43.084] 
[17:43:43.084] 
[17:43:43.084] getGlobalsAndPackages() ... DONE
[17:43:43.084] run() for ‘Future’ ...
[17:43:43.084] - state: ‘created’
[17:43:43.084] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:43.099] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:43.099] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:43.099]   - Field: ‘node’
[17:43:43.099]   - Field: ‘label’
[17:43:43.100]   - Field: ‘local’
[17:43:43.100]   - Field: ‘owner’
[17:43:43.100]   - Field: ‘envir’
[17:43:43.100]   - Field: ‘workers’
[17:43:43.100]   - Field: ‘packages’
[17:43:43.100]   - Field: ‘gc’
[17:43:43.100]   - Field: ‘conditions’
[17:43:43.100]   - Field: ‘persistent’
[17:43:43.100]   - Field: ‘expr’
[17:43:43.100]   - Field: ‘uuid’
[17:43:43.101]   - Field: ‘seed’
[17:43:43.101]   - Field: ‘version’
[17:43:43.101]   - Field: ‘result’
[17:43:43.101]   - Field: ‘asynchronous’
[17:43:43.101]   - Field: ‘calls’
[17:43:43.101]   - Field: ‘globals’
[17:43:43.101]   - Field: ‘stdout’
[17:43:43.101]   - Field: ‘earlySignal’
[17:43:43.101]   - Field: ‘lazy’
[17:43:43.101]   - Field: ‘state’
[17:43:43.102] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:43.102] - Launch lazy future ...
[17:43:43.102] Packages needed by the future expression (n = 0): <none>
[17:43:43.102] Packages needed by future strategies (n = 0): <none>
[17:43:43.103] {
[17:43:43.103]     {
[17:43:43.103]         {
[17:43:43.103]             ...future.startTime <- base::Sys.time()
[17:43:43.103]             {
[17:43:43.103]                 {
[17:43:43.103]                   {
[17:43:43.103]                     {
[17:43:43.103]                       base::local({
[17:43:43.103]                         has_future <- base::requireNamespace("future", 
[17:43:43.103]                           quietly = TRUE)
[17:43:43.103]                         if (has_future) {
[17:43:43.103]                           ns <- base::getNamespace("future")
[17:43:43.103]                           version <- ns[[".package"]][["version"]]
[17:43:43.103]                           if (is.null(version)) 
[17:43:43.103]                             version <- utils::packageVersion("future")
[17:43:43.103]                         }
[17:43:43.103]                         else {
[17:43:43.103]                           version <- NULL
[17:43:43.103]                         }
[17:43:43.103]                         if (!has_future || version < "1.8.0") {
[17:43:43.103]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:43.103]                             "", base::R.version$version.string), 
[17:43:43.103]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:43.103]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:43.103]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:43.103]                               "release", "version")], collapse = " "), 
[17:43:43.103]                             hostname = base::Sys.info()[["nodename"]])
[17:43:43.103]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:43.103]                             info)
[17:43:43.103]                           info <- base::paste(info, collapse = "; ")
[17:43:43.103]                           if (!has_future) {
[17:43:43.103]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:43.103]                               info)
[17:43:43.103]                           }
[17:43:43.103]                           else {
[17:43:43.103]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:43.103]                               info, version)
[17:43:43.103]                           }
[17:43:43.103]                           base::stop(msg)
[17:43:43.103]                         }
[17:43:43.103]                       })
[17:43:43.103]                     }
[17:43:43.103]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:43.103]                     base::options(mc.cores = 1L)
[17:43:43.103]                   }
[17:43:43.103]                   options(future.plan = NULL)
[17:43:43.103]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:43.103]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:43.103]                 }
[17:43:43.103]                 ...future.workdir <- getwd()
[17:43:43.103]             }
[17:43:43.103]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:43.103]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:43.103]         }
[17:43:43.103]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:43.103]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:43.103]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:43.103]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:43.103]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:43.103]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:43.103]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:43.103]             base::names(...future.oldOptions))
[17:43:43.103]     }
[17:43:43.103]     if (FALSE) {
[17:43:43.103]     }
[17:43:43.103]     else {
[17:43:43.103]         if (TRUE) {
[17:43:43.103]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:43.103]                 open = "w")
[17:43:43.103]         }
[17:43:43.103]         else {
[17:43:43.103]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:43.103]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:43.103]         }
[17:43:43.103]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:43.103]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:43.103]             base::sink(type = "output", split = FALSE)
[17:43:43.103]             base::close(...future.stdout)
[17:43:43.103]         }, add = TRUE)
[17:43:43.103]     }
[17:43:43.103]     ...future.frame <- base::sys.nframe()
[17:43:43.103]     ...future.conditions <- base::list()
[17:43:43.103]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:43.103]     if (FALSE) {
[17:43:43.103]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:43.103]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:43.103]     }
[17:43:43.103]     ...future.result <- base::tryCatch({
[17:43:43.103]         base::withCallingHandlers({
[17:43:43.103]             ...future.value <- base::withVisible(base::local({
[17:43:43.103]                 ...future.makeSendCondition <- local({
[17:43:43.103]                   sendCondition <- NULL
[17:43:43.103]                   function(frame = 1L) {
[17:43:43.103]                     if (is.function(sendCondition)) 
[17:43:43.103]                       return(sendCondition)
[17:43:43.103]                     ns <- getNamespace("parallel")
[17:43:43.103]                     if (exists("sendData", mode = "function", 
[17:43:43.103]                       envir = ns)) {
[17:43:43.103]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:43.103]                         envir = ns)
[17:43:43.103]                       envir <- sys.frame(frame)
[17:43:43.103]                       master <- NULL
[17:43:43.103]                       while (!identical(envir, .GlobalEnv) && 
[17:43:43.103]                         !identical(envir, emptyenv())) {
[17:43:43.103]                         if (exists("master", mode = "list", envir = envir, 
[17:43:43.103]                           inherits = FALSE)) {
[17:43:43.103]                           master <- get("master", mode = "list", 
[17:43:43.103]                             envir = envir, inherits = FALSE)
[17:43:43.103]                           if (inherits(master, c("SOCKnode", 
[17:43:43.103]                             "SOCK0node"))) {
[17:43:43.103]                             sendCondition <<- function(cond) {
[17:43:43.103]                               data <- list(type = "VALUE", value = cond, 
[17:43:43.103]                                 success = TRUE)
[17:43:43.103]                               parallel_sendData(master, data)
[17:43:43.103]                             }
[17:43:43.103]                             return(sendCondition)
[17:43:43.103]                           }
[17:43:43.103]                         }
[17:43:43.103]                         frame <- frame + 1L
[17:43:43.103]                         envir <- sys.frame(frame)
[17:43:43.103]                       }
[17:43:43.103]                     }
[17:43:43.103]                     sendCondition <<- function(cond) NULL
[17:43:43.103]                   }
[17:43:43.103]                 })
[17:43:43.103]                 withCallingHandlers({
[17:43:43.103]                   {
[17:43:43.103]                     Sys.sleep(0.5)
[17:43:43.103]                     list(a = 1, b = 42L)
[17:43:43.103]                   }
[17:43:43.103]                 }, immediateCondition = function(cond) {
[17:43:43.103]                   sendCondition <- ...future.makeSendCondition()
[17:43:43.103]                   sendCondition(cond)
[17:43:43.103]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:43.103]                   {
[17:43:43.103]                     inherits <- base::inherits
[17:43:43.103]                     invokeRestart <- base::invokeRestart
[17:43:43.103]                     is.null <- base::is.null
[17:43:43.103]                     muffled <- FALSE
[17:43:43.103]                     if (inherits(cond, "message")) {
[17:43:43.103]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:43.103]                       if (muffled) 
[17:43:43.103]                         invokeRestart("muffleMessage")
[17:43:43.103]                     }
[17:43:43.103]                     else if (inherits(cond, "warning")) {
[17:43:43.103]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:43.103]                       if (muffled) 
[17:43:43.103]                         invokeRestart("muffleWarning")
[17:43:43.103]                     }
[17:43:43.103]                     else if (inherits(cond, "condition")) {
[17:43:43.103]                       if (!is.null(pattern)) {
[17:43:43.103]                         computeRestarts <- base::computeRestarts
[17:43:43.103]                         grepl <- base::grepl
[17:43:43.103]                         restarts <- computeRestarts(cond)
[17:43:43.103]                         for (restart in restarts) {
[17:43:43.103]                           name <- restart$name
[17:43:43.103]                           if (is.null(name)) 
[17:43:43.103]                             next
[17:43:43.103]                           if (!grepl(pattern, name)) 
[17:43:43.103]                             next
[17:43:43.103]                           invokeRestart(restart)
[17:43:43.103]                           muffled <- TRUE
[17:43:43.103]                           break
[17:43:43.103]                         }
[17:43:43.103]                       }
[17:43:43.103]                     }
[17:43:43.103]                     invisible(muffled)
[17:43:43.103]                   }
[17:43:43.103]                   muffleCondition(cond)
[17:43:43.103]                 })
[17:43:43.103]             }))
[17:43:43.103]             future::FutureResult(value = ...future.value$value, 
[17:43:43.103]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:43.103]                   ...future.rng), globalenv = if (FALSE) 
[17:43:43.103]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:43.103]                     ...future.globalenv.names))
[17:43:43.103]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:43.103]         }, condition = base::local({
[17:43:43.103]             c <- base::c
[17:43:43.103]             inherits <- base::inherits
[17:43:43.103]             invokeRestart <- base::invokeRestart
[17:43:43.103]             length <- base::length
[17:43:43.103]             list <- base::list
[17:43:43.103]             seq.int <- base::seq.int
[17:43:43.103]             signalCondition <- base::signalCondition
[17:43:43.103]             sys.calls <- base::sys.calls
[17:43:43.103]             `[[` <- base::`[[`
[17:43:43.103]             `+` <- base::`+`
[17:43:43.103]             `<<-` <- base::`<<-`
[17:43:43.103]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:43.103]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:43.103]                   3L)]
[17:43:43.103]             }
[17:43:43.103]             function(cond) {
[17:43:43.103]                 is_error <- inherits(cond, "error")
[17:43:43.103]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:43.103]                   NULL)
[17:43:43.103]                 if (is_error) {
[17:43:43.103]                   sessionInformation <- function() {
[17:43:43.103]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:43.103]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:43.103]                       search = base::search(), system = base::Sys.info())
[17:43:43.103]                   }
[17:43:43.103]                   ...future.conditions[[length(...future.conditions) + 
[17:43:43.103]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:43.103]                     cond$call), session = sessionInformation(), 
[17:43:43.103]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:43.103]                   signalCondition(cond)
[17:43:43.103]                 }
[17:43:43.103]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:43.103]                 "immediateCondition"))) {
[17:43:43.103]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:43.103]                   ...future.conditions[[length(...future.conditions) + 
[17:43:43.103]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:43.103]                   if (TRUE && !signal) {
[17:43:43.103]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:43.103]                     {
[17:43:43.103]                       inherits <- base::inherits
[17:43:43.103]                       invokeRestart <- base::invokeRestart
[17:43:43.103]                       is.null <- base::is.null
[17:43:43.103]                       muffled <- FALSE
[17:43:43.103]                       if (inherits(cond, "message")) {
[17:43:43.103]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:43.103]                         if (muffled) 
[17:43:43.103]                           invokeRestart("muffleMessage")
[17:43:43.103]                       }
[17:43:43.103]                       else if (inherits(cond, "warning")) {
[17:43:43.103]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:43.103]                         if (muffled) 
[17:43:43.103]                           invokeRestart("muffleWarning")
[17:43:43.103]                       }
[17:43:43.103]                       else if (inherits(cond, "condition")) {
[17:43:43.103]                         if (!is.null(pattern)) {
[17:43:43.103]                           computeRestarts <- base::computeRestarts
[17:43:43.103]                           grepl <- base::grepl
[17:43:43.103]                           restarts <- computeRestarts(cond)
[17:43:43.103]                           for (restart in restarts) {
[17:43:43.103]                             name <- restart$name
[17:43:43.103]                             if (is.null(name)) 
[17:43:43.103]                               next
[17:43:43.103]                             if (!grepl(pattern, name)) 
[17:43:43.103]                               next
[17:43:43.103]                             invokeRestart(restart)
[17:43:43.103]                             muffled <- TRUE
[17:43:43.103]                             break
[17:43:43.103]                           }
[17:43:43.103]                         }
[17:43:43.103]                       }
[17:43:43.103]                       invisible(muffled)
[17:43:43.103]                     }
[17:43:43.103]                     muffleCondition(cond, pattern = "^muffle")
[17:43:43.103]                   }
[17:43:43.103]                 }
[17:43:43.103]                 else {
[17:43:43.103]                   if (TRUE) {
[17:43:43.103]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:43.103]                     {
[17:43:43.103]                       inherits <- base::inherits
[17:43:43.103]                       invokeRestart <- base::invokeRestart
[17:43:43.103]                       is.null <- base::is.null
[17:43:43.103]                       muffled <- FALSE
[17:43:43.103]                       if (inherits(cond, "message")) {
[17:43:43.103]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:43.103]                         if (muffled) 
[17:43:43.103]                           invokeRestart("muffleMessage")
[17:43:43.103]                       }
[17:43:43.103]                       else if (inherits(cond, "warning")) {
[17:43:43.103]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:43.103]                         if (muffled) 
[17:43:43.103]                           invokeRestart("muffleWarning")
[17:43:43.103]                       }
[17:43:43.103]                       else if (inherits(cond, "condition")) {
[17:43:43.103]                         if (!is.null(pattern)) {
[17:43:43.103]                           computeRestarts <- base::computeRestarts
[17:43:43.103]                           grepl <- base::grepl
[17:43:43.103]                           restarts <- computeRestarts(cond)
[17:43:43.103]                           for (restart in restarts) {
[17:43:43.103]                             name <- restart$name
[17:43:43.103]                             if (is.null(name)) 
[17:43:43.103]                               next
[17:43:43.103]                             if (!grepl(pattern, name)) 
[17:43:43.103]                               next
[17:43:43.103]                             invokeRestart(restart)
[17:43:43.103]                             muffled <- TRUE
[17:43:43.103]                             break
[17:43:43.103]                           }
[17:43:43.103]                         }
[17:43:43.103]                       }
[17:43:43.103]                       invisible(muffled)
[17:43:43.103]                     }
[17:43:43.103]                     muffleCondition(cond, pattern = "^muffle")
[17:43:43.103]                   }
[17:43:43.103]                 }
[17:43:43.103]             }
[17:43:43.103]         }))
[17:43:43.103]     }, error = function(ex) {
[17:43:43.103]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:43.103]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:43.103]                 ...future.rng), started = ...future.startTime, 
[17:43:43.103]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:43.103]             version = "1.8"), class = "FutureResult")
[17:43:43.103]     }, finally = {
[17:43:43.103]         if (!identical(...future.workdir, getwd())) 
[17:43:43.103]             setwd(...future.workdir)
[17:43:43.103]         {
[17:43:43.103]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:43.103]                 ...future.oldOptions$nwarnings <- NULL
[17:43:43.103]             }
[17:43:43.103]             base::options(...future.oldOptions)
[17:43:43.103]             if (.Platform$OS.type == "windows") {
[17:43:43.103]                 old_names <- names(...future.oldEnvVars)
[17:43:43.103]                 envs <- base::Sys.getenv()
[17:43:43.103]                 names <- names(envs)
[17:43:43.103]                 common <- intersect(names, old_names)
[17:43:43.103]                 added <- setdiff(names, old_names)
[17:43:43.103]                 removed <- setdiff(old_names, names)
[17:43:43.103]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:43.103]                   envs[common]]
[17:43:43.103]                 NAMES <- toupper(changed)
[17:43:43.103]                 args <- list()
[17:43:43.103]                 for (kk in seq_along(NAMES)) {
[17:43:43.103]                   name <- changed[[kk]]
[17:43:43.103]                   NAME <- NAMES[[kk]]
[17:43:43.103]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:43.103]                     next
[17:43:43.103]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:43.103]                 }
[17:43:43.103]                 NAMES <- toupper(added)
[17:43:43.103]                 for (kk in seq_along(NAMES)) {
[17:43:43.103]                   name <- added[[kk]]
[17:43:43.103]                   NAME <- NAMES[[kk]]
[17:43:43.103]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:43.103]                     next
[17:43:43.103]                   args[[name]] <- ""
[17:43:43.103]                 }
[17:43:43.103]                 NAMES <- toupper(removed)
[17:43:43.103]                 for (kk in seq_along(NAMES)) {
[17:43:43.103]                   name <- removed[[kk]]
[17:43:43.103]                   NAME <- NAMES[[kk]]
[17:43:43.103]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:43.103]                     next
[17:43:43.103]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:43.103]                 }
[17:43:43.103]                 if (length(args) > 0) 
[17:43:43.103]                   base::do.call(base::Sys.setenv, args = args)
[17:43:43.103]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:43.103]             }
[17:43:43.103]             else {
[17:43:43.103]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:43.103]             }
[17:43:43.103]             {
[17:43:43.103]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:43.103]                   0L) {
[17:43:43.103]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:43.103]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:43.103]                   base::options(opts)
[17:43:43.103]                 }
[17:43:43.103]                 {
[17:43:43.103]                   {
[17:43:43.103]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:43.103]                     NULL
[17:43:43.103]                   }
[17:43:43.103]                   options(future.plan = NULL)
[17:43:43.103]                   if (is.na(NA_character_)) 
[17:43:43.103]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:43.103]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:43.103]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:43.103]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:43.103]                     envir = parent.frame()) 
[17:43:43.103]                   {
[17:43:43.103]                     if (is.function(workers)) 
[17:43:43.103]                       workers <- workers()
[17:43:43.103]                     workers <- structure(as.integer(workers), 
[17:43:43.103]                       class = class(workers))
[17:43:43.103]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:43.103]                       workers >= 1)
[17:43:43.103]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:43.103]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:43.103]                     }
[17:43:43.103]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:43.103]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:43.103]                       envir = envir)
[17:43:43.103]                     if (!future$lazy) 
[17:43:43.103]                       future <- run(future)
[17:43:43.103]                     invisible(future)
[17:43:43.103]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:43.103]                 }
[17:43:43.103]             }
[17:43:43.103]         }
[17:43:43.103]     })
[17:43:43.103]     if (TRUE) {
[17:43:43.103]         base::sink(type = "output", split = FALSE)
[17:43:43.103]         if (TRUE) {
[17:43:43.103]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:43.103]         }
[17:43:43.103]         else {
[17:43:43.103]             ...future.result["stdout"] <- base::list(NULL)
[17:43:43.103]         }
[17:43:43.103]         base::close(...future.stdout)
[17:43:43.103]         ...future.stdout <- NULL
[17:43:43.103]     }
[17:43:43.103]     ...future.result$conditions <- ...future.conditions
[17:43:43.103]     ...future.result$finished <- base::Sys.time()
[17:43:43.103]     ...future.result
[17:43:43.103] }
[17:43:43.106] MultisessionFuture started
[17:43:43.106] - Launch lazy future ... done
[17:43:43.106] run() for ‘MultisessionFuture’ ... done
[17:43:43.666] receiveMessageFromWorker() for ClusterFuture ...
[17:43:43.666] - Validating connection of MultisessionFuture
[17:43:43.666] - received message: FutureResult
[17:43:43.666] - Received FutureResult
[17:43:43.666] - Erased future from FutureRegistry
[17:43:43.667] result() for ClusterFuture ...
[17:43:43.667] - result already collected: FutureResult
[17:43:43.667] result() for ClusterFuture ... done
[17:43:43.667] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:43.667] A MultisessionFuture was resolved (result was not collected)
[17:43:43.667] getGlobalsAndPackages() ...
[17:43:43.667] Searching for globals...
[17:43:43.668] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:43:43.669] Searching for globals ... DONE
[17:43:43.669] Resolving globals: FALSE
[17:43:43.669] 
[17:43:43.669] 
[17:43:43.669] getGlobalsAndPackages() ... DONE
[17:43:43.669] run() for ‘Future’ ...
[17:43:43.670] - state: ‘created’
[17:43:43.670] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:43.685] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:43.685] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:43.685]   - Field: ‘node’
[17:43:43.685]   - Field: ‘label’
[17:43:43.685]   - Field: ‘local’
[17:43:43.686]   - Field: ‘owner’
[17:43:43.686]   - Field: ‘envir’
[17:43:43.686]   - Field: ‘workers’
[17:43:43.686]   - Field: ‘packages’
[17:43:43.686]   - Field: ‘gc’
[17:43:43.686]   - Field: ‘conditions’
[17:43:43.686]   - Field: ‘persistent’
[17:43:43.686]   - Field: ‘expr’
[17:43:43.686]   - Field: ‘uuid’
[17:43:43.686]   - Field: ‘seed’
[17:43:43.687]   - Field: ‘version’
[17:43:43.687]   - Field: ‘result’
[17:43:43.687]   - Field: ‘asynchronous’
[17:43:43.687]   - Field: ‘calls’
[17:43:43.687]   - Field: ‘globals’
[17:43:43.687]   - Field: ‘stdout’
[17:43:43.687]   - Field: ‘earlySignal’
[17:43:43.687]   - Field: ‘lazy’
[17:43:43.687]   - Field: ‘state’
[17:43:43.687] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:43.688] - Launch lazy future ...
[17:43:43.688] Packages needed by the future expression (n = 0): <none>
[17:43:43.688] Packages needed by future strategies (n = 0): <none>
[17:43:43.688] {
[17:43:43.688]     {
[17:43:43.688]         {
[17:43:43.688]             ...future.startTime <- base::Sys.time()
[17:43:43.688]             {
[17:43:43.688]                 {
[17:43:43.688]                   {
[17:43:43.688]                     {
[17:43:43.688]                       base::local({
[17:43:43.688]                         has_future <- base::requireNamespace("future", 
[17:43:43.688]                           quietly = TRUE)
[17:43:43.688]                         if (has_future) {
[17:43:43.688]                           ns <- base::getNamespace("future")
[17:43:43.688]                           version <- ns[[".package"]][["version"]]
[17:43:43.688]                           if (is.null(version)) 
[17:43:43.688]                             version <- utils::packageVersion("future")
[17:43:43.688]                         }
[17:43:43.688]                         else {
[17:43:43.688]                           version <- NULL
[17:43:43.688]                         }
[17:43:43.688]                         if (!has_future || version < "1.8.0") {
[17:43:43.688]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:43.688]                             "", base::R.version$version.string), 
[17:43:43.688]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:43.688]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:43.688]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:43.688]                               "release", "version")], collapse = " "), 
[17:43:43.688]                             hostname = base::Sys.info()[["nodename"]])
[17:43:43.688]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:43.688]                             info)
[17:43:43.688]                           info <- base::paste(info, collapse = "; ")
[17:43:43.688]                           if (!has_future) {
[17:43:43.688]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:43.688]                               info)
[17:43:43.688]                           }
[17:43:43.688]                           else {
[17:43:43.688]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:43.688]                               info, version)
[17:43:43.688]                           }
[17:43:43.688]                           base::stop(msg)
[17:43:43.688]                         }
[17:43:43.688]                       })
[17:43:43.688]                     }
[17:43:43.688]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:43.688]                     base::options(mc.cores = 1L)
[17:43:43.688]                   }
[17:43:43.688]                   options(future.plan = NULL)
[17:43:43.688]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:43.688]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:43.688]                 }
[17:43:43.688]                 ...future.workdir <- getwd()
[17:43:43.688]             }
[17:43:43.688]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:43.688]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:43.688]         }
[17:43:43.688]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:43.688]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:43.688]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:43.688]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:43.688]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:43.688]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:43.688]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:43.688]             base::names(...future.oldOptions))
[17:43:43.688]     }
[17:43:43.688]     if (FALSE) {
[17:43:43.688]     }
[17:43:43.688]     else {
[17:43:43.688]         if (TRUE) {
[17:43:43.688]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:43.688]                 open = "w")
[17:43:43.688]         }
[17:43:43.688]         else {
[17:43:43.688]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:43.688]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:43.688]         }
[17:43:43.688]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:43.688]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:43.688]             base::sink(type = "output", split = FALSE)
[17:43:43.688]             base::close(...future.stdout)
[17:43:43.688]         }, add = TRUE)
[17:43:43.688]     }
[17:43:43.688]     ...future.frame <- base::sys.nframe()
[17:43:43.688]     ...future.conditions <- base::list()
[17:43:43.688]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:43.688]     if (FALSE) {
[17:43:43.688]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:43.688]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:43.688]     }
[17:43:43.688]     ...future.result <- base::tryCatch({
[17:43:43.688]         base::withCallingHandlers({
[17:43:43.688]             ...future.value <- base::withVisible(base::local({
[17:43:43.688]                 ...future.makeSendCondition <- local({
[17:43:43.688]                   sendCondition <- NULL
[17:43:43.688]                   function(frame = 1L) {
[17:43:43.688]                     if (is.function(sendCondition)) 
[17:43:43.688]                       return(sendCondition)
[17:43:43.688]                     ns <- getNamespace("parallel")
[17:43:43.688]                     if (exists("sendData", mode = "function", 
[17:43:43.688]                       envir = ns)) {
[17:43:43.688]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:43.688]                         envir = ns)
[17:43:43.688]                       envir <- sys.frame(frame)
[17:43:43.688]                       master <- NULL
[17:43:43.688]                       while (!identical(envir, .GlobalEnv) && 
[17:43:43.688]                         !identical(envir, emptyenv())) {
[17:43:43.688]                         if (exists("master", mode = "list", envir = envir, 
[17:43:43.688]                           inherits = FALSE)) {
[17:43:43.688]                           master <- get("master", mode = "list", 
[17:43:43.688]                             envir = envir, inherits = FALSE)
[17:43:43.688]                           if (inherits(master, c("SOCKnode", 
[17:43:43.688]                             "SOCK0node"))) {
[17:43:43.688]                             sendCondition <<- function(cond) {
[17:43:43.688]                               data <- list(type = "VALUE", value = cond, 
[17:43:43.688]                                 success = TRUE)
[17:43:43.688]                               parallel_sendData(master, data)
[17:43:43.688]                             }
[17:43:43.688]                             return(sendCondition)
[17:43:43.688]                           }
[17:43:43.688]                         }
[17:43:43.688]                         frame <- frame + 1L
[17:43:43.688]                         envir <- sys.frame(frame)
[17:43:43.688]                       }
[17:43:43.688]                     }
[17:43:43.688]                     sendCondition <<- function(cond) NULL
[17:43:43.688]                   }
[17:43:43.688]                 })
[17:43:43.688]                 withCallingHandlers({
[17:43:43.688]                   {
[17:43:43.688]                     Sys.sleep(0.5)
[17:43:43.688]                     list(a = 1, b = 42L)
[17:43:43.688]                   }
[17:43:43.688]                 }, immediateCondition = function(cond) {
[17:43:43.688]                   sendCondition <- ...future.makeSendCondition()
[17:43:43.688]                   sendCondition(cond)
[17:43:43.688]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:43.688]                   {
[17:43:43.688]                     inherits <- base::inherits
[17:43:43.688]                     invokeRestart <- base::invokeRestart
[17:43:43.688]                     is.null <- base::is.null
[17:43:43.688]                     muffled <- FALSE
[17:43:43.688]                     if (inherits(cond, "message")) {
[17:43:43.688]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:43.688]                       if (muffled) 
[17:43:43.688]                         invokeRestart("muffleMessage")
[17:43:43.688]                     }
[17:43:43.688]                     else if (inherits(cond, "warning")) {
[17:43:43.688]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:43.688]                       if (muffled) 
[17:43:43.688]                         invokeRestart("muffleWarning")
[17:43:43.688]                     }
[17:43:43.688]                     else if (inherits(cond, "condition")) {
[17:43:43.688]                       if (!is.null(pattern)) {
[17:43:43.688]                         computeRestarts <- base::computeRestarts
[17:43:43.688]                         grepl <- base::grepl
[17:43:43.688]                         restarts <- computeRestarts(cond)
[17:43:43.688]                         for (restart in restarts) {
[17:43:43.688]                           name <- restart$name
[17:43:43.688]                           if (is.null(name)) 
[17:43:43.688]                             next
[17:43:43.688]                           if (!grepl(pattern, name)) 
[17:43:43.688]                             next
[17:43:43.688]                           invokeRestart(restart)
[17:43:43.688]                           muffled <- TRUE
[17:43:43.688]                           break
[17:43:43.688]                         }
[17:43:43.688]                       }
[17:43:43.688]                     }
[17:43:43.688]                     invisible(muffled)
[17:43:43.688]                   }
[17:43:43.688]                   muffleCondition(cond)
[17:43:43.688]                 })
[17:43:43.688]             }))
[17:43:43.688]             future::FutureResult(value = ...future.value$value, 
[17:43:43.688]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:43.688]                   ...future.rng), globalenv = if (FALSE) 
[17:43:43.688]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:43.688]                     ...future.globalenv.names))
[17:43:43.688]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:43.688]         }, condition = base::local({
[17:43:43.688]             c <- base::c
[17:43:43.688]             inherits <- base::inherits
[17:43:43.688]             invokeRestart <- base::invokeRestart
[17:43:43.688]             length <- base::length
[17:43:43.688]             list <- base::list
[17:43:43.688]             seq.int <- base::seq.int
[17:43:43.688]             signalCondition <- base::signalCondition
[17:43:43.688]             sys.calls <- base::sys.calls
[17:43:43.688]             `[[` <- base::`[[`
[17:43:43.688]             `+` <- base::`+`
[17:43:43.688]             `<<-` <- base::`<<-`
[17:43:43.688]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:43.688]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:43.688]                   3L)]
[17:43:43.688]             }
[17:43:43.688]             function(cond) {
[17:43:43.688]                 is_error <- inherits(cond, "error")
[17:43:43.688]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:43.688]                   NULL)
[17:43:43.688]                 if (is_error) {
[17:43:43.688]                   sessionInformation <- function() {
[17:43:43.688]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:43.688]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:43.688]                       search = base::search(), system = base::Sys.info())
[17:43:43.688]                   }
[17:43:43.688]                   ...future.conditions[[length(...future.conditions) + 
[17:43:43.688]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:43.688]                     cond$call), session = sessionInformation(), 
[17:43:43.688]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:43.688]                   signalCondition(cond)
[17:43:43.688]                 }
[17:43:43.688]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:43.688]                 "immediateCondition"))) {
[17:43:43.688]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:43.688]                   ...future.conditions[[length(...future.conditions) + 
[17:43:43.688]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:43.688]                   if (TRUE && !signal) {
[17:43:43.688]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:43.688]                     {
[17:43:43.688]                       inherits <- base::inherits
[17:43:43.688]                       invokeRestart <- base::invokeRestart
[17:43:43.688]                       is.null <- base::is.null
[17:43:43.688]                       muffled <- FALSE
[17:43:43.688]                       if (inherits(cond, "message")) {
[17:43:43.688]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:43.688]                         if (muffled) 
[17:43:43.688]                           invokeRestart("muffleMessage")
[17:43:43.688]                       }
[17:43:43.688]                       else if (inherits(cond, "warning")) {
[17:43:43.688]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:43.688]                         if (muffled) 
[17:43:43.688]                           invokeRestart("muffleWarning")
[17:43:43.688]                       }
[17:43:43.688]                       else if (inherits(cond, "condition")) {
[17:43:43.688]                         if (!is.null(pattern)) {
[17:43:43.688]                           computeRestarts <- base::computeRestarts
[17:43:43.688]                           grepl <- base::grepl
[17:43:43.688]                           restarts <- computeRestarts(cond)
[17:43:43.688]                           for (restart in restarts) {
[17:43:43.688]                             name <- restart$name
[17:43:43.688]                             if (is.null(name)) 
[17:43:43.688]                               next
[17:43:43.688]                             if (!grepl(pattern, name)) 
[17:43:43.688]                               next
[17:43:43.688]                             invokeRestart(restart)
[17:43:43.688]                             muffled <- TRUE
[17:43:43.688]                             break
[17:43:43.688]                           }
[17:43:43.688]                         }
[17:43:43.688]                       }
[17:43:43.688]                       invisible(muffled)
[17:43:43.688]                     }
[17:43:43.688]                     muffleCondition(cond, pattern = "^muffle")
[17:43:43.688]                   }
[17:43:43.688]                 }
[17:43:43.688]                 else {
[17:43:43.688]                   if (TRUE) {
[17:43:43.688]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:43.688]                     {
[17:43:43.688]                       inherits <- base::inherits
[17:43:43.688]                       invokeRestart <- base::invokeRestart
[17:43:43.688]                       is.null <- base::is.null
[17:43:43.688]                       muffled <- FALSE
[17:43:43.688]                       if (inherits(cond, "message")) {
[17:43:43.688]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:43.688]                         if (muffled) 
[17:43:43.688]                           invokeRestart("muffleMessage")
[17:43:43.688]                       }
[17:43:43.688]                       else if (inherits(cond, "warning")) {
[17:43:43.688]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:43.688]                         if (muffled) 
[17:43:43.688]                           invokeRestart("muffleWarning")
[17:43:43.688]                       }
[17:43:43.688]                       else if (inherits(cond, "condition")) {
[17:43:43.688]                         if (!is.null(pattern)) {
[17:43:43.688]                           computeRestarts <- base::computeRestarts
[17:43:43.688]                           grepl <- base::grepl
[17:43:43.688]                           restarts <- computeRestarts(cond)
[17:43:43.688]                           for (restart in restarts) {
[17:43:43.688]                             name <- restart$name
[17:43:43.688]                             if (is.null(name)) 
[17:43:43.688]                               next
[17:43:43.688]                             if (!grepl(pattern, name)) 
[17:43:43.688]                               next
[17:43:43.688]                             invokeRestart(restart)
[17:43:43.688]                             muffled <- TRUE
[17:43:43.688]                             break
[17:43:43.688]                           }
[17:43:43.688]                         }
[17:43:43.688]                       }
[17:43:43.688]                       invisible(muffled)
[17:43:43.688]                     }
[17:43:43.688]                     muffleCondition(cond, pattern = "^muffle")
[17:43:43.688]                   }
[17:43:43.688]                 }
[17:43:43.688]             }
[17:43:43.688]         }))
[17:43:43.688]     }, error = function(ex) {
[17:43:43.688]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:43.688]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:43.688]                 ...future.rng), started = ...future.startTime, 
[17:43:43.688]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:43.688]             version = "1.8"), class = "FutureResult")
[17:43:43.688]     }, finally = {
[17:43:43.688]         if (!identical(...future.workdir, getwd())) 
[17:43:43.688]             setwd(...future.workdir)
[17:43:43.688]         {
[17:43:43.688]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:43.688]                 ...future.oldOptions$nwarnings <- NULL
[17:43:43.688]             }
[17:43:43.688]             base::options(...future.oldOptions)
[17:43:43.688]             if (.Platform$OS.type == "windows") {
[17:43:43.688]                 old_names <- names(...future.oldEnvVars)
[17:43:43.688]                 envs <- base::Sys.getenv()
[17:43:43.688]                 names <- names(envs)
[17:43:43.688]                 common <- intersect(names, old_names)
[17:43:43.688]                 added <- setdiff(names, old_names)
[17:43:43.688]                 removed <- setdiff(old_names, names)
[17:43:43.688]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:43.688]                   envs[common]]
[17:43:43.688]                 NAMES <- toupper(changed)
[17:43:43.688]                 args <- list()
[17:43:43.688]                 for (kk in seq_along(NAMES)) {
[17:43:43.688]                   name <- changed[[kk]]
[17:43:43.688]                   NAME <- NAMES[[kk]]
[17:43:43.688]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:43.688]                     next
[17:43:43.688]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:43.688]                 }
[17:43:43.688]                 NAMES <- toupper(added)
[17:43:43.688]                 for (kk in seq_along(NAMES)) {
[17:43:43.688]                   name <- added[[kk]]
[17:43:43.688]                   NAME <- NAMES[[kk]]
[17:43:43.688]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:43.688]                     next
[17:43:43.688]                   args[[name]] <- ""
[17:43:43.688]                 }
[17:43:43.688]                 NAMES <- toupper(removed)
[17:43:43.688]                 for (kk in seq_along(NAMES)) {
[17:43:43.688]                   name <- removed[[kk]]
[17:43:43.688]                   NAME <- NAMES[[kk]]
[17:43:43.688]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:43.688]                     next
[17:43:43.688]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:43.688]                 }
[17:43:43.688]                 if (length(args) > 0) 
[17:43:43.688]                   base::do.call(base::Sys.setenv, args = args)
[17:43:43.688]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:43.688]             }
[17:43:43.688]             else {
[17:43:43.688]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:43.688]             }
[17:43:43.688]             {
[17:43:43.688]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:43.688]                   0L) {
[17:43:43.688]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:43.688]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:43.688]                   base::options(opts)
[17:43:43.688]                 }
[17:43:43.688]                 {
[17:43:43.688]                   {
[17:43:43.688]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:43.688]                     NULL
[17:43:43.688]                   }
[17:43:43.688]                   options(future.plan = NULL)
[17:43:43.688]                   if (is.na(NA_character_)) 
[17:43:43.688]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:43.688]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:43.688]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:43.688]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:43.688]                     envir = parent.frame()) 
[17:43:43.688]                   {
[17:43:43.688]                     if (is.function(workers)) 
[17:43:43.688]                       workers <- workers()
[17:43:43.688]                     workers <- structure(as.integer(workers), 
[17:43:43.688]                       class = class(workers))
[17:43:43.688]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:43.688]                       workers >= 1)
[17:43:43.688]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:43.688]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:43.688]                     }
[17:43:43.688]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:43.688]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:43.688]                       envir = envir)
[17:43:43.688]                     if (!future$lazy) 
[17:43:43.688]                       future <- run(future)
[17:43:43.688]                     invisible(future)
[17:43:43.688]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:43.688]                 }
[17:43:43.688]             }
[17:43:43.688]         }
[17:43:43.688]     })
[17:43:43.688]     if (TRUE) {
[17:43:43.688]         base::sink(type = "output", split = FALSE)
[17:43:43.688]         if (TRUE) {
[17:43:43.688]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:43.688]         }
[17:43:43.688]         else {
[17:43:43.688]             ...future.result["stdout"] <- base::list(NULL)
[17:43:43.688]         }
[17:43:43.688]         base::close(...future.stdout)
[17:43:43.688]         ...future.stdout <- NULL
[17:43:43.688]     }
[17:43:43.688]     ...future.result$conditions <- ...future.conditions
[17:43:43.688]     ...future.result$finished <- base::Sys.time()
[17:43:43.688]     ...future.result
[17:43:43.688] }
[17:43:43.692] MultisessionFuture started
[17:43:43.692] - Launch lazy future ... done
[17:43:43.692] run() for ‘MultisessionFuture’ ... done
[17:43:44.241] receiveMessageFromWorker() for ClusterFuture ...
[17:43:44.241] - Validating connection of MultisessionFuture
[17:43:44.242] - received message: FutureResult
[17:43:44.242] - Received FutureResult
[17:43:44.242] - Erased future from FutureRegistry
[17:43:44.242] result() for ClusterFuture ...
[17:43:44.242] - result already collected: FutureResult
[17:43:44.242] result() for ClusterFuture ... done
[17:43:44.242] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:44.242] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[17:43:44.243] getGlobalsAndPackages() ...
[17:43:44.243] Searching for globals...
[17:43:44.243] - globals found: [2] ‘list’, ‘stop’
[17:43:44.244] Searching for globals ... DONE
[17:43:44.244] Resolving globals: FALSE
[17:43:44.244] 
[17:43:44.244] 
[17:43:44.244] getGlobalsAndPackages() ... DONE
[17:43:44.244] run() for ‘Future’ ...
[17:43:44.245] - state: ‘created’
[17:43:44.245] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:44.259] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:44.259] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:44.259]   - Field: ‘node’
[17:43:44.259]   - Field: ‘label’
[17:43:44.259]   - Field: ‘local’
[17:43:44.260]   - Field: ‘owner’
[17:43:44.260]   - Field: ‘envir’
[17:43:44.260]   - Field: ‘workers’
[17:43:44.260]   - Field: ‘packages’
[17:43:44.260]   - Field: ‘gc’
[17:43:44.260]   - Field: ‘conditions’
[17:43:44.260]   - Field: ‘persistent’
[17:43:44.260]   - Field: ‘expr’
[17:43:44.260]   - Field: ‘uuid’
[17:43:44.260]   - Field: ‘seed’
[17:43:44.260]   - Field: ‘version’
[17:43:44.261]   - Field: ‘result’
[17:43:44.261]   - Field: ‘asynchronous’
[17:43:44.261]   - Field: ‘calls’
[17:43:44.261]   - Field: ‘globals’
[17:43:44.261]   - Field: ‘stdout’
[17:43:44.261]   - Field: ‘earlySignal’
[17:43:44.261]   - Field: ‘lazy’
[17:43:44.261]   - Field: ‘state’
[17:43:44.261] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:44.261] - Launch lazy future ...
[17:43:44.262] Packages needed by the future expression (n = 0): <none>
[17:43:44.262] Packages needed by future strategies (n = 0): <none>
[17:43:44.262] {
[17:43:44.262]     {
[17:43:44.262]         {
[17:43:44.262]             ...future.startTime <- base::Sys.time()
[17:43:44.262]             {
[17:43:44.262]                 {
[17:43:44.262]                   {
[17:43:44.262]                     {
[17:43:44.262]                       base::local({
[17:43:44.262]                         has_future <- base::requireNamespace("future", 
[17:43:44.262]                           quietly = TRUE)
[17:43:44.262]                         if (has_future) {
[17:43:44.262]                           ns <- base::getNamespace("future")
[17:43:44.262]                           version <- ns[[".package"]][["version"]]
[17:43:44.262]                           if (is.null(version)) 
[17:43:44.262]                             version <- utils::packageVersion("future")
[17:43:44.262]                         }
[17:43:44.262]                         else {
[17:43:44.262]                           version <- NULL
[17:43:44.262]                         }
[17:43:44.262]                         if (!has_future || version < "1.8.0") {
[17:43:44.262]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:44.262]                             "", base::R.version$version.string), 
[17:43:44.262]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:44.262]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:44.262]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:44.262]                               "release", "version")], collapse = " "), 
[17:43:44.262]                             hostname = base::Sys.info()[["nodename"]])
[17:43:44.262]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:44.262]                             info)
[17:43:44.262]                           info <- base::paste(info, collapse = "; ")
[17:43:44.262]                           if (!has_future) {
[17:43:44.262]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:44.262]                               info)
[17:43:44.262]                           }
[17:43:44.262]                           else {
[17:43:44.262]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:44.262]                               info, version)
[17:43:44.262]                           }
[17:43:44.262]                           base::stop(msg)
[17:43:44.262]                         }
[17:43:44.262]                       })
[17:43:44.262]                     }
[17:43:44.262]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:44.262]                     base::options(mc.cores = 1L)
[17:43:44.262]                   }
[17:43:44.262]                   options(future.plan = NULL)
[17:43:44.262]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:44.262]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:44.262]                 }
[17:43:44.262]                 ...future.workdir <- getwd()
[17:43:44.262]             }
[17:43:44.262]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:44.262]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:44.262]         }
[17:43:44.262]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:44.262]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:44.262]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:44.262]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:44.262]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:44.262]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:44.262]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:44.262]             base::names(...future.oldOptions))
[17:43:44.262]     }
[17:43:44.262]     if (FALSE) {
[17:43:44.262]     }
[17:43:44.262]     else {
[17:43:44.262]         if (TRUE) {
[17:43:44.262]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:44.262]                 open = "w")
[17:43:44.262]         }
[17:43:44.262]         else {
[17:43:44.262]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:44.262]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:44.262]         }
[17:43:44.262]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:44.262]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:44.262]             base::sink(type = "output", split = FALSE)
[17:43:44.262]             base::close(...future.stdout)
[17:43:44.262]         }, add = TRUE)
[17:43:44.262]     }
[17:43:44.262]     ...future.frame <- base::sys.nframe()
[17:43:44.262]     ...future.conditions <- base::list()
[17:43:44.262]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:44.262]     if (FALSE) {
[17:43:44.262]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:44.262]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:44.262]     }
[17:43:44.262]     ...future.result <- base::tryCatch({
[17:43:44.262]         base::withCallingHandlers({
[17:43:44.262]             ...future.value <- base::withVisible(base::local({
[17:43:44.262]                 ...future.makeSendCondition <- local({
[17:43:44.262]                   sendCondition <- NULL
[17:43:44.262]                   function(frame = 1L) {
[17:43:44.262]                     if (is.function(sendCondition)) 
[17:43:44.262]                       return(sendCondition)
[17:43:44.262]                     ns <- getNamespace("parallel")
[17:43:44.262]                     if (exists("sendData", mode = "function", 
[17:43:44.262]                       envir = ns)) {
[17:43:44.262]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:44.262]                         envir = ns)
[17:43:44.262]                       envir <- sys.frame(frame)
[17:43:44.262]                       master <- NULL
[17:43:44.262]                       while (!identical(envir, .GlobalEnv) && 
[17:43:44.262]                         !identical(envir, emptyenv())) {
[17:43:44.262]                         if (exists("master", mode = "list", envir = envir, 
[17:43:44.262]                           inherits = FALSE)) {
[17:43:44.262]                           master <- get("master", mode = "list", 
[17:43:44.262]                             envir = envir, inherits = FALSE)
[17:43:44.262]                           if (inherits(master, c("SOCKnode", 
[17:43:44.262]                             "SOCK0node"))) {
[17:43:44.262]                             sendCondition <<- function(cond) {
[17:43:44.262]                               data <- list(type = "VALUE", value = cond, 
[17:43:44.262]                                 success = TRUE)
[17:43:44.262]                               parallel_sendData(master, data)
[17:43:44.262]                             }
[17:43:44.262]                             return(sendCondition)
[17:43:44.262]                           }
[17:43:44.262]                         }
[17:43:44.262]                         frame <- frame + 1L
[17:43:44.262]                         envir <- sys.frame(frame)
[17:43:44.262]                       }
[17:43:44.262]                     }
[17:43:44.262]                     sendCondition <<- function(cond) NULL
[17:43:44.262]                   }
[17:43:44.262]                 })
[17:43:44.262]                 withCallingHandlers({
[17:43:44.262]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:43:44.262]                 }, immediateCondition = function(cond) {
[17:43:44.262]                   sendCondition <- ...future.makeSendCondition()
[17:43:44.262]                   sendCondition(cond)
[17:43:44.262]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:44.262]                   {
[17:43:44.262]                     inherits <- base::inherits
[17:43:44.262]                     invokeRestart <- base::invokeRestart
[17:43:44.262]                     is.null <- base::is.null
[17:43:44.262]                     muffled <- FALSE
[17:43:44.262]                     if (inherits(cond, "message")) {
[17:43:44.262]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:44.262]                       if (muffled) 
[17:43:44.262]                         invokeRestart("muffleMessage")
[17:43:44.262]                     }
[17:43:44.262]                     else if (inherits(cond, "warning")) {
[17:43:44.262]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:44.262]                       if (muffled) 
[17:43:44.262]                         invokeRestart("muffleWarning")
[17:43:44.262]                     }
[17:43:44.262]                     else if (inherits(cond, "condition")) {
[17:43:44.262]                       if (!is.null(pattern)) {
[17:43:44.262]                         computeRestarts <- base::computeRestarts
[17:43:44.262]                         grepl <- base::grepl
[17:43:44.262]                         restarts <- computeRestarts(cond)
[17:43:44.262]                         for (restart in restarts) {
[17:43:44.262]                           name <- restart$name
[17:43:44.262]                           if (is.null(name)) 
[17:43:44.262]                             next
[17:43:44.262]                           if (!grepl(pattern, name)) 
[17:43:44.262]                             next
[17:43:44.262]                           invokeRestart(restart)
[17:43:44.262]                           muffled <- TRUE
[17:43:44.262]                           break
[17:43:44.262]                         }
[17:43:44.262]                       }
[17:43:44.262]                     }
[17:43:44.262]                     invisible(muffled)
[17:43:44.262]                   }
[17:43:44.262]                   muffleCondition(cond)
[17:43:44.262]                 })
[17:43:44.262]             }))
[17:43:44.262]             future::FutureResult(value = ...future.value$value, 
[17:43:44.262]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:44.262]                   ...future.rng), globalenv = if (FALSE) 
[17:43:44.262]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:44.262]                     ...future.globalenv.names))
[17:43:44.262]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:44.262]         }, condition = base::local({
[17:43:44.262]             c <- base::c
[17:43:44.262]             inherits <- base::inherits
[17:43:44.262]             invokeRestart <- base::invokeRestart
[17:43:44.262]             length <- base::length
[17:43:44.262]             list <- base::list
[17:43:44.262]             seq.int <- base::seq.int
[17:43:44.262]             signalCondition <- base::signalCondition
[17:43:44.262]             sys.calls <- base::sys.calls
[17:43:44.262]             `[[` <- base::`[[`
[17:43:44.262]             `+` <- base::`+`
[17:43:44.262]             `<<-` <- base::`<<-`
[17:43:44.262]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:44.262]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:44.262]                   3L)]
[17:43:44.262]             }
[17:43:44.262]             function(cond) {
[17:43:44.262]                 is_error <- inherits(cond, "error")
[17:43:44.262]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:44.262]                   NULL)
[17:43:44.262]                 if (is_error) {
[17:43:44.262]                   sessionInformation <- function() {
[17:43:44.262]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:44.262]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:44.262]                       search = base::search(), system = base::Sys.info())
[17:43:44.262]                   }
[17:43:44.262]                   ...future.conditions[[length(...future.conditions) + 
[17:43:44.262]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:44.262]                     cond$call), session = sessionInformation(), 
[17:43:44.262]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:44.262]                   signalCondition(cond)
[17:43:44.262]                 }
[17:43:44.262]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:44.262]                 "immediateCondition"))) {
[17:43:44.262]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:44.262]                   ...future.conditions[[length(...future.conditions) + 
[17:43:44.262]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:44.262]                   if (TRUE && !signal) {
[17:43:44.262]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:44.262]                     {
[17:43:44.262]                       inherits <- base::inherits
[17:43:44.262]                       invokeRestart <- base::invokeRestart
[17:43:44.262]                       is.null <- base::is.null
[17:43:44.262]                       muffled <- FALSE
[17:43:44.262]                       if (inherits(cond, "message")) {
[17:43:44.262]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:44.262]                         if (muffled) 
[17:43:44.262]                           invokeRestart("muffleMessage")
[17:43:44.262]                       }
[17:43:44.262]                       else if (inherits(cond, "warning")) {
[17:43:44.262]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:44.262]                         if (muffled) 
[17:43:44.262]                           invokeRestart("muffleWarning")
[17:43:44.262]                       }
[17:43:44.262]                       else if (inherits(cond, "condition")) {
[17:43:44.262]                         if (!is.null(pattern)) {
[17:43:44.262]                           computeRestarts <- base::computeRestarts
[17:43:44.262]                           grepl <- base::grepl
[17:43:44.262]                           restarts <- computeRestarts(cond)
[17:43:44.262]                           for (restart in restarts) {
[17:43:44.262]                             name <- restart$name
[17:43:44.262]                             if (is.null(name)) 
[17:43:44.262]                               next
[17:43:44.262]                             if (!grepl(pattern, name)) 
[17:43:44.262]                               next
[17:43:44.262]                             invokeRestart(restart)
[17:43:44.262]                             muffled <- TRUE
[17:43:44.262]                             break
[17:43:44.262]                           }
[17:43:44.262]                         }
[17:43:44.262]                       }
[17:43:44.262]                       invisible(muffled)
[17:43:44.262]                     }
[17:43:44.262]                     muffleCondition(cond, pattern = "^muffle")
[17:43:44.262]                   }
[17:43:44.262]                 }
[17:43:44.262]                 else {
[17:43:44.262]                   if (TRUE) {
[17:43:44.262]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:44.262]                     {
[17:43:44.262]                       inherits <- base::inherits
[17:43:44.262]                       invokeRestart <- base::invokeRestart
[17:43:44.262]                       is.null <- base::is.null
[17:43:44.262]                       muffled <- FALSE
[17:43:44.262]                       if (inherits(cond, "message")) {
[17:43:44.262]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:44.262]                         if (muffled) 
[17:43:44.262]                           invokeRestart("muffleMessage")
[17:43:44.262]                       }
[17:43:44.262]                       else if (inherits(cond, "warning")) {
[17:43:44.262]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:44.262]                         if (muffled) 
[17:43:44.262]                           invokeRestart("muffleWarning")
[17:43:44.262]                       }
[17:43:44.262]                       else if (inherits(cond, "condition")) {
[17:43:44.262]                         if (!is.null(pattern)) {
[17:43:44.262]                           computeRestarts <- base::computeRestarts
[17:43:44.262]                           grepl <- base::grepl
[17:43:44.262]                           restarts <- computeRestarts(cond)
[17:43:44.262]                           for (restart in restarts) {
[17:43:44.262]                             name <- restart$name
[17:43:44.262]                             if (is.null(name)) 
[17:43:44.262]                               next
[17:43:44.262]                             if (!grepl(pattern, name)) 
[17:43:44.262]                               next
[17:43:44.262]                             invokeRestart(restart)
[17:43:44.262]                             muffled <- TRUE
[17:43:44.262]                             break
[17:43:44.262]                           }
[17:43:44.262]                         }
[17:43:44.262]                       }
[17:43:44.262]                       invisible(muffled)
[17:43:44.262]                     }
[17:43:44.262]                     muffleCondition(cond, pattern = "^muffle")
[17:43:44.262]                   }
[17:43:44.262]                 }
[17:43:44.262]             }
[17:43:44.262]         }))
[17:43:44.262]     }, error = function(ex) {
[17:43:44.262]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:44.262]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:44.262]                 ...future.rng), started = ...future.startTime, 
[17:43:44.262]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:44.262]             version = "1.8"), class = "FutureResult")
[17:43:44.262]     }, finally = {
[17:43:44.262]         if (!identical(...future.workdir, getwd())) 
[17:43:44.262]             setwd(...future.workdir)
[17:43:44.262]         {
[17:43:44.262]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:44.262]                 ...future.oldOptions$nwarnings <- NULL
[17:43:44.262]             }
[17:43:44.262]             base::options(...future.oldOptions)
[17:43:44.262]             if (.Platform$OS.type == "windows") {
[17:43:44.262]                 old_names <- names(...future.oldEnvVars)
[17:43:44.262]                 envs <- base::Sys.getenv()
[17:43:44.262]                 names <- names(envs)
[17:43:44.262]                 common <- intersect(names, old_names)
[17:43:44.262]                 added <- setdiff(names, old_names)
[17:43:44.262]                 removed <- setdiff(old_names, names)
[17:43:44.262]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:44.262]                   envs[common]]
[17:43:44.262]                 NAMES <- toupper(changed)
[17:43:44.262]                 args <- list()
[17:43:44.262]                 for (kk in seq_along(NAMES)) {
[17:43:44.262]                   name <- changed[[kk]]
[17:43:44.262]                   NAME <- NAMES[[kk]]
[17:43:44.262]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:44.262]                     next
[17:43:44.262]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:44.262]                 }
[17:43:44.262]                 NAMES <- toupper(added)
[17:43:44.262]                 for (kk in seq_along(NAMES)) {
[17:43:44.262]                   name <- added[[kk]]
[17:43:44.262]                   NAME <- NAMES[[kk]]
[17:43:44.262]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:44.262]                     next
[17:43:44.262]                   args[[name]] <- ""
[17:43:44.262]                 }
[17:43:44.262]                 NAMES <- toupper(removed)
[17:43:44.262]                 for (kk in seq_along(NAMES)) {
[17:43:44.262]                   name <- removed[[kk]]
[17:43:44.262]                   NAME <- NAMES[[kk]]
[17:43:44.262]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:44.262]                     next
[17:43:44.262]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:44.262]                 }
[17:43:44.262]                 if (length(args) > 0) 
[17:43:44.262]                   base::do.call(base::Sys.setenv, args = args)
[17:43:44.262]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:44.262]             }
[17:43:44.262]             else {
[17:43:44.262]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:44.262]             }
[17:43:44.262]             {
[17:43:44.262]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:44.262]                   0L) {
[17:43:44.262]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:44.262]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:44.262]                   base::options(opts)
[17:43:44.262]                 }
[17:43:44.262]                 {
[17:43:44.262]                   {
[17:43:44.262]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:44.262]                     NULL
[17:43:44.262]                   }
[17:43:44.262]                   options(future.plan = NULL)
[17:43:44.262]                   if (is.na(NA_character_)) 
[17:43:44.262]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:44.262]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:44.262]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:44.262]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:44.262]                     envir = parent.frame()) 
[17:43:44.262]                   {
[17:43:44.262]                     if (is.function(workers)) 
[17:43:44.262]                       workers <- workers()
[17:43:44.262]                     workers <- structure(as.integer(workers), 
[17:43:44.262]                       class = class(workers))
[17:43:44.262]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:44.262]                       workers >= 1)
[17:43:44.262]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:44.262]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:44.262]                     }
[17:43:44.262]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:44.262]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:44.262]                       envir = envir)
[17:43:44.262]                     if (!future$lazy) 
[17:43:44.262]                       future <- run(future)
[17:43:44.262]                     invisible(future)
[17:43:44.262]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:44.262]                 }
[17:43:44.262]             }
[17:43:44.262]         }
[17:43:44.262]     })
[17:43:44.262]     if (TRUE) {
[17:43:44.262]         base::sink(type = "output", split = FALSE)
[17:43:44.262]         if (TRUE) {
[17:43:44.262]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:44.262]         }
[17:43:44.262]         else {
[17:43:44.262]             ...future.result["stdout"] <- base::list(NULL)
[17:43:44.262]         }
[17:43:44.262]         base::close(...future.stdout)
[17:43:44.262]         ...future.stdout <- NULL
[17:43:44.262]     }
[17:43:44.262]     ...future.result$conditions <- ...future.conditions
[17:43:44.262]     ...future.result$finished <- base::Sys.time()
[17:43:44.262]     ...future.result
[17:43:44.262] }
[17:43:44.265] MultisessionFuture started
[17:43:44.265] - Launch lazy future ... done
[17:43:44.265] run() for ‘MultisessionFuture’ ... done
[17:43:44.314] receiveMessageFromWorker() for ClusterFuture ...
[17:43:44.314] - Validating connection of MultisessionFuture
[17:43:44.314] - received message: FutureResult
[17:43:44.315] - Received FutureResult
[17:43:44.315] - Erased future from FutureRegistry
[17:43:44.315] result() for ClusterFuture ...
[17:43:44.315] - result already collected: FutureResult
[17:43:44.315] result() for ClusterFuture ... done
[17:43:44.315] signalConditions() ...
[17:43:44.315]  - include = ‘immediateCondition’
[17:43:44.315]  - exclude = 
[17:43:44.315]  - resignal = FALSE
[17:43:44.315]  - Number of conditions: 1
[17:43:44.316] signalConditions() ... done
[17:43:44.316] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:44.316] A MultisessionFuture was resolved (result was not collected)
[17:43:44.316] getGlobalsAndPackages() ...
[17:43:44.316] Searching for globals...
[17:43:44.317] - globals found: [2] ‘list’, ‘stop’
[17:43:44.317] Searching for globals ... DONE
[17:43:44.317] Resolving globals: FALSE
[17:43:44.317] 
[17:43:44.317] 
[17:43:44.317] getGlobalsAndPackages() ... DONE
[17:43:44.318] run() for ‘Future’ ...
[17:43:44.318] - state: ‘created’
[17:43:44.318] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:44.332] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:44.332] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:44.332]   - Field: ‘node’
[17:43:44.333]   - Field: ‘label’
[17:43:44.333]   - Field: ‘local’
[17:43:44.333]   - Field: ‘owner’
[17:43:44.333]   - Field: ‘envir’
[17:43:44.333]   - Field: ‘workers’
[17:43:44.333]   - Field: ‘packages’
[17:43:44.333]   - Field: ‘gc’
[17:43:44.333]   - Field: ‘conditions’
[17:43:44.333]   - Field: ‘persistent’
[17:43:44.333]   - Field: ‘expr’
[17:43:44.334]   - Field: ‘uuid’
[17:43:44.334]   - Field: ‘seed’
[17:43:44.334]   - Field: ‘version’
[17:43:44.334]   - Field: ‘result’
[17:43:44.334]   - Field: ‘asynchronous’
[17:43:44.334]   - Field: ‘calls’
[17:43:44.334]   - Field: ‘globals’
[17:43:44.334]   - Field: ‘stdout’
[17:43:44.334]   - Field: ‘earlySignal’
[17:43:44.334]   - Field: ‘lazy’
[17:43:44.334]   - Field: ‘state’
[17:43:44.335] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:44.335] - Launch lazy future ...
[17:43:44.335] Packages needed by the future expression (n = 0): <none>
[17:43:44.335] Packages needed by future strategies (n = 0): <none>
[17:43:44.336] {
[17:43:44.336]     {
[17:43:44.336]         {
[17:43:44.336]             ...future.startTime <- base::Sys.time()
[17:43:44.336]             {
[17:43:44.336]                 {
[17:43:44.336]                   {
[17:43:44.336]                     {
[17:43:44.336]                       base::local({
[17:43:44.336]                         has_future <- base::requireNamespace("future", 
[17:43:44.336]                           quietly = TRUE)
[17:43:44.336]                         if (has_future) {
[17:43:44.336]                           ns <- base::getNamespace("future")
[17:43:44.336]                           version <- ns[[".package"]][["version"]]
[17:43:44.336]                           if (is.null(version)) 
[17:43:44.336]                             version <- utils::packageVersion("future")
[17:43:44.336]                         }
[17:43:44.336]                         else {
[17:43:44.336]                           version <- NULL
[17:43:44.336]                         }
[17:43:44.336]                         if (!has_future || version < "1.8.0") {
[17:43:44.336]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:44.336]                             "", base::R.version$version.string), 
[17:43:44.336]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:44.336]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:44.336]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:44.336]                               "release", "version")], collapse = " "), 
[17:43:44.336]                             hostname = base::Sys.info()[["nodename"]])
[17:43:44.336]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:44.336]                             info)
[17:43:44.336]                           info <- base::paste(info, collapse = "; ")
[17:43:44.336]                           if (!has_future) {
[17:43:44.336]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:44.336]                               info)
[17:43:44.336]                           }
[17:43:44.336]                           else {
[17:43:44.336]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:44.336]                               info, version)
[17:43:44.336]                           }
[17:43:44.336]                           base::stop(msg)
[17:43:44.336]                         }
[17:43:44.336]                       })
[17:43:44.336]                     }
[17:43:44.336]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:44.336]                     base::options(mc.cores = 1L)
[17:43:44.336]                   }
[17:43:44.336]                   options(future.plan = NULL)
[17:43:44.336]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:44.336]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:44.336]                 }
[17:43:44.336]                 ...future.workdir <- getwd()
[17:43:44.336]             }
[17:43:44.336]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:44.336]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:44.336]         }
[17:43:44.336]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:44.336]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:44.336]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:44.336]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:44.336]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:44.336]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:44.336]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:44.336]             base::names(...future.oldOptions))
[17:43:44.336]     }
[17:43:44.336]     if (FALSE) {
[17:43:44.336]     }
[17:43:44.336]     else {
[17:43:44.336]         if (TRUE) {
[17:43:44.336]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:44.336]                 open = "w")
[17:43:44.336]         }
[17:43:44.336]         else {
[17:43:44.336]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:44.336]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:44.336]         }
[17:43:44.336]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:44.336]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:44.336]             base::sink(type = "output", split = FALSE)
[17:43:44.336]             base::close(...future.stdout)
[17:43:44.336]         }, add = TRUE)
[17:43:44.336]     }
[17:43:44.336]     ...future.frame <- base::sys.nframe()
[17:43:44.336]     ...future.conditions <- base::list()
[17:43:44.336]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:44.336]     if (FALSE) {
[17:43:44.336]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:44.336]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:44.336]     }
[17:43:44.336]     ...future.result <- base::tryCatch({
[17:43:44.336]         base::withCallingHandlers({
[17:43:44.336]             ...future.value <- base::withVisible(base::local({
[17:43:44.336]                 ...future.makeSendCondition <- local({
[17:43:44.336]                   sendCondition <- NULL
[17:43:44.336]                   function(frame = 1L) {
[17:43:44.336]                     if (is.function(sendCondition)) 
[17:43:44.336]                       return(sendCondition)
[17:43:44.336]                     ns <- getNamespace("parallel")
[17:43:44.336]                     if (exists("sendData", mode = "function", 
[17:43:44.336]                       envir = ns)) {
[17:43:44.336]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:44.336]                         envir = ns)
[17:43:44.336]                       envir <- sys.frame(frame)
[17:43:44.336]                       master <- NULL
[17:43:44.336]                       while (!identical(envir, .GlobalEnv) && 
[17:43:44.336]                         !identical(envir, emptyenv())) {
[17:43:44.336]                         if (exists("master", mode = "list", envir = envir, 
[17:43:44.336]                           inherits = FALSE)) {
[17:43:44.336]                           master <- get("master", mode = "list", 
[17:43:44.336]                             envir = envir, inherits = FALSE)
[17:43:44.336]                           if (inherits(master, c("SOCKnode", 
[17:43:44.336]                             "SOCK0node"))) {
[17:43:44.336]                             sendCondition <<- function(cond) {
[17:43:44.336]                               data <- list(type = "VALUE", value = cond, 
[17:43:44.336]                                 success = TRUE)
[17:43:44.336]                               parallel_sendData(master, data)
[17:43:44.336]                             }
[17:43:44.336]                             return(sendCondition)
[17:43:44.336]                           }
[17:43:44.336]                         }
[17:43:44.336]                         frame <- frame + 1L
[17:43:44.336]                         envir <- sys.frame(frame)
[17:43:44.336]                       }
[17:43:44.336]                     }
[17:43:44.336]                     sendCondition <<- function(cond) NULL
[17:43:44.336]                   }
[17:43:44.336]                 })
[17:43:44.336]                 withCallingHandlers({
[17:43:44.336]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:43:44.336]                 }, immediateCondition = function(cond) {
[17:43:44.336]                   sendCondition <- ...future.makeSendCondition()
[17:43:44.336]                   sendCondition(cond)
[17:43:44.336]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:44.336]                   {
[17:43:44.336]                     inherits <- base::inherits
[17:43:44.336]                     invokeRestart <- base::invokeRestart
[17:43:44.336]                     is.null <- base::is.null
[17:43:44.336]                     muffled <- FALSE
[17:43:44.336]                     if (inherits(cond, "message")) {
[17:43:44.336]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:44.336]                       if (muffled) 
[17:43:44.336]                         invokeRestart("muffleMessage")
[17:43:44.336]                     }
[17:43:44.336]                     else if (inherits(cond, "warning")) {
[17:43:44.336]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:44.336]                       if (muffled) 
[17:43:44.336]                         invokeRestart("muffleWarning")
[17:43:44.336]                     }
[17:43:44.336]                     else if (inherits(cond, "condition")) {
[17:43:44.336]                       if (!is.null(pattern)) {
[17:43:44.336]                         computeRestarts <- base::computeRestarts
[17:43:44.336]                         grepl <- base::grepl
[17:43:44.336]                         restarts <- computeRestarts(cond)
[17:43:44.336]                         for (restart in restarts) {
[17:43:44.336]                           name <- restart$name
[17:43:44.336]                           if (is.null(name)) 
[17:43:44.336]                             next
[17:43:44.336]                           if (!grepl(pattern, name)) 
[17:43:44.336]                             next
[17:43:44.336]                           invokeRestart(restart)
[17:43:44.336]                           muffled <- TRUE
[17:43:44.336]                           break
[17:43:44.336]                         }
[17:43:44.336]                       }
[17:43:44.336]                     }
[17:43:44.336]                     invisible(muffled)
[17:43:44.336]                   }
[17:43:44.336]                   muffleCondition(cond)
[17:43:44.336]                 })
[17:43:44.336]             }))
[17:43:44.336]             future::FutureResult(value = ...future.value$value, 
[17:43:44.336]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:44.336]                   ...future.rng), globalenv = if (FALSE) 
[17:43:44.336]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:44.336]                     ...future.globalenv.names))
[17:43:44.336]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:44.336]         }, condition = base::local({
[17:43:44.336]             c <- base::c
[17:43:44.336]             inherits <- base::inherits
[17:43:44.336]             invokeRestart <- base::invokeRestart
[17:43:44.336]             length <- base::length
[17:43:44.336]             list <- base::list
[17:43:44.336]             seq.int <- base::seq.int
[17:43:44.336]             signalCondition <- base::signalCondition
[17:43:44.336]             sys.calls <- base::sys.calls
[17:43:44.336]             `[[` <- base::`[[`
[17:43:44.336]             `+` <- base::`+`
[17:43:44.336]             `<<-` <- base::`<<-`
[17:43:44.336]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:44.336]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:44.336]                   3L)]
[17:43:44.336]             }
[17:43:44.336]             function(cond) {
[17:43:44.336]                 is_error <- inherits(cond, "error")
[17:43:44.336]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:44.336]                   NULL)
[17:43:44.336]                 if (is_error) {
[17:43:44.336]                   sessionInformation <- function() {
[17:43:44.336]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:44.336]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:44.336]                       search = base::search(), system = base::Sys.info())
[17:43:44.336]                   }
[17:43:44.336]                   ...future.conditions[[length(...future.conditions) + 
[17:43:44.336]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:44.336]                     cond$call), session = sessionInformation(), 
[17:43:44.336]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:44.336]                   signalCondition(cond)
[17:43:44.336]                 }
[17:43:44.336]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:44.336]                 "immediateCondition"))) {
[17:43:44.336]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:44.336]                   ...future.conditions[[length(...future.conditions) + 
[17:43:44.336]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:44.336]                   if (TRUE && !signal) {
[17:43:44.336]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:44.336]                     {
[17:43:44.336]                       inherits <- base::inherits
[17:43:44.336]                       invokeRestart <- base::invokeRestart
[17:43:44.336]                       is.null <- base::is.null
[17:43:44.336]                       muffled <- FALSE
[17:43:44.336]                       if (inherits(cond, "message")) {
[17:43:44.336]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:44.336]                         if (muffled) 
[17:43:44.336]                           invokeRestart("muffleMessage")
[17:43:44.336]                       }
[17:43:44.336]                       else if (inherits(cond, "warning")) {
[17:43:44.336]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:44.336]                         if (muffled) 
[17:43:44.336]                           invokeRestart("muffleWarning")
[17:43:44.336]                       }
[17:43:44.336]                       else if (inherits(cond, "condition")) {
[17:43:44.336]                         if (!is.null(pattern)) {
[17:43:44.336]                           computeRestarts <- base::computeRestarts
[17:43:44.336]                           grepl <- base::grepl
[17:43:44.336]                           restarts <- computeRestarts(cond)
[17:43:44.336]                           for (restart in restarts) {
[17:43:44.336]                             name <- restart$name
[17:43:44.336]                             if (is.null(name)) 
[17:43:44.336]                               next
[17:43:44.336]                             if (!grepl(pattern, name)) 
[17:43:44.336]                               next
[17:43:44.336]                             invokeRestart(restart)
[17:43:44.336]                             muffled <- TRUE
[17:43:44.336]                             break
[17:43:44.336]                           }
[17:43:44.336]                         }
[17:43:44.336]                       }
[17:43:44.336]                       invisible(muffled)
[17:43:44.336]                     }
[17:43:44.336]                     muffleCondition(cond, pattern = "^muffle")
[17:43:44.336]                   }
[17:43:44.336]                 }
[17:43:44.336]                 else {
[17:43:44.336]                   if (TRUE) {
[17:43:44.336]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:44.336]                     {
[17:43:44.336]                       inherits <- base::inherits
[17:43:44.336]                       invokeRestart <- base::invokeRestart
[17:43:44.336]                       is.null <- base::is.null
[17:43:44.336]                       muffled <- FALSE
[17:43:44.336]                       if (inherits(cond, "message")) {
[17:43:44.336]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:44.336]                         if (muffled) 
[17:43:44.336]                           invokeRestart("muffleMessage")
[17:43:44.336]                       }
[17:43:44.336]                       else if (inherits(cond, "warning")) {
[17:43:44.336]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:44.336]                         if (muffled) 
[17:43:44.336]                           invokeRestart("muffleWarning")
[17:43:44.336]                       }
[17:43:44.336]                       else if (inherits(cond, "condition")) {
[17:43:44.336]                         if (!is.null(pattern)) {
[17:43:44.336]                           computeRestarts <- base::computeRestarts
[17:43:44.336]                           grepl <- base::grepl
[17:43:44.336]                           restarts <- computeRestarts(cond)
[17:43:44.336]                           for (restart in restarts) {
[17:43:44.336]                             name <- restart$name
[17:43:44.336]                             if (is.null(name)) 
[17:43:44.336]                               next
[17:43:44.336]                             if (!grepl(pattern, name)) 
[17:43:44.336]                               next
[17:43:44.336]                             invokeRestart(restart)
[17:43:44.336]                             muffled <- TRUE
[17:43:44.336]                             break
[17:43:44.336]                           }
[17:43:44.336]                         }
[17:43:44.336]                       }
[17:43:44.336]                       invisible(muffled)
[17:43:44.336]                     }
[17:43:44.336]                     muffleCondition(cond, pattern = "^muffle")
[17:43:44.336]                   }
[17:43:44.336]                 }
[17:43:44.336]             }
[17:43:44.336]         }))
[17:43:44.336]     }, error = function(ex) {
[17:43:44.336]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:44.336]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:44.336]                 ...future.rng), started = ...future.startTime, 
[17:43:44.336]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:44.336]             version = "1.8"), class = "FutureResult")
[17:43:44.336]     }, finally = {
[17:43:44.336]         if (!identical(...future.workdir, getwd())) 
[17:43:44.336]             setwd(...future.workdir)
[17:43:44.336]         {
[17:43:44.336]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:44.336]                 ...future.oldOptions$nwarnings <- NULL
[17:43:44.336]             }
[17:43:44.336]             base::options(...future.oldOptions)
[17:43:44.336]             if (.Platform$OS.type == "windows") {
[17:43:44.336]                 old_names <- names(...future.oldEnvVars)
[17:43:44.336]                 envs <- base::Sys.getenv()
[17:43:44.336]                 names <- names(envs)
[17:43:44.336]                 common <- intersect(names, old_names)
[17:43:44.336]                 added <- setdiff(names, old_names)
[17:43:44.336]                 removed <- setdiff(old_names, names)
[17:43:44.336]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:44.336]                   envs[common]]
[17:43:44.336]                 NAMES <- toupper(changed)
[17:43:44.336]                 args <- list()
[17:43:44.336]                 for (kk in seq_along(NAMES)) {
[17:43:44.336]                   name <- changed[[kk]]
[17:43:44.336]                   NAME <- NAMES[[kk]]
[17:43:44.336]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:44.336]                     next
[17:43:44.336]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:44.336]                 }
[17:43:44.336]                 NAMES <- toupper(added)
[17:43:44.336]                 for (kk in seq_along(NAMES)) {
[17:43:44.336]                   name <- added[[kk]]
[17:43:44.336]                   NAME <- NAMES[[kk]]
[17:43:44.336]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:44.336]                     next
[17:43:44.336]                   args[[name]] <- ""
[17:43:44.336]                 }
[17:43:44.336]                 NAMES <- toupper(removed)
[17:43:44.336]                 for (kk in seq_along(NAMES)) {
[17:43:44.336]                   name <- removed[[kk]]
[17:43:44.336]                   NAME <- NAMES[[kk]]
[17:43:44.336]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:44.336]                     next
[17:43:44.336]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:44.336]                 }
[17:43:44.336]                 if (length(args) > 0) 
[17:43:44.336]                   base::do.call(base::Sys.setenv, args = args)
[17:43:44.336]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:44.336]             }
[17:43:44.336]             else {
[17:43:44.336]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:44.336]             }
[17:43:44.336]             {
[17:43:44.336]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:44.336]                   0L) {
[17:43:44.336]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:44.336]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:44.336]                   base::options(opts)
[17:43:44.336]                 }
[17:43:44.336]                 {
[17:43:44.336]                   {
[17:43:44.336]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:44.336]                     NULL
[17:43:44.336]                   }
[17:43:44.336]                   options(future.plan = NULL)
[17:43:44.336]                   if (is.na(NA_character_)) 
[17:43:44.336]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:44.336]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:44.336]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:44.336]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:44.336]                     envir = parent.frame()) 
[17:43:44.336]                   {
[17:43:44.336]                     if (is.function(workers)) 
[17:43:44.336]                       workers <- workers()
[17:43:44.336]                     workers <- structure(as.integer(workers), 
[17:43:44.336]                       class = class(workers))
[17:43:44.336]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:44.336]                       workers >= 1)
[17:43:44.336]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:44.336]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:44.336]                     }
[17:43:44.336]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:44.336]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:44.336]                       envir = envir)
[17:43:44.336]                     if (!future$lazy) 
[17:43:44.336]                       future <- run(future)
[17:43:44.336]                     invisible(future)
[17:43:44.336]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:44.336]                 }
[17:43:44.336]             }
[17:43:44.336]         }
[17:43:44.336]     })
[17:43:44.336]     if (TRUE) {
[17:43:44.336]         base::sink(type = "output", split = FALSE)
[17:43:44.336]         if (TRUE) {
[17:43:44.336]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:44.336]         }
[17:43:44.336]         else {
[17:43:44.336]             ...future.result["stdout"] <- base::list(NULL)
[17:43:44.336]         }
[17:43:44.336]         base::close(...future.stdout)
[17:43:44.336]         ...future.stdout <- NULL
[17:43:44.336]     }
[17:43:44.336]     ...future.result$conditions <- ...future.conditions
[17:43:44.336]     ...future.result$finished <- base::Sys.time()
[17:43:44.336]     ...future.result
[17:43:44.336] }
[17:43:44.339] MultisessionFuture started
[17:43:44.339] - Launch lazy future ... done
[17:43:44.339] run() for ‘MultisessionFuture’ ... done
[17:43:44.384] receiveMessageFromWorker() for ClusterFuture ...
[17:43:44.384] - Validating connection of MultisessionFuture
[17:43:44.385] - received message: FutureResult
[17:43:44.385] - Received FutureResult
[17:43:44.385] - Erased future from FutureRegistry
[17:43:44.385] result() for ClusterFuture ...
[17:43:44.385] - result already collected: FutureResult
[17:43:44.385] result() for ClusterFuture ... done
[17:43:44.385] signalConditions() ...
[17:43:44.385]  - include = ‘immediateCondition’
[17:43:44.386]  - exclude = 
[17:43:44.386]  - resignal = FALSE
[17:43:44.386]  - Number of conditions: 1
[17:43:44.386] signalConditions() ... done
[17:43:44.386] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:44.386] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 2 ... DONE
- result = FALSE, recursive = Inf ...
[17:43:44.386] getGlobalsAndPackages() ...
[17:43:44.386] Searching for globals...
[17:43:44.388] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:43:44.388] Searching for globals ... DONE
[17:43:44.388] Resolving globals: FALSE
[17:43:44.388] 
[17:43:44.388] 
[17:43:44.388] getGlobalsAndPackages() ... DONE
[17:43:44.389] run() for ‘Future’ ...
[17:43:44.389] - state: ‘created’
[17:43:44.389] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:44.405] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:44.406] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:44.406]   - Field: ‘node’
[17:43:44.406]   - Field: ‘label’
[17:43:44.406]   - Field: ‘local’
[17:43:44.406]   - Field: ‘owner’
[17:43:44.406]   - Field: ‘envir’
[17:43:44.406]   - Field: ‘workers’
[17:43:44.406]   - Field: ‘packages’
[17:43:44.406]   - Field: ‘gc’
[17:43:44.407]   - Field: ‘conditions’
[17:43:44.407]   - Field: ‘persistent’
[17:43:44.407]   - Field: ‘expr’
[17:43:44.407]   - Field: ‘uuid’
[17:43:44.407]   - Field: ‘seed’
[17:43:44.407]   - Field: ‘version’
[17:43:44.407]   - Field: ‘result’
[17:43:44.407]   - Field: ‘asynchronous’
[17:43:44.407]   - Field: ‘calls’
[17:43:44.407]   - Field: ‘globals’
[17:43:44.408]   - Field: ‘stdout’
[17:43:44.408]   - Field: ‘earlySignal’
[17:43:44.408]   - Field: ‘lazy’
[17:43:44.408]   - Field: ‘state’
[17:43:44.408] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:44.408] - Launch lazy future ...
[17:43:44.408] Packages needed by the future expression (n = 0): <none>
[17:43:44.408] Packages needed by future strategies (n = 0): <none>
[17:43:44.409] {
[17:43:44.409]     {
[17:43:44.409]         {
[17:43:44.409]             ...future.startTime <- base::Sys.time()
[17:43:44.409]             {
[17:43:44.409]                 {
[17:43:44.409]                   {
[17:43:44.409]                     {
[17:43:44.409]                       base::local({
[17:43:44.409]                         has_future <- base::requireNamespace("future", 
[17:43:44.409]                           quietly = TRUE)
[17:43:44.409]                         if (has_future) {
[17:43:44.409]                           ns <- base::getNamespace("future")
[17:43:44.409]                           version <- ns[[".package"]][["version"]]
[17:43:44.409]                           if (is.null(version)) 
[17:43:44.409]                             version <- utils::packageVersion("future")
[17:43:44.409]                         }
[17:43:44.409]                         else {
[17:43:44.409]                           version <- NULL
[17:43:44.409]                         }
[17:43:44.409]                         if (!has_future || version < "1.8.0") {
[17:43:44.409]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:44.409]                             "", base::R.version$version.string), 
[17:43:44.409]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:44.409]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:44.409]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:44.409]                               "release", "version")], collapse = " "), 
[17:43:44.409]                             hostname = base::Sys.info()[["nodename"]])
[17:43:44.409]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:44.409]                             info)
[17:43:44.409]                           info <- base::paste(info, collapse = "; ")
[17:43:44.409]                           if (!has_future) {
[17:43:44.409]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:44.409]                               info)
[17:43:44.409]                           }
[17:43:44.409]                           else {
[17:43:44.409]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:44.409]                               info, version)
[17:43:44.409]                           }
[17:43:44.409]                           base::stop(msg)
[17:43:44.409]                         }
[17:43:44.409]                       })
[17:43:44.409]                     }
[17:43:44.409]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:44.409]                     base::options(mc.cores = 1L)
[17:43:44.409]                   }
[17:43:44.409]                   options(future.plan = NULL)
[17:43:44.409]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:44.409]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:44.409]                 }
[17:43:44.409]                 ...future.workdir <- getwd()
[17:43:44.409]             }
[17:43:44.409]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:44.409]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:44.409]         }
[17:43:44.409]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:44.409]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:44.409]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:44.409]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:44.409]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:44.409]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:44.409]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:44.409]             base::names(...future.oldOptions))
[17:43:44.409]     }
[17:43:44.409]     if (FALSE) {
[17:43:44.409]     }
[17:43:44.409]     else {
[17:43:44.409]         if (TRUE) {
[17:43:44.409]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:44.409]                 open = "w")
[17:43:44.409]         }
[17:43:44.409]         else {
[17:43:44.409]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:44.409]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:44.409]         }
[17:43:44.409]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:44.409]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:44.409]             base::sink(type = "output", split = FALSE)
[17:43:44.409]             base::close(...future.stdout)
[17:43:44.409]         }, add = TRUE)
[17:43:44.409]     }
[17:43:44.409]     ...future.frame <- base::sys.nframe()
[17:43:44.409]     ...future.conditions <- base::list()
[17:43:44.409]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:44.409]     if (FALSE) {
[17:43:44.409]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:44.409]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:44.409]     }
[17:43:44.409]     ...future.result <- base::tryCatch({
[17:43:44.409]         base::withCallingHandlers({
[17:43:44.409]             ...future.value <- base::withVisible(base::local({
[17:43:44.409]                 ...future.makeSendCondition <- local({
[17:43:44.409]                   sendCondition <- NULL
[17:43:44.409]                   function(frame = 1L) {
[17:43:44.409]                     if (is.function(sendCondition)) 
[17:43:44.409]                       return(sendCondition)
[17:43:44.409]                     ns <- getNamespace("parallel")
[17:43:44.409]                     if (exists("sendData", mode = "function", 
[17:43:44.409]                       envir = ns)) {
[17:43:44.409]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:44.409]                         envir = ns)
[17:43:44.409]                       envir <- sys.frame(frame)
[17:43:44.409]                       master <- NULL
[17:43:44.409]                       while (!identical(envir, .GlobalEnv) && 
[17:43:44.409]                         !identical(envir, emptyenv())) {
[17:43:44.409]                         if (exists("master", mode = "list", envir = envir, 
[17:43:44.409]                           inherits = FALSE)) {
[17:43:44.409]                           master <- get("master", mode = "list", 
[17:43:44.409]                             envir = envir, inherits = FALSE)
[17:43:44.409]                           if (inherits(master, c("SOCKnode", 
[17:43:44.409]                             "SOCK0node"))) {
[17:43:44.409]                             sendCondition <<- function(cond) {
[17:43:44.409]                               data <- list(type = "VALUE", value = cond, 
[17:43:44.409]                                 success = TRUE)
[17:43:44.409]                               parallel_sendData(master, data)
[17:43:44.409]                             }
[17:43:44.409]                             return(sendCondition)
[17:43:44.409]                           }
[17:43:44.409]                         }
[17:43:44.409]                         frame <- frame + 1L
[17:43:44.409]                         envir <- sys.frame(frame)
[17:43:44.409]                       }
[17:43:44.409]                     }
[17:43:44.409]                     sendCondition <<- function(cond) NULL
[17:43:44.409]                   }
[17:43:44.409]                 })
[17:43:44.409]                 withCallingHandlers({
[17:43:44.409]                   {
[17:43:44.409]                     Sys.sleep(0.5)
[17:43:44.409]                     list(a = 1, b = 42L)
[17:43:44.409]                   }
[17:43:44.409]                 }, immediateCondition = function(cond) {
[17:43:44.409]                   sendCondition <- ...future.makeSendCondition()
[17:43:44.409]                   sendCondition(cond)
[17:43:44.409]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:44.409]                   {
[17:43:44.409]                     inherits <- base::inherits
[17:43:44.409]                     invokeRestart <- base::invokeRestart
[17:43:44.409]                     is.null <- base::is.null
[17:43:44.409]                     muffled <- FALSE
[17:43:44.409]                     if (inherits(cond, "message")) {
[17:43:44.409]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:44.409]                       if (muffled) 
[17:43:44.409]                         invokeRestart("muffleMessage")
[17:43:44.409]                     }
[17:43:44.409]                     else if (inherits(cond, "warning")) {
[17:43:44.409]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:44.409]                       if (muffled) 
[17:43:44.409]                         invokeRestart("muffleWarning")
[17:43:44.409]                     }
[17:43:44.409]                     else if (inherits(cond, "condition")) {
[17:43:44.409]                       if (!is.null(pattern)) {
[17:43:44.409]                         computeRestarts <- base::computeRestarts
[17:43:44.409]                         grepl <- base::grepl
[17:43:44.409]                         restarts <- computeRestarts(cond)
[17:43:44.409]                         for (restart in restarts) {
[17:43:44.409]                           name <- restart$name
[17:43:44.409]                           if (is.null(name)) 
[17:43:44.409]                             next
[17:43:44.409]                           if (!grepl(pattern, name)) 
[17:43:44.409]                             next
[17:43:44.409]                           invokeRestart(restart)
[17:43:44.409]                           muffled <- TRUE
[17:43:44.409]                           break
[17:43:44.409]                         }
[17:43:44.409]                       }
[17:43:44.409]                     }
[17:43:44.409]                     invisible(muffled)
[17:43:44.409]                   }
[17:43:44.409]                   muffleCondition(cond)
[17:43:44.409]                 })
[17:43:44.409]             }))
[17:43:44.409]             future::FutureResult(value = ...future.value$value, 
[17:43:44.409]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:44.409]                   ...future.rng), globalenv = if (FALSE) 
[17:43:44.409]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:44.409]                     ...future.globalenv.names))
[17:43:44.409]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:44.409]         }, condition = base::local({
[17:43:44.409]             c <- base::c
[17:43:44.409]             inherits <- base::inherits
[17:43:44.409]             invokeRestart <- base::invokeRestart
[17:43:44.409]             length <- base::length
[17:43:44.409]             list <- base::list
[17:43:44.409]             seq.int <- base::seq.int
[17:43:44.409]             signalCondition <- base::signalCondition
[17:43:44.409]             sys.calls <- base::sys.calls
[17:43:44.409]             `[[` <- base::`[[`
[17:43:44.409]             `+` <- base::`+`
[17:43:44.409]             `<<-` <- base::`<<-`
[17:43:44.409]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:44.409]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:44.409]                   3L)]
[17:43:44.409]             }
[17:43:44.409]             function(cond) {
[17:43:44.409]                 is_error <- inherits(cond, "error")
[17:43:44.409]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:44.409]                   NULL)
[17:43:44.409]                 if (is_error) {
[17:43:44.409]                   sessionInformation <- function() {
[17:43:44.409]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:44.409]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:44.409]                       search = base::search(), system = base::Sys.info())
[17:43:44.409]                   }
[17:43:44.409]                   ...future.conditions[[length(...future.conditions) + 
[17:43:44.409]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:44.409]                     cond$call), session = sessionInformation(), 
[17:43:44.409]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:44.409]                   signalCondition(cond)
[17:43:44.409]                 }
[17:43:44.409]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:44.409]                 "immediateCondition"))) {
[17:43:44.409]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:44.409]                   ...future.conditions[[length(...future.conditions) + 
[17:43:44.409]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:44.409]                   if (TRUE && !signal) {
[17:43:44.409]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:44.409]                     {
[17:43:44.409]                       inherits <- base::inherits
[17:43:44.409]                       invokeRestart <- base::invokeRestart
[17:43:44.409]                       is.null <- base::is.null
[17:43:44.409]                       muffled <- FALSE
[17:43:44.409]                       if (inherits(cond, "message")) {
[17:43:44.409]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:44.409]                         if (muffled) 
[17:43:44.409]                           invokeRestart("muffleMessage")
[17:43:44.409]                       }
[17:43:44.409]                       else if (inherits(cond, "warning")) {
[17:43:44.409]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:44.409]                         if (muffled) 
[17:43:44.409]                           invokeRestart("muffleWarning")
[17:43:44.409]                       }
[17:43:44.409]                       else if (inherits(cond, "condition")) {
[17:43:44.409]                         if (!is.null(pattern)) {
[17:43:44.409]                           computeRestarts <- base::computeRestarts
[17:43:44.409]                           grepl <- base::grepl
[17:43:44.409]                           restarts <- computeRestarts(cond)
[17:43:44.409]                           for (restart in restarts) {
[17:43:44.409]                             name <- restart$name
[17:43:44.409]                             if (is.null(name)) 
[17:43:44.409]                               next
[17:43:44.409]                             if (!grepl(pattern, name)) 
[17:43:44.409]                               next
[17:43:44.409]                             invokeRestart(restart)
[17:43:44.409]                             muffled <- TRUE
[17:43:44.409]                             break
[17:43:44.409]                           }
[17:43:44.409]                         }
[17:43:44.409]                       }
[17:43:44.409]                       invisible(muffled)
[17:43:44.409]                     }
[17:43:44.409]                     muffleCondition(cond, pattern = "^muffle")
[17:43:44.409]                   }
[17:43:44.409]                 }
[17:43:44.409]                 else {
[17:43:44.409]                   if (TRUE) {
[17:43:44.409]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:44.409]                     {
[17:43:44.409]                       inherits <- base::inherits
[17:43:44.409]                       invokeRestart <- base::invokeRestart
[17:43:44.409]                       is.null <- base::is.null
[17:43:44.409]                       muffled <- FALSE
[17:43:44.409]                       if (inherits(cond, "message")) {
[17:43:44.409]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:44.409]                         if (muffled) 
[17:43:44.409]                           invokeRestart("muffleMessage")
[17:43:44.409]                       }
[17:43:44.409]                       else if (inherits(cond, "warning")) {
[17:43:44.409]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:44.409]                         if (muffled) 
[17:43:44.409]                           invokeRestart("muffleWarning")
[17:43:44.409]                       }
[17:43:44.409]                       else if (inherits(cond, "condition")) {
[17:43:44.409]                         if (!is.null(pattern)) {
[17:43:44.409]                           computeRestarts <- base::computeRestarts
[17:43:44.409]                           grepl <- base::grepl
[17:43:44.409]                           restarts <- computeRestarts(cond)
[17:43:44.409]                           for (restart in restarts) {
[17:43:44.409]                             name <- restart$name
[17:43:44.409]                             if (is.null(name)) 
[17:43:44.409]                               next
[17:43:44.409]                             if (!grepl(pattern, name)) 
[17:43:44.409]                               next
[17:43:44.409]                             invokeRestart(restart)
[17:43:44.409]                             muffled <- TRUE
[17:43:44.409]                             break
[17:43:44.409]                           }
[17:43:44.409]                         }
[17:43:44.409]                       }
[17:43:44.409]                       invisible(muffled)
[17:43:44.409]                     }
[17:43:44.409]                     muffleCondition(cond, pattern = "^muffle")
[17:43:44.409]                   }
[17:43:44.409]                 }
[17:43:44.409]             }
[17:43:44.409]         }))
[17:43:44.409]     }, error = function(ex) {
[17:43:44.409]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:44.409]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:44.409]                 ...future.rng), started = ...future.startTime, 
[17:43:44.409]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:44.409]             version = "1.8"), class = "FutureResult")
[17:43:44.409]     }, finally = {
[17:43:44.409]         if (!identical(...future.workdir, getwd())) 
[17:43:44.409]             setwd(...future.workdir)
[17:43:44.409]         {
[17:43:44.409]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:44.409]                 ...future.oldOptions$nwarnings <- NULL
[17:43:44.409]             }
[17:43:44.409]             base::options(...future.oldOptions)
[17:43:44.409]             if (.Platform$OS.type == "windows") {
[17:43:44.409]                 old_names <- names(...future.oldEnvVars)
[17:43:44.409]                 envs <- base::Sys.getenv()
[17:43:44.409]                 names <- names(envs)
[17:43:44.409]                 common <- intersect(names, old_names)
[17:43:44.409]                 added <- setdiff(names, old_names)
[17:43:44.409]                 removed <- setdiff(old_names, names)
[17:43:44.409]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:44.409]                   envs[common]]
[17:43:44.409]                 NAMES <- toupper(changed)
[17:43:44.409]                 args <- list()
[17:43:44.409]                 for (kk in seq_along(NAMES)) {
[17:43:44.409]                   name <- changed[[kk]]
[17:43:44.409]                   NAME <- NAMES[[kk]]
[17:43:44.409]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:44.409]                     next
[17:43:44.409]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:44.409]                 }
[17:43:44.409]                 NAMES <- toupper(added)
[17:43:44.409]                 for (kk in seq_along(NAMES)) {
[17:43:44.409]                   name <- added[[kk]]
[17:43:44.409]                   NAME <- NAMES[[kk]]
[17:43:44.409]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:44.409]                     next
[17:43:44.409]                   args[[name]] <- ""
[17:43:44.409]                 }
[17:43:44.409]                 NAMES <- toupper(removed)
[17:43:44.409]                 for (kk in seq_along(NAMES)) {
[17:43:44.409]                   name <- removed[[kk]]
[17:43:44.409]                   NAME <- NAMES[[kk]]
[17:43:44.409]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:44.409]                     next
[17:43:44.409]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:44.409]                 }
[17:43:44.409]                 if (length(args) > 0) 
[17:43:44.409]                   base::do.call(base::Sys.setenv, args = args)
[17:43:44.409]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:44.409]             }
[17:43:44.409]             else {
[17:43:44.409]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:44.409]             }
[17:43:44.409]             {
[17:43:44.409]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:44.409]                   0L) {
[17:43:44.409]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:44.409]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:44.409]                   base::options(opts)
[17:43:44.409]                 }
[17:43:44.409]                 {
[17:43:44.409]                   {
[17:43:44.409]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:44.409]                     NULL
[17:43:44.409]                   }
[17:43:44.409]                   options(future.plan = NULL)
[17:43:44.409]                   if (is.na(NA_character_)) 
[17:43:44.409]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:44.409]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:44.409]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:44.409]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:44.409]                     envir = parent.frame()) 
[17:43:44.409]                   {
[17:43:44.409]                     if (is.function(workers)) 
[17:43:44.409]                       workers <- workers()
[17:43:44.409]                     workers <- structure(as.integer(workers), 
[17:43:44.409]                       class = class(workers))
[17:43:44.409]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:44.409]                       workers >= 1)
[17:43:44.409]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:44.409]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:44.409]                     }
[17:43:44.409]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:44.409]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:44.409]                       envir = envir)
[17:43:44.409]                     if (!future$lazy) 
[17:43:44.409]                       future <- run(future)
[17:43:44.409]                     invisible(future)
[17:43:44.409]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:44.409]                 }
[17:43:44.409]             }
[17:43:44.409]         }
[17:43:44.409]     })
[17:43:44.409]     if (TRUE) {
[17:43:44.409]         base::sink(type = "output", split = FALSE)
[17:43:44.409]         if (TRUE) {
[17:43:44.409]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:44.409]         }
[17:43:44.409]         else {
[17:43:44.409]             ...future.result["stdout"] <- base::list(NULL)
[17:43:44.409]         }
[17:43:44.409]         base::close(...future.stdout)
[17:43:44.409]         ...future.stdout <- NULL
[17:43:44.409]     }
[17:43:44.409]     ...future.result$conditions <- ...future.conditions
[17:43:44.409]     ...future.result$finished <- base::Sys.time()
[17:43:44.409]     ...future.result
[17:43:44.409] }
[17:43:44.412] MultisessionFuture started
[17:43:44.412] - Launch lazy future ... done
[17:43:44.413] run() for ‘MultisessionFuture’ ... done
[17:43:44.961] receiveMessageFromWorker() for ClusterFuture ...
[17:43:44.961] - Validating connection of MultisessionFuture
[17:43:44.961] - received message: FutureResult
[17:43:44.961] - Received FutureResult
[17:43:44.961] - Erased future from FutureRegistry
[17:43:44.962] result() for ClusterFuture ...
[17:43:44.962] - result already collected: FutureResult
[17:43:44.962] result() for ClusterFuture ... done
[17:43:44.962] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:44.962] A MultisessionFuture was resolved (result was not collected)
[17:43:44.962] getGlobalsAndPackages() ...
[17:43:44.962] Searching for globals...
[17:43:44.963] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:43:44.963] Searching for globals ... DONE
[17:43:44.964] Resolving globals: FALSE
[17:43:44.964] 
[17:43:44.964] 
[17:43:44.964] getGlobalsAndPackages() ... DONE
[17:43:44.964] run() for ‘Future’ ...
[17:43:44.964] - state: ‘created’
[17:43:44.965] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:44.979] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:44.980] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:44.980]   - Field: ‘node’
[17:43:44.980]   - Field: ‘label’
[17:43:44.980]   - Field: ‘local’
[17:43:44.980]   - Field: ‘owner’
[17:43:44.980]   - Field: ‘envir’
[17:43:44.980]   - Field: ‘workers’
[17:43:44.980]   - Field: ‘packages’
[17:43:44.980]   - Field: ‘gc’
[17:43:44.981]   - Field: ‘conditions’
[17:43:44.981]   - Field: ‘persistent’
[17:43:44.981]   - Field: ‘expr’
[17:43:44.981]   - Field: ‘uuid’
[17:43:44.981]   - Field: ‘seed’
[17:43:44.981]   - Field: ‘version’
[17:43:44.981]   - Field: ‘result’
[17:43:44.981]   - Field: ‘asynchronous’
[17:43:44.981]   - Field: ‘calls’
[17:43:44.981]   - Field: ‘globals’
[17:43:44.981]   - Field: ‘stdout’
[17:43:44.982]   - Field: ‘earlySignal’
[17:43:44.982]   - Field: ‘lazy’
[17:43:44.982]   - Field: ‘state’
[17:43:44.982] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:44.982] - Launch lazy future ...
[17:43:44.982] Packages needed by the future expression (n = 0): <none>
[17:43:44.982] Packages needed by future strategies (n = 0): <none>
[17:43:44.983] {
[17:43:44.983]     {
[17:43:44.983]         {
[17:43:44.983]             ...future.startTime <- base::Sys.time()
[17:43:44.983]             {
[17:43:44.983]                 {
[17:43:44.983]                   {
[17:43:44.983]                     {
[17:43:44.983]                       base::local({
[17:43:44.983]                         has_future <- base::requireNamespace("future", 
[17:43:44.983]                           quietly = TRUE)
[17:43:44.983]                         if (has_future) {
[17:43:44.983]                           ns <- base::getNamespace("future")
[17:43:44.983]                           version <- ns[[".package"]][["version"]]
[17:43:44.983]                           if (is.null(version)) 
[17:43:44.983]                             version <- utils::packageVersion("future")
[17:43:44.983]                         }
[17:43:44.983]                         else {
[17:43:44.983]                           version <- NULL
[17:43:44.983]                         }
[17:43:44.983]                         if (!has_future || version < "1.8.0") {
[17:43:44.983]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:44.983]                             "", base::R.version$version.string), 
[17:43:44.983]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:44.983]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:44.983]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:44.983]                               "release", "version")], collapse = " "), 
[17:43:44.983]                             hostname = base::Sys.info()[["nodename"]])
[17:43:44.983]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:44.983]                             info)
[17:43:44.983]                           info <- base::paste(info, collapse = "; ")
[17:43:44.983]                           if (!has_future) {
[17:43:44.983]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:44.983]                               info)
[17:43:44.983]                           }
[17:43:44.983]                           else {
[17:43:44.983]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:44.983]                               info, version)
[17:43:44.983]                           }
[17:43:44.983]                           base::stop(msg)
[17:43:44.983]                         }
[17:43:44.983]                       })
[17:43:44.983]                     }
[17:43:44.983]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:44.983]                     base::options(mc.cores = 1L)
[17:43:44.983]                   }
[17:43:44.983]                   options(future.plan = NULL)
[17:43:44.983]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:44.983]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:44.983]                 }
[17:43:44.983]                 ...future.workdir <- getwd()
[17:43:44.983]             }
[17:43:44.983]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:44.983]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:44.983]         }
[17:43:44.983]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:44.983]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:44.983]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:44.983]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:44.983]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:44.983]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:44.983]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:44.983]             base::names(...future.oldOptions))
[17:43:44.983]     }
[17:43:44.983]     if (FALSE) {
[17:43:44.983]     }
[17:43:44.983]     else {
[17:43:44.983]         if (TRUE) {
[17:43:44.983]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:44.983]                 open = "w")
[17:43:44.983]         }
[17:43:44.983]         else {
[17:43:44.983]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:44.983]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:44.983]         }
[17:43:44.983]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:44.983]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:44.983]             base::sink(type = "output", split = FALSE)
[17:43:44.983]             base::close(...future.stdout)
[17:43:44.983]         }, add = TRUE)
[17:43:44.983]     }
[17:43:44.983]     ...future.frame <- base::sys.nframe()
[17:43:44.983]     ...future.conditions <- base::list()
[17:43:44.983]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:44.983]     if (FALSE) {
[17:43:44.983]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:44.983]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:44.983]     }
[17:43:44.983]     ...future.result <- base::tryCatch({
[17:43:44.983]         base::withCallingHandlers({
[17:43:44.983]             ...future.value <- base::withVisible(base::local({
[17:43:44.983]                 ...future.makeSendCondition <- local({
[17:43:44.983]                   sendCondition <- NULL
[17:43:44.983]                   function(frame = 1L) {
[17:43:44.983]                     if (is.function(sendCondition)) 
[17:43:44.983]                       return(sendCondition)
[17:43:44.983]                     ns <- getNamespace("parallel")
[17:43:44.983]                     if (exists("sendData", mode = "function", 
[17:43:44.983]                       envir = ns)) {
[17:43:44.983]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:44.983]                         envir = ns)
[17:43:44.983]                       envir <- sys.frame(frame)
[17:43:44.983]                       master <- NULL
[17:43:44.983]                       while (!identical(envir, .GlobalEnv) && 
[17:43:44.983]                         !identical(envir, emptyenv())) {
[17:43:44.983]                         if (exists("master", mode = "list", envir = envir, 
[17:43:44.983]                           inherits = FALSE)) {
[17:43:44.983]                           master <- get("master", mode = "list", 
[17:43:44.983]                             envir = envir, inherits = FALSE)
[17:43:44.983]                           if (inherits(master, c("SOCKnode", 
[17:43:44.983]                             "SOCK0node"))) {
[17:43:44.983]                             sendCondition <<- function(cond) {
[17:43:44.983]                               data <- list(type = "VALUE", value = cond, 
[17:43:44.983]                                 success = TRUE)
[17:43:44.983]                               parallel_sendData(master, data)
[17:43:44.983]                             }
[17:43:44.983]                             return(sendCondition)
[17:43:44.983]                           }
[17:43:44.983]                         }
[17:43:44.983]                         frame <- frame + 1L
[17:43:44.983]                         envir <- sys.frame(frame)
[17:43:44.983]                       }
[17:43:44.983]                     }
[17:43:44.983]                     sendCondition <<- function(cond) NULL
[17:43:44.983]                   }
[17:43:44.983]                 })
[17:43:44.983]                 withCallingHandlers({
[17:43:44.983]                   {
[17:43:44.983]                     Sys.sleep(0.5)
[17:43:44.983]                     list(a = 1, b = 42L)
[17:43:44.983]                   }
[17:43:44.983]                 }, immediateCondition = function(cond) {
[17:43:44.983]                   sendCondition <- ...future.makeSendCondition()
[17:43:44.983]                   sendCondition(cond)
[17:43:44.983]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:44.983]                   {
[17:43:44.983]                     inherits <- base::inherits
[17:43:44.983]                     invokeRestart <- base::invokeRestart
[17:43:44.983]                     is.null <- base::is.null
[17:43:44.983]                     muffled <- FALSE
[17:43:44.983]                     if (inherits(cond, "message")) {
[17:43:44.983]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:44.983]                       if (muffled) 
[17:43:44.983]                         invokeRestart("muffleMessage")
[17:43:44.983]                     }
[17:43:44.983]                     else if (inherits(cond, "warning")) {
[17:43:44.983]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:44.983]                       if (muffled) 
[17:43:44.983]                         invokeRestart("muffleWarning")
[17:43:44.983]                     }
[17:43:44.983]                     else if (inherits(cond, "condition")) {
[17:43:44.983]                       if (!is.null(pattern)) {
[17:43:44.983]                         computeRestarts <- base::computeRestarts
[17:43:44.983]                         grepl <- base::grepl
[17:43:44.983]                         restarts <- computeRestarts(cond)
[17:43:44.983]                         for (restart in restarts) {
[17:43:44.983]                           name <- restart$name
[17:43:44.983]                           if (is.null(name)) 
[17:43:44.983]                             next
[17:43:44.983]                           if (!grepl(pattern, name)) 
[17:43:44.983]                             next
[17:43:44.983]                           invokeRestart(restart)
[17:43:44.983]                           muffled <- TRUE
[17:43:44.983]                           break
[17:43:44.983]                         }
[17:43:44.983]                       }
[17:43:44.983]                     }
[17:43:44.983]                     invisible(muffled)
[17:43:44.983]                   }
[17:43:44.983]                   muffleCondition(cond)
[17:43:44.983]                 })
[17:43:44.983]             }))
[17:43:44.983]             future::FutureResult(value = ...future.value$value, 
[17:43:44.983]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:44.983]                   ...future.rng), globalenv = if (FALSE) 
[17:43:44.983]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:44.983]                     ...future.globalenv.names))
[17:43:44.983]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:44.983]         }, condition = base::local({
[17:43:44.983]             c <- base::c
[17:43:44.983]             inherits <- base::inherits
[17:43:44.983]             invokeRestart <- base::invokeRestart
[17:43:44.983]             length <- base::length
[17:43:44.983]             list <- base::list
[17:43:44.983]             seq.int <- base::seq.int
[17:43:44.983]             signalCondition <- base::signalCondition
[17:43:44.983]             sys.calls <- base::sys.calls
[17:43:44.983]             `[[` <- base::`[[`
[17:43:44.983]             `+` <- base::`+`
[17:43:44.983]             `<<-` <- base::`<<-`
[17:43:44.983]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:44.983]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:44.983]                   3L)]
[17:43:44.983]             }
[17:43:44.983]             function(cond) {
[17:43:44.983]                 is_error <- inherits(cond, "error")
[17:43:44.983]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:44.983]                   NULL)
[17:43:44.983]                 if (is_error) {
[17:43:44.983]                   sessionInformation <- function() {
[17:43:44.983]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:44.983]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:44.983]                       search = base::search(), system = base::Sys.info())
[17:43:44.983]                   }
[17:43:44.983]                   ...future.conditions[[length(...future.conditions) + 
[17:43:44.983]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:44.983]                     cond$call), session = sessionInformation(), 
[17:43:44.983]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:44.983]                   signalCondition(cond)
[17:43:44.983]                 }
[17:43:44.983]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:44.983]                 "immediateCondition"))) {
[17:43:44.983]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:44.983]                   ...future.conditions[[length(...future.conditions) + 
[17:43:44.983]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:44.983]                   if (TRUE && !signal) {
[17:43:44.983]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:44.983]                     {
[17:43:44.983]                       inherits <- base::inherits
[17:43:44.983]                       invokeRestart <- base::invokeRestart
[17:43:44.983]                       is.null <- base::is.null
[17:43:44.983]                       muffled <- FALSE
[17:43:44.983]                       if (inherits(cond, "message")) {
[17:43:44.983]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:44.983]                         if (muffled) 
[17:43:44.983]                           invokeRestart("muffleMessage")
[17:43:44.983]                       }
[17:43:44.983]                       else if (inherits(cond, "warning")) {
[17:43:44.983]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:44.983]                         if (muffled) 
[17:43:44.983]                           invokeRestart("muffleWarning")
[17:43:44.983]                       }
[17:43:44.983]                       else if (inherits(cond, "condition")) {
[17:43:44.983]                         if (!is.null(pattern)) {
[17:43:44.983]                           computeRestarts <- base::computeRestarts
[17:43:44.983]                           grepl <- base::grepl
[17:43:44.983]                           restarts <- computeRestarts(cond)
[17:43:44.983]                           for (restart in restarts) {
[17:43:44.983]                             name <- restart$name
[17:43:44.983]                             if (is.null(name)) 
[17:43:44.983]                               next
[17:43:44.983]                             if (!grepl(pattern, name)) 
[17:43:44.983]                               next
[17:43:44.983]                             invokeRestart(restart)
[17:43:44.983]                             muffled <- TRUE
[17:43:44.983]                             break
[17:43:44.983]                           }
[17:43:44.983]                         }
[17:43:44.983]                       }
[17:43:44.983]                       invisible(muffled)
[17:43:44.983]                     }
[17:43:44.983]                     muffleCondition(cond, pattern = "^muffle")
[17:43:44.983]                   }
[17:43:44.983]                 }
[17:43:44.983]                 else {
[17:43:44.983]                   if (TRUE) {
[17:43:44.983]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:44.983]                     {
[17:43:44.983]                       inherits <- base::inherits
[17:43:44.983]                       invokeRestart <- base::invokeRestart
[17:43:44.983]                       is.null <- base::is.null
[17:43:44.983]                       muffled <- FALSE
[17:43:44.983]                       if (inherits(cond, "message")) {
[17:43:44.983]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:44.983]                         if (muffled) 
[17:43:44.983]                           invokeRestart("muffleMessage")
[17:43:44.983]                       }
[17:43:44.983]                       else if (inherits(cond, "warning")) {
[17:43:44.983]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:44.983]                         if (muffled) 
[17:43:44.983]                           invokeRestart("muffleWarning")
[17:43:44.983]                       }
[17:43:44.983]                       else if (inherits(cond, "condition")) {
[17:43:44.983]                         if (!is.null(pattern)) {
[17:43:44.983]                           computeRestarts <- base::computeRestarts
[17:43:44.983]                           grepl <- base::grepl
[17:43:44.983]                           restarts <- computeRestarts(cond)
[17:43:44.983]                           for (restart in restarts) {
[17:43:44.983]                             name <- restart$name
[17:43:44.983]                             if (is.null(name)) 
[17:43:44.983]                               next
[17:43:44.983]                             if (!grepl(pattern, name)) 
[17:43:44.983]                               next
[17:43:44.983]                             invokeRestart(restart)
[17:43:44.983]                             muffled <- TRUE
[17:43:44.983]                             break
[17:43:44.983]                           }
[17:43:44.983]                         }
[17:43:44.983]                       }
[17:43:44.983]                       invisible(muffled)
[17:43:44.983]                     }
[17:43:44.983]                     muffleCondition(cond, pattern = "^muffle")
[17:43:44.983]                   }
[17:43:44.983]                 }
[17:43:44.983]             }
[17:43:44.983]         }))
[17:43:44.983]     }, error = function(ex) {
[17:43:44.983]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:44.983]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:44.983]                 ...future.rng), started = ...future.startTime, 
[17:43:44.983]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:44.983]             version = "1.8"), class = "FutureResult")
[17:43:44.983]     }, finally = {
[17:43:44.983]         if (!identical(...future.workdir, getwd())) 
[17:43:44.983]             setwd(...future.workdir)
[17:43:44.983]         {
[17:43:44.983]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:44.983]                 ...future.oldOptions$nwarnings <- NULL
[17:43:44.983]             }
[17:43:44.983]             base::options(...future.oldOptions)
[17:43:44.983]             if (.Platform$OS.type == "windows") {
[17:43:44.983]                 old_names <- names(...future.oldEnvVars)
[17:43:44.983]                 envs <- base::Sys.getenv()
[17:43:44.983]                 names <- names(envs)
[17:43:44.983]                 common <- intersect(names, old_names)
[17:43:44.983]                 added <- setdiff(names, old_names)
[17:43:44.983]                 removed <- setdiff(old_names, names)
[17:43:44.983]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:44.983]                   envs[common]]
[17:43:44.983]                 NAMES <- toupper(changed)
[17:43:44.983]                 args <- list()
[17:43:44.983]                 for (kk in seq_along(NAMES)) {
[17:43:44.983]                   name <- changed[[kk]]
[17:43:44.983]                   NAME <- NAMES[[kk]]
[17:43:44.983]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:44.983]                     next
[17:43:44.983]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:44.983]                 }
[17:43:44.983]                 NAMES <- toupper(added)
[17:43:44.983]                 for (kk in seq_along(NAMES)) {
[17:43:44.983]                   name <- added[[kk]]
[17:43:44.983]                   NAME <- NAMES[[kk]]
[17:43:44.983]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:44.983]                     next
[17:43:44.983]                   args[[name]] <- ""
[17:43:44.983]                 }
[17:43:44.983]                 NAMES <- toupper(removed)
[17:43:44.983]                 for (kk in seq_along(NAMES)) {
[17:43:44.983]                   name <- removed[[kk]]
[17:43:44.983]                   NAME <- NAMES[[kk]]
[17:43:44.983]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:44.983]                     next
[17:43:44.983]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:44.983]                 }
[17:43:44.983]                 if (length(args) > 0) 
[17:43:44.983]                   base::do.call(base::Sys.setenv, args = args)
[17:43:44.983]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:44.983]             }
[17:43:44.983]             else {
[17:43:44.983]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:44.983]             }
[17:43:44.983]             {
[17:43:44.983]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:44.983]                   0L) {
[17:43:44.983]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:44.983]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:44.983]                   base::options(opts)
[17:43:44.983]                 }
[17:43:44.983]                 {
[17:43:44.983]                   {
[17:43:44.983]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:44.983]                     NULL
[17:43:44.983]                   }
[17:43:44.983]                   options(future.plan = NULL)
[17:43:44.983]                   if (is.na(NA_character_)) 
[17:43:44.983]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:44.983]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:44.983]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:44.983]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:44.983]                     envir = parent.frame()) 
[17:43:44.983]                   {
[17:43:44.983]                     if (is.function(workers)) 
[17:43:44.983]                       workers <- workers()
[17:43:44.983]                     workers <- structure(as.integer(workers), 
[17:43:44.983]                       class = class(workers))
[17:43:44.983]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:44.983]                       workers >= 1)
[17:43:44.983]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:44.983]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:44.983]                     }
[17:43:44.983]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:44.983]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:44.983]                       envir = envir)
[17:43:44.983]                     if (!future$lazy) 
[17:43:44.983]                       future <- run(future)
[17:43:44.983]                     invisible(future)
[17:43:44.983]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:44.983]                 }
[17:43:44.983]             }
[17:43:44.983]         }
[17:43:44.983]     })
[17:43:44.983]     if (TRUE) {
[17:43:44.983]         base::sink(type = "output", split = FALSE)
[17:43:44.983]         if (TRUE) {
[17:43:44.983]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:44.983]         }
[17:43:44.983]         else {
[17:43:44.983]             ...future.result["stdout"] <- base::list(NULL)
[17:43:44.983]         }
[17:43:44.983]         base::close(...future.stdout)
[17:43:44.983]         ...future.stdout <- NULL
[17:43:44.983]     }
[17:43:44.983]     ...future.result$conditions <- ...future.conditions
[17:43:44.983]     ...future.result$finished <- base::Sys.time()
[17:43:44.983]     ...future.result
[17:43:44.983] }
[17:43:44.986] MultisessionFuture started
[17:43:44.986] - Launch lazy future ... done
[17:43:44.986] run() for ‘MultisessionFuture’ ... done
[17:43:45.533] receiveMessageFromWorker() for ClusterFuture ...
[17:43:45.533] - Validating connection of MultisessionFuture
[17:43:45.533] - received message: FutureResult
[17:43:45.533] - Received FutureResult
[17:43:45.534] - Erased future from FutureRegistry
[17:43:45.534] result() for ClusterFuture ...
[17:43:45.534] - result already collected: FutureResult
[17:43:45.534] result() for ClusterFuture ... done
[17:43:45.534] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:45.534] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[17:43:45.534] getGlobalsAndPackages() ...
[17:43:45.534] Searching for globals...
[17:43:45.535] - globals found: [2] ‘list’, ‘stop’
[17:43:45.535] Searching for globals ... DONE
[17:43:45.535] Resolving globals: FALSE
[17:43:45.536] 
[17:43:45.536] 
[17:43:45.536] getGlobalsAndPackages() ... DONE
[17:43:45.536] run() for ‘Future’ ...
[17:43:45.536] - state: ‘created’
[17:43:45.536] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:45.550] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:45.550] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:45.551]   - Field: ‘node’
[17:43:45.551]   - Field: ‘label’
[17:43:45.551]   - Field: ‘local’
[17:43:45.551]   - Field: ‘owner’
[17:43:45.551]   - Field: ‘envir’
[17:43:45.551]   - Field: ‘workers’
[17:43:45.551]   - Field: ‘packages’
[17:43:45.551]   - Field: ‘gc’
[17:43:45.551]   - Field: ‘conditions’
[17:43:45.552]   - Field: ‘persistent’
[17:43:45.552]   - Field: ‘expr’
[17:43:45.552]   - Field: ‘uuid’
[17:43:45.552]   - Field: ‘seed’
[17:43:45.552]   - Field: ‘version’
[17:43:45.552]   - Field: ‘result’
[17:43:45.552]   - Field: ‘asynchronous’
[17:43:45.552]   - Field: ‘calls’
[17:43:45.552]   - Field: ‘globals’
[17:43:45.552]   - Field: ‘stdout’
[17:43:45.552]   - Field: ‘earlySignal’
[17:43:45.553]   - Field: ‘lazy’
[17:43:45.553]   - Field: ‘state’
[17:43:45.553] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:45.553] - Launch lazy future ...
[17:43:45.553] Packages needed by the future expression (n = 0): <none>
[17:43:45.553] Packages needed by future strategies (n = 0): <none>
[17:43:45.554] {
[17:43:45.554]     {
[17:43:45.554]         {
[17:43:45.554]             ...future.startTime <- base::Sys.time()
[17:43:45.554]             {
[17:43:45.554]                 {
[17:43:45.554]                   {
[17:43:45.554]                     {
[17:43:45.554]                       base::local({
[17:43:45.554]                         has_future <- base::requireNamespace("future", 
[17:43:45.554]                           quietly = TRUE)
[17:43:45.554]                         if (has_future) {
[17:43:45.554]                           ns <- base::getNamespace("future")
[17:43:45.554]                           version <- ns[[".package"]][["version"]]
[17:43:45.554]                           if (is.null(version)) 
[17:43:45.554]                             version <- utils::packageVersion("future")
[17:43:45.554]                         }
[17:43:45.554]                         else {
[17:43:45.554]                           version <- NULL
[17:43:45.554]                         }
[17:43:45.554]                         if (!has_future || version < "1.8.0") {
[17:43:45.554]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:45.554]                             "", base::R.version$version.string), 
[17:43:45.554]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:45.554]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:45.554]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:45.554]                               "release", "version")], collapse = " "), 
[17:43:45.554]                             hostname = base::Sys.info()[["nodename"]])
[17:43:45.554]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:45.554]                             info)
[17:43:45.554]                           info <- base::paste(info, collapse = "; ")
[17:43:45.554]                           if (!has_future) {
[17:43:45.554]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:45.554]                               info)
[17:43:45.554]                           }
[17:43:45.554]                           else {
[17:43:45.554]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:45.554]                               info, version)
[17:43:45.554]                           }
[17:43:45.554]                           base::stop(msg)
[17:43:45.554]                         }
[17:43:45.554]                       })
[17:43:45.554]                     }
[17:43:45.554]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:45.554]                     base::options(mc.cores = 1L)
[17:43:45.554]                   }
[17:43:45.554]                   options(future.plan = NULL)
[17:43:45.554]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:45.554]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:45.554]                 }
[17:43:45.554]                 ...future.workdir <- getwd()
[17:43:45.554]             }
[17:43:45.554]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:45.554]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:45.554]         }
[17:43:45.554]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:45.554]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:45.554]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:45.554]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:45.554]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:45.554]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:45.554]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:45.554]             base::names(...future.oldOptions))
[17:43:45.554]     }
[17:43:45.554]     if (FALSE) {
[17:43:45.554]     }
[17:43:45.554]     else {
[17:43:45.554]         if (TRUE) {
[17:43:45.554]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:45.554]                 open = "w")
[17:43:45.554]         }
[17:43:45.554]         else {
[17:43:45.554]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:45.554]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:45.554]         }
[17:43:45.554]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:45.554]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:45.554]             base::sink(type = "output", split = FALSE)
[17:43:45.554]             base::close(...future.stdout)
[17:43:45.554]         }, add = TRUE)
[17:43:45.554]     }
[17:43:45.554]     ...future.frame <- base::sys.nframe()
[17:43:45.554]     ...future.conditions <- base::list()
[17:43:45.554]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:45.554]     if (FALSE) {
[17:43:45.554]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:45.554]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:45.554]     }
[17:43:45.554]     ...future.result <- base::tryCatch({
[17:43:45.554]         base::withCallingHandlers({
[17:43:45.554]             ...future.value <- base::withVisible(base::local({
[17:43:45.554]                 ...future.makeSendCondition <- local({
[17:43:45.554]                   sendCondition <- NULL
[17:43:45.554]                   function(frame = 1L) {
[17:43:45.554]                     if (is.function(sendCondition)) 
[17:43:45.554]                       return(sendCondition)
[17:43:45.554]                     ns <- getNamespace("parallel")
[17:43:45.554]                     if (exists("sendData", mode = "function", 
[17:43:45.554]                       envir = ns)) {
[17:43:45.554]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:45.554]                         envir = ns)
[17:43:45.554]                       envir <- sys.frame(frame)
[17:43:45.554]                       master <- NULL
[17:43:45.554]                       while (!identical(envir, .GlobalEnv) && 
[17:43:45.554]                         !identical(envir, emptyenv())) {
[17:43:45.554]                         if (exists("master", mode = "list", envir = envir, 
[17:43:45.554]                           inherits = FALSE)) {
[17:43:45.554]                           master <- get("master", mode = "list", 
[17:43:45.554]                             envir = envir, inherits = FALSE)
[17:43:45.554]                           if (inherits(master, c("SOCKnode", 
[17:43:45.554]                             "SOCK0node"))) {
[17:43:45.554]                             sendCondition <<- function(cond) {
[17:43:45.554]                               data <- list(type = "VALUE", value = cond, 
[17:43:45.554]                                 success = TRUE)
[17:43:45.554]                               parallel_sendData(master, data)
[17:43:45.554]                             }
[17:43:45.554]                             return(sendCondition)
[17:43:45.554]                           }
[17:43:45.554]                         }
[17:43:45.554]                         frame <- frame + 1L
[17:43:45.554]                         envir <- sys.frame(frame)
[17:43:45.554]                       }
[17:43:45.554]                     }
[17:43:45.554]                     sendCondition <<- function(cond) NULL
[17:43:45.554]                   }
[17:43:45.554]                 })
[17:43:45.554]                 withCallingHandlers({
[17:43:45.554]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:43:45.554]                 }, immediateCondition = function(cond) {
[17:43:45.554]                   sendCondition <- ...future.makeSendCondition()
[17:43:45.554]                   sendCondition(cond)
[17:43:45.554]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:45.554]                   {
[17:43:45.554]                     inherits <- base::inherits
[17:43:45.554]                     invokeRestart <- base::invokeRestart
[17:43:45.554]                     is.null <- base::is.null
[17:43:45.554]                     muffled <- FALSE
[17:43:45.554]                     if (inherits(cond, "message")) {
[17:43:45.554]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:45.554]                       if (muffled) 
[17:43:45.554]                         invokeRestart("muffleMessage")
[17:43:45.554]                     }
[17:43:45.554]                     else if (inherits(cond, "warning")) {
[17:43:45.554]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:45.554]                       if (muffled) 
[17:43:45.554]                         invokeRestart("muffleWarning")
[17:43:45.554]                     }
[17:43:45.554]                     else if (inherits(cond, "condition")) {
[17:43:45.554]                       if (!is.null(pattern)) {
[17:43:45.554]                         computeRestarts <- base::computeRestarts
[17:43:45.554]                         grepl <- base::grepl
[17:43:45.554]                         restarts <- computeRestarts(cond)
[17:43:45.554]                         for (restart in restarts) {
[17:43:45.554]                           name <- restart$name
[17:43:45.554]                           if (is.null(name)) 
[17:43:45.554]                             next
[17:43:45.554]                           if (!grepl(pattern, name)) 
[17:43:45.554]                             next
[17:43:45.554]                           invokeRestart(restart)
[17:43:45.554]                           muffled <- TRUE
[17:43:45.554]                           break
[17:43:45.554]                         }
[17:43:45.554]                       }
[17:43:45.554]                     }
[17:43:45.554]                     invisible(muffled)
[17:43:45.554]                   }
[17:43:45.554]                   muffleCondition(cond)
[17:43:45.554]                 })
[17:43:45.554]             }))
[17:43:45.554]             future::FutureResult(value = ...future.value$value, 
[17:43:45.554]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:45.554]                   ...future.rng), globalenv = if (FALSE) 
[17:43:45.554]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:45.554]                     ...future.globalenv.names))
[17:43:45.554]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:45.554]         }, condition = base::local({
[17:43:45.554]             c <- base::c
[17:43:45.554]             inherits <- base::inherits
[17:43:45.554]             invokeRestart <- base::invokeRestart
[17:43:45.554]             length <- base::length
[17:43:45.554]             list <- base::list
[17:43:45.554]             seq.int <- base::seq.int
[17:43:45.554]             signalCondition <- base::signalCondition
[17:43:45.554]             sys.calls <- base::sys.calls
[17:43:45.554]             `[[` <- base::`[[`
[17:43:45.554]             `+` <- base::`+`
[17:43:45.554]             `<<-` <- base::`<<-`
[17:43:45.554]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:45.554]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:45.554]                   3L)]
[17:43:45.554]             }
[17:43:45.554]             function(cond) {
[17:43:45.554]                 is_error <- inherits(cond, "error")
[17:43:45.554]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:45.554]                   NULL)
[17:43:45.554]                 if (is_error) {
[17:43:45.554]                   sessionInformation <- function() {
[17:43:45.554]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:45.554]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:45.554]                       search = base::search(), system = base::Sys.info())
[17:43:45.554]                   }
[17:43:45.554]                   ...future.conditions[[length(...future.conditions) + 
[17:43:45.554]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:45.554]                     cond$call), session = sessionInformation(), 
[17:43:45.554]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:45.554]                   signalCondition(cond)
[17:43:45.554]                 }
[17:43:45.554]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:45.554]                 "immediateCondition"))) {
[17:43:45.554]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:45.554]                   ...future.conditions[[length(...future.conditions) + 
[17:43:45.554]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:45.554]                   if (TRUE && !signal) {
[17:43:45.554]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:45.554]                     {
[17:43:45.554]                       inherits <- base::inherits
[17:43:45.554]                       invokeRestart <- base::invokeRestart
[17:43:45.554]                       is.null <- base::is.null
[17:43:45.554]                       muffled <- FALSE
[17:43:45.554]                       if (inherits(cond, "message")) {
[17:43:45.554]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:45.554]                         if (muffled) 
[17:43:45.554]                           invokeRestart("muffleMessage")
[17:43:45.554]                       }
[17:43:45.554]                       else if (inherits(cond, "warning")) {
[17:43:45.554]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:45.554]                         if (muffled) 
[17:43:45.554]                           invokeRestart("muffleWarning")
[17:43:45.554]                       }
[17:43:45.554]                       else if (inherits(cond, "condition")) {
[17:43:45.554]                         if (!is.null(pattern)) {
[17:43:45.554]                           computeRestarts <- base::computeRestarts
[17:43:45.554]                           grepl <- base::grepl
[17:43:45.554]                           restarts <- computeRestarts(cond)
[17:43:45.554]                           for (restart in restarts) {
[17:43:45.554]                             name <- restart$name
[17:43:45.554]                             if (is.null(name)) 
[17:43:45.554]                               next
[17:43:45.554]                             if (!grepl(pattern, name)) 
[17:43:45.554]                               next
[17:43:45.554]                             invokeRestart(restart)
[17:43:45.554]                             muffled <- TRUE
[17:43:45.554]                             break
[17:43:45.554]                           }
[17:43:45.554]                         }
[17:43:45.554]                       }
[17:43:45.554]                       invisible(muffled)
[17:43:45.554]                     }
[17:43:45.554]                     muffleCondition(cond, pattern = "^muffle")
[17:43:45.554]                   }
[17:43:45.554]                 }
[17:43:45.554]                 else {
[17:43:45.554]                   if (TRUE) {
[17:43:45.554]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:45.554]                     {
[17:43:45.554]                       inherits <- base::inherits
[17:43:45.554]                       invokeRestart <- base::invokeRestart
[17:43:45.554]                       is.null <- base::is.null
[17:43:45.554]                       muffled <- FALSE
[17:43:45.554]                       if (inherits(cond, "message")) {
[17:43:45.554]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:45.554]                         if (muffled) 
[17:43:45.554]                           invokeRestart("muffleMessage")
[17:43:45.554]                       }
[17:43:45.554]                       else if (inherits(cond, "warning")) {
[17:43:45.554]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:45.554]                         if (muffled) 
[17:43:45.554]                           invokeRestart("muffleWarning")
[17:43:45.554]                       }
[17:43:45.554]                       else if (inherits(cond, "condition")) {
[17:43:45.554]                         if (!is.null(pattern)) {
[17:43:45.554]                           computeRestarts <- base::computeRestarts
[17:43:45.554]                           grepl <- base::grepl
[17:43:45.554]                           restarts <- computeRestarts(cond)
[17:43:45.554]                           for (restart in restarts) {
[17:43:45.554]                             name <- restart$name
[17:43:45.554]                             if (is.null(name)) 
[17:43:45.554]                               next
[17:43:45.554]                             if (!grepl(pattern, name)) 
[17:43:45.554]                               next
[17:43:45.554]                             invokeRestart(restart)
[17:43:45.554]                             muffled <- TRUE
[17:43:45.554]                             break
[17:43:45.554]                           }
[17:43:45.554]                         }
[17:43:45.554]                       }
[17:43:45.554]                       invisible(muffled)
[17:43:45.554]                     }
[17:43:45.554]                     muffleCondition(cond, pattern = "^muffle")
[17:43:45.554]                   }
[17:43:45.554]                 }
[17:43:45.554]             }
[17:43:45.554]         }))
[17:43:45.554]     }, error = function(ex) {
[17:43:45.554]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:45.554]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:45.554]                 ...future.rng), started = ...future.startTime, 
[17:43:45.554]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:45.554]             version = "1.8"), class = "FutureResult")
[17:43:45.554]     }, finally = {
[17:43:45.554]         if (!identical(...future.workdir, getwd())) 
[17:43:45.554]             setwd(...future.workdir)
[17:43:45.554]         {
[17:43:45.554]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:45.554]                 ...future.oldOptions$nwarnings <- NULL
[17:43:45.554]             }
[17:43:45.554]             base::options(...future.oldOptions)
[17:43:45.554]             if (.Platform$OS.type == "windows") {
[17:43:45.554]                 old_names <- names(...future.oldEnvVars)
[17:43:45.554]                 envs <- base::Sys.getenv()
[17:43:45.554]                 names <- names(envs)
[17:43:45.554]                 common <- intersect(names, old_names)
[17:43:45.554]                 added <- setdiff(names, old_names)
[17:43:45.554]                 removed <- setdiff(old_names, names)
[17:43:45.554]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:45.554]                   envs[common]]
[17:43:45.554]                 NAMES <- toupper(changed)
[17:43:45.554]                 args <- list()
[17:43:45.554]                 for (kk in seq_along(NAMES)) {
[17:43:45.554]                   name <- changed[[kk]]
[17:43:45.554]                   NAME <- NAMES[[kk]]
[17:43:45.554]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:45.554]                     next
[17:43:45.554]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:45.554]                 }
[17:43:45.554]                 NAMES <- toupper(added)
[17:43:45.554]                 for (kk in seq_along(NAMES)) {
[17:43:45.554]                   name <- added[[kk]]
[17:43:45.554]                   NAME <- NAMES[[kk]]
[17:43:45.554]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:45.554]                     next
[17:43:45.554]                   args[[name]] <- ""
[17:43:45.554]                 }
[17:43:45.554]                 NAMES <- toupper(removed)
[17:43:45.554]                 for (kk in seq_along(NAMES)) {
[17:43:45.554]                   name <- removed[[kk]]
[17:43:45.554]                   NAME <- NAMES[[kk]]
[17:43:45.554]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:45.554]                     next
[17:43:45.554]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:45.554]                 }
[17:43:45.554]                 if (length(args) > 0) 
[17:43:45.554]                   base::do.call(base::Sys.setenv, args = args)
[17:43:45.554]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:45.554]             }
[17:43:45.554]             else {
[17:43:45.554]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:45.554]             }
[17:43:45.554]             {
[17:43:45.554]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:45.554]                   0L) {
[17:43:45.554]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:45.554]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:45.554]                   base::options(opts)
[17:43:45.554]                 }
[17:43:45.554]                 {
[17:43:45.554]                   {
[17:43:45.554]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:45.554]                     NULL
[17:43:45.554]                   }
[17:43:45.554]                   options(future.plan = NULL)
[17:43:45.554]                   if (is.na(NA_character_)) 
[17:43:45.554]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:45.554]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:45.554]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:45.554]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:45.554]                     envir = parent.frame()) 
[17:43:45.554]                   {
[17:43:45.554]                     if (is.function(workers)) 
[17:43:45.554]                       workers <- workers()
[17:43:45.554]                     workers <- structure(as.integer(workers), 
[17:43:45.554]                       class = class(workers))
[17:43:45.554]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:45.554]                       workers >= 1)
[17:43:45.554]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:45.554]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:45.554]                     }
[17:43:45.554]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:45.554]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:45.554]                       envir = envir)
[17:43:45.554]                     if (!future$lazy) 
[17:43:45.554]                       future <- run(future)
[17:43:45.554]                     invisible(future)
[17:43:45.554]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:45.554]                 }
[17:43:45.554]             }
[17:43:45.554]         }
[17:43:45.554]     })
[17:43:45.554]     if (TRUE) {
[17:43:45.554]         base::sink(type = "output", split = FALSE)
[17:43:45.554]         if (TRUE) {
[17:43:45.554]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:45.554]         }
[17:43:45.554]         else {
[17:43:45.554]             ...future.result["stdout"] <- base::list(NULL)
[17:43:45.554]         }
[17:43:45.554]         base::close(...future.stdout)
[17:43:45.554]         ...future.stdout <- NULL
[17:43:45.554]     }
[17:43:45.554]     ...future.result$conditions <- ...future.conditions
[17:43:45.554]     ...future.result$finished <- base::Sys.time()
[17:43:45.554]     ...future.result
[17:43:45.554] }
[17:43:45.557] MultisessionFuture started
[17:43:45.557] - Launch lazy future ... done
[17:43:45.557] run() for ‘MultisessionFuture’ ... done
[17:43:45.604] receiveMessageFromWorker() for ClusterFuture ...
[17:43:45.604] - Validating connection of MultisessionFuture
[17:43:45.605] - received message: FutureResult
[17:43:45.605] - Received FutureResult
[17:43:45.605] - Erased future from FutureRegistry
[17:43:45.605] result() for ClusterFuture ...
[17:43:45.605] - result already collected: FutureResult
[17:43:45.605] result() for ClusterFuture ... done
[17:43:45.605] signalConditions() ...
[17:43:45.605]  - include = ‘immediateCondition’
[17:43:45.605]  - exclude = 
[17:43:45.605]  - resignal = FALSE
[17:43:45.606]  - Number of conditions: 1
[17:43:45.606] signalConditions() ... done
[17:43:45.606] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:45.606] A MultisessionFuture was resolved (result was not collected)
[17:43:45.606] getGlobalsAndPackages() ...
[17:43:45.606] Searching for globals...
[17:43:45.607] - globals found: [2] ‘list’, ‘stop’
[17:43:45.607] Searching for globals ... DONE
[17:43:45.607] Resolving globals: FALSE
[17:43:45.607] 
[17:43:45.607] 
[17:43:45.608] getGlobalsAndPackages() ... DONE
[17:43:45.608] run() for ‘Future’ ...
[17:43:45.608] - state: ‘created’
[17:43:45.608] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:45.622] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:45.622] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:45.622]   - Field: ‘node’
[17:43:45.623]   - Field: ‘label’
[17:43:45.623]   - Field: ‘local’
[17:43:45.623]   - Field: ‘owner’
[17:43:45.623]   - Field: ‘envir’
[17:43:45.623]   - Field: ‘workers’
[17:43:45.623]   - Field: ‘packages’
[17:43:45.623]   - Field: ‘gc’
[17:43:45.623]   - Field: ‘conditions’
[17:43:45.623]   - Field: ‘persistent’
[17:43:45.624]   - Field: ‘expr’
[17:43:45.624]   - Field: ‘uuid’
[17:43:45.624]   - Field: ‘seed’
[17:43:45.624]   - Field: ‘version’
[17:43:45.624]   - Field: ‘result’
[17:43:45.624]   - Field: ‘asynchronous’
[17:43:45.624]   - Field: ‘calls’
[17:43:45.624]   - Field: ‘globals’
[17:43:45.624]   - Field: ‘stdout’
[17:43:45.624]   - Field: ‘earlySignal’
[17:43:45.624]   - Field: ‘lazy’
[17:43:45.625]   - Field: ‘state’
[17:43:45.625] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:45.625] - Launch lazy future ...
[17:43:45.625] Packages needed by the future expression (n = 0): <none>
[17:43:45.625] Packages needed by future strategies (n = 0): <none>
[17:43:45.626] {
[17:43:45.626]     {
[17:43:45.626]         {
[17:43:45.626]             ...future.startTime <- base::Sys.time()
[17:43:45.626]             {
[17:43:45.626]                 {
[17:43:45.626]                   {
[17:43:45.626]                     {
[17:43:45.626]                       base::local({
[17:43:45.626]                         has_future <- base::requireNamespace("future", 
[17:43:45.626]                           quietly = TRUE)
[17:43:45.626]                         if (has_future) {
[17:43:45.626]                           ns <- base::getNamespace("future")
[17:43:45.626]                           version <- ns[[".package"]][["version"]]
[17:43:45.626]                           if (is.null(version)) 
[17:43:45.626]                             version <- utils::packageVersion("future")
[17:43:45.626]                         }
[17:43:45.626]                         else {
[17:43:45.626]                           version <- NULL
[17:43:45.626]                         }
[17:43:45.626]                         if (!has_future || version < "1.8.0") {
[17:43:45.626]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:45.626]                             "", base::R.version$version.string), 
[17:43:45.626]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:45.626]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:45.626]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:45.626]                               "release", "version")], collapse = " "), 
[17:43:45.626]                             hostname = base::Sys.info()[["nodename"]])
[17:43:45.626]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:45.626]                             info)
[17:43:45.626]                           info <- base::paste(info, collapse = "; ")
[17:43:45.626]                           if (!has_future) {
[17:43:45.626]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:45.626]                               info)
[17:43:45.626]                           }
[17:43:45.626]                           else {
[17:43:45.626]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:45.626]                               info, version)
[17:43:45.626]                           }
[17:43:45.626]                           base::stop(msg)
[17:43:45.626]                         }
[17:43:45.626]                       })
[17:43:45.626]                     }
[17:43:45.626]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:45.626]                     base::options(mc.cores = 1L)
[17:43:45.626]                   }
[17:43:45.626]                   options(future.plan = NULL)
[17:43:45.626]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:45.626]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:45.626]                 }
[17:43:45.626]                 ...future.workdir <- getwd()
[17:43:45.626]             }
[17:43:45.626]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:45.626]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:45.626]         }
[17:43:45.626]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:45.626]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:45.626]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:45.626]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:45.626]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:45.626]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:45.626]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:45.626]             base::names(...future.oldOptions))
[17:43:45.626]     }
[17:43:45.626]     if (FALSE) {
[17:43:45.626]     }
[17:43:45.626]     else {
[17:43:45.626]         if (TRUE) {
[17:43:45.626]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:45.626]                 open = "w")
[17:43:45.626]         }
[17:43:45.626]         else {
[17:43:45.626]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:45.626]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:45.626]         }
[17:43:45.626]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:45.626]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:45.626]             base::sink(type = "output", split = FALSE)
[17:43:45.626]             base::close(...future.stdout)
[17:43:45.626]         }, add = TRUE)
[17:43:45.626]     }
[17:43:45.626]     ...future.frame <- base::sys.nframe()
[17:43:45.626]     ...future.conditions <- base::list()
[17:43:45.626]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:45.626]     if (FALSE) {
[17:43:45.626]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:45.626]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:45.626]     }
[17:43:45.626]     ...future.result <- base::tryCatch({
[17:43:45.626]         base::withCallingHandlers({
[17:43:45.626]             ...future.value <- base::withVisible(base::local({
[17:43:45.626]                 ...future.makeSendCondition <- local({
[17:43:45.626]                   sendCondition <- NULL
[17:43:45.626]                   function(frame = 1L) {
[17:43:45.626]                     if (is.function(sendCondition)) 
[17:43:45.626]                       return(sendCondition)
[17:43:45.626]                     ns <- getNamespace("parallel")
[17:43:45.626]                     if (exists("sendData", mode = "function", 
[17:43:45.626]                       envir = ns)) {
[17:43:45.626]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:45.626]                         envir = ns)
[17:43:45.626]                       envir <- sys.frame(frame)
[17:43:45.626]                       master <- NULL
[17:43:45.626]                       while (!identical(envir, .GlobalEnv) && 
[17:43:45.626]                         !identical(envir, emptyenv())) {
[17:43:45.626]                         if (exists("master", mode = "list", envir = envir, 
[17:43:45.626]                           inherits = FALSE)) {
[17:43:45.626]                           master <- get("master", mode = "list", 
[17:43:45.626]                             envir = envir, inherits = FALSE)
[17:43:45.626]                           if (inherits(master, c("SOCKnode", 
[17:43:45.626]                             "SOCK0node"))) {
[17:43:45.626]                             sendCondition <<- function(cond) {
[17:43:45.626]                               data <- list(type = "VALUE", value = cond, 
[17:43:45.626]                                 success = TRUE)
[17:43:45.626]                               parallel_sendData(master, data)
[17:43:45.626]                             }
[17:43:45.626]                             return(sendCondition)
[17:43:45.626]                           }
[17:43:45.626]                         }
[17:43:45.626]                         frame <- frame + 1L
[17:43:45.626]                         envir <- sys.frame(frame)
[17:43:45.626]                       }
[17:43:45.626]                     }
[17:43:45.626]                     sendCondition <<- function(cond) NULL
[17:43:45.626]                   }
[17:43:45.626]                 })
[17:43:45.626]                 withCallingHandlers({
[17:43:45.626]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:43:45.626]                 }, immediateCondition = function(cond) {
[17:43:45.626]                   sendCondition <- ...future.makeSendCondition()
[17:43:45.626]                   sendCondition(cond)
[17:43:45.626]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:45.626]                   {
[17:43:45.626]                     inherits <- base::inherits
[17:43:45.626]                     invokeRestart <- base::invokeRestart
[17:43:45.626]                     is.null <- base::is.null
[17:43:45.626]                     muffled <- FALSE
[17:43:45.626]                     if (inherits(cond, "message")) {
[17:43:45.626]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:45.626]                       if (muffled) 
[17:43:45.626]                         invokeRestart("muffleMessage")
[17:43:45.626]                     }
[17:43:45.626]                     else if (inherits(cond, "warning")) {
[17:43:45.626]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:45.626]                       if (muffled) 
[17:43:45.626]                         invokeRestart("muffleWarning")
[17:43:45.626]                     }
[17:43:45.626]                     else if (inherits(cond, "condition")) {
[17:43:45.626]                       if (!is.null(pattern)) {
[17:43:45.626]                         computeRestarts <- base::computeRestarts
[17:43:45.626]                         grepl <- base::grepl
[17:43:45.626]                         restarts <- computeRestarts(cond)
[17:43:45.626]                         for (restart in restarts) {
[17:43:45.626]                           name <- restart$name
[17:43:45.626]                           if (is.null(name)) 
[17:43:45.626]                             next
[17:43:45.626]                           if (!grepl(pattern, name)) 
[17:43:45.626]                             next
[17:43:45.626]                           invokeRestart(restart)
[17:43:45.626]                           muffled <- TRUE
[17:43:45.626]                           break
[17:43:45.626]                         }
[17:43:45.626]                       }
[17:43:45.626]                     }
[17:43:45.626]                     invisible(muffled)
[17:43:45.626]                   }
[17:43:45.626]                   muffleCondition(cond)
[17:43:45.626]                 })
[17:43:45.626]             }))
[17:43:45.626]             future::FutureResult(value = ...future.value$value, 
[17:43:45.626]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:45.626]                   ...future.rng), globalenv = if (FALSE) 
[17:43:45.626]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:45.626]                     ...future.globalenv.names))
[17:43:45.626]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:45.626]         }, condition = base::local({
[17:43:45.626]             c <- base::c
[17:43:45.626]             inherits <- base::inherits
[17:43:45.626]             invokeRestart <- base::invokeRestart
[17:43:45.626]             length <- base::length
[17:43:45.626]             list <- base::list
[17:43:45.626]             seq.int <- base::seq.int
[17:43:45.626]             signalCondition <- base::signalCondition
[17:43:45.626]             sys.calls <- base::sys.calls
[17:43:45.626]             `[[` <- base::`[[`
[17:43:45.626]             `+` <- base::`+`
[17:43:45.626]             `<<-` <- base::`<<-`
[17:43:45.626]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:45.626]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:45.626]                   3L)]
[17:43:45.626]             }
[17:43:45.626]             function(cond) {
[17:43:45.626]                 is_error <- inherits(cond, "error")
[17:43:45.626]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:45.626]                   NULL)
[17:43:45.626]                 if (is_error) {
[17:43:45.626]                   sessionInformation <- function() {
[17:43:45.626]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:45.626]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:45.626]                       search = base::search(), system = base::Sys.info())
[17:43:45.626]                   }
[17:43:45.626]                   ...future.conditions[[length(...future.conditions) + 
[17:43:45.626]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:45.626]                     cond$call), session = sessionInformation(), 
[17:43:45.626]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:45.626]                   signalCondition(cond)
[17:43:45.626]                 }
[17:43:45.626]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:45.626]                 "immediateCondition"))) {
[17:43:45.626]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:45.626]                   ...future.conditions[[length(...future.conditions) + 
[17:43:45.626]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:45.626]                   if (TRUE && !signal) {
[17:43:45.626]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:45.626]                     {
[17:43:45.626]                       inherits <- base::inherits
[17:43:45.626]                       invokeRestart <- base::invokeRestart
[17:43:45.626]                       is.null <- base::is.null
[17:43:45.626]                       muffled <- FALSE
[17:43:45.626]                       if (inherits(cond, "message")) {
[17:43:45.626]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:45.626]                         if (muffled) 
[17:43:45.626]                           invokeRestart("muffleMessage")
[17:43:45.626]                       }
[17:43:45.626]                       else if (inherits(cond, "warning")) {
[17:43:45.626]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:45.626]                         if (muffled) 
[17:43:45.626]                           invokeRestart("muffleWarning")
[17:43:45.626]                       }
[17:43:45.626]                       else if (inherits(cond, "condition")) {
[17:43:45.626]                         if (!is.null(pattern)) {
[17:43:45.626]                           computeRestarts <- base::computeRestarts
[17:43:45.626]                           grepl <- base::grepl
[17:43:45.626]                           restarts <- computeRestarts(cond)
[17:43:45.626]                           for (restart in restarts) {
[17:43:45.626]                             name <- restart$name
[17:43:45.626]                             if (is.null(name)) 
[17:43:45.626]                               next
[17:43:45.626]                             if (!grepl(pattern, name)) 
[17:43:45.626]                               next
[17:43:45.626]                             invokeRestart(restart)
[17:43:45.626]                             muffled <- TRUE
[17:43:45.626]                             break
[17:43:45.626]                           }
[17:43:45.626]                         }
[17:43:45.626]                       }
[17:43:45.626]                       invisible(muffled)
[17:43:45.626]                     }
[17:43:45.626]                     muffleCondition(cond, pattern = "^muffle")
[17:43:45.626]                   }
[17:43:45.626]                 }
[17:43:45.626]                 else {
[17:43:45.626]                   if (TRUE) {
[17:43:45.626]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:45.626]                     {
[17:43:45.626]                       inherits <- base::inherits
[17:43:45.626]                       invokeRestart <- base::invokeRestart
[17:43:45.626]                       is.null <- base::is.null
[17:43:45.626]                       muffled <- FALSE
[17:43:45.626]                       if (inherits(cond, "message")) {
[17:43:45.626]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:45.626]                         if (muffled) 
[17:43:45.626]                           invokeRestart("muffleMessage")
[17:43:45.626]                       }
[17:43:45.626]                       else if (inherits(cond, "warning")) {
[17:43:45.626]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:45.626]                         if (muffled) 
[17:43:45.626]                           invokeRestart("muffleWarning")
[17:43:45.626]                       }
[17:43:45.626]                       else if (inherits(cond, "condition")) {
[17:43:45.626]                         if (!is.null(pattern)) {
[17:43:45.626]                           computeRestarts <- base::computeRestarts
[17:43:45.626]                           grepl <- base::grepl
[17:43:45.626]                           restarts <- computeRestarts(cond)
[17:43:45.626]                           for (restart in restarts) {
[17:43:45.626]                             name <- restart$name
[17:43:45.626]                             if (is.null(name)) 
[17:43:45.626]                               next
[17:43:45.626]                             if (!grepl(pattern, name)) 
[17:43:45.626]                               next
[17:43:45.626]                             invokeRestart(restart)
[17:43:45.626]                             muffled <- TRUE
[17:43:45.626]                             break
[17:43:45.626]                           }
[17:43:45.626]                         }
[17:43:45.626]                       }
[17:43:45.626]                       invisible(muffled)
[17:43:45.626]                     }
[17:43:45.626]                     muffleCondition(cond, pattern = "^muffle")
[17:43:45.626]                   }
[17:43:45.626]                 }
[17:43:45.626]             }
[17:43:45.626]         }))
[17:43:45.626]     }, error = function(ex) {
[17:43:45.626]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:45.626]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:45.626]                 ...future.rng), started = ...future.startTime, 
[17:43:45.626]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:45.626]             version = "1.8"), class = "FutureResult")
[17:43:45.626]     }, finally = {
[17:43:45.626]         if (!identical(...future.workdir, getwd())) 
[17:43:45.626]             setwd(...future.workdir)
[17:43:45.626]         {
[17:43:45.626]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:45.626]                 ...future.oldOptions$nwarnings <- NULL
[17:43:45.626]             }
[17:43:45.626]             base::options(...future.oldOptions)
[17:43:45.626]             if (.Platform$OS.type == "windows") {
[17:43:45.626]                 old_names <- names(...future.oldEnvVars)
[17:43:45.626]                 envs <- base::Sys.getenv()
[17:43:45.626]                 names <- names(envs)
[17:43:45.626]                 common <- intersect(names, old_names)
[17:43:45.626]                 added <- setdiff(names, old_names)
[17:43:45.626]                 removed <- setdiff(old_names, names)
[17:43:45.626]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:45.626]                   envs[common]]
[17:43:45.626]                 NAMES <- toupper(changed)
[17:43:45.626]                 args <- list()
[17:43:45.626]                 for (kk in seq_along(NAMES)) {
[17:43:45.626]                   name <- changed[[kk]]
[17:43:45.626]                   NAME <- NAMES[[kk]]
[17:43:45.626]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:45.626]                     next
[17:43:45.626]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:45.626]                 }
[17:43:45.626]                 NAMES <- toupper(added)
[17:43:45.626]                 for (kk in seq_along(NAMES)) {
[17:43:45.626]                   name <- added[[kk]]
[17:43:45.626]                   NAME <- NAMES[[kk]]
[17:43:45.626]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:45.626]                     next
[17:43:45.626]                   args[[name]] <- ""
[17:43:45.626]                 }
[17:43:45.626]                 NAMES <- toupper(removed)
[17:43:45.626]                 for (kk in seq_along(NAMES)) {
[17:43:45.626]                   name <- removed[[kk]]
[17:43:45.626]                   NAME <- NAMES[[kk]]
[17:43:45.626]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:45.626]                     next
[17:43:45.626]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:45.626]                 }
[17:43:45.626]                 if (length(args) > 0) 
[17:43:45.626]                   base::do.call(base::Sys.setenv, args = args)
[17:43:45.626]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:45.626]             }
[17:43:45.626]             else {
[17:43:45.626]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:45.626]             }
[17:43:45.626]             {
[17:43:45.626]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:45.626]                   0L) {
[17:43:45.626]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:45.626]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:45.626]                   base::options(opts)
[17:43:45.626]                 }
[17:43:45.626]                 {
[17:43:45.626]                   {
[17:43:45.626]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:45.626]                     NULL
[17:43:45.626]                   }
[17:43:45.626]                   options(future.plan = NULL)
[17:43:45.626]                   if (is.na(NA_character_)) 
[17:43:45.626]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:45.626]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:45.626]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:45.626]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:45.626]                     envir = parent.frame()) 
[17:43:45.626]                   {
[17:43:45.626]                     if (is.function(workers)) 
[17:43:45.626]                       workers <- workers()
[17:43:45.626]                     workers <- structure(as.integer(workers), 
[17:43:45.626]                       class = class(workers))
[17:43:45.626]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:45.626]                       workers >= 1)
[17:43:45.626]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:45.626]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:45.626]                     }
[17:43:45.626]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:45.626]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:45.626]                       envir = envir)
[17:43:45.626]                     if (!future$lazy) 
[17:43:45.626]                       future <- run(future)
[17:43:45.626]                     invisible(future)
[17:43:45.626]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:45.626]                 }
[17:43:45.626]             }
[17:43:45.626]         }
[17:43:45.626]     })
[17:43:45.626]     if (TRUE) {
[17:43:45.626]         base::sink(type = "output", split = FALSE)
[17:43:45.626]         if (TRUE) {
[17:43:45.626]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:45.626]         }
[17:43:45.626]         else {
[17:43:45.626]             ...future.result["stdout"] <- base::list(NULL)
[17:43:45.626]         }
[17:43:45.626]         base::close(...future.stdout)
[17:43:45.626]         ...future.stdout <- NULL
[17:43:45.626]     }
[17:43:45.626]     ...future.result$conditions <- ...future.conditions
[17:43:45.626]     ...future.result$finished <- base::Sys.time()
[17:43:45.626]     ...future.result
[17:43:45.626] }
[17:43:45.629] MultisessionFuture started
[17:43:45.629] - Launch lazy future ... done
[17:43:45.629] run() for ‘MultisessionFuture’ ... done
[17:43:45.676] receiveMessageFromWorker() for ClusterFuture ...
[17:43:45.676] - Validating connection of MultisessionFuture
[17:43:45.676] - received message: FutureResult
[17:43:45.676] - Received FutureResult
[17:43:45.677] - Erased future from FutureRegistry
[17:43:45.677] result() for ClusterFuture ...
[17:43:45.677] - result already collected: FutureResult
[17:43:45.677] result() for ClusterFuture ... done
[17:43:45.677] signalConditions() ...
[17:43:45.677]  - include = ‘immediateCondition’
[17:43:45.677]  - exclude = 
[17:43:45.677]  - resignal = FALSE
[17:43:45.677]  - Number of conditions: 1
[17:43:45.677] signalConditions() ... done
[17:43:45.678] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:45.678] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = Inf ... DONE
- result = TRUE, recursive = FALSE ...
[17:43:45.678] getGlobalsAndPackages() ...
[17:43:45.678] Searching for globals...
[17:43:45.679] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:43:45.679] Searching for globals ... DONE
[17:43:45.679] Resolving globals: FALSE
[17:43:45.680] 
[17:43:45.680] 
[17:43:45.680] getGlobalsAndPackages() ... DONE
[17:43:45.680] run() for ‘Future’ ...
[17:43:45.680] - state: ‘created’
[17:43:45.680] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:45.694] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:45.695] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:45.695]   - Field: ‘node’
[17:43:45.695]   - Field: ‘label’
[17:43:45.695]   - Field: ‘local’
[17:43:45.695]   - Field: ‘owner’
[17:43:45.695]   - Field: ‘envir’
[17:43:45.695]   - Field: ‘workers’
[17:43:45.695]   - Field: ‘packages’
[17:43:45.695]   - Field: ‘gc’
[17:43:45.696]   - Field: ‘conditions’
[17:43:45.696]   - Field: ‘persistent’
[17:43:45.696]   - Field: ‘expr’
[17:43:45.696]   - Field: ‘uuid’
[17:43:45.696]   - Field: ‘seed’
[17:43:45.696]   - Field: ‘version’
[17:43:45.696]   - Field: ‘result’
[17:43:45.696]   - Field: ‘asynchronous’
[17:43:45.696]   - Field: ‘calls’
[17:43:45.696]   - Field: ‘globals’
[17:43:45.696]   - Field: ‘stdout’
[17:43:45.697]   - Field: ‘earlySignal’
[17:43:45.697]   - Field: ‘lazy’
[17:43:45.697]   - Field: ‘state’
[17:43:45.697] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:45.697] - Launch lazy future ...
[17:43:45.697] Packages needed by the future expression (n = 0): <none>
[17:43:45.697] Packages needed by future strategies (n = 0): <none>
[17:43:45.698] {
[17:43:45.698]     {
[17:43:45.698]         {
[17:43:45.698]             ...future.startTime <- base::Sys.time()
[17:43:45.698]             {
[17:43:45.698]                 {
[17:43:45.698]                   {
[17:43:45.698]                     {
[17:43:45.698]                       base::local({
[17:43:45.698]                         has_future <- base::requireNamespace("future", 
[17:43:45.698]                           quietly = TRUE)
[17:43:45.698]                         if (has_future) {
[17:43:45.698]                           ns <- base::getNamespace("future")
[17:43:45.698]                           version <- ns[[".package"]][["version"]]
[17:43:45.698]                           if (is.null(version)) 
[17:43:45.698]                             version <- utils::packageVersion("future")
[17:43:45.698]                         }
[17:43:45.698]                         else {
[17:43:45.698]                           version <- NULL
[17:43:45.698]                         }
[17:43:45.698]                         if (!has_future || version < "1.8.0") {
[17:43:45.698]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:45.698]                             "", base::R.version$version.string), 
[17:43:45.698]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:45.698]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:45.698]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:45.698]                               "release", "version")], collapse = " "), 
[17:43:45.698]                             hostname = base::Sys.info()[["nodename"]])
[17:43:45.698]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:45.698]                             info)
[17:43:45.698]                           info <- base::paste(info, collapse = "; ")
[17:43:45.698]                           if (!has_future) {
[17:43:45.698]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:45.698]                               info)
[17:43:45.698]                           }
[17:43:45.698]                           else {
[17:43:45.698]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:45.698]                               info, version)
[17:43:45.698]                           }
[17:43:45.698]                           base::stop(msg)
[17:43:45.698]                         }
[17:43:45.698]                       })
[17:43:45.698]                     }
[17:43:45.698]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:45.698]                     base::options(mc.cores = 1L)
[17:43:45.698]                   }
[17:43:45.698]                   options(future.plan = NULL)
[17:43:45.698]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:45.698]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:45.698]                 }
[17:43:45.698]                 ...future.workdir <- getwd()
[17:43:45.698]             }
[17:43:45.698]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:45.698]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:45.698]         }
[17:43:45.698]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:45.698]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:45.698]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:45.698]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:45.698]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:45.698]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:45.698]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:45.698]             base::names(...future.oldOptions))
[17:43:45.698]     }
[17:43:45.698]     if (FALSE) {
[17:43:45.698]     }
[17:43:45.698]     else {
[17:43:45.698]         if (TRUE) {
[17:43:45.698]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:45.698]                 open = "w")
[17:43:45.698]         }
[17:43:45.698]         else {
[17:43:45.698]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:45.698]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:45.698]         }
[17:43:45.698]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:45.698]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:45.698]             base::sink(type = "output", split = FALSE)
[17:43:45.698]             base::close(...future.stdout)
[17:43:45.698]         }, add = TRUE)
[17:43:45.698]     }
[17:43:45.698]     ...future.frame <- base::sys.nframe()
[17:43:45.698]     ...future.conditions <- base::list()
[17:43:45.698]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:45.698]     if (FALSE) {
[17:43:45.698]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:45.698]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:45.698]     }
[17:43:45.698]     ...future.result <- base::tryCatch({
[17:43:45.698]         base::withCallingHandlers({
[17:43:45.698]             ...future.value <- base::withVisible(base::local({
[17:43:45.698]                 ...future.makeSendCondition <- local({
[17:43:45.698]                   sendCondition <- NULL
[17:43:45.698]                   function(frame = 1L) {
[17:43:45.698]                     if (is.function(sendCondition)) 
[17:43:45.698]                       return(sendCondition)
[17:43:45.698]                     ns <- getNamespace("parallel")
[17:43:45.698]                     if (exists("sendData", mode = "function", 
[17:43:45.698]                       envir = ns)) {
[17:43:45.698]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:45.698]                         envir = ns)
[17:43:45.698]                       envir <- sys.frame(frame)
[17:43:45.698]                       master <- NULL
[17:43:45.698]                       while (!identical(envir, .GlobalEnv) && 
[17:43:45.698]                         !identical(envir, emptyenv())) {
[17:43:45.698]                         if (exists("master", mode = "list", envir = envir, 
[17:43:45.698]                           inherits = FALSE)) {
[17:43:45.698]                           master <- get("master", mode = "list", 
[17:43:45.698]                             envir = envir, inherits = FALSE)
[17:43:45.698]                           if (inherits(master, c("SOCKnode", 
[17:43:45.698]                             "SOCK0node"))) {
[17:43:45.698]                             sendCondition <<- function(cond) {
[17:43:45.698]                               data <- list(type = "VALUE", value = cond, 
[17:43:45.698]                                 success = TRUE)
[17:43:45.698]                               parallel_sendData(master, data)
[17:43:45.698]                             }
[17:43:45.698]                             return(sendCondition)
[17:43:45.698]                           }
[17:43:45.698]                         }
[17:43:45.698]                         frame <- frame + 1L
[17:43:45.698]                         envir <- sys.frame(frame)
[17:43:45.698]                       }
[17:43:45.698]                     }
[17:43:45.698]                     sendCondition <<- function(cond) NULL
[17:43:45.698]                   }
[17:43:45.698]                 })
[17:43:45.698]                 withCallingHandlers({
[17:43:45.698]                   {
[17:43:45.698]                     Sys.sleep(0.5)
[17:43:45.698]                     list(a = 1, b = 42L)
[17:43:45.698]                   }
[17:43:45.698]                 }, immediateCondition = function(cond) {
[17:43:45.698]                   sendCondition <- ...future.makeSendCondition()
[17:43:45.698]                   sendCondition(cond)
[17:43:45.698]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:45.698]                   {
[17:43:45.698]                     inherits <- base::inherits
[17:43:45.698]                     invokeRestart <- base::invokeRestart
[17:43:45.698]                     is.null <- base::is.null
[17:43:45.698]                     muffled <- FALSE
[17:43:45.698]                     if (inherits(cond, "message")) {
[17:43:45.698]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:45.698]                       if (muffled) 
[17:43:45.698]                         invokeRestart("muffleMessage")
[17:43:45.698]                     }
[17:43:45.698]                     else if (inherits(cond, "warning")) {
[17:43:45.698]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:45.698]                       if (muffled) 
[17:43:45.698]                         invokeRestart("muffleWarning")
[17:43:45.698]                     }
[17:43:45.698]                     else if (inherits(cond, "condition")) {
[17:43:45.698]                       if (!is.null(pattern)) {
[17:43:45.698]                         computeRestarts <- base::computeRestarts
[17:43:45.698]                         grepl <- base::grepl
[17:43:45.698]                         restarts <- computeRestarts(cond)
[17:43:45.698]                         for (restart in restarts) {
[17:43:45.698]                           name <- restart$name
[17:43:45.698]                           if (is.null(name)) 
[17:43:45.698]                             next
[17:43:45.698]                           if (!grepl(pattern, name)) 
[17:43:45.698]                             next
[17:43:45.698]                           invokeRestart(restart)
[17:43:45.698]                           muffled <- TRUE
[17:43:45.698]                           break
[17:43:45.698]                         }
[17:43:45.698]                       }
[17:43:45.698]                     }
[17:43:45.698]                     invisible(muffled)
[17:43:45.698]                   }
[17:43:45.698]                   muffleCondition(cond)
[17:43:45.698]                 })
[17:43:45.698]             }))
[17:43:45.698]             future::FutureResult(value = ...future.value$value, 
[17:43:45.698]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:45.698]                   ...future.rng), globalenv = if (FALSE) 
[17:43:45.698]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:45.698]                     ...future.globalenv.names))
[17:43:45.698]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:45.698]         }, condition = base::local({
[17:43:45.698]             c <- base::c
[17:43:45.698]             inherits <- base::inherits
[17:43:45.698]             invokeRestart <- base::invokeRestart
[17:43:45.698]             length <- base::length
[17:43:45.698]             list <- base::list
[17:43:45.698]             seq.int <- base::seq.int
[17:43:45.698]             signalCondition <- base::signalCondition
[17:43:45.698]             sys.calls <- base::sys.calls
[17:43:45.698]             `[[` <- base::`[[`
[17:43:45.698]             `+` <- base::`+`
[17:43:45.698]             `<<-` <- base::`<<-`
[17:43:45.698]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:45.698]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:45.698]                   3L)]
[17:43:45.698]             }
[17:43:45.698]             function(cond) {
[17:43:45.698]                 is_error <- inherits(cond, "error")
[17:43:45.698]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:45.698]                   NULL)
[17:43:45.698]                 if (is_error) {
[17:43:45.698]                   sessionInformation <- function() {
[17:43:45.698]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:45.698]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:45.698]                       search = base::search(), system = base::Sys.info())
[17:43:45.698]                   }
[17:43:45.698]                   ...future.conditions[[length(...future.conditions) + 
[17:43:45.698]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:45.698]                     cond$call), session = sessionInformation(), 
[17:43:45.698]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:45.698]                   signalCondition(cond)
[17:43:45.698]                 }
[17:43:45.698]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:45.698]                 "immediateCondition"))) {
[17:43:45.698]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:45.698]                   ...future.conditions[[length(...future.conditions) + 
[17:43:45.698]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:45.698]                   if (TRUE && !signal) {
[17:43:45.698]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:45.698]                     {
[17:43:45.698]                       inherits <- base::inherits
[17:43:45.698]                       invokeRestart <- base::invokeRestart
[17:43:45.698]                       is.null <- base::is.null
[17:43:45.698]                       muffled <- FALSE
[17:43:45.698]                       if (inherits(cond, "message")) {
[17:43:45.698]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:45.698]                         if (muffled) 
[17:43:45.698]                           invokeRestart("muffleMessage")
[17:43:45.698]                       }
[17:43:45.698]                       else if (inherits(cond, "warning")) {
[17:43:45.698]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:45.698]                         if (muffled) 
[17:43:45.698]                           invokeRestart("muffleWarning")
[17:43:45.698]                       }
[17:43:45.698]                       else if (inherits(cond, "condition")) {
[17:43:45.698]                         if (!is.null(pattern)) {
[17:43:45.698]                           computeRestarts <- base::computeRestarts
[17:43:45.698]                           grepl <- base::grepl
[17:43:45.698]                           restarts <- computeRestarts(cond)
[17:43:45.698]                           for (restart in restarts) {
[17:43:45.698]                             name <- restart$name
[17:43:45.698]                             if (is.null(name)) 
[17:43:45.698]                               next
[17:43:45.698]                             if (!grepl(pattern, name)) 
[17:43:45.698]                               next
[17:43:45.698]                             invokeRestart(restart)
[17:43:45.698]                             muffled <- TRUE
[17:43:45.698]                             break
[17:43:45.698]                           }
[17:43:45.698]                         }
[17:43:45.698]                       }
[17:43:45.698]                       invisible(muffled)
[17:43:45.698]                     }
[17:43:45.698]                     muffleCondition(cond, pattern = "^muffle")
[17:43:45.698]                   }
[17:43:45.698]                 }
[17:43:45.698]                 else {
[17:43:45.698]                   if (TRUE) {
[17:43:45.698]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:45.698]                     {
[17:43:45.698]                       inherits <- base::inherits
[17:43:45.698]                       invokeRestart <- base::invokeRestart
[17:43:45.698]                       is.null <- base::is.null
[17:43:45.698]                       muffled <- FALSE
[17:43:45.698]                       if (inherits(cond, "message")) {
[17:43:45.698]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:45.698]                         if (muffled) 
[17:43:45.698]                           invokeRestart("muffleMessage")
[17:43:45.698]                       }
[17:43:45.698]                       else if (inherits(cond, "warning")) {
[17:43:45.698]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:45.698]                         if (muffled) 
[17:43:45.698]                           invokeRestart("muffleWarning")
[17:43:45.698]                       }
[17:43:45.698]                       else if (inherits(cond, "condition")) {
[17:43:45.698]                         if (!is.null(pattern)) {
[17:43:45.698]                           computeRestarts <- base::computeRestarts
[17:43:45.698]                           grepl <- base::grepl
[17:43:45.698]                           restarts <- computeRestarts(cond)
[17:43:45.698]                           for (restart in restarts) {
[17:43:45.698]                             name <- restart$name
[17:43:45.698]                             if (is.null(name)) 
[17:43:45.698]                               next
[17:43:45.698]                             if (!grepl(pattern, name)) 
[17:43:45.698]                               next
[17:43:45.698]                             invokeRestart(restart)
[17:43:45.698]                             muffled <- TRUE
[17:43:45.698]                             break
[17:43:45.698]                           }
[17:43:45.698]                         }
[17:43:45.698]                       }
[17:43:45.698]                       invisible(muffled)
[17:43:45.698]                     }
[17:43:45.698]                     muffleCondition(cond, pattern = "^muffle")
[17:43:45.698]                   }
[17:43:45.698]                 }
[17:43:45.698]             }
[17:43:45.698]         }))
[17:43:45.698]     }, error = function(ex) {
[17:43:45.698]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:45.698]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:45.698]                 ...future.rng), started = ...future.startTime, 
[17:43:45.698]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:45.698]             version = "1.8"), class = "FutureResult")
[17:43:45.698]     }, finally = {
[17:43:45.698]         if (!identical(...future.workdir, getwd())) 
[17:43:45.698]             setwd(...future.workdir)
[17:43:45.698]         {
[17:43:45.698]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:45.698]                 ...future.oldOptions$nwarnings <- NULL
[17:43:45.698]             }
[17:43:45.698]             base::options(...future.oldOptions)
[17:43:45.698]             if (.Platform$OS.type == "windows") {
[17:43:45.698]                 old_names <- names(...future.oldEnvVars)
[17:43:45.698]                 envs <- base::Sys.getenv()
[17:43:45.698]                 names <- names(envs)
[17:43:45.698]                 common <- intersect(names, old_names)
[17:43:45.698]                 added <- setdiff(names, old_names)
[17:43:45.698]                 removed <- setdiff(old_names, names)
[17:43:45.698]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:45.698]                   envs[common]]
[17:43:45.698]                 NAMES <- toupper(changed)
[17:43:45.698]                 args <- list()
[17:43:45.698]                 for (kk in seq_along(NAMES)) {
[17:43:45.698]                   name <- changed[[kk]]
[17:43:45.698]                   NAME <- NAMES[[kk]]
[17:43:45.698]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:45.698]                     next
[17:43:45.698]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:45.698]                 }
[17:43:45.698]                 NAMES <- toupper(added)
[17:43:45.698]                 for (kk in seq_along(NAMES)) {
[17:43:45.698]                   name <- added[[kk]]
[17:43:45.698]                   NAME <- NAMES[[kk]]
[17:43:45.698]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:45.698]                     next
[17:43:45.698]                   args[[name]] <- ""
[17:43:45.698]                 }
[17:43:45.698]                 NAMES <- toupper(removed)
[17:43:45.698]                 for (kk in seq_along(NAMES)) {
[17:43:45.698]                   name <- removed[[kk]]
[17:43:45.698]                   NAME <- NAMES[[kk]]
[17:43:45.698]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:45.698]                     next
[17:43:45.698]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:45.698]                 }
[17:43:45.698]                 if (length(args) > 0) 
[17:43:45.698]                   base::do.call(base::Sys.setenv, args = args)
[17:43:45.698]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:45.698]             }
[17:43:45.698]             else {
[17:43:45.698]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:45.698]             }
[17:43:45.698]             {
[17:43:45.698]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:45.698]                   0L) {
[17:43:45.698]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:45.698]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:45.698]                   base::options(opts)
[17:43:45.698]                 }
[17:43:45.698]                 {
[17:43:45.698]                   {
[17:43:45.698]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:45.698]                     NULL
[17:43:45.698]                   }
[17:43:45.698]                   options(future.plan = NULL)
[17:43:45.698]                   if (is.na(NA_character_)) 
[17:43:45.698]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:45.698]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:45.698]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:45.698]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:45.698]                     envir = parent.frame()) 
[17:43:45.698]                   {
[17:43:45.698]                     if (is.function(workers)) 
[17:43:45.698]                       workers <- workers()
[17:43:45.698]                     workers <- structure(as.integer(workers), 
[17:43:45.698]                       class = class(workers))
[17:43:45.698]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:45.698]                       workers >= 1)
[17:43:45.698]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:45.698]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:45.698]                     }
[17:43:45.698]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:45.698]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:45.698]                       envir = envir)
[17:43:45.698]                     if (!future$lazy) 
[17:43:45.698]                       future <- run(future)
[17:43:45.698]                     invisible(future)
[17:43:45.698]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:45.698]                 }
[17:43:45.698]             }
[17:43:45.698]         }
[17:43:45.698]     })
[17:43:45.698]     if (TRUE) {
[17:43:45.698]         base::sink(type = "output", split = FALSE)
[17:43:45.698]         if (TRUE) {
[17:43:45.698]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:45.698]         }
[17:43:45.698]         else {
[17:43:45.698]             ...future.result["stdout"] <- base::list(NULL)
[17:43:45.698]         }
[17:43:45.698]         base::close(...future.stdout)
[17:43:45.698]         ...future.stdout <- NULL
[17:43:45.698]     }
[17:43:45.698]     ...future.result$conditions <- ...future.conditions
[17:43:45.698]     ...future.result$finished <- base::Sys.time()
[17:43:45.698]     ...future.result
[17:43:45.698] }
[17:43:45.701] MultisessionFuture started
[17:43:45.701] - Launch lazy future ... done
[17:43:45.701] run() for ‘MultisessionFuture’ ... done
[17:43:46.250] receiveMessageFromWorker() for ClusterFuture ...
[17:43:46.250] - Validating connection of MultisessionFuture
[17:43:46.250] - received message: FutureResult
[17:43:46.250] - Received FutureResult
[17:43:46.251] - Erased future from FutureRegistry
[17:43:46.251] result() for ClusterFuture ...
[17:43:46.251] - result already collected: FutureResult
[17:43:46.251] result() for ClusterFuture ... done
[17:43:46.251] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:46.251] A MultisessionFuture was resolved
[17:43:46.251] getGlobalsAndPackages() ...
[17:43:46.251] Searching for globals...
[17:43:46.253] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:43:46.253] Searching for globals ... DONE
[17:43:46.253] Resolving globals: FALSE
[17:43:46.253] 
[17:43:46.254] 
[17:43:46.254] getGlobalsAndPackages() ... DONE
[17:43:46.254] run() for ‘Future’ ...
[17:43:46.254] - state: ‘created’
[17:43:46.254] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:46.270] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:46.271] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:46.271]   - Field: ‘node’
[17:43:46.271]   - Field: ‘label’
[17:43:46.271]   - Field: ‘local’
[17:43:46.271]   - Field: ‘owner’
[17:43:46.271]   - Field: ‘envir’
[17:43:46.271]   - Field: ‘workers’
[17:43:46.272]   - Field: ‘packages’
[17:43:46.272]   - Field: ‘gc’
[17:43:46.272]   - Field: ‘conditions’
[17:43:46.272]   - Field: ‘persistent’
[17:43:46.272]   - Field: ‘expr’
[17:43:46.272]   - Field: ‘uuid’
[17:43:46.272]   - Field: ‘seed’
[17:43:46.272]   - Field: ‘version’
[17:43:46.273]   - Field: ‘result’
[17:43:46.273]   - Field: ‘asynchronous’
[17:43:46.273]   - Field: ‘calls’
[17:43:46.273]   - Field: ‘globals’
[17:43:46.273]   - Field: ‘stdout’
[17:43:46.273]   - Field: ‘earlySignal’
[17:43:46.273]   - Field: ‘lazy’
[17:43:46.274]   - Field: ‘state’
[17:43:46.274] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:46.274] - Launch lazy future ...
[17:43:46.274] Packages needed by the future expression (n = 0): <none>
[17:43:46.274] Packages needed by future strategies (n = 0): <none>
[17:43:46.275] {
[17:43:46.275]     {
[17:43:46.275]         {
[17:43:46.275]             ...future.startTime <- base::Sys.time()
[17:43:46.275]             {
[17:43:46.275]                 {
[17:43:46.275]                   {
[17:43:46.275]                     {
[17:43:46.275]                       base::local({
[17:43:46.275]                         has_future <- base::requireNamespace("future", 
[17:43:46.275]                           quietly = TRUE)
[17:43:46.275]                         if (has_future) {
[17:43:46.275]                           ns <- base::getNamespace("future")
[17:43:46.275]                           version <- ns[[".package"]][["version"]]
[17:43:46.275]                           if (is.null(version)) 
[17:43:46.275]                             version <- utils::packageVersion("future")
[17:43:46.275]                         }
[17:43:46.275]                         else {
[17:43:46.275]                           version <- NULL
[17:43:46.275]                         }
[17:43:46.275]                         if (!has_future || version < "1.8.0") {
[17:43:46.275]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:46.275]                             "", base::R.version$version.string), 
[17:43:46.275]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:46.275]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:46.275]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:46.275]                               "release", "version")], collapse = " "), 
[17:43:46.275]                             hostname = base::Sys.info()[["nodename"]])
[17:43:46.275]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:46.275]                             info)
[17:43:46.275]                           info <- base::paste(info, collapse = "; ")
[17:43:46.275]                           if (!has_future) {
[17:43:46.275]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:46.275]                               info)
[17:43:46.275]                           }
[17:43:46.275]                           else {
[17:43:46.275]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:46.275]                               info, version)
[17:43:46.275]                           }
[17:43:46.275]                           base::stop(msg)
[17:43:46.275]                         }
[17:43:46.275]                       })
[17:43:46.275]                     }
[17:43:46.275]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:46.275]                     base::options(mc.cores = 1L)
[17:43:46.275]                   }
[17:43:46.275]                   options(future.plan = NULL)
[17:43:46.275]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:46.275]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:46.275]                 }
[17:43:46.275]                 ...future.workdir <- getwd()
[17:43:46.275]             }
[17:43:46.275]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:46.275]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:46.275]         }
[17:43:46.275]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:46.275]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:46.275]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:46.275]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:46.275]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:46.275]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:46.275]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:46.275]             base::names(...future.oldOptions))
[17:43:46.275]     }
[17:43:46.275]     if (FALSE) {
[17:43:46.275]     }
[17:43:46.275]     else {
[17:43:46.275]         if (TRUE) {
[17:43:46.275]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:46.275]                 open = "w")
[17:43:46.275]         }
[17:43:46.275]         else {
[17:43:46.275]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:46.275]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:46.275]         }
[17:43:46.275]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:46.275]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:46.275]             base::sink(type = "output", split = FALSE)
[17:43:46.275]             base::close(...future.stdout)
[17:43:46.275]         }, add = TRUE)
[17:43:46.275]     }
[17:43:46.275]     ...future.frame <- base::sys.nframe()
[17:43:46.275]     ...future.conditions <- base::list()
[17:43:46.275]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:46.275]     if (FALSE) {
[17:43:46.275]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:46.275]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:46.275]     }
[17:43:46.275]     ...future.result <- base::tryCatch({
[17:43:46.275]         base::withCallingHandlers({
[17:43:46.275]             ...future.value <- base::withVisible(base::local({
[17:43:46.275]                 ...future.makeSendCondition <- local({
[17:43:46.275]                   sendCondition <- NULL
[17:43:46.275]                   function(frame = 1L) {
[17:43:46.275]                     if (is.function(sendCondition)) 
[17:43:46.275]                       return(sendCondition)
[17:43:46.275]                     ns <- getNamespace("parallel")
[17:43:46.275]                     if (exists("sendData", mode = "function", 
[17:43:46.275]                       envir = ns)) {
[17:43:46.275]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:46.275]                         envir = ns)
[17:43:46.275]                       envir <- sys.frame(frame)
[17:43:46.275]                       master <- NULL
[17:43:46.275]                       while (!identical(envir, .GlobalEnv) && 
[17:43:46.275]                         !identical(envir, emptyenv())) {
[17:43:46.275]                         if (exists("master", mode = "list", envir = envir, 
[17:43:46.275]                           inherits = FALSE)) {
[17:43:46.275]                           master <- get("master", mode = "list", 
[17:43:46.275]                             envir = envir, inherits = FALSE)
[17:43:46.275]                           if (inherits(master, c("SOCKnode", 
[17:43:46.275]                             "SOCK0node"))) {
[17:43:46.275]                             sendCondition <<- function(cond) {
[17:43:46.275]                               data <- list(type = "VALUE", value = cond, 
[17:43:46.275]                                 success = TRUE)
[17:43:46.275]                               parallel_sendData(master, data)
[17:43:46.275]                             }
[17:43:46.275]                             return(sendCondition)
[17:43:46.275]                           }
[17:43:46.275]                         }
[17:43:46.275]                         frame <- frame + 1L
[17:43:46.275]                         envir <- sys.frame(frame)
[17:43:46.275]                       }
[17:43:46.275]                     }
[17:43:46.275]                     sendCondition <<- function(cond) NULL
[17:43:46.275]                   }
[17:43:46.275]                 })
[17:43:46.275]                 withCallingHandlers({
[17:43:46.275]                   {
[17:43:46.275]                     Sys.sleep(0.5)
[17:43:46.275]                     list(a = 1, b = 42L)
[17:43:46.275]                   }
[17:43:46.275]                 }, immediateCondition = function(cond) {
[17:43:46.275]                   sendCondition <- ...future.makeSendCondition()
[17:43:46.275]                   sendCondition(cond)
[17:43:46.275]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:46.275]                   {
[17:43:46.275]                     inherits <- base::inherits
[17:43:46.275]                     invokeRestart <- base::invokeRestart
[17:43:46.275]                     is.null <- base::is.null
[17:43:46.275]                     muffled <- FALSE
[17:43:46.275]                     if (inherits(cond, "message")) {
[17:43:46.275]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:46.275]                       if (muffled) 
[17:43:46.275]                         invokeRestart("muffleMessage")
[17:43:46.275]                     }
[17:43:46.275]                     else if (inherits(cond, "warning")) {
[17:43:46.275]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:46.275]                       if (muffled) 
[17:43:46.275]                         invokeRestart("muffleWarning")
[17:43:46.275]                     }
[17:43:46.275]                     else if (inherits(cond, "condition")) {
[17:43:46.275]                       if (!is.null(pattern)) {
[17:43:46.275]                         computeRestarts <- base::computeRestarts
[17:43:46.275]                         grepl <- base::grepl
[17:43:46.275]                         restarts <- computeRestarts(cond)
[17:43:46.275]                         for (restart in restarts) {
[17:43:46.275]                           name <- restart$name
[17:43:46.275]                           if (is.null(name)) 
[17:43:46.275]                             next
[17:43:46.275]                           if (!grepl(pattern, name)) 
[17:43:46.275]                             next
[17:43:46.275]                           invokeRestart(restart)
[17:43:46.275]                           muffled <- TRUE
[17:43:46.275]                           break
[17:43:46.275]                         }
[17:43:46.275]                       }
[17:43:46.275]                     }
[17:43:46.275]                     invisible(muffled)
[17:43:46.275]                   }
[17:43:46.275]                   muffleCondition(cond)
[17:43:46.275]                 })
[17:43:46.275]             }))
[17:43:46.275]             future::FutureResult(value = ...future.value$value, 
[17:43:46.275]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:46.275]                   ...future.rng), globalenv = if (FALSE) 
[17:43:46.275]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:46.275]                     ...future.globalenv.names))
[17:43:46.275]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:46.275]         }, condition = base::local({
[17:43:46.275]             c <- base::c
[17:43:46.275]             inherits <- base::inherits
[17:43:46.275]             invokeRestart <- base::invokeRestart
[17:43:46.275]             length <- base::length
[17:43:46.275]             list <- base::list
[17:43:46.275]             seq.int <- base::seq.int
[17:43:46.275]             signalCondition <- base::signalCondition
[17:43:46.275]             sys.calls <- base::sys.calls
[17:43:46.275]             `[[` <- base::`[[`
[17:43:46.275]             `+` <- base::`+`
[17:43:46.275]             `<<-` <- base::`<<-`
[17:43:46.275]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:46.275]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:46.275]                   3L)]
[17:43:46.275]             }
[17:43:46.275]             function(cond) {
[17:43:46.275]                 is_error <- inherits(cond, "error")
[17:43:46.275]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:46.275]                   NULL)
[17:43:46.275]                 if (is_error) {
[17:43:46.275]                   sessionInformation <- function() {
[17:43:46.275]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:46.275]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:46.275]                       search = base::search(), system = base::Sys.info())
[17:43:46.275]                   }
[17:43:46.275]                   ...future.conditions[[length(...future.conditions) + 
[17:43:46.275]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:46.275]                     cond$call), session = sessionInformation(), 
[17:43:46.275]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:46.275]                   signalCondition(cond)
[17:43:46.275]                 }
[17:43:46.275]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:46.275]                 "immediateCondition"))) {
[17:43:46.275]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:46.275]                   ...future.conditions[[length(...future.conditions) + 
[17:43:46.275]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:46.275]                   if (TRUE && !signal) {
[17:43:46.275]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:46.275]                     {
[17:43:46.275]                       inherits <- base::inherits
[17:43:46.275]                       invokeRestart <- base::invokeRestart
[17:43:46.275]                       is.null <- base::is.null
[17:43:46.275]                       muffled <- FALSE
[17:43:46.275]                       if (inherits(cond, "message")) {
[17:43:46.275]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:46.275]                         if (muffled) 
[17:43:46.275]                           invokeRestart("muffleMessage")
[17:43:46.275]                       }
[17:43:46.275]                       else if (inherits(cond, "warning")) {
[17:43:46.275]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:46.275]                         if (muffled) 
[17:43:46.275]                           invokeRestart("muffleWarning")
[17:43:46.275]                       }
[17:43:46.275]                       else if (inherits(cond, "condition")) {
[17:43:46.275]                         if (!is.null(pattern)) {
[17:43:46.275]                           computeRestarts <- base::computeRestarts
[17:43:46.275]                           grepl <- base::grepl
[17:43:46.275]                           restarts <- computeRestarts(cond)
[17:43:46.275]                           for (restart in restarts) {
[17:43:46.275]                             name <- restart$name
[17:43:46.275]                             if (is.null(name)) 
[17:43:46.275]                               next
[17:43:46.275]                             if (!grepl(pattern, name)) 
[17:43:46.275]                               next
[17:43:46.275]                             invokeRestart(restart)
[17:43:46.275]                             muffled <- TRUE
[17:43:46.275]                             break
[17:43:46.275]                           }
[17:43:46.275]                         }
[17:43:46.275]                       }
[17:43:46.275]                       invisible(muffled)
[17:43:46.275]                     }
[17:43:46.275]                     muffleCondition(cond, pattern = "^muffle")
[17:43:46.275]                   }
[17:43:46.275]                 }
[17:43:46.275]                 else {
[17:43:46.275]                   if (TRUE) {
[17:43:46.275]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:46.275]                     {
[17:43:46.275]                       inherits <- base::inherits
[17:43:46.275]                       invokeRestart <- base::invokeRestart
[17:43:46.275]                       is.null <- base::is.null
[17:43:46.275]                       muffled <- FALSE
[17:43:46.275]                       if (inherits(cond, "message")) {
[17:43:46.275]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:46.275]                         if (muffled) 
[17:43:46.275]                           invokeRestart("muffleMessage")
[17:43:46.275]                       }
[17:43:46.275]                       else if (inherits(cond, "warning")) {
[17:43:46.275]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:46.275]                         if (muffled) 
[17:43:46.275]                           invokeRestart("muffleWarning")
[17:43:46.275]                       }
[17:43:46.275]                       else if (inherits(cond, "condition")) {
[17:43:46.275]                         if (!is.null(pattern)) {
[17:43:46.275]                           computeRestarts <- base::computeRestarts
[17:43:46.275]                           grepl <- base::grepl
[17:43:46.275]                           restarts <- computeRestarts(cond)
[17:43:46.275]                           for (restart in restarts) {
[17:43:46.275]                             name <- restart$name
[17:43:46.275]                             if (is.null(name)) 
[17:43:46.275]                               next
[17:43:46.275]                             if (!grepl(pattern, name)) 
[17:43:46.275]                               next
[17:43:46.275]                             invokeRestart(restart)
[17:43:46.275]                             muffled <- TRUE
[17:43:46.275]                             break
[17:43:46.275]                           }
[17:43:46.275]                         }
[17:43:46.275]                       }
[17:43:46.275]                       invisible(muffled)
[17:43:46.275]                     }
[17:43:46.275]                     muffleCondition(cond, pattern = "^muffle")
[17:43:46.275]                   }
[17:43:46.275]                 }
[17:43:46.275]             }
[17:43:46.275]         }))
[17:43:46.275]     }, error = function(ex) {
[17:43:46.275]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:46.275]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:46.275]                 ...future.rng), started = ...future.startTime, 
[17:43:46.275]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:46.275]             version = "1.8"), class = "FutureResult")
[17:43:46.275]     }, finally = {
[17:43:46.275]         if (!identical(...future.workdir, getwd())) 
[17:43:46.275]             setwd(...future.workdir)
[17:43:46.275]         {
[17:43:46.275]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:46.275]                 ...future.oldOptions$nwarnings <- NULL
[17:43:46.275]             }
[17:43:46.275]             base::options(...future.oldOptions)
[17:43:46.275]             if (.Platform$OS.type == "windows") {
[17:43:46.275]                 old_names <- names(...future.oldEnvVars)
[17:43:46.275]                 envs <- base::Sys.getenv()
[17:43:46.275]                 names <- names(envs)
[17:43:46.275]                 common <- intersect(names, old_names)
[17:43:46.275]                 added <- setdiff(names, old_names)
[17:43:46.275]                 removed <- setdiff(old_names, names)
[17:43:46.275]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:46.275]                   envs[common]]
[17:43:46.275]                 NAMES <- toupper(changed)
[17:43:46.275]                 args <- list()
[17:43:46.275]                 for (kk in seq_along(NAMES)) {
[17:43:46.275]                   name <- changed[[kk]]
[17:43:46.275]                   NAME <- NAMES[[kk]]
[17:43:46.275]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:46.275]                     next
[17:43:46.275]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:46.275]                 }
[17:43:46.275]                 NAMES <- toupper(added)
[17:43:46.275]                 for (kk in seq_along(NAMES)) {
[17:43:46.275]                   name <- added[[kk]]
[17:43:46.275]                   NAME <- NAMES[[kk]]
[17:43:46.275]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:46.275]                     next
[17:43:46.275]                   args[[name]] <- ""
[17:43:46.275]                 }
[17:43:46.275]                 NAMES <- toupper(removed)
[17:43:46.275]                 for (kk in seq_along(NAMES)) {
[17:43:46.275]                   name <- removed[[kk]]
[17:43:46.275]                   NAME <- NAMES[[kk]]
[17:43:46.275]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:46.275]                     next
[17:43:46.275]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:46.275]                 }
[17:43:46.275]                 if (length(args) > 0) 
[17:43:46.275]                   base::do.call(base::Sys.setenv, args = args)
[17:43:46.275]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:46.275]             }
[17:43:46.275]             else {
[17:43:46.275]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:46.275]             }
[17:43:46.275]             {
[17:43:46.275]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:46.275]                   0L) {
[17:43:46.275]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:46.275]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:46.275]                   base::options(opts)
[17:43:46.275]                 }
[17:43:46.275]                 {
[17:43:46.275]                   {
[17:43:46.275]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:46.275]                     NULL
[17:43:46.275]                   }
[17:43:46.275]                   options(future.plan = NULL)
[17:43:46.275]                   if (is.na(NA_character_)) 
[17:43:46.275]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:46.275]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:46.275]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:46.275]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:46.275]                     envir = parent.frame()) 
[17:43:46.275]                   {
[17:43:46.275]                     if (is.function(workers)) 
[17:43:46.275]                       workers <- workers()
[17:43:46.275]                     workers <- structure(as.integer(workers), 
[17:43:46.275]                       class = class(workers))
[17:43:46.275]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:46.275]                       workers >= 1)
[17:43:46.275]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:46.275]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:46.275]                     }
[17:43:46.275]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:46.275]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:46.275]                       envir = envir)
[17:43:46.275]                     if (!future$lazy) 
[17:43:46.275]                       future <- run(future)
[17:43:46.275]                     invisible(future)
[17:43:46.275]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:46.275]                 }
[17:43:46.275]             }
[17:43:46.275]         }
[17:43:46.275]     })
[17:43:46.275]     if (TRUE) {
[17:43:46.275]         base::sink(type = "output", split = FALSE)
[17:43:46.275]         if (TRUE) {
[17:43:46.275]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:46.275]         }
[17:43:46.275]         else {
[17:43:46.275]             ...future.result["stdout"] <- base::list(NULL)
[17:43:46.275]         }
[17:43:46.275]         base::close(...future.stdout)
[17:43:46.275]         ...future.stdout <- NULL
[17:43:46.275]     }
[17:43:46.275]     ...future.result$conditions <- ...future.conditions
[17:43:46.275]     ...future.result$finished <- base::Sys.time()
[17:43:46.275]     ...future.result
[17:43:46.275] }
[17:43:46.279] MultisessionFuture started
[17:43:46.279] - Launch lazy future ... done
[17:43:46.279] run() for ‘MultisessionFuture’ ... done
[17:43:46.829] receiveMessageFromWorker() for ClusterFuture ...
[17:43:46.830] - Validating connection of MultisessionFuture
[17:43:46.830] - received message: FutureResult
[17:43:46.830] - Received FutureResult
[17:43:46.830] - Erased future from FutureRegistry
[17:43:46.830] result() for ClusterFuture ...
[17:43:46.830] - result already collected: FutureResult
[17:43:46.830] result() for ClusterFuture ... done
[17:43:46.831] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:46.831] A MultisessionFuture was resolved
- w/ exception ...
[17:43:46.831] getGlobalsAndPackages() ...
[17:43:46.831] Searching for globals...
[17:43:46.832] - globals found: [2] ‘list’, ‘stop’
[17:43:46.832] Searching for globals ... DONE
[17:43:46.832] Resolving globals: FALSE
[17:43:46.832] 
[17:43:46.832] 
[17:43:46.832] getGlobalsAndPackages() ... DONE
[17:43:46.833] run() for ‘Future’ ...
[17:43:46.833] - state: ‘created’
[17:43:46.833] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:46.849] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:46.849] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:46.849]   - Field: ‘node’
[17:43:46.850]   - Field: ‘label’
[17:43:46.850]   - Field: ‘local’
[17:43:46.850]   - Field: ‘owner’
[17:43:46.850]   - Field: ‘envir’
[17:43:46.850]   - Field: ‘workers’
[17:43:46.850]   - Field: ‘packages’
[17:43:46.850]   - Field: ‘gc’
[17:43:46.850]   - Field: ‘conditions’
[17:43:46.850]   - Field: ‘persistent’
[17:43:46.850]   - Field: ‘expr’
[17:43:46.851]   - Field: ‘uuid’
[17:43:46.851]   - Field: ‘seed’
[17:43:46.851]   - Field: ‘version’
[17:43:46.851]   - Field: ‘result’
[17:43:46.851]   - Field: ‘asynchronous’
[17:43:46.851]   - Field: ‘calls’
[17:43:46.851]   - Field: ‘globals’
[17:43:46.851]   - Field: ‘stdout’
[17:43:46.851]   - Field: ‘earlySignal’
[17:43:46.851]   - Field: ‘lazy’
[17:43:46.852]   - Field: ‘state’
[17:43:46.852] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:46.852] - Launch lazy future ...
[17:43:46.852] Packages needed by the future expression (n = 0): <none>
[17:43:46.852] Packages needed by future strategies (n = 0): <none>
[17:43:46.853] {
[17:43:46.853]     {
[17:43:46.853]         {
[17:43:46.853]             ...future.startTime <- base::Sys.time()
[17:43:46.853]             {
[17:43:46.853]                 {
[17:43:46.853]                   {
[17:43:46.853]                     {
[17:43:46.853]                       base::local({
[17:43:46.853]                         has_future <- base::requireNamespace("future", 
[17:43:46.853]                           quietly = TRUE)
[17:43:46.853]                         if (has_future) {
[17:43:46.853]                           ns <- base::getNamespace("future")
[17:43:46.853]                           version <- ns[[".package"]][["version"]]
[17:43:46.853]                           if (is.null(version)) 
[17:43:46.853]                             version <- utils::packageVersion("future")
[17:43:46.853]                         }
[17:43:46.853]                         else {
[17:43:46.853]                           version <- NULL
[17:43:46.853]                         }
[17:43:46.853]                         if (!has_future || version < "1.8.0") {
[17:43:46.853]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:46.853]                             "", base::R.version$version.string), 
[17:43:46.853]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:46.853]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:46.853]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:46.853]                               "release", "version")], collapse = " "), 
[17:43:46.853]                             hostname = base::Sys.info()[["nodename"]])
[17:43:46.853]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:46.853]                             info)
[17:43:46.853]                           info <- base::paste(info, collapse = "; ")
[17:43:46.853]                           if (!has_future) {
[17:43:46.853]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:46.853]                               info)
[17:43:46.853]                           }
[17:43:46.853]                           else {
[17:43:46.853]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:46.853]                               info, version)
[17:43:46.853]                           }
[17:43:46.853]                           base::stop(msg)
[17:43:46.853]                         }
[17:43:46.853]                       })
[17:43:46.853]                     }
[17:43:46.853]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:46.853]                     base::options(mc.cores = 1L)
[17:43:46.853]                   }
[17:43:46.853]                   options(future.plan = NULL)
[17:43:46.853]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:46.853]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:46.853]                 }
[17:43:46.853]                 ...future.workdir <- getwd()
[17:43:46.853]             }
[17:43:46.853]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:46.853]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:46.853]         }
[17:43:46.853]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:46.853]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:46.853]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:46.853]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:46.853]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:46.853]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:46.853]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:46.853]             base::names(...future.oldOptions))
[17:43:46.853]     }
[17:43:46.853]     if (FALSE) {
[17:43:46.853]     }
[17:43:46.853]     else {
[17:43:46.853]         if (TRUE) {
[17:43:46.853]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:46.853]                 open = "w")
[17:43:46.853]         }
[17:43:46.853]         else {
[17:43:46.853]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:46.853]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:46.853]         }
[17:43:46.853]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:46.853]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:46.853]             base::sink(type = "output", split = FALSE)
[17:43:46.853]             base::close(...future.stdout)
[17:43:46.853]         }, add = TRUE)
[17:43:46.853]     }
[17:43:46.853]     ...future.frame <- base::sys.nframe()
[17:43:46.853]     ...future.conditions <- base::list()
[17:43:46.853]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:46.853]     if (FALSE) {
[17:43:46.853]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:46.853]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:46.853]     }
[17:43:46.853]     ...future.result <- base::tryCatch({
[17:43:46.853]         base::withCallingHandlers({
[17:43:46.853]             ...future.value <- base::withVisible(base::local({
[17:43:46.853]                 ...future.makeSendCondition <- local({
[17:43:46.853]                   sendCondition <- NULL
[17:43:46.853]                   function(frame = 1L) {
[17:43:46.853]                     if (is.function(sendCondition)) 
[17:43:46.853]                       return(sendCondition)
[17:43:46.853]                     ns <- getNamespace("parallel")
[17:43:46.853]                     if (exists("sendData", mode = "function", 
[17:43:46.853]                       envir = ns)) {
[17:43:46.853]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:46.853]                         envir = ns)
[17:43:46.853]                       envir <- sys.frame(frame)
[17:43:46.853]                       master <- NULL
[17:43:46.853]                       while (!identical(envir, .GlobalEnv) && 
[17:43:46.853]                         !identical(envir, emptyenv())) {
[17:43:46.853]                         if (exists("master", mode = "list", envir = envir, 
[17:43:46.853]                           inherits = FALSE)) {
[17:43:46.853]                           master <- get("master", mode = "list", 
[17:43:46.853]                             envir = envir, inherits = FALSE)
[17:43:46.853]                           if (inherits(master, c("SOCKnode", 
[17:43:46.853]                             "SOCK0node"))) {
[17:43:46.853]                             sendCondition <<- function(cond) {
[17:43:46.853]                               data <- list(type = "VALUE", value = cond, 
[17:43:46.853]                                 success = TRUE)
[17:43:46.853]                               parallel_sendData(master, data)
[17:43:46.853]                             }
[17:43:46.853]                             return(sendCondition)
[17:43:46.853]                           }
[17:43:46.853]                         }
[17:43:46.853]                         frame <- frame + 1L
[17:43:46.853]                         envir <- sys.frame(frame)
[17:43:46.853]                       }
[17:43:46.853]                     }
[17:43:46.853]                     sendCondition <<- function(cond) NULL
[17:43:46.853]                   }
[17:43:46.853]                 })
[17:43:46.853]                 withCallingHandlers({
[17:43:46.853]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:43:46.853]                 }, immediateCondition = function(cond) {
[17:43:46.853]                   sendCondition <- ...future.makeSendCondition()
[17:43:46.853]                   sendCondition(cond)
[17:43:46.853]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:46.853]                   {
[17:43:46.853]                     inherits <- base::inherits
[17:43:46.853]                     invokeRestart <- base::invokeRestart
[17:43:46.853]                     is.null <- base::is.null
[17:43:46.853]                     muffled <- FALSE
[17:43:46.853]                     if (inherits(cond, "message")) {
[17:43:46.853]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:46.853]                       if (muffled) 
[17:43:46.853]                         invokeRestart("muffleMessage")
[17:43:46.853]                     }
[17:43:46.853]                     else if (inherits(cond, "warning")) {
[17:43:46.853]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:46.853]                       if (muffled) 
[17:43:46.853]                         invokeRestart("muffleWarning")
[17:43:46.853]                     }
[17:43:46.853]                     else if (inherits(cond, "condition")) {
[17:43:46.853]                       if (!is.null(pattern)) {
[17:43:46.853]                         computeRestarts <- base::computeRestarts
[17:43:46.853]                         grepl <- base::grepl
[17:43:46.853]                         restarts <- computeRestarts(cond)
[17:43:46.853]                         for (restart in restarts) {
[17:43:46.853]                           name <- restart$name
[17:43:46.853]                           if (is.null(name)) 
[17:43:46.853]                             next
[17:43:46.853]                           if (!grepl(pattern, name)) 
[17:43:46.853]                             next
[17:43:46.853]                           invokeRestart(restart)
[17:43:46.853]                           muffled <- TRUE
[17:43:46.853]                           break
[17:43:46.853]                         }
[17:43:46.853]                       }
[17:43:46.853]                     }
[17:43:46.853]                     invisible(muffled)
[17:43:46.853]                   }
[17:43:46.853]                   muffleCondition(cond)
[17:43:46.853]                 })
[17:43:46.853]             }))
[17:43:46.853]             future::FutureResult(value = ...future.value$value, 
[17:43:46.853]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:46.853]                   ...future.rng), globalenv = if (FALSE) 
[17:43:46.853]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:46.853]                     ...future.globalenv.names))
[17:43:46.853]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:46.853]         }, condition = base::local({
[17:43:46.853]             c <- base::c
[17:43:46.853]             inherits <- base::inherits
[17:43:46.853]             invokeRestart <- base::invokeRestart
[17:43:46.853]             length <- base::length
[17:43:46.853]             list <- base::list
[17:43:46.853]             seq.int <- base::seq.int
[17:43:46.853]             signalCondition <- base::signalCondition
[17:43:46.853]             sys.calls <- base::sys.calls
[17:43:46.853]             `[[` <- base::`[[`
[17:43:46.853]             `+` <- base::`+`
[17:43:46.853]             `<<-` <- base::`<<-`
[17:43:46.853]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:46.853]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:46.853]                   3L)]
[17:43:46.853]             }
[17:43:46.853]             function(cond) {
[17:43:46.853]                 is_error <- inherits(cond, "error")
[17:43:46.853]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:46.853]                   NULL)
[17:43:46.853]                 if (is_error) {
[17:43:46.853]                   sessionInformation <- function() {
[17:43:46.853]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:46.853]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:46.853]                       search = base::search(), system = base::Sys.info())
[17:43:46.853]                   }
[17:43:46.853]                   ...future.conditions[[length(...future.conditions) + 
[17:43:46.853]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:46.853]                     cond$call), session = sessionInformation(), 
[17:43:46.853]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:46.853]                   signalCondition(cond)
[17:43:46.853]                 }
[17:43:46.853]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:46.853]                 "immediateCondition"))) {
[17:43:46.853]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:46.853]                   ...future.conditions[[length(...future.conditions) + 
[17:43:46.853]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:46.853]                   if (TRUE && !signal) {
[17:43:46.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:46.853]                     {
[17:43:46.853]                       inherits <- base::inherits
[17:43:46.853]                       invokeRestart <- base::invokeRestart
[17:43:46.853]                       is.null <- base::is.null
[17:43:46.853]                       muffled <- FALSE
[17:43:46.853]                       if (inherits(cond, "message")) {
[17:43:46.853]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:46.853]                         if (muffled) 
[17:43:46.853]                           invokeRestart("muffleMessage")
[17:43:46.853]                       }
[17:43:46.853]                       else if (inherits(cond, "warning")) {
[17:43:46.853]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:46.853]                         if (muffled) 
[17:43:46.853]                           invokeRestart("muffleWarning")
[17:43:46.853]                       }
[17:43:46.853]                       else if (inherits(cond, "condition")) {
[17:43:46.853]                         if (!is.null(pattern)) {
[17:43:46.853]                           computeRestarts <- base::computeRestarts
[17:43:46.853]                           grepl <- base::grepl
[17:43:46.853]                           restarts <- computeRestarts(cond)
[17:43:46.853]                           for (restart in restarts) {
[17:43:46.853]                             name <- restart$name
[17:43:46.853]                             if (is.null(name)) 
[17:43:46.853]                               next
[17:43:46.853]                             if (!grepl(pattern, name)) 
[17:43:46.853]                               next
[17:43:46.853]                             invokeRestart(restart)
[17:43:46.853]                             muffled <- TRUE
[17:43:46.853]                             break
[17:43:46.853]                           }
[17:43:46.853]                         }
[17:43:46.853]                       }
[17:43:46.853]                       invisible(muffled)
[17:43:46.853]                     }
[17:43:46.853]                     muffleCondition(cond, pattern = "^muffle")
[17:43:46.853]                   }
[17:43:46.853]                 }
[17:43:46.853]                 else {
[17:43:46.853]                   if (TRUE) {
[17:43:46.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:46.853]                     {
[17:43:46.853]                       inherits <- base::inherits
[17:43:46.853]                       invokeRestart <- base::invokeRestart
[17:43:46.853]                       is.null <- base::is.null
[17:43:46.853]                       muffled <- FALSE
[17:43:46.853]                       if (inherits(cond, "message")) {
[17:43:46.853]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:46.853]                         if (muffled) 
[17:43:46.853]                           invokeRestart("muffleMessage")
[17:43:46.853]                       }
[17:43:46.853]                       else if (inherits(cond, "warning")) {
[17:43:46.853]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:46.853]                         if (muffled) 
[17:43:46.853]                           invokeRestart("muffleWarning")
[17:43:46.853]                       }
[17:43:46.853]                       else if (inherits(cond, "condition")) {
[17:43:46.853]                         if (!is.null(pattern)) {
[17:43:46.853]                           computeRestarts <- base::computeRestarts
[17:43:46.853]                           grepl <- base::grepl
[17:43:46.853]                           restarts <- computeRestarts(cond)
[17:43:46.853]                           for (restart in restarts) {
[17:43:46.853]                             name <- restart$name
[17:43:46.853]                             if (is.null(name)) 
[17:43:46.853]                               next
[17:43:46.853]                             if (!grepl(pattern, name)) 
[17:43:46.853]                               next
[17:43:46.853]                             invokeRestart(restart)
[17:43:46.853]                             muffled <- TRUE
[17:43:46.853]                             break
[17:43:46.853]                           }
[17:43:46.853]                         }
[17:43:46.853]                       }
[17:43:46.853]                       invisible(muffled)
[17:43:46.853]                     }
[17:43:46.853]                     muffleCondition(cond, pattern = "^muffle")
[17:43:46.853]                   }
[17:43:46.853]                 }
[17:43:46.853]             }
[17:43:46.853]         }))
[17:43:46.853]     }, error = function(ex) {
[17:43:46.853]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:46.853]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:46.853]                 ...future.rng), started = ...future.startTime, 
[17:43:46.853]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:46.853]             version = "1.8"), class = "FutureResult")
[17:43:46.853]     }, finally = {
[17:43:46.853]         if (!identical(...future.workdir, getwd())) 
[17:43:46.853]             setwd(...future.workdir)
[17:43:46.853]         {
[17:43:46.853]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:46.853]                 ...future.oldOptions$nwarnings <- NULL
[17:43:46.853]             }
[17:43:46.853]             base::options(...future.oldOptions)
[17:43:46.853]             if (.Platform$OS.type == "windows") {
[17:43:46.853]                 old_names <- names(...future.oldEnvVars)
[17:43:46.853]                 envs <- base::Sys.getenv()
[17:43:46.853]                 names <- names(envs)
[17:43:46.853]                 common <- intersect(names, old_names)
[17:43:46.853]                 added <- setdiff(names, old_names)
[17:43:46.853]                 removed <- setdiff(old_names, names)
[17:43:46.853]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:46.853]                   envs[common]]
[17:43:46.853]                 NAMES <- toupper(changed)
[17:43:46.853]                 args <- list()
[17:43:46.853]                 for (kk in seq_along(NAMES)) {
[17:43:46.853]                   name <- changed[[kk]]
[17:43:46.853]                   NAME <- NAMES[[kk]]
[17:43:46.853]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:46.853]                     next
[17:43:46.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:46.853]                 }
[17:43:46.853]                 NAMES <- toupper(added)
[17:43:46.853]                 for (kk in seq_along(NAMES)) {
[17:43:46.853]                   name <- added[[kk]]
[17:43:46.853]                   NAME <- NAMES[[kk]]
[17:43:46.853]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:46.853]                     next
[17:43:46.853]                   args[[name]] <- ""
[17:43:46.853]                 }
[17:43:46.853]                 NAMES <- toupper(removed)
[17:43:46.853]                 for (kk in seq_along(NAMES)) {
[17:43:46.853]                   name <- removed[[kk]]
[17:43:46.853]                   NAME <- NAMES[[kk]]
[17:43:46.853]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:46.853]                     next
[17:43:46.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:46.853]                 }
[17:43:46.853]                 if (length(args) > 0) 
[17:43:46.853]                   base::do.call(base::Sys.setenv, args = args)
[17:43:46.853]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:46.853]             }
[17:43:46.853]             else {
[17:43:46.853]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:46.853]             }
[17:43:46.853]             {
[17:43:46.853]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:46.853]                   0L) {
[17:43:46.853]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:46.853]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:46.853]                   base::options(opts)
[17:43:46.853]                 }
[17:43:46.853]                 {
[17:43:46.853]                   {
[17:43:46.853]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:46.853]                     NULL
[17:43:46.853]                   }
[17:43:46.853]                   options(future.plan = NULL)
[17:43:46.853]                   if (is.na(NA_character_)) 
[17:43:46.853]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:46.853]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:46.853]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:46.853]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:46.853]                     envir = parent.frame()) 
[17:43:46.853]                   {
[17:43:46.853]                     if (is.function(workers)) 
[17:43:46.853]                       workers <- workers()
[17:43:46.853]                     workers <- structure(as.integer(workers), 
[17:43:46.853]                       class = class(workers))
[17:43:46.853]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:46.853]                       workers >= 1)
[17:43:46.853]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:46.853]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:46.853]                     }
[17:43:46.853]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:46.853]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:46.853]                       envir = envir)
[17:43:46.853]                     if (!future$lazy) 
[17:43:46.853]                       future <- run(future)
[17:43:46.853]                     invisible(future)
[17:43:46.853]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:46.853]                 }
[17:43:46.853]             }
[17:43:46.853]         }
[17:43:46.853]     })
[17:43:46.853]     if (TRUE) {
[17:43:46.853]         base::sink(type = "output", split = FALSE)
[17:43:46.853]         if (TRUE) {
[17:43:46.853]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:46.853]         }
[17:43:46.853]         else {
[17:43:46.853]             ...future.result["stdout"] <- base::list(NULL)
[17:43:46.853]         }
[17:43:46.853]         base::close(...future.stdout)
[17:43:46.853]         ...future.stdout <- NULL
[17:43:46.853]     }
[17:43:46.853]     ...future.result$conditions <- ...future.conditions
[17:43:46.853]     ...future.result$finished <- base::Sys.time()
[17:43:46.853]     ...future.result
[17:43:46.853] }
[17:43:46.856] MultisessionFuture started
[17:43:46.856] - Launch lazy future ... done
[17:43:46.856] run() for ‘MultisessionFuture’ ... done
[17:43:46.904] receiveMessageFromWorker() for ClusterFuture ...
[17:43:46.905] - Validating connection of MultisessionFuture
[17:43:46.905] - received message: FutureResult
[17:43:46.905] - Received FutureResult
[17:43:46.905] - Erased future from FutureRegistry
[17:43:46.905] result() for ClusterFuture ...
[17:43:46.906] - result already collected: FutureResult
[17:43:46.906] result() for ClusterFuture ... done
[17:43:46.906] signalConditions() ...
[17:43:46.906]  - include = ‘immediateCondition’
[17:43:46.906]  - exclude = 
[17:43:46.906]  - resignal = FALSE
[17:43:46.906]  - Number of conditions: 1
[17:43:46.906] signalConditions() ... done
[17:43:46.906] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:46.906] A MultisessionFuture was resolved
[17:43:46.907] getGlobalsAndPackages() ...
[17:43:46.907] Searching for globals...
[17:43:46.907] - globals found: [2] ‘list’, ‘stop’
[17:43:46.908] Searching for globals ... DONE
[17:43:46.908] Resolving globals: FALSE
[17:43:46.908] 
[17:43:46.908] 
[17:43:46.908] getGlobalsAndPackages() ... DONE
[17:43:46.908] run() for ‘Future’ ...
[17:43:46.909] - state: ‘created’
[17:43:46.909] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:46.923] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:46.923] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:46.923]   - Field: ‘node’
[17:43:46.923]   - Field: ‘label’
[17:43:46.923]   - Field: ‘local’
[17:43:46.924]   - Field: ‘owner’
[17:43:46.924]   - Field: ‘envir’
[17:43:46.924]   - Field: ‘workers’
[17:43:46.924]   - Field: ‘packages’
[17:43:46.924]   - Field: ‘gc’
[17:43:46.924]   - Field: ‘conditions’
[17:43:46.924]   - Field: ‘persistent’
[17:43:46.924]   - Field: ‘expr’
[17:43:46.924]   - Field: ‘uuid’
[17:43:46.924]   - Field: ‘seed’
[17:43:46.924]   - Field: ‘version’
[17:43:46.925]   - Field: ‘result’
[17:43:46.925]   - Field: ‘asynchronous’
[17:43:46.925]   - Field: ‘calls’
[17:43:46.925]   - Field: ‘globals’
[17:43:46.925]   - Field: ‘stdout’
[17:43:46.925]   - Field: ‘earlySignal’
[17:43:46.925]   - Field: ‘lazy’
[17:43:46.925]   - Field: ‘state’
[17:43:46.925] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:46.925] - Launch lazy future ...
[17:43:46.926] Packages needed by the future expression (n = 0): <none>
[17:43:46.926] Packages needed by future strategies (n = 0): <none>
[17:43:46.926] {
[17:43:46.926]     {
[17:43:46.926]         {
[17:43:46.926]             ...future.startTime <- base::Sys.time()
[17:43:46.926]             {
[17:43:46.926]                 {
[17:43:46.926]                   {
[17:43:46.926]                     {
[17:43:46.926]                       base::local({
[17:43:46.926]                         has_future <- base::requireNamespace("future", 
[17:43:46.926]                           quietly = TRUE)
[17:43:46.926]                         if (has_future) {
[17:43:46.926]                           ns <- base::getNamespace("future")
[17:43:46.926]                           version <- ns[[".package"]][["version"]]
[17:43:46.926]                           if (is.null(version)) 
[17:43:46.926]                             version <- utils::packageVersion("future")
[17:43:46.926]                         }
[17:43:46.926]                         else {
[17:43:46.926]                           version <- NULL
[17:43:46.926]                         }
[17:43:46.926]                         if (!has_future || version < "1.8.0") {
[17:43:46.926]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:46.926]                             "", base::R.version$version.string), 
[17:43:46.926]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:46.926]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:46.926]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:46.926]                               "release", "version")], collapse = " "), 
[17:43:46.926]                             hostname = base::Sys.info()[["nodename"]])
[17:43:46.926]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:46.926]                             info)
[17:43:46.926]                           info <- base::paste(info, collapse = "; ")
[17:43:46.926]                           if (!has_future) {
[17:43:46.926]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:46.926]                               info)
[17:43:46.926]                           }
[17:43:46.926]                           else {
[17:43:46.926]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:46.926]                               info, version)
[17:43:46.926]                           }
[17:43:46.926]                           base::stop(msg)
[17:43:46.926]                         }
[17:43:46.926]                       })
[17:43:46.926]                     }
[17:43:46.926]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:46.926]                     base::options(mc.cores = 1L)
[17:43:46.926]                   }
[17:43:46.926]                   options(future.plan = NULL)
[17:43:46.926]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:46.926]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:46.926]                 }
[17:43:46.926]                 ...future.workdir <- getwd()
[17:43:46.926]             }
[17:43:46.926]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:46.926]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:46.926]         }
[17:43:46.926]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:46.926]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:46.926]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:46.926]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:46.926]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:46.926]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:46.926]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:46.926]             base::names(...future.oldOptions))
[17:43:46.926]     }
[17:43:46.926]     if (FALSE) {
[17:43:46.926]     }
[17:43:46.926]     else {
[17:43:46.926]         if (TRUE) {
[17:43:46.926]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:46.926]                 open = "w")
[17:43:46.926]         }
[17:43:46.926]         else {
[17:43:46.926]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:46.926]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:46.926]         }
[17:43:46.926]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:46.926]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:46.926]             base::sink(type = "output", split = FALSE)
[17:43:46.926]             base::close(...future.stdout)
[17:43:46.926]         }, add = TRUE)
[17:43:46.926]     }
[17:43:46.926]     ...future.frame <- base::sys.nframe()
[17:43:46.926]     ...future.conditions <- base::list()
[17:43:46.926]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:46.926]     if (FALSE) {
[17:43:46.926]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:46.926]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:46.926]     }
[17:43:46.926]     ...future.result <- base::tryCatch({
[17:43:46.926]         base::withCallingHandlers({
[17:43:46.926]             ...future.value <- base::withVisible(base::local({
[17:43:46.926]                 ...future.makeSendCondition <- local({
[17:43:46.926]                   sendCondition <- NULL
[17:43:46.926]                   function(frame = 1L) {
[17:43:46.926]                     if (is.function(sendCondition)) 
[17:43:46.926]                       return(sendCondition)
[17:43:46.926]                     ns <- getNamespace("parallel")
[17:43:46.926]                     if (exists("sendData", mode = "function", 
[17:43:46.926]                       envir = ns)) {
[17:43:46.926]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:46.926]                         envir = ns)
[17:43:46.926]                       envir <- sys.frame(frame)
[17:43:46.926]                       master <- NULL
[17:43:46.926]                       while (!identical(envir, .GlobalEnv) && 
[17:43:46.926]                         !identical(envir, emptyenv())) {
[17:43:46.926]                         if (exists("master", mode = "list", envir = envir, 
[17:43:46.926]                           inherits = FALSE)) {
[17:43:46.926]                           master <- get("master", mode = "list", 
[17:43:46.926]                             envir = envir, inherits = FALSE)
[17:43:46.926]                           if (inherits(master, c("SOCKnode", 
[17:43:46.926]                             "SOCK0node"))) {
[17:43:46.926]                             sendCondition <<- function(cond) {
[17:43:46.926]                               data <- list(type = "VALUE", value = cond, 
[17:43:46.926]                                 success = TRUE)
[17:43:46.926]                               parallel_sendData(master, data)
[17:43:46.926]                             }
[17:43:46.926]                             return(sendCondition)
[17:43:46.926]                           }
[17:43:46.926]                         }
[17:43:46.926]                         frame <- frame + 1L
[17:43:46.926]                         envir <- sys.frame(frame)
[17:43:46.926]                       }
[17:43:46.926]                     }
[17:43:46.926]                     sendCondition <<- function(cond) NULL
[17:43:46.926]                   }
[17:43:46.926]                 })
[17:43:46.926]                 withCallingHandlers({
[17:43:46.926]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:43:46.926]                 }, immediateCondition = function(cond) {
[17:43:46.926]                   sendCondition <- ...future.makeSendCondition()
[17:43:46.926]                   sendCondition(cond)
[17:43:46.926]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:46.926]                   {
[17:43:46.926]                     inherits <- base::inherits
[17:43:46.926]                     invokeRestart <- base::invokeRestart
[17:43:46.926]                     is.null <- base::is.null
[17:43:46.926]                     muffled <- FALSE
[17:43:46.926]                     if (inherits(cond, "message")) {
[17:43:46.926]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:46.926]                       if (muffled) 
[17:43:46.926]                         invokeRestart("muffleMessage")
[17:43:46.926]                     }
[17:43:46.926]                     else if (inherits(cond, "warning")) {
[17:43:46.926]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:46.926]                       if (muffled) 
[17:43:46.926]                         invokeRestart("muffleWarning")
[17:43:46.926]                     }
[17:43:46.926]                     else if (inherits(cond, "condition")) {
[17:43:46.926]                       if (!is.null(pattern)) {
[17:43:46.926]                         computeRestarts <- base::computeRestarts
[17:43:46.926]                         grepl <- base::grepl
[17:43:46.926]                         restarts <- computeRestarts(cond)
[17:43:46.926]                         for (restart in restarts) {
[17:43:46.926]                           name <- restart$name
[17:43:46.926]                           if (is.null(name)) 
[17:43:46.926]                             next
[17:43:46.926]                           if (!grepl(pattern, name)) 
[17:43:46.926]                             next
[17:43:46.926]                           invokeRestart(restart)
[17:43:46.926]                           muffled <- TRUE
[17:43:46.926]                           break
[17:43:46.926]                         }
[17:43:46.926]                       }
[17:43:46.926]                     }
[17:43:46.926]                     invisible(muffled)
[17:43:46.926]                   }
[17:43:46.926]                   muffleCondition(cond)
[17:43:46.926]                 })
[17:43:46.926]             }))
[17:43:46.926]             future::FutureResult(value = ...future.value$value, 
[17:43:46.926]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:46.926]                   ...future.rng), globalenv = if (FALSE) 
[17:43:46.926]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:46.926]                     ...future.globalenv.names))
[17:43:46.926]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:46.926]         }, condition = base::local({
[17:43:46.926]             c <- base::c
[17:43:46.926]             inherits <- base::inherits
[17:43:46.926]             invokeRestart <- base::invokeRestart
[17:43:46.926]             length <- base::length
[17:43:46.926]             list <- base::list
[17:43:46.926]             seq.int <- base::seq.int
[17:43:46.926]             signalCondition <- base::signalCondition
[17:43:46.926]             sys.calls <- base::sys.calls
[17:43:46.926]             `[[` <- base::`[[`
[17:43:46.926]             `+` <- base::`+`
[17:43:46.926]             `<<-` <- base::`<<-`
[17:43:46.926]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:46.926]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:46.926]                   3L)]
[17:43:46.926]             }
[17:43:46.926]             function(cond) {
[17:43:46.926]                 is_error <- inherits(cond, "error")
[17:43:46.926]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:46.926]                   NULL)
[17:43:46.926]                 if (is_error) {
[17:43:46.926]                   sessionInformation <- function() {
[17:43:46.926]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:46.926]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:46.926]                       search = base::search(), system = base::Sys.info())
[17:43:46.926]                   }
[17:43:46.926]                   ...future.conditions[[length(...future.conditions) + 
[17:43:46.926]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:46.926]                     cond$call), session = sessionInformation(), 
[17:43:46.926]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:46.926]                   signalCondition(cond)
[17:43:46.926]                 }
[17:43:46.926]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:46.926]                 "immediateCondition"))) {
[17:43:46.926]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:46.926]                   ...future.conditions[[length(...future.conditions) + 
[17:43:46.926]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:46.926]                   if (TRUE && !signal) {
[17:43:46.926]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:46.926]                     {
[17:43:46.926]                       inherits <- base::inherits
[17:43:46.926]                       invokeRestart <- base::invokeRestart
[17:43:46.926]                       is.null <- base::is.null
[17:43:46.926]                       muffled <- FALSE
[17:43:46.926]                       if (inherits(cond, "message")) {
[17:43:46.926]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:46.926]                         if (muffled) 
[17:43:46.926]                           invokeRestart("muffleMessage")
[17:43:46.926]                       }
[17:43:46.926]                       else if (inherits(cond, "warning")) {
[17:43:46.926]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:46.926]                         if (muffled) 
[17:43:46.926]                           invokeRestart("muffleWarning")
[17:43:46.926]                       }
[17:43:46.926]                       else if (inherits(cond, "condition")) {
[17:43:46.926]                         if (!is.null(pattern)) {
[17:43:46.926]                           computeRestarts <- base::computeRestarts
[17:43:46.926]                           grepl <- base::grepl
[17:43:46.926]                           restarts <- computeRestarts(cond)
[17:43:46.926]                           for (restart in restarts) {
[17:43:46.926]                             name <- restart$name
[17:43:46.926]                             if (is.null(name)) 
[17:43:46.926]                               next
[17:43:46.926]                             if (!grepl(pattern, name)) 
[17:43:46.926]                               next
[17:43:46.926]                             invokeRestart(restart)
[17:43:46.926]                             muffled <- TRUE
[17:43:46.926]                             break
[17:43:46.926]                           }
[17:43:46.926]                         }
[17:43:46.926]                       }
[17:43:46.926]                       invisible(muffled)
[17:43:46.926]                     }
[17:43:46.926]                     muffleCondition(cond, pattern = "^muffle")
[17:43:46.926]                   }
[17:43:46.926]                 }
[17:43:46.926]                 else {
[17:43:46.926]                   if (TRUE) {
[17:43:46.926]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:46.926]                     {
[17:43:46.926]                       inherits <- base::inherits
[17:43:46.926]                       invokeRestart <- base::invokeRestart
[17:43:46.926]                       is.null <- base::is.null
[17:43:46.926]                       muffled <- FALSE
[17:43:46.926]                       if (inherits(cond, "message")) {
[17:43:46.926]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:46.926]                         if (muffled) 
[17:43:46.926]                           invokeRestart("muffleMessage")
[17:43:46.926]                       }
[17:43:46.926]                       else if (inherits(cond, "warning")) {
[17:43:46.926]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:46.926]                         if (muffled) 
[17:43:46.926]                           invokeRestart("muffleWarning")
[17:43:46.926]                       }
[17:43:46.926]                       else if (inherits(cond, "condition")) {
[17:43:46.926]                         if (!is.null(pattern)) {
[17:43:46.926]                           computeRestarts <- base::computeRestarts
[17:43:46.926]                           grepl <- base::grepl
[17:43:46.926]                           restarts <- computeRestarts(cond)
[17:43:46.926]                           for (restart in restarts) {
[17:43:46.926]                             name <- restart$name
[17:43:46.926]                             if (is.null(name)) 
[17:43:46.926]                               next
[17:43:46.926]                             if (!grepl(pattern, name)) 
[17:43:46.926]                               next
[17:43:46.926]                             invokeRestart(restart)
[17:43:46.926]                             muffled <- TRUE
[17:43:46.926]                             break
[17:43:46.926]                           }
[17:43:46.926]                         }
[17:43:46.926]                       }
[17:43:46.926]                       invisible(muffled)
[17:43:46.926]                     }
[17:43:46.926]                     muffleCondition(cond, pattern = "^muffle")
[17:43:46.926]                   }
[17:43:46.926]                 }
[17:43:46.926]             }
[17:43:46.926]         }))
[17:43:46.926]     }, error = function(ex) {
[17:43:46.926]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:46.926]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:46.926]                 ...future.rng), started = ...future.startTime, 
[17:43:46.926]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:46.926]             version = "1.8"), class = "FutureResult")
[17:43:46.926]     }, finally = {
[17:43:46.926]         if (!identical(...future.workdir, getwd())) 
[17:43:46.926]             setwd(...future.workdir)
[17:43:46.926]         {
[17:43:46.926]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:46.926]                 ...future.oldOptions$nwarnings <- NULL
[17:43:46.926]             }
[17:43:46.926]             base::options(...future.oldOptions)
[17:43:46.926]             if (.Platform$OS.type == "windows") {
[17:43:46.926]                 old_names <- names(...future.oldEnvVars)
[17:43:46.926]                 envs <- base::Sys.getenv()
[17:43:46.926]                 names <- names(envs)
[17:43:46.926]                 common <- intersect(names, old_names)
[17:43:46.926]                 added <- setdiff(names, old_names)
[17:43:46.926]                 removed <- setdiff(old_names, names)
[17:43:46.926]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:46.926]                   envs[common]]
[17:43:46.926]                 NAMES <- toupper(changed)
[17:43:46.926]                 args <- list()
[17:43:46.926]                 for (kk in seq_along(NAMES)) {
[17:43:46.926]                   name <- changed[[kk]]
[17:43:46.926]                   NAME <- NAMES[[kk]]
[17:43:46.926]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:46.926]                     next
[17:43:46.926]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:46.926]                 }
[17:43:46.926]                 NAMES <- toupper(added)
[17:43:46.926]                 for (kk in seq_along(NAMES)) {
[17:43:46.926]                   name <- added[[kk]]
[17:43:46.926]                   NAME <- NAMES[[kk]]
[17:43:46.926]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:46.926]                     next
[17:43:46.926]                   args[[name]] <- ""
[17:43:46.926]                 }
[17:43:46.926]                 NAMES <- toupper(removed)
[17:43:46.926]                 for (kk in seq_along(NAMES)) {
[17:43:46.926]                   name <- removed[[kk]]
[17:43:46.926]                   NAME <- NAMES[[kk]]
[17:43:46.926]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:46.926]                     next
[17:43:46.926]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:46.926]                 }
[17:43:46.926]                 if (length(args) > 0) 
[17:43:46.926]                   base::do.call(base::Sys.setenv, args = args)
[17:43:46.926]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:46.926]             }
[17:43:46.926]             else {
[17:43:46.926]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:46.926]             }
[17:43:46.926]             {
[17:43:46.926]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:46.926]                   0L) {
[17:43:46.926]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:46.926]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:46.926]                   base::options(opts)
[17:43:46.926]                 }
[17:43:46.926]                 {
[17:43:46.926]                   {
[17:43:46.926]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:46.926]                     NULL
[17:43:46.926]                   }
[17:43:46.926]                   options(future.plan = NULL)
[17:43:46.926]                   if (is.na(NA_character_)) 
[17:43:46.926]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:46.926]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:46.926]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:46.926]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:46.926]                     envir = parent.frame()) 
[17:43:46.926]                   {
[17:43:46.926]                     if (is.function(workers)) 
[17:43:46.926]                       workers <- workers()
[17:43:46.926]                     workers <- structure(as.integer(workers), 
[17:43:46.926]                       class = class(workers))
[17:43:46.926]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:46.926]                       workers >= 1)
[17:43:46.926]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:46.926]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:46.926]                     }
[17:43:46.926]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:46.926]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:46.926]                       envir = envir)
[17:43:46.926]                     if (!future$lazy) 
[17:43:46.926]                       future <- run(future)
[17:43:46.926]                     invisible(future)
[17:43:46.926]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:46.926]                 }
[17:43:46.926]             }
[17:43:46.926]         }
[17:43:46.926]     })
[17:43:46.926]     if (TRUE) {
[17:43:46.926]         base::sink(type = "output", split = FALSE)
[17:43:46.926]         if (TRUE) {
[17:43:46.926]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:46.926]         }
[17:43:46.926]         else {
[17:43:46.926]             ...future.result["stdout"] <- base::list(NULL)
[17:43:46.926]         }
[17:43:46.926]         base::close(...future.stdout)
[17:43:46.926]         ...future.stdout <- NULL
[17:43:46.926]     }
[17:43:46.926]     ...future.result$conditions <- ...future.conditions
[17:43:46.926]     ...future.result$finished <- base::Sys.time()
[17:43:46.926]     ...future.result
[17:43:46.926] }
[17:43:46.929] MultisessionFuture started
[17:43:46.929] - Launch lazy future ... done
[17:43:46.930] run() for ‘MultisessionFuture’ ... done
[17:43:46.976] receiveMessageFromWorker() for ClusterFuture ...
[17:43:46.976] - Validating connection of MultisessionFuture
[17:43:46.977] - received message: FutureResult
[17:43:46.977] - Received FutureResult
[17:43:46.977] - Erased future from FutureRegistry
[17:43:46.977] result() for ClusterFuture ...
[17:43:46.977] - result already collected: FutureResult
[17:43:46.977] result() for ClusterFuture ... done
[17:43:46.978] signalConditions() ...
[17:43:46.978]  - include = ‘immediateCondition’
[17:43:46.978]  - exclude = 
[17:43:46.978]  - resignal = FALSE
[17:43:46.978]  - Number of conditions: 1
[17:43:46.978] signalConditions() ... done
[17:43:46.978] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:46.978] A MultisessionFuture was resolved
- result = TRUE, recursive = FALSE ... DONE
- result = TRUE, recursive = TRUE ...
[17:43:46.978] getGlobalsAndPackages() ...
[17:43:46.979] Searching for globals...
[17:43:46.980] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:43:46.980] Searching for globals ... DONE
[17:43:46.980] Resolving globals: FALSE
[17:43:46.980] 
[17:43:46.980] 
[17:43:46.980] getGlobalsAndPackages() ... DONE
[17:43:46.981] run() for ‘Future’ ...
[17:43:46.981] - state: ‘created’
[17:43:46.981] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:46.995] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:46.996] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:46.996]   - Field: ‘node’
[17:43:46.996]   - Field: ‘label’
[17:43:46.996]   - Field: ‘local’
[17:43:46.996]   - Field: ‘owner’
[17:43:46.996]   - Field: ‘envir’
[17:43:46.996]   - Field: ‘workers’
[17:43:46.996]   - Field: ‘packages’
[17:43:46.996]   - Field: ‘gc’
[17:43:46.997]   - Field: ‘conditions’
[17:43:46.997]   - Field: ‘persistent’
[17:43:46.997]   - Field: ‘expr’
[17:43:46.997]   - Field: ‘uuid’
[17:43:46.997]   - Field: ‘seed’
[17:43:46.997]   - Field: ‘version’
[17:43:46.997]   - Field: ‘result’
[17:43:46.997]   - Field: ‘asynchronous’
[17:43:46.997]   - Field: ‘calls’
[17:43:46.997]   - Field: ‘globals’
[17:43:46.997]   - Field: ‘stdout’
[17:43:46.998]   - Field: ‘earlySignal’
[17:43:46.998]   - Field: ‘lazy’
[17:43:46.998]   - Field: ‘state’
[17:43:46.998] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:46.998] - Launch lazy future ...
[17:43:46.998] Packages needed by the future expression (n = 0): <none>
[17:43:46.998] Packages needed by future strategies (n = 0): <none>
[17:43:46.999] {
[17:43:46.999]     {
[17:43:46.999]         {
[17:43:46.999]             ...future.startTime <- base::Sys.time()
[17:43:46.999]             {
[17:43:46.999]                 {
[17:43:46.999]                   {
[17:43:46.999]                     {
[17:43:46.999]                       base::local({
[17:43:46.999]                         has_future <- base::requireNamespace("future", 
[17:43:46.999]                           quietly = TRUE)
[17:43:46.999]                         if (has_future) {
[17:43:46.999]                           ns <- base::getNamespace("future")
[17:43:46.999]                           version <- ns[[".package"]][["version"]]
[17:43:46.999]                           if (is.null(version)) 
[17:43:46.999]                             version <- utils::packageVersion("future")
[17:43:46.999]                         }
[17:43:46.999]                         else {
[17:43:46.999]                           version <- NULL
[17:43:46.999]                         }
[17:43:46.999]                         if (!has_future || version < "1.8.0") {
[17:43:46.999]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:46.999]                             "", base::R.version$version.string), 
[17:43:46.999]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:46.999]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:46.999]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:46.999]                               "release", "version")], collapse = " "), 
[17:43:46.999]                             hostname = base::Sys.info()[["nodename"]])
[17:43:46.999]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:46.999]                             info)
[17:43:46.999]                           info <- base::paste(info, collapse = "; ")
[17:43:46.999]                           if (!has_future) {
[17:43:46.999]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:46.999]                               info)
[17:43:46.999]                           }
[17:43:46.999]                           else {
[17:43:46.999]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:46.999]                               info, version)
[17:43:46.999]                           }
[17:43:46.999]                           base::stop(msg)
[17:43:46.999]                         }
[17:43:46.999]                       })
[17:43:46.999]                     }
[17:43:46.999]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:46.999]                     base::options(mc.cores = 1L)
[17:43:46.999]                   }
[17:43:46.999]                   options(future.plan = NULL)
[17:43:46.999]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:46.999]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:46.999]                 }
[17:43:46.999]                 ...future.workdir <- getwd()
[17:43:46.999]             }
[17:43:46.999]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:46.999]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:46.999]         }
[17:43:46.999]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:46.999]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:46.999]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:46.999]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:46.999]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:46.999]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:46.999]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:46.999]             base::names(...future.oldOptions))
[17:43:46.999]     }
[17:43:46.999]     if (FALSE) {
[17:43:46.999]     }
[17:43:46.999]     else {
[17:43:46.999]         if (TRUE) {
[17:43:46.999]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:46.999]                 open = "w")
[17:43:46.999]         }
[17:43:46.999]         else {
[17:43:46.999]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:46.999]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:46.999]         }
[17:43:46.999]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:46.999]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:46.999]             base::sink(type = "output", split = FALSE)
[17:43:46.999]             base::close(...future.stdout)
[17:43:46.999]         }, add = TRUE)
[17:43:46.999]     }
[17:43:46.999]     ...future.frame <- base::sys.nframe()
[17:43:46.999]     ...future.conditions <- base::list()
[17:43:46.999]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:46.999]     if (FALSE) {
[17:43:46.999]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:46.999]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:46.999]     }
[17:43:46.999]     ...future.result <- base::tryCatch({
[17:43:46.999]         base::withCallingHandlers({
[17:43:46.999]             ...future.value <- base::withVisible(base::local({
[17:43:46.999]                 ...future.makeSendCondition <- local({
[17:43:46.999]                   sendCondition <- NULL
[17:43:46.999]                   function(frame = 1L) {
[17:43:46.999]                     if (is.function(sendCondition)) 
[17:43:46.999]                       return(sendCondition)
[17:43:46.999]                     ns <- getNamespace("parallel")
[17:43:46.999]                     if (exists("sendData", mode = "function", 
[17:43:46.999]                       envir = ns)) {
[17:43:46.999]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:46.999]                         envir = ns)
[17:43:46.999]                       envir <- sys.frame(frame)
[17:43:46.999]                       master <- NULL
[17:43:46.999]                       while (!identical(envir, .GlobalEnv) && 
[17:43:46.999]                         !identical(envir, emptyenv())) {
[17:43:46.999]                         if (exists("master", mode = "list", envir = envir, 
[17:43:46.999]                           inherits = FALSE)) {
[17:43:46.999]                           master <- get("master", mode = "list", 
[17:43:46.999]                             envir = envir, inherits = FALSE)
[17:43:46.999]                           if (inherits(master, c("SOCKnode", 
[17:43:46.999]                             "SOCK0node"))) {
[17:43:46.999]                             sendCondition <<- function(cond) {
[17:43:46.999]                               data <- list(type = "VALUE", value = cond, 
[17:43:46.999]                                 success = TRUE)
[17:43:46.999]                               parallel_sendData(master, data)
[17:43:46.999]                             }
[17:43:46.999]                             return(sendCondition)
[17:43:46.999]                           }
[17:43:46.999]                         }
[17:43:46.999]                         frame <- frame + 1L
[17:43:46.999]                         envir <- sys.frame(frame)
[17:43:46.999]                       }
[17:43:46.999]                     }
[17:43:46.999]                     sendCondition <<- function(cond) NULL
[17:43:46.999]                   }
[17:43:46.999]                 })
[17:43:46.999]                 withCallingHandlers({
[17:43:46.999]                   {
[17:43:46.999]                     Sys.sleep(0.5)
[17:43:46.999]                     list(a = 1, b = 42L)
[17:43:46.999]                   }
[17:43:46.999]                 }, immediateCondition = function(cond) {
[17:43:46.999]                   sendCondition <- ...future.makeSendCondition()
[17:43:46.999]                   sendCondition(cond)
[17:43:46.999]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:46.999]                   {
[17:43:46.999]                     inherits <- base::inherits
[17:43:46.999]                     invokeRestart <- base::invokeRestart
[17:43:46.999]                     is.null <- base::is.null
[17:43:46.999]                     muffled <- FALSE
[17:43:46.999]                     if (inherits(cond, "message")) {
[17:43:46.999]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:46.999]                       if (muffled) 
[17:43:46.999]                         invokeRestart("muffleMessage")
[17:43:46.999]                     }
[17:43:46.999]                     else if (inherits(cond, "warning")) {
[17:43:46.999]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:46.999]                       if (muffled) 
[17:43:46.999]                         invokeRestart("muffleWarning")
[17:43:46.999]                     }
[17:43:46.999]                     else if (inherits(cond, "condition")) {
[17:43:46.999]                       if (!is.null(pattern)) {
[17:43:46.999]                         computeRestarts <- base::computeRestarts
[17:43:46.999]                         grepl <- base::grepl
[17:43:46.999]                         restarts <- computeRestarts(cond)
[17:43:46.999]                         for (restart in restarts) {
[17:43:46.999]                           name <- restart$name
[17:43:46.999]                           if (is.null(name)) 
[17:43:46.999]                             next
[17:43:46.999]                           if (!grepl(pattern, name)) 
[17:43:46.999]                             next
[17:43:46.999]                           invokeRestart(restart)
[17:43:46.999]                           muffled <- TRUE
[17:43:46.999]                           break
[17:43:46.999]                         }
[17:43:46.999]                       }
[17:43:46.999]                     }
[17:43:46.999]                     invisible(muffled)
[17:43:46.999]                   }
[17:43:46.999]                   muffleCondition(cond)
[17:43:46.999]                 })
[17:43:46.999]             }))
[17:43:46.999]             future::FutureResult(value = ...future.value$value, 
[17:43:46.999]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:46.999]                   ...future.rng), globalenv = if (FALSE) 
[17:43:46.999]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:46.999]                     ...future.globalenv.names))
[17:43:46.999]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:46.999]         }, condition = base::local({
[17:43:46.999]             c <- base::c
[17:43:46.999]             inherits <- base::inherits
[17:43:46.999]             invokeRestart <- base::invokeRestart
[17:43:46.999]             length <- base::length
[17:43:46.999]             list <- base::list
[17:43:46.999]             seq.int <- base::seq.int
[17:43:46.999]             signalCondition <- base::signalCondition
[17:43:46.999]             sys.calls <- base::sys.calls
[17:43:46.999]             `[[` <- base::`[[`
[17:43:46.999]             `+` <- base::`+`
[17:43:46.999]             `<<-` <- base::`<<-`
[17:43:46.999]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:46.999]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:46.999]                   3L)]
[17:43:46.999]             }
[17:43:46.999]             function(cond) {
[17:43:46.999]                 is_error <- inherits(cond, "error")
[17:43:46.999]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:46.999]                   NULL)
[17:43:46.999]                 if (is_error) {
[17:43:46.999]                   sessionInformation <- function() {
[17:43:46.999]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:46.999]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:46.999]                       search = base::search(), system = base::Sys.info())
[17:43:46.999]                   }
[17:43:46.999]                   ...future.conditions[[length(...future.conditions) + 
[17:43:46.999]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:46.999]                     cond$call), session = sessionInformation(), 
[17:43:46.999]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:46.999]                   signalCondition(cond)
[17:43:46.999]                 }
[17:43:46.999]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:46.999]                 "immediateCondition"))) {
[17:43:46.999]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:46.999]                   ...future.conditions[[length(...future.conditions) + 
[17:43:46.999]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:46.999]                   if (TRUE && !signal) {
[17:43:46.999]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:46.999]                     {
[17:43:46.999]                       inherits <- base::inherits
[17:43:46.999]                       invokeRestart <- base::invokeRestart
[17:43:46.999]                       is.null <- base::is.null
[17:43:46.999]                       muffled <- FALSE
[17:43:46.999]                       if (inherits(cond, "message")) {
[17:43:46.999]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:46.999]                         if (muffled) 
[17:43:46.999]                           invokeRestart("muffleMessage")
[17:43:46.999]                       }
[17:43:46.999]                       else if (inherits(cond, "warning")) {
[17:43:46.999]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:46.999]                         if (muffled) 
[17:43:46.999]                           invokeRestart("muffleWarning")
[17:43:46.999]                       }
[17:43:46.999]                       else if (inherits(cond, "condition")) {
[17:43:46.999]                         if (!is.null(pattern)) {
[17:43:46.999]                           computeRestarts <- base::computeRestarts
[17:43:46.999]                           grepl <- base::grepl
[17:43:46.999]                           restarts <- computeRestarts(cond)
[17:43:46.999]                           for (restart in restarts) {
[17:43:46.999]                             name <- restart$name
[17:43:46.999]                             if (is.null(name)) 
[17:43:46.999]                               next
[17:43:46.999]                             if (!grepl(pattern, name)) 
[17:43:46.999]                               next
[17:43:46.999]                             invokeRestart(restart)
[17:43:46.999]                             muffled <- TRUE
[17:43:46.999]                             break
[17:43:46.999]                           }
[17:43:46.999]                         }
[17:43:46.999]                       }
[17:43:46.999]                       invisible(muffled)
[17:43:46.999]                     }
[17:43:46.999]                     muffleCondition(cond, pattern = "^muffle")
[17:43:46.999]                   }
[17:43:46.999]                 }
[17:43:46.999]                 else {
[17:43:46.999]                   if (TRUE) {
[17:43:46.999]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:46.999]                     {
[17:43:46.999]                       inherits <- base::inherits
[17:43:46.999]                       invokeRestart <- base::invokeRestart
[17:43:46.999]                       is.null <- base::is.null
[17:43:46.999]                       muffled <- FALSE
[17:43:46.999]                       if (inherits(cond, "message")) {
[17:43:46.999]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:46.999]                         if (muffled) 
[17:43:46.999]                           invokeRestart("muffleMessage")
[17:43:46.999]                       }
[17:43:46.999]                       else if (inherits(cond, "warning")) {
[17:43:46.999]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:46.999]                         if (muffled) 
[17:43:46.999]                           invokeRestart("muffleWarning")
[17:43:46.999]                       }
[17:43:46.999]                       else if (inherits(cond, "condition")) {
[17:43:46.999]                         if (!is.null(pattern)) {
[17:43:46.999]                           computeRestarts <- base::computeRestarts
[17:43:46.999]                           grepl <- base::grepl
[17:43:46.999]                           restarts <- computeRestarts(cond)
[17:43:46.999]                           for (restart in restarts) {
[17:43:46.999]                             name <- restart$name
[17:43:46.999]                             if (is.null(name)) 
[17:43:46.999]                               next
[17:43:46.999]                             if (!grepl(pattern, name)) 
[17:43:46.999]                               next
[17:43:46.999]                             invokeRestart(restart)
[17:43:46.999]                             muffled <- TRUE
[17:43:46.999]                             break
[17:43:46.999]                           }
[17:43:46.999]                         }
[17:43:46.999]                       }
[17:43:46.999]                       invisible(muffled)
[17:43:46.999]                     }
[17:43:46.999]                     muffleCondition(cond, pattern = "^muffle")
[17:43:46.999]                   }
[17:43:46.999]                 }
[17:43:46.999]             }
[17:43:46.999]         }))
[17:43:46.999]     }, error = function(ex) {
[17:43:46.999]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:46.999]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:46.999]                 ...future.rng), started = ...future.startTime, 
[17:43:46.999]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:46.999]             version = "1.8"), class = "FutureResult")
[17:43:46.999]     }, finally = {
[17:43:46.999]         if (!identical(...future.workdir, getwd())) 
[17:43:46.999]             setwd(...future.workdir)
[17:43:46.999]         {
[17:43:46.999]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:46.999]                 ...future.oldOptions$nwarnings <- NULL
[17:43:46.999]             }
[17:43:46.999]             base::options(...future.oldOptions)
[17:43:46.999]             if (.Platform$OS.type == "windows") {
[17:43:46.999]                 old_names <- names(...future.oldEnvVars)
[17:43:46.999]                 envs <- base::Sys.getenv()
[17:43:46.999]                 names <- names(envs)
[17:43:46.999]                 common <- intersect(names, old_names)
[17:43:46.999]                 added <- setdiff(names, old_names)
[17:43:46.999]                 removed <- setdiff(old_names, names)
[17:43:46.999]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:46.999]                   envs[common]]
[17:43:46.999]                 NAMES <- toupper(changed)
[17:43:46.999]                 args <- list()
[17:43:46.999]                 for (kk in seq_along(NAMES)) {
[17:43:46.999]                   name <- changed[[kk]]
[17:43:46.999]                   NAME <- NAMES[[kk]]
[17:43:46.999]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:46.999]                     next
[17:43:46.999]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:46.999]                 }
[17:43:46.999]                 NAMES <- toupper(added)
[17:43:46.999]                 for (kk in seq_along(NAMES)) {
[17:43:46.999]                   name <- added[[kk]]
[17:43:46.999]                   NAME <- NAMES[[kk]]
[17:43:46.999]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:46.999]                     next
[17:43:46.999]                   args[[name]] <- ""
[17:43:46.999]                 }
[17:43:46.999]                 NAMES <- toupper(removed)
[17:43:46.999]                 for (kk in seq_along(NAMES)) {
[17:43:46.999]                   name <- removed[[kk]]
[17:43:46.999]                   NAME <- NAMES[[kk]]
[17:43:46.999]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:46.999]                     next
[17:43:46.999]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:46.999]                 }
[17:43:46.999]                 if (length(args) > 0) 
[17:43:46.999]                   base::do.call(base::Sys.setenv, args = args)
[17:43:46.999]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:46.999]             }
[17:43:46.999]             else {
[17:43:46.999]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:46.999]             }
[17:43:46.999]             {
[17:43:46.999]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:46.999]                   0L) {
[17:43:46.999]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:46.999]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:46.999]                   base::options(opts)
[17:43:46.999]                 }
[17:43:46.999]                 {
[17:43:46.999]                   {
[17:43:46.999]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:46.999]                     NULL
[17:43:46.999]                   }
[17:43:46.999]                   options(future.plan = NULL)
[17:43:46.999]                   if (is.na(NA_character_)) 
[17:43:46.999]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:46.999]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:46.999]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:46.999]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:46.999]                     envir = parent.frame()) 
[17:43:46.999]                   {
[17:43:46.999]                     if (is.function(workers)) 
[17:43:46.999]                       workers <- workers()
[17:43:46.999]                     workers <- structure(as.integer(workers), 
[17:43:46.999]                       class = class(workers))
[17:43:46.999]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:46.999]                       workers >= 1)
[17:43:46.999]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:46.999]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:46.999]                     }
[17:43:46.999]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:46.999]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:46.999]                       envir = envir)
[17:43:46.999]                     if (!future$lazy) 
[17:43:46.999]                       future <- run(future)
[17:43:46.999]                     invisible(future)
[17:43:46.999]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:46.999]                 }
[17:43:46.999]             }
[17:43:46.999]         }
[17:43:46.999]     })
[17:43:46.999]     if (TRUE) {
[17:43:46.999]         base::sink(type = "output", split = FALSE)
[17:43:46.999]         if (TRUE) {
[17:43:46.999]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:46.999]         }
[17:43:46.999]         else {
[17:43:46.999]             ...future.result["stdout"] <- base::list(NULL)
[17:43:46.999]         }
[17:43:46.999]         base::close(...future.stdout)
[17:43:46.999]         ...future.stdout <- NULL
[17:43:46.999]     }
[17:43:46.999]     ...future.result$conditions <- ...future.conditions
[17:43:46.999]     ...future.result$finished <- base::Sys.time()
[17:43:46.999]     ...future.result
[17:43:46.999] }
[17:43:47.002] MultisessionFuture started
[17:43:47.002] - Launch lazy future ... done
[17:43:47.002] run() for ‘MultisessionFuture’ ... done
[17:43:47.549] receiveMessageFromWorker() for ClusterFuture ...
[17:43:47.549] - Validating connection of MultisessionFuture
[17:43:47.549] - received message: FutureResult
[17:43:47.549] - Received FutureResult
[17:43:47.549] - Erased future from FutureRegistry
[17:43:47.550] result() for ClusterFuture ...
[17:43:47.550] - result already collected: FutureResult
[17:43:47.550] result() for ClusterFuture ... done
[17:43:47.550] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:47.550] resolve() on list ...
[17:43:47.550]  recursive: 98
[17:43:47.550]  length: 2
[17:43:47.550]  elements: ‘a’, ‘b’
[17:43:47.550]  length: 1 (resolved future 1)
[17:43:47.551]  length: 0 (resolved future 2)
[17:43:47.551] resolve() on list ... DONE
[17:43:47.551] A MultisessionFuture was resolved (and resolved itself)
[17:43:47.551] getGlobalsAndPackages() ...
[17:43:47.551] Searching for globals...
[17:43:47.552] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:43:47.552] Searching for globals ... DONE
[17:43:47.552] Resolving globals: FALSE
[17:43:47.553] 
[17:43:47.553] 
[17:43:47.553] getGlobalsAndPackages() ... DONE
[17:43:47.553] run() for ‘Future’ ...
[17:43:47.553] - state: ‘created’
[17:43:47.553] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:47.568] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:47.568] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:47.568]   - Field: ‘node’
[17:43:47.568]   - Field: ‘label’
[17:43:47.568]   - Field: ‘local’
[17:43:47.573]   - Field: ‘owner’
[17:43:47.573]   - Field: ‘envir’
[17:43:47.573]   - Field: ‘workers’
[17:43:47.573]   - Field: ‘packages’
[17:43:47.574]   - Field: ‘gc’
[17:43:47.574]   - Field: ‘conditions’
[17:43:47.574]   - Field: ‘persistent’
[17:43:47.574]   - Field: ‘expr’
[17:43:47.574]   - Field: ‘uuid’
[17:43:47.574]   - Field: ‘seed’
[17:43:47.574]   - Field: ‘version’
[17:43:47.574]   - Field: ‘result’
[17:43:47.574]   - Field: ‘asynchronous’
[17:43:47.574]   - Field: ‘calls’
[17:43:47.574]   - Field: ‘globals’
[17:43:47.575]   - Field: ‘stdout’
[17:43:47.575]   - Field: ‘earlySignal’
[17:43:47.575]   - Field: ‘lazy’
[17:43:47.575]   - Field: ‘state’
[17:43:47.575] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:47.575] - Launch lazy future ...
[17:43:47.575] Packages needed by the future expression (n = 0): <none>
[17:43:47.575] Packages needed by future strategies (n = 0): <none>
[17:43:47.576] {
[17:43:47.576]     {
[17:43:47.576]         {
[17:43:47.576]             ...future.startTime <- base::Sys.time()
[17:43:47.576]             {
[17:43:47.576]                 {
[17:43:47.576]                   {
[17:43:47.576]                     {
[17:43:47.576]                       base::local({
[17:43:47.576]                         has_future <- base::requireNamespace("future", 
[17:43:47.576]                           quietly = TRUE)
[17:43:47.576]                         if (has_future) {
[17:43:47.576]                           ns <- base::getNamespace("future")
[17:43:47.576]                           version <- ns[[".package"]][["version"]]
[17:43:47.576]                           if (is.null(version)) 
[17:43:47.576]                             version <- utils::packageVersion("future")
[17:43:47.576]                         }
[17:43:47.576]                         else {
[17:43:47.576]                           version <- NULL
[17:43:47.576]                         }
[17:43:47.576]                         if (!has_future || version < "1.8.0") {
[17:43:47.576]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:47.576]                             "", base::R.version$version.string), 
[17:43:47.576]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:47.576]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:47.576]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:47.576]                               "release", "version")], collapse = " "), 
[17:43:47.576]                             hostname = base::Sys.info()[["nodename"]])
[17:43:47.576]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:47.576]                             info)
[17:43:47.576]                           info <- base::paste(info, collapse = "; ")
[17:43:47.576]                           if (!has_future) {
[17:43:47.576]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:47.576]                               info)
[17:43:47.576]                           }
[17:43:47.576]                           else {
[17:43:47.576]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:47.576]                               info, version)
[17:43:47.576]                           }
[17:43:47.576]                           base::stop(msg)
[17:43:47.576]                         }
[17:43:47.576]                       })
[17:43:47.576]                     }
[17:43:47.576]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:47.576]                     base::options(mc.cores = 1L)
[17:43:47.576]                   }
[17:43:47.576]                   options(future.plan = NULL)
[17:43:47.576]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:47.576]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:47.576]                 }
[17:43:47.576]                 ...future.workdir <- getwd()
[17:43:47.576]             }
[17:43:47.576]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:47.576]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:47.576]         }
[17:43:47.576]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:47.576]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:47.576]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:47.576]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:47.576]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:47.576]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:47.576]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:47.576]             base::names(...future.oldOptions))
[17:43:47.576]     }
[17:43:47.576]     if (FALSE) {
[17:43:47.576]     }
[17:43:47.576]     else {
[17:43:47.576]         if (TRUE) {
[17:43:47.576]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:47.576]                 open = "w")
[17:43:47.576]         }
[17:43:47.576]         else {
[17:43:47.576]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:47.576]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:47.576]         }
[17:43:47.576]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:47.576]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:47.576]             base::sink(type = "output", split = FALSE)
[17:43:47.576]             base::close(...future.stdout)
[17:43:47.576]         }, add = TRUE)
[17:43:47.576]     }
[17:43:47.576]     ...future.frame <- base::sys.nframe()
[17:43:47.576]     ...future.conditions <- base::list()
[17:43:47.576]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:47.576]     if (FALSE) {
[17:43:47.576]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:47.576]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:47.576]     }
[17:43:47.576]     ...future.result <- base::tryCatch({
[17:43:47.576]         base::withCallingHandlers({
[17:43:47.576]             ...future.value <- base::withVisible(base::local({
[17:43:47.576]                 ...future.makeSendCondition <- local({
[17:43:47.576]                   sendCondition <- NULL
[17:43:47.576]                   function(frame = 1L) {
[17:43:47.576]                     if (is.function(sendCondition)) 
[17:43:47.576]                       return(sendCondition)
[17:43:47.576]                     ns <- getNamespace("parallel")
[17:43:47.576]                     if (exists("sendData", mode = "function", 
[17:43:47.576]                       envir = ns)) {
[17:43:47.576]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:47.576]                         envir = ns)
[17:43:47.576]                       envir <- sys.frame(frame)
[17:43:47.576]                       master <- NULL
[17:43:47.576]                       while (!identical(envir, .GlobalEnv) && 
[17:43:47.576]                         !identical(envir, emptyenv())) {
[17:43:47.576]                         if (exists("master", mode = "list", envir = envir, 
[17:43:47.576]                           inherits = FALSE)) {
[17:43:47.576]                           master <- get("master", mode = "list", 
[17:43:47.576]                             envir = envir, inherits = FALSE)
[17:43:47.576]                           if (inherits(master, c("SOCKnode", 
[17:43:47.576]                             "SOCK0node"))) {
[17:43:47.576]                             sendCondition <<- function(cond) {
[17:43:47.576]                               data <- list(type = "VALUE", value = cond, 
[17:43:47.576]                                 success = TRUE)
[17:43:47.576]                               parallel_sendData(master, data)
[17:43:47.576]                             }
[17:43:47.576]                             return(sendCondition)
[17:43:47.576]                           }
[17:43:47.576]                         }
[17:43:47.576]                         frame <- frame + 1L
[17:43:47.576]                         envir <- sys.frame(frame)
[17:43:47.576]                       }
[17:43:47.576]                     }
[17:43:47.576]                     sendCondition <<- function(cond) NULL
[17:43:47.576]                   }
[17:43:47.576]                 })
[17:43:47.576]                 withCallingHandlers({
[17:43:47.576]                   {
[17:43:47.576]                     Sys.sleep(0.5)
[17:43:47.576]                     list(a = 1, b = 42L)
[17:43:47.576]                   }
[17:43:47.576]                 }, immediateCondition = function(cond) {
[17:43:47.576]                   sendCondition <- ...future.makeSendCondition()
[17:43:47.576]                   sendCondition(cond)
[17:43:47.576]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:47.576]                   {
[17:43:47.576]                     inherits <- base::inherits
[17:43:47.576]                     invokeRestart <- base::invokeRestart
[17:43:47.576]                     is.null <- base::is.null
[17:43:47.576]                     muffled <- FALSE
[17:43:47.576]                     if (inherits(cond, "message")) {
[17:43:47.576]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:47.576]                       if (muffled) 
[17:43:47.576]                         invokeRestart("muffleMessage")
[17:43:47.576]                     }
[17:43:47.576]                     else if (inherits(cond, "warning")) {
[17:43:47.576]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:47.576]                       if (muffled) 
[17:43:47.576]                         invokeRestart("muffleWarning")
[17:43:47.576]                     }
[17:43:47.576]                     else if (inherits(cond, "condition")) {
[17:43:47.576]                       if (!is.null(pattern)) {
[17:43:47.576]                         computeRestarts <- base::computeRestarts
[17:43:47.576]                         grepl <- base::grepl
[17:43:47.576]                         restarts <- computeRestarts(cond)
[17:43:47.576]                         for (restart in restarts) {
[17:43:47.576]                           name <- restart$name
[17:43:47.576]                           if (is.null(name)) 
[17:43:47.576]                             next
[17:43:47.576]                           if (!grepl(pattern, name)) 
[17:43:47.576]                             next
[17:43:47.576]                           invokeRestart(restart)
[17:43:47.576]                           muffled <- TRUE
[17:43:47.576]                           break
[17:43:47.576]                         }
[17:43:47.576]                       }
[17:43:47.576]                     }
[17:43:47.576]                     invisible(muffled)
[17:43:47.576]                   }
[17:43:47.576]                   muffleCondition(cond)
[17:43:47.576]                 })
[17:43:47.576]             }))
[17:43:47.576]             future::FutureResult(value = ...future.value$value, 
[17:43:47.576]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:47.576]                   ...future.rng), globalenv = if (FALSE) 
[17:43:47.576]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:47.576]                     ...future.globalenv.names))
[17:43:47.576]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:47.576]         }, condition = base::local({
[17:43:47.576]             c <- base::c
[17:43:47.576]             inherits <- base::inherits
[17:43:47.576]             invokeRestart <- base::invokeRestart
[17:43:47.576]             length <- base::length
[17:43:47.576]             list <- base::list
[17:43:47.576]             seq.int <- base::seq.int
[17:43:47.576]             signalCondition <- base::signalCondition
[17:43:47.576]             sys.calls <- base::sys.calls
[17:43:47.576]             `[[` <- base::`[[`
[17:43:47.576]             `+` <- base::`+`
[17:43:47.576]             `<<-` <- base::`<<-`
[17:43:47.576]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:47.576]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:47.576]                   3L)]
[17:43:47.576]             }
[17:43:47.576]             function(cond) {
[17:43:47.576]                 is_error <- inherits(cond, "error")
[17:43:47.576]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:47.576]                   NULL)
[17:43:47.576]                 if (is_error) {
[17:43:47.576]                   sessionInformation <- function() {
[17:43:47.576]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:47.576]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:47.576]                       search = base::search(), system = base::Sys.info())
[17:43:47.576]                   }
[17:43:47.576]                   ...future.conditions[[length(...future.conditions) + 
[17:43:47.576]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:47.576]                     cond$call), session = sessionInformation(), 
[17:43:47.576]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:47.576]                   signalCondition(cond)
[17:43:47.576]                 }
[17:43:47.576]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:47.576]                 "immediateCondition"))) {
[17:43:47.576]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:47.576]                   ...future.conditions[[length(...future.conditions) + 
[17:43:47.576]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:47.576]                   if (TRUE && !signal) {
[17:43:47.576]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:47.576]                     {
[17:43:47.576]                       inherits <- base::inherits
[17:43:47.576]                       invokeRestart <- base::invokeRestart
[17:43:47.576]                       is.null <- base::is.null
[17:43:47.576]                       muffled <- FALSE
[17:43:47.576]                       if (inherits(cond, "message")) {
[17:43:47.576]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:47.576]                         if (muffled) 
[17:43:47.576]                           invokeRestart("muffleMessage")
[17:43:47.576]                       }
[17:43:47.576]                       else if (inherits(cond, "warning")) {
[17:43:47.576]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:47.576]                         if (muffled) 
[17:43:47.576]                           invokeRestart("muffleWarning")
[17:43:47.576]                       }
[17:43:47.576]                       else if (inherits(cond, "condition")) {
[17:43:47.576]                         if (!is.null(pattern)) {
[17:43:47.576]                           computeRestarts <- base::computeRestarts
[17:43:47.576]                           grepl <- base::grepl
[17:43:47.576]                           restarts <- computeRestarts(cond)
[17:43:47.576]                           for (restart in restarts) {
[17:43:47.576]                             name <- restart$name
[17:43:47.576]                             if (is.null(name)) 
[17:43:47.576]                               next
[17:43:47.576]                             if (!grepl(pattern, name)) 
[17:43:47.576]                               next
[17:43:47.576]                             invokeRestart(restart)
[17:43:47.576]                             muffled <- TRUE
[17:43:47.576]                             break
[17:43:47.576]                           }
[17:43:47.576]                         }
[17:43:47.576]                       }
[17:43:47.576]                       invisible(muffled)
[17:43:47.576]                     }
[17:43:47.576]                     muffleCondition(cond, pattern = "^muffle")
[17:43:47.576]                   }
[17:43:47.576]                 }
[17:43:47.576]                 else {
[17:43:47.576]                   if (TRUE) {
[17:43:47.576]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:47.576]                     {
[17:43:47.576]                       inherits <- base::inherits
[17:43:47.576]                       invokeRestart <- base::invokeRestart
[17:43:47.576]                       is.null <- base::is.null
[17:43:47.576]                       muffled <- FALSE
[17:43:47.576]                       if (inherits(cond, "message")) {
[17:43:47.576]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:47.576]                         if (muffled) 
[17:43:47.576]                           invokeRestart("muffleMessage")
[17:43:47.576]                       }
[17:43:47.576]                       else if (inherits(cond, "warning")) {
[17:43:47.576]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:47.576]                         if (muffled) 
[17:43:47.576]                           invokeRestart("muffleWarning")
[17:43:47.576]                       }
[17:43:47.576]                       else if (inherits(cond, "condition")) {
[17:43:47.576]                         if (!is.null(pattern)) {
[17:43:47.576]                           computeRestarts <- base::computeRestarts
[17:43:47.576]                           grepl <- base::grepl
[17:43:47.576]                           restarts <- computeRestarts(cond)
[17:43:47.576]                           for (restart in restarts) {
[17:43:47.576]                             name <- restart$name
[17:43:47.576]                             if (is.null(name)) 
[17:43:47.576]                               next
[17:43:47.576]                             if (!grepl(pattern, name)) 
[17:43:47.576]                               next
[17:43:47.576]                             invokeRestart(restart)
[17:43:47.576]                             muffled <- TRUE
[17:43:47.576]                             break
[17:43:47.576]                           }
[17:43:47.576]                         }
[17:43:47.576]                       }
[17:43:47.576]                       invisible(muffled)
[17:43:47.576]                     }
[17:43:47.576]                     muffleCondition(cond, pattern = "^muffle")
[17:43:47.576]                   }
[17:43:47.576]                 }
[17:43:47.576]             }
[17:43:47.576]         }))
[17:43:47.576]     }, error = function(ex) {
[17:43:47.576]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:47.576]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:47.576]                 ...future.rng), started = ...future.startTime, 
[17:43:47.576]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:47.576]             version = "1.8"), class = "FutureResult")
[17:43:47.576]     }, finally = {
[17:43:47.576]         if (!identical(...future.workdir, getwd())) 
[17:43:47.576]             setwd(...future.workdir)
[17:43:47.576]         {
[17:43:47.576]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:47.576]                 ...future.oldOptions$nwarnings <- NULL
[17:43:47.576]             }
[17:43:47.576]             base::options(...future.oldOptions)
[17:43:47.576]             if (.Platform$OS.type == "windows") {
[17:43:47.576]                 old_names <- names(...future.oldEnvVars)
[17:43:47.576]                 envs <- base::Sys.getenv()
[17:43:47.576]                 names <- names(envs)
[17:43:47.576]                 common <- intersect(names, old_names)
[17:43:47.576]                 added <- setdiff(names, old_names)
[17:43:47.576]                 removed <- setdiff(old_names, names)
[17:43:47.576]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:47.576]                   envs[common]]
[17:43:47.576]                 NAMES <- toupper(changed)
[17:43:47.576]                 args <- list()
[17:43:47.576]                 for (kk in seq_along(NAMES)) {
[17:43:47.576]                   name <- changed[[kk]]
[17:43:47.576]                   NAME <- NAMES[[kk]]
[17:43:47.576]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.576]                     next
[17:43:47.576]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:47.576]                 }
[17:43:47.576]                 NAMES <- toupper(added)
[17:43:47.576]                 for (kk in seq_along(NAMES)) {
[17:43:47.576]                   name <- added[[kk]]
[17:43:47.576]                   NAME <- NAMES[[kk]]
[17:43:47.576]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.576]                     next
[17:43:47.576]                   args[[name]] <- ""
[17:43:47.576]                 }
[17:43:47.576]                 NAMES <- toupper(removed)
[17:43:47.576]                 for (kk in seq_along(NAMES)) {
[17:43:47.576]                   name <- removed[[kk]]
[17:43:47.576]                   NAME <- NAMES[[kk]]
[17:43:47.576]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:47.576]                     next
[17:43:47.576]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:47.576]                 }
[17:43:47.576]                 if (length(args) > 0) 
[17:43:47.576]                   base::do.call(base::Sys.setenv, args = args)
[17:43:47.576]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:47.576]             }
[17:43:47.576]             else {
[17:43:47.576]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:47.576]             }
[17:43:47.576]             {
[17:43:47.576]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:47.576]                   0L) {
[17:43:47.576]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:47.576]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:47.576]                   base::options(opts)
[17:43:47.576]                 }
[17:43:47.576]                 {
[17:43:47.576]                   {
[17:43:47.576]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:47.576]                     NULL
[17:43:47.576]                   }
[17:43:47.576]                   options(future.plan = NULL)
[17:43:47.576]                   if (is.na(NA_character_)) 
[17:43:47.576]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:47.576]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:47.576]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:47.576]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:47.576]                     envir = parent.frame()) 
[17:43:47.576]                   {
[17:43:47.576]                     if (is.function(workers)) 
[17:43:47.576]                       workers <- workers()
[17:43:47.576]                     workers <- structure(as.integer(workers), 
[17:43:47.576]                       class = class(workers))
[17:43:47.576]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:47.576]                       workers >= 1)
[17:43:47.576]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:47.576]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:47.576]                     }
[17:43:47.576]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:47.576]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:47.576]                       envir = envir)
[17:43:47.576]                     if (!future$lazy) 
[17:43:47.576]                       future <- run(future)
[17:43:47.576]                     invisible(future)
[17:43:47.576]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:47.576]                 }
[17:43:47.576]             }
[17:43:47.576]         }
[17:43:47.576]     })
[17:43:47.576]     if (TRUE) {
[17:43:47.576]         base::sink(type = "output", split = FALSE)
[17:43:47.576]         if (TRUE) {
[17:43:47.576]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:47.576]         }
[17:43:47.576]         else {
[17:43:47.576]             ...future.result["stdout"] <- base::list(NULL)
[17:43:47.576]         }
[17:43:47.576]         base::close(...future.stdout)
[17:43:47.576]         ...future.stdout <- NULL
[17:43:47.576]     }
[17:43:47.576]     ...future.result$conditions <- ...future.conditions
[17:43:47.576]     ...future.result$finished <- base::Sys.time()
[17:43:47.576]     ...future.result
[17:43:47.576] }
[17:43:47.579] MultisessionFuture started
[17:43:47.579] - Launch lazy future ... done
[17:43:47.580] run() for ‘MultisessionFuture’ ... done
[17:43:48.129] receiveMessageFromWorker() for ClusterFuture ...
[17:43:48.129] - Validating connection of MultisessionFuture
[17:43:48.129] - received message: FutureResult
[17:43:48.129] - Received FutureResult
[17:43:48.130] - Erased future from FutureRegistry
[17:43:48.130] result() for ClusterFuture ...
[17:43:48.130] - result already collected: FutureResult
[17:43:48.130] result() for ClusterFuture ... done
[17:43:48.130] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:48.130] resolve() on list ...
[17:43:48.130]  recursive: 98
[17:43:48.130]  length: 2
[17:43:48.130]  elements: ‘a’, ‘b’
[17:43:48.131]  length: 1 (resolved future 1)
[17:43:48.131]  length: 0 (resolved future 2)
[17:43:48.131] resolve() on list ... DONE
[17:43:48.131] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[17:43:48.131] getGlobalsAndPackages() ...
[17:43:48.131] Searching for globals...
[17:43:48.132] - globals found: [2] ‘list’, ‘stop’
[17:43:48.132] Searching for globals ... DONE
[17:43:48.132] Resolving globals: FALSE
[17:43:48.132] 
[17:43:48.132] 
[17:43:48.132] getGlobalsAndPackages() ... DONE
[17:43:48.133] run() for ‘Future’ ...
[17:43:48.133] - state: ‘created’
[17:43:48.133] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:48.147] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:48.147] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:48.147]   - Field: ‘node’
[17:43:48.148]   - Field: ‘label’
[17:43:48.148]   - Field: ‘local’
[17:43:48.148]   - Field: ‘owner’
[17:43:48.148]   - Field: ‘envir’
[17:43:48.148]   - Field: ‘workers’
[17:43:48.148]   - Field: ‘packages’
[17:43:48.148]   - Field: ‘gc’
[17:43:48.148]   - Field: ‘conditions’
[17:43:48.148]   - Field: ‘persistent’
[17:43:48.148]   - Field: ‘expr’
[17:43:48.149]   - Field: ‘uuid’
[17:43:48.149]   - Field: ‘seed’
[17:43:48.149]   - Field: ‘version’
[17:43:48.149]   - Field: ‘result’
[17:43:48.149]   - Field: ‘asynchronous’
[17:43:48.149]   - Field: ‘calls’
[17:43:48.149]   - Field: ‘globals’
[17:43:48.149]   - Field: ‘stdout’
[17:43:48.149]   - Field: ‘earlySignal’
[17:43:48.149]   - Field: ‘lazy’
[17:43:48.149]   - Field: ‘state’
[17:43:48.150] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:48.150] - Launch lazy future ...
[17:43:48.150] Packages needed by the future expression (n = 0): <none>
[17:43:48.150] Packages needed by future strategies (n = 0): <none>
[17:43:48.150] {
[17:43:48.150]     {
[17:43:48.150]         {
[17:43:48.150]             ...future.startTime <- base::Sys.time()
[17:43:48.150]             {
[17:43:48.150]                 {
[17:43:48.150]                   {
[17:43:48.150]                     {
[17:43:48.150]                       base::local({
[17:43:48.150]                         has_future <- base::requireNamespace("future", 
[17:43:48.150]                           quietly = TRUE)
[17:43:48.150]                         if (has_future) {
[17:43:48.150]                           ns <- base::getNamespace("future")
[17:43:48.150]                           version <- ns[[".package"]][["version"]]
[17:43:48.150]                           if (is.null(version)) 
[17:43:48.150]                             version <- utils::packageVersion("future")
[17:43:48.150]                         }
[17:43:48.150]                         else {
[17:43:48.150]                           version <- NULL
[17:43:48.150]                         }
[17:43:48.150]                         if (!has_future || version < "1.8.0") {
[17:43:48.150]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:48.150]                             "", base::R.version$version.string), 
[17:43:48.150]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:48.150]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:48.150]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:48.150]                               "release", "version")], collapse = " "), 
[17:43:48.150]                             hostname = base::Sys.info()[["nodename"]])
[17:43:48.150]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:48.150]                             info)
[17:43:48.150]                           info <- base::paste(info, collapse = "; ")
[17:43:48.150]                           if (!has_future) {
[17:43:48.150]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:48.150]                               info)
[17:43:48.150]                           }
[17:43:48.150]                           else {
[17:43:48.150]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:48.150]                               info, version)
[17:43:48.150]                           }
[17:43:48.150]                           base::stop(msg)
[17:43:48.150]                         }
[17:43:48.150]                       })
[17:43:48.150]                     }
[17:43:48.150]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:48.150]                     base::options(mc.cores = 1L)
[17:43:48.150]                   }
[17:43:48.150]                   options(future.plan = NULL)
[17:43:48.150]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.150]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:48.150]                 }
[17:43:48.150]                 ...future.workdir <- getwd()
[17:43:48.150]             }
[17:43:48.150]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:48.150]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:48.150]         }
[17:43:48.150]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:48.150]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:48.150]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:48.150]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:48.150]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:48.150]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:48.150]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:48.150]             base::names(...future.oldOptions))
[17:43:48.150]     }
[17:43:48.150]     if (FALSE) {
[17:43:48.150]     }
[17:43:48.150]     else {
[17:43:48.150]         if (TRUE) {
[17:43:48.150]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:48.150]                 open = "w")
[17:43:48.150]         }
[17:43:48.150]         else {
[17:43:48.150]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:48.150]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:48.150]         }
[17:43:48.150]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:48.150]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:48.150]             base::sink(type = "output", split = FALSE)
[17:43:48.150]             base::close(...future.stdout)
[17:43:48.150]         }, add = TRUE)
[17:43:48.150]     }
[17:43:48.150]     ...future.frame <- base::sys.nframe()
[17:43:48.150]     ...future.conditions <- base::list()
[17:43:48.150]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:48.150]     if (FALSE) {
[17:43:48.150]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:48.150]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:48.150]     }
[17:43:48.150]     ...future.result <- base::tryCatch({
[17:43:48.150]         base::withCallingHandlers({
[17:43:48.150]             ...future.value <- base::withVisible(base::local({
[17:43:48.150]                 ...future.makeSendCondition <- local({
[17:43:48.150]                   sendCondition <- NULL
[17:43:48.150]                   function(frame = 1L) {
[17:43:48.150]                     if (is.function(sendCondition)) 
[17:43:48.150]                       return(sendCondition)
[17:43:48.150]                     ns <- getNamespace("parallel")
[17:43:48.150]                     if (exists("sendData", mode = "function", 
[17:43:48.150]                       envir = ns)) {
[17:43:48.150]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:48.150]                         envir = ns)
[17:43:48.150]                       envir <- sys.frame(frame)
[17:43:48.150]                       master <- NULL
[17:43:48.150]                       while (!identical(envir, .GlobalEnv) && 
[17:43:48.150]                         !identical(envir, emptyenv())) {
[17:43:48.150]                         if (exists("master", mode = "list", envir = envir, 
[17:43:48.150]                           inherits = FALSE)) {
[17:43:48.150]                           master <- get("master", mode = "list", 
[17:43:48.150]                             envir = envir, inherits = FALSE)
[17:43:48.150]                           if (inherits(master, c("SOCKnode", 
[17:43:48.150]                             "SOCK0node"))) {
[17:43:48.150]                             sendCondition <<- function(cond) {
[17:43:48.150]                               data <- list(type = "VALUE", value = cond, 
[17:43:48.150]                                 success = TRUE)
[17:43:48.150]                               parallel_sendData(master, data)
[17:43:48.150]                             }
[17:43:48.150]                             return(sendCondition)
[17:43:48.150]                           }
[17:43:48.150]                         }
[17:43:48.150]                         frame <- frame + 1L
[17:43:48.150]                         envir <- sys.frame(frame)
[17:43:48.150]                       }
[17:43:48.150]                     }
[17:43:48.150]                     sendCondition <<- function(cond) NULL
[17:43:48.150]                   }
[17:43:48.150]                 })
[17:43:48.150]                 withCallingHandlers({
[17:43:48.150]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:43:48.150]                 }, immediateCondition = function(cond) {
[17:43:48.150]                   sendCondition <- ...future.makeSendCondition()
[17:43:48.150]                   sendCondition(cond)
[17:43:48.150]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.150]                   {
[17:43:48.150]                     inherits <- base::inherits
[17:43:48.150]                     invokeRestart <- base::invokeRestart
[17:43:48.150]                     is.null <- base::is.null
[17:43:48.150]                     muffled <- FALSE
[17:43:48.150]                     if (inherits(cond, "message")) {
[17:43:48.150]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:48.150]                       if (muffled) 
[17:43:48.150]                         invokeRestart("muffleMessage")
[17:43:48.150]                     }
[17:43:48.150]                     else if (inherits(cond, "warning")) {
[17:43:48.150]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:48.150]                       if (muffled) 
[17:43:48.150]                         invokeRestart("muffleWarning")
[17:43:48.150]                     }
[17:43:48.150]                     else if (inherits(cond, "condition")) {
[17:43:48.150]                       if (!is.null(pattern)) {
[17:43:48.150]                         computeRestarts <- base::computeRestarts
[17:43:48.150]                         grepl <- base::grepl
[17:43:48.150]                         restarts <- computeRestarts(cond)
[17:43:48.150]                         for (restart in restarts) {
[17:43:48.150]                           name <- restart$name
[17:43:48.150]                           if (is.null(name)) 
[17:43:48.150]                             next
[17:43:48.150]                           if (!grepl(pattern, name)) 
[17:43:48.150]                             next
[17:43:48.150]                           invokeRestart(restart)
[17:43:48.150]                           muffled <- TRUE
[17:43:48.150]                           break
[17:43:48.150]                         }
[17:43:48.150]                       }
[17:43:48.150]                     }
[17:43:48.150]                     invisible(muffled)
[17:43:48.150]                   }
[17:43:48.150]                   muffleCondition(cond)
[17:43:48.150]                 })
[17:43:48.150]             }))
[17:43:48.150]             future::FutureResult(value = ...future.value$value, 
[17:43:48.150]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.150]                   ...future.rng), globalenv = if (FALSE) 
[17:43:48.150]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:48.150]                     ...future.globalenv.names))
[17:43:48.150]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:48.150]         }, condition = base::local({
[17:43:48.150]             c <- base::c
[17:43:48.150]             inherits <- base::inherits
[17:43:48.150]             invokeRestart <- base::invokeRestart
[17:43:48.150]             length <- base::length
[17:43:48.150]             list <- base::list
[17:43:48.150]             seq.int <- base::seq.int
[17:43:48.150]             signalCondition <- base::signalCondition
[17:43:48.150]             sys.calls <- base::sys.calls
[17:43:48.150]             `[[` <- base::`[[`
[17:43:48.150]             `+` <- base::`+`
[17:43:48.150]             `<<-` <- base::`<<-`
[17:43:48.150]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:48.150]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:48.150]                   3L)]
[17:43:48.150]             }
[17:43:48.150]             function(cond) {
[17:43:48.150]                 is_error <- inherits(cond, "error")
[17:43:48.150]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:48.150]                   NULL)
[17:43:48.150]                 if (is_error) {
[17:43:48.150]                   sessionInformation <- function() {
[17:43:48.150]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:48.150]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:48.150]                       search = base::search(), system = base::Sys.info())
[17:43:48.150]                   }
[17:43:48.150]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.150]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:48.150]                     cond$call), session = sessionInformation(), 
[17:43:48.150]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:48.150]                   signalCondition(cond)
[17:43:48.150]                 }
[17:43:48.150]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:48.150]                 "immediateCondition"))) {
[17:43:48.150]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:48.150]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.150]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:48.150]                   if (TRUE && !signal) {
[17:43:48.150]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.150]                     {
[17:43:48.150]                       inherits <- base::inherits
[17:43:48.150]                       invokeRestart <- base::invokeRestart
[17:43:48.150]                       is.null <- base::is.null
[17:43:48.150]                       muffled <- FALSE
[17:43:48.150]                       if (inherits(cond, "message")) {
[17:43:48.150]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.150]                         if (muffled) 
[17:43:48.150]                           invokeRestart("muffleMessage")
[17:43:48.150]                       }
[17:43:48.150]                       else if (inherits(cond, "warning")) {
[17:43:48.150]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.150]                         if (muffled) 
[17:43:48.150]                           invokeRestart("muffleWarning")
[17:43:48.150]                       }
[17:43:48.150]                       else if (inherits(cond, "condition")) {
[17:43:48.150]                         if (!is.null(pattern)) {
[17:43:48.150]                           computeRestarts <- base::computeRestarts
[17:43:48.150]                           grepl <- base::grepl
[17:43:48.150]                           restarts <- computeRestarts(cond)
[17:43:48.150]                           for (restart in restarts) {
[17:43:48.150]                             name <- restart$name
[17:43:48.150]                             if (is.null(name)) 
[17:43:48.150]                               next
[17:43:48.150]                             if (!grepl(pattern, name)) 
[17:43:48.150]                               next
[17:43:48.150]                             invokeRestart(restart)
[17:43:48.150]                             muffled <- TRUE
[17:43:48.150]                             break
[17:43:48.150]                           }
[17:43:48.150]                         }
[17:43:48.150]                       }
[17:43:48.150]                       invisible(muffled)
[17:43:48.150]                     }
[17:43:48.150]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.150]                   }
[17:43:48.150]                 }
[17:43:48.150]                 else {
[17:43:48.150]                   if (TRUE) {
[17:43:48.150]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.150]                     {
[17:43:48.150]                       inherits <- base::inherits
[17:43:48.150]                       invokeRestart <- base::invokeRestart
[17:43:48.150]                       is.null <- base::is.null
[17:43:48.150]                       muffled <- FALSE
[17:43:48.150]                       if (inherits(cond, "message")) {
[17:43:48.150]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.150]                         if (muffled) 
[17:43:48.150]                           invokeRestart("muffleMessage")
[17:43:48.150]                       }
[17:43:48.150]                       else if (inherits(cond, "warning")) {
[17:43:48.150]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.150]                         if (muffled) 
[17:43:48.150]                           invokeRestart("muffleWarning")
[17:43:48.150]                       }
[17:43:48.150]                       else if (inherits(cond, "condition")) {
[17:43:48.150]                         if (!is.null(pattern)) {
[17:43:48.150]                           computeRestarts <- base::computeRestarts
[17:43:48.150]                           grepl <- base::grepl
[17:43:48.150]                           restarts <- computeRestarts(cond)
[17:43:48.150]                           for (restart in restarts) {
[17:43:48.150]                             name <- restart$name
[17:43:48.150]                             if (is.null(name)) 
[17:43:48.150]                               next
[17:43:48.150]                             if (!grepl(pattern, name)) 
[17:43:48.150]                               next
[17:43:48.150]                             invokeRestart(restart)
[17:43:48.150]                             muffled <- TRUE
[17:43:48.150]                             break
[17:43:48.150]                           }
[17:43:48.150]                         }
[17:43:48.150]                       }
[17:43:48.150]                       invisible(muffled)
[17:43:48.150]                     }
[17:43:48.150]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.150]                   }
[17:43:48.150]                 }
[17:43:48.150]             }
[17:43:48.150]         }))
[17:43:48.150]     }, error = function(ex) {
[17:43:48.150]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:48.150]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.150]                 ...future.rng), started = ...future.startTime, 
[17:43:48.150]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:48.150]             version = "1.8"), class = "FutureResult")
[17:43:48.150]     }, finally = {
[17:43:48.150]         if (!identical(...future.workdir, getwd())) 
[17:43:48.150]             setwd(...future.workdir)
[17:43:48.150]         {
[17:43:48.150]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:48.150]                 ...future.oldOptions$nwarnings <- NULL
[17:43:48.150]             }
[17:43:48.150]             base::options(...future.oldOptions)
[17:43:48.150]             if (.Platform$OS.type == "windows") {
[17:43:48.150]                 old_names <- names(...future.oldEnvVars)
[17:43:48.150]                 envs <- base::Sys.getenv()
[17:43:48.150]                 names <- names(envs)
[17:43:48.150]                 common <- intersect(names, old_names)
[17:43:48.150]                 added <- setdiff(names, old_names)
[17:43:48.150]                 removed <- setdiff(old_names, names)
[17:43:48.150]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:48.150]                   envs[common]]
[17:43:48.150]                 NAMES <- toupper(changed)
[17:43:48.150]                 args <- list()
[17:43:48.150]                 for (kk in seq_along(NAMES)) {
[17:43:48.150]                   name <- changed[[kk]]
[17:43:48.150]                   NAME <- NAMES[[kk]]
[17:43:48.150]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.150]                     next
[17:43:48.150]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.150]                 }
[17:43:48.150]                 NAMES <- toupper(added)
[17:43:48.150]                 for (kk in seq_along(NAMES)) {
[17:43:48.150]                   name <- added[[kk]]
[17:43:48.150]                   NAME <- NAMES[[kk]]
[17:43:48.150]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.150]                     next
[17:43:48.150]                   args[[name]] <- ""
[17:43:48.150]                 }
[17:43:48.150]                 NAMES <- toupper(removed)
[17:43:48.150]                 for (kk in seq_along(NAMES)) {
[17:43:48.150]                   name <- removed[[kk]]
[17:43:48.150]                   NAME <- NAMES[[kk]]
[17:43:48.150]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.150]                     next
[17:43:48.150]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.150]                 }
[17:43:48.150]                 if (length(args) > 0) 
[17:43:48.150]                   base::do.call(base::Sys.setenv, args = args)
[17:43:48.150]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:48.150]             }
[17:43:48.150]             else {
[17:43:48.150]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:48.150]             }
[17:43:48.150]             {
[17:43:48.150]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:48.150]                   0L) {
[17:43:48.150]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:48.150]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:48.150]                   base::options(opts)
[17:43:48.150]                 }
[17:43:48.150]                 {
[17:43:48.150]                   {
[17:43:48.150]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:48.150]                     NULL
[17:43:48.150]                   }
[17:43:48.150]                   options(future.plan = NULL)
[17:43:48.150]                   if (is.na(NA_character_)) 
[17:43:48.150]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.150]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:48.150]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:48.150]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:48.150]                     envir = parent.frame()) 
[17:43:48.150]                   {
[17:43:48.150]                     if (is.function(workers)) 
[17:43:48.150]                       workers <- workers()
[17:43:48.150]                     workers <- structure(as.integer(workers), 
[17:43:48.150]                       class = class(workers))
[17:43:48.150]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:48.150]                       workers >= 1)
[17:43:48.150]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:48.150]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:48.150]                     }
[17:43:48.150]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:48.150]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:48.150]                       envir = envir)
[17:43:48.150]                     if (!future$lazy) 
[17:43:48.150]                       future <- run(future)
[17:43:48.150]                     invisible(future)
[17:43:48.150]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:48.150]                 }
[17:43:48.150]             }
[17:43:48.150]         }
[17:43:48.150]     })
[17:43:48.150]     if (TRUE) {
[17:43:48.150]         base::sink(type = "output", split = FALSE)
[17:43:48.150]         if (TRUE) {
[17:43:48.150]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:48.150]         }
[17:43:48.150]         else {
[17:43:48.150]             ...future.result["stdout"] <- base::list(NULL)
[17:43:48.150]         }
[17:43:48.150]         base::close(...future.stdout)
[17:43:48.150]         ...future.stdout <- NULL
[17:43:48.150]     }
[17:43:48.150]     ...future.result$conditions <- ...future.conditions
[17:43:48.150]     ...future.result$finished <- base::Sys.time()
[17:43:48.150]     ...future.result
[17:43:48.150] }
[17:43:48.154] MultisessionFuture started
[17:43:48.154] - Launch lazy future ... done
[17:43:48.154] run() for ‘MultisessionFuture’ ... done
[17:43:48.200] receiveMessageFromWorker() for ClusterFuture ...
[17:43:48.201] - Validating connection of MultisessionFuture
[17:43:48.201] - received message: FutureResult
[17:43:48.201] - Received FutureResult
[17:43:48.201] - Erased future from FutureRegistry
[17:43:48.202] result() for ClusterFuture ...
[17:43:48.202] - result already collected: FutureResult
[17:43:48.202] result() for ClusterFuture ... done
[17:43:48.202] signalConditions() ...
[17:43:48.202]  - include = ‘immediateCondition’
[17:43:48.202]  - exclude = 
[17:43:48.202]  - resignal = FALSE
[17:43:48.202]  - Number of conditions: 1
[17:43:48.202] signalConditions() ... done
[17:43:48.202] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:48.202] A MultisessionFuture was resolved
[17:43:48.203] getGlobalsAndPackages() ...
[17:43:48.203] Searching for globals...
[17:43:48.203] - globals found: [2] ‘list’, ‘stop’
[17:43:48.204] Searching for globals ... DONE
[17:43:48.204] Resolving globals: FALSE
[17:43:48.204] 
[17:43:48.204] 
[17:43:48.204] getGlobalsAndPackages() ... DONE
[17:43:48.205] run() for ‘Future’ ...
[17:43:48.205] - state: ‘created’
[17:43:48.205] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:48.219] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:48.219] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:48.219]   - Field: ‘node’
[17:43:48.219]   - Field: ‘label’
[17:43:48.219]   - Field: ‘local’
[17:43:48.220]   - Field: ‘owner’
[17:43:48.220]   - Field: ‘envir’
[17:43:48.220]   - Field: ‘workers’
[17:43:48.220]   - Field: ‘packages’
[17:43:48.220]   - Field: ‘gc’
[17:43:48.220]   - Field: ‘conditions’
[17:43:48.220]   - Field: ‘persistent’
[17:43:48.220]   - Field: ‘expr’
[17:43:48.220]   - Field: ‘uuid’
[17:43:48.220]   - Field: ‘seed’
[17:43:48.220]   - Field: ‘version’
[17:43:48.221]   - Field: ‘result’
[17:43:48.221]   - Field: ‘asynchronous’
[17:43:48.221]   - Field: ‘calls’
[17:43:48.221]   - Field: ‘globals’
[17:43:48.221]   - Field: ‘stdout’
[17:43:48.221]   - Field: ‘earlySignal’
[17:43:48.221]   - Field: ‘lazy’
[17:43:48.221]   - Field: ‘state’
[17:43:48.221] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:48.221] - Launch lazy future ...
[17:43:48.222] Packages needed by the future expression (n = 0): <none>
[17:43:48.222] Packages needed by future strategies (n = 0): <none>
[17:43:48.222] {
[17:43:48.222]     {
[17:43:48.222]         {
[17:43:48.222]             ...future.startTime <- base::Sys.time()
[17:43:48.222]             {
[17:43:48.222]                 {
[17:43:48.222]                   {
[17:43:48.222]                     {
[17:43:48.222]                       base::local({
[17:43:48.222]                         has_future <- base::requireNamespace("future", 
[17:43:48.222]                           quietly = TRUE)
[17:43:48.222]                         if (has_future) {
[17:43:48.222]                           ns <- base::getNamespace("future")
[17:43:48.222]                           version <- ns[[".package"]][["version"]]
[17:43:48.222]                           if (is.null(version)) 
[17:43:48.222]                             version <- utils::packageVersion("future")
[17:43:48.222]                         }
[17:43:48.222]                         else {
[17:43:48.222]                           version <- NULL
[17:43:48.222]                         }
[17:43:48.222]                         if (!has_future || version < "1.8.0") {
[17:43:48.222]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:48.222]                             "", base::R.version$version.string), 
[17:43:48.222]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:48.222]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:48.222]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:48.222]                               "release", "version")], collapse = " "), 
[17:43:48.222]                             hostname = base::Sys.info()[["nodename"]])
[17:43:48.222]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:48.222]                             info)
[17:43:48.222]                           info <- base::paste(info, collapse = "; ")
[17:43:48.222]                           if (!has_future) {
[17:43:48.222]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:48.222]                               info)
[17:43:48.222]                           }
[17:43:48.222]                           else {
[17:43:48.222]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:48.222]                               info, version)
[17:43:48.222]                           }
[17:43:48.222]                           base::stop(msg)
[17:43:48.222]                         }
[17:43:48.222]                       })
[17:43:48.222]                     }
[17:43:48.222]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:48.222]                     base::options(mc.cores = 1L)
[17:43:48.222]                   }
[17:43:48.222]                   options(future.plan = NULL)
[17:43:48.222]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.222]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:48.222]                 }
[17:43:48.222]                 ...future.workdir <- getwd()
[17:43:48.222]             }
[17:43:48.222]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:48.222]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:48.222]         }
[17:43:48.222]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:48.222]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:48.222]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:48.222]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:48.222]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:48.222]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:48.222]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:48.222]             base::names(...future.oldOptions))
[17:43:48.222]     }
[17:43:48.222]     if (FALSE) {
[17:43:48.222]     }
[17:43:48.222]     else {
[17:43:48.222]         if (TRUE) {
[17:43:48.222]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:48.222]                 open = "w")
[17:43:48.222]         }
[17:43:48.222]         else {
[17:43:48.222]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:48.222]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:48.222]         }
[17:43:48.222]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:48.222]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:48.222]             base::sink(type = "output", split = FALSE)
[17:43:48.222]             base::close(...future.stdout)
[17:43:48.222]         }, add = TRUE)
[17:43:48.222]     }
[17:43:48.222]     ...future.frame <- base::sys.nframe()
[17:43:48.222]     ...future.conditions <- base::list()
[17:43:48.222]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:48.222]     if (FALSE) {
[17:43:48.222]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:48.222]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:48.222]     }
[17:43:48.222]     ...future.result <- base::tryCatch({
[17:43:48.222]         base::withCallingHandlers({
[17:43:48.222]             ...future.value <- base::withVisible(base::local({
[17:43:48.222]                 ...future.makeSendCondition <- local({
[17:43:48.222]                   sendCondition <- NULL
[17:43:48.222]                   function(frame = 1L) {
[17:43:48.222]                     if (is.function(sendCondition)) 
[17:43:48.222]                       return(sendCondition)
[17:43:48.222]                     ns <- getNamespace("parallel")
[17:43:48.222]                     if (exists("sendData", mode = "function", 
[17:43:48.222]                       envir = ns)) {
[17:43:48.222]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:48.222]                         envir = ns)
[17:43:48.222]                       envir <- sys.frame(frame)
[17:43:48.222]                       master <- NULL
[17:43:48.222]                       while (!identical(envir, .GlobalEnv) && 
[17:43:48.222]                         !identical(envir, emptyenv())) {
[17:43:48.222]                         if (exists("master", mode = "list", envir = envir, 
[17:43:48.222]                           inherits = FALSE)) {
[17:43:48.222]                           master <- get("master", mode = "list", 
[17:43:48.222]                             envir = envir, inherits = FALSE)
[17:43:48.222]                           if (inherits(master, c("SOCKnode", 
[17:43:48.222]                             "SOCK0node"))) {
[17:43:48.222]                             sendCondition <<- function(cond) {
[17:43:48.222]                               data <- list(type = "VALUE", value = cond, 
[17:43:48.222]                                 success = TRUE)
[17:43:48.222]                               parallel_sendData(master, data)
[17:43:48.222]                             }
[17:43:48.222]                             return(sendCondition)
[17:43:48.222]                           }
[17:43:48.222]                         }
[17:43:48.222]                         frame <- frame + 1L
[17:43:48.222]                         envir <- sys.frame(frame)
[17:43:48.222]                       }
[17:43:48.222]                     }
[17:43:48.222]                     sendCondition <<- function(cond) NULL
[17:43:48.222]                   }
[17:43:48.222]                 })
[17:43:48.222]                 withCallingHandlers({
[17:43:48.222]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:43:48.222]                 }, immediateCondition = function(cond) {
[17:43:48.222]                   sendCondition <- ...future.makeSendCondition()
[17:43:48.222]                   sendCondition(cond)
[17:43:48.222]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.222]                   {
[17:43:48.222]                     inherits <- base::inherits
[17:43:48.222]                     invokeRestart <- base::invokeRestart
[17:43:48.222]                     is.null <- base::is.null
[17:43:48.222]                     muffled <- FALSE
[17:43:48.222]                     if (inherits(cond, "message")) {
[17:43:48.222]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:48.222]                       if (muffled) 
[17:43:48.222]                         invokeRestart("muffleMessage")
[17:43:48.222]                     }
[17:43:48.222]                     else if (inherits(cond, "warning")) {
[17:43:48.222]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:48.222]                       if (muffled) 
[17:43:48.222]                         invokeRestart("muffleWarning")
[17:43:48.222]                     }
[17:43:48.222]                     else if (inherits(cond, "condition")) {
[17:43:48.222]                       if (!is.null(pattern)) {
[17:43:48.222]                         computeRestarts <- base::computeRestarts
[17:43:48.222]                         grepl <- base::grepl
[17:43:48.222]                         restarts <- computeRestarts(cond)
[17:43:48.222]                         for (restart in restarts) {
[17:43:48.222]                           name <- restart$name
[17:43:48.222]                           if (is.null(name)) 
[17:43:48.222]                             next
[17:43:48.222]                           if (!grepl(pattern, name)) 
[17:43:48.222]                             next
[17:43:48.222]                           invokeRestart(restart)
[17:43:48.222]                           muffled <- TRUE
[17:43:48.222]                           break
[17:43:48.222]                         }
[17:43:48.222]                       }
[17:43:48.222]                     }
[17:43:48.222]                     invisible(muffled)
[17:43:48.222]                   }
[17:43:48.222]                   muffleCondition(cond)
[17:43:48.222]                 })
[17:43:48.222]             }))
[17:43:48.222]             future::FutureResult(value = ...future.value$value, 
[17:43:48.222]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.222]                   ...future.rng), globalenv = if (FALSE) 
[17:43:48.222]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:48.222]                     ...future.globalenv.names))
[17:43:48.222]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:48.222]         }, condition = base::local({
[17:43:48.222]             c <- base::c
[17:43:48.222]             inherits <- base::inherits
[17:43:48.222]             invokeRestart <- base::invokeRestart
[17:43:48.222]             length <- base::length
[17:43:48.222]             list <- base::list
[17:43:48.222]             seq.int <- base::seq.int
[17:43:48.222]             signalCondition <- base::signalCondition
[17:43:48.222]             sys.calls <- base::sys.calls
[17:43:48.222]             `[[` <- base::`[[`
[17:43:48.222]             `+` <- base::`+`
[17:43:48.222]             `<<-` <- base::`<<-`
[17:43:48.222]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:48.222]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:48.222]                   3L)]
[17:43:48.222]             }
[17:43:48.222]             function(cond) {
[17:43:48.222]                 is_error <- inherits(cond, "error")
[17:43:48.222]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:48.222]                   NULL)
[17:43:48.222]                 if (is_error) {
[17:43:48.222]                   sessionInformation <- function() {
[17:43:48.222]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:48.222]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:48.222]                       search = base::search(), system = base::Sys.info())
[17:43:48.222]                   }
[17:43:48.222]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.222]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:48.222]                     cond$call), session = sessionInformation(), 
[17:43:48.222]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:48.222]                   signalCondition(cond)
[17:43:48.222]                 }
[17:43:48.222]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:48.222]                 "immediateCondition"))) {
[17:43:48.222]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:48.222]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.222]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:48.222]                   if (TRUE && !signal) {
[17:43:48.222]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.222]                     {
[17:43:48.222]                       inherits <- base::inherits
[17:43:48.222]                       invokeRestart <- base::invokeRestart
[17:43:48.222]                       is.null <- base::is.null
[17:43:48.222]                       muffled <- FALSE
[17:43:48.222]                       if (inherits(cond, "message")) {
[17:43:48.222]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.222]                         if (muffled) 
[17:43:48.222]                           invokeRestart("muffleMessage")
[17:43:48.222]                       }
[17:43:48.222]                       else if (inherits(cond, "warning")) {
[17:43:48.222]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.222]                         if (muffled) 
[17:43:48.222]                           invokeRestart("muffleWarning")
[17:43:48.222]                       }
[17:43:48.222]                       else if (inherits(cond, "condition")) {
[17:43:48.222]                         if (!is.null(pattern)) {
[17:43:48.222]                           computeRestarts <- base::computeRestarts
[17:43:48.222]                           grepl <- base::grepl
[17:43:48.222]                           restarts <- computeRestarts(cond)
[17:43:48.222]                           for (restart in restarts) {
[17:43:48.222]                             name <- restart$name
[17:43:48.222]                             if (is.null(name)) 
[17:43:48.222]                               next
[17:43:48.222]                             if (!grepl(pattern, name)) 
[17:43:48.222]                               next
[17:43:48.222]                             invokeRestart(restart)
[17:43:48.222]                             muffled <- TRUE
[17:43:48.222]                             break
[17:43:48.222]                           }
[17:43:48.222]                         }
[17:43:48.222]                       }
[17:43:48.222]                       invisible(muffled)
[17:43:48.222]                     }
[17:43:48.222]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.222]                   }
[17:43:48.222]                 }
[17:43:48.222]                 else {
[17:43:48.222]                   if (TRUE) {
[17:43:48.222]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.222]                     {
[17:43:48.222]                       inherits <- base::inherits
[17:43:48.222]                       invokeRestart <- base::invokeRestart
[17:43:48.222]                       is.null <- base::is.null
[17:43:48.222]                       muffled <- FALSE
[17:43:48.222]                       if (inherits(cond, "message")) {
[17:43:48.222]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.222]                         if (muffled) 
[17:43:48.222]                           invokeRestart("muffleMessage")
[17:43:48.222]                       }
[17:43:48.222]                       else if (inherits(cond, "warning")) {
[17:43:48.222]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.222]                         if (muffled) 
[17:43:48.222]                           invokeRestart("muffleWarning")
[17:43:48.222]                       }
[17:43:48.222]                       else if (inherits(cond, "condition")) {
[17:43:48.222]                         if (!is.null(pattern)) {
[17:43:48.222]                           computeRestarts <- base::computeRestarts
[17:43:48.222]                           grepl <- base::grepl
[17:43:48.222]                           restarts <- computeRestarts(cond)
[17:43:48.222]                           for (restart in restarts) {
[17:43:48.222]                             name <- restart$name
[17:43:48.222]                             if (is.null(name)) 
[17:43:48.222]                               next
[17:43:48.222]                             if (!grepl(pattern, name)) 
[17:43:48.222]                               next
[17:43:48.222]                             invokeRestart(restart)
[17:43:48.222]                             muffled <- TRUE
[17:43:48.222]                             break
[17:43:48.222]                           }
[17:43:48.222]                         }
[17:43:48.222]                       }
[17:43:48.222]                       invisible(muffled)
[17:43:48.222]                     }
[17:43:48.222]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.222]                   }
[17:43:48.222]                 }
[17:43:48.222]             }
[17:43:48.222]         }))
[17:43:48.222]     }, error = function(ex) {
[17:43:48.222]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:48.222]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.222]                 ...future.rng), started = ...future.startTime, 
[17:43:48.222]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:48.222]             version = "1.8"), class = "FutureResult")
[17:43:48.222]     }, finally = {
[17:43:48.222]         if (!identical(...future.workdir, getwd())) 
[17:43:48.222]             setwd(...future.workdir)
[17:43:48.222]         {
[17:43:48.222]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:48.222]                 ...future.oldOptions$nwarnings <- NULL
[17:43:48.222]             }
[17:43:48.222]             base::options(...future.oldOptions)
[17:43:48.222]             if (.Platform$OS.type == "windows") {
[17:43:48.222]                 old_names <- names(...future.oldEnvVars)
[17:43:48.222]                 envs <- base::Sys.getenv()
[17:43:48.222]                 names <- names(envs)
[17:43:48.222]                 common <- intersect(names, old_names)
[17:43:48.222]                 added <- setdiff(names, old_names)
[17:43:48.222]                 removed <- setdiff(old_names, names)
[17:43:48.222]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:48.222]                   envs[common]]
[17:43:48.222]                 NAMES <- toupper(changed)
[17:43:48.222]                 args <- list()
[17:43:48.222]                 for (kk in seq_along(NAMES)) {
[17:43:48.222]                   name <- changed[[kk]]
[17:43:48.222]                   NAME <- NAMES[[kk]]
[17:43:48.222]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.222]                     next
[17:43:48.222]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.222]                 }
[17:43:48.222]                 NAMES <- toupper(added)
[17:43:48.222]                 for (kk in seq_along(NAMES)) {
[17:43:48.222]                   name <- added[[kk]]
[17:43:48.222]                   NAME <- NAMES[[kk]]
[17:43:48.222]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.222]                     next
[17:43:48.222]                   args[[name]] <- ""
[17:43:48.222]                 }
[17:43:48.222]                 NAMES <- toupper(removed)
[17:43:48.222]                 for (kk in seq_along(NAMES)) {
[17:43:48.222]                   name <- removed[[kk]]
[17:43:48.222]                   NAME <- NAMES[[kk]]
[17:43:48.222]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.222]                     next
[17:43:48.222]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.222]                 }
[17:43:48.222]                 if (length(args) > 0) 
[17:43:48.222]                   base::do.call(base::Sys.setenv, args = args)
[17:43:48.222]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:48.222]             }
[17:43:48.222]             else {
[17:43:48.222]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:48.222]             }
[17:43:48.222]             {
[17:43:48.222]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:48.222]                   0L) {
[17:43:48.222]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:48.222]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:48.222]                   base::options(opts)
[17:43:48.222]                 }
[17:43:48.222]                 {
[17:43:48.222]                   {
[17:43:48.222]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:48.222]                     NULL
[17:43:48.222]                   }
[17:43:48.222]                   options(future.plan = NULL)
[17:43:48.222]                   if (is.na(NA_character_)) 
[17:43:48.222]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.222]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:48.222]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:48.222]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:48.222]                     envir = parent.frame()) 
[17:43:48.222]                   {
[17:43:48.222]                     if (is.function(workers)) 
[17:43:48.222]                       workers <- workers()
[17:43:48.222]                     workers <- structure(as.integer(workers), 
[17:43:48.222]                       class = class(workers))
[17:43:48.222]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:48.222]                       workers >= 1)
[17:43:48.222]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:48.222]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:48.222]                     }
[17:43:48.222]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:48.222]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:48.222]                       envir = envir)
[17:43:48.222]                     if (!future$lazy) 
[17:43:48.222]                       future <- run(future)
[17:43:48.222]                     invisible(future)
[17:43:48.222]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:48.222]                 }
[17:43:48.222]             }
[17:43:48.222]         }
[17:43:48.222]     })
[17:43:48.222]     if (TRUE) {
[17:43:48.222]         base::sink(type = "output", split = FALSE)
[17:43:48.222]         if (TRUE) {
[17:43:48.222]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:48.222]         }
[17:43:48.222]         else {
[17:43:48.222]             ...future.result["stdout"] <- base::list(NULL)
[17:43:48.222]         }
[17:43:48.222]         base::close(...future.stdout)
[17:43:48.222]         ...future.stdout <- NULL
[17:43:48.222]     }
[17:43:48.222]     ...future.result$conditions <- ...future.conditions
[17:43:48.222]     ...future.result$finished <- base::Sys.time()
[17:43:48.222]     ...future.result
[17:43:48.222] }
[17:43:48.225] MultisessionFuture started
[17:43:48.225] - Launch lazy future ... done
[17:43:48.226] run() for ‘MultisessionFuture’ ... done
[17:43:48.271] receiveMessageFromWorker() for ClusterFuture ...
[17:43:48.272] - Validating connection of MultisessionFuture
[17:43:48.272] - received message: FutureResult
[17:43:48.272] - Received FutureResult
[17:43:48.272] - Erased future from FutureRegistry
[17:43:48.273] result() for ClusterFuture ...
[17:43:48.273] - result already collected: FutureResult
[17:43:48.273] result() for ClusterFuture ... done
[17:43:48.273] signalConditions() ...
[17:43:48.273]  - include = ‘immediateCondition’
[17:43:48.273]  - exclude = 
[17:43:48.273]  - resignal = FALSE
[17:43:48.273]  - Number of conditions: 1
[17:43:48.273] signalConditions() ... done
[17:43:48.273] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:48.273] A MultisessionFuture was resolved
- result = TRUE, recursive = TRUE ... DONE
- result = TRUE, recursive = -1 ...
[17:43:48.274] getGlobalsAndPackages() ...
[17:43:48.274] Searching for globals...
[17:43:48.275] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:43:48.275] Searching for globals ... DONE
[17:43:48.275] Resolving globals: FALSE
[17:43:48.275] 
[17:43:48.276] 
[17:43:48.276] getGlobalsAndPackages() ... DONE
[17:43:48.276] run() for ‘Future’ ...
[17:43:48.276] - state: ‘created’
[17:43:48.276] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:48.293] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:48.293] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:48.293]   - Field: ‘node’
[17:43:48.293]   - Field: ‘label’
[17:43:48.293]   - Field: ‘local’
[17:43:48.293]   - Field: ‘owner’
[17:43:48.293]   - Field: ‘envir’
[17:43:48.293]   - Field: ‘workers’
[17:43:48.294]   - Field: ‘packages’
[17:43:48.294]   - Field: ‘gc’
[17:43:48.294]   - Field: ‘conditions’
[17:43:48.294]   - Field: ‘persistent’
[17:43:48.294]   - Field: ‘expr’
[17:43:48.294]   - Field: ‘uuid’
[17:43:48.294]   - Field: ‘seed’
[17:43:48.294]   - Field: ‘version’
[17:43:48.294]   - Field: ‘result’
[17:43:48.294]   - Field: ‘asynchronous’
[17:43:48.294]   - Field: ‘calls’
[17:43:48.295]   - Field: ‘globals’
[17:43:48.295]   - Field: ‘stdout’
[17:43:48.295]   - Field: ‘earlySignal’
[17:43:48.295]   - Field: ‘lazy’
[17:43:48.295]   - Field: ‘state’
[17:43:48.295] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:48.295] - Launch lazy future ...
[17:43:48.295] Packages needed by the future expression (n = 0): <none>
[17:43:48.296] Packages needed by future strategies (n = 0): <none>
[17:43:48.296] {
[17:43:48.296]     {
[17:43:48.296]         {
[17:43:48.296]             ...future.startTime <- base::Sys.time()
[17:43:48.296]             {
[17:43:48.296]                 {
[17:43:48.296]                   {
[17:43:48.296]                     {
[17:43:48.296]                       base::local({
[17:43:48.296]                         has_future <- base::requireNamespace("future", 
[17:43:48.296]                           quietly = TRUE)
[17:43:48.296]                         if (has_future) {
[17:43:48.296]                           ns <- base::getNamespace("future")
[17:43:48.296]                           version <- ns[[".package"]][["version"]]
[17:43:48.296]                           if (is.null(version)) 
[17:43:48.296]                             version <- utils::packageVersion("future")
[17:43:48.296]                         }
[17:43:48.296]                         else {
[17:43:48.296]                           version <- NULL
[17:43:48.296]                         }
[17:43:48.296]                         if (!has_future || version < "1.8.0") {
[17:43:48.296]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:48.296]                             "", base::R.version$version.string), 
[17:43:48.296]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:48.296]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:48.296]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:48.296]                               "release", "version")], collapse = " "), 
[17:43:48.296]                             hostname = base::Sys.info()[["nodename"]])
[17:43:48.296]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:48.296]                             info)
[17:43:48.296]                           info <- base::paste(info, collapse = "; ")
[17:43:48.296]                           if (!has_future) {
[17:43:48.296]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:48.296]                               info)
[17:43:48.296]                           }
[17:43:48.296]                           else {
[17:43:48.296]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:48.296]                               info, version)
[17:43:48.296]                           }
[17:43:48.296]                           base::stop(msg)
[17:43:48.296]                         }
[17:43:48.296]                       })
[17:43:48.296]                     }
[17:43:48.296]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:48.296]                     base::options(mc.cores = 1L)
[17:43:48.296]                   }
[17:43:48.296]                   options(future.plan = NULL)
[17:43:48.296]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.296]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:48.296]                 }
[17:43:48.296]                 ...future.workdir <- getwd()
[17:43:48.296]             }
[17:43:48.296]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:48.296]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:48.296]         }
[17:43:48.296]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:48.296]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:48.296]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:48.296]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:48.296]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:48.296]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:48.296]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:48.296]             base::names(...future.oldOptions))
[17:43:48.296]     }
[17:43:48.296]     if (FALSE) {
[17:43:48.296]     }
[17:43:48.296]     else {
[17:43:48.296]         if (TRUE) {
[17:43:48.296]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:48.296]                 open = "w")
[17:43:48.296]         }
[17:43:48.296]         else {
[17:43:48.296]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:48.296]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:48.296]         }
[17:43:48.296]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:48.296]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:48.296]             base::sink(type = "output", split = FALSE)
[17:43:48.296]             base::close(...future.stdout)
[17:43:48.296]         }, add = TRUE)
[17:43:48.296]     }
[17:43:48.296]     ...future.frame <- base::sys.nframe()
[17:43:48.296]     ...future.conditions <- base::list()
[17:43:48.296]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:48.296]     if (FALSE) {
[17:43:48.296]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:48.296]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:48.296]     }
[17:43:48.296]     ...future.result <- base::tryCatch({
[17:43:48.296]         base::withCallingHandlers({
[17:43:48.296]             ...future.value <- base::withVisible(base::local({
[17:43:48.296]                 ...future.makeSendCondition <- local({
[17:43:48.296]                   sendCondition <- NULL
[17:43:48.296]                   function(frame = 1L) {
[17:43:48.296]                     if (is.function(sendCondition)) 
[17:43:48.296]                       return(sendCondition)
[17:43:48.296]                     ns <- getNamespace("parallel")
[17:43:48.296]                     if (exists("sendData", mode = "function", 
[17:43:48.296]                       envir = ns)) {
[17:43:48.296]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:48.296]                         envir = ns)
[17:43:48.296]                       envir <- sys.frame(frame)
[17:43:48.296]                       master <- NULL
[17:43:48.296]                       while (!identical(envir, .GlobalEnv) && 
[17:43:48.296]                         !identical(envir, emptyenv())) {
[17:43:48.296]                         if (exists("master", mode = "list", envir = envir, 
[17:43:48.296]                           inherits = FALSE)) {
[17:43:48.296]                           master <- get("master", mode = "list", 
[17:43:48.296]                             envir = envir, inherits = FALSE)
[17:43:48.296]                           if (inherits(master, c("SOCKnode", 
[17:43:48.296]                             "SOCK0node"))) {
[17:43:48.296]                             sendCondition <<- function(cond) {
[17:43:48.296]                               data <- list(type = "VALUE", value = cond, 
[17:43:48.296]                                 success = TRUE)
[17:43:48.296]                               parallel_sendData(master, data)
[17:43:48.296]                             }
[17:43:48.296]                             return(sendCondition)
[17:43:48.296]                           }
[17:43:48.296]                         }
[17:43:48.296]                         frame <- frame + 1L
[17:43:48.296]                         envir <- sys.frame(frame)
[17:43:48.296]                       }
[17:43:48.296]                     }
[17:43:48.296]                     sendCondition <<- function(cond) NULL
[17:43:48.296]                   }
[17:43:48.296]                 })
[17:43:48.296]                 withCallingHandlers({
[17:43:48.296]                   {
[17:43:48.296]                     Sys.sleep(0.5)
[17:43:48.296]                     list(a = 1, b = 42L)
[17:43:48.296]                   }
[17:43:48.296]                 }, immediateCondition = function(cond) {
[17:43:48.296]                   sendCondition <- ...future.makeSendCondition()
[17:43:48.296]                   sendCondition(cond)
[17:43:48.296]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.296]                   {
[17:43:48.296]                     inherits <- base::inherits
[17:43:48.296]                     invokeRestart <- base::invokeRestart
[17:43:48.296]                     is.null <- base::is.null
[17:43:48.296]                     muffled <- FALSE
[17:43:48.296]                     if (inherits(cond, "message")) {
[17:43:48.296]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:48.296]                       if (muffled) 
[17:43:48.296]                         invokeRestart("muffleMessage")
[17:43:48.296]                     }
[17:43:48.296]                     else if (inherits(cond, "warning")) {
[17:43:48.296]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:48.296]                       if (muffled) 
[17:43:48.296]                         invokeRestart("muffleWarning")
[17:43:48.296]                     }
[17:43:48.296]                     else if (inherits(cond, "condition")) {
[17:43:48.296]                       if (!is.null(pattern)) {
[17:43:48.296]                         computeRestarts <- base::computeRestarts
[17:43:48.296]                         grepl <- base::grepl
[17:43:48.296]                         restarts <- computeRestarts(cond)
[17:43:48.296]                         for (restart in restarts) {
[17:43:48.296]                           name <- restart$name
[17:43:48.296]                           if (is.null(name)) 
[17:43:48.296]                             next
[17:43:48.296]                           if (!grepl(pattern, name)) 
[17:43:48.296]                             next
[17:43:48.296]                           invokeRestart(restart)
[17:43:48.296]                           muffled <- TRUE
[17:43:48.296]                           break
[17:43:48.296]                         }
[17:43:48.296]                       }
[17:43:48.296]                     }
[17:43:48.296]                     invisible(muffled)
[17:43:48.296]                   }
[17:43:48.296]                   muffleCondition(cond)
[17:43:48.296]                 })
[17:43:48.296]             }))
[17:43:48.296]             future::FutureResult(value = ...future.value$value, 
[17:43:48.296]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.296]                   ...future.rng), globalenv = if (FALSE) 
[17:43:48.296]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:48.296]                     ...future.globalenv.names))
[17:43:48.296]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:48.296]         }, condition = base::local({
[17:43:48.296]             c <- base::c
[17:43:48.296]             inherits <- base::inherits
[17:43:48.296]             invokeRestart <- base::invokeRestart
[17:43:48.296]             length <- base::length
[17:43:48.296]             list <- base::list
[17:43:48.296]             seq.int <- base::seq.int
[17:43:48.296]             signalCondition <- base::signalCondition
[17:43:48.296]             sys.calls <- base::sys.calls
[17:43:48.296]             `[[` <- base::`[[`
[17:43:48.296]             `+` <- base::`+`
[17:43:48.296]             `<<-` <- base::`<<-`
[17:43:48.296]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:48.296]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:48.296]                   3L)]
[17:43:48.296]             }
[17:43:48.296]             function(cond) {
[17:43:48.296]                 is_error <- inherits(cond, "error")
[17:43:48.296]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:48.296]                   NULL)
[17:43:48.296]                 if (is_error) {
[17:43:48.296]                   sessionInformation <- function() {
[17:43:48.296]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:48.296]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:48.296]                       search = base::search(), system = base::Sys.info())
[17:43:48.296]                   }
[17:43:48.296]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.296]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:48.296]                     cond$call), session = sessionInformation(), 
[17:43:48.296]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:48.296]                   signalCondition(cond)
[17:43:48.296]                 }
[17:43:48.296]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:48.296]                 "immediateCondition"))) {
[17:43:48.296]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:48.296]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.296]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:48.296]                   if (TRUE && !signal) {
[17:43:48.296]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.296]                     {
[17:43:48.296]                       inherits <- base::inherits
[17:43:48.296]                       invokeRestart <- base::invokeRestart
[17:43:48.296]                       is.null <- base::is.null
[17:43:48.296]                       muffled <- FALSE
[17:43:48.296]                       if (inherits(cond, "message")) {
[17:43:48.296]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.296]                         if (muffled) 
[17:43:48.296]                           invokeRestart("muffleMessage")
[17:43:48.296]                       }
[17:43:48.296]                       else if (inherits(cond, "warning")) {
[17:43:48.296]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.296]                         if (muffled) 
[17:43:48.296]                           invokeRestart("muffleWarning")
[17:43:48.296]                       }
[17:43:48.296]                       else if (inherits(cond, "condition")) {
[17:43:48.296]                         if (!is.null(pattern)) {
[17:43:48.296]                           computeRestarts <- base::computeRestarts
[17:43:48.296]                           grepl <- base::grepl
[17:43:48.296]                           restarts <- computeRestarts(cond)
[17:43:48.296]                           for (restart in restarts) {
[17:43:48.296]                             name <- restart$name
[17:43:48.296]                             if (is.null(name)) 
[17:43:48.296]                               next
[17:43:48.296]                             if (!grepl(pattern, name)) 
[17:43:48.296]                               next
[17:43:48.296]                             invokeRestart(restart)
[17:43:48.296]                             muffled <- TRUE
[17:43:48.296]                             break
[17:43:48.296]                           }
[17:43:48.296]                         }
[17:43:48.296]                       }
[17:43:48.296]                       invisible(muffled)
[17:43:48.296]                     }
[17:43:48.296]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.296]                   }
[17:43:48.296]                 }
[17:43:48.296]                 else {
[17:43:48.296]                   if (TRUE) {
[17:43:48.296]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.296]                     {
[17:43:48.296]                       inherits <- base::inherits
[17:43:48.296]                       invokeRestart <- base::invokeRestart
[17:43:48.296]                       is.null <- base::is.null
[17:43:48.296]                       muffled <- FALSE
[17:43:48.296]                       if (inherits(cond, "message")) {
[17:43:48.296]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.296]                         if (muffled) 
[17:43:48.296]                           invokeRestart("muffleMessage")
[17:43:48.296]                       }
[17:43:48.296]                       else if (inherits(cond, "warning")) {
[17:43:48.296]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.296]                         if (muffled) 
[17:43:48.296]                           invokeRestart("muffleWarning")
[17:43:48.296]                       }
[17:43:48.296]                       else if (inherits(cond, "condition")) {
[17:43:48.296]                         if (!is.null(pattern)) {
[17:43:48.296]                           computeRestarts <- base::computeRestarts
[17:43:48.296]                           grepl <- base::grepl
[17:43:48.296]                           restarts <- computeRestarts(cond)
[17:43:48.296]                           for (restart in restarts) {
[17:43:48.296]                             name <- restart$name
[17:43:48.296]                             if (is.null(name)) 
[17:43:48.296]                               next
[17:43:48.296]                             if (!grepl(pattern, name)) 
[17:43:48.296]                               next
[17:43:48.296]                             invokeRestart(restart)
[17:43:48.296]                             muffled <- TRUE
[17:43:48.296]                             break
[17:43:48.296]                           }
[17:43:48.296]                         }
[17:43:48.296]                       }
[17:43:48.296]                       invisible(muffled)
[17:43:48.296]                     }
[17:43:48.296]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.296]                   }
[17:43:48.296]                 }
[17:43:48.296]             }
[17:43:48.296]         }))
[17:43:48.296]     }, error = function(ex) {
[17:43:48.296]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:48.296]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.296]                 ...future.rng), started = ...future.startTime, 
[17:43:48.296]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:48.296]             version = "1.8"), class = "FutureResult")
[17:43:48.296]     }, finally = {
[17:43:48.296]         if (!identical(...future.workdir, getwd())) 
[17:43:48.296]             setwd(...future.workdir)
[17:43:48.296]         {
[17:43:48.296]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:48.296]                 ...future.oldOptions$nwarnings <- NULL
[17:43:48.296]             }
[17:43:48.296]             base::options(...future.oldOptions)
[17:43:48.296]             if (.Platform$OS.type == "windows") {
[17:43:48.296]                 old_names <- names(...future.oldEnvVars)
[17:43:48.296]                 envs <- base::Sys.getenv()
[17:43:48.296]                 names <- names(envs)
[17:43:48.296]                 common <- intersect(names, old_names)
[17:43:48.296]                 added <- setdiff(names, old_names)
[17:43:48.296]                 removed <- setdiff(old_names, names)
[17:43:48.296]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:48.296]                   envs[common]]
[17:43:48.296]                 NAMES <- toupper(changed)
[17:43:48.296]                 args <- list()
[17:43:48.296]                 for (kk in seq_along(NAMES)) {
[17:43:48.296]                   name <- changed[[kk]]
[17:43:48.296]                   NAME <- NAMES[[kk]]
[17:43:48.296]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.296]                     next
[17:43:48.296]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.296]                 }
[17:43:48.296]                 NAMES <- toupper(added)
[17:43:48.296]                 for (kk in seq_along(NAMES)) {
[17:43:48.296]                   name <- added[[kk]]
[17:43:48.296]                   NAME <- NAMES[[kk]]
[17:43:48.296]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.296]                     next
[17:43:48.296]                   args[[name]] <- ""
[17:43:48.296]                 }
[17:43:48.296]                 NAMES <- toupper(removed)
[17:43:48.296]                 for (kk in seq_along(NAMES)) {
[17:43:48.296]                   name <- removed[[kk]]
[17:43:48.296]                   NAME <- NAMES[[kk]]
[17:43:48.296]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.296]                     next
[17:43:48.296]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.296]                 }
[17:43:48.296]                 if (length(args) > 0) 
[17:43:48.296]                   base::do.call(base::Sys.setenv, args = args)
[17:43:48.296]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:48.296]             }
[17:43:48.296]             else {
[17:43:48.296]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:48.296]             }
[17:43:48.296]             {
[17:43:48.296]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:48.296]                   0L) {
[17:43:48.296]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:48.296]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:48.296]                   base::options(opts)
[17:43:48.296]                 }
[17:43:48.296]                 {
[17:43:48.296]                   {
[17:43:48.296]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:48.296]                     NULL
[17:43:48.296]                   }
[17:43:48.296]                   options(future.plan = NULL)
[17:43:48.296]                   if (is.na(NA_character_)) 
[17:43:48.296]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.296]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:48.296]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:48.296]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:48.296]                     envir = parent.frame()) 
[17:43:48.296]                   {
[17:43:48.296]                     if (is.function(workers)) 
[17:43:48.296]                       workers <- workers()
[17:43:48.296]                     workers <- structure(as.integer(workers), 
[17:43:48.296]                       class = class(workers))
[17:43:48.296]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:48.296]                       workers >= 1)
[17:43:48.296]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:48.296]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:48.296]                     }
[17:43:48.296]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:48.296]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:48.296]                       envir = envir)
[17:43:48.296]                     if (!future$lazy) 
[17:43:48.296]                       future <- run(future)
[17:43:48.296]                     invisible(future)
[17:43:48.296]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:48.296]                 }
[17:43:48.296]             }
[17:43:48.296]         }
[17:43:48.296]     })
[17:43:48.296]     if (TRUE) {
[17:43:48.296]         base::sink(type = "output", split = FALSE)
[17:43:48.296]         if (TRUE) {
[17:43:48.296]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:48.296]         }
[17:43:48.296]         else {
[17:43:48.296]             ...future.result["stdout"] <- base::list(NULL)
[17:43:48.296]         }
[17:43:48.296]         base::close(...future.stdout)
[17:43:48.296]         ...future.stdout <- NULL
[17:43:48.296]     }
[17:43:48.296]     ...future.result$conditions <- ...future.conditions
[17:43:48.296]     ...future.result$finished <- base::Sys.time()
[17:43:48.296]     ...future.result
[17:43:48.296] }
[17:43:48.299] MultisessionFuture started
[17:43:48.299] - Launch lazy future ... done
[17:43:48.300] run() for ‘MultisessionFuture’ ... done
[17:43:48.300] getGlobalsAndPackages() ...
[17:43:48.300] Searching for globals...
[17:43:48.301] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:43:48.301] Searching for globals ... DONE
[17:43:48.301] Resolving globals: FALSE
[17:43:48.302] 
[17:43:48.302] 
[17:43:48.302] getGlobalsAndPackages() ... DONE
- w/ exception ...
[17:43:48.302] getGlobalsAndPackages() ...
[17:43:48.302] Searching for globals...
[17:43:48.303] - globals found: [2] ‘list’, ‘stop’
[17:43:48.303] Searching for globals ... DONE
[17:43:48.303] Resolving globals: FALSE
[17:43:48.303] 
[17:43:48.303] 
[17:43:48.304] getGlobalsAndPackages() ... DONE
[17:43:48.304] run() for ‘Future’ ...
[17:43:48.304] - state: ‘created’
[17:43:48.304] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:48.318] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:48.319] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:48.319]   - Field: ‘node’
[17:43:48.319]   - Field: ‘label’
[17:43:48.319]   - Field: ‘local’
[17:43:48.319]   - Field: ‘owner’
[17:43:48.319]   - Field: ‘envir’
[17:43:48.319]   - Field: ‘workers’
[17:43:48.319]   - Field: ‘packages’
[17:43:48.319]   - Field: ‘gc’
[17:43:48.320]   - Field: ‘conditions’
[17:43:48.320]   - Field: ‘persistent’
[17:43:48.320]   - Field: ‘expr’
[17:43:48.320]   - Field: ‘uuid’
[17:43:48.320]   - Field: ‘seed’
[17:43:48.320]   - Field: ‘version’
[17:43:48.320]   - Field: ‘result’
[17:43:48.320]   - Field: ‘asynchronous’
[17:43:48.320]   - Field: ‘calls’
[17:43:48.320]   - Field: ‘globals’
[17:43:48.320]   - Field: ‘stdout’
[17:43:48.321]   - Field: ‘earlySignal’
[17:43:48.321]   - Field: ‘lazy’
[17:43:48.321]   - Field: ‘state’
[17:43:48.321] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:48.321] - Launch lazy future ...
[17:43:48.321] Packages needed by the future expression (n = 0): <none>
[17:43:48.321] Packages needed by future strategies (n = 0): <none>
[17:43:48.322] {
[17:43:48.322]     {
[17:43:48.322]         {
[17:43:48.322]             ...future.startTime <- base::Sys.time()
[17:43:48.322]             {
[17:43:48.322]                 {
[17:43:48.322]                   {
[17:43:48.322]                     {
[17:43:48.322]                       base::local({
[17:43:48.322]                         has_future <- base::requireNamespace("future", 
[17:43:48.322]                           quietly = TRUE)
[17:43:48.322]                         if (has_future) {
[17:43:48.322]                           ns <- base::getNamespace("future")
[17:43:48.322]                           version <- ns[[".package"]][["version"]]
[17:43:48.322]                           if (is.null(version)) 
[17:43:48.322]                             version <- utils::packageVersion("future")
[17:43:48.322]                         }
[17:43:48.322]                         else {
[17:43:48.322]                           version <- NULL
[17:43:48.322]                         }
[17:43:48.322]                         if (!has_future || version < "1.8.0") {
[17:43:48.322]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:48.322]                             "", base::R.version$version.string), 
[17:43:48.322]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:48.322]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:48.322]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:48.322]                               "release", "version")], collapse = " "), 
[17:43:48.322]                             hostname = base::Sys.info()[["nodename"]])
[17:43:48.322]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:48.322]                             info)
[17:43:48.322]                           info <- base::paste(info, collapse = "; ")
[17:43:48.322]                           if (!has_future) {
[17:43:48.322]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:48.322]                               info)
[17:43:48.322]                           }
[17:43:48.322]                           else {
[17:43:48.322]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:48.322]                               info, version)
[17:43:48.322]                           }
[17:43:48.322]                           base::stop(msg)
[17:43:48.322]                         }
[17:43:48.322]                       })
[17:43:48.322]                     }
[17:43:48.322]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:48.322]                     base::options(mc.cores = 1L)
[17:43:48.322]                   }
[17:43:48.322]                   options(future.plan = NULL)
[17:43:48.322]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.322]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:48.322]                 }
[17:43:48.322]                 ...future.workdir <- getwd()
[17:43:48.322]             }
[17:43:48.322]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:48.322]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:48.322]         }
[17:43:48.322]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:48.322]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:48.322]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:48.322]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:48.322]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:48.322]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:48.322]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:48.322]             base::names(...future.oldOptions))
[17:43:48.322]     }
[17:43:48.322]     if (FALSE) {
[17:43:48.322]     }
[17:43:48.322]     else {
[17:43:48.322]         if (TRUE) {
[17:43:48.322]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:48.322]                 open = "w")
[17:43:48.322]         }
[17:43:48.322]         else {
[17:43:48.322]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:48.322]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:48.322]         }
[17:43:48.322]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:48.322]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:48.322]             base::sink(type = "output", split = FALSE)
[17:43:48.322]             base::close(...future.stdout)
[17:43:48.322]         }, add = TRUE)
[17:43:48.322]     }
[17:43:48.322]     ...future.frame <- base::sys.nframe()
[17:43:48.322]     ...future.conditions <- base::list()
[17:43:48.322]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:48.322]     if (FALSE) {
[17:43:48.322]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:48.322]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:48.322]     }
[17:43:48.322]     ...future.result <- base::tryCatch({
[17:43:48.322]         base::withCallingHandlers({
[17:43:48.322]             ...future.value <- base::withVisible(base::local({
[17:43:48.322]                 ...future.makeSendCondition <- local({
[17:43:48.322]                   sendCondition <- NULL
[17:43:48.322]                   function(frame = 1L) {
[17:43:48.322]                     if (is.function(sendCondition)) 
[17:43:48.322]                       return(sendCondition)
[17:43:48.322]                     ns <- getNamespace("parallel")
[17:43:48.322]                     if (exists("sendData", mode = "function", 
[17:43:48.322]                       envir = ns)) {
[17:43:48.322]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:48.322]                         envir = ns)
[17:43:48.322]                       envir <- sys.frame(frame)
[17:43:48.322]                       master <- NULL
[17:43:48.322]                       while (!identical(envir, .GlobalEnv) && 
[17:43:48.322]                         !identical(envir, emptyenv())) {
[17:43:48.322]                         if (exists("master", mode = "list", envir = envir, 
[17:43:48.322]                           inherits = FALSE)) {
[17:43:48.322]                           master <- get("master", mode = "list", 
[17:43:48.322]                             envir = envir, inherits = FALSE)
[17:43:48.322]                           if (inherits(master, c("SOCKnode", 
[17:43:48.322]                             "SOCK0node"))) {
[17:43:48.322]                             sendCondition <<- function(cond) {
[17:43:48.322]                               data <- list(type = "VALUE", value = cond, 
[17:43:48.322]                                 success = TRUE)
[17:43:48.322]                               parallel_sendData(master, data)
[17:43:48.322]                             }
[17:43:48.322]                             return(sendCondition)
[17:43:48.322]                           }
[17:43:48.322]                         }
[17:43:48.322]                         frame <- frame + 1L
[17:43:48.322]                         envir <- sys.frame(frame)
[17:43:48.322]                       }
[17:43:48.322]                     }
[17:43:48.322]                     sendCondition <<- function(cond) NULL
[17:43:48.322]                   }
[17:43:48.322]                 })
[17:43:48.322]                 withCallingHandlers({
[17:43:48.322]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:43:48.322]                 }, immediateCondition = function(cond) {
[17:43:48.322]                   sendCondition <- ...future.makeSendCondition()
[17:43:48.322]                   sendCondition(cond)
[17:43:48.322]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.322]                   {
[17:43:48.322]                     inherits <- base::inherits
[17:43:48.322]                     invokeRestart <- base::invokeRestart
[17:43:48.322]                     is.null <- base::is.null
[17:43:48.322]                     muffled <- FALSE
[17:43:48.322]                     if (inherits(cond, "message")) {
[17:43:48.322]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:48.322]                       if (muffled) 
[17:43:48.322]                         invokeRestart("muffleMessage")
[17:43:48.322]                     }
[17:43:48.322]                     else if (inherits(cond, "warning")) {
[17:43:48.322]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:48.322]                       if (muffled) 
[17:43:48.322]                         invokeRestart("muffleWarning")
[17:43:48.322]                     }
[17:43:48.322]                     else if (inherits(cond, "condition")) {
[17:43:48.322]                       if (!is.null(pattern)) {
[17:43:48.322]                         computeRestarts <- base::computeRestarts
[17:43:48.322]                         grepl <- base::grepl
[17:43:48.322]                         restarts <- computeRestarts(cond)
[17:43:48.322]                         for (restart in restarts) {
[17:43:48.322]                           name <- restart$name
[17:43:48.322]                           if (is.null(name)) 
[17:43:48.322]                             next
[17:43:48.322]                           if (!grepl(pattern, name)) 
[17:43:48.322]                             next
[17:43:48.322]                           invokeRestart(restart)
[17:43:48.322]                           muffled <- TRUE
[17:43:48.322]                           break
[17:43:48.322]                         }
[17:43:48.322]                       }
[17:43:48.322]                     }
[17:43:48.322]                     invisible(muffled)
[17:43:48.322]                   }
[17:43:48.322]                   muffleCondition(cond)
[17:43:48.322]                 })
[17:43:48.322]             }))
[17:43:48.322]             future::FutureResult(value = ...future.value$value, 
[17:43:48.322]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.322]                   ...future.rng), globalenv = if (FALSE) 
[17:43:48.322]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:48.322]                     ...future.globalenv.names))
[17:43:48.322]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:48.322]         }, condition = base::local({
[17:43:48.322]             c <- base::c
[17:43:48.322]             inherits <- base::inherits
[17:43:48.322]             invokeRestart <- base::invokeRestart
[17:43:48.322]             length <- base::length
[17:43:48.322]             list <- base::list
[17:43:48.322]             seq.int <- base::seq.int
[17:43:48.322]             signalCondition <- base::signalCondition
[17:43:48.322]             sys.calls <- base::sys.calls
[17:43:48.322]             `[[` <- base::`[[`
[17:43:48.322]             `+` <- base::`+`
[17:43:48.322]             `<<-` <- base::`<<-`
[17:43:48.322]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:48.322]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:48.322]                   3L)]
[17:43:48.322]             }
[17:43:48.322]             function(cond) {
[17:43:48.322]                 is_error <- inherits(cond, "error")
[17:43:48.322]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:48.322]                   NULL)
[17:43:48.322]                 if (is_error) {
[17:43:48.322]                   sessionInformation <- function() {
[17:43:48.322]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:48.322]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:48.322]                       search = base::search(), system = base::Sys.info())
[17:43:48.322]                   }
[17:43:48.322]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.322]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:48.322]                     cond$call), session = sessionInformation(), 
[17:43:48.322]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:48.322]                   signalCondition(cond)
[17:43:48.322]                 }
[17:43:48.322]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:48.322]                 "immediateCondition"))) {
[17:43:48.322]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:48.322]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.322]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:48.322]                   if (TRUE && !signal) {
[17:43:48.322]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.322]                     {
[17:43:48.322]                       inherits <- base::inherits
[17:43:48.322]                       invokeRestart <- base::invokeRestart
[17:43:48.322]                       is.null <- base::is.null
[17:43:48.322]                       muffled <- FALSE
[17:43:48.322]                       if (inherits(cond, "message")) {
[17:43:48.322]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.322]                         if (muffled) 
[17:43:48.322]                           invokeRestart("muffleMessage")
[17:43:48.322]                       }
[17:43:48.322]                       else if (inherits(cond, "warning")) {
[17:43:48.322]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.322]                         if (muffled) 
[17:43:48.322]                           invokeRestart("muffleWarning")
[17:43:48.322]                       }
[17:43:48.322]                       else if (inherits(cond, "condition")) {
[17:43:48.322]                         if (!is.null(pattern)) {
[17:43:48.322]                           computeRestarts <- base::computeRestarts
[17:43:48.322]                           grepl <- base::grepl
[17:43:48.322]                           restarts <- computeRestarts(cond)
[17:43:48.322]                           for (restart in restarts) {
[17:43:48.322]                             name <- restart$name
[17:43:48.322]                             if (is.null(name)) 
[17:43:48.322]                               next
[17:43:48.322]                             if (!grepl(pattern, name)) 
[17:43:48.322]                               next
[17:43:48.322]                             invokeRestart(restart)
[17:43:48.322]                             muffled <- TRUE
[17:43:48.322]                             break
[17:43:48.322]                           }
[17:43:48.322]                         }
[17:43:48.322]                       }
[17:43:48.322]                       invisible(muffled)
[17:43:48.322]                     }
[17:43:48.322]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.322]                   }
[17:43:48.322]                 }
[17:43:48.322]                 else {
[17:43:48.322]                   if (TRUE) {
[17:43:48.322]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.322]                     {
[17:43:48.322]                       inherits <- base::inherits
[17:43:48.322]                       invokeRestart <- base::invokeRestart
[17:43:48.322]                       is.null <- base::is.null
[17:43:48.322]                       muffled <- FALSE
[17:43:48.322]                       if (inherits(cond, "message")) {
[17:43:48.322]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.322]                         if (muffled) 
[17:43:48.322]                           invokeRestart("muffleMessage")
[17:43:48.322]                       }
[17:43:48.322]                       else if (inherits(cond, "warning")) {
[17:43:48.322]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.322]                         if (muffled) 
[17:43:48.322]                           invokeRestart("muffleWarning")
[17:43:48.322]                       }
[17:43:48.322]                       else if (inherits(cond, "condition")) {
[17:43:48.322]                         if (!is.null(pattern)) {
[17:43:48.322]                           computeRestarts <- base::computeRestarts
[17:43:48.322]                           grepl <- base::grepl
[17:43:48.322]                           restarts <- computeRestarts(cond)
[17:43:48.322]                           for (restart in restarts) {
[17:43:48.322]                             name <- restart$name
[17:43:48.322]                             if (is.null(name)) 
[17:43:48.322]                               next
[17:43:48.322]                             if (!grepl(pattern, name)) 
[17:43:48.322]                               next
[17:43:48.322]                             invokeRestart(restart)
[17:43:48.322]                             muffled <- TRUE
[17:43:48.322]                             break
[17:43:48.322]                           }
[17:43:48.322]                         }
[17:43:48.322]                       }
[17:43:48.322]                       invisible(muffled)
[17:43:48.322]                     }
[17:43:48.322]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.322]                   }
[17:43:48.322]                 }
[17:43:48.322]             }
[17:43:48.322]         }))
[17:43:48.322]     }, error = function(ex) {
[17:43:48.322]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:48.322]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.322]                 ...future.rng), started = ...future.startTime, 
[17:43:48.322]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:48.322]             version = "1.8"), class = "FutureResult")
[17:43:48.322]     }, finally = {
[17:43:48.322]         if (!identical(...future.workdir, getwd())) 
[17:43:48.322]             setwd(...future.workdir)
[17:43:48.322]         {
[17:43:48.322]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:48.322]                 ...future.oldOptions$nwarnings <- NULL
[17:43:48.322]             }
[17:43:48.322]             base::options(...future.oldOptions)
[17:43:48.322]             if (.Platform$OS.type == "windows") {
[17:43:48.322]                 old_names <- names(...future.oldEnvVars)
[17:43:48.322]                 envs <- base::Sys.getenv()
[17:43:48.322]                 names <- names(envs)
[17:43:48.322]                 common <- intersect(names, old_names)
[17:43:48.322]                 added <- setdiff(names, old_names)
[17:43:48.322]                 removed <- setdiff(old_names, names)
[17:43:48.322]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:48.322]                   envs[common]]
[17:43:48.322]                 NAMES <- toupper(changed)
[17:43:48.322]                 args <- list()
[17:43:48.322]                 for (kk in seq_along(NAMES)) {
[17:43:48.322]                   name <- changed[[kk]]
[17:43:48.322]                   NAME <- NAMES[[kk]]
[17:43:48.322]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.322]                     next
[17:43:48.322]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.322]                 }
[17:43:48.322]                 NAMES <- toupper(added)
[17:43:48.322]                 for (kk in seq_along(NAMES)) {
[17:43:48.322]                   name <- added[[kk]]
[17:43:48.322]                   NAME <- NAMES[[kk]]
[17:43:48.322]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.322]                     next
[17:43:48.322]                   args[[name]] <- ""
[17:43:48.322]                 }
[17:43:48.322]                 NAMES <- toupper(removed)
[17:43:48.322]                 for (kk in seq_along(NAMES)) {
[17:43:48.322]                   name <- removed[[kk]]
[17:43:48.322]                   NAME <- NAMES[[kk]]
[17:43:48.322]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.322]                     next
[17:43:48.322]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.322]                 }
[17:43:48.322]                 if (length(args) > 0) 
[17:43:48.322]                   base::do.call(base::Sys.setenv, args = args)
[17:43:48.322]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:48.322]             }
[17:43:48.322]             else {
[17:43:48.322]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:48.322]             }
[17:43:48.322]             {
[17:43:48.322]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:48.322]                   0L) {
[17:43:48.322]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:48.322]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:48.322]                   base::options(opts)
[17:43:48.322]                 }
[17:43:48.322]                 {
[17:43:48.322]                   {
[17:43:48.322]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:48.322]                     NULL
[17:43:48.322]                   }
[17:43:48.322]                   options(future.plan = NULL)
[17:43:48.322]                   if (is.na(NA_character_)) 
[17:43:48.322]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.322]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:48.322]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:48.322]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:48.322]                     envir = parent.frame()) 
[17:43:48.322]                   {
[17:43:48.322]                     if (is.function(workers)) 
[17:43:48.322]                       workers <- workers()
[17:43:48.322]                     workers <- structure(as.integer(workers), 
[17:43:48.322]                       class = class(workers))
[17:43:48.322]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:48.322]                       workers >= 1)
[17:43:48.322]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:48.322]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:48.322]                     }
[17:43:48.322]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:48.322]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:48.322]                       envir = envir)
[17:43:48.322]                     if (!future$lazy) 
[17:43:48.322]                       future <- run(future)
[17:43:48.322]                     invisible(future)
[17:43:48.322]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:48.322]                 }
[17:43:48.322]             }
[17:43:48.322]         }
[17:43:48.322]     })
[17:43:48.322]     if (TRUE) {
[17:43:48.322]         base::sink(type = "output", split = FALSE)
[17:43:48.322]         if (TRUE) {
[17:43:48.322]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:48.322]         }
[17:43:48.322]         else {
[17:43:48.322]             ...future.result["stdout"] <- base::list(NULL)
[17:43:48.322]         }
[17:43:48.322]         base::close(...future.stdout)
[17:43:48.322]         ...future.stdout <- NULL
[17:43:48.322]     }
[17:43:48.322]     ...future.result$conditions <- ...future.conditions
[17:43:48.322]     ...future.result$finished <- base::Sys.time()
[17:43:48.322]     ...future.result
[17:43:48.322] }
[17:43:48.324] Poll #1 (0): usedNodes() = 2, workers = 2
[17:43:48.335] receiveMessageFromWorker() for ClusterFuture ...
[17:43:48.335] - Validating connection of MultisessionFuture
[17:43:48.335] - received message: FutureResult
[17:43:48.335] - Received FutureResult
[17:43:48.335] - Erased future from FutureRegistry
[17:43:48.336] result() for ClusterFuture ...
[17:43:48.336] - result already collected: FutureResult
[17:43:48.336] result() for ClusterFuture ... done
[17:43:48.336] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:48.336] result() for ClusterFuture ...
[17:43:48.336] - result already collected: FutureResult
[17:43:48.336] result() for ClusterFuture ... done
[17:43:48.336] result() for ClusterFuture ...
[17:43:48.336] - result already collected: FutureResult
[17:43:48.336] result() for ClusterFuture ... done
[17:43:48.338] MultisessionFuture started
[17:43:48.338] - Launch lazy future ... done
[17:43:48.338] run() for ‘MultisessionFuture’ ... done
[17:43:48.338] getGlobalsAndPackages() ...
[17:43:48.338] Searching for globals...
[17:43:48.339] - globals found: [2] ‘list’, ‘stop’
[17:43:48.339] Searching for globals ... DONE
[17:43:48.339] Resolving globals: FALSE
[17:43:48.339] 
[17:43:48.339] 
[17:43:48.339] getGlobalsAndPackages() ... DONE
- result = TRUE, recursive = -1 ... DONE
- result = TRUE, recursive = 0 ...
[17:43:48.340] getGlobalsAndPackages() ...
[17:43:48.340] Searching for globals...
[17:43:48.341] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:43:48.341] Searching for globals ... DONE
[17:43:48.341] Resolving globals: FALSE
[17:43:48.341] 
[17:43:48.342] 
[17:43:48.342] getGlobalsAndPackages() ... DONE
[17:43:48.342] run() for ‘Future’ ...
[17:43:48.342] - state: ‘created’
[17:43:48.342] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:48.357] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:48.357] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:48.357]   - Field: ‘node’
[17:43:48.357]   - Field: ‘label’
[17:43:48.357]   - Field: ‘local’
[17:43:48.357]   - Field: ‘owner’
[17:43:48.358]   - Field: ‘envir’
[17:43:48.358]   - Field: ‘workers’
[17:43:48.358]   - Field: ‘packages’
[17:43:48.358]   - Field: ‘gc’
[17:43:48.358]   - Field: ‘conditions’
[17:43:48.358]   - Field: ‘persistent’
[17:43:48.358]   - Field: ‘expr’
[17:43:48.358]   - Field: ‘uuid’
[17:43:48.358]   - Field: ‘seed’
[17:43:48.358]   - Field: ‘version’
[17:43:48.358]   - Field: ‘result’
[17:43:48.359]   - Field: ‘asynchronous’
[17:43:48.359]   - Field: ‘calls’
[17:43:48.359]   - Field: ‘globals’
[17:43:48.359]   - Field: ‘stdout’
[17:43:48.359]   - Field: ‘earlySignal’
[17:43:48.359]   - Field: ‘lazy’
[17:43:48.359]   - Field: ‘state’
[17:43:48.359] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:48.359] - Launch lazy future ...
[17:43:48.360] Packages needed by the future expression (n = 0): <none>
[17:43:48.360] Packages needed by future strategies (n = 0): <none>
[17:43:48.360] {
[17:43:48.360]     {
[17:43:48.360]         {
[17:43:48.360]             ...future.startTime <- base::Sys.time()
[17:43:48.360]             {
[17:43:48.360]                 {
[17:43:48.360]                   {
[17:43:48.360]                     {
[17:43:48.360]                       base::local({
[17:43:48.360]                         has_future <- base::requireNamespace("future", 
[17:43:48.360]                           quietly = TRUE)
[17:43:48.360]                         if (has_future) {
[17:43:48.360]                           ns <- base::getNamespace("future")
[17:43:48.360]                           version <- ns[[".package"]][["version"]]
[17:43:48.360]                           if (is.null(version)) 
[17:43:48.360]                             version <- utils::packageVersion("future")
[17:43:48.360]                         }
[17:43:48.360]                         else {
[17:43:48.360]                           version <- NULL
[17:43:48.360]                         }
[17:43:48.360]                         if (!has_future || version < "1.8.0") {
[17:43:48.360]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:48.360]                             "", base::R.version$version.string), 
[17:43:48.360]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:48.360]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:48.360]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:48.360]                               "release", "version")], collapse = " "), 
[17:43:48.360]                             hostname = base::Sys.info()[["nodename"]])
[17:43:48.360]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:48.360]                             info)
[17:43:48.360]                           info <- base::paste(info, collapse = "; ")
[17:43:48.360]                           if (!has_future) {
[17:43:48.360]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:48.360]                               info)
[17:43:48.360]                           }
[17:43:48.360]                           else {
[17:43:48.360]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:48.360]                               info, version)
[17:43:48.360]                           }
[17:43:48.360]                           base::stop(msg)
[17:43:48.360]                         }
[17:43:48.360]                       })
[17:43:48.360]                     }
[17:43:48.360]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:48.360]                     base::options(mc.cores = 1L)
[17:43:48.360]                   }
[17:43:48.360]                   options(future.plan = NULL)
[17:43:48.360]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.360]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:48.360]                 }
[17:43:48.360]                 ...future.workdir <- getwd()
[17:43:48.360]             }
[17:43:48.360]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:48.360]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:48.360]         }
[17:43:48.360]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:48.360]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:48.360]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:48.360]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:48.360]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:48.360]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:48.360]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:48.360]             base::names(...future.oldOptions))
[17:43:48.360]     }
[17:43:48.360]     if (FALSE) {
[17:43:48.360]     }
[17:43:48.360]     else {
[17:43:48.360]         if (TRUE) {
[17:43:48.360]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:48.360]                 open = "w")
[17:43:48.360]         }
[17:43:48.360]         else {
[17:43:48.360]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:48.360]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:48.360]         }
[17:43:48.360]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:48.360]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:48.360]             base::sink(type = "output", split = FALSE)
[17:43:48.360]             base::close(...future.stdout)
[17:43:48.360]         }, add = TRUE)
[17:43:48.360]     }
[17:43:48.360]     ...future.frame <- base::sys.nframe()
[17:43:48.360]     ...future.conditions <- base::list()
[17:43:48.360]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:48.360]     if (FALSE) {
[17:43:48.360]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:48.360]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:48.360]     }
[17:43:48.360]     ...future.result <- base::tryCatch({
[17:43:48.360]         base::withCallingHandlers({
[17:43:48.360]             ...future.value <- base::withVisible(base::local({
[17:43:48.360]                 ...future.makeSendCondition <- local({
[17:43:48.360]                   sendCondition <- NULL
[17:43:48.360]                   function(frame = 1L) {
[17:43:48.360]                     if (is.function(sendCondition)) 
[17:43:48.360]                       return(sendCondition)
[17:43:48.360]                     ns <- getNamespace("parallel")
[17:43:48.360]                     if (exists("sendData", mode = "function", 
[17:43:48.360]                       envir = ns)) {
[17:43:48.360]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:48.360]                         envir = ns)
[17:43:48.360]                       envir <- sys.frame(frame)
[17:43:48.360]                       master <- NULL
[17:43:48.360]                       while (!identical(envir, .GlobalEnv) && 
[17:43:48.360]                         !identical(envir, emptyenv())) {
[17:43:48.360]                         if (exists("master", mode = "list", envir = envir, 
[17:43:48.360]                           inherits = FALSE)) {
[17:43:48.360]                           master <- get("master", mode = "list", 
[17:43:48.360]                             envir = envir, inherits = FALSE)
[17:43:48.360]                           if (inherits(master, c("SOCKnode", 
[17:43:48.360]                             "SOCK0node"))) {
[17:43:48.360]                             sendCondition <<- function(cond) {
[17:43:48.360]                               data <- list(type = "VALUE", value = cond, 
[17:43:48.360]                                 success = TRUE)
[17:43:48.360]                               parallel_sendData(master, data)
[17:43:48.360]                             }
[17:43:48.360]                             return(sendCondition)
[17:43:48.360]                           }
[17:43:48.360]                         }
[17:43:48.360]                         frame <- frame + 1L
[17:43:48.360]                         envir <- sys.frame(frame)
[17:43:48.360]                       }
[17:43:48.360]                     }
[17:43:48.360]                     sendCondition <<- function(cond) NULL
[17:43:48.360]                   }
[17:43:48.360]                 })
[17:43:48.360]                 withCallingHandlers({
[17:43:48.360]                   {
[17:43:48.360]                     Sys.sleep(0.5)
[17:43:48.360]                     list(a = 1, b = 42L)
[17:43:48.360]                   }
[17:43:48.360]                 }, immediateCondition = function(cond) {
[17:43:48.360]                   sendCondition <- ...future.makeSendCondition()
[17:43:48.360]                   sendCondition(cond)
[17:43:48.360]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.360]                   {
[17:43:48.360]                     inherits <- base::inherits
[17:43:48.360]                     invokeRestart <- base::invokeRestart
[17:43:48.360]                     is.null <- base::is.null
[17:43:48.360]                     muffled <- FALSE
[17:43:48.360]                     if (inherits(cond, "message")) {
[17:43:48.360]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:48.360]                       if (muffled) 
[17:43:48.360]                         invokeRestart("muffleMessage")
[17:43:48.360]                     }
[17:43:48.360]                     else if (inherits(cond, "warning")) {
[17:43:48.360]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:48.360]                       if (muffled) 
[17:43:48.360]                         invokeRestart("muffleWarning")
[17:43:48.360]                     }
[17:43:48.360]                     else if (inherits(cond, "condition")) {
[17:43:48.360]                       if (!is.null(pattern)) {
[17:43:48.360]                         computeRestarts <- base::computeRestarts
[17:43:48.360]                         grepl <- base::grepl
[17:43:48.360]                         restarts <- computeRestarts(cond)
[17:43:48.360]                         for (restart in restarts) {
[17:43:48.360]                           name <- restart$name
[17:43:48.360]                           if (is.null(name)) 
[17:43:48.360]                             next
[17:43:48.360]                           if (!grepl(pattern, name)) 
[17:43:48.360]                             next
[17:43:48.360]                           invokeRestart(restart)
[17:43:48.360]                           muffled <- TRUE
[17:43:48.360]                           break
[17:43:48.360]                         }
[17:43:48.360]                       }
[17:43:48.360]                     }
[17:43:48.360]                     invisible(muffled)
[17:43:48.360]                   }
[17:43:48.360]                   muffleCondition(cond)
[17:43:48.360]                 })
[17:43:48.360]             }))
[17:43:48.360]             future::FutureResult(value = ...future.value$value, 
[17:43:48.360]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.360]                   ...future.rng), globalenv = if (FALSE) 
[17:43:48.360]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:48.360]                     ...future.globalenv.names))
[17:43:48.360]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:48.360]         }, condition = base::local({
[17:43:48.360]             c <- base::c
[17:43:48.360]             inherits <- base::inherits
[17:43:48.360]             invokeRestart <- base::invokeRestart
[17:43:48.360]             length <- base::length
[17:43:48.360]             list <- base::list
[17:43:48.360]             seq.int <- base::seq.int
[17:43:48.360]             signalCondition <- base::signalCondition
[17:43:48.360]             sys.calls <- base::sys.calls
[17:43:48.360]             `[[` <- base::`[[`
[17:43:48.360]             `+` <- base::`+`
[17:43:48.360]             `<<-` <- base::`<<-`
[17:43:48.360]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:48.360]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:48.360]                   3L)]
[17:43:48.360]             }
[17:43:48.360]             function(cond) {
[17:43:48.360]                 is_error <- inherits(cond, "error")
[17:43:48.360]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:48.360]                   NULL)
[17:43:48.360]                 if (is_error) {
[17:43:48.360]                   sessionInformation <- function() {
[17:43:48.360]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:48.360]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:48.360]                       search = base::search(), system = base::Sys.info())
[17:43:48.360]                   }
[17:43:48.360]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.360]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:48.360]                     cond$call), session = sessionInformation(), 
[17:43:48.360]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:48.360]                   signalCondition(cond)
[17:43:48.360]                 }
[17:43:48.360]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:48.360]                 "immediateCondition"))) {
[17:43:48.360]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:48.360]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.360]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:48.360]                   if (TRUE && !signal) {
[17:43:48.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.360]                     {
[17:43:48.360]                       inherits <- base::inherits
[17:43:48.360]                       invokeRestart <- base::invokeRestart
[17:43:48.360]                       is.null <- base::is.null
[17:43:48.360]                       muffled <- FALSE
[17:43:48.360]                       if (inherits(cond, "message")) {
[17:43:48.360]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.360]                         if (muffled) 
[17:43:48.360]                           invokeRestart("muffleMessage")
[17:43:48.360]                       }
[17:43:48.360]                       else if (inherits(cond, "warning")) {
[17:43:48.360]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.360]                         if (muffled) 
[17:43:48.360]                           invokeRestart("muffleWarning")
[17:43:48.360]                       }
[17:43:48.360]                       else if (inherits(cond, "condition")) {
[17:43:48.360]                         if (!is.null(pattern)) {
[17:43:48.360]                           computeRestarts <- base::computeRestarts
[17:43:48.360]                           grepl <- base::grepl
[17:43:48.360]                           restarts <- computeRestarts(cond)
[17:43:48.360]                           for (restart in restarts) {
[17:43:48.360]                             name <- restart$name
[17:43:48.360]                             if (is.null(name)) 
[17:43:48.360]                               next
[17:43:48.360]                             if (!grepl(pattern, name)) 
[17:43:48.360]                               next
[17:43:48.360]                             invokeRestart(restart)
[17:43:48.360]                             muffled <- TRUE
[17:43:48.360]                             break
[17:43:48.360]                           }
[17:43:48.360]                         }
[17:43:48.360]                       }
[17:43:48.360]                       invisible(muffled)
[17:43:48.360]                     }
[17:43:48.360]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.360]                   }
[17:43:48.360]                 }
[17:43:48.360]                 else {
[17:43:48.360]                   if (TRUE) {
[17:43:48.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.360]                     {
[17:43:48.360]                       inherits <- base::inherits
[17:43:48.360]                       invokeRestart <- base::invokeRestart
[17:43:48.360]                       is.null <- base::is.null
[17:43:48.360]                       muffled <- FALSE
[17:43:48.360]                       if (inherits(cond, "message")) {
[17:43:48.360]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.360]                         if (muffled) 
[17:43:48.360]                           invokeRestart("muffleMessage")
[17:43:48.360]                       }
[17:43:48.360]                       else if (inherits(cond, "warning")) {
[17:43:48.360]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.360]                         if (muffled) 
[17:43:48.360]                           invokeRestart("muffleWarning")
[17:43:48.360]                       }
[17:43:48.360]                       else if (inherits(cond, "condition")) {
[17:43:48.360]                         if (!is.null(pattern)) {
[17:43:48.360]                           computeRestarts <- base::computeRestarts
[17:43:48.360]                           grepl <- base::grepl
[17:43:48.360]                           restarts <- computeRestarts(cond)
[17:43:48.360]                           for (restart in restarts) {
[17:43:48.360]                             name <- restart$name
[17:43:48.360]                             if (is.null(name)) 
[17:43:48.360]                               next
[17:43:48.360]                             if (!grepl(pattern, name)) 
[17:43:48.360]                               next
[17:43:48.360]                             invokeRestart(restart)
[17:43:48.360]                             muffled <- TRUE
[17:43:48.360]                             break
[17:43:48.360]                           }
[17:43:48.360]                         }
[17:43:48.360]                       }
[17:43:48.360]                       invisible(muffled)
[17:43:48.360]                     }
[17:43:48.360]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.360]                   }
[17:43:48.360]                 }
[17:43:48.360]             }
[17:43:48.360]         }))
[17:43:48.360]     }, error = function(ex) {
[17:43:48.360]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:48.360]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.360]                 ...future.rng), started = ...future.startTime, 
[17:43:48.360]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:48.360]             version = "1.8"), class = "FutureResult")
[17:43:48.360]     }, finally = {
[17:43:48.360]         if (!identical(...future.workdir, getwd())) 
[17:43:48.360]             setwd(...future.workdir)
[17:43:48.360]         {
[17:43:48.360]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:48.360]                 ...future.oldOptions$nwarnings <- NULL
[17:43:48.360]             }
[17:43:48.360]             base::options(...future.oldOptions)
[17:43:48.360]             if (.Platform$OS.type == "windows") {
[17:43:48.360]                 old_names <- names(...future.oldEnvVars)
[17:43:48.360]                 envs <- base::Sys.getenv()
[17:43:48.360]                 names <- names(envs)
[17:43:48.360]                 common <- intersect(names, old_names)
[17:43:48.360]                 added <- setdiff(names, old_names)
[17:43:48.360]                 removed <- setdiff(old_names, names)
[17:43:48.360]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:48.360]                   envs[common]]
[17:43:48.360]                 NAMES <- toupper(changed)
[17:43:48.360]                 args <- list()
[17:43:48.360]                 for (kk in seq_along(NAMES)) {
[17:43:48.360]                   name <- changed[[kk]]
[17:43:48.360]                   NAME <- NAMES[[kk]]
[17:43:48.360]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.360]                     next
[17:43:48.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.360]                 }
[17:43:48.360]                 NAMES <- toupper(added)
[17:43:48.360]                 for (kk in seq_along(NAMES)) {
[17:43:48.360]                   name <- added[[kk]]
[17:43:48.360]                   NAME <- NAMES[[kk]]
[17:43:48.360]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.360]                     next
[17:43:48.360]                   args[[name]] <- ""
[17:43:48.360]                 }
[17:43:48.360]                 NAMES <- toupper(removed)
[17:43:48.360]                 for (kk in seq_along(NAMES)) {
[17:43:48.360]                   name <- removed[[kk]]
[17:43:48.360]                   NAME <- NAMES[[kk]]
[17:43:48.360]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.360]                     next
[17:43:48.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.360]                 }
[17:43:48.360]                 if (length(args) > 0) 
[17:43:48.360]                   base::do.call(base::Sys.setenv, args = args)
[17:43:48.360]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:48.360]             }
[17:43:48.360]             else {
[17:43:48.360]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:48.360]             }
[17:43:48.360]             {
[17:43:48.360]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:48.360]                   0L) {
[17:43:48.360]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:48.360]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:48.360]                   base::options(opts)
[17:43:48.360]                 }
[17:43:48.360]                 {
[17:43:48.360]                   {
[17:43:48.360]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:48.360]                     NULL
[17:43:48.360]                   }
[17:43:48.360]                   options(future.plan = NULL)
[17:43:48.360]                   if (is.na(NA_character_)) 
[17:43:48.360]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.360]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:48.360]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:48.360]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:48.360]                     envir = parent.frame()) 
[17:43:48.360]                   {
[17:43:48.360]                     if (is.function(workers)) 
[17:43:48.360]                       workers <- workers()
[17:43:48.360]                     workers <- structure(as.integer(workers), 
[17:43:48.360]                       class = class(workers))
[17:43:48.360]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:48.360]                       workers >= 1)
[17:43:48.360]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:48.360]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:48.360]                     }
[17:43:48.360]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:48.360]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:48.360]                       envir = envir)
[17:43:48.360]                     if (!future$lazy) 
[17:43:48.360]                       future <- run(future)
[17:43:48.360]                     invisible(future)
[17:43:48.360]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:48.360]                 }
[17:43:48.360]             }
[17:43:48.360]         }
[17:43:48.360]     })
[17:43:48.360]     if (TRUE) {
[17:43:48.360]         base::sink(type = "output", split = FALSE)
[17:43:48.360]         if (TRUE) {
[17:43:48.360]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:48.360]         }
[17:43:48.360]         else {
[17:43:48.360]             ...future.result["stdout"] <- base::list(NULL)
[17:43:48.360]         }
[17:43:48.360]         base::close(...future.stdout)
[17:43:48.360]         ...future.stdout <- NULL
[17:43:48.360]     }
[17:43:48.360]     ...future.result$conditions <- ...future.conditions
[17:43:48.360]     ...future.result$finished <- base::Sys.time()
[17:43:48.360]     ...future.result
[17:43:48.360] }
[17:43:48.363] Poll #1 (0): usedNodes() = 2, workers = 2
[17:43:48.384] receiveMessageFromWorker() for ClusterFuture ...
[17:43:48.384] - Validating connection of MultisessionFuture
[17:43:48.387] - received message: FutureResult
[17:43:48.387] - Received FutureResult
[17:43:48.388] - Erased future from FutureRegistry
[17:43:48.388] result() for ClusterFuture ...
[17:43:48.388] - result already collected: FutureResult
[17:43:48.388] result() for ClusterFuture ... done
[17:43:48.388] signalConditions() ...
[17:43:48.388]  - include = ‘immediateCondition’
[17:43:48.388]  - exclude = 
[17:43:48.388]  - resignal = FALSE
[17:43:48.389]  - Number of conditions: 1
[17:43:48.389] signalConditions() ... done
[17:43:48.389] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:48.389] result() for ClusterFuture ...
[17:43:48.389] - result already collected: FutureResult
[17:43:48.389] result() for ClusterFuture ... done
[17:43:48.389] result() for ClusterFuture ...
[17:43:48.389] - result already collected: FutureResult
[17:43:48.389] result() for ClusterFuture ... done
[17:43:48.390] signalConditions() ...
[17:43:48.390]  - include = ‘immediateCondition’
[17:43:48.390]  - exclude = 
[17:43:48.390]  - resignal = FALSE
[17:43:48.390]  - Number of conditions: 1
[17:43:48.390] signalConditions() ... done
[17:43:48.391] MultisessionFuture started
[17:43:48.391] - Launch lazy future ... done
[17:43:48.391] run() for ‘MultisessionFuture’ ... done
[17:43:48.952] receiveMessageFromWorker() for ClusterFuture ...
[17:43:48.952] - Validating connection of MultisessionFuture
[17:43:48.952] - received message: FutureResult
[17:43:48.952] - Received FutureResult
[17:43:48.952] - Erased future from FutureRegistry
[17:43:48.953] result() for ClusterFuture ...
[17:43:48.953] - result already collected: FutureResult
[17:43:48.953] result() for ClusterFuture ... done
[17:43:48.953] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:48.953] A MultisessionFuture was resolved
[17:43:48.953] getGlobalsAndPackages() ...
[17:43:48.953] Searching for globals...
[17:43:48.954] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:43:48.954] Searching for globals ... DONE
[17:43:48.954] Resolving globals: FALSE
[17:43:48.955] 
[17:43:48.955] 
[17:43:48.955] getGlobalsAndPackages() ... DONE
[17:43:48.955] run() for ‘Future’ ...
[17:43:48.955] - state: ‘created’
[17:43:48.956] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:48.970] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:48.970] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:48.970]   - Field: ‘node’
[17:43:48.970]   - Field: ‘label’
[17:43:48.970]   - Field: ‘local’
[17:43:48.970]   - Field: ‘owner’
[17:43:48.971]   - Field: ‘envir’
[17:43:48.971]   - Field: ‘workers’
[17:43:48.971]   - Field: ‘packages’
[17:43:48.971]   - Field: ‘gc’
[17:43:48.971]   - Field: ‘conditions’
[17:43:48.971]   - Field: ‘persistent’
[17:43:48.971]   - Field: ‘expr’
[17:43:48.971]   - Field: ‘uuid’
[17:43:48.971]   - Field: ‘seed’
[17:43:48.971]   - Field: ‘version’
[17:43:48.972]   - Field: ‘result’
[17:43:48.972]   - Field: ‘asynchronous’
[17:43:48.972]   - Field: ‘calls’
[17:43:48.972]   - Field: ‘globals’
[17:43:48.972]   - Field: ‘stdout’
[17:43:48.972]   - Field: ‘earlySignal’
[17:43:48.972]   - Field: ‘lazy’
[17:43:48.972]   - Field: ‘state’
[17:43:48.972] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:48.972] - Launch lazy future ...
[17:43:48.973] Packages needed by the future expression (n = 0): <none>
[17:43:48.973] Packages needed by future strategies (n = 0): <none>
[17:43:48.973] {
[17:43:48.973]     {
[17:43:48.973]         {
[17:43:48.973]             ...future.startTime <- base::Sys.time()
[17:43:48.973]             {
[17:43:48.973]                 {
[17:43:48.973]                   {
[17:43:48.973]                     {
[17:43:48.973]                       base::local({
[17:43:48.973]                         has_future <- base::requireNamespace("future", 
[17:43:48.973]                           quietly = TRUE)
[17:43:48.973]                         if (has_future) {
[17:43:48.973]                           ns <- base::getNamespace("future")
[17:43:48.973]                           version <- ns[[".package"]][["version"]]
[17:43:48.973]                           if (is.null(version)) 
[17:43:48.973]                             version <- utils::packageVersion("future")
[17:43:48.973]                         }
[17:43:48.973]                         else {
[17:43:48.973]                           version <- NULL
[17:43:48.973]                         }
[17:43:48.973]                         if (!has_future || version < "1.8.0") {
[17:43:48.973]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:48.973]                             "", base::R.version$version.string), 
[17:43:48.973]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:48.973]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:48.973]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:48.973]                               "release", "version")], collapse = " "), 
[17:43:48.973]                             hostname = base::Sys.info()[["nodename"]])
[17:43:48.973]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:48.973]                             info)
[17:43:48.973]                           info <- base::paste(info, collapse = "; ")
[17:43:48.973]                           if (!has_future) {
[17:43:48.973]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:48.973]                               info)
[17:43:48.973]                           }
[17:43:48.973]                           else {
[17:43:48.973]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:48.973]                               info, version)
[17:43:48.973]                           }
[17:43:48.973]                           base::stop(msg)
[17:43:48.973]                         }
[17:43:48.973]                       })
[17:43:48.973]                     }
[17:43:48.973]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:48.973]                     base::options(mc.cores = 1L)
[17:43:48.973]                   }
[17:43:48.973]                   options(future.plan = NULL)
[17:43:48.973]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.973]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:48.973]                 }
[17:43:48.973]                 ...future.workdir <- getwd()
[17:43:48.973]             }
[17:43:48.973]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:48.973]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:48.973]         }
[17:43:48.973]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:48.973]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:48.973]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:48.973]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:48.973]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:48.973]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:48.973]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:48.973]             base::names(...future.oldOptions))
[17:43:48.973]     }
[17:43:48.973]     if (FALSE) {
[17:43:48.973]     }
[17:43:48.973]     else {
[17:43:48.973]         if (TRUE) {
[17:43:48.973]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:48.973]                 open = "w")
[17:43:48.973]         }
[17:43:48.973]         else {
[17:43:48.973]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:48.973]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:48.973]         }
[17:43:48.973]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:48.973]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:48.973]             base::sink(type = "output", split = FALSE)
[17:43:48.973]             base::close(...future.stdout)
[17:43:48.973]         }, add = TRUE)
[17:43:48.973]     }
[17:43:48.973]     ...future.frame <- base::sys.nframe()
[17:43:48.973]     ...future.conditions <- base::list()
[17:43:48.973]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:48.973]     if (FALSE) {
[17:43:48.973]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:48.973]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:48.973]     }
[17:43:48.973]     ...future.result <- base::tryCatch({
[17:43:48.973]         base::withCallingHandlers({
[17:43:48.973]             ...future.value <- base::withVisible(base::local({
[17:43:48.973]                 ...future.makeSendCondition <- local({
[17:43:48.973]                   sendCondition <- NULL
[17:43:48.973]                   function(frame = 1L) {
[17:43:48.973]                     if (is.function(sendCondition)) 
[17:43:48.973]                       return(sendCondition)
[17:43:48.973]                     ns <- getNamespace("parallel")
[17:43:48.973]                     if (exists("sendData", mode = "function", 
[17:43:48.973]                       envir = ns)) {
[17:43:48.973]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:48.973]                         envir = ns)
[17:43:48.973]                       envir <- sys.frame(frame)
[17:43:48.973]                       master <- NULL
[17:43:48.973]                       while (!identical(envir, .GlobalEnv) && 
[17:43:48.973]                         !identical(envir, emptyenv())) {
[17:43:48.973]                         if (exists("master", mode = "list", envir = envir, 
[17:43:48.973]                           inherits = FALSE)) {
[17:43:48.973]                           master <- get("master", mode = "list", 
[17:43:48.973]                             envir = envir, inherits = FALSE)
[17:43:48.973]                           if (inherits(master, c("SOCKnode", 
[17:43:48.973]                             "SOCK0node"))) {
[17:43:48.973]                             sendCondition <<- function(cond) {
[17:43:48.973]                               data <- list(type = "VALUE", value = cond, 
[17:43:48.973]                                 success = TRUE)
[17:43:48.973]                               parallel_sendData(master, data)
[17:43:48.973]                             }
[17:43:48.973]                             return(sendCondition)
[17:43:48.973]                           }
[17:43:48.973]                         }
[17:43:48.973]                         frame <- frame + 1L
[17:43:48.973]                         envir <- sys.frame(frame)
[17:43:48.973]                       }
[17:43:48.973]                     }
[17:43:48.973]                     sendCondition <<- function(cond) NULL
[17:43:48.973]                   }
[17:43:48.973]                 })
[17:43:48.973]                 withCallingHandlers({
[17:43:48.973]                   {
[17:43:48.973]                     Sys.sleep(0.5)
[17:43:48.973]                     list(a = 1, b = 42L)
[17:43:48.973]                   }
[17:43:48.973]                 }, immediateCondition = function(cond) {
[17:43:48.973]                   sendCondition <- ...future.makeSendCondition()
[17:43:48.973]                   sendCondition(cond)
[17:43:48.973]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.973]                   {
[17:43:48.973]                     inherits <- base::inherits
[17:43:48.973]                     invokeRestart <- base::invokeRestart
[17:43:48.973]                     is.null <- base::is.null
[17:43:48.973]                     muffled <- FALSE
[17:43:48.973]                     if (inherits(cond, "message")) {
[17:43:48.973]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:48.973]                       if (muffled) 
[17:43:48.973]                         invokeRestart("muffleMessage")
[17:43:48.973]                     }
[17:43:48.973]                     else if (inherits(cond, "warning")) {
[17:43:48.973]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:48.973]                       if (muffled) 
[17:43:48.973]                         invokeRestart("muffleWarning")
[17:43:48.973]                     }
[17:43:48.973]                     else if (inherits(cond, "condition")) {
[17:43:48.973]                       if (!is.null(pattern)) {
[17:43:48.973]                         computeRestarts <- base::computeRestarts
[17:43:48.973]                         grepl <- base::grepl
[17:43:48.973]                         restarts <- computeRestarts(cond)
[17:43:48.973]                         for (restart in restarts) {
[17:43:48.973]                           name <- restart$name
[17:43:48.973]                           if (is.null(name)) 
[17:43:48.973]                             next
[17:43:48.973]                           if (!grepl(pattern, name)) 
[17:43:48.973]                             next
[17:43:48.973]                           invokeRestart(restart)
[17:43:48.973]                           muffled <- TRUE
[17:43:48.973]                           break
[17:43:48.973]                         }
[17:43:48.973]                       }
[17:43:48.973]                     }
[17:43:48.973]                     invisible(muffled)
[17:43:48.973]                   }
[17:43:48.973]                   muffleCondition(cond)
[17:43:48.973]                 })
[17:43:48.973]             }))
[17:43:48.973]             future::FutureResult(value = ...future.value$value, 
[17:43:48.973]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.973]                   ...future.rng), globalenv = if (FALSE) 
[17:43:48.973]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:48.973]                     ...future.globalenv.names))
[17:43:48.973]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:48.973]         }, condition = base::local({
[17:43:48.973]             c <- base::c
[17:43:48.973]             inherits <- base::inherits
[17:43:48.973]             invokeRestart <- base::invokeRestart
[17:43:48.973]             length <- base::length
[17:43:48.973]             list <- base::list
[17:43:48.973]             seq.int <- base::seq.int
[17:43:48.973]             signalCondition <- base::signalCondition
[17:43:48.973]             sys.calls <- base::sys.calls
[17:43:48.973]             `[[` <- base::`[[`
[17:43:48.973]             `+` <- base::`+`
[17:43:48.973]             `<<-` <- base::`<<-`
[17:43:48.973]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:48.973]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:48.973]                   3L)]
[17:43:48.973]             }
[17:43:48.973]             function(cond) {
[17:43:48.973]                 is_error <- inherits(cond, "error")
[17:43:48.973]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:48.973]                   NULL)
[17:43:48.973]                 if (is_error) {
[17:43:48.973]                   sessionInformation <- function() {
[17:43:48.973]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:48.973]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:48.973]                       search = base::search(), system = base::Sys.info())
[17:43:48.973]                   }
[17:43:48.973]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.973]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:48.973]                     cond$call), session = sessionInformation(), 
[17:43:48.973]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:48.973]                   signalCondition(cond)
[17:43:48.973]                 }
[17:43:48.973]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:48.973]                 "immediateCondition"))) {
[17:43:48.973]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:48.973]                   ...future.conditions[[length(...future.conditions) + 
[17:43:48.973]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:48.973]                   if (TRUE && !signal) {
[17:43:48.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.973]                     {
[17:43:48.973]                       inherits <- base::inherits
[17:43:48.973]                       invokeRestart <- base::invokeRestart
[17:43:48.973]                       is.null <- base::is.null
[17:43:48.973]                       muffled <- FALSE
[17:43:48.973]                       if (inherits(cond, "message")) {
[17:43:48.973]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.973]                         if (muffled) 
[17:43:48.973]                           invokeRestart("muffleMessage")
[17:43:48.973]                       }
[17:43:48.973]                       else if (inherits(cond, "warning")) {
[17:43:48.973]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.973]                         if (muffled) 
[17:43:48.973]                           invokeRestart("muffleWarning")
[17:43:48.973]                       }
[17:43:48.973]                       else if (inherits(cond, "condition")) {
[17:43:48.973]                         if (!is.null(pattern)) {
[17:43:48.973]                           computeRestarts <- base::computeRestarts
[17:43:48.973]                           grepl <- base::grepl
[17:43:48.973]                           restarts <- computeRestarts(cond)
[17:43:48.973]                           for (restart in restarts) {
[17:43:48.973]                             name <- restart$name
[17:43:48.973]                             if (is.null(name)) 
[17:43:48.973]                               next
[17:43:48.973]                             if (!grepl(pattern, name)) 
[17:43:48.973]                               next
[17:43:48.973]                             invokeRestart(restart)
[17:43:48.973]                             muffled <- TRUE
[17:43:48.973]                             break
[17:43:48.973]                           }
[17:43:48.973]                         }
[17:43:48.973]                       }
[17:43:48.973]                       invisible(muffled)
[17:43:48.973]                     }
[17:43:48.973]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.973]                   }
[17:43:48.973]                 }
[17:43:48.973]                 else {
[17:43:48.973]                   if (TRUE) {
[17:43:48.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:48.973]                     {
[17:43:48.973]                       inherits <- base::inherits
[17:43:48.973]                       invokeRestart <- base::invokeRestart
[17:43:48.973]                       is.null <- base::is.null
[17:43:48.973]                       muffled <- FALSE
[17:43:48.973]                       if (inherits(cond, "message")) {
[17:43:48.973]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:48.973]                         if (muffled) 
[17:43:48.973]                           invokeRestart("muffleMessage")
[17:43:48.973]                       }
[17:43:48.973]                       else if (inherits(cond, "warning")) {
[17:43:48.973]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:48.973]                         if (muffled) 
[17:43:48.973]                           invokeRestart("muffleWarning")
[17:43:48.973]                       }
[17:43:48.973]                       else if (inherits(cond, "condition")) {
[17:43:48.973]                         if (!is.null(pattern)) {
[17:43:48.973]                           computeRestarts <- base::computeRestarts
[17:43:48.973]                           grepl <- base::grepl
[17:43:48.973]                           restarts <- computeRestarts(cond)
[17:43:48.973]                           for (restart in restarts) {
[17:43:48.973]                             name <- restart$name
[17:43:48.973]                             if (is.null(name)) 
[17:43:48.973]                               next
[17:43:48.973]                             if (!grepl(pattern, name)) 
[17:43:48.973]                               next
[17:43:48.973]                             invokeRestart(restart)
[17:43:48.973]                             muffled <- TRUE
[17:43:48.973]                             break
[17:43:48.973]                           }
[17:43:48.973]                         }
[17:43:48.973]                       }
[17:43:48.973]                       invisible(muffled)
[17:43:48.973]                     }
[17:43:48.973]                     muffleCondition(cond, pattern = "^muffle")
[17:43:48.973]                   }
[17:43:48.973]                 }
[17:43:48.973]             }
[17:43:48.973]         }))
[17:43:48.973]     }, error = function(ex) {
[17:43:48.973]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:48.973]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:48.973]                 ...future.rng), started = ...future.startTime, 
[17:43:48.973]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:48.973]             version = "1.8"), class = "FutureResult")
[17:43:48.973]     }, finally = {
[17:43:48.973]         if (!identical(...future.workdir, getwd())) 
[17:43:48.973]             setwd(...future.workdir)
[17:43:48.973]         {
[17:43:48.973]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:48.973]                 ...future.oldOptions$nwarnings <- NULL
[17:43:48.973]             }
[17:43:48.973]             base::options(...future.oldOptions)
[17:43:48.973]             if (.Platform$OS.type == "windows") {
[17:43:48.973]                 old_names <- names(...future.oldEnvVars)
[17:43:48.973]                 envs <- base::Sys.getenv()
[17:43:48.973]                 names <- names(envs)
[17:43:48.973]                 common <- intersect(names, old_names)
[17:43:48.973]                 added <- setdiff(names, old_names)
[17:43:48.973]                 removed <- setdiff(old_names, names)
[17:43:48.973]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:48.973]                   envs[common]]
[17:43:48.973]                 NAMES <- toupper(changed)
[17:43:48.973]                 args <- list()
[17:43:48.973]                 for (kk in seq_along(NAMES)) {
[17:43:48.973]                   name <- changed[[kk]]
[17:43:48.973]                   NAME <- NAMES[[kk]]
[17:43:48.973]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.973]                     next
[17:43:48.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.973]                 }
[17:43:48.973]                 NAMES <- toupper(added)
[17:43:48.973]                 for (kk in seq_along(NAMES)) {
[17:43:48.973]                   name <- added[[kk]]
[17:43:48.973]                   NAME <- NAMES[[kk]]
[17:43:48.973]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.973]                     next
[17:43:48.973]                   args[[name]] <- ""
[17:43:48.973]                 }
[17:43:48.973]                 NAMES <- toupper(removed)
[17:43:48.973]                 for (kk in seq_along(NAMES)) {
[17:43:48.973]                   name <- removed[[kk]]
[17:43:48.973]                   NAME <- NAMES[[kk]]
[17:43:48.973]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:48.973]                     next
[17:43:48.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:48.973]                 }
[17:43:48.973]                 if (length(args) > 0) 
[17:43:48.973]                   base::do.call(base::Sys.setenv, args = args)
[17:43:48.973]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:48.973]             }
[17:43:48.973]             else {
[17:43:48.973]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:48.973]             }
[17:43:48.973]             {
[17:43:48.973]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:48.973]                   0L) {
[17:43:48.973]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:48.973]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:48.973]                   base::options(opts)
[17:43:48.973]                 }
[17:43:48.973]                 {
[17:43:48.973]                   {
[17:43:48.973]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:48.973]                     NULL
[17:43:48.973]                   }
[17:43:48.973]                   options(future.plan = NULL)
[17:43:48.973]                   if (is.na(NA_character_)) 
[17:43:48.973]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:48.973]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:48.973]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:48.973]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:48.973]                     envir = parent.frame()) 
[17:43:48.973]                   {
[17:43:48.973]                     if (is.function(workers)) 
[17:43:48.973]                       workers <- workers()
[17:43:48.973]                     workers <- structure(as.integer(workers), 
[17:43:48.973]                       class = class(workers))
[17:43:48.973]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:48.973]                       workers >= 1)
[17:43:48.973]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:48.973]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:48.973]                     }
[17:43:48.973]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:48.973]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:48.973]                       envir = envir)
[17:43:48.973]                     if (!future$lazy) 
[17:43:48.973]                       future <- run(future)
[17:43:48.973]                     invisible(future)
[17:43:48.973]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:48.973]                 }
[17:43:48.973]             }
[17:43:48.973]         }
[17:43:48.973]     })
[17:43:48.973]     if (TRUE) {
[17:43:48.973]         base::sink(type = "output", split = FALSE)
[17:43:48.973]         if (TRUE) {
[17:43:48.973]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:48.973]         }
[17:43:48.973]         else {
[17:43:48.973]             ...future.result["stdout"] <- base::list(NULL)
[17:43:48.973]         }
[17:43:48.973]         base::close(...future.stdout)
[17:43:48.973]         ...future.stdout <- NULL
[17:43:48.973]     }
[17:43:48.973]     ...future.result$conditions <- ...future.conditions
[17:43:48.973]     ...future.result$finished <- base::Sys.time()
[17:43:48.973]     ...future.result
[17:43:48.973] }
[17:43:48.977] MultisessionFuture started
[17:43:48.977] - Launch lazy future ... done
[17:43:48.977] run() for ‘MultisessionFuture’ ... done
[17:43:49.525] receiveMessageFromWorker() for ClusterFuture ...
[17:43:49.525] - Validating connection of MultisessionFuture
[17:43:49.525] - received message: FutureResult
[17:43:49.525] - Received FutureResult
[17:43:49.526] - Erased future from FutureRegistry
[17:43:49.526] result() for ClusterFuture ...
[17:43:49.526] - result already collected: FutureResult
[17:43:49.526] result() for ClusterFuture ... done
[17:43:49.526] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:49.526] A MultisessionFuture was resolved
- w/ exception ...
[17:43:49.526] getGlobalsAndPackages() ...
[17:43:49.526] Searching for globals...
[17:43:49.527] - globals found: [2] ‘list’, ‘stop’
[17:43:49.527] Searching for globals ... DONE
[17:43:49.527] Resolving globals: FALSE
[17:43:49.528] 
[17:43:49.528] 
[17:43:49.528] getGlobalsAndPackages() ... DONE
[17:43:49.528] run() for ‘Future’ ...
[17:43:49.528] - state: ‘created’
[17:43:49.528] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:49.543] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:49.543] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:49.543]   - Field: ‘node’
[17:43:49.543]   - Field: ‘label’
[17:43:49.543]   - Field: ‘local’
[17:43:49.543]   - Field: ‘owner’
[17:43:49.543]   - Field: ‘envir’
[17:43:49.544]   - Field: ‘workers’
[17:43:49.544]   - Field: ‘packages’
[17:43:49.544]   - Field: ‘gc’
[17:43:49.544]   - Field: ‘conditions’
[17:43:49.544]   - Field: ‘persistent’
[17:43:49.544]   - Field: ‘expr’
[17:43:49.544]   - Field: ‘uuid’
[17:43:49.544]   - Field: ‘seed’
[17:43:49.544]   - Field: ‘version’
[17:43:49.544]   - Field: ‘result’
[17:43:49.544]   - Field: ‘asynchronous’
[17:43:49.545]   - Field: ‘calls’
[17:43:49.545]   - Field: ‘globals’
[17:43:49.545]   - Field: ‘stdout’
[17:43:49.545]   - Field: ‘earlySignal’
[17:43:49.545]   - Field: ‘lazy’
[17:43:49.545]   - Field: ‘state’
[17:43:49.545] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:49.545] - Launch lazy future ...
[17:43:49.545] Packages needed by the future expression (n = 0): <none>
[17:43:49.546] Packages needed by future strategies (n = 0): <none>
[17:43:49.546] {
[17:43:49.546]     {
[17:43:49.546]         {
[17:43:49.546]             ...future.startTime <- base::Sys.time()
[17:43:49.546]             {
[17:43:49.546]                 {
[17:43:49.546]                   {
[17:43:49.546]                     {
[17:43:49.546]                       base::local({
[17:43:49.546]                         has_future <- base::requireNamespace("future", 
[17:43:49.546]                           quietly = TRUE)
[17:43:49.546]                         if (has_future) {
[17:43:49.546]                           ns <- base::getNamespace("future")
[17:43:49.546]                           version <- ns[[".package"]][["version"]]
[17:43:49.546]                           if (is.null(version)) 
[17:43:49.546]                             version <- utils::packageVersion("future")
[17:43:49.546]                         }
[17:43:49.546]                         else {
[17:43:49.546]                           version <- NULL
[17:43:49.546]                         }
[17:43:49.546]                         if (!has_future || version < "1.8.0") {
[17:43:49.546]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:49.546]                             "", base::R.version$version.string), 
[17:43:49.546]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:49.546]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:49.546]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:49.546]                               "release", "version")], collapse = " "), 
[17:43:49.546]                             hostname = base::Sys.info()[["nodename"]])
[17:43:49.546]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:49.546]                             info)
[17:43:49.546]                           info <- base::paste(info, collapse = "; ")
[17:43:49.546]                           if (!has_future) {
[17:43:49.546]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:49.546]                               info)
[17:43:49.546]                           }
[17:43:49.546]                           else {
[17:43:49.546]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:49.546]                               info, version)
[17:43:49.546]                           }
[17:43:49.546]                           base::stop(msg)
[17:43:49.546]                         }
[17:43:49.546]                       })
[17:43:49.546]                     }
[17:43:49.546]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:49.546]                     base::options(mc.cores = 1L)
[17:43:49.546]                   }
[17:43:49.546]                   options(future.plan = NULL)
[17:43:49.546]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:49.546]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:49.546]                 }
[17:43:49.546]                 ...future.workdir <- getwd()
[17:43:49.546]             }
[17:43:49.546]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:49.546]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:49.546]         }
[17:43:49.546]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:49.546]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:49.546]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:49.546]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:49.546]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:49.546]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:49.546]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:49.546]             base::names(...future.oldOptions))
[17:43:49.546]     }
[17:43:49.546]     if (FALSE) {
[17:43:49.546]     }
[17:43:49.546]     else {
[17:43:49.546]         if (TRUE) {
[17:43:49.546]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:49.546]                 open = "w")
[17:43:49.546]         }
[17:43:49.546]         else {
[17:43:49.546]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:49.546]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:49.546]         }
[17:43:49.546]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:49.546]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:49.546]             base::sink(type = "output", split = FALSE)
[17:43:49.546]             base::close(...future.stdout)
[17:43:49.546]         }, add = TRUE)
[17:43:49.546]     }
[17:43:49.546]     ...future.frame <- base::sys.nframe()
[17:43:49.546]     ...future.conditions <- base::list()
[17:43:49.546]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:49.546]     if (FALSE) {
[17:43:49.546]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:49.546]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:49.546]     }
[17:43:49.546]     ...future.result <- base::tryCatch({
[17:43:49.546]         base::withCallingHandlers({
[17:43:49.546]             ...future.value <- base::withVisible(base::local({
[17:43:49.546]                 ...future.makeSendCondition <- local({
[17:43:49.546]                   sendCondition <- NULL
[17:43:49.546]                   function(frame = 1L) {
[17:43:49.546]                     if (is.function(sendCondition)) 
[17:43:49.546]                       return(sendCondition)
[17:43:49.546]                     ns <- getNamespace("parallel")
[17:43:49.546]                     if (exists("sendData", mode = "function", 
[17:43:49.546]                       envir = ns)) {
[17:43:49.546]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:49.546]                         envir = ns)
[17:43:49.546]                       envir <- sys.frame(frame)
[17:43:49.546]                       master <- NULL
[17:43:49.546]                       while (!identical(envir, .GlobalEnv) && 
[17:43:49.546]                         !identical(envir, emptyenv())) {
[17:43:49.546]                         if (exists("master", mode = "list", envir = envir, 
[17:43:49.546]                           inherits = FALSE)) {
[17:43:49.546]                           master <- get("master", mode = "list", 
[17:43:49.546]                             envir = envir, inherits = FALSE)
[17:43:49.546]                           if (inherits(master, c("SOCKnode", 
[17:43:49.546]                             "SOCK0node"))) {
[17:43:49.546]                             sendCondition <<- function(cond) {
[17:43:49.546]                               data <- list(type = "VALUE", value = cond, 
[17:43:49.546]                                 success = TRUE)
[17:43:49.546]                               parallel_sendData(master, data)
[17:43:49.546]                             }
[17:43:49.546]                             return(sendCondition)
[17:43:49.546]                           }
[17:43:49.546]                         }
[17:43:49.546]                         frame <- frame + 1L
[17:43:49.546]                         envir <- sys.frame(frame)
[17:43:49.546]                       }
[17:43:49.546]                     }
[17:43:49.546]                     sendCondition <<- function(cond) NULL
[17:43:49.546]                   }
[17:43:49.546]                 })
[17:43:49.546]                 withCallingHandlers({
[17:43:49.546]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:43:49.546]                 }, immediateCondition = function(cond) {
[17:43:49.546]                   sendCondition <- ...future.makeSendCondition()
[17:43:49.546]                   sendCondition(cond)
[17:43:49.546]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:49.546]                   {
[17:43:49.546]                     inherits <- base::inherits
[17:43:49.546]                     invokeRestart <- base::invokeRestart
[17:43:49.546]                     is.null <- base::is.null
[17:43:49.546]                     muffled <- FALSE
[17:43:49.546]                     if (inherits(cond, "message")) {
[17:43:49.546]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:49.546]                       if (muffled) 
[17:43:49.546]                         invokeRestart("muffleMessage")
[17:43:49.546]                     }
[17:43:49.546]                     else if (inherits(cond, "warning")) {
[17:43:49.546]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:49.546]                       if (muffled) 
[17:43:49.546]                         invokeRestart("muffleWarning")
[17:43:49.546]                     }
[17:43:49.546]                     else if (inherits(cond, "condition")) {
[17:43:49.546]                       if (!is.null(pattern)) {
[17:43:49.546]                         computeRestarts <- base::computeRestarts
[17:43:49.546]                         grepl <- base::grepl
[17:43:49.546]                         restarts <- computeRestarts(cond)
[17:43:49.546]                         for (restart in restarts) {
[17:43:49.546]                           name <- restart$name
[17:43:49.546]                           if (is.null(name)) 
[17:43:49.546]                             next
[17:43:49.546]                           if (!grepl(pattern, name)) 
[17:43:49.546]                             next
[17:43:49.546]                           invokeRestart(restart)
[17:43:49.546]                           muffled <- TRUE
[17:43:49.546]                           break
[17:43:49.546]                         }
[17:43:49.546]                       }
[17:43:49.546]                     }
[17:43:49.546]                     invisible(muffled)
[17:43:49.546]                   }
[17:43:49.546]                   muffleCondition(cond)
[17:43:49.546]                 })
[17:43:49.546]             }))
[17:43:49.546]             future::FutureResult(value = ...future.value$value, 
[17:43:49.546]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:49.546]                   ...future.rng), globalenv = if (FALSE) 
[17:43:49.546]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:49.546]                     ...future.globalenv.names))
[17:43:49.546]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:49.546]         }, condition = base::local({
[17:43:49.546]             c <- base::c
[17:43:49.546]             inherits <- base::inherits
[17:43:49.546]             invokeRestart <- base::invokeRestart
[17:43:49.546]             length <- base::length
[17:43:49.546]             list <- base::list
[17:43:49.546]             seq.int <- base::seq.int
[17:43:49.546]             signalCondition <- base::signalCondition
[17:43:49.546]             sys.calls <- base::sys.calls
[17:43:49.546]             `[[` <- base::`[[`
[17:43:49.546]             `+` <- base::`+`
[17:43:49.546]             `<<-` <- base::`<<-`
[17:43:49.546]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:49.546]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:49.546]                   3L)]
[17:43:49.546]             }
[17:43:49.546]             function(cond) {
[17:43:49.546]                 is_error <- inherits(cond, "error")
[17:43:49.546]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:49.546]                   NULL)
[17:43:49.546]                 if (is_error) {
[17:43:49.546]                   sessionInformation <- function() {
[17:43:49.546]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:49.546]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:49.546]                       search = base::search(), system = base::Sys.info())
[17:43:49.546]                   }
[17:43:49.546]                   ...future.conditions[[length(...future.conditions) + 
[17:43:49.546]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:49.546]                     cond$call), session = sessionInformation(), 
[17:43:49.546]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:49.546]                   signalCondition(cond)
[17:43:49.546]                 }
[17:43:49.546]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:49.546]                 "immediateCondition"))) {
[17:43:49.546]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:49.546]                   ...future.conditions[[length(...future.conditions) + 
[17:43:49.546]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:49.546]                   if (TRUE && !signal) {
[17:43:49.546]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:49.546]                     {
[17:43:49.546]                       inherits <- base::inherits
[17:43:49.546]                       invokeRestart <- base::invokeRestart
[17:43:49.546]                       is.null <- base::is.null
[17:43:49.546]                       muffled <- FALSE
[17:43:49.546]                       if (inherits(cond, "message")) {
[17:43:49.546]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:49.546]                         if (muffled) 
[17:43:49.546]                           invokeRestart("muffleMessage")
[17:43:49.546]                       }
[17:43:49.546]                       else if (inherits(cond, "warning")) {
[17:43:49.546]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:49.546]                         if (muffled) 
[17:43:49.546]                           invokeRestart("muffleWarning")
[17:43:49.546]                       }
[17:43:49.546]                       else if (inherits(cond, "condition")) {
[17:43:49.546]                         if (!is.null(pattern)) {
[17:43:49.546]                           computeRestarts <- base::computeRestarts
[17:43:49.546]                           grepl <- base::grepl
[17:43:49.546]                           restarts <- computeRestarts(cond)
[17:43:49.546]                           for (restart in restarts) {
[17:43:49.546]                             name <- restart$name
[17:43:49.546]                             if (is.null(name)) 
[17:43:49.546]                               next
[17:43:49.546]                             if (!grepl(pattern, name)) 
[17:43:49.546]                               next
[17:43:49.546]                             invokeRestart(restart)
[17:43:49.546]                             muffled <- TRUE
[17:43:49.546]                             break
[17:43:49.546]                           }
[17:43:49.546]                         }
[17:43:49.546]                       }
[17:43:49.546]                       invisible(muffled)
[17:43:49.546]                     }
[17:43:49.546]                     muffleCondition(cond, pattern = "^muffle")
[17:43:49.546]                   }
[17:43:49.546]                 }
[17:43:49.546]                 else {
[17:43:49.546]                   if (TRUE) {
[17:43:49.546]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:49.546]                     {
[17:43:49.546]                       inherits <- base::inherits
[17:43:49.546]                       invokeRestart <- base::invokeRestart
[17:43:49.546]                       is.null <- base::is.null
[17:43:49.546]                       muffled <- FALSE
[17:43:49.546]                       if (inherits(cond, "message")) {
[17:43:49.546]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:49.546]                         if (muffled) 
[17:43:49.546]                           invokeRestart("muffleMessage")
[17:43:49.546]                       }
[17:43:49.546]                       else if (inherits(cond, "warning")) {
[17:43:49.546]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:49.546]                         if (muffled) 
[17:43:49.546]                           invokeRestart("muffleWarning")
[17:43:49.546]                       }
[17:43:49.546]                       else if (inherits(cond, "condition")) {
[17:43:49.546]                         if (!is.null(pattern)) {
[17:43:49.546]                           computeRestarts <- base::computeRestarts
[17:43:49.546]                           grepl <- base::grepl
[17:43:49.546]                           restarts <- computeRestarts(cond)
[17:43:49.546]                           for (restart in restarts) {
[17:43:49.546]                             name <- restart$name
[17:43:49.546]                             if (is.null(name)) 
[17:43:49.546]                               next
[17:43:49.546]                             if (!grepl(pattern, name)) 
[17:43:49.546]                               next
[17:43:49.546]                             invokeRestart(restart)
[17:43:49.546]                             muffled <- TRUE
[17:43:49.546]                             break
[17:43:49.546]                           }
[17:43:49.546]                         }
[17:43:49.546]                       }
[17:43:49.546]                       invisible(muffled)
[17:43:49.546]                     }
[17:43:49.546]                     muffleCondition(cond, pattern = "^muffle")
[17:43:49.546]                   }
[17:43:49.546]                 }
[17:43:49.546]             }
[17:43:49.546]         }))
[17:43:49.546]     }, error = function(ex) {
[17:43:49.546]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:49.546]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:49.546]                 ...future.rng), started = ...future.startTime, 
[17:43:49.546]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:49.546]             version = "1.8"), class = "FutureResult")
[17:43:49.546]     }, finally = {
[17:43:49.546]         if (!identical(...future.workdir, getwd())) 
[17:43:49.546]             setwd(...future.workdir)
[17:43:49.546]         {
[17:43:49.546]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:49.546]                 ...future.oldOptions$nwarnings <- NULL
[17:43:49.546]             }
[17:43:49.546]             base::options(...future.oldOptions)
[17:43:49.546]             if (.Platform$OS.type == "windows") {
[17:43:49.546]                 old_names <- names(...future.oldEnvVars)
[17:43:49.546]                 envs <- base::Sys.getenv()
[17:43:49.546]                 names <- names(envs)
[17:43:49.546]                 common <- intersect(names, old_names)
[17:43:49.546]                 added <- setdiff(names, old_names)
[17:43:49.546]                 removed <- setdiff(old_names, names)
[17:43:49.546]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:49.546]                   envs[common]]
[17:43:49.546]                 NAMES <- toupper(changed)
[17:43:49.546]                 args <- list()
[17:43:49.546]                 for (kk in seq_along(NAMES)) {
[17:43:49.546]                   name <- changed[[kk]]
[17:43:49.546]                   NAME <- NAMES[[kk]]
[17:43:49.546]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:49.546]                     next
[17:43:49.546]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:49.546]                 }
[17:43:49.546]                 NAMES <- toupper(added)
[17:43:49.546]                 for (kk in seq_along(NAMES)) {
[17:43:49.546]                   name <- added[[kk]]
[17:43:49.546]                   NAME <- NAMES[[kk]]
[17:43:49.546]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:49.546]                     next
[17:43:49.546]                   args[[name]] <- ""
[17:43:49.546]                 }
[17:43:49.546]                 NAMES <- toupper(removed)
[17:43:49.546]                 for (kk in seq_along(NAMES)) {
[17:43:49.546]                   name <- removed[[kk]]
[17:43:49.546]                   NAME <- NAMES[[kk]]
[17:43:49.546]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:49.546]                     next
[17:43:49.546]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:49.546]                 }
[17:43:49.546]                 if (length(args) > 0) 
[17:43:49.546]                   base::do.call(base::Sys.setenv, args = args)
[17:43:49.546]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:49.546]             }
[17:43:49.546]             else {
[17:43:49.546]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:49.546]             }
[17:43:49.546]             {
[17:43:49.546]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:49.546]                   0L) {
[17:43:49.546]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:49.546]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:49.546]                   base::options(opts)
[17:43:49.546]                 }
[17:43:49.546]                 {
[17:43:49.546]                   {
[17:43:49.546]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:49.546]                     NULL
[17:43:49.546]                   }
[17:43:49.546]                   options(future.plan = NULL)
[17:43:49.546]                   if (is.na(NA_character_)) 
[17:43:49.546]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:49.546]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:49.546]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:49.546]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:49.546]                     envir = parent.frame()) 
[17:43:49.546]                   {
[17:43:49.546]                     if (is.function(workers)) 
[17:43:49.546]                       workers <- workers()
[17:43:49.546]                     workers <- structure(as.integer(workers), 
[17:43:49.546]                       class = class(workers))
[17:43:49.546]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:49.546]                       workers >= 1)
[17:43:49.546]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:49.546]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:49.546]                     }
[17:43:49.546]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:49.546]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:49.546]                       envir = envir)
[17:43:49.546]                     if (!future$lazy) 
[17:43:49.546]                       future <- run(future)
[17:43:49.546]                     invisible(future)
[17:43:49.546]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:49.546]                 }
[17:43:49.546]             }
[17:43:49.546]         }
[17:43:49.546]     })
[17:43:49.546]     if (TRUE) {
[17:43:49.546]         base::sink(type = "output", split = FALSE)
[17:43:49.546]         if (TRUE) {
[17:43:49.546]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:49.546]         }
[17:43:49.546]         else {
[17:43:49.546]             ...future.result["stdout"] <- base::list(NULL)
[17:43:49.546]         }
[17:43:49.546]         base::close(...future.stdout)
[17:43:49.546]         ...future.stdout <- NULL
[17:43:49.546]     }
[17:43:49.546]     ...future.result$conditions <- ...future.conditions
[17:43:49.546]     ...future.result$finished <- base::Sys.time()
[17:43:49.546]     ...future.result
[17:43:49.546] }
[17:43:49.549] MultisessionFuture started
[17:43:49.549] - Launch lazy future ... done
[17:43:49.549] run() for ‘MultisessionFuture’ ... done
[17:43:49.596] receiveMessageFromWorker() for ClusterFuture ...
[17:43:49.596] - Validating connection of MultisessionFuture
[17:43:49.597] - received message: FutureResult
[17:43:49.597] - Received FutureResult
[17:43:49.597] - Erased future from FutureRegistry
[17:43:49.597] result() for ClusterFuture ...
[17:43:49.597] - result already collected: FutureResult
[17:43:49.598] result() for ClusterFuture ... done
[17:43:49.598] signalConditions() ...
[17:43:49.598]  - include = ‘immediateCondition’
[17:43:49.598]  - exclude = 
[17:43:49.598]  - resignal = FALSE
[17:43:49.598]  - Number of conditions: 1
[17:43:49.598] signalConditions() ... done
[17:43:49.598] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:49.598] A MultisessionFuture was resolved
[17:43:49.598] getGlobalsAndPackages() ...
[17:43:49.598] Searching for globals...
[17:43:49.599] - globals found: [2] ‘list’, ‘stop’
[17:43:49.599] Searching for globals ... DONE
[17:43:49.599] Resolving globals: FALSE
[17:43:49.600] 
[17:43:49.600] 
[17:43:49.600] getGlobalsAndPackages() ... DONE
[17:43:49.600] run() for ‘Future’ ...
[17:43:49.600] - state: ‘created’
[17:43:49.601] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:49.615] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:49.615] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:49.615]   - Field: ‘node’
[17:43:49.616]   - Field: ‘label’
[17:43:49.616]   - Field: ‘local’
[17:43:49.616]   - Field: ‘owner’
[17:43:49.616]   - Field: ‘envir’
[17:43:49.616]   - Field: ‘workers’
[17:43:49.616]   - Field: ‘packages’
[17:43:49.616]   - Field: ‘gc’
[17:43:49.616]   - Field: ‘conditions’
[17:43:49.616]   - Field: ‘persistent’
[17:43:49.616]   - Field: ‘expr’
[17:43:49.617]   - Field: ‘uuid’
[17:43:49.617]   - Field: ‘seed’
[17:43:49.617]   - Field: ‘version’
[17:43:49.617]   - Field: ‘result’
[17:43:49.617]   - Field: ‘asynchronous’
[17:43:49.617]   - Field: ‘calls’
[17:43:49.617]   - Field: ‘globals’
[17:43:49.617]   - Field: ‘stdout’
[17:43:49.617]   - Field: ‘earlySignal’
[17:43:49.617]   - Field: ‘lazy’
[17:43:49.617]   - Field: ‘state’
[17:43:49.617] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:49.618] - Launch lazy future ...
[17:43:49.618] Packages needed by the future expression (n = 0): <none>
[17:43:49.618] Packages needed by future strategies (n = 0): <none>
[17:43:49.618] {
[17:43:49.618]     {
[17:43:49.618]         {
[17:43:49.618]             ...future.startTime <- base::Sys.time()
[17:43:49.618]             {
[17:43:49.618]                 {
[17:43:49.618]                   {
[17:43:49.618]                     {
[17:43:49.618]                       base::local({
[17:43:49.618]                         has_future <- base::requireNamespace("future", 
[17:43:49.618]                           quietly = TRUE)
[17:43:49.618]                         if (has_future) {
[17:43:49.618]                           ns <- base::getNamespace("future")
[17:43:49.618]                           version <- ns[[".package"]][["version"]]
[17:43:49.618]                           if (is.null(version)) 
[17:43:49.618]                             version <- utils::packageVersion("future")
[17:43:49.618]                         }
[17:43:49.618]                         else {
[17:43:49.618]                           version <- NULL
[17:43:49.618]                         }
[17:43:49.618]                         if (!has_future || version < "1.8.0") {
[17:43:49.618]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:49.618]                             "", base::R.version$version.string), 
[17:43:49.618]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:49.618]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:49.618]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:49.618]                               "release", "version")], collapse = " "), 
[17:43:49.618]                             hostname = base::Sys.info()[["nodename"]])
[17:43:49.618]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:49.618]                             info)
[17:43:49.618]                           info <- base::paste(info, collapse = "; ")
[17:43:49.618]                           if (!has_future) {
[17:43:49.618]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:49.618]                               info)
[17:43:49.618]                           }
[17:43:49.618]                           else {
[17:43:49.618]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:49.618]                               info, version)
[17:43:49.618]                           }
[17:43:49.618]                           base::stop(msg)
[17:43:49.618]                         }
[17:43:49.618]                       })
[17:43:49.618]                     }
[17:43:49.618]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:49.618]                     base::options(mc.cores = 1L)
[17:43:49.618]                   }
[17:43:49.618]                   options(future.plan = NULL)
[17:43:49.618]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:49.618]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:49.618]                 }
[17:43:49.618]                 ...future.workdir <- getwd()
[17:43:49.618]             }
[17:43:49.618]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:49.618]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:49.618]         }
[17:43:49.618]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:49.618]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:49.618]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:49.618]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:49.618]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:49.618]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:49.618]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:49.618]             base::names(...future.oldOptions))
[17:43:49.618]     }
[17:43:49.618]     if (FALSE) {
[17:43:49.618]     }
[17:43:49.618]     else {
[17:43:49.618]         if (TRUE) {
[17:43:49.618]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:49.618]                 open = "w")
[17:43:49.618]         }
[17:43:49.618]         else {
[17:43:49.618]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:49.618]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:49.618]         }
[17:43:49.618]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:49.618]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:49.618]             base::sink(type = "output", split = FALSE)
[17:43:49.618]             base::close(...future.stdout)
[17:43:49.618]         }, add = TRUE)
[17:43:49.618]     }
[17:43:49.618]     ...future.frame <- base::sys.nframe()
[17:43:49.618]     ...future.conditions <- base::list()
[17:43:49.618]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:49.618]     if (FALSE) {
[17:43:49.618]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:49.618]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:49.618]     }
[17:43:49.618]     ...future.result <- base::tryCatch({
[17:43:49.618]         base::withCallingHandlers({
[17:43:49.618]             ...future.value <- base::withVisible(base::local({
[17:43:49.618]                 ...future.makeSendCondition <- local({
[17:43:49.618]                   sendCondition <- NULL
[17:43:49.618]                   function(frame = 1L) {
[17:43:49.618]                     if (is.function(sendCondition)) 
[17:43:49.618]                       return(sendCondition)
[17:43:49.618]                     ns <- getNamespace("parallel")
[17:43:49.618]                     if (exists("sendData", mode = "function", 
[17:43:49.618]                       envir = ns)) {
[17:43:49.618]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:49.618]                         envir = ns)
[17:43:49.618]                       envir <- sys.frame(frame)
[17:43:49.618]                       master <- NULL
[17:43:49.618]                       while (!identical(envir, .GlobalEnv) && 
[17:43:49.618]                         !identical(envir, emptyenv())) {
[17:43:49.618]                         if (exists("master", mode = "list", envir = envir, 
[17:43:49.618]                           inherits = FALSE)) {
[17:43:49.618]                           master <- get("master", mode = "list", 
[17:43:49.618]                             envir = envir, inherits = FALSE)
[17:43:49.618]                           if (inherits(master, c("SOCKnode", 
[17:43:49.618]                             "SOCK0node"))) {
[17:43:49.618]                             sendCondition <<- function(cond) {
[17:43:49.618]                               data <- list(type = "VALUE", value = cond, 
[17:43:49.618]                                 success = TRUE)
[17:43:49.618]                               parallel_sendData(master, data)
[17:43:49.618]                             }
[17:43:49.618]                             return(sendCondition)
[17:43:49.618]                           }
[17:43:49.618]                         }
[17:43:49.618]                         frame <- frame + 1L
[17:43:49.618]                         envir <- sys.frame(frame)
[17:43:49.618]                       }
[17:43:49.618]                     }
[17:43:49.618]                     sendCondition <<- function(cond) NULL
[17:43:49.618]                   }
[17:43:49.618]                 })
[17:43:49.618]                 withCallingHandlers({
[17:43:49.618]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:43:49.618]                 }, immediateCondition = function(cond) {
[17:43:49.618]                   sendCondition <- ...future.makeSendCondition()
[17:43:49.618]                   sendCondition(cond)
[17:43:49.618]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:49.618]                   {
[17:43:49.618]                     inherits <- base::inherits
[17:43:49.618]                     invokeRestart <- base::invokeRestart
[17:43:49.618]                     is.null <- base::is.null
[17:43:49.618]                     muffled <- FALSE
[17:43:49.618]                     if (inherits(cond, "message")) {
[17:43:49.618]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:49.618]                       if (muffled) 
[17:43:49.618]                         invokeRestart("muffleMessage")
[17:43:49.618]                     }
[17:43:49.618]                     else if (inherits(cond, "warning")) {
[17:43:49.618]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:49.618]                       if (muffled) 
[17:43:49.618]                         invokeRestart("muffleWarning")
[17:43:49.618]                     }
[17:43:49.618]                     else if (inherits(cond, "condition")) {
[17:43:49.618]                       if (!is.null(pattern)) {
[17:43:49.618]                         computeRestarts <- base::computeRestarts
[17:43:49.618]                         grepl <- base::grepl
[17:43:49.618]                         restarts <- computeRestarts(cond)
[17:43:49.618]                         for (restart in restarts) {
[17:43:49.618]                           name <- restart$name
[17:43:49.618]                           if (is.null(name)) 
[17:43:49.618]                             next
[17:43:49.618]                           if (!grepl(pattern, name)) 
[17:43:49.618]                             next
[17:43:49.618]                           invokeRestart(restart)
[17:43:49.618]                           muffled <- TRUE
[17:43:49.618]                           break
[17:43:49.618]                         }
[17:43:49.618]                       }
[17:43:49.618]                     }
[17:43:49.618]                     invisible(muffled)
[17:43:49.618]                   }
[17:43:49.618]                   muffleCondition(cond)
[17:43:49.618]                 })
[17:43:49.618]             }))
[17:43:49.618]             future::FutureResult(value = ...future.value$value, 
[17:43:49.618]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:49.618]                   ...future.rng), globalenv = if (FALSE) 
[17:43:49.618]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:49.618]                     ...future.globalenv.names))
[17:43:49.618]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:49.618]         }, condition = base::local({
[17:43:49.618]             c <- base::c
[17:43:49.618]             inherits <- base::inherits
[17:43:49.618]             invokeRestart <- base::invokeRestart
[17:43:49.618]             length <- base::length
[17:43:49.618]             list <- base::list
[17:43:49.618]             seq.int <- base::seq.int
[17:43:49.618]             signalCondition <- base::signalCondition
[17:43:49.618]             sys.calls <- base::sys.calls
[17:43:49.618]             `[[` <- base::`[[`
[17:43:49.618]             `+` <- base::`+`
[17:43:49.618]             `<<-` <- base::`<<-`
[17:43:49.618]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:49.618]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:49.618]                   3L)]
[17:43:49.618]             }
[17:43:49.618]             function(cond) {
[17:43:49.618]                 is_error <- inherits(cond, "error")
[17:43:49.618]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:49.618]                   NULL)
[17:43:49.618]                 if (is_error) {
[17:43:49.618]                   sessionInformation <- function() {
[17:43:49.618]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:49.618]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:49.618]                       search = base::search(), system = base::Sys.info())
[17:43:49.618]                   }
[17:43:49.618]                   ...future.conditions[[length(...future.conditions) + 
[17:43:49.618]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:49.618]                     cond$call), session = sessionInformation(), 
[17:43:49.618]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:49.618]                   signalCondition(cond)
[17:43:49.618]                 }
[17:43:49.618]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:49.618]                 "immediateCondition"))) {
[17:43:49.618]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:49.618]                   ...future.conditions[[length(...future.conditions) + 
[17:43:49.618]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:49.618]                   if (TRUE && !signal) {
[17:43:49.618]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:49.618]                     {
[17:43:49.618]                       inherits <- base::inherits
[17:43:49.618]                       invokeRestart <- base::invokeRestart
[17:43:49.618]                       is.null <- base::is.null
[17:43:49.618]                       muffled <- FALSE
[17:43:49.618]                       if (inherits(cond, "message")) {
[17:43:49.618]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:49.618]                         if (muffled) 
[17:43:49.618]                           invokeRestart("muffleMessage")
[17:43:49.618]                       }
[17:43:49.618]                       else if (inherits(cond, "warning")) {
[17:43:49.618]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:49.618]                         if (muffled) 
[17:43:49.618]                           invokeRestart("muffleWarning")
[17:43:49.618]                       }
[17:43:49.618]                       else if (inherits(cond, "condition")) {
[17:43:49.618]                         if (!is.null(pattern)) {
[17:43:49.618]                           computeRestarts <- base::computeRestarts
[17:43:49.618]                           grepl <- base::grepl
[17:43:49.618]                           restarts <- computeRestarts(cond)
[17:43:49.618]                           for (restart in restarts) {
[17:43:49.618]                             name <- restart$name
[17:43:49.618]                             if (is.null(name)) 
[17:43:49.618]                               next
[17:43:49.618]                             if (!grepl(pattern, name)) 
[17:43:49.618]                               next
[17:43:49.618]                             invokeRestart(restart)
[17:43:49.618]                             muffled <- TRUE
[17:43:49.618]                             break
[17:43:49.618]                           }
[17:43:49.618]                         }
[17:43:49.618]                       }
[17:43:49.618]                       invisible(muffled)
[17:43:49.618]                     }
[17:43:49.618]                     muffleCondition(cond, pattern = "^muffle")
[17:43:49.618]                   }
[17:43:49.618]                 }
[17:43:49.618]                 else {
[17:43:49.618]                   if (TRUE) {
[17:43:49.618]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:49.618]                     {
[17:43:49.618]                       inherits <- base::inherits
[17:43:49.618]                       invokeRestart <- base::invokeRestart
[17:43:49.618]                       is.null <- base::is.null
[17:43:49.618]                       muffled <- FALSE
[17:43:49.618]                       if (inherits(cond, "message")) {
[17:43:49.618]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:49.618]                         if (muffled) 
[17:43:49.618]                           invokeRestart("muffleMessage")
[17:43:49.618]                       }
[17:43:49.618]                       else if (inherits(cond, "warning")) {
[17:43:49.618]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:49.618]                         if (muffled) 
[17:43:49.618]                           invokeRestart("muffleWarning")
[17:43:49.618]                       }
[17:43:49.618]                       else if (inherits(cond, "condition")) {
[17:43:49.618]                         if (!is.null(pattern)) {
[17:43:49.618]                           computeRestarts <- base::computeRestarts
[17:43:49.618]                           grepl <- base::grepl
[17:43:49.618]                           restarts <- computeRestarts(cond)
[17:43:49.618]                           for (restart in restarts) {
[17:43:49.618]                             name <- restart$name
[17:43:49.618]                             if (is.null(name)) 
[17:43:49.618]                               next
[17:43:49.618]                             if (!grepl(pattern, name)) 
[17:43:49.618]                               next
[17:43:49.618]                             invokeRestart(restart)
[17:43:49.618]                             muffled <- TRUE
[17:43:49.618]                             break
[17:43:49.618]                           }
[17:43:49.618]                         }
[17:43:49.618]                       }
[17:43:49.618]                       invisible(muffled)
[17:43:49.618]                     }
[17:43:49.618]                     muffleCondition(cond, pattern = "^muffle")
[17:43:49.618]                   }
[17:43:49.618]                 }
[17:43:49.618]             }
[17:43:49.618]         }))
[17:43:49.618]     }, error = function(ex) {
[17:43:49.618]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:49.618]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:49.618]                 ...future.rng), started = ...future.startTime, 
[17:43:49.618]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:49.618]             version = "1.8"), class = "FutureResult")
[17:43:49.618]     }, finally = {
[17:43:49.618]         if (!identical(...future.workdir, getwd())) 
[17:43:49.618]             setwd(...future.workdir)
[17:43:49.618]         {
[17:43:49.618]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:49.618]                 ...future.oldOptions$nwarnings <- NULL
[17:43:49.618]             }
[17:43:49.618]             base::options(...future.oldOptions)
[17:43:49.618]             if (.Platform$OS.type == "windows") {
[17:43:49.618]                 old_names <- names(...future.oldEnvVars)
[17:43:49.618]                 envs <- base::Sys.getenv()
[17:43:49.618]                 names <- names(envs)
[17:43:49.618]                 common <- intersect(names, old_names)
[17:43:49.618]                 added <- setdiff(names, old_names)
[17:43:49.618]                 removed <- setdiff(old_names, names)
[17:43:49.618]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:49.618]                   envs[common]]
[17:43:49.618]                 NAMES <- toupper(changed)
[17:43:49.618]                 args <- list()
[17:43:49.618]                 for (kk in seq_along(NAMES)) {
[17:43:49.618]                   name <- changed[[kk]]
[17:43:49.618]                   NAME <- NAMES[[kk]]
[17:43:49.618]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:49.618]                     next
[17:43:49.618]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:49.618]                 }
[17:43:49.618]                 NAMES <- toupper(added)
[17:43:49.618]                 for (kk in seq_along(NAMES)) {
[17:43:49.618]                   name <- added[[kk]]
[17:43:49.618]                   NAME <- NAMES[[kk]]
[17:43:49.618]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:49.618]                     next
[17:43:49.618]                   args[[name]] <- ""
[17:43:49.618]                 }
[17:43:49.618]                 NAMES <- toupper(removed)
[17:43:49.618]                 for (kk in seq_along(NAMES)) {
[17:43:49.618]                   name <- removed[[kk]]
[17:43:49.618]                   NAME <- NAMES[[kk]]
[17:43:49.618]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:49.618]                     next
[17:43:49.618]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:49.618]                 }
[17:43:49.618]                 if (length(args) > 0) 
[17:43:49.618]                   base::do.call(base::Sys.setenv, args = args)
[17:43:49.618]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:49.618]             }
[17:43:49.618]             else {
[17:43:49.618]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:49.618]             }
[17:43:49.618]             {
[17:43:49.618]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:49.618]                   0L) {
[17:43:49.618]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:49.618]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:49.618]                   base::options(opts)
[17:43:49.618]                 }
[17:43:49.618]                 {
[17:43:49.618]                   {
[17:43:49.618]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:49.618]                     NULL
[17:43:49.618]                   }
[17:43:49.618]                   options(future.plan = NULL)
[17:43:49.618]                   if (is.na(NA_character_)) 
[17:43:49.618]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:49.618]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:49.618]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:49.618]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:49.618]                     envir = parent.frame()) 
[17:43:49.618]                   {
[17:43:49.618]                     if (is.function(workers)) 
[17:43:49.618]                       workers <- workers()
[17:43:49.618]                     workers <- structure(as.integer(workers), 
[17:43:49.618]                       class = class(workers))
[17:43:49.618]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:49.618]                       workers >= 1)
[17:43:49.618]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:49.618]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:49.618]                     }
[17:43:49.618]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:49.618]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:49.618]                       envir = envir)
[17:43:49.618]                     if (!future$lazy) 
[17:43:49.618]                       future <- run(future)
[17:43:49.618]                     invisible(future)
[17:43:49.618]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:49.618]                 }
[17:43:49.618]             }
[17:43:49.618]         }
[17:43:49.618]     })
[17:43:49.618]     if (TRUE) {
[17:43:49.618]         base::sink(type = "output", split = FALSE)
[17:43:49.618]         if (TRUE) {
[17:43:49.618]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:49.618]         }
[17:43:49.618]         else {
[17:43:49.618]             ...future.result["stdout"] <- base::list(NULL)
[17:43:49.618]         }
[17:43:49.618]         base::close(...future.stdout)
[17:43:49.618]         ...future.stdout <- NULL
[17:43:49.618]     }
[17:43:49.618]     ...future.result$conditions <- ...future.conditions
[17:43:49.618]     ...future.result$finished <- base::Sys.time()
[17:43:49.618]     ...future.result
[17:43:49.618] }
[17:43:49.622] MultisessionFuture started
[17:43:49.622] - Launch lazy future ... done
[17:43:49.622] run() for ‘MultisessionFuture’ ... done
[17:43:49.668] receiveMessageFromWorker() for ClusterFuture ...
[17:43:49.668] - Validating connection of MultisessionFuture
[17:43:49.669] - received message: FutureResult
[17:43:49.669] - Received FutureResult
[17:43:49.669] - Erased future from FutureRegistry
[17:43:49.669] result() for ClusterFuture ...
[17:43:49.670] - result already collected: FutureResult
[17:43:49.670] result() for ClusterFuture ... done
[17:43:49.670] signalConditions() ...
[17:43:49.670]  - include = ‘immediateCondition’
[17:43:49.670]  - exclude = 
[17:43:49.670]  - resignal = FALSE
[17:43:49.670]  - Number of conditions: 1
[17:43:49.670] signalConditions() ... done
[17:43:49.670] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:49.670] A MultisessionFuture was resolved
- result = TRUE, recursive = 0 ... DONE
- result = TRUE, recursive = 1 ...
[17:43:49.671] getGlobalsAndPackages() ...
[17:43:49.671] Searching for globals...
[17:43:49.672] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:43:49.672] Searching for globals ... DONE
[17:43:49.672] Resolving globals: FALSE
[17:43:49.673] 
[17:43:49.673] 
[17:43:49.673] getGlobalsAndPackages() ... DONE
[17:43:49.673] run() for ‘Future’ ...
[17:43:49.673] - state: ‘created’
[17:43:49.673] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:49.688] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:49.688] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:49.688]   - Field: ‘node’
[17:43:49.688]   - Field: ‘label’
[17:43:49.688]   - Field: ‘local’
[17:43:49.689]   - Field: ‘owner’
[17:43:49.689]   - Field: ‘envir’
[17:43:49.689]   - Field: ‘workers’
[17:43:49.689]   - Field: ‘packages’
[17:43:49.689]   - Field: ‘gc’
[17:43:49.689]   - Field: ‘conditions’
[17:43:49.689]   - Field: ‘persistent’
[17:43:49.689]   - Field: ‘expr’
[17:43:49.689]   - Field: ‘uuid’
[17:43:49.689]   - Field: ‘seed’
[17:43:49.689]   - Field: ‘version’
[17:43:49.690]   - Field: ‘result’
[17:43:49.690]   - Field: ‘asynchronous’
[17:43:49.690]   - Field: ‘calls’
[17:43:49.690]   - Field: ‘globals’
[17:43:49.690]   - Field: ‘stdout’
[17:43:49.690]   - Field: ‘earlySignal’
[17:43:49.690]   - Field: ‘lazy’
[17:43:49.690]   - Field: ‘state’
[17:43:49.690] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:49.690] - Launch lazy future ...
[17:43:49.691] Packages needed by the future expression (n = 0): <none>
[17:43:49.691] Packages needed by future strategies (n = 0): <none>
[17:43:49.691] {
[17:43:49.691]     {
[17:43:49.691]         {
[17:43:49.691]             ...future.startTime <- base::Sys.time()
[17:43:49.691]             {
[17:43:49.691]                 {
[17:43:49.691]                   {
[17:43:49.691]                     {
[17:43:49.691]                       base::local({
[17:43:49.691]                         has_future <- base::requireNamespace("future", 
[17:43:49.691]                           quietly = TRUE)
[17:43:49.691]                         if (has_future) {
[17:43:49.691]                           ns <- base::getNamespace("future")
[17:43:49.691]                           version <- ns[[".package"]][["version"]]
[17:43:49.691]                           if (is.null(version)) 
[17:43:49.691]                             version <- utils::packageVersion("future")
[17:43:49.691]                         }
[17:43:49.691]                         else {
[17:43:49.691]                           version <- NULL
[17:43:49.691]                         }
[17:43:49.691]                         if (!has_future || version < "1.8.0") {
[17:43:49.691]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:49.691]                             "", base::R.version$version.string), 
[17:43:49.691]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:49.691]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:49.691]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:49.691]                               "release", "version")], collapse = " "), 
[17:43:49.691]                             hostname = base::Sys.info()[["nodename"]])
[17:43:49.691]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:49.691]                             info)
[17:43:49.691]                           info <- base::paste(info, collapse = "; ")
[17:43:49.691]                           if (!has_future) {
[17:43:49.691]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:49.691]                               info)
[17:43:49.691]                           }
[17:43:49.691]                           else {
[17:43:49.691]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:49.691]                               info, version)
[17:43:49.691]                           }
[17:43:49.691]                           base::stop(msg)
[17:43:49.691]                         }
[17:43:49.691]                       })
[17:43:49.691]                     }
[17:43:49.691]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:49.691]                     base::options(mc.cores = 1L)
[17:43:49.691]                   }
[17:43:49.691]                   options(future.plan = NULL)
[17:43:49.691]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:49.691]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:49.691]                 }
[17:43:49.691]                 ...future.workdir <- getwd()
[17:43:49.691]             }
[17:43:49.691]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:49.691]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:49.691]         }
[17:43:49.691]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:49.691]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:49.691]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:49.691]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:49.691]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:49.691]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:49.691]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:49.691]             base::names(...future.oldOptions))
[17:43:49.691]     }
[17:43:49.691]     if (FALSE) {
[17:43:49.691]     }
[17:43:49.691]     else {
[17:43:49.691]         if (TRUE) {
[17:43:49.691]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:49.691]                 open = "w")
[17:43:49.691]         }
[17:43:49.691]         else {
[17:43:49.691]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:49.691]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:49.691]         }
[17:43:49.691]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:49.691]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:49.691]             base::sink(type = "output", split = FALSE)
[17:43:49.691]             base::close(...future.stdout)
[17:43:49.691]         }, add = TRUE)
[17:43:49.691]     }
[17:43:49.691]     ...future.frame <- base::sys.nframe()
[17:43:49.691]     ...future.conditions <- base::list()
[17:43:49.691]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:49.691]     if (FALSE) {
[17:43:49.691]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:49.691]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:49.691]     }
[17:43:49.691]     ...future.result <- base::tryCatch({
[17:43:49.691]         base::withCallingHandlers({
[17:43:49.691]             ...future.value <- base::withVisible(base::local({
[17:43:49.691]                 ...future.makeSendCondition <- local({
[17:43:49.691]                   sendCondition <- NULL
[17:43:49.691]                   function(frame = 1L) {
[17:43:49.691]                     if (is.function(sendCondition)) 
[17:43:49.691]                       return(sendCondition)
[17:43:49.691]                     ns <- getNamespace("parallel")
[17:43:49.691]                     if (exists("sendData", mode = "function", 
[17:43:49.691]                       envir = ns)) {
[17:43:49.691]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:49.691]                         envir = ns)
[17:43:49.691]                       envir <- sys.frame(frame)
[17:43:49.691]                       master <- NULL
[17:43:49.691]                       while (!identical(envir, .GlobalEnv) && 
[17:43:49.691]                         !identical(envir, emptyenv())) {
[17:43:49.691]                         if (exists("master", mode = "list", envir = envir, 
[17:43:49.691]                           inherits = FALSE)) {
[17:43:49.691]                           master <- get("master", mode = "list", 
[17:43:49.691]                             envir = envir, inherits = FALSE)
[17:43:49.691]                           if (inherits(master, c("SOCKnode", 
[17:43:49.691]                             "SOCK0node"))) {
[17:43:49.691]                             sendCondition <<- function(cond) {
[17:43:49.691]                               data <- list(type = "VALUE", value = cond, 
[17:43:49.691]                                 success = TRUE)
[17:43:49.691]                               parallel_sendData(master, data)
[17:43:49.691]                             }
[17:43:49.691]                             return(sendCondition)
[17:43:49.691]                           }
[17:43:49.691]                         }
[17:43:49.691]                         frame <- frame + 1L
[17:43:49.691]                         envir <- sys.frame(frame)
[17:43:49.691]                       }
[17:43:49.691]                     }
[17:43:49.691]                     sendCondition <<- function(cond) NULL
[17:43:49.691]                   }
[17:43:49.691]                 })
[17:43:49.691]                 withCallingHandlers({
[17:43:49.691]                   {
[17:43:49.691]                     Sys.sleep(0.5)
[17:43:49.691]                     list(a = 1, b = 42L)
[17:43:49.691]                   }
[17:43:49.691]                 }, immediateCondition = function(cond) {
[17:43:49.691]                   sendCondition <- ...future.makeSendCondition()
[17:43:49.691]                   sendCondition(cond)
[17:43:49.691]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:49.691]                   {
[17:43:49.691]                     inherits <- base::inherits
[17:43:49.691]                     invokeRestart <- base::invokeRestart
[17:43:49.691]                     is.null <- base::is.null
[17:43:49.691]                     muffled <- FALSE
[17:43:49.691]                     if (inherits(cond, "message")) {
[17:43:49.691]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:49.691]                       if (muffled) 
[17:43:49.691]                         invokeRestart("muffleMessage")
[17:43:49.691]                     }
[17:43:49.691]                     else if (inherits(cond, "warning")) {
[17:43:49.691]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:49.691]                       if (muffled) 
[17:43:49.691]                         invokeRestart("muffleWarning")
[17:43:49.691]                     }
[17:43:49.691]                     else if (inherits(cond, "condition")) {
[17:43:49.691]                       if (!is.null(pattern)) {
[17:43:49.691]                         computeRestarts <- base::computeRestarts
[17:43:49.691]                         grepl <- base::grepl
[17:43:49.691]                         restarts <- computeRestarts(cond)
[17:43:49.691]                         for (restart in restarts) {
[17:43:49.691]                           name <- restart$name
[17:43:49.691]                           if (is.null(name)) 
[17:43:49.691]                             next
[17:43:49.691]                           if (!grepl(pattern, name)) 
[17:43:49.691]                             next
[17:43:49.691]                           invokeRestart(restart)
[17:43:49.691]                           muffled <- TRUE
[17:43:49.691]                           break
[17:43:49.691]                         }
[17:43:49.691]                       }
[17:43:49.691]                     }
[17:43:49.691]                     invisible(muffled)
[17:43:49.691]                   }
[17:43:49.691]                   muffleCondition(cond)
[17:43:49.691]                 })
[17:43:49.691]             }))
[17:43:49.691]             future::FutureResult(value = ...future.value$value, 
[17:43:49.691]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:49.691]                   ...future.rng), globalenv = if (FALSE) 
[17:43:49.691]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:49.691]                     ...future.globalenv.names))
[17:43:49.691]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:49.691]         }, condition = base::local({
[17:43:49.691]             c <- base::c
[17:43:49.691]             inherits <- base::inherits
[17:43:49.691]             invokeRestart <- base::invokeRestart
[17:43:49.691]             length <- base::length
[17:43:49.691]             list <- base::list
[17:43:49.691]             seq.int <- base::seq.int
[17:43:49.691]             signalCondition <- base::signalCondition
[17:43:49.691]             sys.calls <- base::sys.calls
[17:43:49.691]             `[[` <- base::`[[`
[17:43:49.691]             `+` <- base::`+`
[17:43:49.691]             `<<-` <- base::`<<-`
[17:43:49.691]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:49.691]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:49.691]                   3L)]
[17:43:49.691]             }
[17:43:49.691]             function(cond) {
[17:43:49.691]                 is_error <- inherits(cond, "error")
[17:43:49.691]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:49.691]                   NULL)
[17:43:49.691]                 if (is_error) {
[17:43:49.691]                   sessionInformation <- function() {
[17:43:49.691]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:49.691]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:49.691]                       search = base::search(), system = base::Sys.info())
[17:43:49.691]                   }
[17:43:49.691]                   ...future.conditions[[length(...future.conditions) + 
[17:43:49.691]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:49.691]                     cond$call), session = sessionInformation(), 
[17:43:49.691]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:49.691]                   signalCondition(cond)
[17:43:49.691]                 }
[17:43:49.691]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:49.691]                 "immediateCondition"))) {
[17:43:49.691]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:49.691]                   ...future.conditions[[length(...future.conditions) + 
[17:43:49.691]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:49.691]                   if (TRUE && !signal) {
[17:43:49.691]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:49.691]                     {
[17:43:49.691]                       inherits <- base::inherits
[17:43:49.691]                       invokeRestart <- base::invokeRestart
[17:43:49.691]                       is.null <- base::is.null
[17:43:49.691]                       muffled <- FALSE
[17:43:49.691]                       if (inherits(cond, "message")) {
[17:43:49.691]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:49.691]                         if (muffled) 
[17:43:49.691]                           invokeRestart("muffleMessage")
[17:43:49.691]                       }
[17:43:49.691]                       else if (inherits(cond, "warning")) {
[17:43:49.691]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:49.691]                         if (muffled) 
[17:43:49.691]                           invokeRestart("muffleWarning")
[17:43:49.691]                       }
[17:43:49.691]                       else if (inherits(cond, "condition")) {
[17:43:49.691]                         if (!is.null(pattern)) {
[17:43:49.691]                           computeRestarts <- base::computeRestarts
[17:43:49.691]                           grepl <- base::grepl
[17:43:49.691]                           restarts <- computeRestarts(cond)
[17:43:49.691]                           for (restart in restarts) {
[17:43:49.691]                             name <- restart$name
[17:43:49.691]                             if (is.null(name)) 
[17:43:49.691]                               next
[17:43:49.691]                             if (!grepl(pattern, name)) 
[17:43:49.691]                               next
[17:43:49.691]                             invokeRestart(restart)
[17:43:49.691]                             muffled <- TRUE
[17:43:49.691]                             break
[17:43:49.691]                           }
[17:43:49.691]                         }
[17:43:49.691]                       }
[17:43:49.691]                       invisible(muffled)
[17:43:49.691]                     }
[17:43:49.691]                     muffleCondition(cond, pattern = "^muffle")
[17:43:49.691]                   }
[17:43:49.691]                 }
[17:43:49.691]                 else {
[17:43:49.691]                   if (TRUE) {
[17:43:49.691]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:49.691]                     {
[17:43:49.691]                       inherits <- base::inherits
[17:43:49.691]                       invokeRestart <- base::invokeRestart
[17:43:49.691]                       is.null <- base::is.null
[17:43:49.691]                       muffled <- FALSE
[17:43:49.691]                       if (inherits(cond, "message")) {
[17:43:49.691]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:49.691]                         if (muffled) 
[17:43:49.691]                           invokeRestart("muffleMessage")
[17:43:49.691]                       }
[17:43:49.691]                       else if (inherits(cond, "warning")) {
[17:43:49.691]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:49.691]                         if (muffled) 
[17:43:49.691]                           invokeRestart("muffleWarning")
[17:43:49.691]                       }
[17:43:49.691]                       else if (inherits(cond, "condition")) {
[17:43:49.691]                         if (!is.null(pattern)) {
[17:43:49.691]                           computeRestarts <- base::computeRestarts
[17:43:49.691]                           grepl <- base::grepl
[17:43:49.691]                           restarts <- computeRestarts(cond)
[17:43:49.691]                           for (restart in restarts) {
[17:43:49.691]                             name <- restart$name
[17:43:49.691]                             if (is.null(name)) 
[17:43:49.691]                               next
[17:43:49.691]                             if (!grepl(pattern, name)) 
[17:43:49.691]                               next
[17:43:49.691]                             invokeRestart(restart)
[17:43:49.691]                             muffled <- TRUE
[17:43:49.691]                             break
[17:43:49.691]                           }
[17:43:49.691]                         }
[17:43:49.691]                       }
[17:43:49.691]                       invisible(muffled)
[17:43:49.691]                     }
[17:43:49.691]                     muffleCondition(cond, pattern = "^muffle")
[17:43:49.691]                   }
[17:43:49.691]                 }
[17:43:49.691]             }
[17:43:49.691]         }))
[17:43:49.691]     }, error = function(ex) {
[17:43:49.691]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:49.691]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:49.691]                 ...future.rng), started = ...future.startTime, 
[17:43:49.691]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:49.691]             version = "1.8"), class = "FutureResult")
[17:43:49.691]     }, finally = {
[17:43:49.691]         if (!identical(...future.workdir, getwd())) 
[17:43:49.691]             setwd(...future.workdir)
[17:43:49.691]         {
[17:43:49.691]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:49.691]                 ...future.oldOptions$nwarnings <- NULL
[17:43:49.691]             }
[17:43:49.691]             base::options(...future.oldOptions)
[17:43:49.691]             if (.Platform$OS.type == "windows") {
[17:43:49.691]                 old_names <- names(...future.oldEnvVars)
[17:43:49.691]                 envs <- base::Sys.getenv()
[17:43:49.691]                 names <- names(envs)
[17:43:49.691]                 common <- intersect(names, old_names)
[17:43:49.691]                 added <- setdiff(names, old_names)
[17:43:49.691]                 removed <- setdiff(old_names, names)
[17:43:49.691]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:49.691]                   envs[common]]
[17:43:49.691]                 NAMES <- toupper(changed)
[17:43:49.691]                 args <- list()
[17:43:49.691]                 for (kk in seq_along(NAMES)) {
[17:43:49.691]                   name <- changed[[kk]]
[17:43:49.691]                   NAME <- NAMES[[kk]]
[17:43:49.691]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:49.691]                     next
[17:43:49.691]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:49.691]                 }
[17:43:49.691]                 NAMES <- toupper(added)
[17:43:49.691]                 for (kk in seq_along(NAMES)) {
[17:43:49.691]                   name <- added[[kk]]
[17:43:49.691]                   NAME <- NAMES[[kk]]
[17:43:49.691]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:49.691]                     next
[17:43:49.691]                   args[[name]] <- ""
[17:43:49.691]                 }
[17:43:49.691]                 NAMES <- toupper(removed)
[17:43:49.691]                 for (kk in seq_along(NAMES)) {
[17:43:49.691]                   name <- removed[[kk]]
[17:43:49.691]                   NAME <- NAMES[[kk]]
[17:43:49.691]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:49.691]                     next
[17:43:49.691]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:49.691]                 }
[17:43:49.691]                 if (length(args) > 0) 
[17:43:49.691]                   base::do.call(base::Sys.setenv, args = args)
[17:43:49.691]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:49.691]             }
[17:43:49.691]             else {
[17:43:49.691]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:49.691]             }
[17:43:49.691]             {
[17:43:49.691]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:49.691]                   0L) {
[17:43:49.691]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:49.691]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:49.691]                   base::options(opts)
[17:43:49.691]                 }
[17:43:49.691]                 {
[17:43:49.691]                   {
[17:43:49.691]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:49.691]                     NULL
[17:43:49.691]                   }
[17:43:49.691]                   options(future.plan = NULL)
[17:43:49.691]                   if (is.na(NA_character_)) 
[17:43:49.691]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:49.691]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:49.691]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:49.691]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:49.691]                     envir = parent.frame()) 
[17:43:49.691]                   {
[17:43:49.691]                     if (is.function(workers)) 
[17:43:49.691]                       workers <- workers()
[17:43:49.691]                     workers <- structure(as.integer(workers), 
[17:43:49.691]                       class = class(workers))
[17:43:49.691]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:49.691]                       workers >= 1)
[17:43:49.691]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:49.691]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:49.691]                     }
[17:43:49.691]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:49.691]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:49.691]                       envir = envir)
[17:43:49.691]                     if (!future$lazy) 
[17:43:49.691]                       future <- run(future)
[17:43:49.691]                     invisible(future)
[17:43:49.691]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:49.691]                 }
[17:43:49.691]             }
[17:43:49.691]         }
[17:43:49.691]     })
[17:43:49.691]     if (TRUE) {
[17:43:49.691]         base::sink(type = "output", split = FALSE)
[17:43:49.691]         if (TRUE) {
[17:43:49.691]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:49.691]         }
[17:43:49.691]         else {
[17:43:49.691]             ...future.result["stdout"] <- base::list(NULL)
[17:43:49.691]         }
[17:43:49.691]         base::close(...future.stdout)
[17:43:49.691]         ...future.stdout <- NULL
[17:43:49.691]     }
[17:43:49.691]     ...future.result$conditions <- ...future.conditions
[17:43:49.691]     ...future.result$finished <- base::Sys.time()
[17:43:49.691]     ...future.result
[17:43:49.691] }
[17:43:49.695] MultisessionFuture started
[17:43:49.695] - Launch lazy future ... done
[17:43:49.695] run() for ‘MultisessionFuture’ ... done
[17:43:50.241] receiveMessageFromWorker() for ClusterFuture ...
[17:43:50.242] - Validating connection of MultisessionFuture
[17:43:50.242] - received message: FutureResult
[17:43:50.242] - Received FutureResult
[17:43:50.242] - Erased future from FutureRegistry
[17:43:50.242] result() for ClusterFuture ...
[17:43:50.242] - result already collected: FutureResult
[17:43:50.242] result() for ClusterFuture ... done
[17:43:50.242] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:50.243] resolve() on list ...
[17:43:50.243]  recursive: 0
[17:43:50.243]  length: 2
[17:43:50.243]  elements: ‘a’, ‘b’
[17:43:50.245]  length: 1 (resolved future 1)
[17:43:50.245]  length: 0 (resolved future 2)
[17:43:50.246] resolve() on list ... DONE
[17:43:50.246] A MultisessionFuture was resolved (and resolved itself)
[17:43:50.246] getGlobalsAndPackages() ...
[17:43:50.246] Searching for globals...
[17:43:50.247] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:43:50.247] Searching for globals ... DONE
[17:43:50.248] Resolving globals: FALSE
[17:43:50.248] 
[17:43:50.248] 
[17:43:50.248] getGlobalsAndPackages() ... DONE
[17:43:50.248] run() for ‘Future’ ...
[17:43:50.249] - state: ‘created’
[17:43:50.249] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:50.263] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:50.263] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:50.263]   - Field: ‘node’
[17:43:50.263]   - Field: ‘label’
[17:43:50.263]   - Field: ‘local’
[17:43:50.264]   - Field: ‘owner’
[17:43:50.264]   - Field: ‘envir’
[17:43:50.264]   - Field: ‘workers’
[17:43:50.264]   - Field: ‘packages’
[17:43:50.264]   - Field: ‘gc’
[17:43:50.264]   - Field: ‘conditions’
[17:43:50.264]   - Field: ‘persistent’
[17:43:50.264]   - Field: ‘expr’
[17:43:50.264]   - Field: ‘uuid’
[17:43:50.264]   - Field: ‘seed’
[17:43:50.264]   - Field: ‘version’
[17:43:50.265]   - Field: ‘result’
[17:43:50.265]   - Field: ‘asynchronous’
[17:43:50.265]   - Field: ‘calls’
[17:43:50.265]   - Field: ‘globals’
[17:43:50.265]   - Field: ‘stdout’
[17:43:50.265]   - Field: ‘earlySignal’
[17:43:50.265]   - Field: ‘lazy’
[17:43:50.265]   - Field: ‘state’
[17:43:50.265] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:50.265] - Launch lazy future ...
[17:43:50.266] Packages needed by the future expression (n = 0): <none>
[17:43:50.266] Packages needed by future strategies (n = 0): <none>
[17:43:50.266] {
[17:43:50.266]     {
[17:43:50.266]         {
[17:43:50.266]             ...future.startTime <- base::Sys.time()
[17:43:50.266]             {
[17:43:50.266]                 {
[17:43:50.266]                   {
[17:43:50.266]                     {
[17:43:50.266]                       base::local({
[17:43:50.266]                         has_future <- base::requireNamespace("future", 
[17:43:50.266]                           quietly = TRUE)
[17:43:50.266]                         if (has_future) {
[17:43:50.266]                           ns <- base::getNamespace("future")
[17:43:50.266]                           version <- ns[[".package"]][["version"]]
[17:43:50.266]                           if (is.null(version)) 
[17:43:50.266]                             version <- utils::packageVersion("future")
[17:43:50.266]                         }
[17:43:50.266]                         else {
[17:43:50.266]                           version <- NULL
[17:43:50.266]                         }
[17:43:50.266]                         if (!has_future || version < "1.8.0") {
[17:43:50.266]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:50.266]                             "", base::R.version$version.string), 
[17:43:50.266]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:50.266]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:50.266]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:50.266]                               "release", "version")], collapse = " "), 
[17:43:50.266]                             hostname = base::Sys.info()[["nodename"]])
[17:43:50.266]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:50.266]                             info)
[17:43:50.266]                           info <- base::paste(info, collapse = "; ")
[17:43:50.266]                           if (!has_future) {
[17:43:50.266]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:50.266]                               info)
[17:43:50.266]                           }
[17:43:50.266]                           else {
[17:43:50.266]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:50.266]                               info, version)
[17:43:50.266]                           }
[17:43:50.266]                           base::stop(msg)
[17:43:50.266]                         }
[17:43:50.266]                       })
[17:43:50.266]                     }
[17:43:50.266]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:50.266]                     base::options(mc.cores = 1L)
[17:43:50.266]                   }
[17:43:50.266]                   options(future.plan = NULL)
[17:43:50.266]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:50.266]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:50.266]                 }
[17:43:50.266]                 ...future.workdir <- getwd()
[17:43:50.266]             }
[17:43:50.266]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:50.266]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:50.266]         }
[17:43:50.266]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:50.266]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:50.266]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:50.266]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:50.266]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:50.266]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:50.266]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:50.266]             base::names(...future.oldOptions))
[17:43:50.266]     }
[17:43:50.266]     if (FALSE) {
[17:43:50.266]     }
[17:43:50.266]     else {
[17:43:50.266]         if (TRUE) {
[17:43:50.266]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:50.266]                 open = "w")
[17:43:50.266]         }
[17:43:50.266]         else {
[17:43:50.266]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:50.266]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:50.266]         }
[17:43:50.266]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:50.266]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:50.266]             base::sink(type = "output", split = FALSE)
[17:43:50.266]             base::close(...future.stdout)
[17:43:50.266]         }, add = TRUE)
[17:43:50.266]     }
[17:43:50.266]     ...future.frame <- base::sys.nframe()
[17:43:50.266]     ...future.conditions <- base::list()
[17:43:50.266]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:50.266]     if (FALSE) {
[17:43:50.266]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:50.266]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:50.266]     }
[17:43:50.266]     ...future.result <- base::tryCatch({
[17:43:50.266]         base::withCallingHandlers({
[17:43:50.266]             ...future.value <- base::withVisible(base::local({
[17:43:50.266]                 ...future.makeSendCondition <- local({
[17:43:50.266]                   sendCondition <- NULL
[17:43:50.266]                   function(frame = 1L) {
[17:43:50.266]                     if (is.function(sendCondition)) 
[17:43:50.266]                       return(sendCondition)
[17:43:50.266]                     ns <- getNamespace("parallel")
[17:43:50.266]                     if (exists("sendData", mode = "function", 
[17:43:50.266]                       envir = ns)) {
[17:43:50.266]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:50.266]                         envir = ns)
[17:43:50.266]                       envir <- sys.frame(frame)
[17:43:50.266]                       master <- NULL
[17:43:50.266]                       while (!identical(envir, .GlobalEnv) && 
[17:43:50.266]                         !identical(envir, emptyenv())) {
[17:43:50.266]                         if (exists("master", mode = "list", envir = envir, 
[17:43:50.266]                           inherits = FALSE)) {
[17:43:50.266]                           master <- get("master", mode = "list", 
[17:43:50.266]                             envir = envir, inherits = FALSE)
[17:43:50.266]                           if (inherits(master, c("SOCKnode", 
[17:43:50.266]                             "SOCK0node"))) {
[17:43:50.266]                             sendCondition <<- function(cond) {
[17:43:50.266]                               data <- list(type = "VALUE", value = cond, 
[17:43:50.266]                                 success = TRUE)
[17:43:50.266]                               parallel_sendData(master, data)
[17:43:50.266]                             }
[17:43:50.266]                             return(sendCondition)
[17:43:50.266]                           }
[17:43:50.266]                         }
[17:43:50.266]                         frame <- frame + 1L
[17:43:50.266]                         envir <- sys.frame(frame)
[17:43:50.266]                       }
[17:43:50.266]                     }
[17:43:50.266]                     sendCondition <<- function(cond) NULL
[17:43:50.266]                   }
[17:43:50.266]                 })
[17:43:50.266]                 withCallingHandlers({
[17:43:50.266]                   {
[17:43:50.266]                     Sys.sleep(0.5)
[17:43:50.266]                     list(a = 1, b = 42L)
[17:43:50.266]                   }
[17:43:50.266]                 }, immediateCondition = function(cond) {
[17:43:50.266]                   sendCondition <- ...future.makeSendCondition()
[17:43:50.266]                   sendCondition(cond)
[17:43:50.266]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.266]                   {
[17:43:50.266]                     inherits <- base::inherits
[17:43:50.266]                     invokeRestart <- base::invokeRestart
[17:43:50.266]                     is.null <- base::is.null
[17:43:50.266]                     muffled <- FALSE
[17:43:50.266]                     if (inherits(cond, "message")) {
[17:43:50.266]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:50.266]                       if (muffled) 
[17:43:50.266]                         invokeRestart("muffleMessage")
[17:43:50.266]                     }
[17:43:50.266]                     else if (inherits(cond, "warning")) {
[17:43:50.266]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:50.266]                       if (muffled) 
[17:43:50.266]                         invokeRestart("muffleWarning")
[17:43:50.266]                     }
[17:43:50.266]                     else if (inherits(cond, "condition")) {
[17:43:50.266]                       if (!is.null(pattern)) {
[17:43:50.266]                         computeRestarts <- base::computeRestarts
[17:43:50.266]                         grepl <- base::grepl
[17:43:50.266]                         restarts <- computeRestarts(cond)
[17:43:50.266]                         for (restart in restarts) {
[17:43:50.266]                           name <- restart$name
[17:43:50.266]                           if (is.null(name)) 
[17:43:50.266]                             next
[17:43:50.266]                           if (!grepl(pattern, name)) 
[17:43:50.266]                             next
[17:43:50.266]                           invokeRestart(restart)
[17:43:50.266]                           muffled <- TRUE
[17:43:50.266]                           break
[17:43:50.266]                         }
[17:43:50.266]                       }
[17:43:50.266]                     }
[17:43:50.266]                     invisible(muffled)
[17:43:50.266]                   }
[17:43:50.266]                   muffleCondition(cond)
[17:43:50.266]                 })
[17:43:50.266]             }))
[17:43:50.266]             future::FutureResult(value = ...future.value$value, 
[17:43:50.266]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:50.266]                   ...future.rng), globalenv = if (FALSE) 
[17:43:50.266]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:50.266]                     ...future.globalenv.names))
[17:43:50.266]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:50.266]         }, condition = base::local({
[17:43:50.266]             c <- base::c
[17:43:50.266]             inherits <- base::inherits
[17:43:50.266]             invokeRestart <- base::invokeRestart
[17:43:50.266]             length <- base::length
[17:43:50.266]             list <- base::list
[17:43:50.266]             seq.int <- base::seq.int
[17:43:50.266]             signalCondition <- base::signalCondition
[17:43:50.266]             sys.calls <- base::sys.calls
[17:43:50.266]             `[[` <- base::`[[`
[17:43:50.266]             `+` <- base::`+`
[17:43:50.266]             `<<-` <- base::`<<-`
[17:43:50.266]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:50.266]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:50.266]                   3L)]
[17:43:50.266]             }
[17:43:50.266]             function(cond) {
[17:43:50.266]                 is_error <- inherits(cond, "error")
[17:43:50.266]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:50.266]                   NULL)
[17:43:50.266]                 if (is_error) {
[17:43:50.266]                   sessionInformation <- function() {
[17:43:50.266]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:50.266]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:50.266]                       search = base::search(), system = base::Sys.info())
[17:43:50.266]                   }
[17:43:50.266]                   ...future.conditions[[length(...future.conditions) + 
[17:43:50.266]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:50.266]                     cond$call), session = sessionInformation(), 
[17:43:50.266]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:50.266]                   signalCondition(cond)
[17:43:50.266]                 }
[17:43:50.266]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:50.266]                 "immediateCondition"))) {
[17:43:50.266]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:50.266]                   ...future.conditions[[length(...future.conditions) + 
[17:43:50.266]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:50.266]                   if (TRUE && !signal) {
[17:43:50.266]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.266]                     {
[17:43:50.266]                       inherits <- base::inherits
[17:43:50.266]                       invokeRestart <- base::invokeRestart
[17:43:50.266]                       is.null <- base::is.null
[17:43:50.266]                       muffled <- FALSE
[17:43:50.266]                       if (inherits(cond, "message")) {
[17:43:50.266]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:50.266]                         if (muffled) 
[17:43:50.266]                           invokeRestart("muffleMessage")
[17:43:50.266]                       }
[17:43:50.266]                       else if (inherits(cond, "warning")) {
[17:43:50.266]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:50.266]                         if (muffled) 
[17:43:50.266]                           invokeRestart("muffleWarning")
[17:43:50.266]                       }
[17:43:50.266]                       else if (inherits(cond, "condition")) {
[17:43:50.266]                         if (!is.null(pattern)) {
[17:43:50.266]                           computeRestarts <- base::computeRestarts
[17:43:50.266]                           grepl <- base::grepl
[17:43:50.266]                           restarts <- computeRestarts(cond)
[17:43:50.266]                           for (restart in restarts) {
[17:43:50.266]                             name <- restart$name
[17:43:50.266]                             if (is.null(name)) 
[17:43:50.266]                               next
[17:43:50.266]                             if (!grepl(pattern, name)) 
[17:43:50.266]                               next
[17:43:50.266]                             invokeRestart(restart)
[17:43:50.266]                             muffled <- TRUE
[17:43:50.266]                             break
[17:43:50.266]                           }
[17:43:50.266]                         }
[17:43:50.266]                       }
[17:43:50.266]                       invisible(muffled)
[17:43:50.266]                     }
[17:43:50.266]                     muffleCondition(cond, pattern = "^muffle")
[17:43:50.266]                   }
[17:43:50.266]                 }
[17:43:50.266]                 else {
[17:43:50.266]                   if (TRUE) {
[17:43:50.266]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.266]                     {
[17:43:50.266]                       inherits <- base::inherits
[17:43:50.266]                       invokeRestart <- base::invokeRestart
[17:43:50.266]                       is.null <- base::is.null
[17:43:50.266]                       muffled <- FALSE
[17:43:50.266]                       if (inherits(cond, "message")) {
[17:43:50.266]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:50.266]                         if (muffled) 
[17:43:50.266]                           invokeRestart("muffleMessage")
[17:43:50.266]                       }
[17:43:50.266]                       else if (inherits(cond, "warning")) {
[17:43:50.266]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:50.266]                         if (muffled) 
[17:43:50.266]                           invokeRestart("muffleWarning")
[17:43:50.266]                       }
[17:43:50.266]                       else if (inherits(cond, "condition")) {
[17:43:50.266]                         if (!is.null(pattern)) {
[17:43:50.266]                           computeRestarts <- base::computeRestarts
[17:43:50.266]                           grepl <- base::grepl
[17:43:50.266]                           restarts <- computeRestarts(cond)
[17:43:50.266]                           for (restart in restarts) {
[17:43:50.266]                             name <- restart$name
[17:43:50.266]                             if (is.null(name)) 
[17:43:50.266]                               next
[17:43:50.266]                             if (!grepl(pattern, name)) 
[17:43:50.266]                               next
[17:43:50.266]                             invokeRestart(restart)
[17:43:50.266]                             muffled <- TRUE
[17:43:50.266]                             break
[17:43:50.266]                           }
[17:43:50.266]                         }
[17:43:50.266]                       }
[17:43:50.266]                       invisible(muffled)
[17:43:50.266]                     }
[17:43:50.266]                     muffleCondition(cond, pattern = "^muffle")
[17:43:50.266]                   }
[17:43:50.266]                 }
[17:43:50.266]             }
[17:43:50.266]         }))
[17:43:50.266]     }, error = function(ex) {
[17:43:50.266]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:50.266]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:50.266]                 ...future.rng), started = ...future.startTime, 
[17:43:50.266]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:50.266]             version = "1.8"), class = "FutureResult")
[17:43:50.266]     }, finally = {
[17:43:50.266]         if (!identical(...future.workdir, getwd())) 
[17:43:50.266]             setwd(...future.workdir)
[17:43:50.266]         {
[17:43:50.266]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:50.266]                 ...future.oldOptions$nwarnings <- NULL
[17:43:50.266]             }
[17:43:50.266]             base::options(...future.oldOptions)
[17:43:50.266]             if (.Platform$OS.type == "windows") {
[17:43:50.266]                 old_names <- names(...future.oldEnvVars)
[17:43:50.266]                 envs <- base::Sys.getenv()
[17:43:50.266]                 names <- names(envs)
[17:43:50.266]                 common <- intersect(names, old_names)
[17:43:50.266]                 added <- setdiff(names, old_names)
[17:43:50.266]                 removed <- setdiff(old_names, names)
[17:43:50.266]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:50.266]                   envs[common]]
[17:43:50.266]                 NAMES <- toupper(changed)
[17:43:50.266]                 args <- list()
[17:43:50.266]                 for (kk in seq_along(NAMES)) {
[17:43:50.266]                   name <- changed[[kk]]
[17:43:50.266]                   NAME <- NAMES[[kk]]
[17:43:50.266]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.266]                     next
[17:43:50.266]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:50.266]                 }
[17:43:50.266]                 NAMES <- toupper(added)
[17:43:50.266]                 for (kk in seq_along(NAMES)) {
[17:43:50.266]                   name <- added[[kk]]
[17:43:50.266]                   NAME <- NAMES[[kk]]
[17:43:50.266]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.266]                     next
[17:43:50.266]                   args[[name]] <- ""
[17:43:50.266]                 }
[17:43:50.266]                 NAMES <- toupper(removed)
[17:43:50.266]                 for (kk in seq_along(NAMES)) {
[17:43:50.266]                   name <- removed[[kk]]
[17:43:50.266]                   NAME <- NAMES[[kk]]
[17:43:50.266]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.266]                     next
[17:43:50.266]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:50.266]                 }
[17:43:50.266]                 if (length(args) > 0) 
[17:43:50.266]                   base::do.call(base::Sys.setenv, args = args)
[17:43:50.266]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:50.266]             }
[17:43:50.266]             else {
[17:43:50.266]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:50.266]             }
[17:43:50.266]             {
[17:43:50.266]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:50.266]                   0L) {
[17:43:50.266]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:50.266]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:50.266]                   base::options(opts)
[17:43:50.266]                 }
[17:43:50.266]                 {
[17:43:50.266]                   {
[17:43:50.266]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:50.266]                     NULL
[17:43:50.266]                   }
[17:43:50.266]                   options(future.plan = NULL)
[17:43:50.266]                   if (is.na(NA_character_)) 
[17:43:50.266]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:50.266]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:50.266]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:50.266]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:50.266]                     envir = parent.frame()) 
[17:43:50.266]                   {
[17:43:50.266]                     if (is.function(workers)) 
[17:43:50.266]                       workers <- workers()
[17:43:50.266]                     workers <- structure(as.integer(workers), 
[17:43:50.266]                       class = class(workers))
[17:43:50.266]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:50.266]                       workers >= 1)
[17:43:50.266]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:50.266]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:50.266]                     }
[17:43:50.266]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:50.266]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:50.266]                       envir = envir)
[17:43:50.266]                     if (!future$lazy) 
[17:43:50.266]                       future <- run(future)
[17:43:50.266]                     invisible(future)
[17:43:50.266]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:50.266]                 }
[17:43:50.266]             }
[17:43:50.266]         }
[17:43:50.266]     })
[17:43:50.266]     if (TRUE) {
[17:43:50.266]         base::sink(type = "output", split = FALSE)
[17:43:50.266]         if (TRUE) {
[17:43:50.266]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:50.266]         }
[17:43:50.266]         else {
[17:43:50.266]             ...future.result["stdout"] <- base::list(NULL)
[17:43:50.266]         }
[17:43:50.266]         base::close(...future.stdout)
[17:43:50.266]         ...future.stdout <- NULL
[17:43:50.266]     }
[17:43:50.266]     ...future.result$conditions <- ...future.conditions
[17:43:50.266]     ...future.result$finished <- base::Sys.time()
[17:43:50.266]     ...future.result
[17:43:50.266] }
[17:43:50.270] MultisessionFuture started
[17:43:50.270] - Launch lazy future ... done
[17:43:50.270] run() for ‘MultisessionFuture’ ... done
[17:43:50.817] receiveMessageFromWorker() for ClusterFuture ...
[17:43:50.817] - Validating connection of MultisessionFuture
[17:43:50.818] - received message: FutureResult
[17:43:50.818] - Received FutureResult
[17:43:50.818] - Erased future from FutureRegistry
[17:43:50.818] result() for ClusterFuture ...
[17:43:50.818] - result already collected: FutureResult
[17:43:50.818] result() for ClusterFuture ... done
[17:43:50.818] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:50.818] resolve() on list ...
[17:43:50.818]  recursive: 0
[17:43:50.818]  length: 2
[17:43:50.819]  elements: ‘a’, ‘b’
[17:43:50.819]  length: 1 (resolved future 1)
[17:43:50.819]  length: 0 (resolved future 2)
[17:43:50.819] resolve() on list ... DONE
[17:43:50.819] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[17:43:50.819] getGlobalsAndPackages() ...
[17:43:50.819] Searching for globals...
[17:43:50.820] - globals found: [2] ‘list’, ‘stop’
[17:43:50.820] Searching for globals ... DONE
[17:43:50.820] Resolving globals: FALSE
[17:43:50.820] 
[17:43:50.821] 
[17:43:50.821] getGlobalsAndPackages() ... DONE
[17:43:50.821] run() for ‘Future’ ...
[17:43:50.821] - state: ‘created’
[17:43:50.821] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:50.838] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:50.838] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:50.838]   - Field: ‘node’
[17:43:50.838]   - Field: ‘label’
[17:43:50.838]   - Field: ‘local’
[17:43:50.838]   - Field: ‘owner’
[17:43:50.838]   - Field: ‘envir’
[17:43:50.839]   - Field: ‘workers’
[17:43:50.839]   - Field: ‘packages’
[17:43:50.839]   - Field: ‘gc’
[17:43:50.839]   - Field: ‘conditions’
[17:43:50.839]   - Field: ‘persistent’
[17:43:50.839]   - Field: ‘expr’
[17:43:50.839]   - Field: ‘uuid’
[17:43:50.839]   - Field: ‘seed’
[17:43:50.839]   - Field: ‘version’
[17:43:50.839]   - Field: ‘result’
[17:43:50.840]   - Field: ‘asynchronous’
[17:43:50.840]   - Field: ‘calls’
[17:43:50.840]   - Field: ‘globals’
[17:43:50.840]   - Field: ‘stdout’
[17:43:50.840]   - Field: ‘earlySignal’
[17:43:50.840]   - Field: ‘lazy’
[17:43:50.840]   - Field: ‘state’
[17:43:50.840] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:50.840] - Launch lazy future ...
[17:43:50.841] Packages needed by the future expression (n = 0): <none>
[17:43:50.841] Packages needed by future strategies (n = 0): <none>
[17:43:50.841] {
[17:43:50.841]     {
[17:43:50.841]         {
[17:43:50.841]             ...future.startTime <- base::Sys.time()
[17:43:50.841]             {
[17:43:50.841]                 {
[17:43:50.841]                   {
[17:43:50.841]                     {
[17:43:50.841]                       base::local({
[17:43:50.841]                         has_future <- base::requireNamespace("future", 
[17:43:50.841]                           quietly = TRUE)
[17:43:50.841]                         if (has_future) {
[17:43:50.841]                           ns <- base::getNamespace("future")
[17:43:50.841]                           version <- ns[[".package"]][["version"]]
[17:43:50.841]                           if (is.null(version)) 
[17:43:50.841]                             version <- utils::packageVersion("future")
[17:43:50.841]                         }
[17:43:50.841]                         else {
[17:43:50.841]                           version <- NULL
[17:43:50.841]                         }
[17:43:50.841]                         if (!has_future || version < "1.8.0") {
[17:43:50.841]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:50.841]                             "", base::R.version$version.string), 
[17:43:50.841]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:50.841]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:50.841]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:50.841]                               "release", "version")], collapse = " "), 
[17:43:50.841]                             hostname = base::Sys.info()[["nodename"]])
[17:43:50.841]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:50.841]                             info)
[17:43:50.841]                           info <- base::paste(info, collapse = "; ")
[17:43:50.841]                           if (!has_future) {
[17:43:50.841]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:50.841]                               info)
[17:43:50.841]                           }
[17:43:50.841]                           else {
[17:43:50.841]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:50.841]                               info, version)
[17:43:50.841]                           }
[17:43:50.841]                           base::stop(msg)
[17:43:50.841]                         }
[17:43:50.841]                       })
[17:43:50.841]                     }
[17:43:50.841]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:50.841]                     base::options(mc.cores = 1L)
[17:43:50.841]                   }
[17:43:50.841]                   options(future.plan = NULL)
[17:43:50.841]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:50.841]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:50.841]                 }
[17:43:50.841]                 ...future.workdir <- getwd()
[17:43:50.841]             }
[17:43:50.841]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:50.841]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:50.841]         }
[17:43:50.841]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:50.841]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:50.841]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:50.841]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:50.841]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:50.841]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:50.841]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:50.841]             base::names(...future.oldOptions))
[17:43:50.841]     }
[17:43:50.841]     if (FALSE) {
[17:43:50.841]     }
[17:43:50.841]     else {
[17:43:50.841]         if (TRUE) {
[17:43:50.841]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:50.841]                 open = "w")
[17:43:50.841]         }
[17:43:50.841]         else {
[17:43:50.841]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:50.841]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:50.841]         }
[17:43:50.841]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:50.841]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:50.841]             base::sink(type = "output", split = FALSE)
[17:43:50.841]             base::close(...future.stdout)
[17:43:50.841]         }, add = TRUE)
[17:43:50.841]     }
[17:43:50.841]     ...future.frame <- base::sys.nframe()
[17:43:50.841]     ...future.conditions <- base::list()
[17:43:50.841]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:50.841]     if (FALSE) {
[17:43:50.841]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:50.841]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:50.841]     }
[17:43:50.841]     ...future.result <- base::tryCatch({
[17:43:50.841]         base::withCallingHandlers({
[17:43:50.841]             ...future.value <- base::withVisible(base::local({
[17:43:50.841]                 ...future.makeSendCondition <- local({
[17:43:50.841]                   sendCondition <- NULL
[17:43:50.841]                   function(frame = 1L) {
[17:43:50.841]                     if (is.function(sendCondition)) 
[17:43:50.841]                       return(sendCondition)
[17:43:50.841]                     ns <- getNamespace("parallel")
[17:43:50.841]                     if (exists("sendData", mode = "function", 
[17:43:50.841]                       envir = ns)) {
[17:43:50.841]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:50.841]                         envir = ns)
[17:43:50.841]                       envir <- sys.frame(frame)
[17:43:50.841]                       master <- NULL
[17:43:50.841]                       while (!identical(envir, .GlobalEnv) && 
[17:43:50.841]                         !identical(envir, emptyenv())) {
[17:43:50.841]                         if (exists("master", mode = "list", envir = envir, 
[17:43:50.841]                           inherits = FALSE)) {
[17:43:50.841]                           master <- get("master", mode = "list", 
[17:43:50.841]                             envir = envir, inherits = FALSE)
[17:43:50.841]                           if (inherits(master, c("SOCKnode", 
[17:43:50.841]                             "SOCK0node"))) {
[17:43:50.841]                             sendCondition <<- function(cond) {
[17:43:50.841]                               data <- list(type = "VALUE", value = cond, 
[17:43:50.841]                                 success = TRUE)
[17:43:50.841]                               parallel_sendData(master, data)
[17:43:50.841]                             }
[17:43:50.841]                             return(sendCondition)
[17:43:50.841]                           }
[17:43:50.841]                         }
[17:43:50.841]                         frame <- frame + 1L
[17:43:50.841]                         envir <- sys.frame(frame)
[17:43:50.841]                       }
[17:43:50.841]                     }
[17:43:50.841]                     sendCondition <<- function(cond) NULL
[17:43:50.841]                   }
[17:43:50.841]                 })
[17:43:50.841]                 withCallingHandlers({
[17:43:50.841]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:43:50.841]                 }, immediateCondition = function(cond) {
[17:43:50.841]                   sendCondition <- ...future.makeSendCondition()
[17:43:50.841]                   sendCondition(cond)
[17:43:50.841]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.841]                   {
[17:43:50.841]                     inherits <- base::inherits
[17:43:50.841]                     invokeRestart <- base::invokeRestart
[17:43:50.841]                     is.null <- base::is.null
[17:43:50.841]                     muffled <- FALSE
[17:43:50.841]                     if (inherits(cond, "message")) {
[17:43:50.841]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:50.841]                       if (muffled) 
[17:43:50.841]                         invokeRestart("muffleMessage")
[17:43:50.841]                     }
[17:43:50.841]                     else if (inherits(cond, "warning")) {
[17:43:50.841]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:50.841]                       if (muffled) 
[17:43:50.841]                         invokeRestart("muffleWarning")
[17:43:50.841]                     }
[17:43:50.841]                     else if (inherits(cond, "condition")) {
[17:43:50.841]                       if (!is.null(pattern)) {
[17:43:50.841]                         computeRestarts <- base::computeRestarts
[17:43:50.841]                         grepl <- base::grepl
[17:43:50.841]                         restarts <- computeRestarts(cond)
[17:43:50.841]                         for (restart in restarts) {
[17:43:50.841]                           name <- restart$name
[17:43:50.841]                           if (is.null(name)) 
[17:43:50.841]                             next
[17:43:50.841]                           if (!grepl(pattern, name)) 
[17:43:50.841]                             next
[17:43:50.841]                           invokeRestart(restart)
[17:43:50.841]                           muffled <- TRUE
[17:43:50.841]                           break
[17:43:50.841]                         }
[17:43:50.841]                       }
[17:43:50.841]                     }
[17:43:50.841]                     invisible(muffled)
[17:43:50.841]                   }
[17:43:50.841]                   muffleCondition(cond)
[17:43:50.841]                 })
[17:43:50.841]             }))
[17:43:50.841]             future::FutureResult(value = ...future.value$value, 
[17:43:50.841]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:50.841]                   ...future.rng), globalenv = if (FALSE) 
[17:43:50.841]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:50.841]                     ...future.globalenv.names))
[17:43:50.841]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:50.841]         }, condition = base::local({
[17:43:50.841]             c <- base::c
[17:43:50.841]             inherits <- base::inherits
[17:43:50.841]             invokeRestart <- base::invokeRestart
[17:43:50.841]             length <- base::length
[17:43:50.841]             list <- base::list
[17:43:50.841]             seq.int <- base::seq.int
[17:43:50.841]             signalCondition <- base::signalCondition
[17:43:50.841]             sys.calls <- base::sys.calls
[17:43:50.841]             `[[` <- base::`[[`
[17:43:50.841]             `+` <- base::`+`
[17:43:50.841]             `<<-` <- base::`<<-`
[17:43:50.841]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:50.841]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:50.841]                   3L)]
[17:43:50.841]             }
[17:43:50.841]             function(cond) {
[17:43:50.841]                 is_error <- inherits(cond, "error")
[17:43:50.841]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:50.841]                   NULL)
[17:43:50.841]                 if (is_error) {
[17:43:50.841]                   sessionInformation <- function() {
[17:43:50.841]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:50.841]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:50.841]                       search = base::search(), system = base::Sys.info())
[17:43:50.841]                   }
[17:43:50.841]                   ...future.conditions[[length(...future.conditions) + 
[17:43:50.841]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:50.841]                     cond$call), session = sessionInformation(), 
[17:43:50.841]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:50.841]                   signalCondition(cond)
[17:43:50.841]                 }
[17:43:50.841]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:50.841]                 "immediateCondition"))) {
[17:43:50.841]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:50.841]                   ...future.conditions[[length(...future.conditions) + 
[17:43:50.841]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:50.841]                   if (TRUE && !signal) {
[17:43:50.841]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.841]                     {
[17:43:50.841]                       inherits <- base::inherits
[17:43:50.841]                       invokeRestart <- base::invokeRestart
[17:43:50.841]                       is.null <- base::is.null
[17:43:50.841]                       muffled <- FALSE
[17:43:50.841]                       if (inherits(cond, "message")) {
[17:43:50.841]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:50.841]                         if (muffled) 
[17:43:50.841]                           invokeRestart("muffleMessage")
[17:43:50.841]                       }
[17:43:50.841]                       else if (inherits(cond, "warning")) {
[17:43:50.841]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:50.841]                         if (muffled) 
[17:43:50.841]                           invokeRestart("muffleWarning")
[17:43:50.841]                       }
[17:43:50.841]                       else if (inherits(cond, "condition")) {
[17:43:50.841]                         if (!is.null(pattern)) {
[17:43:50.841]                           computeRestarts <- base::computeRestarts
[17:43:50.841]                           grepl <- base::grepl
[17:43:50.841]                           restarts <- computeRestarts(cond)
[17:43:50.841]                           for (restart in restarts) {
[17:43:50.841]                             name <- restart$name
[17:43:50.841]                             if (is.null(name)) 
[17:43:50.841]                               next
[17:43:50.841]                             if (!grepl(pattern, name)) 
[17:43:50.841]                               next
[17:43:50.841]                             invokeRestart(restart)
[17:43:50.841]                             muffled <- TRUE
[17:43:50.841]                             break
[17:43:50.841]                           }
[17:43:50.841]                         }
[17:43:50.841]                       }
[17:43:50.841]                       invisible(muffled)
[17:43:50.841]                     }
[17:43:50.841]                     muffleCondition(cond, pattern = "^muffle")
[17:43:50.841]                   }
[17:43:50.841]                 }
[17:43:50.841]                 else {
[17:43:50.841]                   if (TRUE) {
[17:43:50.841]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.841]                     {
[17:43:50.841]                       inherits <- base::inherits
[17:43:50.841]                       invokeRestart <- base::invokeRestart
[17:43:50.841]                       is.null <- base::is.null
[17:43:50.841]                       muffled <- FALSE
[17:43:50.841]                       if (inherits(cond, "message")) {
[17:43:50.841]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:50.841]                         if (muffled) 
[17:43:50.841]                           invokeRestart("muffleMessage")
[17:43:50.841]                       }
[17:43:50.841]                       else if (inherits(cond, "warning")) {
[17:43:50.841]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:50.841]                         if (muffled) 
[17:43:50.841]                           invokeRestart("muffleWarning")
[17:43:50.841]                       }
[17:43:50.841]                       else if (inherits(cond, "condition")) {
[17:43:50.841]                         if (!is.null(pattern)) {
[17:43:50.841]                           computeRestarts <- base::computeRestarts
[17:43:50.841]                           grepl <- base::grepl
[17:43:50.841]                           restarts <- computeRestarts(cond)
[17:43:50.841]                           for (restart in restarts) {
[17:43:50.841]                             name <- restart$name
[17:43:50.841]                             if (is.null(name)) 
[17:43:50.841]                               next
[17:43:50.841]                             if (!grepl(pattern, name)) 
[17:43:50.841]                               next
[17:43:50.841]                             invokeRestart(restart)
[17:43:50.841]                             muffled <- TRUE
[17:43:50.841]                             break
[17:43:50.841]                           }
[17:43:50.841]                         }
[17:43:50.841]                       }
[17:43:50.841]                       invisible(muffled)
[17:43:50.841]                     }
[17:43:50.841]                     muffleCondition(cond, pattern = "^muffle")
[17:43:50.841]                   }
[17:43:50.841]                 }
[17:43:50.841]             }
[17:43:50.841]         }))
[17:43:50.841]     }, error = function(ex) {
[17:43:50.841]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:50.841]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:50.841]                 ...future.rng), started = ...future.startTime, 
[17:43:50.841]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:50.841]             version = "1.8"), class = "FutureResult")
[17:43:50.841]     }, finally = {
[17:43:50.841]         if (!identical(...future.workdir, getwd())) 
[17:43:50.841]             setwd(...future.workdir)
[17:43:50.841]         {
[17:43:50.841]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:50.841]                 ...future.oldOptions$nwarnings <- NULL
[17:43:50.841]             }
[17:43:50.841]             base::options(...future.oldOptions)
[17:43:50.841]             if (.Platform$OS.type == "windows") {
[17:43:50.841]                 old_names <- names(...future.oldEnvVars)
[17:43:50.841]                 envs <- base::Sys.getenv()
[17:43:50.841]                 names <- names(envs)
[17:43:50.841]                 common <- intersect(names, old_names)
[17:43:50.841]                 added <- setdiff(names, old_names)
[17:43:50.841]                 removed <- setdiff(old_names, names)
[17:43:50.841]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:50.841]                   envs[common]]
[17:43:50.841]                 NAMES <- toupper(changed)
[17:43:50.841]                 args <- list()
[17:43:50.841]                 for (kk in seq_along(NAMES)) {
[17:43:50.841]                   name <- changed[[kk]]
[17:43:50.841]                   NAME <- NAMES[[kk]]
[17:43:50.841]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.841]                     next
[17:43:50.841]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:50.841]                 }
[17:43:50.841]                 NAMES <- toupper(added)
[17:43:50.841]                 for (kk in seq_along(NAMES)) {
[17:43:50.841]                   name <- added[[kk]]
[17:43:50.841]                   NAME <- NAMES[[kk]]
[17:43:50.841]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.841]                     next
[17:43:50.841]                   args[[name]] <- ""
[17:43:50.841]                 }
[17:43:50.841]                 NAMES <- toupper(removed)
[17:43:50.841]                 for (kk in seq_along(NAMES)) {
[17:43:50.841]                   name <- removed[[kk]]
[17:43:50.841]                   NAME <- NAMES[[kk]]
[17:43:50.841]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.841]                     next
[17:43:50.841]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:50.841]                 }
[17:43:50.841]                 if (length(args) > 0) 
[17:43:50.841]                   base::do.call(base::Sys.setenv, args = args)
[17:43:50.841]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:50.841]             }
[17:43:50.841]             else {
[17:43:50.841]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:50.841]             }
[17:43:50.841]             {
[17:43:50.841]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:50.841]                   0L) {
[17:43:50.841]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:50.841]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:50.841]                   base::options(opts)
[17:43:50.841]                 }
[17:43:50.841]                 {
[17:43:50.841]                   {
[17:43:50.841]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:50.841]                     NULL
[17:43:50.841]                   }
[17:43:50.841]                   options(future.plan = NULL)
[17:43:50.841]                   if (is.na(NA_character_)) 
[17:43:50.841]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:50.841]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:50.841]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:50.841]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:50.841]                     envir = parent.frame()) 
[17:43:50.841]                   {
[17:43:50.841]                     if (is.function(workers)) 
[17:43:50.841]                       workers <- workers()
[17:43:50.841]                     workers <- structure(as.integer(workers), 
[17:43:50.841]                       class = class(workers))
[17:43:50.841]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:50.841]                       workers >= 1)
[17:43:50.841]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:50.841]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:50.841]                     }
[17:43:50.841]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:50.841]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:50.841]                       envir = envir)
[17:43:50.841]                     if (!future$lazy) 
[17:43:50.841]                       future <- run(future)
[17:43:50.841]                     invisible(future)
[17:43:50.841]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:50.841]                 }
[17:43:50.841]             }
[17:43:50.841]         }
[17:43:50.841]     })
[17:43:50.841]     if (TRUE) {
[17:43:50.841]         base::sink(type = "output", split = FALSE)
[17:43:50.841]         if (TRUE) {
[17:43:50.841]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:50.841]         }
[17:43:50.841]         else {
[17:43:50.841]             ...future.result["stdout"] <- base::list(NULL)
[17:43:50.841]         }
[17:43:50.841]         base::close(...future.stdout)
[17:43:50.841]         ...future.stdout <- NULL
[17:43:50.841]     }
[17:43:50.841]     ...future.result$conditions <- ...future.conditions
[17:43:50.841]     ...future.result$finished <- base::Sys.time()
[17:43:50.841]     ...future.result
[17:43:50.841] }
[17:43:50.844] MultisessionFuture started
[17:43:50.845] - Launch lazy future ... done
[17:43:50.845] run() for ‘MultisessionFuture’ ... done
[17:43:50.892] receiveMessageFromWorker() for ClusterFuture ...
[17:43:50.893] - Validating connection of MultisessionFuture
[17:43:50.893] - received message: FutureResult
[17:43:50.893] - Received FutureResult
[17:43:50.893] - Erased future from FutureRegistry
[17:43:50.893] result() for ClusterFuture ...
[17:43:50.893] - result already collected: FutureResult
[17:43:50.894] result() for ClusterFuture ... done
[17:43:50.894] signalConditions() ...
[17:43:50.894]  - include = ‘immediateCondition’
[17:43:50.894]  - exclude = 
[17:43:50.894]  - resignal = FALSE
[17:43:50.894]  - Number of conditions: 1
[17:43:50.894] signalConditions() ... done
[17:43:50.894] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:50.894] A MultisessionFuture was resolved
[17:43:50.894] getGlobalsAndPackages() ...
[17:43:50.895] Searching for globals...
[17:43:50.895] - globals found: [2] ‘list’, ‘stop’
[17:43:50.895] Searching for globals ... DONE
[17:43:50.895] Resolving globals: FALSE
[17:43:50.896] 
[17:43:50.896] 
[17:43:50.896] getGlobalsAndPackages() ... DONE
[17:43:50.896] run() for ‘Future’ ...
[17:43:50.896] - state: ‘created’
[17:43:50.896] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:50.910] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:50.911] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:50.911]   - Field: ‘node’
[17:43:50.911]   - Field: ‘label’
[17:43:50.911]   - Field: ‘local’
[17:43:50.911]   - Field: ‘owner’
[17:43:50.911]   - Field: ‘envir’
[17:43:50.911]   - Field: ‘workers’
[17:43:50.911]   - Field: ‘packages’
[17:43:50.912]   - Field: ‘gc’
[17:43:50.912]   - Field: ‘conditions’
[17:43:50.912]   - Field: ‘persistent’
[17:43:50.912]   - Field: ‘expr’
[17:43:50.912]   - Field: ‘uuid’
[17:43:50.912]   - Field: ‘seed’
[17:43:50.912]   - Field: ‘version’
[17:43:50.912]   - Field: ‘result’
[17:43:50.912]   - Field: ‘asynchronous’
[17:43:50.912]   - Field: ‘calls’
[17:43:50.912]   - Field: ‘globals’
[17:43:50.913]   - Field: ‘stdout’
[17:43:50.913]   - Field: ‘earlySignal’
[17:43:50.913]   - Field: ‘lazy’
[17:43:50.913]   - Field: ‘state’
[17:43:50.913] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:50.913] - Launch lazy future ...
[17:43:50.913] Packages needed by the future expression (n = 0): <none>
[17:43:50.913] Packages needed by future strategies (n = 0): <none>
[17:43:50.914] {
[17:43:50.914]     {
[17:43:50.914]         {
[17:43:50.914]             ...future.startTime <- base::Sys.time()
[17:43:50.914]             {
[17:43:50.914]                 {
[17:43:50.914]                   {
[17:43:50.914]                     {
[17:43:50.914]                       base::local({
[17:43:50.914]                         has_future <- base::requireNamespace("future", 
[17:43:50.914]                           quietly = TRUE)
[17:43:50.914]                         if (has_future) {
[17:43:50.914]                           ns <- base::getNamespace("future")
[17:43:50.914]                           version <- ns[[".package"]][["version"]]
[17:43:50.914]                           if (is.null(version)) 
[17:43:50.914]                             version <- utils::packageVersion("future")
[17:43:50.914]                         }
[17:43:50.914]                         else {
[17:43:50.914]                           version <- NULL
[17:43:50.914]                         }
[17:43:50.914]                         if (!has_future || version < "1.8.0") {
[17:43:50.914]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:50.914]                             "", base::R.version$version.string), 
[17:43:50.914]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:50.914]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:50.914]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:50.914]                               "release", "version")], collapse = " "), 
[17:43:50.914]                             hostname = base::Sys.info()[["nodename"]])
[17:43:50.914]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:50.914]                             info)
[17:43:50.914]                           info <- base::paste(info, collapse = "; ")
[17:43:50.914]                           if (!has_future) {
[17:43:50.914]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:50.914]                               info)
[17:43:50.914]                           }
[17:43:50.914]                           else {
[17:43:50.914]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:50.914]                               info, version)
[17:43:50.914]                           }
[17:43:50.914]                           base::stop(msg)
[17:43:50.914]                         }
[17:43:50.914]                       })
[17:43:50.914]                     }
[17:43:50.914]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:50.914]                     base::options(mc.cores = 1L)
[17:43:50.914]                   }
[17:43:50.914]                   options(future.plan = NULL)
[17:43:50.914]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:50.914]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:50.914]                 }
[17:43:50.914]                 ...future.workdir <- getwd()
[17:43:50.914]             }
[17:43:50.914]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:50.914]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:50.914]         }
[17:43:50.914]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:50.914]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:50.914]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:50.914]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:50.914]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:50.914]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:50.914]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:50.914]             base::names(...future.oldOptions))
[17:43:50.914]     }
[17:43:50.914]     if (FALSE) {
[17:43:50.914]     }
[17:43:50.914]     else {
[17:43:50.914]         if (TRUE) {
[17:43:50.914]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:50.914]                 open = "w")
[17:43:50.914]         }
[17:43:50.914]         else {
[17:43:50.914]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:50.914]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:50.914]         }
[17:43:50.914]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:50.914]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:50.914]             base::sink(type = "output", split = FALSE)
[17:43:50.914]             base::close(...future.stdout)
[17:43:50.914]         }, add = TRUE)
[17:43:50.914]     }
[17:43:50.914]     ...future.frame <- base::sys.nframe()
[17:43:50.914]     ...future.conditions <- base::list()
[17:43:50.914]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:50.914]     if (FALSE) {
[17:43:50.914]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:50.914]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:50.914]     }
[17:43:50.914]     ...future.result <- base::tryCatch({
[17:43:50.914]         base::withCallingHandlers({
[17:43:50.914]             ...future.value <- base::withVisible(base::local({
[17:43:50.914]                 ...future.makeSendCondition <- local({
[17:43:50.914]                   sendCondition <- NULL
[17:43:50.914]                   function(frame = 1L) {
[17:43:50.914]                     if (is.function(sendCondition)) 
[17:43:50.914]                       return(sendCondition)
[17:43:50.914]                     ns <- getNamespace("parallel")
[17:43:50.914]                     if (exists("sendData", mode = "function", 
[17:43:50.914]                       envir = ns)) {
[17:43:50.914]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:50.914]                         envir = ns)
[17:43:50.914]                       envir <- sys.frame(frame)
[17:43:50.914]                       master <- NULL
[17:43:50.914]                       while (!identical(envir, .GlobalEnv) && 
[17:43:50.914]                         !identical(envir, emptyenv())) {
[17:43:50.914]                         if (exists("master", mode = "list", envir = envir, 
[17:43:50.914]                           inherits = FALSE)) {
[17:43:50.914]                           master <- get("master", mode = "list", 
[17:43:50.914]                             envir = envir, inherits = FALSE)
[17:43:50.914]                           if (inherits(master, c("SOCKnode", 
[17:43:50.914]                             "SOCK0node"))) {
[17:43:50.914]                             sendCondition <<- function(cond) {
[17:43:50.914]                               data <- list(type = "VALUE", value = cond, 
[17:43:50.914]                                 success = TRUE)
[17:43:50.914]                               parallel_sendData(master, data)
[17:43:50.914]                             }
[17:43:50.914]                             return(sendCondition)
[17:43:50.914]                           }
[17:43:50.914]                         }
[17:43:50.914]                         frame <- frame + 1L
[17:43:50.914]                         envir <- sys.frame(frame)
[17:43:50.914]                       }
[17:43:50.914]                     }
[17:43:50.914]                     sendCondition <<- function(cond) NULL
[17:43:50.914]                   }
[17:43:50.914]                 })
[17:43:50.914]                 withCallingHandlers({
[17:43:50.914]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:43:50.914]                 }, immediateCondition = function(cond) {
[17:43:50.914]                   sendCondition <- ...future.makeSendCondition()
[17:43:50.914]                   sendCondition(cond)
[17:43:50.914]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.914]                   {
[17:43:50.914]                     inherits <- base::inherits
[17:43:50.914]                     invokeRestart <- base::invokeRestart
[17:43:50.914]                     is.null <- base::is.null
[17:43:50.914]                     muffled <- FALSE
[17:43:50.914]                     if (inherits(cond, "message")) {
[17:43:50.914]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:50.914]                       if (muffled) 
[17:43:50.914]                         invokeRestart("muffleMessage")
[17:43:50.914]                     }
[17:43:50.914]                     else if (inherits(cond, "warning")) {
[17:43:50.914]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:50.914]                       if (muffled) 
[17:43:50.914]                         invokeRestart("muffleWarning")
[17:43:50.914]                     }
[17:43:50.914]                     else if (inherits(cond, "condition")) {
[17:43:50.914]                       if (!is.null(pattern)) {
[17:43:50.914]                         computeRestarts <- base::computeRestarts
[17:43:50.914]                         grepl <- base::grepl
[17:43:50.914]                         restarts <- computeRestarts(cond)
[17:43:50.914]                         for (restart in restarts) {
[17:43:50.914]                           name <- restart$name
[17:43:50.914]                           if (is.null(name)) 
[17:43:50.914]                             next
[17:43:50.914]                           if (!grepl(pattern, name)) 
[17:43:50.914]                             next
[17:43:50.914]                           invokeRestart(restart)
[17:43:50.914]                           muffled <- TRUE
[17:43:50.914]                           break
[17:43:50.914]                         }
[17:43:50.914]                       }
[17:43:50.914]                     }
[17:43:50.914]                     invisible(muffled)
[17:43:50.914]                   }
[17:43:50.914]                   muffleCondition(cond)
[17:43:50.914]                 })
[17:43:50.914]             }))
[17:43:50.914]             future::FutureResult(value = ...future.value$value, 
[17:43:50.914]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:50.914]                   ...future.rng), globalenv = if (FALSE) 
[17:43:50.914]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:50.914]                     ...future.globalenv.names))
[17:43:50.914]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:50.914]         }, condition = base::local({
[17:43:50.914]             c <- base::c
[17:43:50.914]             inherits <- base::inherits
[17:43:50.914]             invokeRestart <- base::invokeRestart
[17:43:50.914]             length <- base::length
[17:43:50.914]             list <- base::list
[17:43:50.914]             seq.int <- base::seq.int
[17:43:50.914]             signalCondition <- base::signalCondition
[17:43:50.914]             sys.calls <- base::sys.calls
[17:43:50.914]             `[[` <- base::`[[`
[17:43:50.914]             `+` <- base::`+`
[17:43:50.914]             `<<-` <- base::`<<-`
[17:43:50.914]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:50.914]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:50.914]                   3L)]
[17:43:50.914]             }
[17:43:50.914]             function(cond) {
[17:43:50.914]                 is_error <- inherits(cond, "error")
[17:43:50.914]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:50.914]                   NULL)
[17:43:50.914]                 if (is_error) {
[17:43:50.914]                   sessionInformation <- function() {
[17:43:50.914]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:50.914]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:50.914]                       search = base::search(), system = base::Sys.info())
[17:43:50.914]                   }
[17:43:50.914]                   ...future.conditions[[length(...future.conditions) + 
[17:43:50.914]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:50.914]                     cond$call), session = sessionInformation(), 
[17:43:50.914]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:50.914]                   signalCondition(cond)
[17:43:50.914]                 }
[17:43:50.914]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:50.914]                 "immediateCondition"))) {
[17:43:50.914]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:50.914]                   ...future.conditions[[length(...future.conditions) + 
[17:43:50.914]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:50.914]                   if (TRUE && !signal) {
[17:43:50.914]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.914]                     {
[17:43:50.914]                       inherits <- base::inherits
[17:43:50.914]                       invokeRestart <- base::invokeRestart
[17:43:50.914]                       is.null <- base::is.null
[17:43:50.914]                       muffled <- FALSE
[17:43:50.914]                       if (inherits(cond, "message")) {
[17:43:50.914]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:50.914]                         if (muffled) 
[17:43:50.914]                           invokeRestart("muffleMessage")
[17:43:50.914]                       }
[17:43:50.914]                       else if (inherits(cond, "warning")) {
[17:43:50.914]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:50.914]                         if (muffled) 
[17:43:50.914]                           invokeRestart("muffleWarning")
[17:43:50.914]                       }
[17:43:50.914]                       else if (inherits(cond, "condition")) {
[17:43:50.914]                         if (!is.null(pattern)) {
[17:43:50.914]                           computeRestarts <- base::computeRestarts
[17:43:50.914]                           grepl <- base::grepl
[17:43:50.914]                           restarts <- computeRestarts(cond)
[17:43:50.914]                           for (restart in restarts) {
[17:43:50.914]                             name <- restart$name
[17:43:50.914]                             if (is.null(name)) 
[17:43:50.914]                               next
[17:43:50.914]                             if (!grepl(pattern, name)) 
[17:43:50.914]                               next
[17:43:50.914]                             invokeRestart(restart)
[17:43:50.914]                             muffled <- TRUE
[17:43:50.914]                             break
[17:43:50.914]                           }
[17:43:50.914]                         }
[17:43:50.914]                       }
[17:43:50.914]                       invisible(muffled)
[17:43:50.914]                     }
[17:43:50.914]                     muffleCondition(cond, pattern = "^muffle")
[17:43:50.914]                   }
[17:43:50.914]                 }
[17:43:50.914]                 else {
[17:43:50.914]                   if (TRUE) {
[17:43:50.914]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.914]                     {
[17:43:50.914]                       inherits <- base::inherits
[17:43:50.914]                       invokeRestart <- base::invokeRestart
[17:43:50.914]                       is.null <- base::is.null
[17:43:50.914]                       muffled <- FALSE
[17:43:50.914]                       if (inherits(cond, "message")) {
[17:43:50.914]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:50.914]                         if (muffled) 
[17:43:50.914]                           invokeRestart("muffleMessage")
[17:43:50.914]                       }
[17:43:50.914]                       else if (inherits(cond, "warning")) {
[17:43:50.914]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:50.914]                         if (muffled) 
[17:43:50.914]                           invokeRestart("muffleWarning")
[17:43:50.914]                       }
[17:43:50.914]                       else if (inherits(cond, "condition")) {
[17:43:50.914]                         if (!is.null(pattern)) {
[17:43:50.914]                           computeRestarts <- base::computeRestarts
[17:43:50.914]                           grepl <- base::grepl
[17:43:50.914]                           restarts <- computeRestarts(cond)
[17:43:50.914]                           for (restart in restarts) {
[17:43:50.914]                             name <- restart$name
[17:43:50.914]                             if (is.null(name)) 
[17:43:50.914]                               next
[17:43:50.914]                             if (!grepl(pattern, name)) 
[17:43:50.914]                               next
[17:43:50.914]                             invokeRestart(restart)
[17:43:50.914]                             muffled <- TRUE
[17:43:50.914]                             break
[17:43:50.914]                           }
[17:43:50.914]                         }
[17:43:50.914]                       }
[17:43:50.914]                       invisible(muffled)
[17:43:50.914]                     }
[17:43:50.914]                     muffleCondition(cond, pattern = "^muffle")
[17:43:50.914]                   }
[17:43:50.914]                 }
[17:43:50.914]             }
[17:43:50.914]         }))
[17:43:50.914]     }, error = function(ex) {
[17:43:50.914]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:50.914]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:50.914]                 ...future.rng), started = ...future.startTime, 
[17:43:50.914]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:50.914]             version = "1.8"), class = "FutureResult")
[17:43:50.914]     }, finally = {
[17:43:50.914]         if (!identical(...future.workdir, getwd())) 
[17:43:50.914]             setwd(...future.workdir)
[17:43:50.914]         {
[17:43:50.914]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:50.914]                 ...future.oldOptions$nwarnings <- NULL
[17:43:50.914]             }
[17:43:50.914]             base::options(...future.oldOptions)
[17:43:50.914]             if (.Platform$OS.type == "windows") {
[17:43:50.914]                 old_names <- names(...future.oldEnvVars)
[17:43:50.914]                 envs <- base::Sys.getenv()
[17:43:50.914]                 names <- names(envs)
[17:43:50.914]                 common <- intersect(names, old_names)
[17:43:50.914]                 added <- setdiff(names, old_names)
[17:43:50.914]                 removed <- setdiff(old_names, names)
[17:43:50.914]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:50.914]                   envs[common]]
[17:43:50.914]                 NAMES <- toupper(changed)
[17:43:50.914]                 args <- list()
[17:43:50.914]                 for (kk in seq_along(NAMES)) {
[17:43:50.914]                   name <- changed[[kk]]
[17:43:50.914]                   NAME <- NAMES[[kk]]
[17:43:50.914]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.914]                     next
[17:43:50.914]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:50.914]                 }
[17:43:50.914]                 NAMES <- toupper(added)
[17:43:50.914]                 for (kk in seq_along(NAMES)) {
[17:43:50.914]                   name <- added[[kk]]
[17:43:50.914]                   NAME <- NAMES[[kk]]
[17:43:50.914]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.914]                     next
[17:43:50.914]                   args[[name]] <- ""
[17:43:50.914]                 }
[17:43:50.914]                 NAMES <- toupper(removed)
[17:43:50.914]                 for (kk in seq_along(NAMES)) {
[17:43:50.914]                   name <- removed[[kk]]
[17:43:50.914]                   NAME <- NAMES[[kk]]
[17:43:50.914]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.914]                     next
[17:43:50.914]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:50.914]                 }
[17:43:50.914]                 if (length(args) > 0) 
[17:43:50.914]                   base::do.call(base::Sys.setenv, args = args)
[17:43:50.914]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:50.914]             }
[17:43:50.914]             else {
[17:43:50.914]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:50.914]             }
[17:43:50.914]             {
[17:43:50.914]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:50.914]                   0L) {
[17:43:50.914]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:50.914]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:50.914]                   base::options(opts)
[17:43:50.914]                 }
[17:43:50.914]                 {
[17:43:50.914]                   {
[17:43:50.914]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:50.914]                     NULL
[17:43:50.914]                   }
[17:43:50.914]                   options(future.plan = NULL)
[17:43:50.914]                   if (is.na(NA_character_)) 
[17:43:50.914]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:50.914]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:50.914]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:50.914]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:50.914]                     envir = parent.frame()) 
[17:43:50.914]                   {
[17:43:50.914]                     if (is.function(workers)) 
[17:43:50.914]                       workers <- workers()
[17:43:50.914]                     workers <- structure(as.integer(workers), 
[17:43:50.914]                       class = class(workers))
[17:43:50.914]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:50.914]                       workers >= 1)
[17:43:50.914]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:50.914]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:50.914]                     }
[17:43:50.914]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:50.914]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:50.914]                       envir = envir)
[17:43:50.914]                     if (!future$lazy) 
[17:43:50.914]                       future <- run(future)
[17:43:50.914]                     invisible(future)
[17:43:50.914]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:50.914]                 }
[17:43:50.914]             }
[17:43:50.914]         }
[17:43:50.914]     })
[17:43:50.914]     if (TRUE) {
[17:43:50.914]         base::sink(type = "output", split = FALSE)
[17:43:50.914]         if (TRUE) {
[17:43:50.914]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:50.914]         }
[17:43:50.914]         else {
[17:43:50.914]             ...future.result["stdout"] <- base::list(NULL)
[17:43:50.914]         }
[17:43:50.914]         base::close(...future.stdout)
[17:43:50.914]         ...future.stdout <- NULL
[17:43:50.914]     }
[17:43:50.914]     ...future.result$conditions <- ...future.conditions
[17:43:50.914]     ...future.result$finished <- base::Sys.time()
[17:43:50.914]     ...future.result
[17:43:50.914] }
[17:43:50.917] MultisessionFuture started
[17:43:50.917] - Launch lazy future ... done
[17:43:50.917] run() for ‘MultisessionFuture’ ... done
[17:43:50.964] receiveMessageFromWorker() for ClusterFuture ...
[17:43:50.964] - Validating connection of MultisessionFuture
[17:43:50.965] - received message: FutureResult
[17:43:50.965] - Received FutureResult
[17:43:50.965] - Erased future from FutureRegistry
[17:43:50.965] result() for ClusterFuture ...
[17:43:50.965] - result already collected: FutureResult
[17:43:50.965] result() for ClusterFuture ... done
[17:43:50.965] signalConditions() ...
[17:43:50.966]  - include = ‘immediateCondition’
[17:43:50.966]  - exclude = 
[17:43:50.966]  - resignal = FALSE
[17:43:50.966]  - Number of conditions: 1
[17:43:50.966] signalConditions() ... done
[17:43:50.966] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:50.966] A MultisessionFuture was resolved
- result = TRUE, recursive = 1 ... DONE
- result = TRUE, recursive = 2 ...
[17:43:50.966] getGlobalsAndPackages() ...
[17:43:50.967] Searching for globals...
[17:43:50.968] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:43:50.968] Searching for globals ... DONE
[17:43:50.968] Resolving globals: FALSE
[17:43:50.968] 
[17:43:50.968] 
[17:43:50.969] getGlobalsAndPackages() ... DONE
[17:43:50.969] run() for ‘Future’ ...
[17:43:50.969] - state: ‘created’
[17:43:50.969] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:50.984] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:50.984] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:50.984]   - Field: ‘node’
[17:43:50.984]   - Field: ‘label’
[17:43:50.984]   - Field: ‘local’
[17:43:50.984]   - Field: ‘owner’
[17:43:50.985]   - Field: ‘envir’
[17:43:50.985]   - Field: ‘workers’
[17:43:50.985]   - Field: ‘packages’
[17:43:50.985]   - Field: ‘gc’
[17:43:50.985]   - Field: ‘conditions’
[17:43:50.985]   - Field: ‘persistent’
[17:43:50.985]   - Field: ‘expr’
[17:43:50.985]   - Field: ‘uuid’
[17:43:50.985]   - Field: ‘seed’
[17:43:50.985]   - Field: ‘version’
[17:43:50.985]   - Field: ‘result’
[17:43:50.986]   - Field: ‘asynchronous’
[17:43:50.986]   - Field: ‘calls’
[17:43:50.986]   - Field: ‘globals’
[17:43:50.986]   - Field: ‘stdout’
[17:43:50.986]   - Field: ‘earlySignal’
[17:43:50.986]   - Field: ‘lazy’
[17:43:50.986]   - Field: ‘state’
[17:43:50.986] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:50.986] - Launch lazy future ...
[17:43:50.987] Packages needed by the future expression (n = 0): <none>
[17:43:50.987] Packages needed by future strategies (n = 0): <none>
[17:43:50.987] {
[17:43:50.987]     {
[17:43:50.987]         {
[17:43:50.987]             ...future.startTime <- base::Sys.time()
[17:43:50.987]             {
[17:43:50.987]                 {
[17:43:50.987]                   {
[17:43:50.987]                     {
[17:43:50.987]                       base::local({
[17:43:50.987]                         has_future <- base::requireNamespace("future", 
[17:43:50.987]                           quietly = TRUE)
[17:43:50.987]                         if (has_future) {
[17:43:50.987]                           ns <- base::getNamespace("future")
[17:43:50.987]                           version <- ns[[".package"]][["version"]]
[17:43:50.987]                           if (is.null(version)) 
[17:43:50.987]                             version <- utils::packageVersion("future")
[17:43:50.987]                         }
[17:43:50.987]                         else {
[17:43:50.987]                           version <- NULL
[17:43:50.987]                         }
[17:43:50.987]                         if (!has_future || version < "1.8.0") {
[17:43:50.987]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:50.987]                             "", base::R.version$version.string), 
[17:43:50.987]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:50.987]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:50.987]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:50.987]                               "release", "version")], collapse = " "), 
[17:43:50.987]                             hostname = base::Sys.info()[["nodename"]])
[17:43:50.987]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:50.987]                             info)
[17:43:50.987]                           info <- base::paste(info, collapse = "; ")
[17:43:50.987]                           if (!has_future) {
[17:43:50.987]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:50.987]                               info)
[17:43:50.987]                           }
[17:43:50.987]                           else {
[17:43:50.987]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:50.987]                               info, version)
[17:43:50.987]                           }
[17:43:50.987]                           base::stop(msg)
[17:43:50.987]                         }
[17:43:50.987]                       })
[17:43:50.987]                     }
[17:43:50.987]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:50.987]                     base::options(mc.cores = 1L)
[17:43:50.987]                   }
[17:43:50.987]                   options(future.plan = NULL)
[17:43:50.987]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:50.987]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:50.987]                 }
[17:43:50.987]                 ...future.workdir <- getwd()
[17:43:50.987]             }
[17:43:50.987]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:50.987]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:50.987]         }
[17:43:50.987]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:50.987]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:50.987]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:50.987]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:50.987]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:50.987]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:50.987]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:50.987]             base::names(...future.oldOptions))
[17:43:50.987]     }
[17:43:50.987]     if (FALSE) {
[17:43:50.987]     }
[17:43:50.987]     else {
[17:43:50.987]         if (TRUE) {
[17:43:50.987]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:50.987]                 open = "w")
[17:43:50.987]         }
[17:43:50.987]         else {
[17:43:50.987]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:50.987]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:50.987]         }
[17:43:50.987]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:50.987]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:50.987]             base::sink(type = "output", split = FALSE)
[17:43:50.987]             base::close(...future.stdout)
[17:43:50.987]         }, add = TRUE)
[17:43:50.987]     }
[17:43:50.987]     ...future.frame <- base::sys.nframe()
[17:43:50.987]     ...future.conditions <- base::list()
[17:43:50.987]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:50.987]     if (FALSE) {
[17:43:50.987]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:50.987]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:50.987]     }
[17:43:50.987]     ...future.result <- base::tryCatch({
[17:43:50.987]         base::withCallingHandlers({
[17:43:50.987]             ...future.value <- base::withVisible(base::local({
[17:43:50.987]                 ...future.makeSendCondition <- local({
[17:43:50.987]                   sendCondition <- NULL
[17:43:50.987]                   function(frame = 1L) {
[17:43:50.987]                     if (is.function(sendCondition)) 
[17:43:50.987]                       return(sendCondition)
[17:43:50.987]                     ns <- getNamespace("parallel")
[17:43:50.987]                     if (exists("sendData", mode = "function", 
[17:43:50.987]                       envir = ns)) {
[17:43:50.987]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:50.987]                         envir = ns)
[17:43:50.987]                       envir <- sys.frame(frame)
[17:43:50.987]                       master <- NULL
[17:43:50.987]                       while (!identical(envir, .GlobalEnv) && 
[17:43:50.987]                         !identical(envir, emptyenv())) {
[17:43:50.987]                         if (exists("master", mode = "list", envir = envir, 
[17:43:50.987]                           inherits = FALSE)) {
[17:43:50.987]                           master <- get("master", mode = "list", 
[17:43:50.987]                             envir = envir, inherits = FALSE)
[17:43:50.987]                           if (inherits(master, c("SOCKnode", 
[17:43:50.987]                             "SOCK0node"))) {
[17:43:50.987]                             sendCondition <<- function(cond) {
[17:43:50.987]                               data <- list(type = "VALUE", value = cond, 
[17:43:50.987]                                 success = TRUE)
[17:43:50.987]                               parallel_sendData(master, data)
[17:43:50.987]                             }
[17:43:50.987]                             return(sendCondition)
[17:43:50.987]                           }
[17:43:50.987]                         }
[17:43:50.987]                         frame <- frame + 1L
[17:43:50.987]                         envir <- sys.frame(frame)
[17:43:50.987]                       }
[17:43:50.987]                     }
[17:43:50.987]                     sendCondition <<- function(cond) NULL
[17:43:50.987]                   }
[17:43:50.987]                 })
[17:43:50.987]                 withCallingHandlers({
[17:43:50.987]                   {
[17:43:50.987]                     Sys.sleep(0.5)
[17:43:50.987]                     list(a = 1, b = 42L)
[17:43:50.987]                   }
[17:43:50.987]                 }, immediateCondition = function(cond) {
[17:43:50.987]                   sendCondition <- ...future.makeSendCondition()
[17:43:50.987]                   sendCondition(cond)
[17:43:50.987]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.987]                   {
[17:43:50.987]                     inherits <- base::inherits
[17:43:50.987]                     invokeRestart <- base::invokeRestart
[17:43:50.987]                     is.null <- base::is.null
[17:43:50.987]                     muffled <- FALSE
[17:43:50.987]                     if (inherits(cond, "message")) {
[17:43:50.987]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:50.987]                       if (muffled) 
[17:43:50.987]                         invokeRestart("muffleMessage")
[17:43:50.987]                     }
[17:43:50.987]                     else if (inherits(cond, "warning")) {
[17:43:50.987]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:50.987]                       if (muffled) 
[17:43:50.987]                         invokeRestart("muffleWarning")
[17:43:50.987]                     }
[17:43:50.987]                     else if (inherits(cond, "condition")) {
[17:43:50.987]                       if (!is.null(pattern)) {
[17:43:50.987]                         computeRestarts <- base::computeRestarts
[17:43:50.987]                         grepl <- base::grepl
[17:43:50.987]                         restarts <- computeRestarts(cond)
[17:43:50.987]                         for (restart in restarts) {
[17:43:50.987]                           name <- restart$name
[17:43:50.987]                           if (is.null(name)) 
[17:43:50.987]                             next
[17:43:50.987]                           if (!grepl(pattern, name)) 
[17:43:50.987]                             next
[17:43:50.987]                           invokeRestart(restart)
[17:43:50.987]                           muffled <- TRUE
[17:43:50.987]                           break
[17:43:50.987]                         }
[17:43:50.987]                       }
[17:43:50.987]                     }
[17:43:50.987]                     invisible(muffled)
[17:43:50.987]                   }
[17:43:50.987]                   muffleCondition(cond)
[17:43:50.987]                 })
[17:43:50.987]             }))
[17:43:50.987]             future::FutureResult(value = ...future.value$value, 
[17:43:50.987]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:50.987]                   ...future.rng), globalenv = if (FALSE) 
[17:43:50.987]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:50.987]                     ...future.globalenv.names))
[17:43:50.987]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:50.987]         }, condition = base::local({
[17:43:50.987]             c <- base::c
[17:43:50.987]             inherits <- base::inherits
[17:43:50.987]             invokeRestart <- base::invokeRestart
[17:43:50.987]             length <- base::length
[17:43:50.987]             list <- base::list
[17:43:50.987]             seq.int <- base::seq.int
[17:43:50.987]             signalCondition <- base::signalCondition
[17:43:50.987]             sys.calls <- base::sys.calls
[17:43:50.987]             `[[` <- base::`[[`
[17:43:50.987]             `+` <- base::`+`
[17:43:50.987]             `<<-` <- base::`<<-`
[17:43:50.987]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:50.987]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:50.987]                   3L)]
[17:43:50.987]             }
[17:43:50.987]             function(cond) {
[17:43:50.987]                 is_error <- inherits(cond, "error")
[17:43:50.987]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:50.987]                   NULL)
[17:43:50.987]                 if (is_error) {
[17:43:50.987]                   sessionInformation <- function() {
[17:43:50.987]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:50.987]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:50.987]                       search = base::search(), system = base::Sys.info())
[17:43:50.987]                   }
[17:43:50.987]                   ...future.conditions[[length(...future.conditions) + 
[17:43:50.987]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:50.987]                     cond$call), session = sessionInformation(), 
[17:43:50.987]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:50.987]                   signalCondition(cond)
[17:43:50.987]                 }
[17:43:50.987]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:50.987]                 "immediateCondition"))) {
[17:43:50.987]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:50.987]                   ...future.conditions[[length(...future.conditions) + 
[17:43:50.987]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:50.987]                   if (TRUE && !signal) {
[17:43:50.987]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.987]                     {
[17:43:50.987]                       inherits <- base::inherits
[17:43:50.987]                       invokeRestart <- base::invokeRestart
[17:43:50.987]                       is.null <- base::is.null
[17:43:50.987]                       muffled <- FALSE
[17:43:50.987]                       if (inherits(cond, "message")) {
[17:43:50.987]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:50.987]                         if (muffled) 
[17:43:50.987]                           invokeRestart("muffleMessage")
[17:43:50.987]                       }
[17:43:50.987]                       else if (inherits(cond, "warning")) {
[17:43:50.987]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:50.987]                         if (muffled) 
[17:43:50.987]                           invokeRestart("muffleWarning")
[17:43:50.987]                       }
[17:43:50.987]                       else if (inherits(cond, "condition")) {
[17:43:50.987]                         if (!is.null(pattern)) {
[17:43:50.987]                           computeRestarts <- base::computeRestarts
[17:43:50.987]                           grepl <- base::grepl
[17:43:50.987]                           restarts <- computeRestarts(cond)
[17:43:50.987]                           for (restart in restarts) {
[17:43:50.987]                             name <- restart$name
[17:43:50.987]                             if (is.null(name)) 
[17:43:50.987]                               next
[17:43:50.987]                             if (!grepl(pattern, name)) 
[17:43:50.987]                               next
[17:43:50.987]                             invokeRestart(restart)
[17:43:50.987]                             muffled <- TRUE
[17:43:50.987]                             break
[17:43:50.987]                           }
[17:43:50.987]                         }
[17:43:50.987]                       }
[17:43:50.987]                       invisible(muffled)
[17:43:50.987]                     }
[17:43:50.987]                     muffleCondition(cond, pattern = "^muffle")
[17:43:50.987]                   }
[17:43:50.987]                 }
[17:43:50.987]                 else {
[17:43:50.987]                   if (TRUE) {
[17:43:50.987]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:50.987]                     {
[17:43:50.987]                       inherits <- base::inherits
[17:43:50.987]                       invokeRestart <- base::invokeRestart
[17:43:50.987]                       is.null <- base::is.null
[17:43:50.987]                       muffled <- FALSE
[17:43:50.987]                       if (inherits(cond, "message")) {
[17:43:50.987]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:50.987]                         if (muffled) 
[17:43:50.987]                           invokeRestart("muffleMessage")
[17:43:50.987]                       }
[17:43:50.987]                       else if (inherits(cond, "warning")) {
[17:43:50.987]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:50.987]                         if (muffled) 
[17:43:50.987]                           invokeRestart("muffleWarning")
[17:43:50.987]                       }
[17:43:50.987]                       else if (inherits(cond, "condition")) {
[17:43:50.987]                         if (!is.null(pattern)) {
[17:43:50.987]                           computeRestarts <- base::computeRestarts
[17:43:50.987]                           grepl <- base::grepl
[17:43:50.987]                           restarts <- computeRestarts(cond)
[17:43:50.987]                           for (restart in restarts) {
[17:43:50.987]                             name <- restart$name
[17:43:50.987]                             if (is.null(name)) 
[17:43:50.987]                               next
[17:43:50.987]                             if (!grepl(pattern, name)) 
[17:43:50.987]                               next
[17:43:50.987]                             invokeRestart(restart)
[17:43:50.987]                             muffled <- TRUE
[17:43:50.987]                             break
[17:43:50.987]                           }
[17:43:50.987]                         }
[17:43:50.987]                       }
[17:43:50.987]                       invisible(muffled)
[17:43:50.987]                     }
[17:43:50.987]                     muffleCondition(cond, pattern = "^muffle")
[17:43:50.987]                   }
[17:43:50.987]                 }
[17:43:50.987]             }
[17:43:50.987]         }))
[17:43:50.987]     }, error = function(ex) {
[17:43:50.987]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:50.987]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:50.987]                 ...future.rng), started = ...future.startTime, 
[17:43:50.987]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:50.987]             version = "1.8"), class = "FutureResult")
[17:43:50.987]     }, finally = {
[17:43:50.987]         if (!identical(...future.workdir, getwd())) 
[17:43:50.987]             setwd(...future.workdir)
[17:43:50.987]         {
[17:43:50.987]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:50.987]                 ...future.oldOptions$nwarnings <- NULL
[17:43:50.987]             }
[17:43:50.987]             base::options(...future.oldOptions)
[17:43:50.987]             if (.Platform$OS.type == "windows") {
[17:43:50.987]                 old_names <- names(...future.oldEnvVars)
[17:43:50.987]                 envs <- base::Sys.getenv()
[17:43:50.987]                 names <- names(envs)
[17:43:50.987]                 common <- intersect(names, old_names)
[17:43:50.987]                 added <- setdiff(names, old_names)
[17:43:50.987]                 removed <- setdiff(old_names, names)
[17:43:50.987]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:50.987]                   envs[common]]
[17:43:50.987]                 NAMES <- toupper(changed)
[17:43:50.987]                 args <- list()
[17:43:50.987]                 for (kk in seq_along(NAMES)) {
[17:43:50.987]                   name <- changed[[kk]]
[17:43:50.987]                   NAME <- NAMES[[kk]]
[17:43:50.987]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.987]                     next
[17:43:50.987]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:50.987]                 }
[17:43:50.987]                 NAMES <- toupper(added)
[17:43:50.987]                 for (kk in seq_along(NAMES)) {
[17:43:50.987]                   name <- added[[kk]]
[17:43:50.987]                   NAME <- NAMES[[kk]]
[17:43:50.987]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.987]                     next
[17:43:50.987]                   args[[name]] <- ""
[17:43:50.987]                 }
[17:43:50.987]                 NAMES <- toupper(removed)
[17:43:50.987]                 for (kk in seq_along(NAMES)) {
[17:43:50.987]                   name <- removed[[kk]]
[17:43:50.987]                   NAME <- NAMES[[kk]]
[17:43:50.987]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:50.987]                     next
[17:43:50.987]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:50.987]                 }
[17:43:50.987]                 if (length(args) > 0) 
[17:43:50.987]                   base::do.call(base::Sys.setenv, args = args)
[17:43:50.987]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:50.987]             }
[17:43:50.987]             else {
[17:43:50.987]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:50.987]             }
[17:43:50.987]             {
[17:43:50.987]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:50.987]                   0L) {
[17:43:50.987]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:50.987]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:50.987]                   base::options(opts)
[17:43:50.987]                 }
[17:43:50.987]                 {
[17:43:50.987]                   {
[17:43:50.987]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:50.987]                     NULL
[17:43:50.987]                   }
[17:43:50.987]                   options(future.plan = NULL)
[17:43:50.987]                   if (is.na(NA_character_)) 
[17:43:50.987]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:50.987]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:50.987]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:50.987]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:50.987]                     envir = parent.frame()) 
[17:43:50.987]                   {
[17:43:50.987]                     if (is.function(workers)) 
[17:43:50.987]                       workers <- workers()
[17:43:50.987]                     workers <- structure(as.integer(workers), 
[17:43:50.987]                       class = class(workers))
[17:43:50.987]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:50.987]                       workers >= 1)
[17:43:50.987]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:50.987]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:50.987]                     }
[17:43:50.987]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:50.987]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:50.987]                       envir = envir)
[17:43:50.987]                     if (!future$lazy) 
[17:43:50.987]                       future <- run(future)
[17:43:50.987]                     invisible(future)
[17:43:50.987]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:50.987]                 }
[17:43:50.987]             }
[17:43:50.987]         }
[17:43:50.987]     })
[17:43:50.987]     if (TRUE) {
[17:43:50.987]         base::sink(type = "output", split = FALSE)
[17:43:50.987]         if (TRUE) {
[17:43:50.987]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:50.987]         }
[17:43:50.987]         else {
[17:43:50.987]             ...future.result["stdout"] <- base::list(NULL)
[17:43:50.987]         }
[17:43:50.987]         base::close(...future.stdout)
[17:43:50.987]         ...future.stdout <- NULL
[17:43:50.987]     }
[17:43:50.987]     ...future.result$conditions <- ...future.conditions
[17:43:50.987]     ...future.result$finished <- base::Sys.time()
[17:43:50.987]     ...future.result
[17:43:50.987] }
[17:43:50.990] MultisessionFuture started
[17:43:50.991] - Launch lazy future ... done
[17:43:50.991] run() for ‘MultisessionFuture’ ... done
[17:43:51.537] receiveMessageFromWorker() for ClusterFuture ...
[17:43:51.537] - Validating connection of MultisessionFuture
[17:43:51.538] - received message: FutureResult
[17:43:51.538] - Received FutureResult
[17:43:51.538] - Erased future from FutureRegistry
[17:43:51.538] result() for ClusterFuture ...
[17:43:51.538] - result already collected: FutureResult
[17:43:51.538] result() for ClusterFuture ... done
[17:43:51.538] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:51.538] resolve() on list ...
[17:43:51.539]  recursive: 1
[17:43:51.539]  length: 2
[17:43:51.539]  elements: ‘a’, ‘b’
[17:43:51.539]  length: 1 (resolved future 1)
[17:43:51.539]  length: 0 (resolved future 2)
[17:43:51.539] resolve() on list ... DONE
[17:43:51.539] A MultisessionFuture was resolved (and resolved itself)
[17:43:51.539] getGlobalsAndPackages() ...
[17:43:51.539] Searching for globals...
[17:43:51.540] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:43:51.541] Searching for globals ... DONE
[17:43:51.541] Resolving globals: FALSE
[17:43:51.541] 
[17:43:51.541] 
[17:43:51.541] getGlobalsAndPackages() ... DONE
[17:43:51.542] run() for ‘Future’ ...
[17:43:51.542] - state: ‘created’
[17:43:51.542] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:51.556] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:51.556] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:51.556]   - Field: ‘node’
[17:43:51.556]   - Field: ‘label’
[17:43:51.557]   - Field: ‘local’
[17:43:51.557]   - Field: ‘owner’
[17:43:51.557]   - Field: ‘envir’
[17:43:51.557]   - Field: ‘workers’
[17:43:51.557]   - Field: ‘packages’
[17:43:51.557]   - Field: ‘gc’
[17:43:51.557]   - Field: ‘conditions’
[17:43:51.557]   - Field: ‘persistent’
[17:43:51.557]   - Field: ‘expr’
[17:43:51.557]   - Field: ‘uuid’
[17:43:51.557]   - Field: ‘seed’
[17:43:51.558]   - Field: ‘version’
[17:43:51.558]   - Field: ‘result’
[17:43:51.558]   - Field: ‘asynchronous’
[17:43:51.558]   - Field: ‘calls’
[17:43:51.558]   - Field: ‘globals’
[17:43:51.558]   - Field: ‘stdout’
[17:43:51.558]   - Field: ‘earlySignal’
[17:43:51.558]   - Field: ‘lazy’
[17:43:51.558]   - Field: ‘state’
[17:43:51.558] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:51.558] - Launch lazy future ...
[17:43:51.559] Packages needed by the future expression (n = 0): <none>
[17:43:51.559] Packages needed by future strategies (n = 0): <none>
[17:43:51.559] {
[17:43:51.559]     {
[17:43:51.559]         {
[17:43:51.559]             ...future.startTime <- base::Sys.time()
[17:43:51.559]             {
[17:43:51.559]                 {
[17:43:51.559]                   {
[17:43:51.559]                     {
[17:43:51.559]                       base::local({
[17:43:51.559]                         has_future <- base::requireNamespace("future", 
[17:43:51.559]                           quietly = TRUE)
[17:43:51.559]                         if (has_future) {
[17:43:51.559]                           ns <- base::getNamespace("future")
[17:43:51.559]                           version <- ns[[".package"]][["version"]]
[17:43:51.559]                           if (is.null(version)) 
[17:43:51.559]                             version <- utils::packageVersion("future")
[17:43:51.559]                         }
[17:43:51.559]                         else {
[17:43:51.559]                           version <- NULL
[17:43:51.559]                         }
[17:43:51.559]                         if (!has_future || version < "1.8.0") {
[17:43:51.559]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:51.559]                             "", base::R.version$version.string), 
[17:43:51.559]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:51.559]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:51.559]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:51.559]                               "release", "version")], collapse = " "), 
[17:43:51.559]                             hostname = base::Sys.info()[["nodename"]])
[17:43:51.559]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:51.559]                             info)
[17:43:51.559]                           info <- base::paste(info, collapse = "; ")
[17:43:51.559]                           if (!has_future) {
[17:43:51.559]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:51.559]                               info)
[17:43:51.559]                           }
[17:43:51.559]                           else {
[17:43:51.559]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:51.559]                               info, version)
[17:43:51.559]                           }
[17:43:51.559]                           base::stop(msg)
[17:43:51.559]                         }
[17:43:51.559]                       })
[17:43:51.559]                     }
[17:43:51.559]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:51.559]                     base::options(mc.cores = 1L)
[17:43:51.559]                   }
[17:43:51.559]                   options(future.plan = NULL)
[17:43:51.559]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:51.559]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:51.559]                 }
[17:43:51.559]                 ...future.workdir <- getwd()
[17:43:51.559]             }
[17:43:51.559]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:51.559]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:51.559]         }
[17:43:51.559]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:51.559]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:51.559]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:51.559]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:51.559]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:51.559]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:51.559]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:51.559]             base::names(...future.oldOptions))
[17:43:51.559]     }
[17:43:51.559]     if (FALSE) {
[17:43:51.559]     }
[17:43:51.559]     else {
[17:43:51.559]         if (TRUE) {
[17:43:51.559]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:51.559]                 open = "w")
[17:43:51.559]         }
[17:43:51.559]         else {
[17:43:51.559]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:51.559]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:51.559]         }
[17:43:51.559]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:51.559]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:51.559]             base::sink(type = "output", split = FALSE)
[17:43:51.559]             base::close(...future.stdout)
[17:43:51.559]         }, add = TRUE)
[17:43:51.559]     }
[17:43:51.559]     ...future.frame <- base::sys.nframe()
[17:43:51.559]     ...future.conditions <- base::list()
[17:43:51.559]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:51.559]     if (FALSE) {
[17:43:51.559]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:51.559]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:51.559]     }
[17:43:51.559]     ...future.result <- base::tryCatch({
[17:43:51.559]         base::withCallingHandlers({
[17:43:51.559]             ...future.value <- base::withVisible(base::local({
[17:43:51.559]                 ...future.makeSendCondition <- local({
[17:43:51.559]                   sendCondition <- NULL
[17:43:51.559]                   function(frame = 1L) {
[17:43:51.559]                     if (is.function(sendCondition)) 
[17:43:51.559]                       return(sendCondition)
[17:43:51.559]                     ns <- getNamespace("parallel")
[17:43:51.559]                     if (exists("sendData", mode = "function", 
[17:43:51.559]                       envir = ns)) {
[17:43:51.559]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:51.559]                         envir = ns)
[17:43:51.559]                       envir <- sys.frame(frame)
[17:43:51.559]                       master <- NULL
[17:43:51.559]                       while (!identical(envir, .GlobalEnv) && 
[17:43:51.559]                         !identical(envir, emptyenv())) {
[17:43:51.559]                         if (exists("master", mode = "list", envir = envir, 
[17:43:51.559]                           inherits = FALSE)) {
[17:43:51.559]                           master <- get("master", mode = "list", 
[17:43:51.559]                             envir = envir, inherits = FALSE)
[17:43:51.559]                           if (inherits(master, c("SOCKnode", 
[17:43:51.559]                             "SOCK0node"))) {
[17:43:51.559]                             sendCondition <<- function(cond) {
[17:43:51.559]                               data <- list(type = "VALUE", value = cond, 
[17:43:51.559]                                 success = TRUE)
[17:43:51.559]                               parallel_sendData(master, data)
[17:43:51.559]                             }
[17:43:51.559]                             return(sendCondition)
[17:43:51.559]                           }
[17:43:51.559]                         }
[17:43:51.559]                         frame <- frame + 1L
[17:43:51.559]                         envir <- sys.frame(frame)
[17:43:51.559]                       }
[17:43:51.559]                     }
[17:43:51.559]                     sendCondition <<- function(cond) NULL
[17:43:51.559]                   }
[17:43:51.559]                 })
[17:43:51.559]                 withCallingHandlers({
[17:43:51.559]                   {
[17:43:51.559]                     Sys.sleep(0.5)
[17:43:51.559]                     list(a = 1, b = 42L)
[17:43:51.559]                   }
[17:43:51.559]                 }, immediateCondition = function(cond) {
[17:43:51.559]                   sendCondition <- ...future.makeSendCondition()
[17:43:51.559]                   sendCondition(cond)
[17:43:51.559]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:51.559]                   {
[17:43:51.559]                     inherits <- base::inherits
[17:43:51.559]                     invokeRestart <- base::invokeRestart
[17:43:51.559]                     is.null <- base::is.null
[17:43:51.559]                     muffled <- FALSE
[17:43:51.559]                     if (inherits(cond, "message")) {
[17:43:51.559]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:51.559]                       if (muffled) 
[17:43:51.559]                         invokeRestart("muffleMessage")
[17:43:51.559]                     }
[17:43:51.559]                     else if (inherits(cond, "warning")) {
[17:43:51.559]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:51.559]                       if (muffled) 
[17:43:51.559]                         invokeRestart("muffleWarning")
[17:43:51.559]                     }
[17:43:51.559]                     else if (inherits(cond, "condition")) {
[17:43:51.559]                       if (!is.null(pattern)) {
[17:43:51.559]                         computeRestarts <- base::computeRestarts
[17:43:51.559]                         grepl <- base::grepl
[17:43:51.559]                         restarts <- computeRestarts(cond)
[17:43:51.559]                         for (restart in restarts) {
[17:43:51.559]                           name <- restart$name
[17:43:51.559]                           if (is.null(name)) 
[17:43:51.559]                             next
[17:43:51.559]                           if (!grepl(pattern, name)) 
[17:43:51.559]                             next
[17:43:51.559]                           invokeRestart(restart)
[17:43:51.559]                           muffled <- TRUE
[17:43:51.559]                           break
[17:43:51.559]                         }
[17:43:51.559]                       }
[17:43:51.559]                     }
[17:43:51.559]                     invisible(muffled)
[17:43:51.559]                   }
[17:43:51.559]                   muffleCondition(cond)
[17:43:51.559]                 })
[17:43:51.559]             }))
[17:43:51.559]             future::FutureResult(value = ...future.value$value, 
[17:43:51.559]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:51.559]                   ...future.rng), globalenv = if (FALSE) 
[17:43:51.559]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:51.559]                     ...future.globalenv.names))
[17:43:51.559]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:51.559]         }, condition = base::local({
[17:43:51.559]             c <- base::c
[17:43:51.559]             inherits <- base::inherits
[17:43:51.559]             invokeRestart <- base::invokeRestart
[17:43:51.559]             length <- base::length
[17:43:51.559]             list <- base::list
[17:43:51.559]             seq.int <- base::seq.int
[17:43:51.559]             signalCondition <- base::signalCondition
[17:43:51.559]             sys.calls <- base::sys.calls
[17:43:51.559]             `[[` <- base::`[[`
[17:43:51.559]             `+` <- base::`+`
[17:43:51.559]             `<<-` <- base::`<<-`
[17:43:51.559]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:51.559]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:51.559]                   3L)]
[17:43:51.559]             }
[17:43:51.559]             function(cond) {
[17:43:51.559]                 is_error <- inherits(cond, "error")
[17:43:51.559]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:51.559]                   NULL)
[17:43:51.559]                 if (is_error) {
[17:43:51.559]                   sessionInformation <- function() {
[17:43:51.559]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:51.559]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:51.559]                       search = base::search(), system = base::Sys.info())
[17:43:51.559]                   }
[17:43:51.559]                   ...future.conditions[[length(...future.conditions) + 
[17:43:51.559]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:51.559]                     cond$call), session = sessionInformation(), 
[17:43:51.559]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:51.559]                   signalCondition(cond)
[17:43:51.559]                 }
[17:43:51.559]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:51.559]                 "immediateCondition"))) {
[17:43:51.559]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:51.559]                   ...future.conditions[[length(...future.conditions) + 
[17:43:51.559]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:51.559]                   if (TRUE && !signal) {
[17:43:51.559]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:51.559]                     {
[17:43:51.559]                       inherits <- base::inherits
[17:43:51.559]                       invokeRestart <- base::invokeRestart
[17:43:51.559]                       is.null <- base::is.null
[17:43:51.559]                       muffled <- FALSE
[17:43:51.559]                       if (inherits(cond, "message")) {
[17:43:51.559]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:51.559]                         if (muffled) 
[17:43:51.559]                           invokeRestart("muffleMessage")
[17:43:51.559]                       }
[17:43:51.559]                       else if (inherits(cond, "warning")) {
[17:43:51.559]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:51.559]                         if (muffled) 
[17:43:51.559]                           invokeRestart("muffleWarning")
[17:43:51.559]                       }
[17:43:51.559]                       else if (inherits(cond, "condition")) {
[17:43:51.559]                         if (!is.null(pattern)) {
[17:43:51.559]                           computeRestarts <- base::computeRestarts
[17:43:51.559]                           grepl <- base::grepl
[17:43:51.559]                           restarts <- computeRestarts(cond)
[17:43:51.559]                           for (restart in restarts) {
[17:43:51.559]                             name <- restart$name
[17:43:51.559]                             if (is.null(name)) 
[17:43:51.559]                               next
[17:43:51.559]                             if (!grepl(pattern, name)) 
[17:43:51.559]                               next
[17:43:51.559]                             invokeRestart(restart)
[17:43:51.559]                             muffled <- TRUE
[17:43:51.559]                             break
[17:43:51.559]                           }
[17:43:51.559]                         }
[17:43:51.559]                       }
[17:43:51.559]                       invisible(muffled)
[17:43:51.559]                     }
[17:43:51.559]                     muffleCondition(cond, pattern = "^muffle")
[17:43:51.559]                   }
[17:43:51.559]                 }
[17:43:51.559]                 else {
[17:43:51.559]                   if (TRUE) {
[17:43:51.559]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:51.559]                     {
[17:43:51.559]                       inherits <- base::inherits
[17:43:51.559]                       invokeRestart <- base::invokeRestart
[17:43:51.559]                       is.null <- base::is.null
[17:43:51.559]                       muffled <- FALSE
[17:43:51.559]                       if (inherits(cond, "message")) {
[17:43:51.559]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:51.559]                         if (muffled) 
[17:43:51.559]                           invokeRestart("muffleMessage")
[17:43:51.559]                       }
[17:43:51.559]                       else if (inherits(cond, "warning")) {
[17:43:51.559]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:51.559]                         if (muffled) 
[17:43:51.559]                           invokeRestart("muffleWarning")
[17:43:51.559]                       }
[17:43:51.559]                       else if (inherits(cond, "condition")) {
[17:43:51.559]                         if (!is.null(pattern)) {
[17:43:51.559]                           computeRestarts <- base::computeRestarts
[17:43:51.559]                           grepl <- base::grepl
[17:43:51.559]                           restarts <- computeRestarts(cond)
[17:43:51.559]                           for (restart in restarts) {
[17:43:51.559]                             name <- restart$name
[17:43:51.559]                             if (is.null(name)) 
[17:43:51.559]                               next
[17:43:51.559]                             if (!grepl(pattern, name)) 
[17:43:51.559]                               next
[17:43:51.559]                             invokeRestart(restart)
[17:43:51.559]                             muffled <- TRUE
[17:43:51.559]                             break
[17:43:51.559]                           }
[17:43:51.559]                         }
[17:43:51.559]                       }
[17:43:51.559]                       invisible(muffled)
[17:43:51.559]                     }
[17:43:51.559]                     muffleCondition(cond, pattern = "^muffle")
[17:43:51.559]                   }
[17:43:51.559]                 }
[17:43:51.559]             }
[17:43:51.559]         }))
[17:43:51.559]     }, error = function(ex) {
[17:43:51.559]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:51.559]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:51.559]                 ...future.rng), started = ...future.startTime, 
[17:43:51.559]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:51.559]             version = "1.8"), class = "FutureResult")
[17:43:51.559]     }, finally = {
[17:43:51.559]         if (!identical(...future.workdir, getwd())) 
[17:43:51.559]             setwd(...future.workdir)
[17:43:51.559]         {
[17:43:51.559]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:51.559]                 ...future.oldOptions$nwarnings <- NULL
[17:43:51.559]             }
[17:43:51.559]             base::options(...future.oldOptions)
[17:43:51.559]             if (.Platform$OS.type == "windows") {
[17:43:51.559]                 old_names <- names(...future.oldEnvVars)
[17:43:51.559]                 envs <- base::Sys.getenv()
[17:43:51.559]                 names <- names(envs)
[17:43:51.559]                 common <- intersect(names, old_names)
[17:43:51.559]                 added <- setdiff(names, old_names)
[17:43:51.559]                 removed <- setdiff(old_names, names)
[17:43:51.559]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:51.559]                   envs[common]]
[17:43:51.559]                 NAMES <- toupper(changed)
[17:43:51.559]                 args <- list()
[17:43:51.559]                 for (kk in seq_along(NAMES)) {
[17:43:51.559]                   name <- changed[[kk]]
[17:43:51.559]                   NAME <- NAMES[[kk]]
[17:43:51.559]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:51.559]                     next
[17:43:51.559]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:51.559]                 }
[17:43:51.559]                 NAMES <- toupper(added)
[17:43:51.559]                 for (kk in seq_along(NAMES)) {
[17:43:51.559]                   name <- added[[kk]]
[17:43:51.559]                   NAME <- NAMES[[kk]]
[17:43:51.559]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:51.559]                     next
[17:43:51.559]                   args[[name]] <- ""
[17:43:51.559]                 }
[17:43:51.559]                 NAMES <- toupper(removed)
[17:43:51.559]                 for (kk in seq_along(NAMES)) {
[17:43:51.559]                   name <- removed[[kk]]
[17:43:51.559]                   NAME <- NAMES[[kk]]
[17:43:51.559]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:51.559]                     next
[17:43:51.559]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:51.559]                 }
[17:43:51.559]                 if (length(args) > 0) 
[17:43:51.559]                   base::do.call(base::Sys.setenv, args = args)
[17:43:51.559]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:51.559]             }
[17:43:51.559]             else {
[17:43:51.559]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:51.559]             }
[17:43:51.559]             {
[17:43:51.559]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:51.559]                   0L) {
[17:43:51.559]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:51.559]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:51.559]                   base::options(opts)
[17:43:51.559]                 }
[17:43:51.559]                 {
[17:43:51.559]                   {
[17:43:51.559]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:51.559]                     NULL
[17:43:51.559]                   }
[17:43:51.559]                   options(future.plan = NULL)
[17:43:51.559]                   if (is.na(NA_character_)) 
[17:43:51.559]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:51.559]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:51.559]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:51.559]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:51.559]                     envir = parent.frame()) 
[17:43:51.559]                   {
[17:43:51.559]                     if (is.function(workers)) 
[17:43:51.559]                       workers <- workers()
[17:43:51.559]                     workers <- structure(as.integer(workers), 
[17:43:51.559]                       class = class(workers))
[17:43:51.559]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:51.559]                       workers >= 1)
[17:43:51.559]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:51.559]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:51.559]                     }
[17:43:51.559]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:51.559]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:51.559]                       envir = envir)
[17:43:51.559]                     if (!future$lazy) 
[17:43:51.559]                       future <- run(future)
[17:43:51.559]                     invisible(future)
[17:43:51.559]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:51.559]                 }
[17:43:51.559]             }
[17:43:51.559]         }
[17:43:51.559]     })
[17:43:51.559]     if (TRUE) {
[17:43:51.559]         base::sink(type = "output", split = FALSE)
[17:43:51.559]         if (TRUE) {
[17:43:51.559]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:51.559]         }
[17:43:51.559]         else {
[17:43:51.559]             ...future.result["stdout"] <- base::list(NULL)
[17:43:51.559]         }
[17:43:51.559]         base::close(...future.stdout)
[17:43:51.559]         ...future.stdout <- NULL
[17:43:51.559]     }
[17:43:51.559]     ...future.result$conditions <- ...future.conditions
[17:43:51.559]     ...future.result$finished <- base::Sys.time()
[17:43:51.559]     ...future.result
[17:43:51.559] }
[17:43:51.563] MultisessionFuture started
[17:43:51.566] - Launch lazy future ... done
[17:43:51.566] run() for ‘MultisessionFuture’ ... done
[17:43:52.109] receiveMessageFromWorker() for ClusterFuture ...
[17:43:52.109] - Validating connection of MultisessionFuture
[17:43:52.109] - received message: FutureResult
[17:43:52.109] - Received FutureResult
[17:43:52.110] - Erased future from FutureRegistry
[17:43:52.110] result() for ClusterFuture ...
[17:43:52.110] - result already collected: FutureResult
[17:43:52.110] result() for ClusterFuture ... done
[17:43:52.110] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:52.110] resolve() on list ...
[17:43:52.110]  recursive: 1
[17:43:52.110]  length: 2
[17:43:52.110]  elements: ‘a’, ‘b’
[17:43:52.110]  length: 1 (resolved future 1)
[17:43:52.111]  length: 0 (resolved future 2)
[17:43:52.111] resolve() on list ... DONE
[17:43:52.111] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[17:43:52.111] getGlobalsAndPackages() ...
[17:43:52.111] Searching for globals...
[17:43:52.112] - globals found: [2] ‘list’, ‘stop’
[17:43:52.112] Searching for globals ... DONE
[17:43:52.112] Resolving globals: FALSE
[17:43:52.112] 
[17:43:52.112] 
[17:43:52.112] getGlobalsAndPackages() ... DONE
[17:43:52.113] run() for ‘Future’ ...
[17:43:52.113] - state: ‘created’
[17:43:52.113] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:52.128] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:52.128] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:52.128]   - Field: ‘node’
[17:43:52.128]   - Field: ‘label’
[17:43:52.128]   - Field: ‘local’
[17:43:52.128]   - Field: ‘owner’
[17:43:52.128]   - Field: ‘envir’
[17:43:52.128]   - Field: ‘workers’
[17:43:52.128]   - Field: ‘packages’
[17:43:52.128]   - Field: ‘gc’
[17:43:52.129]   - Field: ‘conditions’
[17:43:52.129]   - Field: ‘persistent’
[17:43:52.129]   - Field: ‘expr’
[17:43:52.129]   - Field: ‘uuid’
[17:43:52.129]   - Field: ‘seed’
[17:43:52.129]   - Field: ‘version’
[17:43:52.129]   - Field: ‘result’
[17:43:52.129]   - Field: ‘asynchronous’
[17:43:52.129]   - Field: ‘calls’
[17:43:52.129]   - Field: ‘globals’
[17:43:52.129]   - Field: ‘stdout’
[17:43:52.130]   - Field: ‘earlySignal’
[17:43:52.130]   - Field: ‘lazy’
[17:43:52.130]   - Field: ‘state’
[17:43:52.130] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:52.130] - Launch lazy future ...
[17:43:52.130] Packages needed by the future expression (n = 0): <none>
[17:43:52.130] Packages needed by future strategies (n = 0): <none>
[17:43:52.131] {
[17:43:52.131]     {
[17:43:52.131]         {
[17:43:52.131]             ...future.startTime <- base::Sys.time()
[17:43:52.131]             {
[17:43:52.131]                 {
[17:43:52.131]                   {
[17:43:52.131]                     {
[17:43:52.131]                       base::local({
[17:43:52.131]                         has_future <- base::requireNamespace("future", 
[17:43:52.131]                           quietly = TRUE)
[17:43:52.131]                         if (has_future) {
[17:43:52.131]                           ns <- base::getNamespace("future")
[17:43:52.131]                           version <- ns[[".package"]][["version"]]
[17:43:52.131]                           if (is.null(version)) 
[17:43:52.131]                             version <- utils::packageVersion("future")
[17:43:52.131]                         }
[17:43:52.131]                         else {
[17:43:52.131]                           version <- NULL
[17:43:52.131]                         }
[17:43:52.131]                         if (!has_future || version < "1.8.0") {
[17:43:52.131]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:52.131]                             "", base::R.version$version.string), 
[17:43:52.131]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:52.131]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:52.131]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:52.131]                               "release", "version")], collapse = " "), 
[17:43:52.131]                             hostname = base::Sys.info()[["nodename"]])
[17:43:52.131]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:52.131]                             info)
[17:43:52.131]                           info <- base::paste(info, collapse = "; ")
[17:43:52.131]                           if (!has_future) {
[17:43:52.131]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:52.131]                               info)
[17:43:52.131]                           }
[17:43:52.131]                           else {
[17:43:52.131]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:52.131]                               info, version)
[17:43:52.131]                           }
[17:43:52.131]                           base::stop(msg)
[17:43:52.131]                         }
[17:43:52.131]                       })
[17:43:52.131]                     }
[17:43:52.131]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:52.131]                     base::options(mc.cores = 1L)
[17:43:52.131]                   }
[17:43:52.131]                   options(future.plan = NULL)
[17:43:52.131]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.131]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:52.131]                 }
[17:43:52.131]                 ...future.workdir <- getwd()
[17:43:52.131]             }
[17:43:52.131]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:52.131]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:52.131]         }
[17:43:52.131]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:52.131]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:52.131]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:52.131]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:52.131]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:52.131]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:52.131]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:52.131]             base::names(...future.oldOptions))
[17:43:52.131]     }
[17:43:52.131]     if (FALSE) {
[17:43:52.131]     }
[17:43:52.131]     else {
[17:43:52.131]         if (TRUE) {
[17:43:52.131]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:52.131]                 open = "w")
[17:43:52.131]         }
[17:43:52.131]         else {
[17:43:52.131]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:52.131]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:52.131]         }
[17:43:52.131]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:52.131]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:52.131]             base::sink(type = "output", split = FALSE)
[17:43:52.131]             base::close(...future.stdout)
[17:43:52.131]         }, add = TRUE)
[17:43:52.131]     }
[17:43:52.131]     ...future.frame <- base::sys.nframe()
[17:43:52.131]     ...future.conditions <- base::list()
[17:43:52.131]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:52.131]     if (FALSE) {
[17:43:52.131]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:52.131]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:52.131]     }
[17:43:52.131]     ...future.result <- base::tryCatch({
[17:43:52.131]         base::withCallingHandlers({
[17:43:52.131]             ...future.value <- base::withVisible(base::local({
[17:43:52.131]                 ...future.makeSendCondition <- local({
[17:43:52.131]                   sendCondition <- NULL
[17:43:52.131]                   function(frame = 1L) {
[17:43:52.131]                     if (is.function(sendCondition)) 
[17:43:52.131]                       return(sendCondition)
[17:43:52.131]                     ns <- getNamespace("parallel")
[17:43:52.131]                     if (exists("sendData", mode = "function", 
[17:43:52.131]                       envir = ns)) {
[17:43:52.131]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:52.131]                         envir = ns)
[17:43:52.131]                       envir <- sys.frame(frame)
[17:43:52.131]                       master <- NULL
[17:43:52.131]                       while (!identical(envir, .GlobalEnv) && 
[17:43:52.131]                         !identical(envir, emptyenv())) {
[17:43:52.131]                         if (exists("master", mode = "list", envir = envir, 
[17:43:52.131]                           inherits = FALSE)) {
[17:43:52.131]                           master <- get("master", mode = "list", 
[17:43:52.131]                             envir = envir, inherits = FALSE)
[17:43:52.131]                           if (inherits(master, c("SOCKnode", 
[17:43:52.131]                             "SOCK0node"))) {
[17:43:52.131]                             sendCondition <<- function(cond) {
[17:43:52.131]                               data <- list(type = "VALUE", value = cond, 
[17:43:52.131]                                 success = TRUE)
[17:43:52.131]                               parallel_sendData(master, data)
[17:43:52.131]                             }
[17:43:52.131]                             return(sendCondition)
[17:43:52.131]                           }
[17:43:52.131]                         }
[17:43:52.131]                         frame <- frame + 1L
[17:43:52.131]                         envir <- sys.frame(frame)
[17:43:52.131]                       }
[17:43:52.131]                     }
[17:43:52.131]                     sendCondition <<- function(cond) NULL
[17:43:52.131]                   }
[17:43:52.131]                 })
[17:43:52.131]                 withCallingHandlers({
[17:43:52.131]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:43:52.131]                 }, immediateCondition = function(cond) {
[17:43:52.131]                   sendCondition <- ...future.makeSendCondition()
[17:43:52.131]                   sendCondition(cond)
[17:43:52.131]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.131]                   {
[17:43:52.131]                     inherits <- base::inherits
[17:43:52.131]                     invokeRestart <- base::invokeRestart
[17:43:52.131]                     is.null <- base::is.null
[17:43:52.131]                     muffled <- FALSE
[17:43:52.131]                     if (inherits(cond, "message")) {
[17:43:52.131]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:52.131]                       if (muffled) 
[17:43:52.131]                         invokeRestart("muffleMessage")
[17:43:52.131]                     }
[17:43:52.131]                     else if (inherits(cond, "warning")) {
[17:43:52.131]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:52.131]                       if (muffled) 
[17:43:52.131]                         invokeRestart("muffleWarning")
[17:43:52.131]                     }
[17:43:52.131]                     else if (inherits(cond, "condition")) {
[17:43:52.131]                       if (!is.null(pattern)) {
[17:43:52.131]                         computeRestarts <- base::computeRestarts
[17:43:52.131]                         grepl <- base::grepl
[17:43:52.131]                         restarts <- computeRestarts(cond)
[17:43:52.131]                         for (restart in restarts) {
[17:43:52.131]                           name <- restart$name
[17:43:52.131]                           if (is.null(name)) 
[17:43:52.131]                             next
[17:43:52.131]                           if (!grepl(pattern, name)) 
[17:43:52.131]                             next
[17:43:52.131]                           invokeRestart(restart)
[17:43:52.131]                           muffled <- TRUE
[17:43:52.131]                           break
[17:43:52.131]                         }
[17:43:52.131]                       }
[17:43:52.131]                     }
[17:43:52.131]                     invisible(muffled)
[17:43:52.131]                   }
[17:43:52.131]                   muffleCondition(cond)
[17:43:52.131]                 })
[17:43:52.131]             }))
[17:43:52.131]             future::FutureResult(value = ...future.value$value, 
[17:43:52.131]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.131]                   ...future.rng), globalenv = if (FALSE) 
[17:43:52.131]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:52.131]                     ...future.globalenv.names))
[17:43:52.131]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:52.131]         }, condition = base::local({
[17:43:52.131]             c <- base::c
[17:43:52.131]             inherits <- base::inherits
[17:43:52.131]             invokeRestart <- base::invokeRestart
[17:43:52.131]             length <- base::length
[17:43:52.131]             list <- base::list
[17:43:52.131]             seq.int <- base::seq.int
[17:43:52.131]             signalCondition <- base::signalCondition
[17:43:52.131]             sys.calls <- base::sys.calls
[17:43:52.131]             `[[` <- base::`[[`
[17:43:52.131]             `+` <- base::`+`
[17:43:52.131]             `<<-` <- base::`<<-`
[17:43:52.131]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:52.131]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:52.131]                   3L)]
[17:43:52.131]             }
[17:43:52.131]             function(cond) {
[17:43:52.131]                 is_error <- inherits(cond, "error")
[17:43:52.131]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:52.131]                   NULL)
[17:43:52.131]                 if (is_error) {
[17:43:52.131]                   sessionInformation <- function() {
[17:43:52.131]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:52.131]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:52.131]                       search = base::search(), system = base::Sys.info())
[17:43:52.131]                   }
[17:43:52.131]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.131]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:52.131]                     cond$call), session = sessionInformation(), 
[17:43:52.131]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:52.131]                   signalCondition(cond)
[17:43:52.131]                 }
[17:43:52.131]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:52.131]                 "immediateCondition"))) {
[17:43:52.131]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:52.131]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.131]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:52.131]                   if (TRUE && !signal) {
[17:43:52.131]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.131]                     {
[17:43:52.131]                       inherits <- base::inherits
[17:43:52.131]                       invokeRestart <- base::invokeRestart
[17:43:52.131]                       is.null <- base::is.null
[17:43:52.131]                       muffled <- FALSE
[17:43:52.131]                       if (inherits(cond, "message")) {
[17:43:52.131]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.131]                         if (muffled) 
[17:43:52.131]                           invokeRestart("muffleMessage")
[17:43:52.131]                       }
[17:43:52.131]                       else if (inherits(cond, "warning")) {
[17:43:52.131]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.131]                         if (muffled) 
[17:43:52.131]                           invokeRestart("muffleWarning")
[17:43:52.131]                       }
[17:43:52.131]                       else if (inherits(cond, "condition")) {
[17:43:52.131]                         if (!is.null(pattern)) {
[17:43:52.131]                           computeRestarts <- base::computeRestarts
[17:43:52.131]                           grepl <- base::grepl
[17:43:52.131]                           restarts <- computeRestarts(cond)
[17:43:52.131]                           for (restart in restarts) {
[17:43:52.131]                             name <- restart$name
[17:43:52.131]                             if (is.null(name)) 
[17:43:52.131]                               next
[17:43:52.131]                             if (!grepl(pattern, name)) 
[17:43:52.131]                               next
[17:43:52.131]                             invokeRestart(restart)
[17:43:52.131]                             muffled <- TRUE
[17:43:52.131]                             break
[17:43:52.131]                           }
[17:43:52.131]                         }
[17:43:52.131]                       }
[17:43:52.131]                       invisible(muffled)
[17:43:52.131]                     }
[17:43:52.131]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.131]                   }
[17:43:52.131]                 }
[17:43:52.131]                 else {
[17:43:52.131]                   if (TRUE) {
[17:43:52.131]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.131]                     {
[17:43:52.131]                       inherits <- base::inherits
[17:43:52.131]                       invokeRestart <- base::invokeRestart
[17:43:52.131]                       is.null <- base::is.null
[17:43:52.131]                       muffled <- FALSE
[17:43:52.131]                       if (inherits(cond, "message")) {
[17:43:52.131]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.131]                         if (muffled) 
[17:43:52.131]                           invokeRestart("muffleMessage")
[17:43:52.131]                       }
[17:43:52.131]                       else if (inherits(cond, "warning")) {
[17:43:52.131]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.131]                         if (muffled) 
[17:43:52.131]                           invokeRestart("muffleWarning")
[17:43:52.131]                       }
[17:43:52.131]                       else if (inherits(cond, "condition")) {
[17:43:52.131]                         if (!is.null(pattern)) {
[17:43:52.131]                           computeRestarts <- base::computeRestarts
[17:43:52.131]                           grepl <- base::grepl
[17:43:52.131]                           restarts <- computeRestarts(cond)
[17:43:52.131]                           for (restart in restarts) {
[17:43:52.131]                             name <- restart$name
[17:43:52.131]                             if (is.null(name)) 
[17:43:52.131]                               next
[17:43:52.131]                             if (!grepl(pattern, name)) 
[17:43:52.131]                               next
[17:43:52.131]                             invokeRestart(restart)
[17:43:52.131]                             muffled <- TRUE
[17:43:52.131]                             break
[17:43:52.131]                           }
[17:43:52.131]                         }
[17:43:52.131]                       }
[17:43:52.131]                       invisible(muffled)
[17:43:52.131]                     }
[17:43:52.131]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.131]                   }
[17:43:52.131]                 }
[17:43:52.131]             }
[17:43:52.131]         }))
[17:43:52.131]     }, error = function(ex) {
[17:43:52.131]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:52.131]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.131]                 ...future.rng), started = ...future.startTime, 
[17:43:52.131]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:52.131]             version = "1.8"), class = "FutureResult")
[17:43:52.131]     }, finally = {
[17:43:52.131]         if (!identical(...future.workdir, getwd())) 
[17:43:52.131]             setwd(...future.workdir)
[17:43:52.131]         {
[17:43:52.131]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:52.131]                 ...future.oldOptions$nwarnings <- NULL
[17:43:52.131]             }
[17:43:52.131]             base::options(...future.oldOptions)
[17:43:52.131]             if (.Platform$OS.type == "windows") {
[17:43:52.131]                 old_names <- names(...future.oldEnvVars)
[17:43:52.131]                 envs <- base::Sys.getenv()
[17:43:52.131]                 names <- names(envs)
[17:43:52.131]                 common <- intersect(names, old_names)
[17:43:52.131]                 added <- setdiff(names, old_names)
[17:43:52.131]                 removed <- setdiff(old_names, names)
[17:43:52.131]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:52.131]                   envs[common]]
[17:43:52.131]                 NAMES <- toupper(changed)
[17:43:52.131]                 args <- list()
[17:43:52.131]                 for (kk in seq_along(NAMES)) {
[17:43:52.131]                   name <- changed[[kk]]
[17:43:52.131]                   NAME <- NAMES[[kk]]
[17:43:52.131]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.131]                     next
[17:43:52.131]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.131]                 }
[17:43:52.131]                 NAMES <- toupper(added)
[17:43:52.131]                 for (kk in seq_along(NAMES)) {
[17:43:52.131]                   name <- added[[kk]]
[17:43:52.131]                   NAME <- NAMES[[kk]]
[17:43:52.131]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.131]                     next
[17:43:52.131]                   args[[name]] <- ""
[17:43:52.131]                 }
[17:43:52.131]                 NAMES <- toupper(removed)
[17:43:52.131]                 for (kk in seq_along(NAMES)) {
[17:43:52.131]                   name <- removed[[kk]]
[17:43:52.131]                   NAME <- NAMES[[kk]]
[17:43:52.131]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.131]                     next
[17:43:52.131]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.131]                 }
[17:43:52.131]                 if (length(args) > 0) 
[17:43:52.131]                   base::do.call(base::Sys.setenv, args = args)
[17:43:52.131]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:52.131]             }
[17:43:52.131]             else {
[17:43:52.131]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:52.131]             }
[17:43:52.131]             {
[17:43:52.131]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:52.131]                   0L) {
[17:43:52.131]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:52.131]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:52.131]                   base::options(opts)
[17:43:52.131]                 }
[17:43:52.131]                 {
[17:43:52.131]                   {
[17:43:52.131]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:52.131]                     NULL
[17:43:52.131]                   }
[17:43:52.131]                   options(future.plan = NULL)
[17:43:52.131]                   if (is.na(NA_character_)) 
[17:43:52.131]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.131]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:52.131]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:52.131]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:52.131]                     envir = parent.frame()) 
[17:43:52.131]                   {
[17:43:52.131]                     if (is.function(workers)) 
[17:43:52.131]                       workers <- workers()
[17:43:52.131]                     workers <- structure(as.integer(workers), 
[17:43:52.131]                       class = class(workers))
[17:43:52.131]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:52.131]                       workers >= 1)
[17:43:52.131]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:52.131]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:52.131]                     }
[17:43:52.131]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:52.131]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:52.131]                       envir = envir)
[17:43:52.131]                     if (!future$lazy) 
[17:43:52.131]                       future <- run(future)
[17:43:52.131]                     invisible(future)
[17:43:52.131]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:52.131]                 }
[17:43:52.131]             }
[17:43:52.131]         }
[17:43:52.131]     })
[17:43:52.131]     if (TRUE) {
[17:43:52.131]         base::sink(type = "output", split = FALSE)
[17:43:52.131]         if (TRUE) {
[17:43:52.131]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:52.131]         }
[17:43:52.131]         else {
[17:43:52.131]             ...future.result["stdout"] <- base::list(NULL)
[17:43:52.131]         }
[17:43:52.131]         base::close(...future.stdout)
[17:43:52.131]         ...future.stdout <- NULL
[17:43:52.131]     }
[17:43:52.131]     ...future.result$conditions <- ...future.conditions
[17:43:52.131]     ...future.result$finished <- base::Sys.time()
[17:43:52.131]     ...future.result
[17:43:52.131] }
[17:43:52.134] MultisessionFuture started
[17:43:52.134] - Launch lazy future ... done
[17:43:52.134] run() for ‘MultisessionFuture’ ... done
[17:43:52.180] receiveMessageFromWorker() for ClusterFuture ...
[17:43:52.181] - Validating connection of MultisessionFuture
[17:43:52.181] - received message: FutureResult
[17:43:52.181] - Received FutureResult
[17:43:52.181] - Erased future from FutureRegistry
[17:43:52.181] result() for ClusterFuture ...
[17:43:52.181] - result already collected: FutureResult
[17:43:52.182] result() for ClusterFuture ... done
[17:43:52.182] signalConditions() ...
[17:43:52.182]  - include = ‘immediateCondition’
[17:43:52.182]  - exclude = 
[17:43:52.182]  - resignal = FALSE
[17:43:52.182]  - Number of conditions: 1
[17:43:52.182] signalConditions() ... done
[17:43:52.182] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:52.182] A MultisessionFuture was resolved
[17:43:52.182] getGlobalsAndPackages() ...
[17:43:52.182] Searching for globals...
[17:43:52.183] - globals found: [2] ‘list’, ‘stop’
[17:43:52.183] Searching for globals ... DONE
[17:43:52.183] Resolving globals: FALSE
[17:43:52.184] 
[17:43:52.184] 
[17:43:52.184] getGlobalsAndPackages() ... DONE
[17:43:52.184] run() for ‘Future’ ...
[17:43:52.184] - state: ‘created’
[17:43:52.184] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:52.200] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:52.200] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:52.200]   - Field: ‘node’
[17:43:52.200]   - Field: ‘label’
[17:43:52.200]   - Field: ‘local’
[17:43:52.200]   - Field: ‘owner’
[17:43:52.200]   - Field: ‘envir’
[17:43:52.200]   - Field: ‘workers’
[17:43:52.200]   - Field: ‘packages’
[17:43:52.201]   - Field: ‘gc’
[17:43:52.201]   - Field: ‘conditions’
[17:43:52.201]   - Field: ‘persistent’
[17:43:52.201]   - Field: ‘expr’
[17:43:52.201]   - Field: ‘uuid’
[17:43:52.201]   - Field: ‘seed’
[17:43:52.201]   - Field: ‘version’
[17:43:52.201]   - Field: ‘result’
[17:43:52.201]   - Field: ‘asynchronous’
[17:43:52.201]   - Field: ‘calls’
[17:43:52.201]   - Field: ‘globals’
[17:43:52.202]   - Field: ‘stdout’
[17:43:52.202]   - Field: ‘earlySignal’
[17:43:52.202]   - Field: ‘lazy’
[17:43:52.202]   - Field: ‘state’
[17:43:52.202] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:52.202] - Launch lazy future ...
[17:43:52.202] Packages needed by the future expression (n = 0): <none>
[17:43:52.202] Packages needed by future strategies (n = 0): <none>
[17:43:52.203] {
[17:43:52.203]     {
[17:43:52.203]         {
[17:43:52.203]             ...future.startTime <- base::Sys.time()
[17:43:52.203]             {
[17:43:52.203]                 {
[17:43:52.203]                   {
[17:43:52.203]                     {
[17:43:52.203]                       base::local({
[17:43:52.203]                         has_future <- base::requireNamespace("future", 
[17:43:52.203]                           quietly = TRUE)
[17:43:52.203]                         if (has_future) {
[17:43:52.203]                           ns <- base::getNamespace("future")
[17:43:52.203]                           version <- ns[[".package"]][["version"]]
[17:43:52.203]                           if (is.null(version)) 
[17:43:52.203]                             version <- utils::packageVersion("future")
[17:43:52.203]                         }
[17:43:52.203]                         else {
[17:43:52.203]                           version <- NULL
[17:43:52.203]                         }
[17:43:52.203]                         if (!has_future || version < "1.8.0") {
[17:43:52.203]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:52.203]                             "", base::R.version$version.string), 
[17:43:52.203]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:52.203]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:52.203]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:52.203]                               "release", "version")], collapse = " "), 
[17:43:52.203]                             hostname = base::Sys.info()[["nodename"]])
[17:43:52.203]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:52.203]                             info)
[17:43:52.203]                           info <- base::paste(info, collapse = "; ")
[17:43:52.203]                           if (!has_future) {
[17:43:52.203]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:52.203]                               info)
[17:43:52.203]                           }
[17:43:52.203]                           else {
[17:43:52.203]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:52.203]                               info, version)
[17:43:52.203]                           }
[17:43:52.203]                           base::stop(msg)
[17:43:52.203]                         }
[17:43:52.203]                       })
[17:43:52.203]                     }
[17:43:52.203]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:52.203]                     base::options(mc.cores = 1L)
[17:43:52.203]                   }
[17:43:52.203]                   options(future.plan = NULL)
[17:43:52.203]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.203]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:52.203]                 }
[17:43:52.203]                 ...future.workdir <- getwd()
[17:43:52.203]             }
[17:43:52.203]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:52.203]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:52.203]         }
[17:43:52.203]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:52.203]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:52.203]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:52.203]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:52.203]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:52.203]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:52.203]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:52.203]             base::names(...future.oldOptions))
[17:43:52.203]     }
[17:43:52.203]     if (FALSE) {
[17:43:52.203]     }
[17:43:52.203]     else {
[17:43:52.203]         if (TRUE) {
[17:43:52.203]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:52.203]                 open = "w")
[17:43:52.203]         }
[17:43:52.203]         else {
[17:43:52.203]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:52.203]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:52.203]         }
[17:43:52.203]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:52.203]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:52.203]             base::sink(type = "output", split = FALSE)
[17:43:52.203]             base::close(...future.stdout)
[17:43:52.203]         }, add = TRUE)
[17:43:52.203]     }
[17:43:52.203]     ...future.frame <- base::sys.nframe()
[17:43:52.203]     ...future.conditions <- base::list()
[17:43:52.203]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:52.203]     if (FALSE) {
[17:43:52.203]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:52.203]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:52.203]     }
[17:43:52.203]     ...future.result <- base::tryCatch({
[17:43:52.203]         base::withCallingHandlers({
[17:43:52.203]             ...future.value <- base::withVisible(base::local({
[17:43:52.203]                 ...future.makeSendCondition <- local({
[17:43:52.203]                   sendCondition <- NULL
[17:43:52.203]                   function(frame = 1L) {
[17:43:52.203]                     if (is.function(sendCondition)) 
[17:43:52.203]                       return(sendCondition)
[17:43:52.203]                     ns <- getNamespace("parallel")
[17:43:52.203]                     if (exists("sendData", mode = "function", 
[17:43:52.203]                       envir = ns)) {
[17:43:52.203]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:52.203]                         envir = ns)
[17:43:52.203]                       envir <- sys.frame(frame)
[17:43:52.203]                       master <- NULL
[17:43:52.203]                       while (!identical(envir, .GlobalEnv) && 
[17:43:52.203]                         !identical(envir, emptyenv())) {
[17:43:52.203]                         if (exists("master", mode = "list", envir = envir, 
[17:43:52.203]                           inherits = FALSE)) {
[17:43:52.203]                           master <- get("master", mode = "list", 
[17:43:52.203]                             envir = envir, inherits = FALSE)
[17:43:52.203]                           if (inherits(master, c("SOCKnode", 
[17:43:52.203]                             "SOCK0node"))) {
[17:43:52.203]                             sendCondition <<- function(cond) {
[17:43:52.203]                               data <- list(type = "VALUE", value = cond, 
[17:43:52.203]                                 success = TRUE)
[17:43:52.203]                               parallel_sendData(master, data)
[17:43:52.203]                             }
[17:43:52.203]                             return(sendCondition)
[17:43:52.203]                           }
[17:43:52.203]                         }
[17:43:52.203]                         frame <- frame + 1L
[17:43:52.203]                         envir <- sys.frame(frame)
[17:43:52.203]                       }
[17:43:52.203]                     }
[17:43:52.203]                     sendCondition <<- function(cond) NULL
[17:43:52.203]                   }
[17:43:52.203]                 })
[17:43:52.203]                 withCallingHandlers({
[17:43:52.203]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:43:52.203]                 }, immediateCondition = function(cond) {
[17:43:52.203]                   sendCondition <- ...future.makeSendCondition()
[17:43:52.203]                   sendCondition(cond)
[17:43:52.203]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.203]                   {
[17:43:52.203]                     inherits <- base::inherits
[17:43:52.203]                     invokeRestart <- base::invokeRestart
[17:43:52.203]                     is.null <- base::is.null
[17:43:52.203]                     muffled <- FALSE
[17:43:52.203]                     if (inherits(cond, "message")) {
[17:43:52.203]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:52.203]                       if (muffled) 
[17:43:52.203]                         invokeRestart("muffleMessage")
[17:43:52.203]                     }
[17:43:52.203]                     else if (inherits(cond, "warning")) {
[17:43:52.203]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:52.203]                       if (muffled) 
[17:43:52.203]                         invokeRestart("muffleWarning")
[17:43:52.203]                     }
[17:43:52.203]                     else if (inherits(cond, "condition")) {
[17:43:52.203]                       if (!is.null(pattern)) {
[17:43:52.203]                         computeRestarts <- base::computeRestarts
[17:43:52.203]                         grepl <- base::grepl
[17:43:52.203]                         restarts <- computeRestarts(cond)
[17:43:52.203]                         for (restart in restarts) {
[17:43:52.203]                           name <- restart$name
[17:43:52.203]                           if (is.null(name)) 
[17:43:52.203]                             next
[17:43:52.203]                           if (!grepl(pattern, name)) 
[17:43:52.203]                             next
[17:43:52.203]                           invokeRestart(restart)
[17:43:52.203]                           muffled <- TRUE
[17:43:52.203]                           break
[17:43:52.203]                         }
[17:43:52.203]                       }
[17:43:52.203]                     }
[17:43:52.203]                     invisible(muffled)
[17:43:52.203]                   }
[17:43:52.203]                   muffleCondition(cond)
[17:43:52.203]                 })
[17:43:52.203]             }))
[17:43:52.203]             future::FutureResult(value = ...future.value$value, 
[17:43:52.203]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.203]                   ...future.rng), globalenv = if (FALSE) 
[17:43:52.203]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:52.203]                     ...future.globalenv.names))
[17:43:52.203]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:52.203]         }, condition = base::local({
[17:43:52.203]             c <- base::c
[17:43:52.203]             inherits <- base::inherits
[17:43:52.203]             invokeRestart <- base::invokeRestart
[17:43:52.203]             length <- base::length
[17:43:52.203]             list <- base::list
[17:43:52.203]             seq.int <- base::seq.int
[17:43:52.203]             signalCondition <- base::signalCondition
[17:43:52.203]             sys.calls <- base::sys.calls
[17:43:52.203]             `[[` <- base::`[[`
[17:43:52.203]             `+` <- base::`+`
[17:43:52.203]             `<<-` <- base::`<<-`
[17:43:52.203]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:52.203]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:52.203]                   3L)]
[17:43:52.203]             }
[17:43:52.203]             function(cond) {
[17:43:52.203]                 is_error <- inherits(cond, "error")
[17:43:52.203]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:52.203]                   NULL)
[17:43:52.203]                 if (is_error) {
[17:43:52.203]                   sessionInformation <- function() {
[17:43:52.203]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:52.203]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:52.203]                       search = base::search(), system = base::Sys.info())
[17:43:52.203]                   }
[17:43:52.203]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.203]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:52.203]                     cond$call), session = sessionInformation(), 
[17:43:52.203]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:52.203]                   signalCondition(cond)
[17:43:52.203]                 }
[17:43:52.203]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:52.203]                 "immediateCondition"))) {
[17:43:52.203]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:52.203]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.203]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:52.203]                   if (TRUE && !signal) {
[17:43:52.203]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.203]                     {
[17:43:52.203]                       inherits <- base::inherits
[17:43:52.203]                       invokeRestart <- base::invokeRestart
[17:43:52.203]                       is.null <- base::is.null
[17:43:52.203]                       muffled <- FALSE
[17:43:52.203]                       if (inherits(cond, "message")) {
[17:43:52.203]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.203]                         if (muffled) 
[17:43:52.203]                           invokeRestart("muffleMessage")
[17:43:52.203]                       }
[17:43:52.203]                       else if (inherits(cond, "warning")) {
[17:43:52.203]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.203]                         if (muffled) 
[17:43:52.203]                           invokeRestart("muffleWarning")
[17:43:52.203]                       }
[17:43:52.203]                       else if (inherits(cond, "condition")) {
[17:43:52.203]                         if (!is.null(pattern)) {
[17:43:52.203]                           computeRestarts <- base::computeRestarts
[17:43:52.203]                           grepl <- base::grepl
[17:43:52.203]                           restarts <- computeRestarts(cond)
[17:43:52.203]                           for (restart in restarts) {
[17:43:52.203]                             name <- restart$name
[17:43:52.203]                             if (is.null(name)) 
[17:43:52.203]                               next
[17:43:52.203]                             if (!grepl(pattern, name)) 
[17:43:52.203]                               next
[17:43:52.203]                             invokeRestart(restart)
[17:43:52.203]                             muffled <- TRUE
[17:43:52.203]                             break
[17:43:52.203]                           }
[17:43:52.203]                         }
[17:43:52.203]                       }
[17:43:52.203]                       invisible(muffled)
[17:43:52.203]                     }
[17:43:52.203]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.203]                   }
[17:43:52.203]                 }
[17:43:52.203]                 else {
[17:43:52.203]                   if (TRUE) {
[17:43:52.203]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.203]                     {
[17:43:52.203]                       inherits <- base::inherits
[17:43:52.203]                       invokeRestart <- base::invokeRestart
[17:43:52.203]                       is.null <- base::is.null
[17:43:52.203]                       muffled <- FALSE
[17:43:52.203]                       if (inherits(cond, "message")) {
[17:43:52.203]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.203]                         if (muffled) 
[17:43:52.203]                           invokeRestart("muffleMessage")
[17:43:52.203]                       }
[17:43:52.203]                       else if (inherits(cond, "warning")) {
[17:43:52.203]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.203]                         if (muffled) 
[17:43:52.203]                           invokeRestart("muffleWarning")
[17:43:52.203]                       }
[17:43:52.203]                       else if (inherits(cond, "condition")) {
[17:43:52.203]                         if (!is.null(pattern)) {
[17:43:52.203]                           computeRestarts <- base::computeRestarts
[17:43:52.203]                           grepl <- base::grepl
[17:43:52.203]                           restarts <- computeRestarts(cond)
[17:43:52.203]                           for (restart in restarts) {
[17:43:52.203]                             name <- restart$name
[17:43:52.203]                             if (is.null(name)) 
[17:43:52.203]                               next
[17:43:52.203]                             if (!grepl(pattern, name)) 
[17:43:52.203]                               next
[17:43:52.203]                             invokeRestart(restart)
[17:43:52.203]                             muffled <- TRUE
[17:43:52.203]                             break
[17:43:52.203]                           }
[17:43:52.203]                         }
[17:43:52.203]                       }
[17:43:52.203]                       invisible(muffled)
[17:43:52.203]                     }
[17:43:52.203]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.203]                   }
[17:43:52.203]                 }
[17:43:52.203]             }
[17:43:52.203]         }))
[17:43:52.203]     }, error = function(ex) {
[17:43:52.203]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:52.203]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.203]                 ...future.rng), started = ...future.startTime, 
[17:43:52.203]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:52.203]             version = "1.8"), class = "FutureResult")
[17:43:52.203]     }, finally = {
[17:43:52.203]         if (!identical(...future.workdir, getwd())) 
[17:43:52.203]             setwd(...future.workdir)
[17:43:52.203]         {
[17:43:52.203]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:52.203]                 ...future.oldOptions$nwarnings <- NULL
[17:43:52.203]             }
[17:43:52.203]             base::options(...future.oldOptions)
[17:43:52.203]             if (.Platform$OS.type == "windows") {
[17:43:52.203]                 old_names <- names(...future.oldEnvVars)
[17:43:52.203]                 envs <- base::Sys.getenv()
[17:43:52.203]                 names <- names(envs)
[17:43:52.203]                 common <- intersect(names, old_names)
[17:43:52.203]                 added <- setdiff(names, old_names)
[17:43:52.203]                 removed <- setdiff(old_names, names)
[17:43:52.203]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:52.203]                   envs[common]]
[17:43:52.203]                 NAMES <- toupper(changed)
[17:43:52.203]                 args <- list()
[17:43:52.203]                 for (kk in seq_along(NAMES)) {
[17:43:52.203]                   name <- changed[[kk]]
[17:43:52.203]                   NAME <- NAMES[[kk]]
[17:43:52.203]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.203]                     next
[17:43:52.203]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.203]                 }
[17:43:52.203]                 NAMES <- toupper(added)
[17:43:52.203]                 for (kk in seq_along(NAMES)) {
[17:43:52.203]                   name <- added[[kk]]
[17:43:52.203]                   NAME <- NAMES[[kk]]
[17:43:52.203]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.203]                     next
[17:43:52.203]                   args[[name]] <- ""
[17:43:52.203]                 }
[17:43:52.203]                 NAMES <- toupper(removed)
[17:43:52.203]                 for (kk in seq_along(NAMES)) {
[17:43:52.203]                   name <- removed[[kk]]
[17:43:52.203]                   NAME <- NAMES[[kk]]
[17:43:52.203]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.203]                     next
[17:43:52.203]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.203]                 }
[17:43:52.203]                 if (length(args) > 0) 
[17:43:52.203]                   base::do.call(base::Sys.setenv, args = args)
[17:43:52.203]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:52.203]             }
[17:43:52.203]             else {
[17:43:52.203]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:52.203]             }
[17:43:52.203]             {
[17:43:52.203]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:52.203]                   0L) {
[17:43:52.203]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:52.203]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:52.203]                   base::options(opts)
[17:43:52.203]                 }
[17:43:52.203]                 {
[17:43:52.203]                   {
[17:43:52.203]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:52.203]                     NULL
[17:43:52.203]                   }
[17:43:52.203]                   options(future.plan = NULL)
[17:43:52.203]                   if (is.na(NA_character_)) 
[17:43:52.203]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.203]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:52.203]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:52.203]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:52.203]                     envir = parent.frame()) 
[17:43:52.203]                   {
[17:43:52.203]                     if (is.function(workers)) 
[17:43:52.203]                       workers <- workers()
[17:43:52.203]                     workers <- structure(as.integer(workers), 
[17:43:52.203]                       class = class(workers))
[17:43:52.203]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:52.203]                       workers >= 1)
[17:43:52.203]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:52.203]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:52.203]                     }
[17:43:52.203]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:52.203]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:52.203]                       envir = envir)
[17:43:52.203]                     if (!future$lazy) 
[17:43:52.203]                       future <- run(future)
[17:43:52.203]                     invisible(future)
[17:43:52.203]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:52.203]                 }
[17:43:52.203]             }
[17:43:52.203]         }
[17:43:52.203]     })
[17:43:52.203]     if (TRUE) {
[17:43:52.203]         base::sink(type = "output", split = FALSE)
[17:43:52.203]         if (TRUE) {
[17:43:52.203]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:52.203]         }
[17:43:52.203]         else {
[17:43:52.203]             ...future.result["stdout"] <- base::list(NULL)
[17:43:52.203]         }
[17:43:52.203]         base::close(...future.stdout)
[17:43:52.203]         ...future.stdout <- NULL
[17:43:52.203]     }
[17:43:52.203]     ...future.result$conditions <- ...future.conditions
[17:43:52.203]     ...future.result$finished <- base::Sys.time()
[17:43:52.203]     ...future.result
[17:43:52.203] }
[17:43:52.206] MultisessionFuture started
[17:43:52.206] - Launch lazy future ... done
[17:43:52.206] run() for ‘MultisessionFuture’ ... done
[17:43:52.252] receiveMessageFromWorker() for ClusterFuture ...
[17:43:52.252] - Validating connection of MultisessionFuture
[17:43:52.253] - received message: FutureResult
[17:43:52.253] - Received FutureResult
[17:43:52.253] - Erased future from FutureRegistry
[17:43:52.253] result() for ClusterFuture ...
[17:43:52.253] - result already collected: FutureResult
[17:43:52.253] result() for ClusterFuture ... done
[17:43:52.253] signalConditions() ...
[17:43:52.253]  - include = ‘immediateCondition’
[17:43:52.253]  - exclude = 
[17:43:52.254]  - resignal = FALSE
[17:43:52.254]  - Number of conditions: 1
[17:43:52.254] signalConditions() ... done
[17:43:52.254] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:52.254] A MultisessionFuture was resolved
- result = TRUE, recursive = 2 ... DONE
- result = TRUE, recursive = Inf ...
[17:43:52.254] getGlobalsAndPackages() ...
[17:43:52.254] Searching for globals...
[17:43:52.255] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:43:52.256] Searching for globals ... DONE
[17:43:52.256] Resolving globals: FALSE
[17:43:52.256] 
[17:43:52.256] 
[17:43:52.256] getGlobalsAndPackages() ... DONE
[17:43:52.256] run() for ‘Future’ ...
[17:43:52.257] - state: ‘created’
[17:43:52.257] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:52.271] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:52.271] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:52.271]   - Field: ‘node’
[17:43:52.271]   - Field: ‘label’
[17:43:52.271]   - Field: ‘local’
[17:43:52.272]   - Field: ‘owner’
[17:43:52.272]   - Field: ‘envir’
[17:43:52.272]   - Field: ‘workers’
[17:43:52.272]   - Field: ‘packages’
[17:43:52.272]   - Field: ‘gc’
[17:43:52.272]   - Field: ‘conditions’
[17:43:52.272]   - Field: ‘persistent’
[17:43:52.272]   - Field: ‘expr’
[17:43:52.272]   - Field: ‘uuid’
[17:43:52.272]   - Field: ‘seed’
[17:43:52.273]   - Field: ‘version’
[17:43:52.273]   - Field: ‘result’
[17:43:52.273]   - Field: ‘asynchronous’
[17:43:52.273]   - Field: ‘calls’
[17:43:52.273]   - Field: ‘globals’
[17:43:52.273]   - Field: ‘stdout’
[17:43:52.273]   - Field: ‘earlySignal’
[17:43:52.273]   - Field: ‘lazy’
[17:43:52.273]   - Field: ‘state’
[17:43:52.273] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:52.273] - Launch lazy future ...
[17:43:52.274] Packages needed by the future expression (n = 0): <none>
[17:43:52.274] Packages needed by future strategies (n = 0): <none>
[17:43:52.274] {
[17:43:52.274]     {
[17:43:52.274]         {
[17:43:52.274]             ...future.startTime <- base::Sys.time()
[17:43:52.274]             {
[17:43:52.274]                 {
[17:43:52.274]                   {
[17:43:52.274]                     {
[17:43:52.274]                       base::local({
[17:43:52.274]                         has_future <- base::requireNamespace("future", 
[17:43:52.274]                           quietly = TRUE)
[17:43:52.274]                         if (has_future) {
[17:43:52.274]                           ns <- base::getNamespace("future")
[17:43:52.274]                           version <- ns[[".package"]][["version"]]
[17:43:52.274]                           if (is.null(version)) 
[17:43:52.274]                             version <- utils::packageVersion("future")
[17:43:52.274]                         }
[17:43:52.274]                         else {
[17:43:52.274]                           version <- NULL
[17:43:52.274]                         }
[17:43:52.274]                         if (!has_future || version < "1.8.0") {
[17:43:52.274]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:52.274]                             "", base::R.version$version.string), 
[17:43:52.274]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:52.274]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:52.274]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:52.274]                               "release", "version")], collapse = " "), 
[17:43:52.274]                             hostname = base::Sys.info()[["nodename"]])
[17:43:52.274]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:52.274]                             info)
[17:43:52.274]                           info <- base::paste(info, collapse = "; ")
[17:43:52.274]                           if (!has_future) {
[17:43:52.274]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:52.274]                               info)
[17:43:52.274]                           }
[17:43:52.274]                           else {
[17:43:52.274]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:52.274]                               info, version)
[17:43:52.274]                           }
[17:43:52.274]                           base::stop(msg)
[17:43:52.274]                         }
[17:43:52.274]                       })
[17:43:52.274]                     }
[17:43:52.274]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:52.274]                     base::options(mc.cores = 1L)
[17:43:52.274]                   }
[17:43:52.274]                   options(future.plan = NULL)
[17:43:52.274]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.274]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:52.274]                 }
[17:43:52.274]                 ...future.workdir <- getwd()
[17:43:52.274]             }
[17:43:52.274]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:52.274]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:52.274]         }
[17:43:52.274]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:52.274]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:52.274]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:52.274]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:52.274]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:52.274]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:52.274]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:52.274]             base::names(...future.oldOptions))
[17:43:52.274]     }
[17:43:52.274]     if (FALSE) {
[17:43:52.274]     }
[17:43:52.274]     else {
[17:43:52.274]         if (TRUE) {
[17:43:52.274]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:52.274]                 open = "w")
[17:43:52.274]         }
[17:43:52.274]         else {
[17:43:52.274]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:52.274]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:52.274]         }
[17:43:52.274]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:52.274]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:52.274]             base::sink(type = "output", split = FALSE)
[17:43:52.274]             base::close(...future.stdout)
[17:43:52.274]         }, add = TRUE)
[17:43:52.274]     }
[17:43:52.274]     ...future.frame <- base::sys.nframe()
[17:43:52.274]     ...future.conditions <- base::list()
[17:43:52.274]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:52.274]     if (FALSE) {
[17:43:52.274]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:52.274]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:52.274]     }
[17:43:52.274]     ...future.result <- base::tryCatch({
[17:43:52.274]         base::withCallingHandlers({
[17:43:52.274]             ...future.value <- base::withVisible(base::local({
[17:43:52.274]                 ...future.makeSendCondition <- local({
[17:43:52.274]                   sendCondition <- NULL
[17:43:52.274]                   function(frame = 1L) {
[17:43:52.274]                     if (is.function(sendCondition)) 
[17:43:52.274]                       return(sendCondition)
[17:43:52.274]                     ns <- getNamespace("parallel")
[17:43:52.274]                     if (exists("sendData", mode = "function", 
[17:43:52.274]                       envir = ns)) {
[17:43:52.274]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:52.274]                         envir = ns)
[17:43:52.274]                       envir <- sys.frame(frame)
[17:43:52.274]                       master <- NULL
[17:43:52.274]                       while (!identical(envir, .GlobalEnv) && 
[17:43:52.274]                         !identical(envir, emptyenv())) {
[17:43:52.274]                         if (exists("master", mode = "list", envir = envir, 
[17:43:52.274]                           inherits = FALSE)) {
[17:43:52.274]                           master <- get("master", mode = "list", 
[17:43:52.274]                             envir = envir, inherits = FALSE)
[17:43:52.274]                           if (inherits(master, c("SOCKnode", 
[17:43:52.274]                             "SOCK0node"))) {
[17:43:52.274]                             sendCondition <<- function(cond) {
[17:43:52.274]                               data <- list(type = "VALUE", value = cond, 
[17:43:52.274]                                 success = TRUE)
[17:43:52.274]                               parallel_sendData(master, data)
[17:43:52.274]                             }
[17:43:52.274]                             return(sendCondition)
[17:43:52.274]                           }
[17:43:52.274]                         }
[17:43:52.274]                         frame <- frame + 1L
[17:43:52.274]                         envir <- sys.frame(frame)
[17:43:52.274]                       }
[17:43:52.274]                     }
[17:43:52.274]                     sendCondition <<- function(cond) NULL
[17:43:52.274]                   }
[17:43:52.274]                 })
[17:43:52.274]                 withCallingHandlers({
[17:43:52.274]                   {
[17:43:52.274]                     Sys.sleep(0.5)
[17:43:52.274]                     list(a = 1, b = 42L)
[17:43:52.274]                   }
[17:43:52.274]                 }, immediateCondition = function(cond) {
[17:43:52.274]                   sendCondition <- ...future.makeSendCondition()
[17:43:52.274]                   sendCondition(cond)
[17:43:52.274]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.274]                   {
[17:43:52.274]                     inherits <- base::inherits
[17:43:52.274]                     invokeRestart <- base::invokeRestart
[17:43:52.274]                     is.null <- base::is.null
[17:43:52.274]                     muffled <- FALSE
[17:43:52.274]                     if (inherits(cond, "message")) {
[17:43:52.274]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:52.274]                       if (muffled) 
[17:43:52.274]                         invokeRestart("muffleMessage")
[17:43:52.274]                     }
[17:43:52.274]                     else if (inherits(cond, "warning")) {
[17:43:52.274]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:52.274]                       if (muffled) 
[17:43:52.274]                         invokeRestart("muffleWarning")
[17:43:52.274]                     }
[17:43:52.274]                     else if (inherits(cond, "condition")) {
[17:43:52.274]                       if (!is.null(pattern)) {
[17:43:52.274]                         computeRestarts <- base::computeRestarts
[17:43:52.274]                         grepl <- base::grepl
[17:43:52.274]                         restarts <- computeRestarts(cond)
[17:43:52.274]                         for (restart in restarts) {
[17:43:52.274]                           name <- restart$name
[17:43:52.274]                           if (is.null(name)) 
[17:43:52.274]                             next
[17:43:52.274]                           if (!grepl(pattern, name)) 
[17:43:52.274]                             next
[17:43:52.274]                           invokeRestart(restart)
[17:43:52.274]                           muffled <- TRUE
[17:43:52.274]                           break
[17:43:52.274]                         }
[17:43:52.274]                       }
[17:43:52.274]                     }
[17:43:52.274]                     invisible(muffled)
[17:43:52.274]                   }
[17:43:52.274]                   muffleCondition(cond)
[17:43:52.274]                 })
[17:43:52.274]             }))
[17:43:52.274]             future::FutureResult(value = ...future.value$value, 
[17:43:52.274]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.274]                   ...future.rng), globalenv = if (FALSE) 
[17:43:52.274]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:52.274]                     ...future.globalenv.names))
[17:43:52.274]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:52.274]         }, condition = base::local({
[17:43:52.274]             c <- base::c
[17:43:52.274]             inherits <- base::inherits
[17:43:52.274]             invokeRestart <- base::invokeRestart
[17:43:52.274]             length <- base::length
[17:43:52.274]             list <- base::list
[17:43:52.274]             seq.int <- base::seq.int
[17:43:52.274]             signalCondition <- base::signalCondition
[17:43:52.274]             sys.calls <- base::sys.calls
[17:43:52.274]             `[[` <- base::`[[`
[17:43:52.274]             `+` <- base::`+`
[17:43:52.274]             `<<-` <- base::`<<-`
[17:43:52.274]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:52.274]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:52.274]                   3L)]
[17:43:52.274]             }
[17:43:52.274]             function(cond) {
[17:43:52.274]                 is_error <- inherits(cond, "error")
[17:43:52.274]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:52.274]                   NULL)
[17:43:52.274]                 if (is_error) {
[17:43:52.274]                   sessionInformation <- function() {
[17:43:52.274]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:52.274]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:52.274]                       search = base::search(), system = base::Sys.info())
[17:43:52.274]                   }
[17:43:52.274]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.274]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:52.274]                     cond$call), session = sessionInformation(), 
[17:43:52.274]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:52.274]                   signalCondition(cond)
[17:43:52.274]                 }
[17:43:52.274]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:52.274]                 "immediateCondition"))) {
[17:43:52.274]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:52.274]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.274]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:52.274]                   if (TRUE && !signal) {
[17:43:52.274]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.274]                     {
[17:43:52.274]                       inherits <- base::inherits
[17:43:52.274]                       invokeRestart <- base::invokeRestart
[17:43:52.274]                       is.null <- base::is.null
[17:43:52.274]                       muffled <- FALSE
[17:43:52.274]                       if (inherits(cond, "message")) {
[17:43:52.274]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.274]                         if (muffled) 
[17:43:52.274]                           invokeRestart("muffleMessage")
[17:43:52.274]                       }
[17:43:52.274]                       else if (inherits(cond, "warning")) {
[17:43:52.274]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.274]                         if (muffled) 
[17:43:52.274]                           invokeRestart("muffleWarning")
[17:43:52.274]                       }
[17:43:52.274]                       else if (inherits(cond, "condition")) {
[17:43:52.274]                         if (!is.null(pattern)) {
[17:43:52.274]                           computeRestarts <- base::computeRestarts
[17:43:52.274]                           grepl <- base::grepl
[17:43:52.274]                           restarts <- computeRestarts(cond)
[17:43:52.274]                           for (restart in restarts) {
[17:43:52.274]                             name <- restart$name
[17:43:52.274]                             if (is.null(name)) 
[17:43:52.274]                               next
[17:43:52.274]                             if (!grepl(pattern, name)) 
[17:43:52.274]                               next
[17:43:52.274]                             invokeRestart(restart)
[17:43:52.274]                             muffled <- TRUE
[17:43:52.274]                             break
[17:43:52.274]                           }
[17:43:52.274]                         }
[17:43:52.274]                       }
[17:43:52.274]                       invisible(muffled)
[17:43:52.274]                     }
[17:43:52.274]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.274]                   }
[17:43:52.274]                 }
[17:43:52.274]                 else {
[17:43:52.274]                   if (TRUE) {
[17:43:52.274]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.274]                     {
[17:43:52.274]                       inherits <- base::inherits
[17:43:52.274]                       invokeRestart <- base::invokeRestart
[17:43:52.274]                       is.null <- base::is.null
[17:43:52.274]                       muffled <- FALSE
[17:43:52.274]                       if (inherits(cond, "message")) {
[17:43:52.274]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.274]                         if (muffled) 
[17:43:52.274]                           invokeRestart("muffleMessage")
[17:43:52.274]                       }
[17:43:52.274]                       else if (inherits(cond, "warning")) {
[17:43:52.274]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.274]                         if (muffled) 
[17:43:52.274]                           invokeRestart("muffleWarning")
[17:43:52.274]                       }
[17:43:52.274]                       else if (inherits(cond, "condition")) {
[17:43:52.274]                         if (!is.null(pattern)) {
[17:43:52.274]                           computeRestarts <- base::computeRestarts
[17:43:52.274]                           grepl <- base::grepl
[17:43:52.274]                           restarts <- computeRestarts(cond)
[17:43:52.274]                           for (restart in restarts) {
[17:43:52.274]                             name <- restart$name
[17:43:52.274]                             if (is.null(name)) 
[17:43:52.274]                               next
[17:43:52.274]                             if (!grepl(pattern, name)) 
[17:43:52.274]                               next
[17:43:52.274]                             invokeRestart(restart)
[17:43:52.274]                             muffled <- TRUE
[17:43:52.274]                             break
[17:43:52.274]                           }
[17:43:52.274]                         }
[17:43:52.274]                       }
[17:43:52.274]                       invisible(muffled)
[17:43:52.274]                     }
[17:43:52.274]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.274]                   }
[17:43:52.274]                 }
[17:43:52.274]             }
[17:43:52.274]         }))
[17:43:52.274]     }, error = function(ex) {
[17:43:52.274]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:52.274]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.274]                 ...future.rng), started = ...future.startTime, 
[17:43:52.274]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:52.274]             version = "1.8"), class = "FutureResult")
[17:43:52.274]     }, finally = {
[17:43:52.274]         if (!identical(...future.workdir, getwd())) 
[17:43:52.274]             setwd(...future.workdir)
[17:43:52.274]         {
[17:43:52.274]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:52.274]                 ...future.oldOptions$nwarnings <- NULL
[17:43:52.274]             }
[17:43:52.274]             base::options(...future.oldOptions)
[17:43:52.274]             if (.Platform$OS.type == "windows") {
[17:43:52.274]                 old_names <- names(...future.oldEnvVars)
[17:43:52.274]                 envs <- base::Sys.getenv()
[17:43:52.274]                 names <- names(envs)
[17:43:52.274]                 common <- intersect(names, old_names)
[17:43:52.274]                 added <- setdiff(names, old_names)
[17:43:52.274]                 removed <- setdiff(old_names, names)
[17:43:52.274]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:52.274]                   envs[common]]
[17:43:52.274]                 NAMES <- toupper(changed)
[17:43:52.274]                 args <- list()
[17:43:52.274]                 for (kk in seq_along(NAMES)) {
[17:43:52.274]                   name <- changed[[kk]]
[17:43:52.274]                   NAME <- NAMES[[kk]]
[17:43:52.274]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.274]                     next
[17:43:52.274]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.274]                 }
[17:43:52.274]                 NAMES <- toupper(added)
[17:43:52.274]                 for (kk in seq_along(NAMES)) {
[17:43:52.274]                   name <- added[[kk]]
[17:43:52.274]                   NAME <- NAMES[[kk]]
[17:43:52.274]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.274]                     next
[17:43:52.274]                   args[[name]] <- ""
[17:43:52.274]                 }
[17:43:52.274]                 NAMES <- toupper(removed)
[17:43:52.274]                 for (kk in seq_along(NAMES)) {
[17:43:52.274]                   name <- removed[[kk]]
[17:43:52.274]                   NAME <- NAMES[[kk]]
[17:43:52.274]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.274]                     next
[17:43:52.274]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.274]                 }
[17:43:52.274]                 if (length(args) > 0) 
[17:43:52.274]                   base::do.call(base::Sys.setenv, args = args)
[17:43:52.274]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:52.274]             }
[17:43:52.274]             else {
[17:43:52.274]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:52.274]             }
[17:43:52.274]             {
[17:43:52.274]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:52.274]                   0L) {
[17:43:52.274]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:52.274]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:52.274]                   base::options(opts)
[17:43:52.274]                 }
[17:43:52.274]                 {
[17:43:52.274]                   {
[17:43:52.274]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:52.274]                     NULL
[17:43:52.274]                   }
[17:43:52.274]                   options(future.plan = NULL)
[17:43:52.274]                   if (is.na(NA_character_)) 
[17:43:52.274]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.274]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:52.274]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:52.274]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:52.274]                     envir = parent.frame()) 
[17:43:52.274]                   {
[17:43:52.274]                     if (is.function(workers)) 
[17:43:52.274]                       workers <- workers()
[17:43:52.274]                     workers <- structure(as.integer(workers), 
[17:43:52.274]                       class = class(workers))
[17:43:52.274]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:52.274]                       workers >= 1)
[17:43:52.274]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:52.274]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:52.274]                     }
[17:43:52.274]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:52.274]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:52.274]                       envir = envir)
[17:43:52.274]                     if (!future$lazy) 
[17:43:52.274]                       future <- run(future)
[17:43:52.274]                     invisible(future)
[17:43:52.274]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:52.274]                 }
[17:43:52.274]             }
[17:43:52.274]         }
[17:43:52.274]     })
[17:43:52.274]     if (TRUE) {
[17:43:52.274]         base::sink(type = "output", split = FALSE)
[17:43:52.274]         if (TRUE) {
[17:43:52.274]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:52.274]         }
[17:43:52.274]         else {
[17:43:52.274]             ...future.result["stdout"] <- base::list(NULL)
[17:43:52.274]         }
[17:43:52.274]         base::close(...future.stdout)
[17:43:52.274]         ...future.stdout <- NULL
[17:43:52.274]     }
[17:43:52.274]     ...future.result$conditions <- ...future.conditions
[17:43:52.274]     ...future.result$finished <- base::Sys.time()
[17:43:52.274]     ...future.result
[17:43:52.274] }
[17:43:52.278] MultisessionFuture started
[17:43:52.278] - Launch lazy future ... done
[17:43:52.278] run() for ‘MultisessionFuture’ ... done
[17:43:52.825] receiveMessageFromWorker() for ClusterFuture ...
[17:43:52.825] - Validating connection of MultisessionFuture
[17:43:52.825] - received message: FutureResult
[17:43:52.825] - Received FutureResult
[17:43:52.825] - Erased future from FutureRegistry
[17:43:52.826] result() for ClusterFuture ...
[17:43:52.826] - result already collected: FutureResult
[17:43:52.826] result() for ClusterFuture ... done
[17:43:52.826] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:52.826] resolve() on list ...
[17:43:52.826]  recursive: Inf
[17:43:52.826]  length: 2
[17:43:52.826]  elements: ‘a’, ‘b’
[17:43:52.826]  length: 1 (resolved future 1)
[17:43:52.826]  length: 0 (resolved future 2)
[17:43:52.827] resolve() on list ... DONE
[17:43:52.827] A MultisessionFuture was resolved (and resolved itself)
[17:43:52.827] getGlobalsAndPackages() ...
[17:43:52.827] Searching for globals...
[17:43:52.828] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:43:52.828] Searching for globals ... DONE
[17:43:52.828] Resolving globals: FALSE
[17:43:52.829] 
[17:43:52.829] 
[17:43:52.829] getGlobalsAndPackages() ... DONE
[17:43:52.829] run() for ‘Future’ ...
[17:43:52.829] - state: ‘created’
[17:43:52.829] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:52.844] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:52.844] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:52.844]   - Field: ‘node’
[17:43:52.844]   - Field: ‘label’
[17:43:52.844]   - Field: ‘local’
[17:43:52.844]   - Field: ‘owner’
[17:43:52.844]   - Field: ‘envir’
[17:43:52.844]   - Field: ‘workers’
[17:43:52.844]   - Field: ‘packages’
[17:43:52.845]   - Field: ‘gc’
[17:43:52.845]   - Field: ‘conditions’
[17:43:52.845]   - Field: ‘persistent’
[17:43:52.845]   - Field: ‘expr’
[17:43:52.845]   - Field: ‘uuid’
[17:43:52.845]   - Field: ‘seed’
[17:43:52.845]   - Field: ‘version’
[17:43:52.845]   - Field: ‘result’
[17:43:52.845]   - Field: ‘asynchronous’
[17:43:52.845]   - Field: ‘calls’
[17:43:52.845]   - Field: ‘globals’
[17:43:52.846]   - Field: ‘stdout’
[17:43:52.846]   - Field: ‘earlySignal’
[17:43:52.846]   - Field: ‘lazy’
[17:43:52.846]   - Field: ‘state’
[17:43:52.846] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:52.846] - Launch lazy future ...
[17:43:52.846] Packages needed by the future expression (n = 0): <none>
[17:43:52.846] Packages needed by future strategies (n = 0): <none>
[17:43:52.847] {
[17:43:52.847]     {
[17:43:52.847]         {
[17:43:52.847]             ...future.startTime <- base::Sys.time()
[17:43:52.847]             {
[17:43:52.847]                 {
[17:43:52.847]                   {
[17:43:52.847]                     {
[17:43:52.847]                       base::local({
[17:43:52.847]                         has_future <- base::requireNamespace("future", 
[17:43:52.847]                           quietly = TRUE)
[17:43:52.847]                         if (has_future) {
[17:43:52.847]                           ns <- base::getNamespace("future")
[17:43:52.847]                           version <- ns[[".package"]][["version"]]
[17:43:52.847]                           if (is.null(version)) 
[17:43:52.847]                             version <- utils::packageVersion("future")
[17:43:52.847]                         }
[17:43:52.847]                         else {
[17:43:52.847]                           version <- NULL
[17:43:52.847]                         }
[17:43:52.847]                         if (!has_future || version < "1.8.0") {
[17:43:52.847]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:52.847]                             "", base::R.version$version.string), 
[17:43:52.847]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:52.847]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:52.847]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:52.847]                               "release", "version")], collapse = " "), 
[17:43:52.847]                             hostname = base::Sys.info()[["nodename"]])
[17:43:52.847]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:52.847]                             info)
[17:43:52.847]                           info <- base::paste(info, collapse = "; ")
[17:43:52.847]                           if (!has_future) {
[17:43:52.847]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:52.847]                               info)
[17:43:52.847]                           }
[17:43:52.847]                           else {
[17:43:52.847]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:52.847]                               info, version)
[17:43:52.847]                           }
[17:43:52.847]                           base::stop(msg)
[17:43:52.847]                         }
[17:43:52.847]                       })
[17:43:52.847]                     }
[17:43:52.847]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:52.847]                     base::options(mc.cores = 1L)
[17:43:52.847]                   }
[17:43:52.847]                   options(future.plan = NULL)
[17:43:52.847]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.847]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:52.847]                 }
[17:43:52.847]                 ...future.workdir <- getwd()
[17:43:52.847]             }
[17:43:52.847]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:52.847]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:52.847]         }
[17:43:52.847]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:52.847]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:52.847]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:52.847]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:52.847]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:52.847]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:52.847]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:52.847]             base::names(...future.oldOptions))
[17:43:52.847]     }
[17:43:52.847]     if (FALSE) {
[17:43:52.847]     }
[17:43:52.847]     else {
[17:43:52.847]         if (TRUE) {
[17:43:52.847]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:52.847]                 open = "w")
[17:43:52.847]         }
[17:43:52.847]         else {
[17:43:52.847]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:52.847]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:52.847]         }
[17:43:52.847]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:52.847]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:52.847]             base::sink(type = "output", split = FALSE)
[17:43:52.847]             base::close(...future.stdout)
[17:43:52.847]         }, add = TRUE)
[17:43:52.847]     }
[17:43:52.847]     ...future.frame <- base::sys.nframe()
[17:43:52.847]     ...future.conditions <- base::list()
[17:43:52.847]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:52.847]     if (FALSE) {
[17:43:52.847]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:52.847]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:52.847]     }
[17:43:52.847]     ...future.result <- base::tryCatch({
[17:43:52.847]         base::withCallingHandlers({
[17:43:52.847]             ...future.value <- base::withVisible(base::local({
[17:43:52.847]                 ...future.makeSendCondition <- local({
[17:43:52.847]                   sendCondition <- NULL
[17:43:52.847]                   function(frame = 1L) {
[17:43:52.847]                     if (is.function(sendCondition)) 
[17:43:52.847]                       return(sendCondition)
[17:43:52.847]                     ns <- getNamespace("parallel")
[17:43:52.847]                     if (exists("sendData", mode = "function", 
[17:43:52.847]                       envir = ns)) {
[17:43:52.847]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:52.847]                         envir = ns)
[17:43:52.847]                       envir <- sys.frame(frame)
[17:43:52.847]                       master <- NULL
[17:43:52.847]                       while (!identical(envir, .GlobalEnv) && 
[17:43:52.847]                         !identical(envir, emptyenv())) {
[17:43:52.847]                         if (exists("master", mode = "list", envir = envir, 
[17:43:52.847]                           inherits = FALSE)) {
[17:43:52.847]                           master <- get("master", mode = "list", 
[17:43:52.847]                             envir = envir, inherits = FALSE)
[17:43:52.847]                           if (inherits(master, c("SOCKnode", 
[17:43:52.847]                             "SOCK0node"))) {
[17:43:52.847]                             sendCondition <<- function(cond) {
[17:43:52.847]                               data <- list(type = "VALUE", value = cond, 
[17:43:52.847]                                 success = TRUE)
[17:43:52.847]                               parallel_sendData(master, data)
[17:43:52.847]                             }
[17:43:52.847]                             return(sendCondition)
[17:43:52.847]                           }
[17:43:52.847]                         }
[17:43:52.847]                         frame <- frame + 1L
[17:43:52.847]                         envir <- sys.frame(frame)
[17:43:52.847]                       }
[17:43:52.847]                     }
[17:43:52.847]                     sendCondition <<- function(cond) NULL
[17:43:52.847]                   }
[17:43:52.847]                 })
[17:43:52.847]                 withCallingHandlers({
[17:43:52.847]                   {
[17:43:52.847]                     Sys.sleep(0.5)
[17:43:52.847]                     list(a = 1, b = 42L)
[17:43:52.847]                   }
[17:43:52.847]                 }, immediateCondition = function(cond) {
[17:43:52.847]                   sendCondition <- ...future.makeSendCondition()
[17:43:52.847]                   sendCondition(cond)
[17:43:52.847]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.847]                   {
[17:43:52.847]                     inherits <- base::inherits
[17:43:52.847]                     invokeRestart <- base::invokeRestart
[17:43:52.847]                     is.null <- base::is.null
[17:43:52.847]                     muffled <- FALSE
[17:43:52.847]                     if (inherits(cond, "message")) {
[17:43:52.847]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:52.847]                       if (muffled) 
[17:43:52.847]                         invokeRestart("muffleMessage")
[17:43:52.847]                     }
[17:43:52.847]                     else if (inherits(cond, "warning")) {
[17:43:52.847]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:52.847]                       if (muffled) 
[17:43:52.847]                         invokeRestart("muffleWarning")
[17:43:52.847]                     }
[17:43:52.847]                     else if (inherits(cond, "condition")) {
[17:43:52.847]                       if (!is.null(pattern)) {
[17:43:52.847]                         computeRestarts <- base::computeRestarts
[17:43:52.847]                         grepl <- base::grepl
[17:43:52.847]                         restarts <- computeRestarts(cond)
[17:43:52.847]                         for (restart in restarts) {
[17:43:52.847]                           name <- restart$name
[17:43:52.847]                           if (is.null(name)) 
[17:43:52.847]                             next
[17:43:52.847]                           if (!grepl(pattern, name)) 
[17:43:52.847]                             next
[17:43:52.847]                           invokeRestart(restart)
[17:43:52.847]                           muffled <- TRUE
[17:43:52.847]                           break
[17:43:52.847]                         }
[17:43:52.847]                       }
[17:43:52.847]                     }
[17:43:52.847]                     invisible(muffled)
[17:43:52.847]                   }
[17:43:52.847]                   muffleCondition(cond)
[17:43:52.847]                 })
[17:43:52.847]             }))
[17:43:52.847]             future::FutureResult(value = ...future.value$value, 
[17:43:52.847]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.847]                   ...future.rng), globalenv = if (FALSE) 
[17:43:52.847]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:52.847]                     ...future.globalenv.names))
[17:43:52.847]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:52.847]         }, condition = base::local({
[17:43:52.847]             c <- base::c
[17:43:52.847]             inherits <- base::inherits
[17:43:52.847]             invokeRestart <- base::invokeRestart
[17:43:52.847]             length <- base::length
[17:43:52.847]             list <- base::list
[17:43:52.847]             seq.int <- base::seq.int
[17:43:52.847]             signalCondition <- base::signalCondition
[17:43:52.847]             sys.calls <- base::sys.calls
[17:43:52.847]             `[[` <- base::`[[`
[17:43:52.847]             `+` <- base::`+`
[17:43:52.847]             `<<-` <- base::`<<-`
[17:43:52.847]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:52.847]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:52.847]                   3L)]
[17:43:52.847]             }
[17:43:52.847]             function(cond) {
[17:43:52.847]                 is_error <- inherits(cond, "error")
[17:43:52.847]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:52.847]                   NULL)
[17:43:52.847]                 if (is_error) {
[17:43:52.847]                   sessionInformation <- function() {
[17:43:52.847]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:52.847]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:52.847]                       search = base::search(), system = base::Sys.info())
[17:43:52.847]                   }
[17:43:52.847]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.847]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:52.847]                     cond$call), session = sessionInformation(), 
[17:43:52.847]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:52.847]                   signalCondition(cond)
[17:43:52.847]                 }
[17:43:52.847]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:52.847]                 "immediateCondition"))) {
[17:43:52.847]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:52.847]                   ...future.conditions[[length(...future.conditions) + 
[17:43:52.847]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:52.847]                   if (TRUE && !signal) {
[17:43:52.847]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.847]                     {
[17:43:52.847]                       inherits <- base::inherits
[17:43:52.847]                       invokeRestart <- base::invokeRestart
[17:43:52.847]                       is.null <- base::is.null
[17:43:52.847]                       muffled <- FALSE
[17:43:52.847]                       if (inherits(cond, "message")) {
[17:43:52.847]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.847]                         if (muffled) 
[17:43:52.847]                           invokeRestart("muffleMessage")
[17:43:52.847]                       }
[17:43:52.847]                       else if (inherits(cond, "warning")) {
[17:43:52.847]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.847]                         if (muffled) 
[17:43:52.847]                           invokeRestart("muffleWarning")
[17:43:52.847]                       }
[17:43:52.847]                       else if (inherits(cond, "condition")) {
[17:43:52.847]                         if (!is.null(pattern)) {
[17:43:52.847]                           computeRestarts <- base::computeRestarts
[17:43:52.847]                           grepl <- base::grepl
[17:43:52.847]                           restarts <- computeRestarts(cond)
[17:43:52.847]                           for (restart in restarts) {
[17:43:52.847]                             name <- restart$name
[17:43:52.847]                             if (is.null(name)) 
[17:43:52.847]                               next
[17:43:52.847]                             if (!grepl(pattern, name)) 
[17:43:52.847]                               next
[17:43:52.847]                             invokeRestart(restart)
[17:43:52.847]                             muffled <- TRUE
[17:43:52.847]                             break
[17:43:52.847]                           }
[17:43:52.847]                         }
[17:43:52.847]                       }
[17:43:52.847]                       invisible(muffled)
[17:43:52.847]                     }
[17:43:52.847]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.847]                   }
[17:43:52.847]                 }
[17:43:52.847]                 else {
[17:43:52.847]                   if (TRUE) {
[17:43:52.847]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:52.847]                     {
[17:43:52.847]                       inherits <- base::inherits
[17:43:52.847]                       invokeRestart <- base::invokeRestart
[17:43:52.847]                       is.null <- base::is.null
[17:43:52.847]                       muffled <- FALSE
[17:43:52.847]                       if (inherits(cond, "message")) {
[17:43:52.847]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:52.847]                         if (muffled) 
[17:43:52.847]                           invokeRestart("muffleMessage")
[17:43:52.847]                       }
[17:43:52.847]                       else if (inherits(cond, "warning")) {
[17:43:52.847]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:52.847]                         if (muffled) 
[17:43:52.847]                           invokeRestart("muffleWarning")
[17:43:52.847]                       }
[17:43:52.847]                       else if (inherits(cond, "condition")) {
[17:43:52.847]                         if (!is.null(pattern)) {
[17:43:52.847]                           computeRestarts <- base::computeRestarts
[17:43:52.847]                           grepl <- base::grepl
[17:43:52.847]                           restarts <- computeRestarts(cond)
[17:43:52.847]                           for (restart in restarts) {
[17:43:52.847]                             name <- restart$name
[17:43:52.847]                             if (is.null(name)) 
[17:43:52.847]                               next
[17:43:52.847]                             if (!grepl(pattern, name)) 
[17:43:52.847]                               next
[17:43:52.847]                             invokeRestart(restart)
[17:43:52.847]                             muffled <- TRUE
[17:43:52.847]                             break
[17:43:52.847]                           }
[17:43:52.847]                         }
[17:43:52.847]                       }
[17:43:52.847]                       invisible(muffled)
[17:43:52.847]                     }
[17:43:52.847]                     muffleCondition(cond, pattern = "^muffle")
[17:43:52.847]                   }
[17:43:52.847]                 }
[17:43:52.847]             }
[17:43:52.847]         }))
[17:43:52.847]     }, error = function(ex) {
[17:43:52.847]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:52.847]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:52.847]                 ...future.rng), started = ...future.startTime, 
[17:43:52.847]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:52.847]             version = "1.8"), class = "FutureResult")
[17:43:52.847]     }, finally = {
[17:43:52.847]         if (!identical(...future.workdir, getwd())) 
[17:43:52.847]             setwd(...future.workdir)
[17:43:52.847]         {
[17:43:52.847]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:52.847]                 ...future.oldOptions$nwarnings <- NULL
[17:43:52.847]             }
[17:43:52.847]             base::options(...future.oldOptions)
[17:43:52.847]             if (.Platform$OS.type == "windows") {
[17:43:52.847]                 old_names <- names(...future.oldEnvVars)
[17:43:52.847]                 envs <- base::Sys.getenv()
[17:43:52.847]                 names <- names(envs)
[17:43:52.847]                 common <- intersect(names, old_names)
[17:43:52.847]                 added <- setdiff(names, old_names)
[17:43:52.847]                 removed <- setdiff(old_names, names)
[17:43:52.847]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:52.847]                   envs[common]]
[17:43:52.847]                 NAMES <- toupper(changed)
[17:43:52.847]                 args <- list()
[17:43:52.847]                 for (kk in seq_along(NAMES)) {
[17:43:52.847]                   name <- changed[[kk]]
[17:43:52.847]                   NAME <- NAMES[[kk]]
[17:43:52.847]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.847]                     next
[17:43:52.847]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.847]                 }
[17:43:52.847]                 NAMES <- toupper(added)
[17:43:52.847]                 for (kk in seq_along(NAMES)) {
[17:43:52.847]                   name <- added[[kk]]
[17:43:52.847]                   NAME <- NAMES[[kk]]
[17:43:52.847]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.847]                     next
[17:43:52.847]                   args[[name]] <- ""
[17:43:52.847]                 }
[17:43:52.847]                 NAMES <- toupper(removed)
[17:43:52.847]                 for (kk in seq_along(NAMES)) {
[17:43:52.847]                   name <- removed[[kk]]
[17:43:52.847]                   NAME <- NAMES[[kk]]
[17:43:52.847]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:52.847]                     next
[17:43:52.847]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:52.847]                 }
[17:43:52.847]                 if (length(args) > 0) 
[17:43:52.847]                   base::do.call(base::Sys.setenv, args = args)
[17:43:52.847]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:52.847]             }
[17:43:52.847]             else {
[17:43:52.847]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:52.847]             }
[17:43:52.847]             {
[17:43:52.847]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:52.847]                   0L) {
[17:43:52.847]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:52.847]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:52.847]                   base::options(opts)
[17:43:52.847]                 }
[17:43:52.847]                 {
[17:43:52.847]                   {
[17:43:52.847]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:52.847]                     NULL
[17:43:52.847]                   }
[17:43:52.847]                   options(future.plan = NULL)
[17:43:52.847]                   if (is.na(NA_character_)) 
[17:43:52.847]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:52.847]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:52.847]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:52.847]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:52.847]                     envir = parent.frame()) 
[17:43:52.847]                   {
[17:43:52.847]                     if (is.function(workers)) 
[17:43:52.847]                       workers <- workers()
[17:43:52.847]                     workers <- structure(as.integer(workers), 
[17:43:52.847]                       class = class(workers))
[17:43:52.847]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:52.847]                       workers >= 1)
[17:43:52.847]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:52.847]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:52.847]                     }
[17:43:52.847]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:52.847]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:52.847]                       envir = envir)
[17:43:52.847]                     if (!future$lazy) 
[17:43:52.847]                       future <- run(future)
[17:43:52.847]                     invisible(future)
[17:43:52.847]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:52.847]                 }
[17:43:52.847]             }
[17:43:52.847]         }
[17:43:52.847]     })
[17:43:52.847]     if (TRUE) {
[17:43:52.847]         base::sink(type = "output", split = FALSE)
[17:43:52.847]         if (TRUE) {
[17:43:52.847]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:52.847]         }
[17:43:52.847]         else {
[17:43:52.847]             ...future.result["stdout"] <- base::list(NULL)
[17:43:52.847]         }
[17:43:52.847]         base::close(...future.stdout)
[17:43:52.847]         ...future.stdout <- NULL
[17:43:52.847]     }
[17:43:52.847]     ...future.result$conditions <- ...future.conditions
[17:43:52.847]     ...future.result$finished <- base::Sys.time()
[17:43:52.847]     ...future.result
[17:43:52.847] }
[17:43:52.850] MultisessionFuture started
[17:43:52.850] - Launch lazy future ... done
[17:43:52.850] run() for ‘MultisessionFuture’ ... done
[17:43:53.397] receiveMessageFromWorker() for ClusterFuture ...
[17:43:53.397] - Validating connection of MultisessionFuture
[17:43:53.397] - received message: FutureResult
[17:43:53.397] - Received FutureResult
[17:43:53.397] - Erased future from FutureRegistry
[17:43:53.398] result() for ClusterFuture ...
[17:43:53.398] - result already collected: FutureResult
[17:43:53.398] result() for ClusterFuture ... done
[17:43:53.398] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:53.398] resolve() on list ...
[17:43:53.398]  recursive: Inf
[17:43:53.398]  length: 2
[17:43:53.398]  elements: ‘a’, ‘b’
[17:43:53.399]  length: 1 (resolved future 1)
[17:43:53.399]  length: 0 (resolved future 2)
[17:43:53.399] resolve() on list ... DONE
[17:43:53.399] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[17:43:53.399] getGlobalsAndPackages() ...
[17:43:53.399] Searching for globals...
[17:43:53.403] - globals found: [2] ‘list’, ‘stop’
[17:43:53.403] Searching for globals ... DONE
[17:43:53.403] Resolving globals: FALSE
[17:43:53.403] 
[17:43:53.404] 
[17:43:53.404] getGlobalsAndPackages() ... DONE
[17:43:53.404] run() for ‘Future’ ...
[17:43:53.404] - state: ‘created’
[17:43:53.404] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:53.419] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:53.419] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:53.420]   - Field: ‘node’
[17:43:53.420]   - Field: ‘label’
[17:43:53.420]   - Field: ‘local’
[17:43:53.420]   - Field: ‘owner’
[17:43:53.420]   - Field: ‘envir’
[17:43:53.420]   - Field: ‘workers’
[17:43:53.420]   - Field: ‘packages’
[17:43:53.420]   - Field: ‘gc’
[17:43:53.420]   - Field: ‘conditions’
[17:43:53.420]   - Field: ‘persistent’
[17:43:53.421]   - Field: ‘expr’
[17:43:53.421]   - Field: ‘uuid’
[17:43:53.421]   - Field: ‘seed’
[17:43:53.421]   - Field: ‘version’
[17:43:53.421]   - Field: ‘result’
[17:43:53.421]   - Field: ‘asynchronous’
[17:43:53.421]   - Field: ‘calls’
[17:43:53.421]   - Field: ‘globals’
[17:43:53.421]   - Field: ‘stdout’
[17:43:53.421]   - Field: ‘earlySignal’
[17:43:53.421]   - Field: ‘lazy’
[17:43:53.422]   - Field: ‘state’
[17:43:53.422] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:53.422] - Launch lazy future ...
[17:43:53.422] Packages needed by the future expression (n = 0): <none>
[17:43:53.422] Packages needed by future strategies (n = 0): <none>
[17:43:53.423] {
[17:43:53.423]     {
[17:43:53.423]         {
[17:43:53.423]             ...future.startTime <- base::Sys.time()
[17:43:53.423]             {
[17:43:53.423]                 {
[17:43:53.423]                   {
[17:43:53.423]                     {
[17:43:53.423]                       base::local({
[17:43:53.423]                         has_future <- base::requireNamespace("future", 
[17:43:53.423]                           quietly = TRUE)
[17:43:53.423]                         if (has_future) {
[17:43:53.423]                           ns <- base::getNamespace("future")
[17:43:53.423]                           version <- ns[[".package"]][["version"]]
[17:43:53.423]                           if (is.null(version)) 
[17:43:53.423]                             version <- utils::packageVersion("future")
[17:43:53.423]                         }
[17:43:53.423]                         else {
[17:43:53.423]                           version <- NULL
[17:43:53.423]                         }
[17:43:53.423]                         if (!has_future || version < "1.8.0") {
[17:43:53.423]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:53.423]                             "", base::R.version$version.string), 
[17:43:53.423]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:53.423]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:53.423]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:53.423]                               "release", "version")], collapse = " "), 
[17:43:53.423]                             hostname = base::Sys.info()[["nodename"]])
[17:43:53.423]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:53.423]                             info)
[17:43:53.423]                           info <- base::paste(info, collapse = "; ")
[17:43:53.423]                           if (!has_future) {
[17:43:53.423]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:53.423]                               info)
[17:43:53.423]                           }
[17:43:53.423]                           else {
[17:43:53.423]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:53.423]                               info, version)
[17:43:53.423]                           }
[17:43:53.423]                           base::stop(msg)
[17:43:53.423]                         }
[17:43:53.423]                       })
[17:43:53.423]                     }
[17:43:53.423]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:53.423]                     base::options(mc.cores = 1L)
[17:43:53.423]                   }
[17:43:53.423]                   options(future.plan = NULL)
[17:43:53.423]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.423]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:53.423]                 }
[17:43:53.423]                 ...future.workdir <- getwd()
[17:43:53.423]             }
[17:43:53.423]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:53.423]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:53.423]         }
[17:43:53.423]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:53.423]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:53.423]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:53.423]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:53.423]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:53.423]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:53.423]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:53.423]             base::names(...future.oldOptions))
[17:43:53.423]     }
[17:43:53.423]     if (FALSE) {
[17:43:53.423]     }
[17:43:53.423]     else {
[17:43:53.423]         if (TRUE) {
[17:43:53.423]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:53.423]                 open = "w")
[17:43:53.423]         }
[17:43:53.423]         else {
[17:43:53.423]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:53.423]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:53.423]         }
[17:43:53.423]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:53.423]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:53.423]             base::sink(type = "output", split = FALSE)
[17:43:53.423]             base::close(...future.stdout)
[17:43:53.423]         }, add = TRUE)
[17:43:53.423]     }
[17:43:53.423]     ...future.frame <- base::sys.nframe()
[17:43:53.423]     ...future.conditions <- base::list()
[17:43:53.423]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:53.423]     if (FALSE) {
[17:43:53.423]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:53.423]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:53.423]     }
[17:43:53.423]     ...future.result <- base::tryCatch({
[17:43:53.423]         base::withCallingHandlers({
[17:43:53.423]             ...future.value <- base::withVisible(base::local({
[17:43:53.423]                 ...future.makeSendCondition <- local({
[17:43:53.423]                   sendCondition <- NULL
[17:43:53.423]                   function(frame = 1L) {
[17:43:53.423]                     if (is.function(sendCondition)) 
[17:43:53.423]                       return(sendCondition)
[17:43:53.423]                     ns <- getNamespace("parallel")
[17:43:53.423]                     if (exists("sendData", mode = "function", 
[17:43:53.423]                       envir = ns)) {
[17:43:53.423]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:53.423]                         envir = ns)
[17:43:53.423]                       envir <- sys.frame(frame)
[17:43:53.423]                       master <- NULL
[17:43:53.423]                       while (!identical(envir, .GlobalEnv) && 
[17:43:53.423]                         !identical(envir, emptyenv())) {
[17:43:53.423]                         if (exists("master", mode = "list", envir = envir, 
[17:43:53.423]                           inherits = FALSE)) {
[17:43:53.423]                           master <- get("master", mode = "list", 
[17:43:53.423]                             envir = envir, inherits = FALSE)
[17:43:53.423]                           if (inherits(master, c("SOCKnode", 
[17:43:53.423]                             "SOCK0node"))) {
[17:43:53.423]                             sendCondition <<- function(cond) {
[17:43:53.423]                               data <- list(type = "VALUE", value = cond, 
[17:43:53.423]                                 success = TRUE)
[17:43:53.423]                               parallel_sendData(master, data)
[17:43:53.423]                             }
[17:43:53.423]                             return(sendCondition)
[17:43:53.423]                           }
[17:43:53.423]                         }
[17:43:53.423]                         frame <- frame + 1L
[17:43:53.423]                         envir <- sys.frame(frame)
[17:43:53.423]                       }
[17:43:53.423]                     }
[17:43:53.423]                     sendCondition <<- function(cond) NULL
[17:43:53.423]                   }
[17:43:53.423]                 })
[17:43:53.423]                 withCallingHandlers({
[17:43:53.423]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:43:53.423]                 }, immediateCondition = function(cond) {
[17:43:53.423]                   sendCondition <- ...future.makeSendCondition()
[17:43:53.423]                   sendCondition(cond)
[17:43:53.423]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.423]                   {
[17:43:53.423]                     inherits <- base::inherits
[17:43:53.423]                     invokeRestart <- base::invokeRestart
[17:43:53.423]                     is.null <- base::is.null
[17:43:53.423]                     muffled <- FALSE
[17:43:53.423]                     if (inherits(cond, "message")) {
[17:43:53.423]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:53.423]                       if (muffled) 
[17:43:53.423]                         invokeRestart("muffleMessage")
[17:43:53.423]                     }
[17:43:53.423]                     else if (inherits(cond, "warning")) {
[17:43:53.423]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:53.423]                       if (muffled) 
[17:43:53.423]                         invokeRestart("muffleWarning")
[17:43:53.423]                     }
[17:43:53.423]                     else if (inherits(cond, "condition")) {
[17:43:53.423]                       if (!is.null(pattern)) {
[17:43:53.423]                         computeRestarts <- base::computeRestarts
[17:43:53.423]                         grepl <- base::grepl
[17:43:53.423]                         restarts <- computeRestarts(cond)
[17:43:53.423]                         for (restart in restarts) {
[17:43:53.423]                           name <- restart$name
[17:43:53.423]                           if (is.null(name)) 
[17:43:53.423]                             next
[17:43:53.423]                           if (!grepl(pattern, name)) 
[17:43:53.423]                             next
[17:43:53.423]                           invokeRestart(restart)
[17:43:53.423]                           muffled <- TRUE
[17:43:53.423]                           break
[17:43:53.423]                         }
[17:43:53.423]                       }
[17:43:53.423]                     }
[17:43:53.423]                     invisible(muffled)
[17:43:53.423]                   }
[17:43:53.423]                   muffleCondition(cond)
[17:43:53.423]                 })
[17:43:53.423]             }))
[17:43:53.423]             future::FutureResult(value = ...future.value$value, 
[17:43:53.423]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.423]                   ...future.rng), globalenv = if (FALSE) 
[17:43:53.423]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:53.423]                     ...future.globalenv.names))
[17:43:53.423]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:53.423]         }, condition = base::local({
[17:43:53.423]             c <- base::c
[17:43:53.423]             inherits <- base::inherits
[17:43:53.423]             invokeRestart <- base::invokeRestart
[17:43:53.423]             length <- base::length
[17:43:53.423]             list <- base::list
[17:43:53.423]             seq.int <- base::seq.int
[17:43:53.423]             signalCondition <- base::signalCondition
[17:43:53.423]             sys.calls <- base::sys.calls
[17:43:53.423]             `[[` <- base::`[[`
[17:43:53.423]             `+` <- base::`+`
[17:43:53.423]             `<<-` <- base::`<<-`
[17:43:53.423]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:53.423]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:53.423]                   3L)]
[17:43:53.423]             }
[17:43:53.423]             function(cond) {
[17:43:53.423]                 is_error <- inherits(cond, "error")
[17:43:53.423]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:53.423]                   NULL)
[17:43:53.423]                 if (is_error) {
[17:43:53.423]                   sessionInformation <- function() {
[17:43:53.423]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:53.423]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:53.423]                       search = base::search(), system = base::Sys.info())
[17:43:53.423]                   }
[17:43:53.423]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.423]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:53.423]                     cond$call), session = sessionInformation(), 
[17:43:53.423]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:53.423]                   signalCondition(cond)
[17:43:53.423]                 }
[17:43:53.423]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:53.423]                 "immediateCondition"))) {
[17:43:53.423]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:53.423]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.423]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:53.423]                   if (TRUE && !signal) {
[17:43:53.423]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.423]                     {
[17:43:53.423]                       inherits <- base::inherits
[17:43:53.423]                       invokeRestart <- base::invokeRestart
[17:43:53.423]                       is.null <- base::is.null
[17:43:53.423]                       muffled <- FALSE
[17:43:53.423]                       if (inherits(cond, "message")) {
[17:43:53.423]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.423]                         if (muffled) 
[17:43:53.423]                           invokeRestart("muffleMessage")
[17:43:53.423]                       }
[17:43:53.423]                       else if (inherits(cond, "warning")) {
[17:43:53.423]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.423]                         if (muffled) 
[17:43:53.423]                           invokeRestart("muffleWarning")
[17:43:53.423]                       }
[17:43:53.423]                       else if (inherits(cond, "condition")) {
[17:43:53.423]                         if (!is.null(pattern)) {
[17:43:53.423]                           computeRestarts <- base::computeRestarts
[17:43:53.423]                           grepl <- base::grepl
[17:43:53.423]                           restarts <- computeRestarts(cond)
[17:43:53.423]                           for (restart in restarts) {
[17:43:53.423]                             name <- restart$name
[17:43:53.423]                             if (is.null(name)) 
[17:43:53.423]                               next
[17:43:53.423]                             if (!grepl(pattern, name)) 
[17:43:53.423]                               next
[17:43:53.423]                             invokeRestart(restart)
[17:43:53.423]                             muffled <- TRUE
[17:43:53.423]                             break
[17:43:53.423]                           }
[17:43:53.423]                         }
[17:43:53.423]                       }
[17:43:53.423]                       invisible(muffled)
[17:43:53.423]                     }
[17:43:53.423]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.423]                   }
[17:43:53.423]                 }
[17:43:53.423]                 else {
[17:43:53.423]                   if (TRUE) {
[17:43:53.423]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.423]                     {
[17:43:53.423]                       inherits <- base::inherits
[17:43:53.423]                       invokeRestart <- base::invokeRestart
[17:43:53.423]                       is.null <- base::is.null
[17:43:53.423]                       muffled <- FALSE
[17:43:53.423]                       if (inherits(cond, "message")) {
[17:43:53.423]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.423]                         if (muffled) 
[17:43:53.423]                           invokeRestart("muffleMessage")
[17:43:53.423]                       }
[17:43:53.423]                       else if (inherits(cond, "warning")) {
[17:43:53.423]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.423]                         if (muffled) 
[17:43:53.423]                           invokeRestart("muffleWarning")
[17:43:53.423]                       }
[17:43:53.423]                       else if (inherits(cond, "condition")) {
[17:43:53.423]                         if (!is.null(pattern)) {
[17:43:53.423]                           computeRestarts <- base::computeRestarts
[17:43:53.423]                           grepl <- base::grepl
[17:43:53.423]                           restarts <- computeRestarts(cond)
[17:43:53.423]                           for (restart in restarts) {
[17:43:53.423]                             name <- restart$name
[17:43:53.423]                             if (is.null(name)) 
[17:43:53.423]                               next
[17:43:53.423]                             if (!grepl(pattern, name)) 
[17:43:53.423]                               next
[17:43:53.423]                             invokeRestart(restart)
[17:43:53.423]                             muffled <- TRUE
[17:43:53.423]                             break
[17:43:53.423]                           }
[17:43:53.423]                         }
[17:43:53.423]                       }
[17:43:53.423]                       invisible(muffled)
[17:43:53.423]                     }
[17:43:53.423]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.423]                   }
[17:43:53.423]                 }
[17:43:53.423]             }
[17:43:53.423]         }))
[17:43:53.423]     }, error = function(ex) {
[17:43:53.423]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:53.423]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.423]                 ...future.rng), started = ...future.startTime, 
[17:43:53.423]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:53.423]             version = "1.8"), class = "FutureResult")
[17:43:53.423]     }, finally = {
[17:43:53.423]         if (!identical(...future.workdir, getwd())) 
[17:43:53.423]             setwd(...future.workdir)
[17:43:53.423]         {
[17:43:53.423]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:53.423]                 ...future.oldOptions$nwarnings <- NULL
[17:43:53.423]             }
[17:43:53.423]             base::options(...future.oldOptions)
[17:43:53.423]             if (.Platform$OS.type == "windows") {
[17:43:53.423]                 old_names <- names(...future.oldEnvVars)
[17:43:53.423]                 envs <- base::Sys.getenv()
[17:43:53.423]                 names <- names(envs)
[17:43:53.423]                 common <- intersect(names, old_names)
[17:43:53.423]                 added <- setdiff(names, old_names)
[17:43:53.423]                 removed <- setdiff(old_names, names)
[17:43:53.423]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:53.423]                   envs[common]]
[17:43:53.423]                 NAMES <- toupper(changed)
[17:43:53.423]                 args <- list()
[17:43:53.423]                 for (kk in seq_along(NAMES)) {
[17:43:53.423]                   name <- changed[[kk]]
[17:43:53.423]                   NAME <- NAMES[[kk]]
[17:43:53.423]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.423]                     next
[17:43:53.423]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.423]                 }
[17:43:53.423]                 NAMES <- toupper(added)
[17:43:53.423]                 for (kk in seq_along(NAMES)) {
[17:43:53.423]                   name <- added[[kk]]
[17:43:53.423]                   NAME <- NAMES[[kk]]
[17:43:53.423]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.423]                     next
[17:43:53.423]                   args[[name]] <- ""
[17:43:53.423]                 }
[17:43:53.423]                 NAMES <- toupper(removed)
[17:43:53.423]                 for (kk in seq_along(NAMES)) {
[17:43:53.423]                   name <- removed[[kk]]
[17:43:53.423]                   NAME <- NAMES[[kk]]
[17:43:53.423]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.423]                     next
[17:43:53.423]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.423]                 }
[17:43:53.423]                 if (length(args) > 0) 
[17:43:53.423]                   base::do.call(base::Sys.setenv, args = args)
[17:43:53.423]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:53.423]             }
[17:43:53.423]             else {
[17:43:53.423]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:53.423]             }
[17:43:53.423]             {
[17:43:53.423]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:53.423]                   0L) {
[17:43:53.423]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:53.423]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:53.423]                   base::options(opts)
[17:43:53.423]                 }
[17:43:53.423]                 {
[17:43:53.423]                   {
[17:43:53.423]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:53.423]                     NULL
[17:43:53.423]                   }
[17:43:53.423]                   options(future.plan = NULL)
[17:43:53.423]                   if (is.na(NA_character_)) 
[17:43:53.423]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.423]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:53.423]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:53.423]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:53.423]                     envir = parent.frame()) 
[17:43:53.423]                   {
[17:43:53.423]                     if (is.function(workers)) 
[17:43:53.423]                       workers <- workers()
[17:43:53.423]                     workers <- structure(as.integer(workers), 
[17:43:53.423]                       class = class(workers))
[17:43:53.423]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:53.423]                       workers >= 1)
[17:43:53.423]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:53.423]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:53.423]                     }
[17:43:53.423]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:53.423]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:53.423]                       envir = envir)
[17:43:53.423]                     if (!future$lazy) 
[17:43:53.423]                       future <- run(future)
[17:43:53.423]                     invisible(future)
[17:43:53.423]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:53.423]                 }
[17:43:53.423]             }
[17:43:53.423]         }
[17:43:53.423]     })
[17:43:53.423]     if (TRUE) {
[17:43:53.423]         base::sink(type = "output", split = FALSE)
[17:43:53.423]         if (TRUE) {
[17:43:53.423]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:53.423]         }
[17:43:53.423]         else {
[17:43:53.423]             ...future.result["stdout"] <- base::list(NULL)
[17:43:53.423]         }
[17:43:53.423]         base::close(...future.stdout)
[17:43:53.423]         ...future.stdout <- NULL
[17:43:53.423]     }
[17:43:53.423]     ...future.result$conditions <- ...future.conditions
[17:43:53.423]     ...future.result$finished <- base::Sys.time()
[17:43:53.423]     ...future.result
[17:43:53.423] }
[17:43:53.426] MultisessionFuture started
[17:43:53.426] - Launch lazy future ... done
[17:43:53.426] run() for ‘MultisessionFuture’ ... done
[17:43:53.472] receiveMessageFromWorker() for ClusterFuture ...
[17:43:53.472] - Validating connection of MultisessionFuture
[17:43:53.473] - received message: FutureResult
[17:43:53.473] - Received FutureResult
[17:43:53.473] - Erased future from FutureRegistry
[17:43:53.474] result() for ClusterFuture ...
[17:43:53.474] - result already collected: FutureResult
[17:43:53.474] result() for ClusterFuture ... done
[17:43:53.474] signalConditions() ...
[17:43:53.474]  - include = ‘immediateCondition’
[17:43:53.474]  - exclude = 
[17:43:53.474]  - resignal = FALSE
[17:43:53.474]  - Number of conditions: 1
[17:43:53.474] signalConditions() ... done
[17:43:53.474] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:53.475] A MultisessionFuture was resolved
[17:43:53.475] getGlobalsAndPackages() ...
[17:43:53.475] Searching for globals...
[17:43:53.475] - globals found: [2] ‘list’, ‘stop’
[17:43:53.476] Searching for globals ... DONE
[17:43:53.476] Resolving globals: FALSE
[17:43:53.476] 
[17:43:53.476] 
[17:43:53.476] getGlobalsAndPackages() ... DONE
[17:43:53.477] run() for ‘Future’ ...
[17:43:53.477] - state: ‘created’
[17:43:53.477] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:53.492] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:53.492] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:53.492]   - Field: ‘node’
[17:43:53.492]   - Field: ‘label’
[17:43:53.492]   - Field: ‘local’
[17:43:53.492]   - Field: ‘owner’
[17:43:53.492]   - Field: ‘envir’
[17:43:53.492]   - Field: ‘workers’
[17:43:53.492]   - Field: ‘packages’
[17:43:53.493]   - Field: ‘gc’
[17:43:53.493]   - Field: ‘conditions’
[17:43:53.493]   - Field: ‘persistent’
[17:43:53.493]   - Field: ‘expr’
[17:43:53.493]   - Field: ‘uuid’
[17:43:53.493]   - Field: ‘seed’
[17:43:53.493]   - Field: ‘version’
[17:43:53.493]   - Field: ‘result’
[17:43:53.493]   - Field: ‘asynchronous’
[17:43:53.493]   - Field: ‘calls’
[17:43:53.493]   - Field: ‘globals’
[17:43:53.494]   - Field: ‘stdout’
[17:43:53.494]   - Field: ‘earlySignal’
[17:43:53.494]   - Field: ‘lazy’
[17:43:53.494]   - Field: ‘state’
[17:43:53.494] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:53.494] - Launch lazy future ...
[17:43:53.494] Packages needed by the future expression (n = 0): <none>
[17:43:53.494] Packages needed by future strategies (n = 0): <none>
[17:43:53.495] {
[17:43:53.495]     {
[17:43:53.495]         {
[17:43:53.495]             ...future.startTime <- base::Sys.time()
[17:43:53.495]             {
[17:43:53.495]                 {
[17:43:53.495]                   {
[17:43:53.495]                     {
[17:43:53.495]                       base::local({
[17:43:53.495]                         has_future <- base::requireNamespace("future", 
[17:43:53.495]                           quietly = TRUE)
[17:43:53.495]                         if (has_future) {
[17:43:53.495]                           ns <- base::getNamespace("future")
[17:43:53.495]                           version <- ns[[".package"]][["version"]]
[17:43:53.495]                           if (is.null(version)) 
[17:43:53.495]                             version <- utils::packageVersion("future")
[17:43:53.495]                         }
[17:43:53.495]                         else {
[17:43:53.495]                           version <- NULL
[17:43:53.495]                         }
[17:43:53.495]                         if (!has_future || version < "1.8.0") {
[17:43:53.495]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:53.495]                             "", base::R.version$version.string), 
[17:43:53.495]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:53.495]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:53.495]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:53.495]                               "release", "version")], collapse = " "), 
[17:43:53.495]                             hostname = base::Sys.info()[["nodename"]])
[17:43:53.495]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:53.495]                             info)
[17:43:53.495]                           info <- base::paste(info, collapse = "; ")
[17:43:53.495]                           if (!has_future) {
[17:43:53.495]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:53.495]                               info)
[17:43:53.495]                           }
[17:43:53.495]                           else {
[17:43:53.495]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:53.495]                               info, version)
[17:43:53.495]                           }
[17:43:53.495]                           base::stop(msg)
[17:43:53.495]                         }
[17:43:53.495]                       })
[17:43:53.495]                     }
[17:43:53.495]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:53.495]                     base::options(mc.cores = 1L)
[17:43:53.495]                   }
[17:43:53.495]                   options(future.plan = NULL)
[17:43:53.495]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.495]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:53.495]                 }
[17:43:53.495]                 ...future.workdir <- getwd()
[17:43:53.495]             }
[17:43:53.495]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:53.495]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:53.495]         }
[17:43:53.495]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:53.495]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:53.495]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:53.495]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:53.495]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:53.495]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:53.495]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:53.495]             base::names(...future.oldOptions))
[17:43:53.495]     }
[17:43:53.495]     if (FALSE) {
[17:43:53.495]     }
[17:43:53.495]     else {
[17:43:53.495]         if (TRUE) {
[17:43:53.495]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:53.495]                 open = "w")
[17:43:53.495]         }
[17:43:53.495]         else {
[17:43:53.495]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:53.495]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:53.495]         }
[17:43:53.495]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:53.495]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:53.495]             base::sink(type = "output", split = FALSE)
[17:43:53.495]             base::close(...future.stdout)
[17:43:53.495]         }, add = TRUE)
[17:43:53.495]     }
[17:43:53.495]     ...future.frame <- base::sys.nframe()
[17:43:53.495]     ...future.conditions <- base::list()
[17:43:53.495]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:53.495]     if (FALSE) {
[17:43:53.495]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:53.495]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:53.495]     }
[17:43:53.495]     ...future.result <- base::tryCatch({
[17:43:53.495]         base::withCallingHandlers({
[17:43:53.495]             ...future.value <- base::withVisible(base::local({
[17:43:53.495]                 ...future.makeSendCondition <- local({
[17:43:53.495]                   sendCondition <- NULL
[17:43:53.495]                   function(frame = 1L) {
[17:43:53.495]                     if (is.function(sendCondition)) 
[17:43:53.495]                       return(sendCondition)
[17:43:53.495]                     ns <- getNamespace("parallel")
[17:43:53.495]                     if (exists("sendData", mode = "function", 
[17:43:53.495]                       envir = ns)) {
[17:43:53.495]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:53.495]                         envir = ns)
[17:43:53.495]                       envir <- sys.frame(frame)
[17:43:53.495]                       master <- NULL
[17:43:53.495]                       while (!identical(envir, .GlobalEnv) && 
[17:43:53.495]                         !identical(envir, emptyenv())) {
[17:43:53.495]                         if (exists("master", mode = "list", envir = envir, 
[17:43:53.495]                           inherits = FALSE)) {
[17:43:53.495]                           master <- get("master", mode = "list", 
[17:43:53.495]                             envir = envir, inherits = FALSE)
[17:43:53.495]                           if (inherits(master, c("SOCKnode", 
[17:43:53.495]                             "SOCK0node"))) {
[17:43:53.495]                             sendCondition <<- function(cond) {
[17:43:53.495]                               data <- list(type = "VALUE", value = cond, 
[17:43:53.495]                                 success = TRUE)
[17:43:53.495]                               parallel_sendData(master, data)
[17:43:53.495]                             }
[17:43:53.495]                             return(sendCondition)
[17:43:53.495]                           }
[17:43:53.495]                         }
[17:43:53.495]                         frame <- frame + 1L
[17:43:53.495]                         envir <- sys.frame(frame)
[17:43:53.495]                       }
[17:43:53.495]                     }
[17:43:53.495]                     sendCondition <<- function(cond) NULL
[17:43:53.495]                   }
[17:43:53.495]                 })
[17:43:53.495]                 withCallingHandlers({
[17:43:53.495]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:43:53.495]                 }, immediateCondition = function(cond) {
[17:43:53.495]                   sendCondition <- ...future.makeSendCondition()
[17:43:53.495]                   sendCondition(cond)
[17:43:53.495]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.495]                   {
[17:43:53.495]                     inherits <- base::inherits
[17:43:53.495]                     invokeRestart <- base::invokeRestart
[17:43:53.495]                     is.null <- base::is.null
[17:43:53.495]                     muffled <- FALSE
[17:43:53.495]                     if (inherits(cond, "message")) {
[17:43:53.495]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:53.495]                       if (muffled) 
[17:43:53.495]                         invokeRestart("muffleMessage")
[17:43:53.495]                     }
[17:43:53.495]                     else if (inherits(cond, "warning")) {
[17:43:53.495]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:53.495]                       if (muffled) 
[17:43:53.495]                         invokeRestart("muffleWarning")
[17:43:53.495]                     }
[17:43:53.495]                     else if (inherits(cond, "condition")) {
[17:43:53.495]                       if (!is.null(pattern)) {
[17:43:53.495]                         computeRestarts <- base::computeRestarts
[17:43:53.495]                         grepl <- base::grepl
[17:43:53.495]                         restarts <- computeRestarts(cond)
[17:43:53.495]                         for (restart in restarts) {
[17:43:53.495]                           name <- restart$name
[17:43:53.495]                           if (is.null(name)) 
[17:43:53.495]                             next
[17:43:53.495]                           if (!grepl(pattern, name)) 
[17:43:53.495]                             next
[17:43:53.495]                           invokeRestart(restart)
[17:43:53.495]                           muffled <- TRUE
[17:43:53.495]                           break
[17:43:53.495]                         }
[17:43:53.495]                       }
[17:43:53.495]                     }
[17:43:53.495]                     invisible(muffled)
[17:43:53.495]                   }
[17:43:53.495]                   muffleCondition(cond)
[17:43:53.495]                 })
[17:43:53.495]             }))
[17:43:53.495]             future::FutureResult(value = ...future.value$value, 
[17:43:53.495]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.495]                   ...future.rng), globalenv = if (FALSE) 
[17:43:53.495]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:53.495]                     ...future.globalenv.names))
[17:43:53.495]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:53.495]         }, condition = base::local({
[17:43:53.495]             c <- base::c
[17:43:53.495]             inherits <- base::inherits
[17:43:53.495]             invokeRestart <- base::invokeRestart
[17:43:53.495]             length <- base::length
[17:43:53.495]             list <- base::list
[17:43:53.495]             seq.int <- base::seq.int
[17:43:53.495]             signalCondition <- base::signalCondition
[17:43:53.495]             sys.calls <- base::sys.calls
[17:43:53.495]             `[[` <- base::`[[`
[17:43:53.495]             `+` <- base::`+`
[17:43:53.495]             `<<-` <- base::`<<-`
[17:43:53.495]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:53.495]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:53.495]                   3L)]
[17:43:53.495]             }
[17:43:53.495]             function(cond) {
[17:43:53.495]                 is_error <- inherits(cond, "error")
[17:43:53.495]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:53.495]                   NULL)
[17:43:53.495]                 if (is_error) {
[17:43:53.495]                   sessionInformation <- function() {
[17:43:53.495]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:53.495]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:53.495]                       search = base::search(), system = base::Sys.info())
[17:43:53.495]                   }
[17:43:53.495]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.495]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:53.495]                     cond$call), session = sessionInformation(), 
[17:43:53.495]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:53.495]                   signalCondition(cond)
[17:43:53.495]                 }
[17:43:53.495]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:53.495]                 "immediateCondition"))) {
[17:43:53.495]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:53.495]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.495]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:53.495]                   if (TRUE && !signal) {
[17:43:53.495]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.495]                     {
[17:43:53.495]                       inherits <- base::inherits
[17:43:53.495]                       invokeRestart <- base::invokeRestart
[17:43:53.495]                       is.null <- base::is.null
[17:43:53.495]                       muffled <- FALSE
[17:43:53.495]                       if (inherits(cond, "message")) {
[17:43:53.495]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.495]                         if (muffled) 
[17:43:53.495]                           invokeRestart("muffleMessage")
[17:43:53.495]                       }
[17:43:53.495]                       else if (inherits(cond, "warning")) {
[17:43:53.495]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.495]                         if (muffled) 
[17:43:53.495]                           invokeRestart("muffleWarning")
[17:43:53.495]                       }
[17:43:53.495]                       else if (inherits(cond, "condition")) {
[17:43:53.495]                         if (!is.null(pattern)) {
[17:43:53.495]                           computeRestarts <- base::computeRestarts
[17:43:53.495]                           grepl <- base::grepl
[17:43:53.495]                           restarts <- computeRestarts(cond)
[17:43:53.495]                           for (restart in restarts) {
[17:43:53.495]                             name <- restart$name
[17:43:53.495]                             if (is.null(name)) 
[17:43:53.495]                               next
[17:43:53.495]                             if (!grepl(pattern, name)) 
[17:43:53.495]                               next
[17:43:53.495]                             invokeRestart(restart)
[17:43:53.495]                             muffled <- TRUE
[17:43:53.495]                             break
[17:43:53.495]                           }
[17:43:53.495]                         }
[17:43:53.495]                       }
[17:43:53.495]                       invisible(muffled)
[17:43:53.495]                     }
[17:43:53.495]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.495]                   }
[17:43:53.495]                 }
[17:43:53.495]                 else {
[17:43:53.495]                   if (TRUE) {
[17:43:53.495]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.495]                     {
[17:43:53.495]                       inherits <- base::inherits
[17:43:53.495]                       invokeRestart <- base::invokeRestart
[17:43:53.495]                       is.null <- base::is.null
[17:43:53.495]                       muffled <- FALSE
[17:43:53.495]                       if (inherits(cond, "message")) {
[17:43:53.495]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.495]                         if (muffled) 
[17:43:53.495]                           invokeRestart("muffleMessage")
[17:43:53.495]                       }
[17:43:53.495]                       else if (inherits(cond, "warning")) {
[17:43:53.495]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.495]                         if (muffled) 
[17:43:53.495]                           invokeRestart("muffleWarning")
[17:43:53.495]                       }
[17:43:53.495]                       else if (inherits(cond, "condition")) {
[17:43:53.495]                         if (!is.null(pattern)) {
[17:43:53.495]                           computeRestarts <- base::computeRestarts
[17:43:53.495]                           grepl <- base::grepl
[17:43:53.495]                           restarts <- computeRestarts(cond)
[17:43:53.495]                           for (restart in restarts) {
[17:43:53.495]                             name <- restart$name
[17:43:53.495]                             if (is.null(name)) 
[17:43:53.495]                               next
[17:43:53.495]                             if (!grepl(pattern, name)) 
[17:43:53.495]                               next
[17:43:53.495]                             invokeRestart(restart)
[17:43:53.495]                             muffled <- TRUE
[17:43:53.495]                             break
[17:43:53.495]                           }
[17:43:53.495]                         }
[17:43:53.495]                       }
[17:43:53.495]                       invisible(muffled)
[17:43:53.495]                     }
[17:43:53.495]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.495]                   }
[17:43:53.495]                 }
[17:43:53.495]             }
[17:43:53.495]         }))
[17:43:53.495]     }, error = function(ex) {
[17:43:53.495]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:53.495]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.495]                 ...future.rng), started = ...future.startTime, 
[17:43:53.495]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:53.495]             version = "1.8"), class = "FutureResult")
[17:43:53.495]     }, finally = {
[17:43:53.495]         if (!identical(...future.workdir, getwd())) 
[17:43:53.495]             setwd(...future.workdir)
[17:43:53.495]         {
[17:43:53.495]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:53.495]                 ...future.oldOptions$nwarnings <- NULL
[17:43:53.495]             }
[17:43:53.495]             base::options(...future.oldOptions)
[17:43:53.495]             if (.Platform$OS.type == "windows") {
[17:43:53.495]                 old_names <- names(...future.oldEnvVars)
[17:43:53.495]                 envs <- base::Sys.getenv()
[17:43:53.495]                 names <- names(envs)
[17:43:53.495]                 common <- intersect(names, old_names)
[17:43:53.495]                 added <- setdiff(names, old_names)
[17:43:53.495]                 removed <- setdiff(old_names, names)
[17:43:53.495]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:53.495]                   envs[common]]
[17:43:53.495]                 NAMES <- toupper(changed)
[17:43:53.495]                 args <- list()
[17:43:53.495]                 for (kk in seq_along(NAMES)) {
[17:43:53.495]                   name <- changed[[kk]]
[17:43:53.495]                   NAME <- NAMES[[kk]]
[17:43:53.495]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.495]                     next
[17:43:53.495]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.495]                 }
[17:43:53.495]                 NAMES <- toupper(added)
[17:43:53.495]                 for (kk in seq_along(NAMES)) {
[17:43:53.495]                   name <- added[[kk]]
[17:43:53.495]                   NAME <- NAMES[[kk]]
[17:43:53.495]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.495]                     next
[17:43:53.495]                   args[[name]] <- ""
[17:43:53.495]                 }
[17:43:53.495]                 NAMES <- toupper(removed)
[17:43:53.495]                 for (kk in seq_along(NAMES)) {
[17:43:53.495]                   name <- removed[[kk]]
[17:43:53.495]                   NAME <- NAMES[[kk]]
[17:43:53.495]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.495]                     next
[17:43:53.495]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.495]                 }
[17:43:53.495]                 if (length(args) > 0) 
[17:43:53.495]                   base::do.call(base::Sys.setenv, args = args)
[17:43:53.495]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:53.495]             }
[17:43:53.495]             else {
[17:43:53.495]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:53.495]             }
[17:43:53.495]             {
[17:43:53.495]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:53.495]                   0L) {
[17:43:53.495]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:53.495]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:53.495]                   base::options(opts)
[17:43:53.495]                 }
[17:43:53.495]                 {
[17:43:53.495]                   {
[17:43:53.495]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:53.495]                     NULL
[17:43:53.495]                   }
[17:43:53.495]                   options(future.plan = NULL)
[17:43:53.495]                   if (is.na(NA_character_)) 
[17:43:53.495]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.495]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:53.495]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:53.495]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:53.495]                     envir = parent.frame()) 
[17:43:53.495]                   {
[17:43:53.495]                     if (is.function(workers)) 
[17:43:53.495]                       workers <- workers()
[17:43:53.495]                     workers <- structure(as.integer(workers), 
[17:43:53.495]                       class = class(workers))
[17:43:53.495]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:53.495]                       workers >= 1)
[17:43:53.495]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:53.495]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:53.495]                     }
[17:43:53.495]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:53.495]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:53.495]                       envir = envir)
[17:43:53.495]                     if (!future$lazy) 
[17:43:53.495]                       future <- run(future)
[17:43:53.495]                     invisible(future)
[17:43:53.495]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:53.495]                 }
[17:43:53.495]             }
[17:43:53.495]         }
[17:43:53.495]     })
[17:43:53.495]     if (TRUE) {
[17:43:53.495]         base::sink(type = "output", split = FALSE)
[17:43:53.495]         if (TRUE) {
[17:43:53.495]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:53.495]         }
[17:43:53.495]         else {
[17:43:53.495]             ...future.result["stdout"] <- base::list(NULL)
[17:43:53.495]         }
[17:43:53.495]         base::close(...future.stdout)
[17:43:53.495]         ...future.stdout <- NULL
[17:43:53.495]     }
[17:43:53.495]     ...future.result$conditions <- ...future.conditions
[17:43:53.495]     ...future.result$finished <- base::Sys.time()
[17:43:53.495]     ...future.result
[17:43:53.495] }
[17:43:53.498] MultisessionFuture started
[17:43:53.498] - Launch lazy future ... done
[17:43:53.498] run() for ‘MultisessionFuture’ ... done
[17:43:53.544] receiveMessageFromWorker() for ClusterFuture ...
[17:43:53.544] - Validating connection of MultisessionFuture
[17:43:53.546] - received message: FutureResult
[17:43:53.546] - Received FutureResult
[17:43:53.546] - Erased future from FutureRegistry
[17:43:53.546] result() for ClusterFuture ...
[17:43:53.546] - result already collected: FutureResult
[17:43:53.547] result() for ClusterFuture ... done
[17:43:53.547] signalConditions() ...
[17:43:53.547]  - include = ‘immediateCondition’
[17:43:53.547]  - exclude = 
[17:43:53.547]  - resignal = FALSE
[17:43:53.547]  - Number of conditions: 1
[17:43:53.547] signalConditions() ... done
[17:43:53.547] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:53.547] A MultisessionFuture was resolved
- result = TRUE, recursive = Inf ... DONE
*** resolve() for Future objects ... DONE
*** resolve() for lists ...
[17:43:53.548] resolve() on list ...
[17:43:53.548]  recursive: 0
[17:43:53.548]  length: 2
[17:43:53.548]  elements: ‘a’, ‘b’
[17:43:53.548]  length: 1 (resolved future 1)
[17:43:53.548]  length: 0 (resolved future 2)
[17:43:53.548] resolve() on list ... DONE
[17:43:53.548] getGlobalsAndPackages() ...
[17:43:53.548] Searching for globals...
[17:43:53.549] 
[17:43:53.549] Searching for globals ... DONE
[17:43:53.549] - globals: [0] <none>
[17:43:53.549] getGlobalsAndPackages() ... DONE
[17:43:53.549] run() for ‘Future’ ...
[17:43:53.549] - state: ‘created’
[17:43:53.550] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:53.565] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:53.565] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:53.565]   - Field: ‘node’
[17:43:53.565]   - Field: ‘label’
[17:43:53.565]   - Field: ‘local’
[17:43:53.566]   - Field: ‘owner’
[17:43:53.566]   - Field: ‘envir’
[17:43:53.566]   - Field: ‘workers’
[17:43:53.566]   - Field: ‘packages’
[17:43:53.566]   - Field: ‘gc’
[17:43:53.566]   - Field: ‘conditions’
[17:43:53.566]   - Field: ‘persistent’
[17:43:53.566]   - Field: ‘expr’
[17:43:53.566]   - Field: ‘uuid’
[17:43:53.566]   - Field: ‘seed’
[17:43:53.567]   - Field: ‘version’
[17:43:53.567]   - Field: ‘result’
[17:43:53.567]   - Field: ‘asynchronous’
[17:43:53.567]   - Field: ‘calls’
[17:43:53.567]   - Field: ‘globals’
[17:43:53.567]   - Field: ‘stdout’
[17:43:53.567]   - Field: ‘earlySignal’
[17:43:53.567]   - Field: ‘lazy’
[17:43:53.567]   - Field: ‘state’
[17:43:53.567] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:53.568] - Launch lazy future ...
[17:43:53.568] Packages needed by the future expression (n = 0): <none>
[17:43:53.568] Packages needed by future strategies (n = 0): <none>
[17:43:53.568] {
[17:43:53.568]     {
[17:43:53.568]         {
[17:43:53.568]             ...future.startTime <- base::Sys.time()
[17:43:53.568]             {
[17:43:53.568]                 {
[17:43:53.568]                   {
[17:43:53.568]                     {
[17:43:53.568]                       base::local({
[17:43:53.568]                         has_future <- base::requireNamespace("future", 
[17:43:53.568]                           quietly = TRUE)
[17:43:53.568]                         if (has_future) {
[17:43:53.568]                           ns <- base::getNamespace("future")
[17:43:53.568]                           version <- ns[[".package"]][["version"]]
[17:43:53.568]                           if (is.null(version)) 
[17:43:53.568]                             version <- utils::packageVersion("future")
[17:43:53.568]                         }
[17:43:53.568]                         else {
[17:43:53.568]                           version <- NULL
[17:43:53.568]                         }
[17:43:53.568]                         if (!has_future || version < "1.8.0") {
[17:43:53.568]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:53.568]                             "", base::R.version$version.string), 
[17:43:53.568]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:53.568]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:53.568]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:53.568]                               "release", "version")], collapse = " "), 
[17:43:53.568]                             hostname = base::Sys.info()[["nodename"]])
[17:43:53.568]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:53.568]                             info)
[17:43:53.568]                           info <- base::paste(info, collapse = "; ")
[17:43:53.568]                           if (!has_future) {
[17:43:53.568]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:53.568]                               info)
[17:43:53.568]                           }
[17:43:53.568]                           else {
[17:43:53.568]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:53.568]                               info, version)
[17:43:53.568]                           }
[17:43:53.568]                           base::stop(msg)
[17:43:53.568]                         }
[17:43:53.568]                       })
[17:43:53.568]                     }
[17:43:53.568]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:53.568]                     base::options(mc.cores = 1L)
[17:43:53.568]                   }
[17:43:53.568]                   options(future.plan = NULL)
[17:43:53.568]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.568]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:53.568]                 }
[17:43:53.568]                 ...future.workdir <- getwd()
[17:43:53.568]             }
[17:43:53.568]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:53.568]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:53.568]         }
[17:43:53.568]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:53.568]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:53.568]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:53.568]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:53.568]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:53.568]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:53.568]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:53.568]             base::names(...future.oldOptions))
[17:43:53.568]     }
[17:43:53.568]     if (FALSE) {
[17:43:53.568]     }
[17:43:53.568]     else {
[17:43:53.568]         if (TRUE) {
[17:43:53.568]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:53.568]                 open = "w")
[17:43:53.568]         }
[17:43:53.568]         else {
[17:43:53.568]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:53.568]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:53.568]         }
[17:43:53.568]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:53.568]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:53.568]             base::sink(type = "output", split = FALSE)
[17:43:53.568]             base::close(...future.stdout)
[17:43:53.568]         }, add = TRUE)
[17:43:53.568]     }
[17:43:53.568]     ...future.frame <- base::sys.nframe()
[17:43:53.568]     ...future.conditions <- base::list()
[17:43:53.568]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:53.568]     if (FALSE) {
[17:43:53.568]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:53.568]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:53.568]     }
[17:43:53.568]     ...future.result <- base::tryCatch({
[17:43:53.568]         base::withCallingHandlers({
[17:43:53.568]             ...future.value <- base::withVisible(base::local({
[17:43:53.568]                 ...future.makeSendCondition <- local({
[17:43:53.568]                   sendCondition <- NULL
[17:43:53.568]                   function(frame = 1L) {
[17:43:53.568]                     if (is.function(sendCondition)) 
[17:43:53.568]                       return(sendCondition)
[17:43:53.568]                     ns <- getNamespace("parallel")
[17:43:53.568]                     if (exists("sendData", mode = "function", 
[17:43:53.568]                       envir = ns)) {
[17:43:53.568]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:53.568]                         envir = ns)
[17:43:53.568]                       envir <- sys.frame(frame)
[17:43:53.568]                       master <- NULL
[17:43:53.568]                       while (!identical(envir, .GlobalEnv) && 
[17:43:53.568]                         !identical(envir, emptyenv())) {
[17:43:53.568]                         if (exists("master", mode = "list", envir = envir, 
[17:43:53.568]                           inherits = FALSE)) {
[17:43:53.568]                           master <- get("master", mode = "list", 
[17:43:53.568]                             envir = envir, inherits = FALSE)
[17:43:53.568]                           if (inherits(master, c("SOCKnode", 
[17:43:53.568]                             "SOCK0node"))) {
[17:43:53.568]                             sendCondition <<- function(cond) {
[17:43:53.568]                               data <- list(type = "VALUE", value = cond, 
[17:43:53.568]                                 success = TRUE)
[17:43:53.568]                               parallel_sendData(master, data)
[17:43:53.568]                             }
[17:43:53.568]                             return(sendCondition)
[17:43:53.568]                           }
[17:43:53.568]                         }
[17:43:53.568]                         frame <- frame + 1L
[17:43:53.568]                         envir <- sys.frame(frame)
[17:43:53.568]                       }
[17:43:53.568]                     }
[17:43:53.568]                     sendCondition <<- function(cond) NULL
[17:43:53.568]                   }
[17:43:53.568]                 })
[17:43:53.568]                 withCallingHandlers({
[17:43:53.568]                   1
[17:43:53.568]                 }, immediateCondition = function(cond) {
[17:43:53.568]                   sendCondition <- ...future.makeSendCondition()
[17:43:53.568]                   sendCondition(cond)
[17:43:53.568]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.568]                   {
[17:43:53.568]                     inherits <- base::inherits
[17:43:53.568]                     invokeRestart <- base::invokeRestart
[17:43:53.568]                     is.null <- base::is.null
[17:43:53.568]                     muffled <- FALSE
[17:43:53.568]                     if (inherits(cond, "message")) {
[17:43:53.568]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:53.568]                       if (muffled) 
[17:43:53.568]                         invokeRestart("muffleMessage")
[17:43:53.568]                     }
[17:43:53.568]                     else if (inherits(cond, "warning")) {
[17:43:53.568]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:53.568]                       if (muffled) 
[17:43:53.568]                         invokeRestart("muffleWarning")
[17:43:53.568]                     }
[17:43:53.568]                     else if (inherits(cond, "condition")) {
[17:43:53.568]                       if (!is.null(pattern)) {
[17:43:53.568]                         computeRestarts <- base::computeRestarts
[17:43:53.568]                         grepl <- base::grepl
[17:43:53.568]                         restarts <- computeRestarts(cond)
[17:43:53.568]                         for (restart in restarts) {
[17:43:53.568]                           name <- restart$name
[17:43:53.568]                           if (is.null(name)) 
[17:43:53.568]                             next
[17:43:53.568]                           if (!grepl(pattern, name)) 
[17:43:53.568]                             next
[17:43:53.568]                           invokeRestart(restart)
[17:43:53.568]                           muffled <- TRUE
[17:43:53.568]                           break
[17:43:53.568]                         }
[17:43:53.568]                       }
[17:43:53.568]                     }
[17:43:53.568]                     invisible(muffled)
[17:43:53.568]                   }
[17:43:53.568]                   muffleCondition(cond)
[17:43:53.568]                 })
[17:43:53.568]             }))
[17:43:53.568]             future::FutureResult(value = ...future.value$value, 
[17:43:53.568]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.568]                   ...future.rng), globalenv = if (FALSE) 
[17:43:53.568]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:53.568]                     ...future.globalenv.names))
[17:43:53.568]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:53.568]         }, condition = base::local({
[17:43:53.568]             c <- base::c
[17:43:53.568]             inherits <- base::inherits
[17:43:53.568]             invokeRestart <- base::invokeRestart
[17:43:53.568]             length <- base::length
[17:43:53.568]             list <- base::list
[17:43:53.568]             seq.int <- base::seq.int
[17:43:53.568]             signalCondition <- base::signalCondition
[17:43:53.568]             sys.calls <- base::sys.calls
[17:43:53.568]             `[[` <- base::`[[`
[17:43:53.568]             `+` <- base::`+`
[17:43:53.568]             `<<-` <- base::`<<-`
[17:43:53.568]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:53.568]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:53.568]                   3L)]
[17:43:53.568]             }
[17:43:53.568]             function(cond) {
[17:43:53.568]                 is_error <- inherits(cond, "error")
[17:43:53.568]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:53.568]                   NULL)
[17:43:53.568]                 if (is_error) {
[17:43:53.568]                   sessionInformation <- function() {
[17:43:53.568]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:53.568]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:53.568]                       search = base::search(), system = base::Sys.info())
[17:43:53.568]                   }
[17:43:53.568]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.568]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:53.568]                     cond$call), session = sessionInformation(), 
[17:43:53.568]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:53.568]                   signalCondition(cond)
[17:43:53.568]                 }
[17:43:53.568]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:53.568]                 "immediateCondition"))) {
[17:43:53.568]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:53.568]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.568]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:53.568]                   if (TRUE && !signal) {
[17:43:53.568]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.568]                     {
[17:43:53.568]                       inherits <- base::inherits
[17:43:53.568]                       invokeRestart <- base::invokeRestart
[17:43:53.568]                       is.null <- base::is.null
[17:43:53.568]                       muffled <- FALSE
[17:43:53.568]                       if (inherits(cond, "message")) {
[17:43:53.568]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.568]                         if (muffled) 
[17:43:53.568]                           invokeRestart("muffleMessage")
[17:43:53.568]                       }
[17:43:53.568]                       else if (inherits(cond, "warning")) {
[17:43:53.568]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.568]                         if (muffled) 
[17:43:53.568]                           invokeRestart("muffleWarning")
[17:43:53.568]                       }
[17:43:53.568]                       else if (inherits(cond, "condition")) {
[17:43:53.568]                         if (!is.null(pattern)) {
[17:43:53.568]                           computeRestarts <- base::computeRestarts
[17:43:53.568]                           grepl <- base::grepl
[17:43:53.568]                           restarts <- computeRestarts(cond)
[17:43:53.568]                           for (restart in restarts) {
[17:43:53.568]                             name <- restart$name
[17:43:53.568]                             if (is.null(name)) 
[17:43:53.568]                               next
[17:43:53.568]                             if (!grepl(pattern, name)) 
[17:43:53.568]                               next
[17:43:53.568]                             invokeRestart(restart)
[17:43:53.568]                             muffled <- TRUE
[17:43:53.568]                             break
[17:43:53.568]                           }
[17:43:53.568]                         }
[17:43:53.568]                       }
[17:43:53.568]                       invisible(muffled)
[17:43:53.568]                     }
[17:43:53.568]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.568]                   }
[17:43:53.568]                 }
[17:43:53.568]                 else {
[17:43:53.568]                   if (TRUE) {
[17:43:53.568]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.568]                     {
[17:43:53.568]                       inherits <- base::inherits
[17:43:53.568]                       invokeRestart <- base::invokeRestart
[17:43:53.568]                       is.null <- base::is.null
[17:43:53.568]                       muffled <- FALSE
[17:43:53.568]                       if (inherits(cond, "message")) {
[17:43:53.568]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.568]                         if (muffled) 
[17:43:53.568]                           invokeRestart("muffleMessage")
[17:43:53.568]                       }
[17:43:53.568]                       else if (inherits(cond, "warning")) {
[17:43:53.568]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.568]                         if (muffled) 
[17:43:53.568]                           invokeRestart("muffleWarning")
[17:43:53.568]                       }
[17:43:53.568]                       else if (inherits(cond, "condition")) {
[17:43:53.568]                         if (!is.null(pattern)) {
[17:43:53.568]                           computeRestarts <- base::computeRestarts
[17:43:53.568]                           grepl <- base::grepl
[17:43:53.568]                           restarts <- computeRestarts(cond)
[17:43:53.568]                           for (restart in restarts) {
[17:43:53.568]                             name <- restart$name
[17:43:53.568]                             if (is.null(name)) 
[17:43:53.568]                               next
[17:43:53.568]                             if (!grepl(pattern, name)) 
[17:43:53.568]                               next
[17:43:53.568]                             invokeRestart(restart)
[17:43:53.568]                             muffled <- TRUE
[17:43:53.568]                             break
[17:43:53.568]                           }
[17:43:53.568]                         }
[17:43:53.568]                       }
[17:43:53.568]                       invisible(muffled)
[17:43:53.568]                     }
[17:43:53.568]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.568]                   }
[17:43:53.568]                 }
[17:43:53.568]             }
[17:43:53.568]         }))
[17:43:53.568]     }, error = function(ex) {
[17:43:53.568]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:53.568]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.568]                 ...future.rng), started = ...future.startTime, 
[17:43:53.568]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:53.568]             version = "1.8"), class = "FutureResult")
[17:43:53.568]     }, finally = {
[17:43:53.568]         if (!identical(...future.workdir, getwd())) 
[17:43:53.568]             setwd(...future.workdir)
[17:43:53.568]         {
[17:43:53.568]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:53.568]                 ...future.oldOptions$nwarnings <- NULL
[17:43:53.568]             }
[17:43:53.568]             base::options(...future.oldOptions)
[17:43:53.568]             if (.Platform$OS.type == "windows") {
[17:43:53.568]                 old_names <- names(...future.oldEnvVars)
[17:43:53.568]                 envs <- base::Sys.getenv()
[17:43:53.568]                 names <- names(envs)
[17:43:53.568]                 common <- intersect(names, old_names)
[17:43:53.568]                 added <- setdiff(names, old_names)
[17:43:53.568]                 removed <- setdiff(old_names, names)
[17:43:53.568]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:53.568]                   envs[common]]
[17:43:53.568]                 NAMES <- toupper(changed)
[17:43:53.568]                 args <- list()
[17:43:53.568]                 for (kk in seq_along(NAMES)) {
[17:43:53.568]                   name <- changed[[kk]]
[17:43:53.568]                   NAME <- NAMES[[kk]]
[17:43:53.568]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.568]                     next
[17:43:53.568]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.568]                 }
[17:43:53.568]                 NAMES <- toupper(added)
[17:43:53.568]                 for (kk in seq_along(NAMES)) {
[17:43:53.568]                   name <- added[[kk]]
[17:43:53.568]                   NAME <- NAMES[[kk]]
[17:43:53.568]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.568]                     next
[17:43:53.568]                   args[[name]] <- ""
[17:43:53.568]                 }
[17:43:53.568]                 NAMES <- toupper(removed)
[17:43:53.568]                 for (kk in seq_along(NAMES)) {
[17:43:53.568]                   name <- removed[[kk]]
[17:43:53.568]                   NAME <- NAMES[[kk]]
[17:43:53.568]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.568]                     next
[17:43:53.568]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.568]                 }
[17:43:53.568]                 if (length(args) > 0) 
[17:43:53.568]                   base::do.call(base::Sys.setenv, args = args)
[17:43:53.568]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:53.568]             }
[17:43:53.568]             else {
[17:43:53.568]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:53.568]             }
[17:43:53.568]             {
[17:43:53.568]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:53.568]                   0L) {
[17:43:53.568]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:53.568]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:53.568]                   base::options(opts)
[17:43:53.568]                 }
[17:43:53.568]                 {
[17:43:53.568]                   {
[17:43:53.568]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:53.568]                     NULL
[17:43:53.568]                   }
[17:43:53.568]                   options(future.plan = NULL)
[17:43:53.568]                   if (is.na(NA_character_)) 
[17:43:53.568]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.568]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:53.568]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:53.568]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:53.568]                     envir = parent.frame()) 
[17:43:53.568]                   {
[17:43:53.568]                     if (is.function(workers)) 
[17:43:53.568]                       workers <- workers()
[17:43:53.568]                     workers <- structure(as.integer(workers), 
[17:43:53.568]                       class = class(workers))
[17:43:53.568]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:53.568]                       workers >= 1)
[17:43:53.568]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:53.568]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:53.568]                     }
[17:43:53.568]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:53.568]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:53.568]                       envir = envir)
[17:43:53.568]                     if (!future$lazy) 
[17:43:53.568]                       future <- run(future)
[17:43:53.568]                     invisible(future)
[17:43:53.568]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:53.568]                 }
[17:43:53.568]             }
[17:43:53.568]         }
[17:43:53.568]     })
[17:43:53.568]     if (TRUE) {
[17:43:53.568]         base::sink(type = "output", split = FALSE)
[17:43:53.568]         if (TRUE) {
[17:43:53.568]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:53.568]         }
[17:43:53.568]         else {
[17:43:53.568]             ...future.result["stdout"] <- base::list(NULL)
[17:43:53.568]         }
[17:43:53.568]         base::close(...future.stdout)
[17:43:53.568]         ...future.stdout <- NULL
[17:43:53.568]     }
[17:43:53.568]     ...future.result$conditions <- ...future.conditions
[17:43:53.568]     ...future.result$finished <- base::Sys.time()
[17:43:53.568]     ...future.result
[17:43:53.568] }
[17:43:53.572] MultisessionFuture started
[17:43:53.572] - Launch lazy future ... done
[17:43:53.572] run() for ‘MultisessionFuture’ ... done
[17:43:53.572] getGlobalsAndPackages() ...
[17:43:53.572] Searching for globals...
[17:43:53.573] 
[17:43:53.573] Searching for globals ... DONE
[17:43:53.573] - globals: [0] <none>
[17:43:53.573] getGlobalsAndPackages() ... DONE
[17:43:53.573] run() for ‘Future’ ...
[17:43:53.573] - state: ‘created’
[17:43:53.573] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:53.588] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:53.588] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:53.588]   - Field: ‘node’
[17:43:53.588]   - Field: ‘label’
[17:43:53.588]   - Field: ‘local’
[17:43:53.588]   - Field: ‘owner’
[17:43:53.588]   - Field: ‘envir’
[17:43:53.588]   - Field: ‘workers’
[17:43:53.588]   - Field: ‘packages’
[17:43:53.588]   - Field: ‘gc’
[17:43:53.589]   - Field: ‘conditions’
[17:43:53.589]   - Field: ‘persistent’
[17:43:53.589]   - Field: ‘expr’
[17:43:53.589]   - Field: ‘uuid’
[17:43:53.589]   - Field: ‘seed’
[17:43:53.589]   - Field: ‘version’
[17:43:53.589]   - Field: ‘result’
[17:43:53.589]   - Field: ‘asynchronous’
[17:43:53.589]   - Field: ‘calls’
[17:43:53.589]   - Field: ‘globals’
[17:43:53.589]   - Field: ‘stdout’
[17:43:53.590]   - Field: ‘earlySignal’
[17:43:53.590]   - Field: ‘lazy’
[17:43:53.590]   - Field: ‘state’
[17:43:53.590] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:53.590] - Launch lazy future ...
[17:43:53.590] Packages needed by the future expression (n = 0): <none>
[17:43:53.590] Packages needed by future strategies (n = 0): <none>
[17:43:53.591] {
[17:43:53.591]     {
[17:43:53.591]         {
[17:43:53.591]             ...future.startTime <- base::Sys.time()
[17:43:53.591]             {
[17:43:53.591]                 {
[17:43:53.591]                   {
[17:43:53.591]                     {
[17:43:53.591]                       base::local({
[17:43:53.591]                         has_future <- base::requireNamespace("future", 
[17:43:53.591]                           quietly = TRUE)
[17:43:53.591]                         if (has_future) {
[17:43:53.591]                           ns <- base::getNamespace("future")
[17:43:53.591]                           version <- ns[[".package"]][["version"]]
[17:43:53.591]                           if (is.null(version)) 
[17:43:53.591]                             version <- utils::packageVersion("future")
[17:43:53.591]                         }
[17:43:53.591]                         else {
[17:43:53.591]                           version <- NULL
[17:43:53.591]                         }
[17:43:53.591]                         if (!has_future || version < "1.8.0") {
[17:43:53.591]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:53.591]                             "", base::R.version$version.string), 
[17:43:53.591]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:53.591]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:53.591]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:53.591]                               "release", "version")], collapse = " "), 
[17:43:53.591]                             hostname = base::Sys.info()[["nodename"]])
[17:43:53.591]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:53.591]                             info)
[17:43:53.591]                           info <- base::paste(info, collapse = "; ")
[17:43:53.591]                           if (!has_future) {
[17:43:53.591]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:53.591]                               info)
[17:43:53.591]                           }
[17:43:53.591]                           else {
[17:43:53.591]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:53.591]                               info, version)
[17:43:53.591]                           }
[17:43:53.591]                           base::stop(msg)
[17:43:53.591]                         }
[17:43:53.591]                       })
[17:43:53.591]                     }
[17:43:53.591]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:53.591]                     base::options(mc.cores = 1L)
[17:43:53.591]                   }
[17:43:53.591]                   options(future.plan = NULL)
[17:43:53.591]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.591]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:53.591]                 }
[17:43:53.591]                 ...future.workdir <- getwd()
[17:43:53.591]             }
[17:43:53.591]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:53.591]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:53.591]         }
[17:43:53.591]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:53.591]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:53.591]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:53.591]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:53.591]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:53.591]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:53.591]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:53.591]             base::names(...future.oldOptions))
[17:43:53.591]     }
[17:43:53.591]     if (FALSE) {
[17:43:53.591]     }
[17:43:53.591]     else {
[17:43:53.591]         if (TRUE) {
[17:43:53.591]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:53.591]                 open = "w")
[17:43:53.591]         }
[17:43:53.591]         else {
[17:43:53.591]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:53.591]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:53.591]         }
[17:43:53.591]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:53.591]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:53.591]             base::sink(type = "output", split = FALSE)
[17:43:53.591]             base::close(...future.stdout)
[17:43:53.591]         }, add = TRUE)
[17:43:53.591]     }
[17:43:53.591]     ...future.frame <- base::sys.nframe()
[17:43:53.591]     ...future.conditions <- base::list()
[17:43:53.591]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:53.591]     if (FALSE) {
[17:43:53.591]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:53.591]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:53.591]     }
[17:43:53.591]     ...future.result <- base::tryCatch({
[17:43:53.591]         base::withCallingHandlers({
[17:43:53.591]             ...future.value <- base::withVisible(base::local({
[17:43:53.591]                 ...future.makeSendCondition <- local({
[17:43:53.591]                   sendCondition <- NULL
[17:43:53.591]                   function(frame = 1L) {
[17:43:53.591]                     if (is.function(sendCondition)) 
[17:43:53.591]                       return(sendCondition)
[17:43:53.591]                     ns <- getNamespace("parallel")
[17:43:53.591]                     if (exists("sendData", mode = "function", 
[17:43:53.591]                       envir = ns)) {
[17:43:53.591]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:53.591]                         envir = ns)
[17:43:53.591]                       envir <- sys.frame(frame)
[17:43:53.591]                       master <- NULL
[17:43:53.591]                       while (!identical(envir, .GlobalEnv) && 
[17:43:53.591]                         !identical(envir, emptyenv())) {
[17:43:53.591]                         if (exists("master", mode = "list", envir = envir, 
[17:43:53.591]                           inherits = FALSE)) {
[17:43:53.591]                           master <- get("master", mode = "list", 
[17:43:53.591]                             envir = envir, inherits = FALSE)
[17:43:53.591]                           if (inherits(master, c("SOCKnode", 
[17:43:53.591]                             "SOCK0node"))) {
[17:43:53.591]                             sendCondition <<- function(cond) {
[17:43:53.591]                               data <- list(type = "VALUE", value = cond, 
[17:43:53.591]                                 success = TRUE)
[17:43:53.591]                               parallel_sendData(master, data)
[17:43:53.591]                             }
[17:43:53.591]                             return(sendCondition)
[17:43:53.591]                           }
[17:43:53.591]                         }
[17:43:53.591]                         frame <- frame + 1L
[17:43:53.591]                         envir <- sys.frame(frame)
[17:43:53.591]                       }
[17:43:53.591]                     }
[17:43:53.591]                     sendCondition <<- function(cond) NULL
[17:43:53.591]                   }
[17:43:53.591]                 })
[17:43:53.591]                 withCallingHandlers({
[17:43:53.591]                   2
[17:43:53.591]                 }, immediateCondition = function(cond) {
[17:43:53.591]                   sendCondition <- ...future.makeSendCondition()
[17:43:53.591]                   sendCondition(cond)
[17:43:53.591]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.591]                   {
[17:43:53.591]                     inherits <- base::inherits
[17:43:53.591]                     invokeRestart <- base::invokeRestart
[17:43:53.591]                     is.null <- base::is.null
[17:43:53.591]                     muffled <- FALSE
[17:43:53.591]                     if (inherits(cond, "message")) {
[17:43:53.591]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:53.591]                       if (muffled) 
[17:43:53.591]                         invokeRestart("muffleMessage")
[17:43:53.591]                     }
[17:43:53.591]                     else if (inherits(cond, "warning")) {
[17:43:53.591]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:53.591]                       if (muffled) 
[17:43:53.591]                         invokeRestart("muffleWarning")
[17:43:53.591]                     }
[17:43:53.591]                     else if (inherits(cond, "condition")) {
[17:43:53.591]                       if (!is.null(pattern)) {
[17:43:53.591]                         computeRestarts <- base::computeRestarts
[17:43:53.591]                         grepl <- base::grepl
[17:43:53.591]                         restarts <- computeRestarts(cond)
[17:43:53.591]                         for (restart in restarts) {
[17:43:53.591]                           name <- restart$name
[17:43:53.591]                           if (is.null(name)) 
[17:43:53.591]                             next
[17:43:53.591]                           if (!grepl(pattern, name)) 
[17:43:53.591]                             next
[17:43:53.591]                           invokeRestart(restart)
[17:43:53.591]                           muffled <- TRUE
[17:43:53.591]                           break
[17:43:53.591]                         }
[17:43:53.591]                       }
[17:43:53.591]                     }
[17:43:53.591]                     invisible(muffled)
[17:43:53.591]                   }
[17:43:53.591]                   muffleCondition(cond)
[17:43:53.591]                 })
[17:43:53.591]             }))
[17:43:53.591]             future::FutureResult(value = ...future.value$value, 
[17:43:53.591]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.591]                   ...future.rng), globalenv = if (FALSE) 
[17:43:53.591]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:53.591]                     ...future.globalenv.names))
[17:43:53.591]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:53.591]         }, condition = base::local({
[17:43:53.591]             c <- base::c
[17:43:53.591]             inherits <- base::inherits
[17:43:53.591]             invokeRestart <- base::invokeRestart
[17:43:53.591]             length <- base::length
[17:43:53.591]             list <- base::list
[17:43:53.591]             seq.int <- base::seq.int
[17:43:53.591]             signalCondition <- base::signalCondition
[17:43:53.591]             sys.calls <- base::sys.calls
[17:43:53.591]             `[[` <- base::`[[`
[17:43:53.591]             `+` <- base::`+`
[17:43:53.591]             `<<-` <- base::`<<-`
[17:43:53.591]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:53.591]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:53.591]                   3L)]
[17:43:53.591]             }
[17:43:53.591]             function(cond) {
[17:43:53.591]                 is_error <- inherits(cond, "error")
[17:43:53.591]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:53.591]                   NULL)
[17:43:53.591]                 if (is_error) {
[17:43:53.591]                   sessionInformation <- function() {
[17:43:53.591]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:53.591]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:53.591]                       search = base::search(), system = base::Sys.info())
[17:43:53.591]                   }
[17:43:53.591]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.591]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:53.591]                     cond$call), session = sessionInformation(), 
[17:43:53.591]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:53.591]                   signalCondition(cond)
[17:43:53.591]                 }
[17:43:53.591]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:53.591]                 "immediateCondition"))) {
[17:43:53.591]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:53.591]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.591]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:53.591]                   if (TRUE && !signal) {
[17:43:53.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.591]                     {
[17:43:53.591]                       inherits <- base::inherits
[17:43:53.591]                       invokeRestart <- base::invokeRestart
[17:43:53.591]                       is.null <- base::is.null
[17:43:53.591]                       muffled <- FALSE
[17:43:53.591]                       if (inherits(cond, "message")) {
[17:43:53.591]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.591]                         if (muffled) 
[17:43:53.591]                           invokeRestart("muffleMessage")
[17:43:53.591]                       }
[17:43:53.591]                       else if (inherits(cond, "warning")) {
[17:43:53.591]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.591]                         if (muffled) 
[17:43:53.591]                           invokeRestart("muffleWarning")
[17:43:53.591]                       }
[17:43:53.591]                       else if (inherits(cond, "condition")) {
[17:43:53.591]                         if (!is.null(pattern)) {
[17:43:53.591]                           computeRestarts <- base::computeRestarts
[17:43:53.591]                           grepl <- base::grepl
[17:43:53.591]                           restarts <- computeRestarts(cond)
[17:43:53.591]                           for (restart in restarts) {
[17:43:53.591]                             name <- restart$name
[17:43:53.591]                             if (is.null(name)) 
[17:43:53.591]                               next
[17:43:53.591]                             if (!grepl(pattern, name)) 
[17:43:53.591]                               next
[17:43:53.591]                             invokeRestart(restart)
[17:43:53.591]                             muffled <- TRUE
[17:43:53.591]                             break
[17:43:53.591]                           }
[17:43:53.591]                         }
[17:43:53.591]                       }
[17:43:53.591]                       invisible(muffled)
[17:43:53.591]                     }
[17:43:53.591]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.591]                   }
[17:43:53.591]                 }
[17:43:53.591]                 else {
[17:43:53.591]                   if (TRUE) {
[17:43:53.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.591]                     {
[17:43:53.591]                       inherits <- base::inherits
[17:43:53.591]                       invokeRestart <- base::invokeRestart
[17:43:53.591]                       is.null <- base::is.null
[17:43:53.591]                       muffled <- FALSE
[17:43:53.591]                       if (inherits(cond, "message")) {
[17:43:53.591]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.591]                         if (muffled) 
[17:43:53.591]                           invokeRestart("muffleMessage")
[17:43:53.591]                       }
[17:43:53.591]                       else if (inherits(cond, "warning")) {
[17:43:53.591]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.591]                         if (muffled) 
[17:43:53.591]                           invokeRestart("muffleWarning")
[17:43:53.591]                       }
[17:43:53.591]                       else if (inherits(cond, "condition")) {
[17:43:53.591]                         if (!is.null(pattern)) {
[17:43:53.591]                           computeRestarts <- base::computeRestarts
[17:43:53.591]                           grepl <- base::grepl
[17:43:53.591]                           restarts <- computeRestarts(cond)
[17:43:53.591]                           for (restart in restarts) {
[17:43:53.591]                             name <- restart$name
[17:43:53.591]                             if (is.null(name)) 
[17:43:53.591]                               next
[17:43:53.591]                             if (!grepl(pattern, name)) 
[17:43:53.591]                               next
[17:43:53.591]                             invokeRestart(restart)
[17:43:53.591]                             muffled <- TRUE
[17:43:53.591]                             break
[17:43:53.591]                           }
[17:43:53.591]                         }
[17:43:53.591]                       }
[17:43:53.591]                       invisible(muffled)
[17:43:53.591]                     }
[17:43:53.591]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.591]                   }
[17:43:53.591]                 }
[17:43:53.591]             }
[17:43:53.591]         }))
[17:43:53.591]     }, error = function(ex) {
[17:43:53.591]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:53.591]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.591]                 ...future.rng), started = ...future.startTime, 
[17:43:53.591]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:53.591]             version = "1.8"), class = "FutureResult")
[17:43:53.591]     }, finally = {
[17:43:53.591]         if (!identical(...future.workdir, getwd())) 
[17:43:53.591]             setwd(...future.workdir)
[17:43:53.591]         {
[17:43:53.591]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:53.591]                 ...future.oldOptions$nwarnings <- NULL
[17:43:53.591]             }
[17:43:53.591]             base::options(...future.oldOptions)
[17:43:53.591]             if (.Platform$OS.type == "windows") {
[17:43:53.591]                 old_names <- names(...future.oldEnvVars)
[17:43:53.591]                 envs <- base::Sys.getenv()
[17:43:53.591]                 names <- names(envs)
[17:43:53.591]                 common <- intersect(names, old_names)
[17:43:53.591]                 added <- setdiff(names, old_names)
[17:43:53.591]                 removed <- setdiff(old_names, names)
[17:43:53.591]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:53.591]                   envs[common]]
[17:43:53.591]                 NAMES <- toupper(changed)
[17:43:53.591]                 args <- list()
[17:43:53.591]                 for (kk in seq_along(NAMES)) {
[17:43:53.591]                   name <- changed[[kk]]
[17:43:53.591]                   NAME <- NAMES[[kk]]
[17:43:53.591]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.591]                     next
[17:43:53.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.591]                 }
[17:43:53.591]                 NAMES <- toupper(added)
[17:43:53.591]                 for (kk in seq_along(NAMES)) {
[17:43:53.591]                   name <- added[[kk]]
[17:43:53.591]                   NAME <- NAMES[[kk]]
[17:43:53.591]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.591]                     next
[17:43:53.591]                   args[[name]] <- ""
[17:43:53.591]                 }
[17:43:53.591]                 NAMES <- toupper(removed)
[17:43:53.591]                 for (kk in seq_along(NAMES)) {
[17:43:53.591]                   name <- removed[[kk]]
[17:43:53.591]                   NAME <- NAMES[[kk]]
[17:43:53.591]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.591]                     next
[17:43:53.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.591]                 }
[17:43:53.591]                 if (length(args) > 0) 
[17:43:53.591]                   base::do.call(base::Sys.setenv, args = args)
[17:43:53.591]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:53.591]             }
[17:43:53.591]             else {
[17:43:53.591]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:53.591]             }
[17:43:53.591]             {
[17:43:53.591]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:53.591]                   0L) {
[17:43:53.591]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:53.591]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:53.591]                   base::options(opts)
[17:43:53.591]                 }
[17:43:53.591]                 {
[17:43:53.591]                   {
[17:43:53.591]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:53.591]                     NULL
[17:43:53.591]                   }
[17:43:53.591]                   options(future.plan = NULL)
[17:43:53.591]                   if (is.na(NA_character_)) 
[17:43:53.591]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.591]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:53.591]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:53.591]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:53.591]                     envir = parent.frame()) 
[17:43:53.591]                   {
[17:43:53.591]                     if (is.function(workers)) 
[17:43:53.591]                       workers <- workers()
[17:43:53.591]                     workers <- structure(as.integer(workers), 
[17:43:53.591]                       class = class(workers))
[17:43:53.591]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:53.591]                       workers >= 1)
[17:43:53.591]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:53.591]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:53.591]                     }
[17:43:53.591]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:53.591]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:53.591]                       envir = envir)
[17:43:53.591]                     if (!future$lazy) 
[17:43:53.591]                       future <- run(future)
[17:43:53.591]                     invisible(future)
[17:43:53.591]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:53.591]                 }
[17:43:53.591]             }
[17:43:53.591]         }
[17:43:53.591]     })
[17:43:53.591]     if (TRUE) {
[17:43:53.591]         base::sink(type = "output", split = FALSE)
[17:43:53.591]         if (TRUE) {
[17:43:53.591]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:53.591]         }
[17:43:53.591]         else {
[17:43:53.591]             ...future.result["stdout"] <- base::list(NULL)
[17:43:53.591]         }
[17:43:53.591]         base::close(...future.stdout)
[17:43:53.591]         ...future.stdout <- NULL
[17:43:53.591]     }
[17:43:53.591]     ...future.result$conditions <- ...future.conditions
[17:43:53.591]     ...future.result$finished <- base::Sys.time()
[17:43:53.591]     ...future.result
[17:43:53.591] }
[17:43:53.593] Poll #1 (0): usedNodes() = 2, workers = 2
[17:43:53.604] receiveMessageFromWorker() for ClusterFuture ...
[17:43:53.604] - Validating connection of MultisessionFuture
[17:43:53.604] - received message: FutureResult
[17:43:53.604] - Received FutureResult
[17:43:53.604] - Erased future from FutureRegistry
[17:43:53.605] result() for ClusterFuture ...
[17:43:53.605] - result already collected: FutureResult
[17:43:53.605] result() for ClusterFuture ... done
[17:43:53.605] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:53.605] result() for ClusterFuture ...
[17:43:53.605] - result already collected: FutureResult
[17:43:53.605] result() for ClusterFuture ... done
[17:43:53.605] result() for ClusterFuture ...
[17:43:53.605] - result already collected: FutureResult
[17:43:53.605] result() for ClusterFuture ... done
[17:43:53.607] MultisessionFuture started
[17:43:53.607] - Launch lazy future ... done
[17:43:53.607] run() for ‘MultisessionFuture’ ... done
[17:43:53.607] resolve() on list ...
[17:43:53.607]  recursive: 0
[17:43:53.607]  length: 3
[17:43:53.607]  elements: ‘a’, ‘b’, ‘’
[17:43:53.628]  length: 2 (resolved future 3)
[17:43:53.639] receiveMessageFromWorker() for ClusterFuture ...
[17:43:53.639] - Validating connection of MultisessionFuture
[17:43:53.640] - received message: FutureResult
[17:43:53.640] - Received FutureResult
[17:43:53.640] - Erased future from FutureRegistry
[17:43:53.640] result() for ClusterFuture ...
[17:43:53.640] - result already collected: FutureResult
[17:43:53.640] result() for ClusterFuture ... done
[17:43:53.640] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:53.640] Future #1
[17:43:53.640]  length: 1 (resolved future 1)
[17:43:53.662] receiveMessageFromWorker() for ClusterFuture ...
[17:43:53.662] - Validating connection of MultisessionFuture
[17:43:53.662] - received message: FutureResult
[17:43:53.662] - Received FutureResult
[17:43:53.662] - Erased future from FutureRegistry
[17:43:53.662] result() for ClusterFuture ...
[17:43:53.662] - result already collected: FutureResult
[17:43:53.662] result() for ClusterFuture ... done
[17:43:53.663] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:53.663] Future #2
[17:43:53.663]  length: 0 (resolved future 2)
[17:43:53.663] resolve() on list ... DONE
[17:43:53.663] getGlobalsAndPackages() ...
[17:43:53.663] Searching for globals...
[17:43:53.663] 
[17:43:53.664] Searching for globals ... DONE
[17:43:53.664] - globals: [0] <none>
[17:43:53.664] getGlobalsAndPackages() ... DONE
[17:43:53.664] getGlobalsAndPackages() ...
[17:43:53.664] Searching for globals...
[17:43:53.664] 
[17:43:53.665] Searching for globals ... DONE
[17:43:53.665] - globals: [0] <none>
[17:43:53.665] getGlobalsAndPackages() ... DONE
[17:43:53.665] run() for ‘Future’ ...
[17:43:53.665] - state: ‘created’
[17:43:53.665] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:53.679] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:53.680] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:53.680]   - Field: ‘node’
[17:43:53.680]   - Field: ‘label’
[17:43:53.680]   - Field: ‘local’
[17:43:53.680]   - Field: ‘owner’
[17:43:53.680]   - Field: ‘envir’
[17:43:53.680]   - Field: ‘workers’
[17:43:53.680]   - Field: ‘packages’
[17:43:53.680]   - Field: ‘gc’
[17:43:53.680]   - Field: ‘conditions’
[17:43:53.681]   - Field: ‘persistent’
[17:43:53.681]   - Field: ‘expr’
[17:43:53.681]   - Field: ‘uuid’
[17:43:53.681]   - Field: ‘seed’
[17:43:53.681]   - Field: ‘version’
[17:43:53.681]   - Field: ‘result’
[17:43:53.681]   - Field: ‘asynchronous’
[17:43:53.681]   - Field: ‘calls’
[17:43:53.681]   - Field: ‘globals’
[17:43:53.681]   - Field: ‘stdout’
[17:43:53.681]   - Field: ‘earlySignal’
[17:43:53.682]   - Field: ‘lazy’
[17:43:53.682]   - Field: ‘state’
[17:43:53.682] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:53.682] - Launch lazy future ...
[17:43:53.682] Packages needed by the future expression (n = 0): <none>
[17:43:53.682] Packages needed by future strategies (n = 0): <none>
[17:43:53.683] {
[17:43:53.683]     {
[17:43:53.683]         {
[17:43:53.683]             ...future.startTime <- base::Sys.time()
[17:43:53.683]             {
[17:43:53.683]                 {
[17:43:53.683]                   {
[17:43:53.683]                     {
[17:43:53.683]                       base::local({
[17:43:53.683]                         has_future <- base::requireNamespace("future", 
[17:43:53.683]                           quietly = TRUE)
[17:43:53.683]                         if (has_future) {
[17:43:53.683]                           ns <- base::getNamespace("future")
[17:43:53.683]                           version <- ns[[".package"]][["version"]]
[17:43:53.683]                           if (is.null(version)) 
[17:43:53.683]                             version <- utils::packageVersion("future")
[17:43:53.683]                         }
[17:43:53.683]                         else {
[17:43:53.683]                           version <- NULL
[17:43:53.683]                         }
[17:43:53.683]                         if (!has_future || version < "1.8.0") {
[17:43:53.683]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:53.683]                             "", base::R.version$version.string), 
[17:43:53.683]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:53.683]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:53.683]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:53.683]                               "release", "version")], collapse = " "), 
[17:43:53.683]                             hostname = base::Sys.info()[["nodename"]])
[17:43:53.683]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:53.683]                             info)
[17:43:53.683]                           info <- base::paste(info, collapse = "; ")
[17:43:53.683]                           if (!has_future) {
[17:43:53.683]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:53.683]                               info)
[17:43:53.683]                           }
[17:43:53.683]                           else {
[17:43:53.683]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:53.683]                               info, version)
[17:43:53.683]                           }
[17:43:53.683]                           base::stop(msg)
[17:43:53.683]                         }
[17:43:53.683]                       })
[17:43:53.683]                     }
[17:43:53.683]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:53.683]                     base::options(mc.cores = 1L)
[17:43:53.683]                   }
[17:43:53.683]                   options(future.plan = NULL)
[17:43:53.683]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.683]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:53.683]                 }
[17:43:53.683]                 ...future.workdir <- getwd()
[17:43:53.683]             }
[17:43:53.683]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:53.683]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:53.683]         }
[17:43:53.683]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:53.683]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:53.683]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:53.683]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:53.683]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:53.683]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:53.683]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:53.683]             base::names(...future.oldOptions))
[17:43:53.683]     }
[17:43:53.683]     if (FALSE) {
[17:43:53.683]     }
[17:43:53.683]     else {
[17:43:53.683]         if (TRUE) {
[17:43:53.683]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:53.683]                 open = "w")
[17:43:53.683]         }
[17:43:53.683]         else {
[17:43:53.683]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:53.683]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:53.683]         }
[17:43:53.683]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:53.683]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:53.683]             base::sink(type = "output", split = FALSE)
[17:43:53.683]             base::close(...future.stdout)
[17:43:53.683]         }, add = TRUE)
[17:43:53.683]     }
[17:43:53.683]     ...future.frame <- base::sys.nframe()
[17:43:53.683]     ...future.conditions <- base::list()
[17:43:53.683]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:53.683]     if (FALSE) {
[17:43:53.683]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:53.683]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:53.683]     }
[17:43:53.683]     ...future.result <- base::tryCatch({
[17:43:53.683]         base::withCallingHandlers({
[17:43:53.683]             ...future.value <- base::withVisible(base::local({
[17:43:53.683]                 ...future.makeSendCondition <- local({
[17:43:53.683]                   sendCondition <- NULL
[17:43:53.683]                   function(frame = 1L) {
[17:43:53.683]                     if (is.function(sendCondition)) 
[17:43:53.683]                       return(sendCondition)
[17:43:53.683]                     ns <- getNamespace("parallel")
[17:43:53.683]                     if (exists("sendData", mode = "function", 
[17:43:53.683]                       envir = ns)) {
[17:43:53.683]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:53.683]                         envir = ns)
[17:43:53.683]                       envir <- sys.frame(frame)
[17:43:53.683]                       master <- NULL
[17:43:53.683]                       while (!identical(envir, .GlobalEnv) && 
[17:43:53.683]                         !identical(envir, emptyenv())) {
[17:43:53.683]                         if (exists("master", mode = "list", envir = envir, 
[17:43:53.683]                           inherits = FALSE)) {
[17:43:53.683]                           master <- get("master", mode = "list", 
[17:43:53.683]                             envir = envir, inherits = FALSE)
[17:43:53.683]                           if (inherits(master, c("SOCKnode", 
[17:43:53.683]                             "SOCK0node"))) {
[17:43:53.683]                             sendCondition <<- function(cond) {
[17:43:53.683]                               data <- list(type = "VALUE", value = cond, 
[17:43:53.683]                                 success = TRUE)
[17:43:53.683]                               parallel_sendData(master, data)
[17:43:53.683]                             }
[17:43:53.683]                             return(sendCondition)
[17:43:53.683]                           }
[17:43:53.683]                         }
[17:43:53.683]                         frame <- frame + 1L
[17:43:53.683]                         envir <- sys.frame(frame)
[17:43:53.683]                       }
[17:43:53.683]                     }
[17:43:53.683]                     sendCondition <<- function(cond) NULL
[17:43:53.683]                   }
[17:43:53.683]                 })
[17:43:53.683]                 withCallingHandlers({
[17:43:53.683]                   2
[17:43:53.683]                 }, immediateCondition = function(cond) {
[17:43:53.683]                   sendCondition <- ...future.makeSendCondition()
[17:43:53.683]                   sendCondition(cond)
[17:43:53.683]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.683]                   {
[17:43:53.683]                     inherits <- base::inherits
[17:43:53.683]                     invokeRestart <- base::invokeRestart
[17:43:53.683]                     is.null <- base::is.null
[17:43:53.683]                     muffled <- FALSE
[17:43:53.683]                     if (inherits(cond, "message")) {
[17:43:53.683]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:53.683]                       if (muffled) 
[17:43:53.683]                         invokeRestart("muffleMessage")
[17:43:53.683]                     }
[17:43:53.683]                     else if (inherits(cond, "warning")) {
[17:43:53.683]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:53.683]                       if (muffled) 
[17:43:53.683]                         invokeRestart("muffleWarning")
[17:43:53.683]                     }
[17:43:53.683]                     else if (inherits(cond, "condition")) {
[17:43:53.683]                       if (!is.null(pattern)) {
[17:43:53.683]                         computeRestarts <- base::computeRestarts
[17:43:53.683]                         grepl <- base::grepl
[17:43:53.683]                         restarts <- computeRestarts(cond)
[17:43:53.683]                         for (restart in restarts) {
[17:43:53.683]                           name <- restart$name
[17:43:53.683]                           if (is.null(name)) 
[17:43:53.683]                             next
[17:43:53.683]                           if (!grepl(pattern, name)) 
[17:43:53.683]                             next
[17:43:53.683]                           invokeRestart(restart)
[17:43:53.683]                           muffled <- TRUE
[17:43:53.683]                           break
[17:43:53.683]                         }
[17:43:53.683]                       }
[17:43:53.683]                     }
[17:43:53.683]                     invisible(muffled)
[17:43:53.683]                   }
[17:43:53.683]                   muffleCondition(cond)
[17:43:53.683]                 })
[17:43:53.683]             }))
[17:43:53.683]             future::FutureResult(value = ...future.value$value, 
[17:43:53.683]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.683]                   ...future.rng), globalenv = if (FALSE) 
[17:43:53.683]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:53.683]                     ...future.globalenv.names))
[17:43:53.683]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:53.683]         }, condition = base::local({
[17:43:53.683]             c <- base::c
[17:43:53.683]             inherits <- base::inherits
[17:43:53.683]             invokeRestart <- base::invokeRestart
[17:43:53.683]             length <- base::length
[17:43:53.683]             list <- base::list
[17:43:53.683]             seq.int <- base::seq.int
[17:43:53.683]             signalCondition <- base::signalCondition
[17:43:53.683]             sys.calls <- base::sys.calls
[17:43:53.683]             `[[` <- base::`[[`
[17:43:53.683]             `+` <- base::`+`
[17:43:53.683]             `<<-` <- base::`<<-`
[17:43:53.683]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:53.683]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:53.683]                   3L)]
[17:43:53.683]             }
[17:43:53.683]             function(cond) {
[17:43:53.683]                 is_error <- inherits(cond, "error")
[17:43:53.683]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:53.683]                   NULL)
[17:43:53.683]                 if (is_error) {
[17:43:53.683]                   sessionInformation <- function() {
[17:43:53.683]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:53.683]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:53.683]                       search = base::search(), system = base::Sys.info())
[17:43:53.683]                   }
[17:43:53.683]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.683]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:53.683]                     cond$call), session = sessionInformation(), 
[17:43:53.683]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:53.683]                   signalCondition(cond)
[17:43:53.683]                 }
[17:43:53.683]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:53.683]                 "immediateCondition"))) {
[17:43:53.683]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:53.683]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.683]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:53.683]                   if (TRUE && !signal) {
[17:43:53.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.683]                     {
[17:43:53.683]                       inherits <- base::inherits
[17:43:53.683]                       invokeRestart <- base::invokeRestart
[17:43:53.683]                       is.null <- base::is.null
[17:43:53.683]                       muffled <- FALSE
[17:43:53.683]                       if (inherits(cond, "message")) {
[17:43:53.683]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.683]                         if (muffled) 
[17:43:53.683]                           invokeRestart("muffleMessage")
[17:43:53.683]                       }
[17:43:53.683]                       else if (inherits(cond, "warning")) {
[17:43:53.683]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.683]                         if (muffled) 
[17:43:53.683]                           invokeRestart("muffleWarning")
[17:43:53.683]                       }
[17:43:53.683]                       else if (inherits(cond, "condition")) {
[17:43:53.683]                         if (!is.null(pattern)) {
[17:43:53.683]                           computeRestarts <- base::computeRestarts
[17:43:53.683]                           grepl <- base::grepl
[17:43:53.683]                           restarts <- computeRestarts(cond)
[17:43:53.683]                           for (restart in restarts) {
[17:43:53.683]                             name <- restart$name
[17:43:53.683]                             if (is.null(name)) 
[17:43:53.683]                               next
[17:43:53.683]                             if (!grepl(pattern, name)) 
[17:43:53.683]                               next
[17:43:53.683]                             invokeRestart(restart)
[17:43:53.683]                             muffled <- TRUE
[17:43:53.683]                             break
[17:43:53.683]                           }
[17:43:53.683]                         }
[17:43:53.683]                       }
[17:43:53.683]                       invisible(muffled)
[17:43:53.683]                     }
[17:43:53.683]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.683]                   }
[17:43:53.683]                 }
[17:43:53.683]                 else {
[17:43:53.683]                   if (TRUE) {
[17:43:53.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.683]                     {
[17:43:53.683]                       inherits <- base::inherits
[17:43:53.683]                       invokeRestart <- base::invokeRestart
[17:43:53.683]                       is.null <- base::is.null
[17:43:53.683]                       muffled <- FALSE
[17:43:53.683]                       if (inherits(cond, "message")) {
[17:43:53.683]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.683]                         if (muffled) 
[17:43:53.683]                           invokeRestart("muffleMessage")
[17:43:53.683]                       }
[17:43:53.683]                       else if (inherits(cond, "warning")) {
[17:43:53.683]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.683]                         if (muffled) 
[17:43:53.683]                           invokeRestart("muffleWarning")
[17:43:53.683]                       }
[17:43:53.683]                       else if (inherits(cond, "condition")) {
[17:43:53.683]                         if (!is.null(pattern)) {
[17:43:53.683]                           computeRestarts <- base::computeRestarts
[17:43:53.683]                           grepl <- base::grepl
[17:43:53.683]                           restarts <- computeRestarts(cond)
[17:43:53.683]                           for (restart in restarts) {
[17:43:53.683]                             name <- restart$name
[17:43:53.683]                             if (is.null(name)) 
[17:43:53.683]                               next
[17:43:53.683]                             if (!grepl(pattern, name)) 
[17:43:53.683]                               next
[17:43:53.683]                             invokeRestart(restart)
[17:43:53.683]                             muffled <- TRUE
[17:43:53.683]                             break
[17:43:53.683]                           }
[17:43:53.683]                         }
[17:43:53.683]                       }
[17:43:53.683]                       invisible(muffled)
[17:43:53.683]                     }
[17:43:53.683]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.683]                   }
[17:43:53.683]                 }
[17:43:53.683]             }
[17:43:53.683]         }))
[17:43:53.683]     }, error = function(ex) {
[17:43:53.683]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:53.683]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.683]                 ...future.rng), started = ...future.startTime, 
[17:43:53.683]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:53.683]             version = "1.8"), class = "FutureResult")
[17:43:53.683]     }, finally = {
[17:43:53.683]         if (!identical(...future.workdir, getwd())) 
[17:43:53.683]             setwd(...future.workdir)
[17:43:53.683]         {
[17:43:53.683]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:53.683]                 ...future.oldOptions$nwarnings <- NULL
[17:43:53.683]             }
[17:43:53.683]             base::options(...future.oldOptions)
[17:43:53.683]             if (.Platform$OS.type == "windows") {
[17:43:53.683]                 old_names <- names(...future.oldEnvVars)
[17:43:53.683]                 envs <- base::Sys.getenv()
[17:43:53.683]                 names <- names(envs)
[17:43:53.683]                 common <- intersect(names, old_names)
[17:43:53.683]                 added <- setdiff(names, old_names)
[17:43:53.683]                 removed <- setdiff(old_names, names)
[17:43:53.683]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:53.683]                   envs[common]]
[17:43:53.683]                 NAMES <- toupper(changed)
[17:43:53.683]                 args <- list()
[17:43:53.683]                 for (kk in seq_along(NAMES)) {
[17:43:53.683]                   name <- changed[[kk]]
[17:43:53.683]                   NAME <- NAMES[[kk]]
[17:43:53.683]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.683]                     next
[17:43:53.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.683]                 }
[17:43:53.683]                 NAMES <- toupper(added)
[17:43:53.683]                 for (kk in seq_along(NAMES)) {
[17:43:53.683]                   name <- added[[kk]]
[17:43:53.683]                   NAME <- NAMES[[kk]]
[17:43:53.683]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.683]                     next
[17:43:53.683]                   args[[name]] <- ""
[17:43:53.683]                 }
[17:43:53.683]                 NAMES <- toupper(removed)
[17:43:53.683]                 for (kk in seq_along(NAMES)) {
[17:43:53.683]                   name <- removed[[kk]]
[17:43:53.683]                   NAME <- NAMES[[kk]]
[17:43:53.683]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.683]                     next
[17:43:53.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.683]                 }
[17:43:53.683]                 if (length(args) > 0) 
[17:43:53.683]                   base::do.call(base::Sys.setenv, args = args)
[17:43:53.683]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:53.683]             }
[17:43:53.683]             else {
[17:43:53.683]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:53.683]             }
[17:43:53.683]             {
[17:43:53.683]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:53.683]                   0L) {
[17:43:53.683]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:53.683]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:53.683]                   base::options(opts)
[17:43:53.683]                 }
[17:43:53.683]                 {
[17:43:53.683]                   {
[17:43:53.683]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:53.683]                     NULL
[17:43:53.683]                   }
[17:43:53.683]                   options(future.plan = NULL)
[17:43:53.683]                   if (is.na(NA_character_)) 
[17:43:53.683]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.683]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:53.683]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:53.683]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:53.683]                     envir = parent.frame()) 
[17:43:53.683]                   {
[17:43:53.683]                     if (is.function(workers)) 
[17:43:53.683]                       workers <- workers()
[17:43:53.683]                     workers <- structure(as.integer(workers), 
[17:43:53.683]                       class = class(workers))
[17:43:53.683]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:53.683]                       workers >= 1)
[17:43:53.683]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:53.683]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:53.683]                     }
[17:43:53.683]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:53.683]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:53.683]                       envir = envir)
[17:43:53.683]                     if (!future$lazy) 
[17:43:53.683]                       future <- run(future)
[17:43:53.683]                     invisible(future)
[17:43:53.683]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:53.683]                 }
[17:43:53.683]             }
[17:43:53.683]         }
[17:43:53.683]     })
[17:43:53.683]     if (TRUE) {
[17:43:53.683]         base::sink(type = "output", split = FALSE)
[17:43:53.683]         if (TRUE) {
[17:43:53.683]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:53.683]         }
[17:43:53.683]         else {
[17:43:53.683]             ...future.result["stdout"] <- base::list(NULL)
[17:43:53.683]         }
[17:43:53.683]         base::close(...future.stdout)
[17:43:53.683]         ...future.stdout <- NULL
[17:43:53.683]     }
[17:43:53.683]     ...future.result$conditions <- ...future.conditions
[17:43:53.683]     ...future.result$finished <- base::Sys.time()
[17:43:53.683]     ...future.result
[17:43:53.683] }
[17:43:53.686] MultisessionFuture started
[17:43:53.686] - Launch lazy future ... done
[17:43:53.686] run() for ‘MultisessionFuture’ ... done
[17:43:53.686] resolve() on list ...
[17:43:53.686]  recursive: 0
[17:43:53.686]  length: 3
[17:43:53.687]  elements: ‘a’, ‘b’, ‘’
[17:43:53.687] run() for ‘Future’ ...
[17:43:53.687] - state: ‘created’
[17:43:53.687] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:53.701] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:53.702] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:53.702]   - Field: ‘node’
[17:43:53.702]   - Field: ‘label’
[17:43:53.702]   - Field: ‘local’
[17:43:53.702]   - Field: ‘owner’
[17:43:53.702]   - Field: ‘envir’
[17:43:53.702]   - Field: ‘workers’
[17:43:53.702]   - Field: ‘packages’
[17:43:53.702]   - Field: ‘gc’
[17:43:53.702]   - Field: ‘conditions’
[17:43:53.703]   - Field: ‘persistent’
[17:43:53.703]   - Field: ‘expr’
[17:43:53.703]   - Field: ‘uuid’
[17:43:53.703]   - Field: ‘seed’
[17:43:53.703]   - Field: ‘version’
[17:43:53.703]   - Field: ‘result’
[17:43:53.703]   - Field: ‘asynchronous’
[17:43:53.703]   - Field: ‘calls’
[17:43:53.703]   - Field: ‘globals’
[17:43:53.703]   - Field: ‘stdout’
[17:43:53.704]   - Field: ‘earlySignal’
[17:43:53.704]   - Field: ‘lazy’
[17:43:53.704]   - Field: ‘state’
[17:43:53.704] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:53.704] - Launch lazy future ...
[17:43:53.704] Packages needed by the future expression (n = 0): <none>
[17:43:53.704] Packages needed by future strategies (n = 0): <none>
[17:43:53.705] {
[17:43:53.705]     {
[17:43:53.705]         {
[17:43:53.705]             ...future.startTime <- base::Sys.time()
[17:43:53.705]             {
[17:43:53.705]                 {
[17:43:53.705]                   {
[17:43:53.705]                     {
[17:43:53.705]                       base::local({
[17:43:53.705]                         has_future <- base::requireNamespace("future", 
[17:43:53.705]                           quietly = TRUE)
[17:43:53.705]                         if (has_future) {
[17:43:53.705]                           ns <- base::getNamespace("future")
[17:43:53.705]                           version <- ns[[".package"]][["version"]]
[17:43:53.705]                           if (is.null(version)) 
[17:43:53.705]                             version <- utils::packageVersion("future")
[17:43:53.705]                         }
[17:43:53.705]                         else {
[17:43:53.705]                           version <- NULL
[17:43:53.705]                         }
[17:43:53.705]                         if (!has_future || version < "1.8.0") {
[17:43:53.705]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:53.705]                             "", base::R.version$version.string), 
[17:43:53.705]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:53.705]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:53.705]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:53.705]                               "release", "version")], collapse = " "), 
[17:43:53.705]                             hostname = base::Sys.info()[["nodename"]])
[17:43:53.705]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:53.705]                             info)
[17:43:53.705]                           info <- base::paste(info, collapse = "; ")
[17:43:53.705]                           if (!has_future) {
[17:43:53.705]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:53.705]                               info)
[17:43:53.705]                           }
[17:43:53.705]                           else {
[17:43:53.705]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:53.705]                               info, version)
[17:43:53.705]                           }
[17:43:53.705]                           base::stop(msg)
[17:43:53.705]                         }
[17:43:53.705]                       })
[17:43:53.705]                     }
[17:43:53.705]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:53.705]                     base::options(mc.cores = 1L)
[17:43:53.705]                   }
[17:43:53.705]                   options(future.plan = NULL)
[17:43:53.705]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.705]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:53.705]                 }
[17:43:53.705]                 ...future.workdir <- getwd()
[17:43:53.705]             }
[17:43:53.705]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:53.705]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:53.705]         }
[17:43:53.705]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:53.705]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:53.705]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:53.705]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:53.705]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:53.705]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:53.705]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:53.705]             base::names(...future.oldOptions))
[17:43:53.705]     }
[17:43:53.705]     if (FALSE) {
[17:43:53.705]     }
[17:43:53.705]     else {
[17:43:53.705]         if (TRUE) {
[17:43:53.705]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:53.705]                 open = "w")
[17:43:53.705]         }
[17:43:53.705]         else {
[17:43:53.705]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:53.705]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:53.705]         }
[17:43:53.705]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:53.705]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:53.705]             base::sink(type = "output", split = FALSE)
[17:43:53.705]             base::close(...future.stdout)
[17:43:53.705]         }, add = TRUE)
[17:43:53.705]     }
[17:43:53.705]     ...future.frame <- base::sys.nframe()
[17:43:53.705]     ...future.conditions <- base::list()
[17:43:53.705]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:53.705]     if (FALSE) {
[17:43:53.705]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:53.705]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:53.705]     }
[17:43:53.705]     ...future.result <- base::tryCatch({
[17:43:53.705]         base::withCallingHandlers({
[17:43:53.705]             ...future.value <- base::withVisible(base::local({
[17:43:53.705]                 ...future.makeSendCondition <- local({
[17:43:53.705]                   sendCondition <- NULL
[17:43:53.705]                   function(frame = 1L) {
[17:43:53.705]                     if (is.function(sendCondition)) 
[17:43:53.705]                       return(sendCondition)
[17:43:53.705]                     ns <- getNamespace("parallel")
[17:43:53.705]                     if (exists("sendData", mode = "function", 
[17:43:53.705]                       envir = ns)) {
[17:43:53.705]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:53.705]                         envir = ns)
[17:43:53.705]                       envir <- sys.frame(frame)
[17:43:53.705]                       master <- NULL
[17:43:53.705]                       while (!identical(envir, .GlobalEnv) && 
[17:43:53.705]                         !identical(envir, emptyenv())) {
[17:43:53.705]                         if (exists("master", mode = "list", envir = envir, 
[17:43:53.705]                           inherits = FALSE)) {
[17:43:53.705]                           master <- get("master", mode = "list", 
[17:43:53.705]                             envir = envir, inherits = FALSE)
[17:43:53.705]                           if (inherits(master, c("SOCKnode", 
[17:43:53.705]                             "SOCK0node"))) {
[17:43:53.705]                             sendCondition <<- function(cond) {
[17:43:53.705]                               data <- list(type = "VALUE", value = cond, 
[17:43:53.705]                                 success = TRUE)
[17:43:53.705]                               parallel_sendData(master, data)
[17:43:53.705]                             }
[17:43:53.705]                             return(sendCondition)
[17:43:53.705]                           }
[17:43:53.705]                         }
[17:43:53.705]                         frame <- frame + 1L
[17:43:53.705]                         envir <- sys.frame(frame)
[17:43:53.705]                       }
[17:43:53.705]                     }
[17:43:53.705]                     sendCondition <<- function(cond) NULL
[17:43:53.705]                   }
[17:43:53.705]                 })
[17:43:53.705]                 withCallingHandlers({
[17:43:53.705]                   1
[17:43:53.705]                 }, immediateCondition = function(cond) {
[17:43:53.705]                   sendCondition <- ...future.makeSendCondition()
[17:43:53.705]                   sendCondition(cond)
[17:43:53.705]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.705]                   {
[17:43:53.705]                     inherits <- base::inherits
[17:43:53.705]                     invokeRestart <- base::invokeRestart
[17:43:53.705]                     is.null <- base::is.null
[17:43:53.705]                     muffled <- FALSE
[17:43:53.705]                     if (inherits(cond, "message")) {
[17:43:53.705]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:53.705]                       if (muffled) 
[17:43:53.705]                         invokeRestart("muffleMessage")
[17:43:53.705]                     }
[17:43:53.705]                     else if (inherits(cond, "warning")) {
[17:43:53.705]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:53.705]                       if (muffled) 
[17:43:53.705]                         invokeRestart("muffleWarning")
[17:43:53.705]                     }
[17:43:53.705]                     else if (inherits(cond, "condition")) {
[17:43:53.705]                       if (!is.null(pattern)) {
[17:43:53.705]                         computeRestarts <- base::computeRestarts
[17:43:53.705]                         grepl <- base::grepl
[17:43:53.705]                         restarts <- computeRestarts(cond)
[17:43:53.705]                         for (restart in restarts) {
[17:43:53.705]                           name <- restart$name
[17:43:53.705]                           if (is.null(name)) 
[17:43:53.705]                             next
[17:43:53.705]                           if (!grepl(pattern, name)) 
[17:43:53.705]                             next
[17:43:53.705]                           invokeRestart(restart)
[17:43:53.705]                           muffled <- TRUE
[17:43:53.705]                           break
[17:43:53.705]                         }
[17:43:53.705]                       }
[17:43:53.705]                     }
[17:43:53.705]                     invisible(muffled)
[17:43:53.705]                   }
[17:43:53.705]                   muffleCondition(cond)
[17:43:53.705]                 })
[17:43:53.705]             }))
[17:43:53.705]             future::FutureResult(value = ...future.value$value, 
[17:43:53.705]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.705]                   ...future.rng), globalenv = if (FALSE) 
[17:43:53.705]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:53.705]                     ...future.globalenv.names))
[17:43:53.705]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:53.705]         }, condition = base::local({
[17:43:53.705]             c <- base::c
[17:43:53.705]             inherits <- base::inherits
[17:43:53.705]             invokeRestart <- base::invokeRestart
[17:43:53.705]             length <- base::length
[17:43:53.705]             list <- base::list
[17:43:53.705]             seq.int <- base::seq.int
[17:43:53.705]             signalCondition <- base::signalCondition
[17:43:53.705]             sys.calls <- base::sys.calls
[17:43:53.705]             `[[` <- base::`[[`
[17:43:53.705]             `+` <- base::`+`
[17:43:53.705]             `<<-` <- base::`<<-`
[17:43:53.705]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:53.705]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:53.705]                   3L)]
[17:43:53.705]             }
[17:43:53.705]             function(cond) {
[17:43:53.705]                 is_error <- inherits(cond, "error")
[17:43:53.705]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:53.705]                   NULL)
[17:43:53.705]                 if (is_error) {
[17:43:53.705]                   sessionInformation <- function() {
[17:43:53.705]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:53.705]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:53.705]                       search = base::search(), system = base::Sys.info())
[17:43:53.705]                   }
[17:43:53.705]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.705]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:53.705]                     cond$call), session = sessionInformation(), 
[17:43:53.705]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:53.705]                   signalCondition(cond)
[17:43:53.705]                 }
[17:43:53.705]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:53.705]                 "immediateCondition"))) {
[17:43:53.705]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:53.705]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.705]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:53.705]                   if (TRUE && !signal) {
[17:43:53.705]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.705]                     {
[17:43:53.705]                       inherits <- base::inherits
[17:43:53.705]                       invokeRestart <- base::invokeRestart
[17:43:53.705]                       is.null <- base::is.null
[17:43:53.705]                       muffled <- FALSE
[17:43:53.705]                       if (inherits(cond, "message")) {
[17:43:53.705]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.705]                         if (muffled) 
[17:43:53.705]                           invokeRestart("muffleMessage")
[17:43:53.705]                       }
[17:43:53.705]                       else if (inherits(cond, "warning")) {
[17:43:53.705]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.705]                         if (muffled) 
[17:43:53.705]                           invokeRestart("muffleWarning")
[17:43:53.705]                       }
[17:43:53.705]                       else if (inherits(cond, "condition")) {
[17:43:53.705]                         if (!is.null(pattern)) {
[17:43:53.705]                           computeRestarts <- base::computeRestarts
[17:43:53.705]                           grepl <- base::grepl
[17:43:53.705]                           restarts <- computeRestarts(cond)
[17:43:53.705]                           for (restart in restarts) {
[17:43:53.705]                             name <- restart$name
[17:43:53.705]                             if (is.null(name)) 
[17:43:53.705]                               next
[17:43:53.705]                             if (!grepl(pattern, name)) 
[17:43:53.705]                               next
[17:43:53.705]                             invokeRestart(restart)
[17:43:53.705]                             muffled <- TRUE
[17:43:53.705]                             break
[17:43:53.705]                           }
[17:43:53.705]                         }
[17:43:53.705]                       }
[17:43:53.705]                       invisible(muffled)
[17:43:53.705]                     }
[17:43:53.705]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.705]                   }
[17:43:53.705]                 }
[17:43:53.705]                 else {
[17:43:53.705]                   if (TRUE) {
[17:43:53.705]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.705]                     {
[17:43:53.705]                       inherits <- base::inherits
[17:43:53.705]                       invokeRestart <- base::invokeRestart
[17:43:53.705]                       is.null <- base::is.null
[17:43:53.705]                       muffled <- FALSE
[17:43:53.705]                       if (inherits(cond, "message")) {
[17:43:53.705]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.705]                         if (muffled) 
[17:43:53.705]                           invokeRestart("muffleMessage")
[17:43:53.705]                       }
[17:43:53.705]                       else if (inherits(cond, "warning")) {
[17:43:53.705]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.705]                         if (muffled) 
[17:43:53.705]                           invokeRestart("muffleWarning")
[17:43:53.705]                       }
[17:43:53.705]                       else if (inherits(cond, "condition")) {
[17:43:53.705]                         if (!is.null(pattern)) {
[17:43:53.705]                           computeRestarts <- base::computeRestarts
[17:43:53.705]                           grepl <- base::grepl
[17:43:53.705]                           restarts <- computeRestarts(cond)
[17:43:53.705]                           for (restart in restarts) {
[17:43:53.705]                             name <- restart$name
[17:43:53.705]                             if (is.null(name)) 
[17:43:53.705]                               next
[17:43:53.705]                             if (!grepl(pattern, name)) 
[17:43:53.705]                               next
[17:43:53.705]                             invokeRestart(restart)
[17:43:53.705]                             muffled <- TRUE
[17:43:53.705]                             break
[17:43:53.705]                           }
[17:43:53.705]                         }
[17:43:53.705]                       }
[17:43:53.705]                       invisible(muffled)
[17:43:53.705]                     }
[17:43:53.705]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.705]                   }
[17:43:53.705]                 }
[17:43:53.705]             }
[17:43:53.705]         }))
[17:43:53.705]     }, error = function(ex) {
[17:43:53.705]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:53.705]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.705]                 ...future.rng), started = ...future.startTime, 
[17:43:53.705]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:53.705]             version = "1.8"), class = "FutureResult")
[17:43:53.705]     }, finally = {
[17:43:53.705]         if (!identical(...future.workdir, getwd())) 
[17:43:53.705]             setwd(...future.workdir)
[17:43:53.705]         {
[17:43:53.705]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:53.705]                 ...future.oldOptions$nwarnings <- NULL
[17:43:53.705]             }
[17:43:53.705]             base::options(...future.oldOptions)
[17:43:53.705]             if (.Platform$OS.type == "windows") {
[17:43:53.705]                 old_names <- names(...future.oldEnvVars)
[17:43:53.705]                 envs <- base::Sys.getenv()
[17:43:53.705]                 names <- names(envs)
[17:43:53.705]                 common <- intersect(names, old_names)
[17:43:53.705]                 added <- setdiff(names, old_names)
[17:43:53.705]                 removed <- setdiff(old_names, names)
[17:43:53.705]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:53.705]                   envs[common]]
[17:43:53.705]                 NAMES <- toupper(changed)
[17:43:53.705]                 args <- list()
[17:43:53.705]                 for (kk in seq_along(NAMES)) {
[17:43:53.705]                   name <- changed[[kk]]
[17:43:53.705]                   NAME <- NAMES[[kk]]
[17:43:53.705]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.705]                     next
[17:43:53.705]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.705]                 }
[17:43:53.705]                 NAMES <- toupper(added)
[17:43:53.705]                 for (kk in seq_along(NAMES)) {
[17:43:53.705]                   name <- added[[kk]]
[17:43:53.705]                   NAME <- NAMES[[kk]]
[17:43:53.705]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.705]                     next
[17:43:53.705]                   args[[name]] <- ""
[17:43:53.705]                 }
[17:43:53.705]                 NAMES <- toupper(removed)
[17:43:53.705]                 for (kk in seq_along(NAMES)) {
[17:43:53.705]                   name <- removed[[kk]]
[17:43:53.705]                   NAME <- NAMES[[kk]]
[17:43:53.705]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.705]                     next
[17:43:53.705]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.705]                 }
[17:43:53.705]                 if (length(args) > 0) 
[17:43:53.705]                   base::do.call(base::Sys.setenv, args = args)
[17:43:53.705]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:53.705]             }
[17:43:53.705]             else {
[17:43:53.705]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:53.705]             }
[17:43:53.705]             {
[17:43:53.705]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:53.705]                   0L) {
[17:43:53.705]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:53.705]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:53.705]                   base::options(opts)
[17:43:53.705]                 }
[17:43:53.705]                 {
[17:43:53.705]                   {
[17:43:53.705]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:53.705]                     NULL
[17:43:53.705]                   }
[17:43:53.705]                   options(future.plan = NULL)
[17:43:53.705]                   if (is.na(NA_character_)) 
[17:43:53.705]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.705]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:53.705]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:53.705]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:53.705]                     envir = parent.frame()) 
[17:43:53.705]                   {
[17:43:53.705]                     if (is.function(workers)) 
[17:43:53.705]                       workers <- workers()
[17:43:53.705]                     workers <- structure(as.integer(workers), 
[17:43:53.705]                       class = class(workers))
[17:43:53.705]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:53.705]                       workers >= 1)
[17:43:53.705]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:53.705]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:53.705]                     }
[17:43:53.705]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:53.705]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:53.705]                       envir = envir)
[17:43:53.705]                     if (!future$lazy) 
[17:43:53.705]                       future <- run(future)
[17:43:53.705]                     invisible(future)
[17:43:53.705]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:53.705]                 }
[17:43:53.705]             }
[17:43:53.705]         }
[17:43:53.705]     })
[17:43:53.705]     if (TRUE) {
[17:43:53.705]         base::sink(type = "output", split = FALSE)
[17:43:53.705]         if (TRUE) {
[17:43:53.705]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:53.705]         }
[17:43:53.705]         else {
[17:43:53.705]             ...future.result["stdout"] <- base::list(NULL)
[17:43:53.705]         }
[17:43:53.705]         base::close(...future.stdout)
[17:43:53.705]         ...future.stdout <- NULL
[17:43:53.705]     }
[17:43:53.705]     ...future.result$conditions <- ...future.conditions
[17:43:53.705]     ...future.result$finished <- base::Sys.time()
[17:43:53.705]     ...future.result
[17:43:53.705] }
[17:43:53.708] MultisessionFuture started
[17:43:53.708] - Launch lazy future ... done
[17:43:53.709] run() for ‘MultisessionFuture’ ... done
[17:43:53.730]  length: 2 (resolved future 3)
[17:43:53.751] receiveMessageFromWorker() for ClusterFuture ...
[17:43:53.751] - Validating connection of MultisessionFuture
[17:43:53.751] - received message: FutureResult
[17:43:53.752] - Received FutureResult
[17:43:53.752] - Erased future from FutureRegistry
[17:43:53.752] result() for ClusterFuture ...
[17:43:53.752] - result already collected: FutureResult
[17:43:53.752] result() for ClusterFuture ... done
[17:43:53.752] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:53.752] Future #2
[17:43:53.752]  length: 1 (resolved future 2)
[17:43:53.763] receiveMessageFromWorker() for ClusterFuture ...
[17:43:53.763] - Validating connection of MultisessionFuture
[17:43:53.763] - received message: FutureResult
[17:43:53.763] - Received FutureResult
[17:43:53.764] - Erased future from FutureRegistry
[17:43:53.764] result() for ClusterFuture ...
[17:43:53.764] - result already collected: FutureResult
[17:43:53.764] result() for ClusterFuture ... done
[17:43:53.764] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:53.764] Future #1
[17:43:53.764]  length: 0 (resolved future 1)
[17:43:53.764] resolve() on list ... DONE
[17:43:53.764] getGlobalsAndPackages() ...
[17:43:53.765] Searching for globals...
[17:43:53.765] 
[17:43:53.765] Searching for globals ... DONE
[17:43:53.765] - globals: [0] <none>
[17:43:53.765] getGlobalsAndPackages() ... DONE
[17:43:53.765] getGlobalsAndPackages() ...
[17:43:53.766] Searching for globals...
[17:43:53.766] 
[17:43:53.766] Searching for globals ... DONE
[17:43:53.766] - globals: [0] <none>
[17:43:53.766] getGlobalsAndPackages() ... DONE
[17:43:53.766] resolve() on list ...
[17:43:53.766]  recursive: 0
[17:43:53.767]  length: 3
[17:43:53.767]  elements: ‘a’, ‘b’, ‘’
[17:43:53.767] run() for ‘Future’ ...
[17:43:53.767] - state: ‘created’
[17:43:53.770] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:53.787] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:53.787] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:53.787]   - Field: ‘node’
[17:43:53.787]   - Field: ‘label’
[17:43:53.787]   - Field: ‘local’
[17:43:53.787]   - Field: ‘owner’
[17:43:53.787]   - Field: ‘envir’
[17:43:53.788]   - Field: ‘workers’
[17:43:53.788]   - Field: ‘packages’
[17:43:53.788]   - Field: ‘gc’
[17:43:53.788]   - Field: ‘conditions’
[17:43:53.788]   - Field: ‘persistent’
[17:43:53.788]   - Field: ‘expr’
[17:43:53.788]   - Field: ‘uuid’
[17:43:53.788]   - Field: ‘seed’
[17:43:53.788]   - Field: ‘version’
[17:43:53.788]   - Field: ‘result’
[17:43:53.788]   - Field: ‘asynchronous’
[17:43:53.789]   - Field: ‘calls’
[17:43:53.789]   - Field: ‘globals’
[17:43:53.789]   - Field: ‘stdout’
[17:43:53.789]   - Field: ‘earlySignal’
[17:43:53.789]   - Field: ‘lazy’
[17:43:53.789]   - Field: ‘state’
[17:43:53.789] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:53.789] - Launch lazy future ...
[17:43:53.790] Packages needed by the future expression (n = 0): <none>
[17:43:53.790] Packages needed by future strategies (n = 0): <none>
[17:43:53.790] {
[17:43:53.790]     {
[17:43:53.790]         {
[17:43:53.790]             ...future.startTime <- base::Sys.time()
[17:43:53.790]             {
[17:43:53.790]                 {
[17:43:53.790]                   {
[17:43:53.790]                     {
[17:43:53.790]                       base::local({
[17:43:53.790]                         has_future <- base::requireNamespace("future", 
[17:43:53.790]                           quietly = TRUE)
[17:43:53.790]                         if (has_future) {
[17:43:53.790]                           ns <- base::getNamespace("future")
[17:43:53.790]                           version <- ns[[".package"]][["version"]]
[17:43:53.790]                           if (is.null(version)) 
[17:43:53.790]                             version <- utils::packageVersion("future")
[17:43:53.790]                         }
[17:43:53.790]                         else {
[17:43:53.790]                           version <- NULL
[17:43:53.790]                         }
[17:43:53.790]                         if (!has_future || version < "1.8.0") {
[17:43:53.790]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:53.790]                             "", base::R.version$version.string), 
[17:43:53.790]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:53.790]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:53.790]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:53.790]                               "release", "version")], collapse = " "), 
[17:43:53.790]                             hostname = base::Sys.info()[["nodename"]])
[17:43:53.790]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:53.790]                             info)
[17:43:53.790]                           info <- base::paste(info, collapse = "; ")
[17:43:53.790]                           if (!has_future) {
[17:43:53.790]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:53.790]                               info)
[17:43:53.790]                           }
[17:43:53.790]                           else {
[17:43:53.790]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:53.790]                               info, version)
[17:43:53.790]                           }
[17:43:53.790]                           base::stop(msg)
[17:43:53.790]                         }
[17:43:53.790]                       })
[17:43:53.790]                     }
[17:43:53.790]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:53.790]                     base::options(mc.cores = 1L)
[17:43:53.790]                   }
[17:43:53.790]                   options(future.plan = NULL)
[17:43:53.790]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.790]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:53.790]                 }
[17:43:53.790]                 ...future.workdir <- getwd()
[17:43:53.790]             }
[17:43:53.790]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:53.790]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:53.790]         }
[17:43:53.790]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:53.790]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:53.790]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:53.790]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:53.790]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:53.790]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:53.790]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:53.790]             base::names(...future.oldOptions))
[17:43:53.790]     }
[17:43:53.790]     if (FALSE) {
[17:43:53.790]     }
[17:43:53.790]     else {
[17:43:53.790]         if (TRUE) {
[17:43:53.790]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:53.790]                 open = "w")
[17:43:53.790]         }
[17:43:53.790]         else {
[17:43:53.790]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:53.790]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:53.790]         }
[17:43:53.790]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:53.790]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:53.790]             base::sink(type = "output", split = FALSE)
[17:43:53.790]             base::close(...future.stdout)
[17:43:53.790]         }, add = TRUE)
[17:43:53.790]     }
[17:43:53.790]     ...future.frame <- base::sys.nframe()
[17:43:53.790]     ...future.conditions <- base::list()
[17:43:53.790]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:53.790]     if (FALSE) {
[17:43:53.790]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:53.790]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:53.790]     }
[17:43:53.790]     ...future.result <- base::tryCatch({
[17:43:53.790]         base::withCallingHandlers({
[17:43:53.790]             ...future.value <- base::withVisible(base::local({
[17:43:53.790]                 ...future.makeSendCondition <- local({
[17:43:53.790]                   sendCondition <- NULL
[17:43:53.790]                   function(frame = 1L) {
[17:43:53.790]                     if (is.function(sendCondition)) 
[17:43:53.790]                       return(sendCondition)
[17:43:53.790]                     ns <- getNamespace("parallel")
[17:43:53.790]                     if (exists("sendData", mode = "function", 
[17:43:53.790]                       envir = ns)) {
[17:43:53.790]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:53.790]                         envir = ns)
[17:43:53.790]                       envir <- sys.frame(frame)
[17:43:53.790]                       master <- NULL
[17:43:53.790]                       while (!identical(envir, .GlobalEnv) && 
[17:43:53.790]                         !identical(envir, emptyenv())) {
[17:43:53.790]                         if (exists("master", mode = "list", envir = envir, 
[17:43:53.790]                           inherits = FALSE)) {
[17:43:53.790]                           master <- get("master", mode = "list", 
[17:43:53.790]                             envir = envir, inherits = FALSE)
[17:43:53.790]                           if (inherits(master, c("SOCKnode", 
[17:43:53.790]                             "SOCK0node"))) {
[17:43:53.790]                             sendCondition <<- function(cond) {
[17:43:53.790]                               data <- list(type = "VALUE", value = cond, 
[17:43:53.790]                                 success = TRUE)
[17:43:53.790]                               parallel_sendData(master, data)
[17:43:53.790]                             }
[17:43:53.790]                             return(sendCondition)
[17:43:53.790]                           }
[17:43:53.790]                         }
[17:43:53.790]                         frame <- frame + 1L
[17:43:53.790]                         envir <- sys.frame(frame)
[17:43:53.790]                       }
[17:43:53.790]                     }
[17:43:53.790]                     sendCondition <<- function(cond) NULL
[17:43:53.790]                   }
[17:43:53.790]                 })
[17:43:53.790]                 withCallingHandlers({
[17:43:53.790]                   1
[17:43:53.790]                 }, immediateCondition = function(cond) {
[17:43:53.790]                   sendCondition <- ...future.makeSendCondition()
[17:43:53.790]                   sendCondition(cond)
[17:43:53.790]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.790]                   {
[17:43:53.790]                     inherits <- base::inherits
[17:43:53.790]                     invokeRestart <- base::invokeRestart
[17:43:53.790]                     is.null <- base::is.null
[17:43:53.790]                     muffled <- FALSE
[17:43:53.790]                     if (inherits(cond, "message")) {
[17:43:53.790]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:53.790]                       if (muffled) 
[17:43:53.790]                         invokeRestart("muffleMessage")
[17:43:53.790]                     }
[17:43:53.790]                     else if (inherits(cond, "warning")) {
[17:43:53.790]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:53.790]                       if (muffled) 
[17:43:53.790]                         invokeRestart("muffleWarning")
[17:43:53.790]                     }
[17:43:53.790]                     else if (inherits(cond, "condition")) {
[17:43:53.790]                       if (!is.null(pattern)) {
[17:43:53.790]                         computeRestarts <- base::computeRestarts
[17:43:53.790]                         grepl <- base::grepl
[17:43:53.790]                         restarts <- computeRestarts(cond)
[17:43:53.790]                         for (restart in restarts) {
[17:43:53.790]                           name <- restart$name
[17:43:53.790]                           if (is.null(name)) 
[17:43:53.790]                             next
[17:43:53.790]                           if (!grepl(pattern, name)) 
[17:43:53.790]                             next
[17:43:53.790]                           invokeRestart(restart)
[17:43:53.790]                           muffled <- TRUE
[17:43:53.790]                           break
[17:43:53.790]                         }
[17:43:53.790]                       }
[17:43:53.790]                     }
[17:43:53.790]                     invisible(muffled)
[17:43:53.790]                   }
[17:43:53.790]                   muffleCondition(cond)
[17:43:53.790]                 })
[17:43:53.790]             }))
[17:43:53.790]             future::FutureResult(value = ...future.value$value, 
[17:43:53.790]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.790]                   ...future.rng), globalenv = if (FALSE) 
[17:43:53.790]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:53.790]                     ...future.globalenv.names))
[17:43:53.790]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:53.790]         }, condition = base::local({
[17:43:53.790]             c <- base::c
[17:43:53.790]             inherits <- base::inherits
[17:43:53.790]             invokeRestart <- base::invokeRestart
[17:43:53.790]             length <- base::length
[17:43:53.790]             list <- base::list
[17:43:53.790]             seq.int <- base::seq.int
[17:43:53.790]             signalCondition <- base::signalCondition
[17:43:53.790]             sys.calls <- base::sys.calls
[17:43:53.790]             `[[` <- base::`[[`
[17:43:53.790]             `+` <- base::`+`
[17:43:53.790]             `<<-` <- base::`<<-`
[17:43:53.790]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:53.790]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:53.790]                   3L)]
[17:43:53.790]             }
[17:43:53.790]             function(cond) {
[17:43:53.790]                 is_error <- inherits(cond, "error")
[17:43:53.790]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:53.790]                   NULL)
[17:43:53.790]                 if (is_error) {
[17:43:53.790]                   sessionInformation <- function() {
[17:43:53.790]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:53.790]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:53.790]                       search = base::search(), system = base::Sys.info())
[17:43:53.790]                   }
[17:43:53.790]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.790]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:53.790]                     cond$call), session = sessionInformation(), 
[17:43:53.790]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:53.790]                   signalCondition(cond)
[17:43:53.790]                 }
[17:43:53.790]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:53.790]                 "immediateCondition"))) {
[17:43:53.790]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:53.790]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.790]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:53.790]                   if (TRUE && !signal) {
[17:43:53.790]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.790]                     {
[17:43:53.790]                       inherits <- base::inherits
[17:43:53.790]                       invokeRestart <- base::invokeRestart
[17:43:53.790]                       is.null <- base::is.null
[17:43:53.790]                       muffled <- FALSE
[17:43:53.790]                       if (inherits(cond, "message")) {
[17:43:53.790]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.790]                         if (muffled) 
[17:43:53.790]                           invokeRestart("muffleMessage")
[17:43:53.790]                       }
[17:43:53.790]                       else if (inherits(cond, "warning")) {
[17:43:53.790]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.790]                         if (muffled) 
[17:43:53.790]                           invokeRestart("muffleWarning")
[17:43:53.790]                       }
[17:43:53.790]                       else if (inherits(cond, "condition")) {
[17:43:53.790]                         if (!is.null(pattern)) {
[17:43:53.790]                           computeRestarts <- base::computeRestarts
[17:43:53.790]                           grepl <- base::grepl
[17:43:53.790]                           restarts <- computeRestarts(cond)
[17:43:53.790]                           for (restart in restarts) {
[17:43:53.790]                             name <- restart$name
[17:43:53.790]                             if (is.null(name)) 
[17:43:53.790]                               next
[17:43:53.790]                             if (!grepl(pattern, name)) 
[17:43:53.790]                               next
[17:43:53.790]                             invokeRestart(restart)
[17:43:53.790]                             muffled <- TRUE
[17:43:53.790]                             break
[17:43:53.790]                           }
[17:43:53.790]                         }
[17:43:53.790]                       }
[17:43:53.790]                       invisible(muffled)
[17:43:53.790]                     }
[17:43:53.790]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.790]                   }
[17:43:53.790]                 }
[17:43:53.790]                 else {
[17:43:53.790]                   if (TRUE) {
[17:43:53.790]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.790]                     {
[17:43:53.790]                       inherits <- base::inherits
[17:43:53.790]                       invokeRestart <- base::invokeRestart
[17:43:53.790]                       is.null <- base::is.null
[17:43:53.790]                       muffled <- FALSE
[17:43:53.790]                       if (inherits(cond, "message")) {
[17:43:53.790]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.790]                         if (muffled) 
[17:43:53.790]                           invokeRestart("muffleMessage")
[17:43:53.790]                       }
[17:43:53.790]                       else if (inherits(cond, "warning")) {
[17:43:53.790]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.790]                         if (muffled) 
[17:43:53.790]                           invokeRestart("muffleWarning")
[17:43:53.790]                       }
[17:43:53.790]                       else if (inherits(cond, "condition")) {
[17:43:53.790]                         if (!is.null(pattern)) {
[17:43:53.790]                           computeRestarts <- base::computeRestarts
[17:43:53.790]                           grepl <- base::grepl
[17:43:53.790]                           restarts <- computeRestarts(cond)
[17:43:53.790]                           for (restart in restarts) {
[17:43:53.790]                             name <- restart$name
[17:43:53.790]                             if (is.null(name)) 
[17:43:53.790]                               next
[17:43:53.790]                             if (!grepl(pattern, name)) 
[17:43:53.790]                               next
[17:43:53.790]                             invokeRestart(restart)
[17:43:53.790]                             muffled <- TRUE
[17:43:53.790]                             break
[17:43:53.790]                           }
[17:43:53.790]                         }
[17:43:53.790]                       }
[17:43:53.790]                       invisible(muffled)
[17:43:53.790]                     }
[17:43:53.790]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.790]                   }
[17:43:53.790]                 }
[17:43:53.790]             }
[17:43:53.790]         }))
[17:43:53.790]     }, error = function(ex) {
[17:43:53.790]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:53.790]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.790]                 ...future.rng), started = ...future.startTime, 
[17:43:53.790]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:53.790]             version = "1.8"), class = "FutureResult")
[17:43:53.790]     }, finally = {
[17:43:53.790]         if (!identical(...future.workdir, getwd())) 
[17:43:53.790]             setwd(...future.workdir)
[17:43:53.790]         {
[17:43:53.790]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:53.790]                 ...future.oldOptions$nwarnings <- NULL
[17:43:53.790]             }
[17:43:53.790]             base::options(...future.oldOptions)
[17:43:53.790]             if (.Platform$OS.type == "windows") {
[17:43:53.790]                 old_names <- names(...future.oldEnvVars)
[17:43:53.790]                 envs <- base::Sys.getenv()
[17:43:53.790]                 names <- names(envs)
[17:43:53.790]                 common <- intersect(names, old_names)
[17:43:53.790]                 added <- setdiff(names, old_names)
[17:43:53.790]                 removed <- setdiff(old_names, names)
[17:43:53.790]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:53.790]                   envs[common]]
[17:43:53.790]                 NAMES <- toupper(changed)
[17:43:53.790]                 args <- list()
[17:43:53.790]                 for (kk in seq_along(NAMES)) {
[17:43:53.790]                   name <- changed[[kk]]
[17:43:53.790]                   NAME <- NAMES[[kk]]
[17:43:53.790]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.790]                     next
[17:43:53.790]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.790]                 }
[17:43:53.790]                 NAMES <- toupper(added)
[17:43:53.790]                 for (kk in seq_along(NAMES)) {
[17:43:53.790]                   name <- added[[kk]]
[17:43:53.790]                   NAME <- NAMES[[kk]]
[17:43:53.790]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.790]                     next
[17:43:53.790]                   args[[name]] <- ""
[17:43:53.790]                 }
[17:43:53.790]                 NAMES <- toupper(removed)
[17:43:53.790]                 for (kk in seq_along(NAMES)) {
[17:43:53.790]                   name <- removed[[kk]]
[17:43:53.790]                   NAME <- NAMES[[kk]]
[17:43:53.790]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.790]                     next
[17:43:53.790]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.790]                 }
[17:43:53.790]                 if (length(args) > 0) 
[17:43:53.790]                   base::do.call(base::Sys.setenv, args = args)
[17:43:53.790]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:53.790]             }
[17:43:53.790]             else {
[17:43:53.790]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:53.790]             }
[17:43:53.790]             {
[17:43:53.790]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:53.790]                   0L) {
[17:43:53.790]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:53.790]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:53.790]                   base::options(opts)
[17:43:53.790]                 }
[17:43:53.790]                 {
[17:43:53.790]                   {
[17:43:53.790]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:53.790]                     NULL
[17:43:53.790]                   }
[17:43:53.790]                   options(future.plan = NULL)
[17:43:53.790]                   if (is.na(NA_character_)) 
[17:43:53.790]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.790]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:53.790]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:53.790]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:53.790]                     envir = parent.frame()) 
[17:43:53.790]                   {
[17:43:53.790]                     if (is.function(workers)) 
[17:43:53.790]                       workers <- workers()
[17:43:53.790]                     workers <- structure(as.integer(workers), 
[17:43:53.790]                       class = class(workers))
[17:43:53.790]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:53.790]                       workers >= 1)
[17:43:53.790]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:53.790]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:53.790]                     }
[17:43:53.790]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:53.790]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:53.790]                       envir = envir)
[17:43:53.790]                     if (!future$lazy) 
[17:43:53.790]                       future <- run(future)
[17:43:53.790]                     invisible(future)
[17:43:53.790]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:53.790]                 }
[17:43:53.790]             }
[17:43:53.790]         }
[17:43:53.790]     })
[17:43:53.790]     if (TRUE) {
[17:43:53.790]         base::sink(type = "output", split = FALSE)
[17:43:53.790]         if (TRUE) {
[17:43:53.790]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:53.790]         }
[17:43:53.790]         else {
[17:43:53.790]             ...future.result["stdout"] <- base::list(NULL)
[17:43:53.790]         }
[17:43:53.790]         base::close(...future.stdout)
[17:43:53.790]         ...future.stdout <- NULL
[17:43:53.790]     }
[17:43:53.790]     ...future.result$conditions <- ...future.conditions
[17:43:53.790]     ...future.result$finished <- base::Sys.time()
[17:43:53.790]     ...future.result
[17:43:53.790] }
[17:43:53.794] MultisessionFuture started
[17:43:53.794] - Launch lazy future ... done
[17:43:53.794] run() for ‘MultisessionFuture’ ... done
[17:43:53.805] run() for ‘Future’ ...
[17:43:53.805] - state: ‘created’
[17:43:53.805] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:53.820] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:53.820] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:53.820]   - Field: ‘node’
[17:43:53.821]   - Field: ‘label’
[17:43:53.821]   - Field: ‘local’
[17:43:53.821]   - Field: ‘owner’
[17:43:53.821]   - Field: ‘envir’
[17:43:53.821]   - Field: ‘workers’
[17:43:53.821]   - Field: ‘packages’
[17:43:53.821]   - Field: ‘gc’
[17:43:53.821]   - Field: ‘conditions’
[17:43:53.821]   - Field: ‘persistent’
[17:43:53.821]   - Field: ‘expr’
[17:43:53.821]   - Field: ‘uuid’
[17:43:53.822]   - Field: ‘seed’
[17:43:53.822]   - Field: ‘version’
[17:43:53.822]   - Field: ‘result’
[17:43:53.822]   - Field: ‘asynchronous’
[17:43:53.822]   - Field: ‘calls’
[17:43:53.822]   - Field: ‘globals’
[17:43:53.822]   - Field: ‘stdout’
[17:43:53.822]   - Field: ‘earlySignal’
[17:43:53.822]   - Field: ‘lazy’
[17:43:53.822]   - Field: ‘state’
[17:43:53.822] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:53.823] - Launch lazy future ...
[17:43:53.823] Packages needed by the future expression (n = 0): <none>
[17:43:53.823] Packages needed by future strategies (n = 0): <none>
[17:43:53.824] {
[17:43:53.824]     {
[17:43:53.824]         {
[17:43:53.824]             ...future.startTime <- base::Sys.time()
[17:43:53.824]             {
[17:43:53.824]                 {
[17:43:53.824]                   {
[17:43:53.824]                     {
[17:43:53.824]                       base::local({
[17:43:53.824]                         has_future <- base::requireNamespace("future", 
[17:43:53.824]                           quietly = TRUE)
[17:43:53.824]                         if (has_future) {
[17:43:53.824]                           ns <- base::getNamespace("future")
[17:43:53.824]                           version <- ns[[".package"]][["version"]]
[17:43:53.824]                           if (is.null(version)) 
[17:43:53.824]                             version <- utils::packageVersion("future")
[17:43:53.824]                         }
[17:43:53.824]                         else {
[17:43:53.824]                           version <- NULL
[17:43:53.824]                         }
[17:43:53.824]                         if (!has_future || version < "1.8.0") {
[17:43:53.824]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:53.824]                             "", base::R.version$version.string), 
[17:43:53.824]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:53.824]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:53.824]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:53.824]                               "release", "version")], collapse = " "), 
[17:43:53.824]                             hostname = base::Sys.info()[["nodename"]])
[17:43:53.824]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:53.824]                             info)
[17:43:53.824]                           info <- base::paste(info, collapse = "; ")
[17:43:53.824]                           if (!has_future) {
[17:43:53.824]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:53.824]                               info)
[17:43:53.824]                           }
[17:43:53.824]                           else {
[17:43:53.824]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:53.824]                               info, version)
[17:43:53.824]                           }
[17:43:53.824]                           base::stop(msg)
[17:43:53.824]                         }
[17:43:53.824]                       })
[17:43:53.824]                     }
[17:43:53.824]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:53.824]                     base::options(mc.cores = 1L)
[17:43:53.824]                   }
[17:43:53.824]                   options(future.plan = NULL)
[17:43:53.824]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.824]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:53.824]                 }
[17:43:53.824]                 ...future.workdir <- getwd()
[17:43:53.824]             }
[17:43:53.824]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:53.824]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:53.824]         }
[17:43:53.824]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:53.824]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:53.824]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:53.824]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:53.824]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:53.824]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:53.824]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:53.824]             base::names(...future.oldOptions))
[17:43:53.824]     }
[17:43:53.824]     if (FALSE) {
[17:43:53.824]     }
[17:43:53.824]     else {
[17:43:53.824]         if (TRUE) {
[17:43:53.824]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:53.824]                 open = "w")
[17:43:53.824]         }
[17:43:53.824]         else {
[17:43:53.824]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:53.824]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:53.824]         }
[17:43:53.824]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:53.824]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:53.824]             base::sink(type = "output", split = FALSE)
[17:43:53.824]             base::close(...future.stdout)
[17:43:53.824]         }, add = TRUE)
[17:43:53.824]     }
[17:43:53.824]     ...future.frame <- base::sys.nframe()
[17:43:53.824]     ...future.conditions <- base::list()
[17:43:53.824]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:53.824]     if (FALSE) {
[17:43:53.824]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:53.824]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:53.824]     }
[17:43:53.824]     ...future.result <- base::tryCatch({
[17:43:53.824]         base::withCallingHandlers({
[17:43:53.824]             ...future.value <- base::withVisible(base::local({
[17:43:53.824]                 ...future.makeSendCondition <- local({
[17:43:53.824]                   sendCondition <- NULL
[17:43:53.824]                   function(frame = 1L) {
[17:43:53.824]                     if (is.function(sendCondition)) 
[17:43:53.824]                       return(sendCondition)
[17:43:53.824]                     ns <- getNamespace("parallel")
[17:43:53.824]                     if (exists("sendData", mode = "function", 
[17:43:53.824]                       envir = ns)) {
[17:43:53.824]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:53.824]                         envir = ns)
[17:43:53.824]                       envir <- sys.frame(frame)
[17:43:53.824]                       master <- NULL
[17:43:53.824]                       while (!identical(envir, .GlobalEnv) && 
[17:43:53.824]                         !identical(envir, emptyenv())) {
[17:43:53.824]                         if (exists("master", mode = "list", envir = envir, 
[17:43:53.824]                           inherits = FALSE)) {
[17:43:53.824]                           master <- get("master", mode = "list", 
[17:43:53.824]                             envir = envir, inherits = FALSE)
[17:43:53.824]                           if (inherits(master, c("SOCKnode", 
[17:43:53.824]                             "SOCK0node"))) {
[17:43:53.824]                             sendCondition <<- function(cond) {
[17:43:53.824]                               data <- list(type = "VALUE", value = cond, 
[17:43:53.824]                                 success = TRUE)
[17:43:53.824]                               parallel_sendData(master, data)
[17:43:53.824]                             }
[17:43:53.824]                             return(sendCondition)
[17:43:53.824]                           }
[17:43:53.824]                         }
[17:43:53.824]                         frame <- frame + 1L
[17:43:53.824]                         envir <- sys.frame(frame)
[17:43:53.824]                       }
[17:43:53.824]                     }
[17:43:53.824]                     sendCondition <<- function(cond) NULL
[17:43:53.824]                   }
[17:43:53.824]                 })
[17:43:53.824]                 withCallingHandlers({
[17:43:53.824]                   2
[17:43:53.824]                 }, immediateCondition = function(cond) {
[17:43:53.824]                   sendCondition <- ...future.makeSendCondition()
[17:43:53.824]                   sendCondition(cond)
[17:43:53.824]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.824]                   {
[17:43:53.824]                     inherits <- base::inherits
[17:43:53.824]                     invokeRestart <- base::invokeRestart
[17:43:53.824]                     is.null <- base::is.null
[17:43:53.824]                     muffled <- FALSE
[17:43:53.824]                     if (inherits(cond, "message")) {
[17:43:53.824]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:53.824]                       if (muffled) 
[17:43:53.824]                         invokeRestart("muffleMessage")
[17:43:53.824]                     }
[17:43:53.824]                     else if (inherits(cond, "warning")) {
[17:43:53.824]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:53.824]                       if (muffled) 
[17:43:53.824]                         invokeRestart("muffleWarning")
[17:43:53.824]                     }
[17:43:53.824]                     else if (inherits(cond, "condition")) {
[17:43:53.824]                       if (!is.null(pattern)) {
[17:43:53.824]                         computeRestarts <- base::computeRestarts
[17:43:53.824]                         grepl <- base::grepl
[17:43:53.824]                         restarts <- computeRestarts(cond)
[17:43:53.824]                         for (restart in restarts) {
[17:43:53.824]                           name <- restart$name
[17:43:53.824]                           if (is.null(name)) 
[17:43:53.824]                             next
[17:43:53.824]                           if (!grepl(pattern, name)) 
[17:43:53.824]                             next
[17:43:53.824]                           invokeRestart(restart)
[17:43:53.824]                           muffled <- TRUE
[17:43:53.824]                           break
[17:43:53.824]                         }
[17:43:53.824]                       }
[17:43:53.824]                     }
[17:43:53.824]                     invisible(muffled)
[17:43:53.824]                   }
[17:43:53.824]                   muffleCondition(cond)
[17:43:53.824]                 })
[17:43:53.824]             }))
[17:43:53.824]             future::FutureResult(value = ...future.value$value, 
[17:43:53.824]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.824]                   ...future.rng), globalenv = if (FALSE) 
[17:43:53.824]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:53.824]                     ...future.globalenv.names))
[17:43:53.824]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:53.824]         }, condition = base::local({
[17:43:53.824]             c <- base::c
[17:43:53.824]             inherits <- base::inherits
[17:43:53.824]             invokeRestart <- base::invokeRestart
[17:43:53.824]             length <- base::length
[17:43:53.824]             list <- base::list
[17:43:53.824]             seq.int <- base::seq.int
[17:43:53.824]             signalCondition <- base::signalCondition
[17:43:53.824]             sys.calls <- base::sys.calls
[17:43:53.824]             `[[` <- base::`[[`
[17:43:53.824]             `+` <- base::`+`
[17:43:53.824]             `<<-` <- base::`<<-`
[17:43:53.824]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:53.824]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:53.824]                   3L)]
[17:43:53.824]             }
[17:43:53.824]             function(cond) {
[17:43:53.824]                 is_error <- inherits(cond, "error")
[17:43:53.824]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:53.824]                   NULL)
[17:43:53.824]                 if (is_error) {
[17:43:53.824]                   sessionInformation <- function() {
[17:43:53.824]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:53.824]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:53.824]                       search = base::search(), system = base::Sys.info())
[17:43:53.824]                   }
[17:43:53.824]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.824]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:53.824]                     cond$call), session = sessionInformation(), 
[17:43:53.824]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:53.824]                   signalCondition(cond)
[17:43:53.824]                 }
[17:43:53.824]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:53.824]                 "immediateCondition"))) {
[17:43:53.824]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:53.824]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.824]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:53.824]                   if (TRUE && !signal) {
[17:43:53.824]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.824]                     {
[17:43:53.824]                       inherits <- base::inherits
[17:43:53.824]                       invokeRestart <- base::invokeRestart
[17:43:53.824]                       is.null <- base::is.null
[17:43:53.824]                       muffled <- FALSE
[17:43:53.824]                       if (inherits(cond, "message")) {
[17:43:53.824]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.824]                         if (muffled) 
[17:43:53.824]                           invokeRestart("muffleMessage")
[17:43:53.824]                       }
[17:43:53.824]                       else if (inherits(cond, "warning")) {
[17:43:53.824]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.824]                         if (muffled) 
[17:43:53.824]                           invokeRestart("muffleWarning")
[17:43:53.824]                       }
[17:43:53.824]                       else if (inherits(cond, "condition")) {
[17:43:53.824]                         if (!is.null(pattern)) {
[17:43:53.824]                           computeRestarts <- base::computeRestarts
[17:43:53.824]                           grepl <- base::grepl
[17:43:53.824]                           restarts <- computeRestarts(cond)
[17:43:53.824]                           for (restart in restarts) {
[17:43:53.824]                             name <- restart$name
[17:43:53.824]                             if (is.null(name)) 
[17:43:53.824]                               next
[17:43:53.824]                             if (!grepl(pattern, name)) 
[17:43:53.824]                               next
[17:43:53.824]                             invokeRestart(restart)
[17:43:53.824]                             muffled <- TRUE
[17:43:53.824]                             break
[17:43:53.824]                           }
[17:43:53.824]                         }
[17:43:53.824]                       }
[17:43:53.824]                       invisible(muffled)
[17:43:53.824]                     }
[17:43:53.824]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.824]                   }
[17:43:53.824]                 }
[17:43:53.824]                 else {
[17:43:53.824]                   if (TRUE) {
[17:43:53.824]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.824]                     {
[17:43:53.824]                       inherits <- base::inherits
[17:43:53.824]                       invokeRestart <- base::invokeRestart
[17:43:53.824]                       is.null <- base::is.null
[17:43:53.824]                       muffled <- FALSE
[17:43:53.824]                       if (inherits(cond, "message")) {
[17:43:53.824]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.824]                         if (muffled) 
[17:43:53.824]                           invokeRestart("muffleMessage")
[17:43:53.824]                       }
[17:43:53.824]                       else if (inherits(cond, "warning")) {
[17:43:53.824]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.824]                         if (muffled) 
[17:43:53.824]                           invokeRestart("muffleWarning")
[17:43:53.824]                       }
[17:43:53.824]                       else if (inherits(cond, "condition")) {
[17:43:53.824]                         if (!is.null(pattern)) {
[17:43:53.824]                           computeRestarts <- base::computeRestarts
[17:43:53.824]                           grepl <- base::grepl
[17:43:53.824]                           restarts <- computeRestarts(cond)
[17:43:53.824]                           for (restart in restarts) {
[17:43:53.824]                             name <- restart$name
[17:43:53.824]                             if (is.null(name)) 
[17:43:53.824]                               next
[17:43:53.824]                             if (!grepl(pattern, name)) 
[17:43:53.824]                               next
[17:43:53.824]                             invokeRestart(restart)
[17:43:53.824]                             muffled <- TRUE
[17:43:53.824]                             break
[17:43:53.824]                           }
[17:43:53.824]                         }
[17:43:53.824]                       }
[17:43:53.824]                       invisible(muffled)
[17:43:53.824]                     }
[17:43:53.824]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.824]                   }
[17:43:53.824]                 }
[17:43:53.824]             }
[17:43:53.824]         }))
[17:43:53.824]     }, error = function(ex) {
[17:43:53.824]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:53.824]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.824]                 ...future.rng), started = ...future.startTime, 
[17:43:53.824]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:53.824]             version = "1.8"), class = "FutureResult")
[17:43:53.824]     }, finally = {
[17:43:53.824]         if (!identical(...future.workdir, getwd())) 
[17:43:53.824]             setwd(...future.workdir)
[17:43:53.824]         {
[17:43:53.824]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:53.824]                 ...future.oldOptions$nwarnings <- NULL
[17:43:53.824]             }
[17:43:53.824]             base::options(...future.oldOptions)
[17:43:53.824]             if (.Platform$OS.type == "windows") {
[17:43:53.824]                 old_names <- names(...future.oldEnvVars)
[17:43:53.824]                 envs <- base::Sys.getenv()
[17:43:53.824]                 names <- names(envs)
[17:43:53.824]                 common <- intersect(names, old_names)
[17:43:53.824]                 added <- setdiff(names, old_names)
[17:43:53.824]                 removed <- setdiff(old_names, names)
[17:43:53.824]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:53.824]                   envs[common]]
[17:43:53.824]                 NAMES <- toupper(changed)
[17:43:53.824]                 args <- list()
[17:43:53.824]                 for (kk in seq_along(NAMES)) {
[17:43:53.824]                   name <- changed[[kk]]
[17:43:53.824]                   NAME <- NAMES[[kk]]
[17:43:53.824]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.824]                     next
[17:43:53.824]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.824]                 }
[17:43:53.824]                 NAMES <- toupper(added)
[17:43:53.824]                 for (kk in seq_along(NAMES)) {
[17:43:53.824]                   name <- added[[kk]]
[17:43:53.824]                   NAME <- NAMES[[kk]]
[17:43:53.824]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.824]                     next
[17:43:53.824]                   args[[name]] <- ""
[17:43:53.824]                 }
[17:43:53.824]                 NAMES <- toupper(removed)
[17:43:53.824]                 for (kk in seq_along(NAMES)) {
[17:43:53.824]                   name <- removed[[kk]]
[17:43:53.824]                   NAME <- NAMES[[kk]]
[17:43:53.824]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.824]                     next
[17:43:53.824]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.824]                 }
[17:43:53.824]                 if (length(args) > 0) 
[17:43:53.824]                   base::do.call(base::Sys.setenv, args = args)
[17:43:53.824]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:53.824]             }
[17:43:53.824]             else {
[17:43:53.824]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:53.824]             }
[17:43:53.824]             {
[17:43:53.824]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:53.824]                   0L) {
[17:43:53.824]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:53.824]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:53.824]                   base::options(opts)
[17:43:53.824]                 }
[17:43:53.824]                 {
[17:43:53.824]                   {
[17:43:53.824]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:53.824]                     NULL
[17:43:53.824]                   }
[17:43:53.824]                   options(future.plan = NULL)
[17:43:53.824]                   if (is.na(NA_character_)) 
[17:43:53.824]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.824]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:53.824]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:53.824]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:53.824]                     envir = parent.frame()) 
[17:43:53.824]                   {
[17:43:53.824]                     if (is.function(workers)) 
[17:43:53.824]                       workers <- workers()
[17:43:53.824]                     workers <- structure(as.integer(workers), 
[17:43:53.824]                       class = class(workers))
[17:43:53.824]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:53.824]                       workers >= 1)
[17:43:53.824]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:53.824]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:53.824]                     }
[17:43:53.824]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:53.824]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:53.824]                       envir = envir)
[17:43:53.824]                     if (!future$lazy) 
[17:43:53.824]                       future <- run(future)
[17:43:53.824]                     invisible(future)
[17:43:53.824]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:53.824]                 }
[17:43:53.824]             }
[17:43:53.824]         }
[17:43:53.824]     })
[17:43:53.824]     if (TRUE) {
[17:43:53.824]         base::sink(type = "output", split = FALSE)
[17:43:53.824]         if (TRUE) {
[17:43:53.824]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:53.824]         }
[17:43:53.824]         else {
[17:43:53.824]             ...future.result["stdout"] <- base::list(NULL)
[17:43:53.824]         }
[17:43:53.824]         base::close(...future.stdout)
[17:43:53.824]         ...future.stdout <- NULL
[17:43:53.824]     }
[17:43:53.824]     ...future.result$conditions <- ...future.conditions
[17:43:53.824]     ...future.result$finished <- base::Sys.time()
[17:43:53.824]     ...future.result
[17:43:53.824] }
[17:43:53.827] MultisessionFuture started
[17:43:53.827] - Launch lazy future ... done
[17:43:53.827] run() for ‘MultisessionFuture’ ... done
[17:43:53.838]  length: 2 (resolved future 3)
[17:43:53.849] receiveMessageFromWorker() for ClusterFuture ...
[17:43:53.849] - Validating connection of MultisessionFuture
[17:43:53.849] - received message: FutureResult
[17:43:53.849] - Received FutureResult
[17:43:53.849] - Erased future from FutureRegistry
[17:43:53.850] result() for ClusterFuture ...
[17:43:53.850] - result already collected: FutureResult
[17:43:53.850] result() for ClusterFuture ... done
[17:43:53.850] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:53.850] Future #1
[17:43:53.850]  length: 1 (resolved future 1)
[17:43:53.876] receiveMessageFromWorker() for ClusterFuture ...
[17:43:53.876] - Validating connection of MultisessionFuture
[17:43:53.876] - received message: FutureResult
[17:43:53.876] - Received FutureResult
[17:43:53.877] - Erased future from FutureRegistry
[17:43:53.877] result() for ClusterFuture ...
[17:43:53.877] - result already collected: FutureResult
[17:43:53.877] result() for ClusterFuture ... done
[17:43:53.877] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:53.877] Future #2
[17:43:53.877]  length: 0 (resolved future 2)
[17:43:53.877] resolve() on list ... DONE
[17:43:53.877] getGlobalsAndPackages() ...
[17:43:53.878] Searching for globals...
[17:43:53.878] 
[17:43:53.878] Searching for globals ... DONE
[17:43:53.878] - globals: [0] <none>
[17:43:53.878] getGlobalsAndPackages() ... DONE
[17:43:53.878] run() for ‘Future’ ...
[17:43:53.879] - state: ‘created’
[17:43:53.879] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:53.894] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:53.894] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:53.894]   - Field: ‘node’
[17:43:53.894]   - Field: ‘label’
[17:43:53.895]   - Field: ‘local’
[17:43:53.895]   - Field: ‘owner’
[17:43:53.895]   - Field: ‘envir’
[17:43:53.895]   - Field: ‘workers’
[17:43:53.895]   - Field: ‘packages’
[17:43:53.895]   - Field: ‘gc’
[17:43:53.895]   - Field: ‘conditions’
[17:43:53.895]   - Field: ‘persistent’
[17:43:53.895]   - Field: ‘expr’
[17:43:53.896]   - Field: ‘uuid’
[17:43:53.896]   - Field: ‘seed’
[17:43:53.896]   - Field: ‘version’
[17:43:53.896]   - Field: ‘result’
[17:43:53.896]   - Field: ‘asynchronous’
[17:43:53.896]   - Field: ‘calls’
[17:43:53.896]   - Field: ‘globals’
[17:43:53.896]   - Field: ‘stdout’
[17:43:53.896]   - Field: ‘earlySignal’
[17:43:53.896]   - Field: ‘lazy’
[17:43:53.897]   - Field: ‘state’
[17:43:53.897] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:53.897] - Launch lazy future ...
[17:43:53.897] Packages needed by the future expression (n = 0): <none>
[17:43:53.897] Packages needed by future strategies (n = 0): <none>
[17:43:53.898] {
[17:43:53.898]     {
[17:43:53.898]         {
[17:43:53.898]             ...future.startTime <- base::Sys.time()
[17:43:53.898]             {
[17:43:53.898]                 {
[17:43:53.898]                   {
[17:43:53.898]                     {
[17:43:53.898]                       base::local({
[17:43:53.898]                         has_future <- base::requireNamespace("future", 
[17:43:53.898]                           quietly = TRUE)
[17:43:53.898]                         if (has_future) {
[17:43:53.898]                           ns <- base::getNamespace("future")
[17:43:53.898]                           version <- ns[[".package"]][["version"]]
[17:43:53.898]                           if (is.null(version)) 
[17:43:53.898]                             version <- utils::packageVersion("future")
[17:43:53.898]                         }
[17:43:53.898]                         else {
[17:43:53.898]                           version <- NULL
[17:43:53.898]                         }
[17:43:53.898]                         if (!has_future || version < "1.8.0") {
[17:43:53.898]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:53.898]                             "", base::R.version$version.string), 
[17:43:53.898]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:53.898]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:53.898]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:53.898]                               "release", "version")], collapse = " "), 
[17:43:53.898]                             hostname = base::Sys.info()[["nodename"]])
[17:43:53.898]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:53.898]                             info)
[17:43:53.898]                           info <- base::paste(info, collapse = "; ")
[17:43:53.898]                           if (!has_future) {
[17:43:53.898]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:53.898]                               info)
[17:43:53.898]                           }
[17:43:53.898]                           else {
[17:43:53.898]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:53.898]                               info, version)
[17:43:53.898]                           }
[17:43:53.898]                           base::stop(msg)
[17:43:53.898]                         }
[17:43:53.898]                       })
[17:43:53.898]                     }
[17:43:53.898]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:53.898]                     base::options(mc.cores = 1L)
[17:43:53.898]                   }
[17:43:53.898]                   options(future.plan = NULL)
[17:43:53.898]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.898]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:53.898]                 }
[17:43:53.898]                 ...future.workdir <- getwd()
[17:43:53.898]             }
[17:43:53.898]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:53.898]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:53.898]         }
[17:43:53.898]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:53.898]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:53.898]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:53.898]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:53.898]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:53.898]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:53.898]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:53.898]             base::names(...future.oldOptions))
[17:43:53.898]     }
[17:43:53.898]     if (FALSE) {
[17:43:53.898]     }
[17:43:53.898]     else {
[17:43:53.898]         if (TRUE) {
[17:43:53.898]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:53.898]                 open = "w")
[17:43:53.898]         }
[17:43:53.898]         else {
[17:43:53.898]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:53.898]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:53.898]         }
[17:43:53.898]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:53.898]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:53.898]             base::sink(type = "output", split = FALSE)
[17:43:53.898]             base::close(...future.stdout)
[17:43:53.898]         }, add = TRUE)
[17:43:53.898]     }
[17:43:53.898]     ...future.frame <- base::sys.nframe()
[17:43:53.898]     ...future.conditions <- base::list()
[17:43:53.898]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:53.898]     if (FALSE) {
[17:43:53.898]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:53.898]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:53.898]     }
[17:43:53.898]     ...future.result <- base::tryCatch({
[17:43:53.898]         base::withCallingHandlers({
[17:43:53.898]             ...future.value <- base::withVisible(base::local({
[17:43:53.898]                 ...future.makeSendCondition <- local({
[17:43:53.898]                   sendCondition <- NULL
[17:43:53.898]                   function(frame = 1L) {
[17:43:53.898]                     if (is.function(sendCondition)) 
[17:43:53.898]                       return(sendCondition)
[17:43:53.898]                     ns <- getNamespace("parallel")
[17:43:53.898]                     if (exists("sendData", mode = "function", 
[17:43:53.898]                       envir = ns)) {
[17:43:53.898]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:53.898]                         envir = ns)
[17:43:53.898]                       envir <- sys.frame(frame)
[17:43:53.898]                       master <- NULL
[17:43:53.898]                       while (!identical(envir, .GlobalEnv) && 
[17:43:53.898]                         !identical(envir, emptyenv())) {
[17:43:53.898]                         if (exists("master", mode = "list", envir = envir, 
[17:43:53.898]                           inherits = FALSE)) {
[17:43:53.898]                           master <- get("master", mode = "list", 
[17:43:53.898]                             envir = envir, inherits = FALSE)
[17:43:53.898]                           if (inherits(master, c("SOCKnode", 
[17:43:53.898]                             "SOCK0node"))) {
[17:43:53.898]                             sendCondition <<- function(cond) {
[17:43:53.898]                               data <- list(type = "VALUE", value = cond, 
[17:43:53.898]                                 success = TRUE)
[17:43:53.898]                               parallel_sendData(master, data)
[17:43:53.898]                             }
[17:43:53.898]                             return(sendCondition)
[17:43:53.898]                           }
[17:43:53.898]                         }
[17:43:53.898]                         frame <- frame + 1L
[17:43:53.898]                         envir <- sys.frame(frame)
[17:43:53.898]                       }
[17:43:53.898]                     }
[17:43:53.898]                     sendCondition <<- function(cond) NULL
[17:43:53.898]                   }
[17:43:53.898]                 })
[17:43:53.898]                 withCallingHandlers({
[17:43:53.898]                   1
[17:43:53.898]                 }, immediateCondition = function(cond) {
[17:43:53.898]                   sendCondition <- ...future.makeSendCondition()
[17:43:53.898]                   sendCondition(cond)
[17:43:53.898]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.898]                   {
[17:43:53.898]                     inherits <- base::inherits
[17:43:53.898]                     invokeRestart <- base::invokeRestart
[17:43:53.898]                     is.null <- base::is.null
[17:43:53.898]                     muffled <- FALSE
[17:43:53.898]                     if (inherits(cond, "message")) {
[17:43:53.898]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:53.898]                       if (muffled) 
[17:43:53.898]                         invokeRestart("muffleMessage")
[17:43:53.898]                     }
[17:43:53.898]                     else if (inherits(cond, "warning")) {
[17:43:53.898]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:53.898]                       if (muffled) 
[17:43:53.898]                         invokeRestart("muffleWarning")
[17:43:53.898]                     }
[17:43:53.898]                     else if (inherits(cond, "condition")) {
[17:43:53.898]                       if (!is.null(pattern)) {
[17:43:53.898]                         computeRestarts <- base::computeRestarts
[17:43:53.898]                         grepl <- base::grepl
[17:43:53.898]                         restarts <- computeRestarts(cond)
[17:43:53.898]                         for (restart in restarts) {
[17:43:53.898]                           name <- restart$name
[17:43:53.898]                           if (is.null(name)) 
[17:43:53.898]                             next
[17:43:53.898]                           if (!grepl(pattern, name)) 
[17:43:53.898]                             next
[17:43:53.898]                           invokeRestart(restart)
[17:43:53.898]                           muffled <- TRUE
[17:43:53.898]                           break
[17:43:53.898]                         }
[17:43:53.898]                       }
[17:43:53.898]                     }
[17:43:53.898]                     invisible(muffled)
[17:43:53.898]                   }
[17:43:53.898]                   muffleCondition(cond)
[17:43:53.898]                 })
[17:43:53.898]             }))
[17:43:53.898]             future::FutureResult(value = ...future.value$value, 
[17:43:53.898]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.898]                   ...future.rng), globalenv = if (FALSE) 
[17:43:53.898]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:53.898]                     ...future.globalenv.names))
[17:43:53.898]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:53.898]         }, condition = base::local({
[17:43:53.898]             c <- base::c
[17:43:53.898]             inherits <- base::inherits
[17:43:53.898]             invokeRestart <- base::invokeRestart
[17:43:53.898]             length <- base::length
[17:43:53.898]             list <- base::list
[17:43:53.898]             seq.int <- base::seq.int
[17:43:53.898]             signalCondition <- base::signalCondition
[17:43:53.898]             sys.calls <- base::sys.calls
[17:43:53.898]             `[[` <- base::`[[`
[17:43:53.898]             `+` <- base::`+`
[17:43:53.898]             `<<-` <- base::`<<-`
[17:43:53.898]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:53.898]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:53.898]                   3L)]
[17:43:53.898]             }
[17:43:53.898]             function(cond) {
[17:43:53.898]                 is_error <- inherits(cond, "error")
[17:43:53.898]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:53.898]                   NULL)
[17:43:53.898]                 if (is_error) {
[17:43:53.898]                   sessionInformation <- function() {
[17:43:53.898]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:53.898]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:53.898]                       search = base::search(), system = base::Sys.info())
[17:43:53.898]                   }
[17:43:53.898]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.898]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:53.898]                     cond$call), session = sessionInformation(), 
[17:43:53.898]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:53.898]                   signalCondition(cond)
[17:43:53.898]                 }
[17:43:53.898]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:53.898]                 "immediateCondition"))) {
[17:43:53.898]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:53.898]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.898]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:53.898]                   if (TRUE && !signal) {
[17:43:53.898]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.898]                     {
[17:43:53.898]                       inherits <- base::inherits
[17:43:53.898]                       invokeRestart <- base::invokeRestart
[17:43:53.898]                       is.null <- base::is.null
[17:43:53.898]                       muffled <- FALSE
[17:43:53.898]                       if (inherits(cond, "message")) {
[17:43:53.898]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.898]                         if (muffled) 
[17:43:53.898]                           invokeRestart("muffleMessage")
[17:43:53.898]                       }
[17:43:53.898]                       else if (inherits(cond, "warning")) {
[17:43:53.898]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.898]                         if (muffled) 
[17:43:53.898]                           invokeRestart("muffleWarning")
[17:43:53.898]                       }
[17:43:53.898]                       else if (inherits(cond, "condition")) {
[17:43:53.898]                         if (!is.null(pattern)) {
[17:43:53.898]                           computeRestarts <- base::computeRestarts
[17:43:53.898]                           grepl <- base::grepl
[17:43:53.898]                           restarts <- computeRestarts(cond)
[17:43:53.898]                           for (restart in restarts) {
[17:43:53.898]                             name <- restart$name
[17:43:53.898]                             if (is.null(name)) 
[17:43:53.898]                               next
[17:43:53.898]                             if (!grepl(pattern, name)) 
[17:43:53.898]                               next
[17:43:53.898]                             invokeRestart(restart)
[17:43:53.898]                             muffled <- TRUE
[17:43:53.898]                             break
[17:43:53.898]                           }
[17:43:53.898]                         }
[17:43:53.898]                       }
[17:43:53.898]                       invisible(muffled)
[17:43:53.898]                     }
[17:43:53.898]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.898]                   }
[17:43:53.898]                 }
[17:43:53.898]                 else {
[17:43:53.898]                   if (TRUE) {
[17:43:53.898]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.898]                     {
[17:43:53.898]                       inherits <- base::inherits
[17:43:53.898]                       invokeRestart <- base::invokeRestart
[17:43:53.898]                       is.null <- base::is.null
[17:43:53.898]                       muffled <- FALSE
[17:43:53.898]                       if (inherits(cond, "message")) {
[17:43:53.898]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.898]                         if (muffled) 
[17:43:53.898]                           invokeRestart("muffleMessage")
[17:43:53.898]                       }
[17:43:53.898]                       else if (inherits(cond, "warning")) {
[17:43:53.898]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.898]                         if (muffled) 
[17:43:53.898]                           invokeRestart("muffleWarning")
[17:43:53.898]                       }
[17:43:53.898]                       else if (inherits(cond, "condition")) {
[17:43:53.898]                         if (!is.null(pattern)) {
[17:43:53.898]                           computeRestarts <- base::computeRestarts
[17:43:53.898]                           grepl <- base::grepl
[17:43:53.898]                           restarts <- computeRestarts(cond)
[17:43:53.898]                           for (restart in restarts) {
[17:43:53.898]                             name <- restart$name
[17:43:53.898]                             if (is.null(name)) 
[17:43:53.898]                               next
[17:43:53.898]                             if (!grepl(pattern, name)) 
[17:43:53.898]                               next
[17:43:53.898]                             invokeRestart(restart)
[17:43:53.898]                             muffled <- TRUE
[17:43:53.898]                             break
[17:43:53.898]                           }
[17:43:53.898]                         }
[17:43:53.898]                       }
[17:43:53.898]                       invisible(muffled)
[17:43:53.898]                     }
[17:43:53.898]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.898]                   }
[17:43:53.898]                 }
[17:43:53.898]             }
[17:43:53.898]         }))
[17:43:53.898]     }, error = function(ex) {
[17:43:53.898]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:53.898]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.898]                 ...future.rng), started = ...future.startTime, 
[17:43:53.898]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:53.898]             version = "1.8"), class = "FutureResult")
[17:43:53.898]     }, finally = {
[17:43:53.898]         if (!identical(...future.workdir, getwd())) 
[17:43:53.898]             setwd(...future.workdir)
[17:43:53.898]         {
[17:43:53.898]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:53.898]                 ...future.oldOptions$nwarnings <- NULL
[17:43:53.898]             }
[17:43:53.898]             base::options(...future.oldOptions)
[17:43:53.898]             if (.Platform$OS.type == "windows") {
[17:43:53.898]                 old_names <- names(...future.oldEnvVars)
[17:43:53.898]                 envs <- base::Sys.getenv()
[17:43:53.898]                 names <- names(envs)
[17:43:53.898]                 common <- intersect(names, old_names)
[17:43:53.898]                 added <- setdiff(names, old_names)
[17:43:53.898]                 removed <- setdiff(old_names, names)
[17:43:53.898]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:53.898]                   envs[common]]
[17:43:53.898]                 NAMES <- toupper(changed)
[17:43:53.898]                 args <- list()
[17:43:53.898]                 for (kk in seq_along(NAMES)) {
[17:43:53.898]                   name <- changed[[kk]]
[17:43:53.898]                   NAME <- NAMES[[kk]]
[17:43:53.898]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.898]                     next
[17:43:53.898]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.898]                 }
[17:43:53.898]                 NAMES <- toupper(added)
[17:43:53.898]                 for (kk in seq_along(NAMES)) {
[17:43:53.898]                   name <- added[[kk]]
[17:43:53.898]                   NAME <- NAMES[[kk]]
[17:43:53.898]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.898]                     next
[17:43:53.898]                   args[[name]] <- ""
[17:43:53.898]                 }
[17:43:53.898]                 NAMES <- toupper(removed)
[17:43:53.898]                 for (kk in seq_along(NAMES)) {
[17:43:53.898]                   name <- removed[[kk]]
[17:43:53.898]                   NAME <- NAMES[[kk]]
[17:43:53.898]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.898]                     next
[17:43:53.898]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.898]                 }
[17:43:53.898]                 if (length(args) > 0) 
[17:43:53.898]                   base::do.call(base::Sys.setenv, args = args)
[17:43:53.898]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:53.898]             }
[17:43:53.898]             else {
[17:43:53.898]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:53.898]             }
[17:43:53.898]             {
[17:43:53.898]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:53.898]                   0L) {
[17:43:53.898]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:53.898]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:53.898]                   base::options(opts)
[17:43:53.898]                 }
[17:43:53.898]                 {
[17:43:53.898]                   {
[17:43:53.898]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:53.898]                     NULL
[17:43:53.898]                   }
[17:43:53.898]                   options(future.plan = NULL)
[17:43:53.898]                   if (is.na(NA_character_)) 
[17:43:53.898]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.898]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:53.898]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:53.898]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:53.898]                     envir = parent.frame()) 
[17:43:53.898]                   {
[17:43:53.898]                     if (is.function(workers)) 
[17:43:53.898]                       workers <- workers()
[17:43:53.898]                     workers <- structure(as.integer(workers), 
[17:43:53.898]                       class = class(workers))
[17:43:53.898]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:53.898]                       workers >= 1)
[17:43:53.898]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:53.898]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:53.898]                     }
[17:43:53.898]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:53.898]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:53.898]                       envir = envir)
[17:43:53.898]                     if (!future$lazy) 
[17:43:53.898]                       future <- run(future)
[17:43:53.898]                     invisible(future)
[17:43:53.898]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:53.898]                 }
[17:43:53.898]             }
[17:43:53.898]         }
[17:43:53.898]     })
[17:43:53.898]     if (TRUE) {
[17:43:53.898]         base::sink(type = "output", split = FALSE)
[17:43:53.898]         if (TRUE) {
[17:43:53.898]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:53.898]         }
[17:43:53.898]         else {
[17:43:53.898]             ...future.result["stdout"] <- base::list(NULL)
[17:43:53.898]         }
[17:43:53.898]         base::close(...future.stdout)
[17:43:53.898]         ...future.stdout <- NULL
[17:43:53.898]     }
[17:43:53.898]     ...future.result$conditions <- ...future.conditions
[17:43:53.898]     ...future.result$finished <- base::Sys.time()
[17:43:53.898]     ...future.result
[17:43:53.898] }
[17:43:53.901] MultisessionFuture started
[17:43:53.901] - Launch lazy future ... done
[17:43:53.901] run() for ‘MultisessionFuture’ ... done
[17:43:53.901] getGlobalsAndPackages() ...
[17:43:53.901] Searching for globals...
[17:43:53.902] - globals found: [2] ‘{’, ‘Sys.sleep’
[17:43:53.903] Searching for globals ... DONE
[17:43:53.903] Resolving globals: FALSE
[17:43:53.903] 
[17:43:53.903] 
[17:43:53.903] getGlobalsAndPackages() ... DONE
[17:43:53.904] run() for ‘Future’ ...
[17:43:53.904] - state: ‘created’
[17:43:53.904] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:53.919] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:53.919] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:53.919]   - Field: ‘node’
[17:43:53.919]   - Field: ‘label’
[17:43:53.919]   - Field: ‘local’
[17:43:53.919]   - Field: ‘owner’
[17:43:53.919]   - Field: ‘envir’
[17:43:53.920]   - Field: ‘workers’
[17:43:53.920]   - Field: ‘packages’
[17:43:53.920]   - Field: ‘gc’
[17:43:53.920]   - Field: ‘conditions’
[17:43:53.920]   - Field: ‘persistent’
[17:43:53.920]   - Field: ‘expr’
[17:43:53.920]   - Field: ‘uuid’
[17:43:53.920]   - Field: ‘seed’
[17:43:53.920]   - Field: ‘version’
[17:43:53.920]   - Field: ‘result’
[17:43:53.920]   - Field: ‘asynchronous’
[17:43:53.921]   - Field: ‘calls’
[17:43:53.921]   - Field: ‘globals’
[17:43:53.921]   - Field: ‘stdout’
[17:43:53.921]   - Field: ‘earlySignal’
[17:43:53.921]   - Field: ‘lazy’
[17:43:53.921]   - Field: ‘state’
[17:43:53.921] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:53.921] - Launch lazy future ...
[17:43:53.921] Packages needed by the future expression (n = 0): <none>
[17:43:53.922] Packages needed by future strategies (n = 0): <none>
[17:43:53.922] {
[17:43:53.922]     {
[17:43:53.922]         {
[17:43:53.922]             ...future.startTime <- base::Sys.time()
[17:43:53.922]             {
[17:43:53.922]                 {
[17:43:53.922]                   {
[17:43:53.922]                     {
[17:43:53.922]                       base::local({
[17:43:53.922]                         has_future <- base::requireNamespace("future", 
[17:43:53.922]                           quietly = TRUE)
[17:43:53.922]                         if (has_future) {
[17:43:53.922]                           ns <- base::getNamespace("future")
[17:43:53.922]                           version <- ns[[".package"]][["version"]]
[17:43:53.922]                           if (is.null(version)) 
[17:43:53.922]                             version <- utils::packageVersion("future")
[17:43:53.922]                         }
[17:43:53.922]                         else {
[17:43:53.922]                           version <- NULL
[17:43:53.922]                         }
[17:43:53.922]                         if (!has_future || version < "1.8.0") {
[17:43:53.922]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:53.922]                             "", base::R.version$version.string), 
[17:43:53.922]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:53.922]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:53.922]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:53.922]                               "release", "version")], collapse = " "), 
[17:43:53.922]                             hostname = base::Sys.info()[["nodename"]])
[17:43:53.922]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:53.922]                             info)
[17:43:53.922]                           info <- base::paste(info, collapse = "; ")
[17:43:53.922]                           if (!has_future) {
[17:43:53.922]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:53.922]                               info)
[17:43:53.922]                           }
[17:43:53.922]                           else {
[17:43:53.922]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:53.922]                               info, version)
[17:43:53.922]                           }
[17:43:53.922]                           base::stop(msg)
[17:43:53.922]                         }
[17:43:53.922]                       })
[17:43:53.922]                     }
[17:43:53.922]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:53.922]                     base::options(mc.cores = 1L)
[17:43:53.922]                   }
[17:43:53.922]                   options(future.plan = NULL)
[17:43:53.922]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.922]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:53.922]                 }
[17:43:53.922]                 ...future.workdir <- getwd()
[17:43:53.922]             }
[17:43:53.922]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:53.922]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:53.922]         }
[17:43:53.922]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:53.922]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:53.922]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:53.922]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:53.922]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:53.922]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:53.922]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:53.922]             base::names(...future.oldOptions))
[17:43:53.922]     }
[17:43:53.922]     if (FALSE) {
[17:43:53.922]     }
[17:43:53.922]     else {
[17:43:53.922]         if (TRUE) {
[17:43:53.922]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:53.922]                 open = "w")
[17:43:53.922]         }
[17:43:53.922]         else {
[17:43:53.922]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:53.922]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:53.922]         }
[17:43:53.922]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:53.922]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:53.922]             base::sink(type = "output", split = FALSE)
[17:43:53.922]             base::close(...future.stdout)
[17:43:53.922]         }, add = TRUE)
[17:43:53.922]     }
[17:43:53.922]     ...future.frame <- base::sys.nframe()
[17:43:53.922]     ...future.conditions <- base::list()
[17:43:53.922]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:53.922]     if (FALSE) {
[17:43:53.922]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:53.922]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:53.922]     }
[17:43:53.922]     ...future.result <- base::tryCatch({
[17:43:53.922]         base::withCallingHandlers({
[17:43:53.922]             ...future.value <- base::withVisible(base::local({
[17:43:53.922]                 ...future.makeSendCondition <- local({
[17:43:53.922]                   sendCondition <- NULL
[17:43:53.922]                   function(frame = 1L) {
[17:43:53.922]                     if (is.function(sendCondition)) 
[17:43:53.922]                       return(sendCondition)
[17:43:53.922]                     ns <- getNamespace("parallel")
[17:43:53.922]                     if (exists("sendData", mode = "function", 
[17:43:53.922]                       envir = ns)) {
[17:43:53.922]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:53.922]                         envir = ns)
[17:43:53.922]                       envir <- sys.frame(frame)
[17:43:53.922]                       master <- NULL
[17:43:53.922]                       while (!identical(envir, .GlobalEnv) && 
[17:43:53.922]                         !identical(envir, emptyenv())) {
[17:43:53.922]                         if (exists("master", mode = "list", envir = envir, 
[17:43:53.922]                           inherits = FALSE)) {
[17:43:53.922]                           master <- get("master", mode = "list", 
[17:43:53.922]                             envir = envir, inherits = FALSE)
[17:43:53.922]                           if (inherits(master, c("SOCKnode", 
[17:43:53.922]                             "SOCK0node"))) {
[17:43:53.922]                             sendCondition <<- function(cond) {
[17:43:53.922]                               data <- list(type = "VALUE", value = cond, 
[17:43:53.922]                                 success = TRUE)
[17:43:53.922]                               parallel_sendData(master, data)
[17:43:53.922]                             }
[17:43:53.922]                             return(sendCondition)
[17:43:53.922]                           }
[17:43:53.922]                         }
[17:43:53.922]                         frame <- frame + 1L
[17:43:53.922]                         envir <- sys.frame(frame)
[17:43:53.922]                       }
[17:43:53.922]                     }
[17:43:53.922]                     sendCondition <<- function(cond) NULL
[17:43:53.922]                   }
[17:43:53.922]                 })
[17:43:53.922]                 withCallingHandlers({
[17:43:53.922]                   {
[17:43:53.922]                     Sys.sleep(0.5)
[17:43:53.922]                     2
[17:43:53.922]                   }
[17:43:53.922]                 }, immediateCondition = function(cond) {
[17:43:53.922]                   sendCondition <- ...future.makeSendCondition()
[17:43:53.922]                   sendCondition(cond)
[17:43:53.922]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.922]                   {
[17:43:53.922]                     inherits <- base::inherits
[17:43:53.922]                     invokeRestart <- base::invokeRestart
[17:43:53.922]                     is.null <- base::is.null
[17:43:53.922]                     muffled <- FALSE
[17:43:53.922]                     if (inherits(cond, "message")) {
[17:43:53.922]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:53.922]                       if (muffled) 
[17:43:53.922]                         invokeRestart("muffleMessage")
[17:43:53.922]                     }
[17:43:53.922]                     else if (inherits(cond, "warning")) {
[17:43:53.922]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:53.922]                       if (muffled) 
[17:43:53.922]                         invokeRestart("muffleWarning")
[17:43:53.922]                     }
[17:43:53.922]                     else if (inherits(cond, "condition")) {
[17:43:53.922]                       if (!is.null(pattern)) {
[17:43:53.922]                         computeRestarts <- base::computeRestarts
[17:43:53.922]                         grepl <- base::grepl
[17:43:53.922]                         restarts <- computeRestarts(cond)
[17:43:53.922]                         for (restart in restarts) {
[17:43:53.922]                           name <- restart$name
[17:43:53.922]                           if (is.null(name)) 
[17:43:53.922]                             next
[17:43:53.922]                           if (!grepl(pattern, name)) 
[17:43:53.922]                             next
[17:43:53.922]                           invokeRestart(restart)
[17:43:53.922]                           muffled <- TRUE
[17:43:53.922]                           break
[17:43:53.922]                         }
[17:43:53.922]                       }
[17:43:53.922]                     }
[17:43:53.922]                     invisible(muffled)
[17:43:53.922]                   }
[17:43:53.922]                   muffleCondition(cond)
[17:43:53.922]                 })
[17:43:53.922]             }))
[17:43:53.922]             future::FutureResult(value = ...future.value$value, 
[17:43:53.922]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.922]                   ...future.rng), globalenv = if (FALSE) 
[17:43:53.922]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:53.922]                     ...future.globalenv.names))
[17:43:53.922]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:53.922]         }, condition = base::local({
[17:43:53.922]             c <- base::c
[17:43:53.922]             inherits <- base::inherits
[17:43:53.922]             invokeRestart <- base::invokeRestart
[17:43:53.922]             length <- base::length
[17:43:53.922]             list <- base::list
[17:43:53.922]             seq.int <- base::seq.int
[17:43:53.922]             signalCondition <- base::signalCondition
[17:43:53.922]             sys.calls <- base::sys.calls
[17:43:53.922]             `[[` <- base::`[[`
[17:43:53.922]             `+` <- base::`+`
[17:43:53.922]             `<<-` <- base::`<<-`
[17:43:53.922]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:53.922]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:53.922]                   3L)]
[17:43:53.922]             }
[17:43:53.922]             function(cond) {
[17:43:53.922]                 is_error <- inherits(cond, "error")
[17:43:53.922]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:53.922]                   NULL)
[17:43:53.922]                 if (is_error) {
[17:43:53.922]                   sessionInformation <- function() {
[17:43:53.922]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:53.922]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:53.922]                       search = base::search(), system = base::Sys.info())
[17:43:53.922]                   }
[17:43:53.922]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.922]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:53.922]                     cond$call), session = sessionInformation(), 
[17:43:53.922]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:53.922]                   signalCondition(cond)
[17:43:53.922]                 }
[17:43:53.922]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:53.922]                 "immediateCondition"))) {
[17:43:53.922]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:53.922]                   ...future.conditions[[length(...future.conditions) + 
[17:43:53.922]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:53.922]                   if (TRUE && !signal) {
[17:43:53.922]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.922]                     {
[17:43:53.922]                       inherits <- base::inherits
[17:43:53.922]                       invokeRestart <- base::invokeRestart
[17:43:53.922]                       is.null <- base::is.null
[17:43:53.922]                       muffled <- FALSE
[17:43:53.922]                       if (inherits(cond, "message")) {
[17:43:53.922]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.922]                         if (muffled) 
[17:43:53.922]                           invokeRestart("muffleMessage")
[17:43:53.922]                       }
[17:43:53.922]                       else if (inherits(cond, "warning")) {
[17:43:53.922]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.922]                         if (muffled) 
[17:43:53.922]                           invokeRestart("muffleWarning")
[17:43:53.922]                       }
[17:43:53.922]                       else if (inherits(cond, "condition")) {
[17:43:53.922]                         if (!is.null(pattern)) {
[17:43:53.922]                           computeRestarts <- base::computeRestarts
[17:43:53.922]                           grepl <- base::grepl
[17:43:53.922]                           restarts <- computeRestarts(cond)
[17:43:53.922]                           for (restart in restarts) {
[17:43:53.922]                             name <- restart$name
[17:43:53.922]                             if (is.null(name)) 
[17:43:53.922]                               next
[17:43:53.922]                             if (!grepl(pattern, name)) 
[17:43:53.922]                               next
[17:43:53.922]                             invokeRestart(restart)
[17:43:53.922]                             muffled <- TRUE
[17:43:53.922]                             break
[17:43:53.922]                           }
[17:43:53.922]                         }
[17:43:53.922]                       }
[17:43:53.922]                       invisible(muffled)
[17:43:53.922]                     }
[17:43:53.922]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.922]                   }
[17:43:53.922]                 }
[17:43:53.922]                 else {
[17:43:53.922]                   if (TRUE) {
[17:43:53.922]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:53.922]                     {
[17:43:53.922]                       inherits <- base::inherits
[17:43:53.922]                       invokeRestart <- base::invokeRestart
[17:43:53.922]                       is.null <- base::is.null
[17:43:53.922]                       muffled <- FALSE
[17:43:53.922]                       if (inherits(cond, "message")) {
[17:43:53.922]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:53.922]                         if (muffled) 
[17:43:53.922]                           invokeRestart("muffleMessage")
[17:43:53.922]                       }
[17:43:53.922]                       else if (inherits(cond, "warning")) {
[17:43:53.922]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:53.922]                         if (muffled) 
[17:43:53.922]                           invokeRestart("muffleWarning")
[17:43:53.922]                       }
[17:43:53.922]                       else if (inherits(cond, "condition")) {
[17:43:53.922]                         if (!is.null(pattern)) {
[17:43:53.922]                           computeRestarts <- base::computeRestarts
[17:43:53.922]                           grepl <- base::grepl
[17:43:53.922]                           restarts <- computeRestarts(cond)
[17:43:53.922]                           for (restart in restarts) {
[17:43:53.922]                             name <- restart$name
[17:43:53.922]                             if (is.null(name)) 
[17:43:53.922]                               next
[17:43:53.922]                             if (!grepl(pattern, name)) 
[17:43:53.922]                               next
[17:43:53.922]                             invokeRestart(restart)
[17:43:53.922]                             muffled <- TRUE
[17:43:53.922]                             break
[17:43:53.922]                           }
[17:43:53.922]                         }
[17:43:53.922]                       }
[17:43:53.922]                       invisible(muffled)
[17:43:53.922]                     }
[17:43:53.922]                     muffleCondition(cond, pattern = "^muffle")
[17:43:53.922]                   }
[17:43:53.922]                 }
[17:43:53.922]             }
[17:43:53.922]         }))
[17:43:53.922]     }, error = function(ex) {
[17:43:53.922]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:53.922]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:53.922]                 ...future.rng), started = ...future.startTime, 
[17:43:53.922]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:53.922]             version = "1.8"), class = "FutureResult")
[17:43:53.922]     }, finally = {
[17:43:53.922]         if (!identical(...future.workdir, getwd())) 
[17:43:53.922]             setwd(...future.workdir)
[17:43:53.922]         {
[17:43:53.922]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:53.922]                 ...future.oldOptions$nwarnings <- NULL
[17:43:53.922]             }
[17:43:53.922]             base::options(...future.oldOptions)
[17:43:53.922]             if (.Platform$OS.type == "windows") {
[17:43:53.922]                 old_names <- names(...future.oldEnvVars)
[17:43:53.922]                 envs <- base::Sys.getenv()
[17:43:53.922]                 names <- names(envs)
[17:43:53.922]                 common <- intersect(names, old_names)
[17:43:53.922]                 added <- setdiff(names, old_names)
[17:43:53.922]                 removed <- setdiff(old_names, names)
[17:43:53.922]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:53.922]                   envs[common]]
[17:43:53.922]                 NAMES <- toupper(changed)
[17:43:53.922]                 args <- list()
[17:43:53.922]                 for (kk in seq_along(NAMES)) {
[17:43:53.922]                   name <- changed[[kk]]
[17:43:53.922]                   NAME <- NAMES[[kk]]
[17:43:53.922]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.922]                     next
[17:43:53.922]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.922]                 }
[17:43:53.922]                 NAMES <- toupper(added)
[17:43:53.922]                 for (kk in seq_along(NAMES)) {
[17:43:53.922]                   name <- added[[kk]]
[17:43:53.922]                   NAME <- NAMES[[kk]]
[17:43:53.922]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.922]                     next
[17:43:53.922]                   args[[name]] <- ""
[17:43:53.922]                 }
[17:43:53.922]                 NAMES <- toupper(removed)
[17:43:53.922]                 for (kk in seq_along(NAMES)) {
[17:43:53.922]                   name <- removed[[kk]]
[17:43:53.922]                   NAME <- NAMES[[kk]]
[17:43:53.922]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:53.922]                     next
[17:43:53.922]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:53.922]                 }
[17:43:53.922]                 if (length(args) > 0) 
[17:43:53.922]                   base::do.call(base::Sys.setenv, args = args)
[17:43:53.922]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:53.922]             }
[17:43:53.922]             else {
[17:43:53.922]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:53.922]             }
[17:43:53.922]             {
[17:43:53.922]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:53.922]                   0L) {
[17:43:53.922]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:53.922]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:53.922]                   base::options(opts)
[17:43:53.922]                 }
[17:43:53.922]                 {
[17:43:53.922]                   {
[17:43:53.922]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:53.922]                     NULL
[17:43:53.922]                   }
[17:43:53.922]                   options(future.plan = NULL)
[17:43:53.922]                   if (is.na(NA_character_)) 
[17:43:53.922]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:53.922]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:53.922]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:53.922]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:53.922]                     envir = parent.frame()) 
[17:43:53.922]                   {
[17:43:53.922]                     if (is.function(workers)) 
[17:43:53.922]                       workers <- workers()
[17:43:53.922]                     workers <- structure(as.integer(workers), 
[17:43:53.922]                       class = class(workers))
[17:43:53.922]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:53.922]                       workers >= 1)
[17:43:53.922]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:53.922]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:53.922]                     }
[17:43:53.922]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:53.922]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:53.922]                       envir = envir)
[17:43:53.922]                     if (!future$lazy) 
[17:43:53.922]                       future <- run(future)
[17:43:53.922]                     invisible(future)
[17:43:53.922]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:53.922]                 }
[17:43:53.922]             }
[17:43:53.922]         }
[17:43:53.922]     })
[17:43:53.922]     if (TRUE) {
[17:43:53.922]         base::sink(type = "output", split = FALSE)
[17:43:53.922]         if (TRUE) {
[17:43:53.922]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:53.922]         }
[17:43:53.922]         else {
[17:43:53.922]             ...future.result["stdout"] <- base::list(NULL)
[17:43:53.922]         }
[17:43:53.922]         base::close(...future.stdout)
[17:43:53.922]         ...future.stdout <- NULL
[17:43:53.922]     }
[17:43:53.922]     ...future.result$conditions <- ...future.conditions
[17:43:53.922]     ...future.result$finished <- base::Sys.time()
[17:43:53.922]     ...future.result
[17:43:53.922] }
[17:43:53.925] MultisessionFuture started
[17:43:53.926] - Launch lazy future ... done
[17:43:53.926] run() for ‘MultisessionFuture’ ... done
[17:43:53.926] resolve() on list ...
[17:43:53.926]  recursive: 0
[17:43:53.926]  length: 1
[17:43:53.926] 
[17:43:53.948] receiveMessageFromWorker() for ClusterFuture ...
[17:43:53.948] - Validating connection of MultisessionFuture
[17:43:53.949] - received message: FutureResult
[17:43:53.949] - Received FutureResult
[17:43:53.949] - Erased future from FutureRegistry
[17:43:53.949] result() for ClusterFuture ...
[17:43:53.949] - result already collected: FutureResult
[17:43:53.949] result() for ClusterFuture ... done
[17:43:53.949] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:53.949] Future #1
[17:43:53.950]  length: 0 (resolved future 1)
[17:43:53.950] resolve() on list ... DONE
[17:43:53.950] resolve() on list ...
[17:43:53.950]  recursive: 0
[17:43:53.950]  length: 1
[17:43:53.950] 
[17:43:54.473] receiveMessageFromWorker() for ClusterFuture ...
[17:43:54.473] - Validating connection of MultisessionFuture
[17:43:54.473] - received message: FutureResult
[17:43:54.473] - Received FutureResult
[17:43:54.473] - Erased future from FutureRegistry
[17:43:54.474] result() for ClusterFuture ...
[17:43:54.474] - result already collected: FutureResult
[17:43:54.474] result() for ClusterFuture ... done
[17:43:54.474] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:54.474] Future #1
[17:43:54.474]  length: 0 (resolved future 1)
[17:43:54.474] resolve() on list ... DONE
[17:43:54.474] resolve() on list ...
[17:43:54.475]  recursive: 0
[17:43:54.475]  length: 1
[17:43:54.475] 
[17:43:54.475]  length: 0 (resolved future 1)
[17:43:54.475] resolve() on list ... DONE
[17:43:54.475] resolve() on list ...
[17:43:54.475]  recursive: 0
[17:43:54.475]  length: 4
[17:43:54.475] 
[17:43:54.476] Future #1
[17:43:54.476]  length: 3 (resolved future 1)
[17:43:54.476] Future #2
[17:43:54.476]  length: 2 (resolved future 2)
[17:43:54.476]  length: 1 (resolved future 3)
[17:43:54.476]  length: 0 (resolved future 4)
[17:43:54.476] resolve() on list ... DONE
[17:43:54.476] resolve() on list ...
[17:43:54.476]  recursive: 0
[17:43:54.476]  length: 4
[17:43:54.477] 
[17:43:54.477] Future #1
[17:43:54.477]  length: 3 (resolved future 1)
[17:43:54.477] Future #2
[17:43:54.477]  length: 2 (resolved future 2)
[17:43:54.477]  length: 1 (resolved future 3)
[17:43:54.477]  length: 0 (resolved future 4)
[17:43:54.477] resolve() on list ... DONE
[17:43:54.477] resolve() on list ...
[17:43:54.478]  recursive: 0
[17:43:54.478]  length: 1
[17:43:54.478] 
[17:43:54.478]  length: 0 (resolved future 1)
[17:43:54.478] resolve() on list ... DONE
[17:43:54.478] getGlobalsAndPackages() ...
[17:43:54.478] Searching for globals...
[17:43:54.479] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:43:54.479] Searching for globals ... DONE
[17:43:54.479] Resolving globals: FALSE
[17:43:54.480] The total size of the 1 globals is 56 bytes (56 bytes)
[17:43:54.480] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:43:54.480] - globals: [1] ‘kk’
[17:43:54.480] 
[17:43:54.480] getGlobalsAndPackages() ... DONE
[17:43:54.481] run() for ‘Future’ ...
[17:43:54.481] - state: ‘created’
[17:43:54.481] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:54.495] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:54.495] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:54.495]   - Field: ‘node’
[17:43:54.496]   - Field: ‘label’
[17:43:54.496]   - Field: ‘local’
[17:43:54.496]   - Field: ‘owner’
[17:43:54.496]   - Field: ‘envir’
[17:43:54.496]   - Field: ‘workers’
[17:43:54.496]   - Field: ‘packages’
[17:43:54.496]   - Field: ‘gc’
[17:43:54.496]   - Field: ‘conditions’
[17:43:54.496]   - Field: ‘persistent’
[17:43:54.496]   - Field: ‘expr’
[17:43:54.496]   - Field: ‘uuid’
[17:43:54.497]   - Field: ‘seed’
[17:43:54.497]   - Field: ‘version’
[17:43:54.497]   - Field: ‘result’
[17:43:54.497]   - Field: ‘asynchronous’
[17:43:54.497]   - Field: ‘calls’
[17:43:54.497]   - Field: ‘globals’
[17:43:54.497]   - Field: ‘stdout’
[17:43:54.497]   - Field: ‘earlySignal’
[17:43:54.497]   - Field: ‘lazy’
[17:43:54.498]   - Field: ‘state’
[17:43:54.498] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:54.498] - Launch lazy future ...
[17:43:54.498] Packages needed by the future expression (n = 0): <none>
[17:43:54.498] Packages needed by future strategies (n = 0): <none>
[17:43:54.499] {
[17:43:54.499]     {
[17:43:54.499]         {
[17:43:54.499]             ...future.startTime <- base::Sys.time()
[17:43:54.499]             {
[17:43:54.499]                 {
[17:43:54.499]                   {
[17:43:54.499]                     {
[17:43:54.499]                       base::local({
[17:43:54.499]                         has_future <- base::requireNamespace("future", 
[17:43:54.499]                           quietly = TRUE)
[17:43:54.499]                         if (has_future) {
[17:43:54.499]                           ns <- base::getNamespace("future")
[17:43:54.499]                           version <- ns[[".package"]][["version"]]
[17:43:54.499]                           if (is.null(version)) 
[17:43:54.499]                             version <- utils::packageVersion("future")
[17:43:54.499]                         }
[17:43:54.499]                         else {
[17:43:54.499]                           version <- NULL
[17:43:54.499]                         }
[17:43:54.499]                         if (!has_future || version < "1.8.0") {
[17:43:54.499]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:54.499]                             "", base::R.version$version.string), 
[17:43:54.499]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:54.499]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:54.499]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:54.499]                               "release", "version")], collapse = " "), 
[17:43:54.499]                             hostname = base::Sys.info()[["nodename"]])
[17:43:54.499]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:54.499]                             info)
[17:43:54.499]                           info <- base::paste(info, collapse = "; ")
[17:43:54.499]                           if (!has_future) {
[17:43:54.499]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:54.499]                               info)
[17:43:54.499]                           }
[17:43:54.499]                           else {
[17:43:54.499]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:54.499]                               info, version)
[17:43:54.499]                           }
[17:43:54.499]                           base::stop(msg)
[17:43:54.499]                         }
[17:43:54.499]                       })
[17:43:54.499]                     }
[17:43:54.499]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:54.499]                     base::options(mc.cores = 1L)
[17:43:54.499]                   }
[17:43:54.499]                   options(future.plan = NULL)
[17:43:54.499]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:54.499]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:54.499]                 }
[17:43:54.499]                 ...future.workdir <- getwd()
[17:43:54.499]             }
[17:43:54.499]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:54.499]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:54.499]         }
[17:43:54.499]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:54.499]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:54.499]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:54.499]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:54.499]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:54.499]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:54.499]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:54.499]             base::names(...future.oldOptions))
[17:43:54.499]     }
[17:43:54.499]     if (FALSE) {
[17:43:54.499]     }
[17:43:54.499]     else {
[17:43:54.499]         if (TRUE) {
[17:43:54.499]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:54.499]                 open = "w")
[17:43:54.499]         }
[17:43:54.499]         else {
[17:43:54.499]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:54.499]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:54.499]         }
[17:43:54.499]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:54.499]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:54.499]             base::sink(type = "output", split = FALSE)
[17:43:54.499]             base::close(...future.stdout)
[17:43:54.499]         }, add = TRUE)
[17:43:54.499]     }
[17:43:54.499]     ...future.frame <- base::sys.nframe()
[17:43:54.499]     ...future.conditions <- base::list()
[17:43:54.499]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:54.499]     if (FALSE) {
[17:43:54.499]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:54.499]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:54.499]     }
[17:43:54.499]     ...future.result <- base::tryCatch({
[17:43:54.499]         base::withCallingHandlers({
[17:43:54.499]             ...future.value <- base::withVisible(base::local({
[17:43:54.499]                 ...future.makeSendCondition <- local({
[17:43:54.499]                   sendCondition <- NULL
[17:43:54.499]                   function(frame = 1L) {
[17:43:54.499]                     if (is.function(sendCondition)) 
[17:43:54.499]                       return(sendCondition)
[17:43:54.499]                     ns <- getNamespace("parallel")
[17:43:54.499]                     if (exists("sendData", mode = "function", 
[17:43:54.499]                       envir = ns)) {
[17:43:54.499]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:54.499]                         envir = ns)
[17:43:54.499]                       envir <- sys.frame(frame)
[17:43:54.499]                       master <- NULL
[17:43:54.499]                       while (!identical(envir, .GlobalEnv) && 
[17:43:54.499]                         !identical(envir, emptyenv())) {
[17:43:54.499]                         if (exists("master", mode = "list", envir = envir, 
[17:43:54.499]                           inherits = FALSE)) {
[17:43:54.499]                           master <- get("master", mode = "list", 
[17:43:54.499]                             envir = envir, inherits = FALSE)
[17:43:54.499]                           if (inherits(master, c("SOCKnode", 
[17:43:54.499]                             "SOCK0node"))) {
[17:43:54.499]                             sendCondition <<- function(cond) {
[17:43:54.499]                               data <- list(type = "VALUE", value = cond, 
[17:43:54.499]                                 success = TRUE)
[17:43:54.499]                               parallel_sendData(master, data)
[17:43:54.499]                             }
[17:43:54.499]                             return(sendCondition)
[17:43:54.499]                           }
[17:43:54.499]                         }
[17:43:54.499]                         frame <- frame + 1L
[17:43:54.499]                         envir <- sys.frame(frame)
[17:43:54.499]                       }
[17:43:54.499]                     }
[17:43:54.499]                     sendCondition <<- function(cond) NULL
[17:43:54.499]                   }
[17:43:54.499]                 })
[17:43:54.499]                 withCallingHandlers({
[17:43:54.499]                   {
[17:43:54.499]                     Sys.sleep(0.1)
[17:43:54.499]                     kk
[17:43:54.499]                   }
[17:43:54.499]                 }, immediateCondition = function(cond) {
[17:43:54.499]                   sendCondition <- ...future.makeSendCondition()
[17:43:54.499]                   sendCondition(cond)
[17:43:54.499]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:54.499]                   {
[17:43:54.499]                     inherits <- base::inherits
[17:43:54.499]                     invokeRestart <- base::invokeRestart
[17:43:54.499]                     is.null <- base::is.null
[17:43:54.499]                     muffled <- FALSE
[17:43:54.499]                     if (inherits(cond, "message")) {
[17:43:54.499]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:54.499]                       if (muffled) 
[17:43:54.499]                         invokeRestart("muffleMessage")
[17:43:54.499]                     }
[17:43:54.499]                     else if (inherits(cond, "warning")) {
[17:43:54.499]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:54.499]                       if (muffled) 
[17:43:54.499]                         invokeRestart("muffleWarning")
[17:43:54.499]                     }
[17:43:54.499]                     else if (inherits(cond, "condition")) {
[17:43:54.499]                       if (!is.null(pattern)) {
[17:43:54.499]                         computeRestarts <- base::computeRestarts
[17:43:54.499]                         grepl <- base::grepl
[17:43:54.499]                         restarts <- computeRestarts(cond)
[17:43:54.499]                         for (restart in restarts) {
[17:43:54.499]                           name <- restart$name
[17:43:54.499]                           if (is.null(name)) 
[17:43:54.499]                             next
[17:43:54.499]                           if (!grepl(pattern, name)) 
[17:43:54.499]                             next
[17:43:54.499]                           invokeRestart(restart)
[17:43:54.499]                           muffled <- TRUE
[17:43:54.499]                           break
[17:43:54.499]                         }
[17:43:54.499]                       }
[17:43:54.499]                     }
[17:43:54.499]                     invisible(muffled)
[17:43:54.499]                   }
[17:43:54.499]                   muffleCondition(cond)
[17:43:54.499]                 })
[17:43:54.499]             }))
[17:43:54.499]             future::FutureResult(value = ...future.value$value, 
[17:43:54.499]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:54.499]                   ...future.rng), globalenv = if (FALSE) 
[17:43:54.499]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:54.499]                     ...future.globalenv.names))
[17:43:54.499]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:54.499]         }, condition = base::local({
[17:43:54.499]             c <- base::c
[17:43:54.499]             inherits <- base::inherits
[17:43:54.499]             invokeRestart <- base::invokeRestart
[17:43:54.499]             length <- base::length
[17:43:54.499]             list <- base::list
[17:43:54.499]             seq.int <- base::seq.int
[17:43:54.499]             signalCondition <- base::signalCondition
[17:43:54.499]             sys.calls <- base::sys.calls
[17:43:54.499]             `[[` <- base::`[[`
[17:43:54.499]             `+` <- base::`+`
[17:43:54.499]             `<<-` <- base::`<<-`
[17:43:54.499]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:54.499]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:54.499]                   3L)]
[17:43:54.499]             }
[17:43:54.499]             function(cond) {
[17:43:54.499]                 is_error <- inherits(cond, "error")
[17:43:54.499]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:54.499]                   NULL)
[17:43:54.499]                 if (is_error) {
[17:43:54.499]                   sessionInformation <- function() {
[17:43:54.499]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:54.499]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:54.499]                       search = base::search(), system = base::Sys.info())
[17:43:54.499]                   }
[17:43:54.499]                   ...future.conditions[[length(...future.conditions) + 
[17:43:54.499]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:54.499]                     cond$call), session = sessionInformation(), 
[17:43:54.499]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:54.499]                   signalCondition(cond)
[17:43:54.499]                 }
[17:43:54.499]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:54.499]                 "immediateCondition"))) {
[17:43:54.499]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:54.499]                   ...future.conditions[[length(...future.conditions) + 
[17:43:54.499]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:54.499]                   if (TRUE && !signal) {
[17:43:54.499]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:54.499]                     {
[17:43:54.499]                       inherits <- base::inherits
[17:43:54.499]                       invokeRestart <- base::invokeRestart
[17:43:54.499]                       is.null <- base::is.null
[17:43:54.499]                       muffled <- FALSE
[17:43:54.499]                       if (inherits(cond, "message")) {
[17:43:54.499]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:54.499]                         if (muffled) 
[17:43:54.499]                           invokeRestart("muffleMessage")
[17:43:54.499]                       }
[17:43:54.499]                       else if (inherits(cond, "warning")) {
[17:43:54.499]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:54.499]                         if (muffled) 
[17:43:54.499]                           invokeRestart("muffleWarning")
[17:43:54.499]                       }
[17:43:54.499]                       else if (inherits(cond, "condition")) {
[17:43:54.499]                         if (!is.null(pattern)) {
[17:43:54.499]                           computeRestarts <- base::computeRestarts
[17:43:54.499]                           grepl <- base::grepl
[17:43:54.499]                           restarts <- computeRestarts(cond)
[17:43:54.499]                           for (restart in restarts) {
[17:43:54.499]                             name <- restart$name
[17:43:54.499]                             if (is.null(name)) 
[17:43:54.499]                               next
[17:43:54.499]                             if (!grepl(pattern, name)) 
[17:43:54.499]                               next
[17:43:54.499]                             invokeRestart(restart)
[17:43:54.499]                             muffled <- TRUE
[17:43:54.499]                             break
[17:43:54.499]                           }
[17:43:54.499]                         }
[17:43:54.499]                       }
[17:43:54.499]                       invisible(muffled)
[17:43:54.499]                     }
[17:43:54.499]                     muffleCondition(cond, pattern = "^muffle")
[17:43:54.499]                   }
[17:43:54.499]                 }
[17:43:54.499]                 else {
[17:43:54.499]                   if (TRUE) {
[17:43:54.499]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:54.499]                     {
[17:43:54.499]                       inherits <- base::inherits
[17:43:54.499]                       invokeRestart <- base::invokeRestart
[17:43:54.499]                       is.null <- base::is.null
[17:43:54.499]                       muffled <- FALSE
[17:43:54.499]                       if (inherits(cond, "message")) {
[17:43:54.499]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:54.499]                         if (muffled) 
[17:43:54.499]                           invokeRestart("muffleMessage")
[17:43:54.499]                       }
[17:43:54.499]                       else if (inherits(cond, "warning")) {
[17:43:54.499]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:54.499]                         if (muffled) 
[17:43:54.499]                           invokeRestart("muffleWarning")
[17:43:54.499]                       }
[17:43:54.499]                       else if (inherits(cond, "condition")) {
[17:43:54.499]                         if (!is.null(pattern)) {
[17:43:54.499]                           computeRestarts <- base::computeRestarts
[17:43:54.499]                           grepl <- base::grepl
[17:43:54.499]                           restarts <- computeRestarts(cond)
[17:43:54.499]                           for (restart in restarts) {
[17:43:54.499]                             name <- restart$name
[17:43:54.499]                             if (is.null(name)) 
[17:43:54.499]                               next
[17:43:54.499]                             if (!grepl(pattern, name)) 
[17:43:54.499]                               next
[17:43:54.499]                             invokeRestart(restart)
[17:43:54.499]                             muffled <- TRUE
[17:43:54.499]                             break
[17:43:54.499]                           }
[17:43:54.499]                         }
[17:43:54.499]                       }
[17:43:54.499]                       invisible(muffled)
[17:43:54.499]                     }
[17:43:54.499]                     muffleCondition(cond, pattern = "^muffle")
[17:43:54.499]                   }
[17:43:54.499]                 }
[17:43:54.499]             }
[17:43:54.499]         }))
[17:43:54.499]     }, error = function(ex) {
[17:43:54.499]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:54.499]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:54.499]                 ...future.rng), started = ...future.startTime, 
[17:43:54.499]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:54.499]             version = "1.8"), class = "FutureResult")
[17:43:54.499]     }, finally = {
[17:43:54.499]         if (!identical(...future.workdir, getwd())) 
[17:43:54.499]             setwd(...future.workdir)
[17:43:54.499]         {
[17:43:54.499]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:54.499]                 ...future.oldOptions$nwarnings <- NULL
[17:43:54.499]             }
[17:43:54.499]             base::options(...future.oldOptions)
[17:43:54.499]             if (.Platform$OS.type == "windows") {
[17:43:54.499]                 old_names <- names(...future.oldEnvVars)
[17:43:54.499]                 envs <- base::Sys.getenv()
[17:43:54.499]                 names <- names(envs)
[17:43:54.499]                 common <- intersect(names, old_names)
[17:43:54.499]                 added <- setdiff(names, old_names)
[17:43:54.499]                 removed <- setdiff(old_names, names)
[17:43:54.499]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:54.499]                   envs[common]]
[17:43:54.499]                 NAMES <- toupper(changed)
[17:43:54.499]                 args <- list()
[17:43:54.499]                 for (kk in seq_along(NAMES)) {
[17:43:54.499]                   name <- changed[[kk]]
[17:43:54.499]                   NAME <- NAMES[[kk]]
[17:43:54.499]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:54.499]                     next
[17:43:54.499]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:54.499]                 }
[17:43:54.499]                 NAMES <- toupper(added)
[17:43:54.499]                 for (kk in seq_along(NAMES)) {
[17:43:54.499]                   name <- added[[kk]]
[17:43:54.499]                   NAME <- NAMES[[kk]]
[17:43:54.499]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:54.499]                     next
[17:43:54.499]                   args[[name]] <- ""
[17:43:54.499]                 }
[17:43:54.499]                 NAMES <- toupper(removed)
[17:43:54.499]                 for (kk in seq_along(NAMES)) {
[17:43:54.499]                   name <- removed[[kk]]
[17:43:54.499]                   NAME <- NAMES[[kk]]
[17:43:54.499]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:54.499]                     next
[17:43:54.499]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:54.499]                 }
[17:43:54.499]                 if (length(args) > 0) 
[17:43:54.499]                   base::do.call(base::Sys.setenv, args = args)
[17:43:54.499]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:54.499]             }
[17:43:54.499]             else {
[17:43:54.499]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:54.499]             }
[17:43:54.499]             {
[17:43:54.499]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:54.499]                   0L) {
[17:43:54.499]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:54.499]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:54.499]                   base::options(opts)
[17:43:54.499]                 }
[17:43:54.499]                 {
[17:43:54.499]                   {
[17:43:54.499]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:54.499]                     NULL
[17:43:54.499]                   }
[17:43:54.499]                   options(future.plan = NULL)
[17:43:54.499]                   if (is.na(NA_character_)) 
[17:43:54.499]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:54.499]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:54.499]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:54.499]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:54.499]                     envir = parent.frame()) 
[17:43:54.499]                   {
[17:43:54.499]                     if (is.function(workers)) 
[17:43:54.499]                       workers <- workers()
[17:43:54.499]                     workers <- structure(as.integer(workers), 
[17:43:54.499]                       class = class(workers))
[17:43:54.499]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:54.499]                       workers >= 1)
[17:43:54.499]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:54.499]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:54.499]                     }
[17:43:54.499]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:54.499]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:54.499]                       envir = envir)
[17:43:54.499]                     if (!future$lazy) 
[17:43:54.499]                       future <- run(future)
[17:43:54.499]                     invisible(future)
[17:43:54.499]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:54.499]                 }
[17:43:54.499]             }
[17:43:54.499]         }
[17:43:54.499]     })
[17:43:54.499]     if (TRUE) {
[17:43:54.499]         base::sink(type = "output", split = FALSE)
[17:43:54.499]         if (TRUE) {
[17:43:54.499]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:54.499]         }
[17:43:54.499]         else {
[17:43:54.499]             ...future.result["stdout"] <- base::list(NULL)
[17:43:54.499]         }
[17:43:54.499]         base::close(...future.stdout)
[17:43:54.499]         ...future.stdout <- NULL
[17:43:54.499]     }
[17:43:54.499]     ...future.result$conditions <- ...future.conditions
[17:43:54.499]     ...future.result$finished <- base::Sys.time()
[17:43:54.499]     ...future.result
[17:43:54.499] }
[17:43:54.502] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[17:43:54.502] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[17:43:54.502] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[17:43:54.502] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[17:43:54.503] MultisessionFuture started
[17:43:54.503] - Launch lazy future ... done
[17:43:54.503] run() for ‘MultisessionFuture’ ... done
[17:43:54.503] getGlobalsAndPackages() ...
[17:43:54.503] Searching for globals...
[17:43:54.505] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:43:54.505] Searching for globals ... DONE
[17:43:54.505] Resolving globals: FALSE
[17:43:54.505] The total size of the 1 globals is 56 bytes (56 bytes)
[17:43:54.505] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:43:54.506] - globals: [1] ‘kk’
[17:43:54.506] 
[17:43:54.506] getGlobalsAndPackages() ... DONE
[17:43:54.506] run() for ‘Future’ ...
[17:43:54.506] - state: ‘created’
[17:43:54.506] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:54.521] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:54.521] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:54.521]   - Field: ‘node’
[17:43:54.521]   - Field: ‘label’
[17:43:54.521]   - Field: ‘local’
[17:43:54.521]   - Field: ‘owner’
[17:43:54.521]   - Field: ‘envir’
[17:43:54.522]   - Field: ‘workers’
[17:43:54.522]   - Field: ‘packages’
[17:43:54.522]   - Field: ‘gc’
[17:43:54.522]   - Field: ‘conditions’
[17:43:54.522]   - Field: ‘persistent’
[17:43:54.522]   - Field: ‘expr’
[17:43:54.522]   - Field: ‘uuid’
[17:43:54.522]   - Field: ‘seed’
[17:43:54.522]   - Field: ‘version’
[17:43:54.522]   - Field: ‘result’
[17:43:54.522]   - Field: ‘asynchronous’
[17:43:54.523]   - Field: ‘calls’
[17:43:54.525]   - Field: ‘globals’
[17:43:54.525]   - Field: ‘stdout’
[17:43:54.526]   - Field: ‘earlySignal’
[17:43:54.526]   - Field: ‘lazy’
[17:43:54.526]   - Field: ‘state’
[17:43:54.526] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:54.526] - Launch lazy future ...
[17:43:54.526] Packages needed by the future expression (n = 0): <none>
[17:43:54.527] Packages needed by future strategies (n = 0): <none>
[17:43:54.527] {
[17:43:54.527]     {
[17:43:54.527]         {
[17:43:54.527]             ...future.startTime <- base::Sys.time()
[17:43:54.527]             {
[17:43:54.527]                 {
[17:43:54.527]                   {
[17:43:54.527]                     {
[17:43:54.527]                       base::local({
[17:43:54.527]                         has_future <- base::requireNamespace("future", 
[17:43:54.527]                           quietly = TRUE)
[17:43:54.527]                         if (has_future) {
[17:43:54.527]                           ns <- base::getNamespace("future")
[17:43:54.527]                           version <- ns[[".package"]][["version"]]
[17:43:54.527]                           if (is.null(version)) 
[17:43:54.527]                             version <- utils::packageVersion("future")
[17:43:54.527]                         }
[17:43:54.527]                         else {
[17:43:54.527]                           version <- NULL
[17:43:54.527]                         }
[17:43:54.527]                         if (!has_future || version < "1.8.0") {
[17:43:54.527]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:54.527]                             "", base::R.version$version.string), 
[17:43:54.527]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:54.527]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:54.527]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:54.527]                               "release", "version")], collapse = " "), 
[17:43:54.527]                             hostname = base::Sys.info()[["nodename"]])
[17:43:54.527]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:54.527]                             info)
[17:43:54.527]                           info <- base::paste(info, collapse = "; ")
[17:43:54.527]                           if (!has_future) {
[17:43:54.527]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:54.527]                               info)
[17:43:54.527]                           }
[17:43:54.527]                           else {
[17:43:54.527]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:54.527]                               info, version)
[17:43:54.527]                           }
[17:43:54.527]                           base::stop(msg)
[17:43:54.527]                         }
[17:43:54.527]                       })
[17:43:54.527]                     }
[17:43:54.527]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:54.527]                     base::options(mc.cores = 1L)
[17:43:54.527]                   }
[17:43:54.527]                   options(future.plan = NULL)
[17:43:54.527]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:54.527]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:54.527]                 }
[17:43:54.527]                 ...future.workdir <- getwd()
[17:43:54.527]             }
[17:43:54.527]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:54.527]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:54.527]         }
[17:43:54.527]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:54.527]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:54.527]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:54.527]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:54.527]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:54.527]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:54.527]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:54.527]             base::names(...future.oldOptions))
[17:43:54.527]     }
[17:43:54.527]     if (FALSE) {
[17:43:54.527]     }
[17:43:54.527]     else {
[17:43:54.527]         if (TRUE) {
[17:43:54.527]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:54.527]                 open = "w")
[17:43:54.527]         }
[17:43:54.527]         else {
[17:43:54.527]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:54.527]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:54.527]         }
[17:43:54.527]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:54.527]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:54.527]             base::sink(type = "output", split = FALSE)
[17:43:54.527]             base::close(...future.stdout)
[17:43:54.527]         }, add = TRUE)
[17:43:54.527]     }
[17:43:54.527]     ...future.frame <- base::sys.nframe()
[17:43:54.527]     ...future.conditions <- base::list()
[17:43:54.527]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:54.527]     if (FALSE) {
[17:43:54.527]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:54.527]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:54.527]     }
[17:43:54.527]     ...future.result <- base::tryCatch({
[17:43:54.527]         base::withCallingHandlers({
[17:43:54.527]             ...future.value <- base::withVisible(base::local({
[17:43:54.527]                 ...future.makeSendCondition <- local({
[17:43:54.527]                   sendCondition <- NULL
[17:43:54.527]                   function(frame = 1L) {
[17:43:54.527]                     if (is.function(sendCondition)) 
[17:43:54.527]                       return(sendCondition)
[17:43:54.527]                     ns <- getNamespace("parallel")
[17:43:54.527]                     if (exists("sendData", mode = "function", 
[17:43:54.527]                       envir = ns)) {
[17:43:54.527]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:54.527]                         envir = ns)
[17:43:54.527]                       envir <- sys.frame(frame)
[17:43:54.527]                       master <- NULL
[17:43:54.527]                       while (!identical(envir, .GlobalEnv) && 
[17:43:54.527]                         !identical(envir, emptyenv())) {
[17:43:54.527]                         if (exists("master", mode = "list", envir = envir, 
[17:43:54.527]                           inherits = FALSE)) {
[17:43:54.527]                           master <- get("master", mode = "list", 
[17:43:54.527]                             envir = envir, inherits = FALSE)
[17:43:54.527]                           if (inherits(master, c("SOCKnode", 
[17:43:54.527]                             "SOCK0node"))) {
[17:43:54.527]                             sendCondition <<- function(cond) {
[17:43:54.527]                               data <- list(type = "VALUE", value = cond, 
[17:43:54.527]                                 success = TRUE)
[17:43:54.527]                               parallel_sendData(master, data)
[17:43:54.527]                             }
[17:43:54.527]                             return(sendCondition)
[17:43:54.527]                           }
[17:43:54.527]                         }
[17:43:54.527]                         frame <- frame + 1L
[17:43:54.527]                         envir <- sys.frame(frame)
[17:43:54.527]                       }
[17:43:54.527]                     }
[17:43:54.527]                     sendCondition <<- function(cond) NULL
[17:43:54.527]                   }
[17:43:54.527]                 })
[17:43:54.527]                 withCallingHandlers({
[17:43:54.527]                   {
[17:43:54.527]                     Sys.sleep(0.1)
[17:43:54.527]                     kk
[17:43:54.527]                   }
[17:43:54.527]                 }, immediateCondition = function(cond) {
[17:43:54.527]                   sendCondition <- ...future.makeSendCondition()
[17:43:54.527]                   sendCondition(cond)
[17:43:54.527]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:54.527]                   {
[17:43:54.527]                     inherits <- base::inherits
[17:43:54.527]                     invokeRestart <- base::invokeRestart
[17:43:54.527]                     is.null <- base::is.null
[17:43:54.527]                     muffled <- FALSE
[17:43:54.527]                     if (inherits(cond, "message")) {
[17:43:54.527]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:54.527]                       if (muffled) 
[17:43:54.527]                         invokeRestart("muffleMessage")
[17:43:54.527]                     }
[17:43:54.527]                     else if (inherits(cond, "warning")) {
[17:43:54.527]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:54.527]                       if (muffled) 
[17:43:54.527]                         invokeRestart("muffleWarning")
[17:43:54.527]                     }
[17:43:54.527]                     else if (inherits(cond, "condition")) {
[17:43:54.527]                       if (!is.null(pattern)) {
[17:43:54.527]                         computeRestarts <- base::computeRestarts
[17:43:54.527]                         grepl <- base::grepl
[17:43:54.527]                         restarts <- computeRestarts(cond)
[17:43:54.527]                         for (restart in restarts) {
[17:43:54.527]                           name <- restart$name
[17:43:54.527]                           if (is.null(name)) 
[17:43:54.527]                             next
[17:43:54.527]                           if (!grepl(pattern, name)) 
[17:43:54.527]                             next
[17:43:54.527]                           invokeRestart(restart)
[17:43:54.527]                           muffled <- TRUE
[17:43:54.527]                           break
[17:43:54.527]                         }
[17:43:54.527]                       }
[17:43:54.527]                     }
[17:43:54.527]                     invisible(muffled)
[17:43:54.527]                   }
[17:43:54.527]                   muffleCondition(cond)
[17:43:54.527]                 })
[17:43:54.527]             }))
[17:43:54.527]             future::FutureResult(value = ...future.value$value, 
[17:43:54.527]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:54.527]                   ...future.rng), globalenv = if (FALSE) 
[17:43:54.527]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:54.527]                     ...future.globalenv.names))
[17:43:54.527]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:54.527]         }, condition = base::local({
[17:43:54.527]             c <- base::c
[17:43:54.527]             inherits <- base::inherits
[17:43:54.527]             invokeRestart <- base::invokeRestart
[17:43:54.527]             length <- base::length
[17:43:54.527]             list <- base::list
[17:43:54.527]             seq.int <- base::seq.int
[17:43:54.527]             signalCondition <- base::signalCondition
[17:43:54.527]             sys.calls <- base::sys.calls
[17:43:54.527]             `[[` <- base::`[[`
[17:43:54.527]             `+` <- base::`+`
[17:43:54.527]             `<<-` <- base::`<<-`
[17:43:54.527]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:54.527]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:54.527]                   3L)]
[17:43:54.527]             }
[17:43:54.527]             function(cond) {
[17:43:54.527]                 is_error <- inherits(cond, "error")
[17:43:54.527]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:54.527]                   NULL)
[17:43:54.527]                 if (is_error) {
[17:43:54.527]                   sessionInformation <- function() {
[17:43:54.527]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:54.527]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:54.527]                       search = base::search(), system = base::Sys.info())
[17:43:54.527]                   }
[17:43:54.527]                   ...future.conditions[[length(...future.conditions) + 
[17:43:54.527]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:54.527]                     cond$call), session = sessionInformation(), 
[17:43:54.527]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:54.527]                   signalCondition(cond)
[17:43:54.527]                 }
[17:43:54.527]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:54.527]                 "immediateCondition"))) {
[17:43:54.527]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:54.527]                   ...future.conditions[[length(...future.conditions) + 
[17:43:54.527]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:54.527]                   if (TRUE && !signal) {
[17:43:54.527]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:54.527]                     {
[17:43:54.527]                       inherits <- base::inherits
[17:43:54.527]                       invokeRestart <- base::invokeRestart
[17:43:54.527]                       is.null <- base::is.null
[17:43:54.527]                       muffled <- FALSE
[17:43:54.527]                       if (inherits(cond, "message")) {
[17:43:54.527]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:54.527]                         if (muffled) 
[17:43:54.527]                           invokeRestart("muffleMessage")
[17:43:54.527]                       }
[17:43:54.527]                       else if (inherits(cond, "warning")) {
[17:43:54.527]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:54.527]                         if (muffled) 
[17:43:54.527]                           invokeRestart("muffleWarning")
[17:43:54.527]                       }
[17:43:54.527]                       else if (inherits(cond, "condition")) {
[17:43:54.527]                         if (!is.null(pattern)) {
[17:43:54.527]                           computeRestarts <- base::computeRestarts
[17:43:54.527]                           grepl <- base::grepl
[17:43:54.527]                           restarts <- computeRestarts(cond)
[17:43:54.527]                           for (restart in restarts) {
[17:43:54.527]                             name <- restart$name
[17:43:54.527]                             if (is.null(name)) 
[17:43:54.527]                               next
[17:43:54.527]                             if (!grepl(pattern, name)) 
[17:43:54.527]                               next
[17:43:54.527]                             invokeRestart(restart)
[17:43:54.527]                             muffled <- TRUE
[17:43:54.527]                             break
[17:43:54.527]                           }
[17:43:54.527]                         }
[17:43:54.527]                       }
[17:43:54.527]                       invisible(muffled)
[17:43:54.527]                     }
[17:43:54.527]                     muffleCondition(cond, pattern = "^muffle")
[17:43:54.527]                   }
[17:43:54.527]                 }
[17:43:54.527]                 else {
[17:43:54.527]                   if (TRUE) {
[17:43:54.527]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:54.527]                     {
[17:43:54.527]                       inherits <- base::inherits
[17:43:54.527]                       invokeRestart <- base::invokeRestart
[17:43:54.527]                       is.null <- base::is.null
[17:43:54.527]                       muffled <- FALSE
[17:43:54.527]                       if (inherits(cond, "message")) {
[17:43:54.527]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:54.527]                         if (muffled) 
[17:43:54.527]                           invokeRestart("muffleMessage")
[17:43:54.527]                       }
[17:43:54.527]                       else if (inherits(cond, "warning")) {
[17:43:54.527]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:54.527]                         if (muffled) 
[17:43:54.527]                           invokeRestart("muffleWarning")
[17:43:54.527]                       }
[17:43:54.527]                       else if (inherits(cond, "condition")) {
[17:43:54.527]                         if (!is.null(pattern)) {
[17:43:54.527]                           computeRestarts <- base::computeRestarts
[17:43:54.527]                           grepl <- base::grepl
[17:43:54.527]                           restarts <- computeRestarts(cond)
[17:43:54.527]                           for (restart in restarts) {
[17:43:54.527]                             name <- restart$name
[17:43:54.527]                             if (is.null(name)) 
[17:43:54.527]                               next
[17:43:54.527]                             if (!grepl(pattern, name)) 
[17:43:54.527]                               next
[17:43:54.527]                             invokeRestart(restart)
[17:43:54.527]                             muffled <- TRUE
[17:43:54.527]                             break
[17:43:54.527]                           }
[17:43:54.527]                         }
[17:43:54.527]                       }
[17:43:54.527]                       invisible(muffled)
[17:43:54.527]                     }
[17:43:54.527]                     muffleCondition(cond, pattern = "^muffle")
[17:43:54.527]                   }
[17:43:54.527]                 }
[17:43:54.527]             }
[17:43:54.527]         }))
[17:43:54.527]     }, error = function(ex) {
[17:43:54.527]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:54.527]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:54.527]                 ...future.rng), started = ...future.startTime, 
[17:43:54.527]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:54.527]             version = "1.8"), class = "FutureResult")
[17:43:54.527]     }, finally = {
[17:43:54.527]         if (!identical(...future.workdir, getwd())) 
[17:43:54.527]             setwd(...future.workdir)
[17:43:54.527]         {
[17:43:54.527]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:54.527]                 ...future.oldOptions$nwarnings <- NULL
[17:43:54.527]             }
[17:43:54.527]             base::options(...future.oldOptions)
[17:43:54.527]             if (.Platform$OS.type == "windows") {
[17:43:54.527]                 old_names <- names(...future.oldEnvVars)
[17:43:54.527]                 envs <- base::Sys.getenv()
[17:43:54.527]                 names <- names(envs)
[17:43:54.527]                 common <- intersect(names, old_names)
[17:43:54.527]                 added <- setdiff(names, old_names)
[17:43:54.527]                 removed <- setdiff(old_names, names)
[17:43:54.527]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:54.527]                   envs[common]]
[17:43:54.527]                 NAMES <- toupper(changed)
[17:43:54.527]                 args <- list()
[17:43:54.527]                 for (kk in seq_along(NAMES)) {
[17:43:54.527]                   name <- changed[[kk]]
[17:43:54.527]                   NAME <- NAMES[[kk]]
[17:43:54.527]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:54.527]                     next
[17:43:54.527]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:54.527]                 }
[17:43:54.527]                 NAMES <- toupper(added)
[17:43:54.527]                 for (kk in seq_along(NAMES)) {
[17:43:54.527]                   name <- added[[kk]]
[17:43:54.527]                   NAME <- NAMES[[kk]]
[17:43:54.527]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:54.527]                     next
[17:43:54.527]                   args[[name]] <- ""
[17:43:54.527]                 }
[17:43:54.527]                 NAMES <- toupper(removed)
[17:43:54.527]                 for (kk in seq_along(NAMES)) {
[17:43:54.527]                   name <- removed[[kk]]
[17:43:54.527]                   NAME <- NAMES[[kk]]
[17:43:54.527]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:54.527]                     next
[17:43:54.527]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:54.527]                 }
[17:43:54.527]                 if (length(args) > 0) 
[17:43:54.527]                   base::do.call(base::Sys.setenv, args = args)
[17:43:54.527]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:54.527]             }
[17:43:54.527]             else {
[17:43:54.527]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:54.527]             }
[17:43:54.527]             {
[17:43:54.527]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:54.527]                   0L) {
[17:43:54.527]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:54.527]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:54.527]                   base::options(opts)
[17:43:54.527]                 }
[17:43:54.527]                 {
[17:43:54.527]                   {
[17:43:54.527]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:54.527]                     NULL
[17:43:54.527]                   }
[17:43:54.527]                   options(future.plan = NULL)
[17:43:54.527]                   if (is.na(NA_character_)) 
[17:43:54.527]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:54.527]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:54.527]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:54.527]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:54.527]                     envir = parent.frame()) 
[17:43:54.527]                   {
[17:43:54.527]                     if (is.function(workers)) 
[17:43:54.527]                       workers <- workers()
[17:43:54.527]                     workers <- structure(as.integer(workers), 
[17:43:54.527]                       class = class(workers))
[17:43:54.527]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:54.527]                       workers >= 1)
[17:43:54.527]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:54.527]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:54.527]                     }
[17:43:54.527]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:54.527]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:54.527]                       envir = envir)
[17:43:54.527]                     if (!future$lazy) 
[17:43:54.527]                       future <- run(future)
[17:43:54.527]                     invisible(future)
[17:43:54.527]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:54.527]                 }
[17:43:54.527]             }
[17:43:54.527]         }
[17:43:54.527]     })
[17:43:54.527]     if (TRUE) {
[17:43:54.527]         base::sink(type = "output", split = FALSE)
[17:43:54.527]         if (TRUE) {
[17:43:54.527]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:54.527]         }
[17:43:54.527]         else {
[17:43:54.527]             ...future.result["stdout"] <- base::list(NULL)
[17:43:54.527]         }
[17:43:54.527]         base::close(...future.stdout)
[17:43:54.527]         ...future.stdout <- NULL
[17:43:54.527]     }
[17:43:54.527]     ...future.result$conditions <- ...future.conditions
[17:43:54.527]     ...future.result$finished <- base::Sys.time()
[17:43:54.527]     ...future.result
[17:43:54.527] }
[17:43:54.530] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[17:43:54.530] Exporting ‘kk’ (56 bytes) to cluster node #2 ...
[17:43:54.531] Exporting ‘kk’ (56 bytes) to cluster node #2 ... DONE
[17:43:54.531] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[17:43:54.531] MultisessionFuture started
[17:43:54.531] - Launch lazy future ... done
[17:43:54.532] run() for ‘MultisessionFuture’ ... done
[17:43:54.532] getGlobalsAndPackages() ...
[17:43:54.532] Searching for globals...
[17:43:54.533] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:43:54.533] Searching for globals ... DONE
[17:43:54.533] Resolving globals: FALSE
[17:43:54.533] The total size of the 1 globals is 56 bytes (56 bytes)
[17:43:54.534] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:43:54.534] - globals: [1] ‘kk’
[17:43:54.534] 
[17:43:54.534] getGlobalsAndPackages() ... DONE
[17:43:54.534] run() for ‘Future’ ...
[17:43:54.534] - state: ‘created’
[17:43:54.535] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:54.551] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:54.552] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:54.552]   - Field: ‘node’
[17:43:54.552]   - Field: ‘label’
[17:43:54.552]   - Field: ‘local’
[17:43:54.552]   - Field: ‘owner’
[17:43:54.552]   - Field: ‘envir’
[17:43:54.552]   - Field: ‘workers’
[17:43:54.552]   - Field: ‘packages’
[17:43:54.552]   - Field: ‘gc’
[17:43:54.552]   - Field: ‘conditions’
[17:43:54.553]   - Field: ‘persistent’
[17:43:54.553]   - Field: ‘expr’
[17:43:54.553]   - Field: ‘uuid’
[17:43:54.553]   - Field: ‘seed’
[17:43:54.553]   - Field: ‘version’
[17:43:54.553]   - Field: ‘result’
[17:43:54.553]   - Field: ‘asynchronous’
[17:43:54.553]   - Field: ‘calls’
[17:43:54.553]   - Field: ‘globals’
[17:43:54.553]   - Field: ‘stdout’
[17:43:54.553]   - Field: ‘earlySignal’
[17:43:54.554]   - Field: ‘lazy’
[17:43:54.554]   - Field: ‘state’
[17:43:54.554] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:54.554] - Launch lazy future ...
[17:43:54.554] Packages needed by the future expression (n = 0): <none>
[17:43:54.554] Packages needed by future strategies (n = 0): <none>
[17:43:54.555] {
[17:43:54.555]     {
[17:43:54.555]         {
[17:43:54.555]             ...future.startTime <- base::Sys.time()
[17:43:54.555]             {
[17:43:54.555]                 {
[17:43:54.555]                   {
[17:43:54.555]                     {
[17:43:54.555]                       base::local({
[17:43:54.555]                         has_future <- base::requireNamespace("future", 
[17:43:54.555]                           quietly = TRUE)
[17:43:54.555]                         if (has_future) {
[17:43:54.555]                           ns <- base::getNamespace("future")
[17:43:54.555]                           version <- ns[[".package"]][["version"]]
[17:43:54.555]                           if (is.null(version)) 
[17:43:54.555]                             version <- utils::packageVersion("future")
[17:43:54.555]                         }
[17:43:54.555]                         else {
[17:43:54.555]                           version <- NULL
[17:43:54.555]                         }
[17:43:54.555]                         if (!has_future || version < "1.8.0") {
[17:43:54.555]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:54.555]                             "", base::R.version$version.string), 
[17:43:54.555]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:54.555]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:54.555]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:54.555]                               "release", "version")], collapse = " "), 
[17:43:54.555]                             hostname = base::Sys.info()[["nodename"]])
[17:43:54.555]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:54.555]                             info)
[17:43:54.555]                           info <- base::paste(info, collapse = "; ")
[17:43:54.555]                           if (!has_future) {
[17:43:54.555]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:54.555]                               info)
[17:43:54.555]                           }
[17:43:54.555]                           else {
[17:43:54.555]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:54.555]                               info, version)
[17:43:54.555]                           }
[17:43:54.555]                           base::stop(msg)
[17:43:54.555]                         }
[17:43:54.555]                       })
[17:43:54.555]                     }
[17:43:54.555]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:54.555]                     base::options(mc.cores = 1L)
[17:43:54.555]                   }
[17:43:54.555]                   options(future.plan = NULL)
[17:43:54.555]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:54.555]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:54.555]                 }
[17:43:54.555]                 ...future.workdir <- getwd()
[17:43:54.555]             }
[17:43:54.555]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:54.555]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:54.555]         }
[17:43:54.555]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:54.555]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:54.555]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:54.555]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:54.555]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:54.555]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:54.555]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:54.555]             base::names(...future.oldOptions))
[17:43:54.555]     }
[17:43:54.555]     if (FALSE) {
[17:43:54.555]     }
[17:43:54.555]     else {
[17:43:54.555]         if (TRUE) {
[17:43:54.555]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:54.555]                 open = "w")
[17:43:54.555]         }
[17:43:54.555]         else {
[17:43:54.555]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:54.555]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:54.555]         }
[17:43:54.555]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:54.555]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:54.555]             base::sink(type = "output", split = FALSE)
[17:43:54.555]             base::close(...future.stdout)
[17:43:54.555]         }, add = TRUE)
[17:43:54.555]     }
[17:43:54.555]     ...future.frame <- base::sys.nframe()
[17:43:54.555]     ...future.conditions <- base::list()
[17:43:54.555]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:54.555]     if (FALSE) {
[17:43:54.555]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:54.555]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:54.555]     }
[17:43:54.555]     ...future.result <- base::tryCatch({
[17:43:54.555]         base::withCallingHandlers({
[17:43:54.555]             ...future.value <- base::withVisible(base::local({
[17:43:54.555]                 ...future.makeSendCondition <- local({
[17:43:54.555]                   sendCondition <- NULL
[17:43:54.555]                   function(frame = 1L) {
[17:43:54.555]                     if (is.function(sendCondition)) 
[17:43:54.555]                       return(sendCondition)
[17:43:54.555]                     ns <- getNamespace("parallel")
[17:43:54.555]                     if (exists("sendData", mode = "function", 
[17:43:54.555]                       envir = ns)) {
[17:43:54.555]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:54.555]                         envir = ns)
[17:43:54.555]                       envir <- sys.frame(frame)
[17:43:54.555]                       master <- NULL
[17:43:54.555]                       while (!identical(envir, .GlobalEnv) && 
[17:43:54.555]                         !identical(envir, emptyenv())) {
[17:43:54.555]                         if (exists("master", mode = "list", envir = envir, 
[17:43:54.555]                           inherits = FALSE)) {
[17:43:54.555]                           master <- get("master", mode = "list", 
[17:43:54.555]                             envir = envir, inherits = FALSE)
[17:43:54.555]                           if (inherits(master, c("SOCKnode", 
[17:43:54.555]                             "SOCK0node"))) {
[17:43:54.555]                             sendCondition <<- function(cond) {
[17:43:54.555]                               data <- list(type = "VALUE", value = cond, 
[17:43:54.555]                                 success = TRUE)
[17:43:54.555]                               parallel_sendData(master, data)
[17:43:54.555]                             }
[17:43:54.555]                             return(sendCondition)
[17:43:54.555]                           }
[17:43:54.555]                         }
[17:43:54.555]                         frame <- frame + 1L
[17:43:54.555]                         envir <- sys.frame(frame)
[17:43:54.555]                       }
[17:43:54.555]                     }
[17:43:54.555]                     sendCondition <<- function(cond) NULL
[17:43:54.555]                   }
[17:43:54.555]                 })
[17:43:54.555]                 withCallingHandlers({
[17:43:54.555]                   {
[17:43:54.555]                     Sys.sleep(0.1)
[17:43:54.555]                     kk
[17:43:54.555]                   }
[17:43:54.555]                 }, immediateCondition = function(cond) {
[17:43:54.555]                   sendCondition <- ...future.makeSendCondition()
[17:43:54.555]                   sendCondition(cond)
[17:43:54.555]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:54.555]                   {
[17:43:54.555]                     inherits <- base::inherits
[17:43:54.555]                     invokeRestart <- base::invokeRestart
[17:43:54.555]                     is.null <- base::is.null
[17:43:54.555]                     muffled <- FALSE
[17:43:54.555]                     if (inherits(cond, "message")) {
[17:43:54.555]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:54.555]                       if (muffled) 
[17:43:54.555]                         invokeRestart("muffleMessage")
[17:43:54.555]                     }
[17:43:54.555]                     else if (inherits(cond, "warning")) {
[17:43:54.555]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:54.555]                       if (muffled) 
[17:43:54.555]                         invokeRestart("muffleWarning")
[17:43:54.555]                     }
[17:43:54.555]                     else if (inherits(cond, "condition")) {
[17:43:54.555]                       if (!is.null(pattern)) {
[17:43:54.555]                         computeRestarts <- base::computeRestarts
[17:43:54.555]                         grepl <- base::grepl
[17:43:54.555]                         restarts <- computeRestarts(cond)
[17:43:54.555]                         for (restart in restarts) {
[17:43:54.555]                           name <- restart$name
[17:43:54.555]                           if (is.null(name)) 
[17:43:54.555]                             next
[17:43:54.555]                           if (!grepl(pattern, name)) 
[17:43:54.555]                             next
[17:43:54.555]                           invokeRestart(restart)
[17:43:54.555]                           muffled <- TRUE
[17:43:54.555]                           break
[17:43:54.555]                         }
[17:43:54.555]                       }
[17:43:54.555]                     }
[17:43:54.555]                     invisible(muffled)
[17:43:54.555]                   }
[17:43:54.555]                   muffleCondition(cond)
[17:43:54.555]                 })
[17:43:54.555]             }))
[17:43:54.555]             future::FutureResult(value = ...future.value$value, 
[17:43:54.555]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:54.555]                   ...future.rng), globalenv = if (FALSE) 
[17:43:54.555]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:54.555]                     ...future.globalenv.names))
[17:43:54.555]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:54.555]         }, condition = base::local({
[17:43:54.555]             c <- base::c
[17:43:54.555]             inherits <- base::inherits
[17:43:54.555]             invokeRestart <- base::invokeRestart
[17:43:54.555]             length <- base::length
[17:43:54.555]             list <- base::list
[17:43:54.555]             seq.int <- base::seq.int
[17:43:54.555]             signalCondition <- base::signalCondition
[17:43:54.555]             sys.calls <- base::sys.calls
[17:43:54.555]             `[[` <- base::`[[`
[17:43:54.555]             `+` <- base::`+`
[17:43:54.555]             `<<-` <- base::`<<-`
[17:43:54.555]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:54.555]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:54.555]                   3L)]
[17:43:54.555]             }
[17:43:54.555]             function(cond) {
[17:43:54.555]                 is_error <- inherits(cond, "error")
[17:43:54.555]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:54.555]                   NULL)
[17:43:54.555]                 if (is_error) {
[17:43:54.555]                   sessionInformation <- function() {
[17:43:54.555]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:54.555]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:54.555]                       search = base::search(), system = base::Sys.info())
[17:43:54.555]                   }
[17:43:54.555]                   ...future.conditions[[length(...future.conditions) + 
[17:43:54.555]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:54.555]                     cond$call), session = sessionInformation(), 
[17:43:54.555]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:54.555]                   signalCondition(cond)
[17:43:54.555]                 }
[17:43:54.555]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:54.555]                 "immediateCondition"))) {
[17:43:54.555]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:54.555]                   ...future.conditions[[length(...future.conditions) + 
[17:43:54.555]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:54.555]                   if (TRUE && !signal) {
[17:43:54.555]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:54.555]                     {
[17:43:54.555]                       inherits <- base::inherits
[17:43:54.555]                       invokeRestart <- base::invokeRestart
[17:43:54.555]                       is.null <- base::is.null
[17:43:54.555]                       muffled <- FALSE
[17:43:54.555]                       if (inherits(cond, "message")) {
[17:43:54.555]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:54.555]                         if (muffled) 
[17:43:54.555]                           invokeRestart("muffleMessage")
[17:43:54.555]                       }
[17:43:54.555]                       else if (inherits(cond, "warning")) {
[17:43:54.555]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:54.555]                         if (muffled) 
[17:43:54.555]                           invokeRestart("muffleWarning")
[17:43:54.555]                       }
[17:43:54.555]                       else if (inherits(cond, "condition")) {
[17:43:54.555]                         if (!is.null(pattern)) {
[17:43:54.555]                           computeRestarts <- base::computeRestarts
[17:43:54.555]                           grepl <- base::grepl
[17:43:54.555]                           restarts <- computeRestarts(cond)
[17:43:54.555]                           for (restart in restarts) {
[17:43:54.555]                             name <- restart$name
[17:43:54.555]                             if (is.null(name)) 
[17:43:54.555]                               next
[17:43:54.555]                             if (!grepl(pattern, name)) 
[17:43:54.555]                               next
[17:43:54.555]                             invokeRestart(restart)
[17:43:54.555]                             muffled <- TRUE
[17:43:54.555]                             break
[17:43:54.555]                           }
[17:43:54.555]                         }
[17:43:54.555]                       }
[17:43:54.555]                       invisible(muffled)
[17:43:54.555]                     }
[17:43:54.555]                     muffleCondition(cond, pattern = "^muffle")
[17:43:54.555]                   }
[17:43:54.555]                 }
[17:43:54.555]                 else {
[17:43:54.555]                   if (TRUE) {
[17:43:54.555]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:54.555]                     {
[17:43:54.555]                       inherits <- base::inherits
[17:43:54.555]                       invokeRestart <- base::invokeRestart
[17:43:54.555]                       is.null <- base::is.null
[17:43:54.555]                       muffled <- FALSE
[17:43:54.555]                       if (inherits(cond, "message")) {
[17:43:54.555]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:54.555]                         if (muffled) 
[17:43:54.555]                           invokeRestart("muffleMessage")
[17:43:54.555]                       }
[17:43:54.555]                       else if (inherits(cond, "warning")) {
[17:43:54.555]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:54.555]                         if (muffled) 
[17:43:54.555]                           invokeRestart("muffleWarning")
[17:43:54.555]                       }
[17:43:54.555]                       else if (inherits(cond, "condition")) {
[17:43:54.555]                         if (!is.null(pattern)) {
[17:43:54.555]                           computeRestarts <- base::computeRestarts
[17:43:54.555]                           grepl <- base::grepl
[17:43:54.555]                           restarts <- computeRestarts(cond)
[17:43:54.555]                           for (restart in restarts) {
[17:43:54.555]                             name <- restart$name
[17:43:54.555]                             if (is.null(name)) 
[17:43:54.555]                               next
[17:43:54.555]                             if (!grepl(pattern, name)) 
[17:43:54.555]                               next
[17:43:54.555]                             invokeRestart(restart)
[17:43:54.555]                             muffled <- TRUE
[17:43:54.555]                             break
[17:43:54.555]                           }
[17:43:54.555]                         }
[17:43:54.555]                       }
[17:43:54.555]                       invisible(muffled)
[17:43:54.555]                     }
[17:43:54.555]                     muffleCondition(cond, pattern = "^muffle")
[17:43:54.555]                   }
[17:43:54.555]                 }
[17:43:54.555]             }
[17:43:54.555]         }))
[17:43:54.555]     }, error = function(ex) {
[17:43:54.555]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:54.555]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:54.555]                 ...future.rng), started = ...future.startTime, 
[17:43:54.555]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:54.555]             version = "1.8"), class = "FutureResult")
[17:43:54.555]     }, finally = {
[17:43:54.555]         if (!identical(...future.workdir, getwd())) 
[17:43:54.555]             setwd(...future.workdir)
[17:43:54.555]         {
[17:43:54.555]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:54.555]                 ...future.oldOptions$nwarnings <- NULL
[17:43:54.555]             }
[17:43:54.555]             base::options(...future.oldOptions)
[17:43:54.555]             if (.Platform$OS.type == "windows") {
[17:43:54.555]                 old_names <- names(...future.oldEnvVars)
[17:43:54.555]                 envs <- base::Sys.getenv()
[17:43:54.555]                 names <- names(envs)
[17:43:54.555]                 common <- intersect(names, old_names)
[17:43:54.555]                 added <- setdiff(names, old_names)
[17:43:54.555]                 removed <- setdiff(old_names, names)
[17:43:54.555]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:54.555]                   envs[common]]
[17:43:54.555]                 NAMES <- toupper(changed)
[17:43:54.555]                 args <- list()
[17:43:54.555]                 for (kk in seq_along(NAMES)) {
[17:43:54.555]                   name <- changed[[kk]]
[17:43:54.555]                   NAME <- NAMES[[kk]]
[17:43:54.555]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:54.555]                     next
[17:43:54.555]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:54.555]                 }
[17:43:54.555]                 NAMES <- toupper(added)
[17:43:54.555]                 for (kk in seq_along(NAMES)) {
[17:43:54.555]                   name <- added[[kk]]
[17:43:54.555]                   NAME <- NAMES[[kk]]
[17:43:54.555]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:54.555]                     next
[17:43:54.555]                   args[[name]] <- ""
[17:43:54.555]                 }
[17:43:54.555]                 NAMES <- toupper(removed)
[17:43:54.555]                 for (kk in seq_along(NAMES)) {
[17:43:54.555]                   name <- removed[[kk]]
[17:43:54.555]                   NAME <- NAMES[[kk]]
[17:43:54.555]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:54.555]                     next
[17:43:54.555]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:54.555]                 }
[17:43:54.555]                 if (length(args) > 0) 
[17:43:54.555]                   base::do.call(base::Sys.setenv, args = args)
[17:43:54.555]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:54.555]             }
[17:43:54.555]             else {
[17:43:54.555]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:54.555]             }
[17:43:54.555]             {
[17:43:54.555]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:54.555]                   0L) {
[17:43:54.555]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:54.555]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:54.555]                   base::options(opts)
[17:43:54.555]                 }
[17:43:54.555]                 {
[17:43:54.555]                   {
[17:43:54.555]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:54.555]                     NULL
[17:43:54.555]                   }
[17:43:54.555]                   options(future.plan = NULL)
[17:43:54.555]                   if (is.na(NA_character_)) 
[17:43:54.555]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:54.555]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:54.555]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:54.555]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:54.555]                     envir = parent.frame()) 
[17:43:54.555]                   {
[17:43:54.555]                     if (is.function(workers)) 
[17:43:54.555]                       workers <- workers()
[17:43:54.555]                     workers <- structure(as.integer(workers), 
[17:43:54.555]                       class = class(workers))
[17:43:54.555]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:54.555]                       workers >= 1)
[17:43:54.555]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:54.555]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:54.555]                     }
[17:43:54.555]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:54.555]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:54.555]                       envir = envir)
[17:43:54.555]                     if (!future$lazy) 
[17:43:54.555]                       future <- run(future)
[17:43:54.555]                     invisible(future)
[17:43:54.555]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:54.555]                 }
[17:43:54.555]             }
[17:43:54.555]         }
[17:43:54.555]     })
[17:43:54.555]     if (TRUE) {
[17:43:54.555]         base::sink(type = "output", split = FALSE)
[17:43:54.555]         if (TRUE) {
[17:43:54.555]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:54.555]         }
[17:43:54.555]         else {
[17:43:54.555]             ...future.result["stdout"] <- base::list(NULL)
[17:43:54.555]         }
[17:43:54.555]         base::close(...future.stdout)
[17:43:54.555]         ...future.stdout <- NULL
[17:43:54.555]     }
[17:43:54.555]     ...future.result$conditions <- ...future.conditions
[17:43:54.555]     ...future.result$finished <- base::Sys.time()
[17:43:54.555]     ...future.result
[17:43:54.555] }
[17:43:54.557] Poll #1 (0): usedNodes() = 2, workers = 2
[17:43:54.589] Poll #2 (0.03 secs): usedNodes() = 2, workers = 2
[17:43:54.620] Poll #3 (0.06 secs): usedNodes() = 2, workers = 2
[17:43:54.652] Poll #4 (0.1 secs): usedNodes() = 2, workers = 2
[17:43:54.663] receiveMessageFromWorker() for ClusterFuture ...
[17:43:54.664] - Validating connection of MultisessionFuture
[17:43:54.664] - received message: FutureResult
[17:43:54.664] - Received FutureResult
[17:43:54.664] - Erased future from FutureRegistry
[17:43:54.664] result() for ClusterFuture ...
[17:43:54.664] - result already collected: FutureResult
[17:43:54.664] result() for ClusterFuture ... done
[17:43:54.665] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:54.665] result() for ClusterFuture ...
[17:43:54.665] - result already collected: FutureResult
[17:43:54.665] result() for ClusterFuture ... done
[17:43:54.665] result() for ClusterFuture ...
[17:43:54.665] - result already collected: FutureResult
[17:43:54.665] result() for ClusterFuture ... done
[17:43:54.666] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[17:43:54.666] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[17:43:54.666] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[17:43:54.666] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[17:43:54.667] MultisessionFuture started
[17:43:54.667] - Launch lazy future ... done
[17:43:54.667] run() for ‘MultisessionFuture’ ... done
[17:43:54.668] resolve() on list ...
[17:43:54.668]  recursive: 0
[17:43:54.668]  length: 3
[17:43:54.668] 
[17:43:54.668] Future #1
[17:43:54.668]  length: 2 (resolved future 1)
[17:43:54.700] receiveMessageFromWorker() for ClusterFuture ...
[17:43:54.700] - Validating connection of MultisessionFuture
[17:43:54.700] - received message: FutureResult
[17:43:54.700] - Received FutureResult
[17:43:54.700] - Erased future from FutureRegistry
[17:43:54.701] result() for ClusterFuture ...
[17:43:54.701] - result already collected: FutureResult
[17:43:54.701] result() for ClusterFuture ... done
[17:43:54.701] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:54.701] Future #2
[17:43:54.701]  length: 1 (resolved future 2)
[17:43:54.826] receiveMessageFromWorker() for ClusterFuture ...
[17:43:54.826] - Validating connection of MultisessionFuture
[17:43:54.826] - received message: FutureResult
[17:43:54.826] - Received FutureResult
[17:43:54.826] - Erased future from FutureRegistry
[17:43:54.826] result() for ClusterFuture ...
[17:43:54.826] - result already collected: FutureResult
[17:43:54.827] result() for ClusterFuture ... done
[17:43:54.827] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:54.827] Future #3
[17:43:54.827]  length: 0 (resolved future 3)
[17:43:54.827] resolve() on list ... DONE
[17:43:54.827] getGlobalsAndPackages() ...
[17:43:54.827] Searching for globals...
[17:43:54.828] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:43:54.829] Searching for globals ... DONE
[17:43:54.829] Resolving globals: FALSE
[17:43:54.829] The total size of the 1 globals is 56 bytes (56 bytes)
[17:43:54.829] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:43:54.830] - globals: [1] ‘kk’
[17:43:54.830] 
[17:43:54.830] getGlobalsAndPackages() ... DONE
[17:43:54.830] getGlobalsAndPackages() ...
[17:43:54.830] Searching for globals...
[17:43:54.831] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:43:54.831] Searching for globals ... DONE
[17:43:54.831] Resolving globals: FALSE
[17:43:54.832] The total size of the 1 globals is 56 bytes (56 bytes)
[17:43:54.832] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:43:54.832] - globals: [1] ‘kk’
[17:43:54.832] 
[17:43:54.832] getGlobalsAndPackages() ... DONE
[17:43:54.833] getGlobalsAndPackages() ...
[17:43:54.833] Searching for globals...
[17:43:54.834] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:43:54.834] Searching for globals ... DONE
[17:43:54.834] Resolving globals: FALSE
[17:43:54.834] The total size of the 1 globals is 56 bytes (56 bytes)
[17:43:54.834] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:43:54.835] - globals: [1] ‘kk’
[17:43:54.835] 
[17:43:54.835] getGlobalsAndPackages() ... DONE
[17:43:54.835] resolve() on list ...
[17:43:54.836]  recursive: 0
[17:43:54.836]  length: 3
[17:43:54.836] 
[17:43:54.836] run() for ‘Future’ ...
[17:43:54.836] - state: ‘created’
[17:43:54.836] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:54.851] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:54.851] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:54.851]   - Field: ‘node’
[17:43:54.851]   - Field: ‘label’
[17:43:54.851]   - Field: ‘local’
[17:43:54.851]   - Field: ‘owner’
[17:43:54.852]   - Field: ‘envir’
[17:43:54.852]   - Field: ‘workers’
[17:43:54.852]   - Field: ‘packages’
[17:43:54.852]   - Field: ‘gc’
[17:43:54.852]   - Field: ‘conditions’
[17:43:54.852]   - Field: ‘persistent’
[17:43:54.852]   - Field: ‘expr’
[17:43:54.852]   - Field: ‘uuid’
[17:43:54.852]   - Field: ‘seed’
[17:43:54.852]   - Field: ‘version’
[17:43:54.852]   - Field: ‘result’
[17:43:54.853]   - Field: ‘asynchronous’
[17:43:54.853]   - Field: ‘calls’
[17:43:54.853]   - Field: ‘globals’
[17:43:54.853]   - Field: ‘stdout’
[17:43:54.853]   - Field: ‘earlySignal’
[17:43:54.853]   - Field: ‘lazy’
[17:43:54.853]   - Field: ‘state’
[17:43:54.853] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:54.853] - Launch lazy future ...
[17:43:54.854] Packages needed by the future expression (n = 0): <none>
[17:43:54.854] Packages needed by future strategies (n = 0): <none>
[17:43:54.854] {
[17:43:54.854]     {
[17:43:54.854]         {
[17:43:54.854]             ...future.startTime <- base::Sys.time()
[17:43:54.854]             {
[17:43:54.854]                 {
[17:43:54.854]                   {
[17:43:54.854]                     {
[17:43:54.854]                       base::local({
[17:43:54.854]                         has_future <- base::requireNamespace("future", 
[17:43:54.854]                           quietly = TRUE)
[17:43:54.854]                         if (has_future) {
[17:43:54.854]                           ns <- base::getNamespace("future")
[17:43:54.854]                           version <- ns[[".package"]][["version"]]
[17:43:54.854]                           if (is.null(version)) 
[17:43:54.854]                             version <- utils::packageVersion("future")
[17:43:54.854]                         }
[17:43:54.854]                         else {
[17:43:54.854]                           version <- NULL
[17:43:54.854]                         }
[17:43:54.854]                         if (!has_future || version < "1.8.0") {
[17:43:54.854]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:54.854]                             "", base::R.version$version.string), 
[17:43:54.854]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:54.854]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:54.854]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:54.854]                               "release", "version")], collapse = " "), 
[17:43:54.854]                             hostname = base::Sys.info()[["nodename"]])
[17:43:54.854]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:54.854]                             info)
[17:43:54.854]                           info <- base::paste(info, collapse = "; ")
[17:43:54.854]                           if (!has_future) {
[17:43:54.854]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:54.854]                               info)
[17:43:54.854]                           }
[17:43:54.854]                           else {
[17:43:54.854]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:54.854]                               info, version)
[17:43:54.854]                           }
[17:43:54.854]                           base::stop(msg)
[17:43:54.854]                         }
[17:43:54.854]                       })
[17:43:54.854]                     }
[17:43:54.854]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:54.854]                     base::options(mc.cores = 1L)
[17:43:54.854]                   }
[17:43:54.854]                   options(future.plan = NULL)
[17:43:54.854]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:54.854]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:54.854]                 }
[17:43:54.854]                 ...future.workdir <- getwd()
[17:43:54.854]             }
[17:43:54.854]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:54.854]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:54.854]         }
[17:43:54.854]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:54.854]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:54.854]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:54.854]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:54.854]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:54.854]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:54.854]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:54.854]             base::names(...future.oldOptions))
[17:43:54.854]     }
[17:43:54.854]     if (FALSE) {
[17:43:54.854]     }
[17:43:54.854]     else {
[17:43:54.854]         if (TRUE) {
[17:43:54.854]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:54.854]                 open = "w")
[17:43:54.854]         }
[17:43:54.854]         else {
[17:43:54.854]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:54.854]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:54.854]         }
[17:43:54.854]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:54.854]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:54.854]             base::sink(type = "output", split = FALSE)
[17:43:54.854]             base::close(...future.stdout)
[17:43:54.854]         }, add = TRUE)
[17:43:54.854]     }
[17:43:54.854]     ...future.frame <- base::sys.nframe()
[17:43:54.854]     ...future.conditions <- base::list()
[17:43:54.854]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:54.854]     if (FALSE) {
[17:43:54.854]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:54.854]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:54.854]     }
[17:43:54.854]     ...future.result <- base::tryCatch({
[17:43:54.854]         base::withCallingHandlers({
[17:43:54.854]             ...future.value <- base::withVisible(base::local({
[17:43:54.854]                 ...future.makeSendCondition <- local({
[17:43:54.854]                   sendCondition <- NULL
[17:43:54.854]                   function(frame = 1L) {
[17:43:54.854]                     if (is.function(sendCondition)) 
[17:43:54.854]                       return(sendCondition)
[17:43:54.854]                     ns <- getNamespace("parallel")
[17:43:54.854]                     if (exists("sendData", mode = "function", 
[17:43:54.854]                       envir = ns)) {
[17:43:54.854]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:54.854]                         envir = ns)
[17:43:54.854]                       envir <- sys.frame(frame)
[17:43:54.854]                       master <- NULL
[17:43:54.854]                       while (!identical(envir, .GlobalEnv) && 
[17:43:54.854]                         !identical(envir, emptyenv())) {
[17:43:54.854]                         if (exists("master", mode = "list", envir = envir, 
[17:43:54.854]                           inherits = FALSE)) {
[17:43:54.854]                           master <- get("master", mode = "list", 
[17:43:54.854]                             envir = envir, inherits = FALSE)
[17:43:54.854]                           if (inherits(master, c("SOCKnode", 
[17:43:54.854]                             "SOCK0node"))) {
[17:43:54.854]                             sendCondition <<- function(cond) {
[17:43:54.854]                               data <- list(type = "VALUE", value = cond, 
[17:43:54.854]                                 success = TRUE)
[17:43:54.854]                               parallel_sendData(master, data)
[17:43:54.854]                             }
[17:43:54.854]                             return(sendCondition)
[17:43:54.854]                           }
[17:43:54.854]                         }
[17:43:54.854]                         frame <- frame + 1L
[17:43:54.854]                         envir <- sys.frame(frame)
[17:43:54.854]                       }
[17:43:54.854]                     }
[17:43:54.854]                     sendCondition <<- function(cond) NULL
[17:43:54.854]                   }
[17:43:54.854]                 })
[17:43:54.854]                 withCallingHandlers({
[17:43:54.854]                   {
[17:43:54.854]                     Sys.sleep(0.1)
[17:43:54.854]                     kk
[17:43:54.854]                   }
[17:43:54.854]                 }, immediateCondition = function(cond) {
[17:43:54.854]                   sendCondition <- ...future.makeSendCondition()
[17:43:54.854]                   sendCondition(cond)
[17:43:54.854]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:54.854]                   {
[17:43:54.854]                     inherits <- base::inherits
[17:43:54.854]                     invokeRestart <- base::invokeRestart
[17:43:54.854]                     is.null <- base::is.null
[17:43:54.854]                     muffled <- FALSE
[17:43:54.854]                     if (inherits(cond, "message")) {
[17:43:54.854]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:54.854]                       if (muffled) 
[17:43:54.854]                         invokeRestart("muffleMessage")
[17:43:54.854]                     }
[17:43:54.854]                     else if (inherits(cond, "warning")) {
[17:43:54.854]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:54.854]                       if (muffled) 
[17:43:54.854]                         invokeRestart("muffleWarning")
[17:43:54.854]                     }
[17:43:54.854]                     else if (inherits(cond, "condition")) {
[17:43:54.854]                       if (!is.null(pattern)) {
[17:43:54.854]                         computeRestarts <- base::computeRestarts
[17:43:54.854]                         grepl <- base::grepl
[17:43:54.854]                         restarts <- computeRestarts(cond)
[17:43:54.854]                         for (restart in restarts) {
[17:43:54.854]                           name <- restart$name
[17:43:54.854]                           if (is.null(name)) 
[17:43:54.854]                             next
[17:43:54.854]                           if (!grepl(pattern, name)) 
[17:43:54.854]                             next
[17:43:54.854]                           invokeRestart(restart)
[17:43:54.854]                           muffled <- TRUE
[17:43:54.854]                           break
[17:43:54.854]                         }
[17:43:54.854]                       }
[17:43:54.854]                     }
[17:43:54.854]                     invisible(muffled)
[17:43:54.854]                   }
[17:43:54.854]                   muffleCondition(cond)
[17:43:54.854]                 })
[17:43:54.854]             }))
[17:43:54.854]             future::FutureResult(value = ...future.value$value, 
[17:43:54.854]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:54.854]                   ...future.rng), globalenv = if (FALSE) 
[17:43:54.854]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:54.854]                     ...future.globalenv.names))
[17:43:54.854]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:54.854]         }, condition = base::local({
[17:43:54.854]             c <- base::c
[17:43:54.854]             inherits <- base::inherits
[17:43:54.854]             invokeRestart <- base::invokeRestart
[17:43:54.854]             length <- base::length
[17:43:54.854]             list <- base::list
[17:43:54.854]             seq.int <- base::seq.int
[17:43:54.854]             signalCondition <- base::signalCondition
[17:43:54.854]             sys.calls <- base::sys.calls
[17:43:54.854]             `[[` <- base::`[[`
[17:43:54.854]             `+` <- base::`+`
[17:43:54.854]             `<<-` <- base::`<<-`
[17:43:54.854]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:54.854]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:54.854]                   3L)]
[17:43:54.854]             }
[17:43:54.854]             function(cond) {
[17:43:54.854]                 is_error <- inherits(cond, "error")
[17:43:54.854]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:54.854]                   NULL)
[17:43:54.854]                 if (is_error) {
[17:43:54.854]                   sessionInformation <- function() {
[17:43:54.854]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:54.854]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:54.854]                       search = base::search(), system = base::Sys.info())
[17:43:54.854]                   }
[17:43:54.854]                   ...future.conditions[[length(...future.conditions) + 
[17:43:54.854]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:54.854]                     cond$call), session = sessionInformation(), 
[17:43:54.854]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:54.854]                   signalCondition(cond)
[17:43:54.854]                 }
[17:43:54.854]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:54.854]                 "immediateCondition"))) {
[17:43:54.854]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:54.854]                   ...future.conditions[[length(...future.conditions) + 
[17:43:54.854]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:54.854]                   if (TRUE && !signal) {
[17:43:54.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:54.854]                     {
[17:43:54.854]                       inherits <- base::inherits
[17:43:54.854]                       invokeRestart <- base::invokeRestart
[17:43:54.854]                       is.null <- base::is.null
[17:43:54.854]                       muffled <- FALSE
[17:43:54.854]                       if (inherits(cond, "message")) {
[17:43:54.854]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:54.854]                         if (muffled) 
[17:43:54.854]                           invokeRestart("muffleMessage")
[17:43:54.854]                       }
[17:43:54.854]                       else if (inherits(cond, "warning")) {
[17:43:54.854]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:54.854]                         if (muffled) 
[17:43:54.854]                           invokeRestart("muffleWarning")
[17:43:54.854]                       }
[17:43:54.854]                       else if (inherits(cond, "condition")) {
[17:43:54.854]                         if (!is.null(pattern)) {
[17:43:54.854]                           computeRestarts <- base::computeRestarts
[17:43:54.854]                           grepl <- base::grepl
[17:43:54.854]                           restarts <- computeRestarts(cond)
[17:43:54.854]                           for (restart in restarts) {
[17:43:54.854]                             name <- restart$name
[17:43:54.854]                             if (is.null(name)) 
[17:43:54.854]                               next
[17:43:54.854]                             if (!grepl(pattern, name)) 
[17:43:54.854]                               next
[17:43:54.854]                             invokeRestart(restart)
[17:43:54.854]                             muffled <- TRUE
[17:43:54.854]                             break
[17:43:54.854]                           }
[17:43:54.854]                         }
[17:43:54.854]                       }
[17:43:54.854]                       invisible(muffled)
[17:43:54.854]                     }
[17:43:54.854]                     muffleCondition(cond, pattern = "^muffle")
[17:43:54.854]                   }
[17:43:54.854]                 }
[17:43:54.854]                 else {
[17:43:54.854]                   if (TRUE) {
[17:43:54.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:54.854]                     {
[17:43:54.854]                       inherits <- base::inherits
[17:43:54.854]                       invokeRestart <- base::invokeRestart
[17:43:54.854]                       is.null <- base::is.null
[17:43:54.854]                       muffled <- FALSE
[17:43:54.854]                       if (inherits(cond, "message")) {
[17:43:54.854]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:54.854]                         if (muffled) 
[17:43:54.854]                           invokeRestart("muffleMessage")
[17:43:54.854]                       }
[17:43:54.854]                       else if (inherits(cond, "warning")) {
[17:43:54.854]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:54.854]                         if (muffled) 
[17:43:54.854]                           invokeRestart("muffleWarning")
[17:43:54.854]                       }
[17:43:54.854]                       else if (inherits(cond, "condition")) {
[17:43:54.854]                         if (!is.null(pattern)) {
[17:43:54.854]                           computeRestarts <- base::computeRestarts
[17:43:54.854]                           grepl <- base::grepl
[17:43:54.854]                           restarts <- computeRestarts(cond)
[17:43:54.854]                           for (restart in restarts) {
[17:43:54.854]                             name <- restart$name
[17:43:54.854]                             if (is.null(name)) 
[17:43:54.854]                               next
[17:43:54.854]                             if (!grepl(pattern, name)) 
[17:43:54.854]                               next
[17:43:54.854]                             invokeRestart(restart)
[17:43:54.854]                             muffled <- TRUE
[17:43:54.854]                             break
[17:43:54.854]                           }
[17:43:54.854]                         }
[17:43:54.854]                       }
[17:43:54.854]                       invisible(muffled)
[17:43:54.854]                     }
[17:43:54.854]                     muffleCondition(cond, pattern = "^muffle")
[17:43:54.854]                   }
[17:43:54.854]                 }
[17:43:54.854]             }
[17:43:54.854]         }))
[17:43:54.854]     }, error = function(ex) {
[17:43:54.854]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:54.854]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:54.854]                 ...future.rng), started = ...future.startTime, 
[17:43:54.854]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:54.854]             version = "1.8"), class = "FutureResult")
[17:43:54.854]     }, finally = {
[17:43:54.854]         if (!identical(...future.workdir, getwd())) 
[17:43:54.854]             setwd(...future.workdir)
[17:43:54.854]         {
[17:43:54.854]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:54.854]                 ...future.oldOptions$nwarnings <- NULL
[17:43:54.854]             }
[17:43:54.854]             base::options(...future.oldOptions)
[17:43:54.854]             if (.Platform$OS.type == "windows") {
[17:43:54.854]                 old_names <- names(...future.oldEnvVars)
[17:43:54.854]                 envs <- base::Sys.getenv()
[17:43:54.854]                 names <- names(envs)
[17:43:54.854]                 common <- intersect(names, old_names)
[17:43:54.854]                 added <- setdiff(names, old_names)
[17:43:54.854]                 removed <- setdiff(old_names, names)
[17:43:54.854]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:54.854]                   envs[common]]
[17:43:54.854]                 NAMES <- toupper(changed)
[17:43:54.854]                 args <- list()
[17:43:54.854]                 for (kk in seq_along(NAMES)) {
[17:43:54.854]                   name <- changed[[kk]]
[17:43:54.854]                   NAME <- NAMES[[kk]]
[17:43:54.854]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:54.854]                     next
[17:43:54.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:54.854]                 }
[17:43:54.854]                 NAMES <- toupper(added)
[17:43:54.854]                 for (kk in seq_along(NAMES)) {
[17:43:54.854]                   name <- added[[kk]]
[17:43:54.854]                   NAME <- NAMES[[kk]]
[17:43:54.854]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:54.854]                     next
[17:43:54.854]                   args[[name]] <- ""
[17:43:54.854]                 }
[17:43:54.854]                 NAMES <- toupper(removed)
[17:43:54.854]                 for (kk in seq_along(NAMES)) {
[17:43:54.854]                   name <- removed[[kk]]
[17:43:54.854]                   NAME <- NAMES[[kk]]
[17:43:54.854]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:54.854]                     next
[17:43:54.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:54.854]                 }
[17:43:54.854]                 if (length(args) > 0) 
[17:43:54.854]                   base::do.call(base::Sys.setenv, args = args)
[17:43:54.854]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:54.854]             }
[17:43:54.854]             else {
[17:43:54.854]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:54.854]             }
[17:43:54.854]             {
[17:43:54.854]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:54.854]                   0L) {
[17:43:54.854]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:54.854]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:54.854]                   base::options(opts)
[17:43:54.854]                 }
[17:43:54.854]                 {
[17:43:54.854]                   {
[17:43:54.854]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:54.854]                     NULL
[17:43:54.854]                   }
[17:43:54.854]                   options(future.plan = NULL)
[17:43:54.854]                   if (is.na(NA_character_)) 
[17:43:54.854]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:54.854]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:54.854]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:54.854]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:54.854]                     envir = parent.frame()) 
[17:43:54.854]                   {
[17:43:54.854]                     if (is.function(workers)) 
[17:43:54.854]                       workers <- workers()
[17:43:54.854]                     workers <- structure(as.integer(workers), 
[17:43:54.854]                       class = class(workers))
[17:43:54.854]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:54.854]                       workers >= 1)
[17:43:54.854]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:54.854]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:54.854]                     }
[17:43:54.854]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:54.854]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:54.854]                       envir = envir)
[17:43:54.854]                     if (!future$lazy) 
[17:43:54.854]                       future <- run(future)
[17:43:54.854]                     invisible(future)
[17:43:54.854]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:54.854]                 }
[17:43:54.854]             }
[17:43:54.854]         }
[17:43:54.854]     })
[17:43:54.854]     if (TRUE) {
[17:43:54.854]         base::sink(type = "output", split = FALSE)
[17:43:54.854]         if (TRUE) {
[17:43:54.854]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:54.854]         }
[17:43:54.854]         else {
[17:43:54.854]             ...future.result["stdout"] <- base::list(NULL)
[17:43:54.854]         }
[17:43:54.854]         base::close(...future.stdout)
[17:43:54.854]         ...future.stdout <- NULL
[17:43:54.854]     }
[17:43:54.854]     ...future.result$conditions <- ...future.conditions
[17:43:54.854]     ...future.result$finished <- base::Sys.time()
[17:43:54.854]     ...future.result
[17:43:54.854] }
[17:43:54.857] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[17:43:54.857] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[17:43:54.858] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[17:43:54.858] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[17:43:54.858] MultisessionFuture started
[17:43:54.858] - Launch lazy future ... done
[17:43:54.859] run() for ‘MultisessionFuture’ ... done
[17:43:54.869] run() for ‘Future’ ...
[17:43:54.869] - state: ‘created’
[17:43:54.870] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:54.884] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:54.884] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:54.884]   - Field: ‘node’
[17:43:54.885]   - Field: ‘label’
[17:43:54.885]   - Field: ‘local’
[17:43:54.885]   - Field: ‘owner’
[17:43:54.885]   - Field: ‘envir’
[17:43:54.885]   - Field: ‘workers’
[17:43:54.885]   - Field: ‘packages’
[17:43:54.885]   - Field: ‘gc’
[17:43:54.885]   - Field: ‘conditions’
[17:43:54.885]   - Field: ‘persistent’
[17:43:54.885]   - Field: ‘expr’
[17:43:54.885]   - Field: ‘uuid’
[17:43:54.886]   - Field: ‘seed’
[17:43:54.886]   - Field: ‘version’
[17:43:54.886]   - Field: ‘result’
[17:43:54.886]   - Field: ‘asynchronous’
[17:43:54.886]   - Field: ‘calls’
[17:43:54.886]   - Field: ‘globals’
[17:43:54.886]   - Field: ‘stdout’
[17:43:54.886]   - Field: ‘earlySignal’
[17:43:54.886]   - Field: ‘lazy’
[17:43:54.886]   - Field: ‘state’
[17:43:54.886] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:54.887] - Launch lazy future ...
[17:43:54.887] Packages needed by the future expression (n = 0): <none>
[17:43:54.887] Packages needed by future strategies (n = 0): <none>
[17:43:54.887] {
[17:43:54.887]     {
[17:43:54.887]         {
[17:43:54.887]             ...future.startTime <- base::Sys.time()
[17:43:54.887]             {
[17:43:54.887]                 {
[17:43:54.887]                   {
[17:43:54.887]                     {
[17:43:54.887]                       base::local({
[17:43:54.887]                         has_future <- base::requireNamespace("future", 
[17:43:54.887]                           quietly = TRUE)
[17:43:54.887]                         if (has_future) {
[17:43:54.887]                           ns <- base::getNamespace("future")
[17:43:54.887]                           version <- ns[[".package"]][["version"]]
[17:43:54.887]                           if (is.null(version)) 
[17:43:54.887]                             version <- utils::packageVersion("future")
[17:43:54.887]                         }
[17:43:54.887]                         else {
[17:43:54.887]                           version <- NULL
[17:43:54.887]                         }
[17:43:54.887]                         if (!has_future || version < "1.8.0") {
[17:43:54.887]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:54.887]                             "", base::R.version$version.string), 
[17:43:54.887]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:54.887]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:54.887]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:54.887]                               "release", "version")], collapse = " "), 
[17:43:54.887]                             hostname = base::Sys.info()[["nodename"]])
[17:43:54.887]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:54.887]                             info)
[17:43:54.887]                           info <- base::paste(info, collapse = "; ")
[17:43:54.887]                           if (!has_future) {
[17:43:54.887]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:54.887]                               info)
[17:43:54.887]                           }
[17:43:54.887]                           else {
[17:43:54.887]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:54.887]                               info, version)
[17:43:54.887]                           }
[17:43:54.887]                           base::stop(msg)
[17:43:54.887]                         }
[17:43:54.887]                       })
[17:43:54.887]                     }
[17:43:54.887]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:54.887]                     base::options(mc.cores = 1L)
[17:43:54.887]                   }
[17:43:54.887]                   options(future.plan = NULL)
[17:43:54.887]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:54.887]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:54.887]                 }
[17:43:54.887]                 ...future.workdir <- getwd()
[17:43:54.887]             }
[17:43:54.887]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:54.887]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:54.887]         }
[17:43:54.887]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:54.887]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:54.887]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:54.887]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:54.887]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:54.887]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:54.887]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:54.887]             base::names(...future.oldOptions))
[17:43:54.887]     }
[17:43:54.887]     if (FALSE) {
[17:43:54.887]     }
[17:43:54.887]     else {
[17:43:54.887]         if (TRUE) {
[17:43:54.887]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:54.887]                 open = "w")
[17:43:54.887]         }
[17:43:54.887]         else {
[17:43:54.887]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:54.887]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:54.887]         }
[17:43:54.887]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:54.887]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:54.887]             base::sink(type = "output", split = FALSE)
[17:43:54.887]             base::close(...future.stdout)
[17:43:54.887]         }, add = TRUE)
[17:43:54.887]     }
[17:43:54.887]     ...future.frame <- base::sys.nframe()
[17:43:54.887]     ...future.conditions <- base::list()
[17:43:54.887]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:54.887]     if (FALSE) {
[17:43:54.887]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:54.887]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:54.887]     }
[17:43:54.887]     ...future.result <- base::tryCatch({
[17:43:54.887]         base::withCallingHandlers({
[17:43:54.887]             ...future.value <- base::withVisible(base::local({
[17:43:54.887]                 ...future.makeSendCondition <- local({
[17:43:54.887]                   sendCondition <- NULL
[17:43:54.887]                   function(frame = 1L) {
[17:43:54.887]                     if (is.function(sendCondition)) 
[17:43:54.887]                       return(sendCondition)
[17:43:54.887]                     ns <- getNamespace("parallel")
[17:43:54.887]                     if (exists("sendData", mode = "function", 
[17:43:54.887]                       envir = ns)) {
[17:43:54.887]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:54.887]                         envir = ns)
[17:43:54.887]                       envir <- sys.frame(frame)
[17:43:54.887]                       master <- NULL
[17:43:54.887]                       while (!identical(envir, .GlobalEnv) && 
[17:43:54.887]                         !identical(envir, emptyenv())) {
[17:43:54.887]                         if (exists("master", mode = "list", envir = envir, 
[17:43:54.887]                           inherits = FALSE)) {
[17:43:54.887]                           master <- get("master", mode = "list", 
[17:43:54.887]                             envir = envir, inherits = FALSE)
[17:43:54.887]                           if (inherits(master, c("SOCKnode", 
[17:43:54.887]                             "SOCK0node"))) {
[17:43:54.887]                             sendCondition <<- function(cond) {
[17:43:54.887]                               data <- list(type = "VALUE", value = cond, 
[17:43:54.887]                                 success = TRUE)
[17:43:54.887]                               parallel_sendData(master, data)
[17:43:54.887]                             }
[17:43:54.887]                             return(sendCondition)
[17:43:54.887]                           }
[17:43:54.887]                         }
[17:43:54.887]                         frame <- frame + 1L
[17:43:54.887]                         envir <- sys.frame(frame)
[17:43:54.887]                       }
[17:43:54.887]                     }
[17:43:54.887]                     sendCondition <<- function(cond) NULL
[17:43:54.887]                   }
[17:43:54.887]                 })
[17:43:54.887]                 withCallingHandlers({
[17:43:54.887]                   {
[17:43:54.887]                     Sys.sleep(0.1)
[17:43:54.887]                     kk
[17:43:54.887]                   }
[17:43:54.887]                 }, immediateCondition = function(cond) {
[17:43:54.887]                   sendCondition <- ...future.makeSendCondition()
[17:43:54.887]                   sendCondition(cond)
[17:43:54.887]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:54.887]                   {
[17:43:54.887]                     inherits <- base::inherits
[17:43:54.887]                     invokeRestart <- base::invokeRestart
[17:43:54.887]                     is.null <- base::is.null
[17:43:54.887]                     muffled <- FALSE
[17:43:54.887]                     if (inherits(cond, "message")) {
[17:43:54.887]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:54.887]                       if (muffled) 
[17:43:54.887]                         invokeRestart("muffleMessage")
[17:43:54.887]                     }
[17:43:54.887]                     else if (inherits(cond, "warning")) {
[17:43:54.887]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:54.887]                       if (muffled) 
[17:43:54.887]                         invokeRestart("muffleWarning")
[17:43:54.887]                     }
[17:43:54.887]                     else if (inherits(cond, "condition")) {
[17:43:54.887]                       if (!is.null(pattern)) {
[17:43:54.887]                         computeRestarts <- base::computeRestarts
[17:43:54.887]                         grepl <- base::grepl
[17:43:54.887]                         restarts <- computeRestarts(cond)
[17:43:54.887]                         for (restart in restarts) {
[17:43:54.887]                           name <- restart$name
[17:43:54.887]                           if (is.null(name)) 
[17:43:54.887]                             next
[17:43:54.887]                           if (!grepl(pattern, name)) 
[17:43:54.887]                             next
[17:43:54.887]                           invokeRestart(restart)
[17:43:54.887]                           muffled <- TRUE
[17:43:54.887]                           break
[17:43:54.887]                         }
[17:43:54.887]                       }
[17:43:54.887]                     }
[17:43:54.887]                     invisible(muffled)
[17:43:54.887]                   }
[17:43:54.887]                   muffleCondition(cond)
[17:43:54.887]                 })
[17:43:54.887]             }))
[17:43:54.887]             future::FutureResult(value = ...future.value$value, 
[17:43:54.887]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:54.887]                   ...future.rng), globalenv = if (FALSE) 
[17:43:54.887]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:54.887]                     ...future.globalenv.names))
[17:43:54.887]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:54.887]         }, condition = base::local({
[17:43:54.887]             c <- base::c
[17:43:54.887]             inherits <- base::inherits
[17:43:54.887]             invokeRestart <- base::invokeRestart
[17:43:54.887]             length <- base::length
[17:43:54.887]             list <- base::list
[17:43:54.887]             seq.int <- base::seq.int
[17:43:54.887]             signalCondition <- base::signalCondition
[17:43:54.887]             sys.calls <- base::sys.calls
[17:43:54.887]             `[[` <- base::`[[`
[17:43:54.887]             `+` <- base::`+`
[17:43:54.887]             `<<-` <- base::`<<-`
[17:43:54.887]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:54.887]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:54.887]                   3L)]
[17:43:54.887]             }
[17:43:54.887]             function(cond) {
[17:43:54.887]                 is_error <- inherits(cond, "error")
[17:43:54.887]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:54.887]                   NULL)
[17:43:54.887]                 if (is_error) {
[17:43:54.887]                   sessionInformation <- function() {
[17:43:54.887]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:54.887]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:54.887]                       search = base::search(), system = base::Sys.info())
[17:43:54.887]                   }
[17:43:54.887]                   ...future.conditions[[length(...future.conditions) + 
[17:43:54.887]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:54.887]                     cond$call), session = sessionInformation(), 
[17:43:54.887]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:54.887]                   signalCondition(cond)
[17:43:54.887]                 }
[17:43:54.887]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:54.887]                 "immediateCondition"))) {
[17:43:54.887]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:54.887]                   ...future.conditions[[length(...future.conditions) + 
[17:43:54.887]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:54.887]                   if (TRUE && !signal) {
[17:43:54.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:54.887]                     {
[17:43:54.887]                       inherits <- base::inherits
[17:43:54.887]                       invokeRestart <- base::invokeRestart
[17:43:54.887]                       is.null <- base::is.null
[17:43:54.887]                       muffled <- FALSE
[17:43:54.887]                       if (inherits(cond, "message")) {
[17:43:54.887]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:54.887]                         if (muffled) 
[17:43:54.887]                           invokeRestart("muffleMessage")
[17:43:54.887]                       }
[17:43:54.887]                       else if (inherits(cond, "warning")) {
[17:43:54.887]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:54.887]                         if (muffled) 
[17:43:54.887]                           invokeRestart("muffleWarning")
[17:43:54.887]                       }
[17:43:54.887]                       else if (inherits(cond, "condition")) {
[17:43:54.887]                         if (!is.null(pattern)) {
[17:43:54.887]                           computeRestarts <- base::computeRestarts
[17:43:54.887]                           grepl <- base::grepl
[17:43:54.887]                           restarts <- computeRestarts(cond)
[17:43:54.887]                           for (restart in restarts) {
[17:43:54.887]                             name <- restart$name
[17:43:54.887]                             if (is.null(name)) 
[17:43:54.887]                               next
[17:43:54.887]                             if (!grepl(pattern, name)) 
[17:43:54.887]                               next
[17:43:54.887]                             invokeRestart(restart)
[17:43:54.887]                             muffled <- TRUE
[17:43:54.887]                             break
[17:43:54.887]                           }
[17:43:54.887]                         }
[17:43:54.887]                       }
[17:43:54.887]                       invisible(muffled)
[17:43:54.887]                     }
[17:43:54.887]                     muffleCondition(cond, pattern = "^muffle")
[17:43:54.887]                   }
[17:43:54.887]                 }
[17:43:54.887]                 else {
[17:43:54.887]                   if (TRUE) {
[17:43:54.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:54.887]                     {
[17:43:54.887]                       inherits <- base::inherits
[17:43:54.887]                       invokeRestart <- base::invokeRestart
[17:43:54.887]                       is.null <- base::is.null
[17:43:54.887]                       muffled <- FALSE
[17:43:54.887]                       if (inherits(cond, "message")) {
[17:43:54.887]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:54.887]                         if (muffled) 
[17:43:54.887]                           invokeRestart("muffleMessage")
[17:43:54.887]                       }
[17:43:54.887]                       else if (inherits(cond, "warning")) {
[17:43:54.887]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:54.887]                         if (muffled) 
[17:43:54.887]                           invokeRestart("muffleWarning")
[17:43:54.887]                       }
[17:43:54.887]                       else if (inherits(cond, "condition")) {
[17:43:54.887]                         if (!is.null(pattern)) {
[17:43:54.887]                           computeRestarts <- base::computeRestarts
[17:43:54.887]                           grepl <- base::grepl
[17:43:54.887]                           restarts <- computeRestarts(cond)
[17:43:54.887]                           for (restart in restarts) {
[17:43:54.887]                             name <- restart$name
[17:43:54.887]                             if (is.null(name)) 
[17:43:54.887]                               next
[17:43:54.887]                             if (!grepl(pattern, name)) 
[17:43:54.887]                               next
[17:43:54.887]                             invokeRestart(restart)
[17:43:54.887]                             muffled <- TRUE
[17:43:54.887]                             break
[17:43:54.887]                           }
[17:43:54.887]                         }
[17:43:54.887]                       }
[17:43:54.887]                       invisible(muffled)
[17:43:54.887]                     }
[17:43:54.887]                     muffleCondition(cond, pattern = "^muffle")
[17:43:54.887]                   }
[17:43:54.887]                 }
[17:43:54.887]             }
[17:43:54.887]         }))
[17:43:54.887]     }, error = function(ex) {
[17:43:54.887]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:54.887]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:54.887]                 ...future.rng), started = ...future.startTime, 
[17:43:54.887]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:54.887]             version = "1.8"), class = "FutureResult")
[17:43:54.887]     }, finally = {
[17:43:54.887]         if (!identical(...future.workdir, getwd())) 
[17:43:54.887]             setwd(...future.workdir)
[17:43:54.887]         {
[17:43:54.887]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:54.887]                 ...future.oldOptions$nwarnings <- NULL
[17:43:54.887]             }
[17:43:54.887]             base::options(...future.oldOptions)
[17:43:54.887]             if (.Platform$OS.type == "windows") {
[17:43:54.887]                 old_names <- names(...future.oldEnvVars)
[17:43:54.887]                 envs <- base::Sys.getenv()
[17:43:54.887]                 names <- names(envs)
[17:43:54.887]                 common <- intersect(names, old_names)
[17:43:54.887]                 added <- setdiff(names, old_names)
[17:43:54.887]                 removed <- setdiff(old_names, names)
[17:43:54.887]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:54.887]                   envs[common]]
[17:43:54.887]                 NAMES <- toupper(changed)
[17:43:54.887]                 args <- list()
[17:43:54.887]                 for (kk in seq_along(NAMES)) {
[17:43:54.887]                   name <- changed[[kk]]
[17:43:54.887]                   NAME <- NAMES[[kk]]
[17:43:54.887]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:54.887]                     next
[17:43:54.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:54.887]                 }
[17:43:54.887]                 NAMES <- toupper(added)
[17:43:54.887]                 for (kk in seq_along(NAMES)) {
[17:43:54.887]                   name <- added[[kk]]
[17:43:54.887]                   NAME <- NAMES[[kk]]
[17:43:54.887]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:54.887]                     next
[17:43:54.887]                   args[[name]] <- ""
[17:43:54.887]                 }
[17:43:54.887]                 NAMES <- toupper(removed)
[17:43:54.887]                 for (kk in seq_along(NAMES)) {
[17:43:54.887]                   name <- removed[[kk]]
[17:43:54.887]                   NAME <- NAMES[[kk]]
[17:43:54.887]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:54.887]                     next
[17:43:54.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:54.887]                 }
[17:43:54.887]                 if (length(args) > 0) 
[17:43:54.887]                   base::do.call(base::Sys.setenv, args = args)
[17:43:54.887]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:54.887]             }
[17:43:54.887]             else {
[17:43:54.887]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:54.887]             }
[17:43:54.887]             {
[17:43:54.887]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:54.887]                   0L) {
[17:43:54.887]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:54.887]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:54.887]                   base::options(opts)
[17:43:54.887]                 }
[17:43:54.887]                 {
[17:43:54.887]                   {
[17:43:54.887]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:54.887]                     NULL
[17:43:54.887]                   }
[17:43:54.887]                   options(future.plan = NULL)
[17:43:54.887]                   if (is.na(NA_character_)) 
[17:43:54.887]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:54.887]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:54.887]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:54.887]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:54.887]                     envir = parent.frame()) 
[17:43:54.887]                   {
[17:43:54.887]                     if (is.function(workers)) 
[17:43:54.887]                       workers <- workers()
[17:43:54.887]                     workers <- structure(as.integer(workers), 
[17:43:54.887]                       class = class(workers))
[17:43:54.887]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:54.887]                       workers >= 1)
[17:43:54.887]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:54.887]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:54.887]                     }
[17:43:54.887]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:54.887]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:54.887]                       envir = envir)
[17:43:54.887]                     if (!future$lazy) 
[17:43:54.887]                       future <- run(future)
[17:43:54.887]                     invisible(future)
[17:43:54.887]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:54.887]                 }
[17:43:54.887]             }
[17:43:54.887]         }
[17:43:54.887]     })
[17:43:54.887]     if (TRUE) {
[17:43:54.887]         base::sink(type = "output", split = FALSE)
[17:43:54.887]         if (TRUE) {
[17:43:54.887]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:54.887]         }
[17:43:54.887]         else {
[17:43:54.887]             ...future.result["stdout"] <- base::list(NULL)
[17:43:54.887]         }
[17:43:54.887]         base::close(...future.stdout)
[17:43:54.887]         ...future.stdout <- NULL
[17:43:54.887]     }
[17:43:54.887]     ...future.result$conditions <- ...future.conditions
[17:43:54.887]     ...future.result$finished <- base::Sys.time()
[17:43:54.887]     ...future.result
[17:43:54.887] }
[17:43:54.890] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[17:43:54.890] Exporting ‘kk’ (56 bytes) to cluster node #2 ...
[17:43:54.891] Exporting ‘kk’ (56 bytes) to cluster node #2 ... DONE
[17:43:54.891] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[17:43:54.891] MultisessionFuture started
[17:43:54.892] - Launch lazy future ... done
[17:43:54.892] run() for ‘MultisessionFuture’ ... done
[17:43:54.902] run() for ‘Future’ ...
[17:43:54.903] - state: ‘created’
[17:43:54.903] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:54.917] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:54.917] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:54.918]   - Field: ‘node’
[17:43:54.918]   - Field: ‘label’
[17:43:54.918]   - Field: ‘local’
[17:43:54.918]   - Field: ‘owner’
[17:43:54.918]   - Field: ‘envir’
[17:43:54.918]   - Field: ‘workers’
[17:43:54.918]   - Field: ‘packages’
[17:43:54.918]   - Field: ‘gc’
[17:43:54.918]   - Field: ‘conditions’
[17:43:54.918]   - Field: ‘persistent’
[17:43:54.919]   - Field: ‘expr’
[17:43:54.919]   - Field: ‘uuid’
[17:43:54.919]   - Field: ‘seed’
[17:43:54.919]   - Field: ‘version’
[17:43:54.919]   - Field: ‘result’
[17:43:54.919]   - Field: ‘asynchronous’
[17:43:54.919]   - Field: ‘calls’
[17:43:54.919]   - Field: ‘globals’
[17:43:54.919]   - Field: ‘stdout’
[17:43:54.919]   - Field: ‘earlySignal’
[17:43:54.920]   - Field: ‘lazy’
[17:43:54.920]   - Field: ‘state’
[17:43:54.920] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:54.920] - Launch lazy future ...
[17:43:54.920] Packages needed by the future expression (n = 0): <none>
[17:43:54.920] Packages needed by future strategies (n = 0): <none>
[17:43:54.921] {
[17:43:54.921]     {
[17:43:54.921]         {
[17:43:54.921]             ...future.startTime <- base::Sys.time()
[17:43:54.921]             {
[17:43:54.921]                 {
[17:43:54.921]                   {
[17:43:54.921]                     {
[17:43:54.921]                       base::local({
[17:43:54.921]                         has_future <- base::requireNamespace("future", 
[17:43:54.921]                           quietly = TRUE)
[17:43:54.921]                         if (has_future) {
[17:43:54.921]                           ns <- base::getNamespace("future")
[17:43:54.921]                           version <- ns[[".package"]][["version"]]
[17:43:54.921]                           if (is.null(version)) 
[17:43:54.921]                             version <- utils::packageVersion("future")
[17:43:54.921]                         }
[17:43:54.921]                         else {
[17:43:54.921]                           version <- NULL
[17:43:54.921]                         }
[17:43:54.921]                         if (!has_future || version < "1.8.0") {
[17:43:54.921]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:54.921]                             "", base::R.version$version.string), 
[17:43:54.921]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:54.921]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:54.921]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:54.921]                               "release", "version")], collapse = " "), 
[17:43:54.921]                             hostname = base::Sys.info()[["nodename"]])
[17:43:54.921]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:54.921]                             info)
[17:43:54.921]                           info <- base::paste(info, collapse = "; ")
[17:43:54.921]                           if (!has_future) {
[17:43:54.921]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:54.921]                               info)
[17:43:54.921]                           }
[17:43:54.921]                           else {
[17:43:54.921]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:54.921]                               info, version)
[17:43:54.921]                           }
[17:43:54.921]                           base::stop(msg)
[17:43:54.921]                         }
[17:43:54.921]                       })
[17:43:54.921]                     }
[17:43:54.921]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:54.921]                     base::options(mc.cores = 1L)
[17:43:54.921]                   }
[17:43:54.921]                   options(future.plan = NULL)
[17:43:54.921]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:54.921]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:54.921]                 }
[17:43:54.921]                 ...future.workdir <- getwd()
[17:43:54.921]             }
[17:43:54.921]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:54.921]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:54.921]         }
[17:43:54.921]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:54.921]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:54.921]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:54.921]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:54.921]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:54.921]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:54.921]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:54.921]             base::names(...future.oldOptions))
[17:43:54.921]     }
[17:43:54.921]     if (FALSE) {
[17:43:54.921]     }
[17:43:54.921]     else {
[17:43:54.921]         if (TRUE) {
[17:43:54.921]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:54.921]                 open = "w")
[17:43:54.921]         }
[17:43:54.921]         else {
[17:43:54.921]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:54.921]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:54.921]         }
[17:43:54.921]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:54.921]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:54.921]             base::sink(type = "output", split = FALSE)
[17:43:54.921]             base::close(...future.stdout)
[17:43:54.921]         }, add = TRUE)
[17:43:54.921]     }
[17:43:54.921]     ...future.frame <- base::sys.nframe()
[17:43:54.921]     ...future.conditions <- base::list()
[17:43:54.921]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:54.921]     if (FALSE) {
[17:43:54.921]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:54.921]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:54.921]     }
[17:43:54.921]     ...future.result <- base::tryCatch({
[17:43:54.921]         base::withCallingHandlers({
[17:43:54.921]             ...future.value <- base::withVisible(base::local({
[17:43:54.921]                 ...future.makeSendCondition <- local({
[17:43:54.921]                   sendCondition <- NULL
[17:43:54.921]                   function(frame = 1L) {
[17:43:54.921]                     if (is.function(sendCondition)) 
[17:43:54.921]                       return(sendCondition)
[17:43:54.921]                     ns <- getNamespace("parallel")
[17:43:54.921]                     if (exists("sendData", mode = "function", 
[17:43:54.921]                       envir = ns)) {
[17:43:54.921]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:54.921]                         envir = ns)
[17:43:54.921]                       envir <- sys.frame(frame)
[17:43:54.921]                       master <- NULL
[17:43:54.921]                       while (!identical(envir, .GlobalEnv) && 
[17:43:54.921]                         !identical(envir, emptyenv())) {
[17:43:54.921]                         if (exists("master", mode = "list", envir = envir, 
[17:43:54.921]                           inherits = FALSE)) {
[17:43:54.921]                           master <- get("master", mode = "list", 
[17:43:54.921]                             envir = envir, inherits = FALSE)
[17:43:54.921]                           if (inherits(master, c("SOCKnode", 
[17:43:54.921]                             "SOCK0node"))) {
[17:43:54.921]                             sendCondition <<- function(cond) {
[17:43:54.921]                               data <- list(type = "VALUE", value = cond, 
[17:43:54.921]                                 success = TRUE)
[17:43:54.921]                               parallel_sendData(master, data)
[17:43:54.921]                             }
[17:43:54.921]                             return(sendCondition)
[17:43:54.921]                           }
[17:43:54.921]                         }
[17:43:54.921]                         frame <- frame + 1L
[17:43:54.921]                         envir <- sys.frame(frame)
[17:43:54.921]                       }
[17:43:54.921]                     }
[17:43:54.921]                     sendCondition <<- function(cond) NULL
[17:43:54.921]                   }
[17:43:54.921]                 })
[17:43:54.921]                 withCallingHandlers({
[17:43:54.921]                   {
[17:43:54.921]                     Sys.sleep(0.1)
[17:43:54.921]                     kk
[17:43:54.921]                   }
[17:43:54.921]                 }, immediateCondition = function(cond) {
[17:43:54.921]                   sendCondition <- ...future.makeSendCondition()
[17:43:54.921]                   sendCondition(cond)
[17:43:54.921]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:54.921]                   {
[17:43:54.921]                     inherits <- base::inherits
[17:43:54.921]                     invokeRestart <- base::invokeRestart
[17:43:54.921]                     is.null <- base::is.null
[17:43:54.921]                     muffled <- FALSE
[17:43:54.921]                     if (inherits(cond, "message")) {
[17:43:54.921]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:54.921]                       if (muffled) 
[17:43:54.921]                         invokeRestart("muffleMessage")
[17:43:54.921]                     }
[17:43:54.921]                     else if (inherits(cond, "warning")) {
[17:43:54.921]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:54.921]                       if (muffled) 
[17:43:54.921]                         invokeRestart("muffleWarning")
[17:43:54.921]                     }
[17:43:54.921]                     else if (inherits(cond, "condition")) {
[17:43:54.921]                       if (!is.null(pattern)) {
[17:43:54.921]                         computeRestarts <- base::computeRestarts
[17:43:54.921]                         grepl <- base::grepl
[17:43:54.921]                         restarts <- computeRestarts(cond)
[17:43:54.921]                         for (restart in restarts) {
[17:43:54.921]                           name <- restart$name
[17:43:54.921]                           if (is.null(name)) 
[17:43:54.921]                             next
[17:43:54.921]                           if (!grepl(pattern, name)) 
[17:43:54.921]                             next
[17:43:54.921]                           invokeRestart(restart)
[17:43:54.921]                           muffled <- TRUE
[17:43:54.921]                           break
[17:43:54.921]                         }
[17:43:54.921]                       }
[17:43:54.921]                     }
[17:43:54.921]                     invisible(muffled)
[17:43:54.921]                   }
[17:43:54.921]                   muffleCondition(cond)
[17:43:54.921]                 })
[17:43:54.921]             }))
[17:43:54.921]             future::FutureResult(value = ...future.value$value, 
[17:43:54.921]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:54.921]                   ...future.rng), globalenv = if (FALSE) 
[17:43:54.921]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:54.921]                     ...future.globalenv.names))
[17:43:54.921]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:54.921]         }, condition = base::local({
[17:43:54.921]             c <- base::c
[17:43:54.921]             inherits <- base::inherits
[17:43:54.921]             invokeRestart <- base::invokeRestart
[17:43:54.921]             length <- base::length
[17:43:54.921]             list <- base::list
[17:43:54.921]             seq.int <- base::seq.int
[17:43:54.921]             signalCondition <- base::signalCondition
[17:43:54.921]             sys.calls <- base::sys.calls
[17:43:54.921]             `[[` <- base::`[[`
[17:43:54.921]             `+` <- base::`+`
[17:43:54.921]             `<<-` <- base::`<<-`
[17:43:54.921]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:54.921]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:54.921]                   3L)]
[17:43:54.921]             }
[17:43:54.921]             function(cond) {
[17:43:54.921]                 is_error <- inherits(cond, "error")
[17:43:54.921]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:54.921]                   NULL)
[17:43:54.921]                 if (is_error) {
[17:43:54.921]                   sessionInformation <- function() {
[17:43:54.921]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:54.921]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:54.921]                       search = base::search(), system = base::Sys.info())
[17:43:54.921]                   }
[17:43:54.921]                   ...future.conditions[[length(...future.conditions) + 
[17:43:54.921]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:54.921]                     cond$call), session = sessionInformation(), 
[17:43:54.921]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:54.921]                   signalCondition(cond)
[17:43:54.921]                 }
[17:43:54.921]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:54.921]                 "immediateCondition"))) {
[17:43:54.921]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:54.921]                   ...future.conditions[[length(...future.conditions) + 
[17:43:54.921]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:54.921]                   if (TRUE && !signal) {
[17:43:54.921]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:54.921]                     {
[17:43:54.921]                       inherits <- base::inherits
[17:43:54.921]                       invokeRestart <- base::invokeRestart
[17:43:54.921]                       is.null <- base::is.null
[17:43:54.921]                       muffled <- FALSE
[17:43:54.921]                       if (inherits(cond, "message")) {
[17:43:54.921]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:54.921]                         if (muffled) 
[17:43:54.921]                           invokeRestart("muffleMessage")
[17:43:54.921]                       }
[17:43:54.921]                       else if (inherits(cond, "warning")) {
[17:43:54.921]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:54.921]                         if (muffled) 
[17:43:54.921]                           invokeRestart("muffleWarning")
[17:43:54.921]                       }
[17:43:54.921]                       else if (inherits(cond, "condition")) {
[17:43:54.921]                         if (!is.null(pattern)) {
[17:43:54.921]                           computeRestarts <- base::computeRestarts
[17:43:54.921]                           grepl <- base::grepl
[17:43:54.921]                           restarts <- computeRestarts(cond)
[17:43:54.921]                           for (restart in restarts) {
[17:43:54.921]                             name <- restart$name
[17:43:54.921]                             if (is.null(name)) 
[17:43:54.921]                               next
[17:43:54.921]                             if (!grepl(pattern, name)) 
[17:43:54.921]                               next
[17:43:54.921]                             invokeRestart(restart)
[17:43:54.921]                             muffled <- TRUE
[17:43:54.921]                             break
[17:43:54.921]                           }
[17:43:54.921]                         }
[17:43:54.921]                       }
[17:43:54.921]                       invisible(muffled)
[17:43:54.921]                     }
[17:43:54.921]                     muffleCondition(cond, pattern = "^muffle")
[17:43:54.921]                   }
[17:43:54.921]                 }
[17:43:54.921]                 else {
[17:43:54.921]                   if (TRUE) {
[17:43:54.921]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:54.921]                     {
[17:43:54.921]                       inherits <- base::inherits
[17:43:54.921]                       invokeRestart <- base::invokeRestart
[17:43:54.921]                       is.null <- base::is.null
[17:43:54.921]                       muffled <- FALSE
[17:43:54.921]                       if (inherits(cond, "message")) {
[17:43:54.921]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:54.921]                         if (muffled) 
[17:43:54.921]                           invokeRestart("muffleMessage")
[17:43:54.921]                       }
[17:43:54.921]                       else if (inherits(cond, "warning")) {
[17:43:54.921]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:54.921]                         if (muffled) 
[17:43:54.921]                           invokeRestart("muffleWarning")
[17:43:54.921]                       }
[17:43:54.921]                       else if (inherits(cond, "condition")) {
[17:43:54.921]                         if (!is.null(pattern)) {
[17:43:54.921]                           computeRestarts <- base::computeRestarts
[17:43:54.921]                           grepl <- base::grepl
[17:43:54.921]                           restarts <- computeRestarts(cond)
[17:43:54.921]                           for (restart in restarts) {
[17:43:54.921]                             name <- restart$name
[17:43:54.921]                             if (is.null(name)) 
[17:43:54.921]                               next
[17:43:54.921]                             if (!grepl(pattern, name)) 
[17:43:54.921]                               next
[17:43:54.921]                             invokeRestart(restart)
[17:43:54.921]                             muffled <- TRUE
[17:43:54.921]                             break
[17:43:54.921]                           }
[17:43:54.921]                         }
[17:43:54.921]                       }
[17:43:54.921]                       invisible(muffled)
[17:43:54.921]                     }
[17:43:54.921]                     muffleCondition(cond, pattern = "^muffle")
[17:43:54.921]                   }
[17:43:54.921]                 }
[17:43:54.921]             }
[17:43:54.921]         }))
[17:43:54.921]     }, error = function(ex) {
[17:43:54.921]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:54.921]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:54.921]                 ...future.rng), started = ...future.startTime, 
[17:43:54.921]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:54.921]             version = "1.8"), class = "FutureResult")
[17:43:54.921]     }, finally = {
[17:43:54.921]         if (!identical(...future.workdir, getwd())) 
[17:43:54.921]             setwd(...future.workdir)
[17:43:54.921]         {
[17:43:54.921]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:54.921]                 ...future.oldOptions$nwarnings <- NULL
[17:43:54.921]             }
[17:43:54.921]             base::options(...future.oldOptions)
[17:43:54.921]             if (.Platform$OS.type == "windows") {
[17:43:54.921]                 old_names <- names(...future.oldEnvVars)
[17:43:54.921]                 envs <- base::Sys.getenv()
[17:43:54.921]                 names <- names(envs)
[17:43:54.921]                 common <- intersect(names, old_names)
[17:43:54.921]                 added <- setdiff(names, old_names)
[17:43:54.921]                 removed <- setdiff(old_names, names)
[17:43:54.921]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:54.921]                   envs[common]]
[17:43:54.921]                 NAMES <- toupper(changed)
[17:43:54.921]                 args <- list()
[17:43:54.921]                 for (kk in seq_along(NAMES)) {
[17:43:54.921]                   name <- changed[[kk]]
[17:43:54.921]                   NAME <- NAMES[[kk]]
[17:43:54.921]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:54.921]                     next
[17:43:54.921]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:54.921]                 }
[17:43:54.921]                 NAMES <- toupper(added)
[17:43:54.921]                 for (kk in seq_along(NAMES)) {
[17:43:54.921]                   name <- added[[kk]]
[17:43:54.921]                   NAME <- NAMES[[kk]]
[17:43:54.921]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:54.921]                     next
[17:43:54.921]                   args[[name]] <- ""
[17:43:54.921]                 }
[17:43:54.921]                 NAMES <- toupper(removed)
[17:43:54.921]                 for (kk in seq_along(NAMES)) {
[17:43:54.921]                   name <- removed[[kk]]
[17:43:54.921]                   NAME <- NAMES[[kk]]
[17:43:54.921]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:54.921]                     next
[17:43:54.921]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:54.921]                 }
[17:43:54.921]                 if (length(args) > 0) 
[17:43:54.921]                   base::do.call(base::Sys.setenv, args = args)
[17:43:54.921]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:54.921]             }
[17:43:54.921]             else {
[17:43:54.921]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:54.921]             }
[17:43:54.921]             {
[17:43:54.921]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:54.921]                   0L) {
[17:43:54.921]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:54.921]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:54.921]                   base::options(opts)
[17:43:54.921]                 }
[17:43:54.921]                 {
[17:43:54.921]                   {
[17:43:54.921]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:54.921]                     NULL
[17:43:54.921]                   }
[17:43:54.921]                   options(future.plan = NULL)
[17:43:54.921]                   if (is.na(NA_character_)) 
[17:43:54.921]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:54.921]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:54.921]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:54.921]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:54.921]                     envir = parent.frame()) 
[17:43:54.921]                   {
[17:43:54.921]                     if (is.function(workers)) 
[17:43:54.921]                       workers <- workers()
[17:43:54.921]                     workers <- structure(as.integer(workers), 
[17:43:54.921]                       class = class(workers))
[17:43:54.921]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:54.921]                       workers >= 1)
[17:43:54.921]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:54.921]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:54.921]                     }
[17:43:54.921]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:54.921]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:54.921]                       envir = envir)
[17:43:54.921]                     if (!future$lazy) 
[17:43:54.921]                       future <- run(future)
[17:43:54.921]                     invisible(future)
[17:43:54.921]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:54.921]                 }
[17:43:54.921]             }
[17:43:54.921]         }
[17:43:54.921]     })
[17:43:54.921]     if (TRUE) {
[17:43:54.921]         base::sink(type = "output", split = FALSE)
[17:43:54.921]         if (TRUE) {
[17:43:54.921]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:54.921]         }
[17:43:54.921]         else {
[17:43:54.921]             ...future.result["stdout"] <- base::list(NULL)
[17:43:54.921]         }
[17:43:54.921]         base::close(...future.stdout)
[17:43:54.921]         ...future.stdout <- NULL
[17:43:54.921]     }
[17:43:54.921]     ...future.result$conditions <- ...future.conditions
[17:43:54.921]     ...future.result$finished <- base::Sys.time()
[17:43:54.921]     ...future.result
[17:43:54.921] }
[17:43:54.923] Poll #1 (0): usedNodes() = 2, workers = 2
[17:43:54.954] Poll #2 (0.03 secs): usedNodes() = 2, workers = 2
[17:43:54.986] Poll #3 (0.06 secs): usedNodes() = 2, workers = 2
[17:43:55.004] receiveMessageFromWorker() for ClusterFuture ...
[17:43:55.005] - Validating connection of MultisessionFuture
[17:43:55.005] - received message: FutureResult
[17:43:55.005] - Received FutureResult
[17:43:55.005] - Erased future from FutureRegistry
[17:43:55.005] result() for ClusterFuture ...
[17:43:55.005] - result already collected: FutureResult
[17:43:55.006] result() for ClusterFuture ... done
[17:43:55.006] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:55.006] result() for ClusterFuture ...
[17:43:55.006] - result already collected: FutureResult
[17:43:55.006] result() for ClusterFuture ... done
[17:43:55.006] result() for ClusterFuture ...
[17:43:55.006] - result already collected: FutureResult
[17:43:55.006] result() for ClusterFuture ... done
[17:43:55.007] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[17:43:55.007] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[17:43:55.008] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[17:43:55.008] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[17:43:55.008] MultisessionFuture started
[17:43:55.008] - Launch lazy future ... done
[17:43:55.008] run() for ‘MultisessionFuture’ ... done
[17:43:55.029] Future #1
[17:43:55.029]  length: 2 (resolved future 1)
[17:43:55.061] receiveMessageFromWorker() for ClusterFuture ...
[17:43:55.061] - Validating connection of MultisessionFuture
[17:43:55.061] - received message: FutureResult
[17:43:55.062] - Received FutureResult
[17:43:55.062] - Erased future from FutureRegistry
[17:43:55.062] result() for ClusterFuture ...
[17:43:55.062] - result already collected: FutureResult
[17:43:55.062] result() for ClusterFuture ... done
[17:43:55.062] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:55.062] Future #2
[17:43:55.062]  length: 1 (resolved future 2)
[17:43:55.166] receiveMessageFromWorker() for ClusterFuture ...
[17:43:55.166] - Validating connection of MultisessionFuture
[17:43:55.167] - received message: FutureResult
[17:43:55.167] - Received FutureResult
[17:43:55.167] - Erased future from FutureRegistry
[17:43:55.167] result() for ClusterFuture ...
[17:43:55.167] - result already collected: FutureResult
[17:43:55.167] result() for ClusterFuture ... done
[17:43:55.167] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:55.167] Future #3
[17:43:55.167]  length: 0 (resolved future 3)
[17:43:55.168] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[17:43:55.168] resolve() on environment ...
[17:43:55.168]  recursive: 0
[17:43:55.169]  elements: [2] ‘a’, ‘b’
[17:43:55.169]  length: 1 (resolved future 1)
[17:43:55.169]  length: 0 (resolved future 2)
[17:43:55.169] resolve() on environment ... DONE
[17:43:55.170] getGlobalsAndPackages() ...
[17:43:55.170] Searching for globals...
[17:43:55.170] 
[17:43:55.170] Searching for globals ... DONE
[17:43:55.170] - globals: [0] <none>
[17:43:55.171] getGlobalsAndPackages() ... DONE
[17:43:55.171] run() for ‘Future’ ...
[17:43:55.171] - state: ‘created’
[17:43:55.171] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:55.194] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:55.194] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:55.194]   - Field: ‘node’
[17:43:55.194]   - Field: ‘label’
[17:43:55.194]   - Field: ‘local’
[17:43:55.195]   - Field: ‘owner’
[17:43:55.195]   - Field: ‘envir’
[17:43:55.195]   - Field: ‘workers’
[17:43:55.195]   - Field: ‘packages’
[17:43:55.195]   - Field: ‘gc’
[17:43:55.195]   - Field: ‘conditions’
[17:43:55.195]   - Field: ‘persistent’
[17:43:55.195]   - Field: ‘expr’
[17:43:55.195]   - Field: ‘uuid’
[17:43:55.195]   - Field: ‘seed’
[17:43:55.196]   - Field: ‘version’
[17:43:55.196]   - Field: ‘result’
[17:43:55.196]   - Field: ‘asynchronous’
[17:43:55.196]   - Field: ‘calls’
[17:43:55.196]   - Field: ‘globals’
[17:43:55.196]   - Field: ‘stdout’
[17:43:55.196]   - Field: ‘earlySignal’
[17:43:55.196]   - Field: ‘lazy’
[17:43:55.196]   - Field: ‘state’
[17:43:55.196] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:55.196] - Launch lazy future ...
[17:43:55.197] Packages needed by the future expression (n = 0): <none>
[17:43:55.197] Packages needed by future strategies (n = 0): <none>
[17:43:55.197] {
[17:43:55.197]     {
[17:43:55.197]         {
[17:43:55.197]             ...future.startTime <- base::Sys.time()
[17:43:55.197]             {
[17:43:55.197]                 {
[17:43:55.197]                   {
[17:43:55.197]                     {
[17:43:55.197]                       base::local({
[17:43:55.197]                         has_future <- base::requireNamespace("future", 
[17:43:55.197]                           quietly = TRUE)
[17:43:55.197]                         if (has_future) {
[17:43:55.197]                           ns <- base::getNamespace("future")
[17:43:55.197]                           version <- ns[[".package"]][["version"]]
[17:43:55.197]                           if (is.null(version)) 
[17:43:55.197]                             version <- utils::packageVersion("future")
[17:43:55.197]                         }
[17:43:55.197]                         else {
[17:43:55.197]                           version <- NULL
[17:43:55.197]                         }
[17:43:55.197]                         if (!has_future || version < "1.8.0") {
[17:43:55.197]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:55.197]                             "", base::R.version$version.string), 
[17:43:55.197]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:55.197]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:55.197]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:55.197]                               "release", "version")], collapse = " "), 
[17:43:55.197]                             hostname = base::Sys.info()[["nodename"]])
[17:43:55.197]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:55.197]                             info)
[17:43:55.197]                           info <- base::paste(info, collapse = "; ")
[17:43:55.197]                           if (!has_future) {
[17:43:55.197]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:55.197]                               info)
[17:43:55.197]                           }
[17:43:55.197]                           else {
[17:43:55.197]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:55.197]                               info, version)
[17:43:55.197]                           }
[17:43:55.197]                           base::stop(msg)
[17:43:55.197]                         }
[17:43:55.197]                       })
[17:43:55.197]                     }
[17:43:55.197]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:55.197]                     base::options(mc.cores = 1L)
[17:43:55.197]                   }
[17:43:55.197]                   options(future.plan = NULL)
[17:43:55.197]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.197]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:55.197]                 }
[17:43:55.197]                 ...future.workdir <- getwd()
[17:43:55.197]             }
[17:43:55.197]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:55.197]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:55.197]         }
[17:43:55.197]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:55.197]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:55.197]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:55.197]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:55.197]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:55.197]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:55.197]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:55.197]             base::names(...future.oldOptions))
[17:43:55.197]     }
[17:43:55.197]     if (FALSE) {
[17:43:55.197]     }
[17:43:55.197]     else {
[17:43:55.197]         if (TRUE) {
[17:43:55.197]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:55.197]                 open = "w")
[17:43:55.197]         }
[17:43:55.197]         else {
[17:43:55.197]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:55.197]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:55.197]         }
[17:43:55.197]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:55.197]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:55.197]             base::sink(type = "output", split = FALSE)
[17:43:55.197]             base::close(...future.stdout)
[17:43:55.197]         }, add = TRUE)
[17:43:55.197]     }
[17:43:55.197]     ...future.frame <- base::sys.nframe()
[17:43:55.197]     ...future.conditions <- base::list()
[17:43:55.197]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:55.197]     if (FALSE) {
[17:43:55.197]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:55.197]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:55.197]     }
[17:43:55.197]     ...future.result <- base::tryCatch({
[17:43:55.197]         base::withCallingHandlers({
[17:43:55.197]             ...future.value <- base::withVisible(base::local({
[17:43:55.197]                 ...future.makeSendCondition <- local({
[17:43:55.197]                   sendCondition <- NULL
[17:43:55.197]                   function(frame = 1L) {
[17:43:55.197]                     if (is.function(sendCondition)) 
[17:43:55.197]                       return(sendCondition)
[17:43:55.197]                     ns <- getNamespace("parallel")
[17:43:55.197]                     if (exists("sendData", mode = "function", 
[17:43:55.197]                       envir = ns)) {
[17:43:55.197]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:55.197]                         envir = ns)
[17:43:55.197]                       envir <- sys.frame(frame)
[17:43:55.197]                       master <- NULL
[17:43:55.197]                       while (!identical(envir, .GlobalEnv) && 
[17:43:55.197]                         !identical(envir, emptyenv())) {
[17:43:55.197]                         if (exists("master", mode = "list", envir = envir, 
[17:43:55.197]                           inherits = FALSE)) {
[17:43:55.197]                           master <- get("master", mode = "list", 
[17:43:55.197]                             envir = envir, inherits = FALSE)
[17:43:55.197]                           if (inherits(master, c("SOCKnode", 
[17:43:55.197]                             "SOCK0node"))) {
[17:43:55.197]                             sendCondition <<- function(cond) {
[17:43:55.197]                               data <- list(type = "VALUE", value = cond, 
[17:43:55.197]                                 success = TRUE)
[17:43:55.197]                               parallel_sendData(master, data)
[17:43:55.197]                             }
[17:43:55.197]                             return(sendCondition)
[17:43:55.197]                           }
[17:43:55.197]                         }
[17:43:55.197]                         frame <- frame + 1L
[17:43:55.197]                         envir <- sys.frame(frame)
[17:43:55.197]                       }
[17:43:55.197]                     }
[17:43:55.197]                     sendCondition <<- function(cond) NULL
[17:43:55.197]                   }
[17:43:55.197]                 })
[17:43:55.197]                 withCallingHandlers({
[17:43:55.197]                   1
[17:43:55.197]                 }, immediateCondition = function(cond) {
[17:43:55.197]                   sendCondition <- ...future.makeSendCondition()
[17:43:55.197]                   sendCondition(cond)
[17:43:55.197]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.197]                   {
[17:43:55.197]                     inherits <- base::inherits
[17:43:55.197]                     invokeRestart <- base::invokeRestart
[17:43:55.197]                     is.null <- base::is.null
[17:43:55.197]                     muffled <- FALSE
[17:43:55.197]                     if (inherits(cond, "message")) {
[17:43:55.197]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:55.197]                       if (muffled) 
[17:43:55.197]                         invokeRestart("muffleMessage")
[17:43:55.197]                     }
[17:43:55.197]                     else if (inherits(cond, "warning")) {
[17:43:55.197]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:55.197]                       if (muffled) 
[17:43:55.197]                         invokeRestart("muffleWarning")
[17:43:55.197]                     }
[17:43:55.197]                     else if (inherits(cond, "condition")) {
[17:43:55.197]                       if (!is.null(pattern)) {
[17:43:55.197]                         computeRestarts <- base::computeRestarts
[17:43:55.197]                         grepl <- base::grepl
[17:43:55.197]                         restarts <- computeRestarts(cond)
[17:43:55.197]                         for (restart in restarts) {
[17:43:55.197]                           name <- restart$name
[17:43:55.197]                           if (is.null(name)) 
[17:43:55.197]                             next
[17:43:55.197]                           if (!grepl(pattern, name)) 
[17:43:55.197]                             next
[17:43:55.197]                           invokeRestart(restart)
[17:43:55.197]                           muffled <- TRUE
[17:43:55.197]                           break
[17:43:55.197]                         }
[17:43:55.197]                       }
[17:43:55.197]                     }
[17:43:55.197]                     invisible(muffled)
[17:43:55.197]                   }
[17:43:55.197]                   muffleCondition(cond)
[17:43:55.197]                 })
[17:43:55.197]             }))
[17:43:55.197]             future::FutureResult(value = ...future.value$value, 
[17:43:55.197]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.197]                   ...future.rng), globalenv = if (FALSE) 
[17:43:55.197]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:55.197]                     ...future.globalenv.names))
[17:43:55.197]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:55.197]         }, condition = base::local({
[17:43:55.197]             c <- base::c
[17:43:55.197]             inherits <- base::inherits
[17:43:55.197]             invokeRestart <- base::invokeRestart
[17:43:55.197]             length <- base::length
[17:43:55.197]             list <- base::list
[17:43:55.197]             seq.int <- base::seq.int
[17:43:55.197]             signalCondition <- base::signalCondition
[17:43:55.197]             sys.calls <- base::sys.calls
[17:43:55.197]             `[[` <- base::`[[`
[17:43:55.197]             `+` <- base::`+`
[17:43:55.197]             `<<-` <- base::`<<-`
[17:43:55.197]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:55.197]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:55.197]                   3L)]
[17:43:55.197]             }
[17:43:55.197]             function(cond) {
[17:43:55.197]                 is_error <- inherits(cond, "error")
[17:43:55.197]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:55.197]                   NULL)
[17:43:55.197]                 if (is_error) {
[17:43:55.197]                   sessionInformation <- function() {
[17:43:55.197]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:55.197]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:55.197]                       search = base::search(), system = base::Sys.info())
[17:43:55.197]                   }
[17:43:55.197]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.197]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:55.197]                     cond$call), session = sessionInformation(), 
[17:43:55.197]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:55.197]                   signalCondition(cond)
[17:43:55.197]                 }
[17:43:55.197]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:55.197]                 "immediateCondition"))) {
[17:43:55.197]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:55.197]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.197]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:55.197]                   if (TRUE && !signal) {
[17:43:55.197]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.197]                     {
[17:43:55.197]                       inherits <- base::inherits
[17:43:55.197]                       invokeRestart <- base::invokeRestart
[17:43:55.197]                       is.null <- base::is.null
[17:43:55.197]                       muffled <- FALSE
[17:43:55.197]                       if (inherits(cond, "message")) {
[17:43:55.197]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.197]                         if (muffled) 
[17:43:55.197]                           invokeRestart("muffleMessage")
[17:43:55.197]                       }
[17:43:55.197]                       else if (inherits(cond, "warning")) {
[17:43:55.197]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.197]                         if (muffled) 
[17:43:55.197]                           invokeRestart("muffleWarning")
[17:43:55.197]                       }
[17:43:55.197]                       else if (inherits(cond, "condition")) {
[17:43:55.197]                         if (!is.null(pattern)) {
[17:43:55.197]                           computeRestarts <- base::computeRestarts
[17:43:55.197]                           grepl <- base::grepl
[17:43:55.197]                           restarts <- computeRestarts(cond)
[17:43:55.197]                           for (restart in restarts) {
[17:43:55.197]                             name <- restart$name
[17:43:55.197]                             if (is.null(name)) 
[17:43:55.197]                               next
[17:43:55.197]                             if (!grepl(pattern, name)) 
[17:43:55.197]                               next
[17:43:55.197]                             invokeRestart(restart)
[17:43:55.197]                             muffled <- TRUE
[17:43:55.197]                             break
[17:43:55.197]                           }
[17:43:55.197]                         }
[17:43:55.197]                       }
[17:43:55.197]                       invisible(muffled)
[17:43:55.197]                     }
[17:43:55.197]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.197]                   }
[17:43:55.197]                 }
[17:43:55.197]                 else {
[17:43:55.197]                   if (TRUE) {
[17:43:55.197]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.197]                     {
[17:43:55.197]                       inherits <- base::inherits
[17:43:55.197]                       invokeRestart <- base::invokeRestart
[17:43:55.197]                       is.null <- base::is.null
[17:43:55.197]                       muffled <- FALSE
[17:43:55.197]                       if (inherits(cond, "message")) {
[17:43:55.197]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.197]                         if (muffled) 
[17:43:55.197]                           invokeRestart("muffleMessage")
[17:43:55.197]                       }
[17:43:55.197]                       else if (inherits(cond, "warning")) {
[17:43:55.197]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.197]                         if (muffled) 
[17:43:55.197]                           invokeRestart("muffleWarning")
[17:43:55.197]                       }
[17:43:55.197]                       else if (inherits(cond, "condition")) {
[17:43:55.197]                         if (!is.null(pattern)) {
[17:43:55.197]                           computeRestarts <- base::computeRestarts
[17:43:55.197]                           grepl <- base::grepl
[17:43:55.197]                           restarts <- computeRestarts(cond)
[17:43:55.197]                           for (restart in restarts) {
[17:43:55.197]                             name <- restart$name
[17:43:55.197]                             if (is.null(name)) 
[17:43:55.197]                               next
[17:43:55.197]                             if (!grepl(pattern, name)) 
[17:43:55.197]                               next
[17:43:55.197]                             invokeRestart(restart)
[17:43:55.197]                             muffled <- TRUE
[17:43:55.197]                             break
[17:43:55.197]                           }
[17:43:55.197]                         }
[17:43:55.197]                       }
[17:43:55.197]                       invisible(muffled)
[17:43:55.197]                     }
[17:43:55.197]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.197]                   }
[17:43:55.197]                 }
[17:43:55.197]             }
[17:43:55.197]         }))
[17:43:55.197]     }, error = function(ex) {
[17:43:55.197]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:55.197]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.197]                 ...future.rng), started = ...future.startTime, 
[17:43:55.197]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:55.197]             version = "1.8"), class = "FutureResult")
[17:43:55.197]     }, finally = {
[17:43:55.197]         if (!identical(...future.workdir, getwd())) 
[17:43:55.197]             setwd(...future.workdir)
[17:43:55.197]         {
[17:43:55.197]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:55.197]                 ...future.oldOptions$nwarnings <- NULL
[17:43:55.197]             }
[17:43:55.197]             base::options(...future.oldOptions)
[17:43:55.197]             if (.Platform$OS.type == "windows") {
[17:43:55.197]                 old_names <- names(...future.oldEnvVars)
[17:43:55.197]                 envs <- base::Sys.getenv()
[17:43:55.197]                 names <- names(envs)
[17:43:55.197]                 common <- intersect(names, old_names)
[17:43:55.197]                 added <- setdiff(names, old_names)
[17:43:55.197]                 removed <- setdiff(old_names, names)
[17:43:55.197]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:55.197]                   envs[common]]
[17:43:55.197]                 NAMES <- toupper(changed)
[17:43:55.197]                 args <- list()
[17:43:55.197]                 for (kk in seq_along(NAMES)) {
[17:43:55.197]                   name <- changed[[kk]]
[17:43:55.197]                   NAME <- NAMES[[kk]]
[17:43:55.197]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.197]                     next
[17:43:55.197]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.197]                 }
[17:43:55.197]                 NAMES <- toupper(added)
[17:43:55.197]                 for (kk in seq_along(NAMES)) {
[17:43:55.197]                   name <- added[[kk]]
[17:43:55.197]                   NAME <- NAMES[[kk]]
[17:43:55.197]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.197]                     next
[17:43:55.197]                   args[[name]] <- ""
[17:43:55.197]                 }
[17:43:55.197]                 NAMES <- toupper(removed)
[17:43:55.197]                 for (kk in seq_along(NAMES)) {
[17:43:55.197]                   name <- removed[[kk]]
[17:43:55.197]                   NAME <- NAMES[[kk]]
[17:43:55.197]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.197]                     next
[17:43:55.197]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.197]                 }
[17:43:55.197]                 if (length(args) > 0) 
[17:43:55.197]                   base::do.call(base::Sys.setenv, args = args)
[17:43:55.197]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:55.197]             }
[17:43:55.197]             else {
[17:43:55.197]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:55.197]             }
[17:43:55.197]             {
[17:43:55.197]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:55.197]                   0L) {
[17:43:55.197]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:55.197]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:55.197]                   base::options(opts)
[17:43:55.197]                 }
[17:43:55.197]                 {
[17:43:55.197]                   {
[17:43:55.197]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:55.197]                     NULL
[17:43:55.197]                   }
[17:43:55.197]                   options(future.plan = NULL)
[17:43:55.197]                   if (is.na(NA_character_)) 
[17:43:55.197]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.197]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:55.197]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:55.197]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:55.197]                     envir = parent.frame()) 
[17:43:55.197]                   {
[17:43:55.197]                     if (is.function(workers)) 
[17:43:55.197]                       workers <- workers()
[17:43:55.197]                     workers <- structure(as.integer(workers), 
[17:43:55.197]                       class = class(workers))
[17:43:55.197]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:55.197]                       workers >= 1)
[17:43:55.197]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:55.197]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:55.197]                     }
[17:43:55.197]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:55.197]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:55.197]                       envir = envir)
[17:43:55.197]                     if (!future$lazy) 
[17:43:55.197]                       future <- run(future)
[17:43:55.197]                     invisible(future)
[17:43:55.197]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:55.197]                 }
[17:43:55.197]             }
[17:43:55.197]         }
[17:43:55.197]     })
[17:43:55.197]     if (TRUE) {
[17:43:55.197]         base::sink(type = "output", split = FALSE)
[17:43:55.197]         if (TRUE) {
[17:43:55.197]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:55.197]         }
[17:43:55.197]         else {
[17:43:55.197]             ...future.result["stdout"] <- base::list(NULL)
[17:43:55.197]         }
[17:43:55.197]         base::close(...future.stdout)
[17:43:55.197]         ...future.stdout <- NULL
[17:43:55.197]     }
[17:43:55.197]     ...future.result$conditions <- ...future.conditions
[17:43:55.197]     ...future.result$finished <- base::Sys.time()
[17:43:55.197]     ...future.result
[17:43:55.197] }
[17:43:55.200] MultisessionFuture started
[17:43:55.200] - Launch lazy future ... done
[17:43:55.201] run() for ‘MultisessionFuture’ ... done
[17:43:55.201] getGlobalsAndPackages() ...
[17:43:55.201] Searching for globals...
[17:43:55.201] 
[17:43:55.201] Searching for globals ... DONE
[17:43:55.201] - globals: [0] <none>
[17:43:55.201] getGlobalsAndPackages() ... DONE
[17:43:55.202] run() for ‘Future’ ...
[17:43:55.202] - state: ‘created’
[17:43:55.202] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:55.216] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:55.216] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:55.217]   - Field: ‘node’
[17:43:55.217]   - Field: ‘label’
[17:43:55.217]   - Field: ‘local’
[17:43:55.217]   - Field: ‘owner’
[17:43:55.217]   - Field: ‘envir’
[17:43:55.217]   - Field: ‘workers’
[17:43:55.217]   - Field: ‘packages’
[17:43:55.217]   - Field: ‘gc’
[17:43:55.217]   - Field: ‘conditions’
[17:43:55.217]   - Field: ‘persistent’
[17:43:55.217]   - Field: ‘expr’
[17:43:55.218]   - Field: ‘uuid’
[17:43:55.218]   - Field: ‘seed’
[17:43:55.218]   - Field: ‘version’
[17:43:55.218]   - Field: ‘result’
[17:43:55.218]   - Field: ‘asynchronous’
[17:43:55.218]   - Field: ‘calls’
[17:43:55.218]   - Field: ‘globals’
[17:43:55.218]   - Field: ‘stdout’
[17:43:55.218]   - Field: ‘earlySignal’
[17:43:55.218]   - Field: ‘lazy’
[17:43:55.218]   - Field: ‘state’
[17:43:55.218] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:55.219] - Launch lazy future ...
[17:43:55.219] Packages needed by the future expression (n = 0): <none>
[17:43:55.219] Packages needed by future strategies (n = 0): <none>
[17:43:55.219] {
[17:43:55.219]     {
[17:43:55.219]         {
[17:43:55.219]             ...future.startTime <- base::Sys.time()
[17:43:55.219]             {
[17:43:55.219]                 {
[17:43:55.219]                   {
[17:43:55.219]                     {
[17:43:55.219]                       base::local({
[17:43:55.219]                         has_future <- base::requireNamespace("future", 
[17:43:55.219]                           quietly = TRUE)
[17:43:55.219]                         if (has_future) {
[17:43:55.219]                           ns <- base::getNamespace("future")
[17:43:55.219]                           version <- ns[[".package"]][["version"]]
[17:43:55.219]                           if (is.null(version)) 
[17:43:55.219]                             version <- utils::packageVersion("future")
[17:43:55.219]                         }
[17:43:55.219]                         else {
[17:43:55.219]                           version <- NULL
[17:43:55.219]                         }
[17:43:55.219]                         if (!has_future || version < "1.8.0") {
[17:43:55.219]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:55.219]                             "", base::R.version$version.string), 
[17:43:55.219]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:55.219]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:55.219]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:55.219]                               "release", "version")], collapse = " "), 
[17:43:55.219]                             hostname = base::Sys.info()[["nodename"]])
[17:43:55.219]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:55.219]                             info)
[17:43:55.219]                           info <- base::paste(info, collapse = "; ")
[17:43:55.219]                           if (!has_future) {
[17:43:55.219]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:55.219]                               info)
[17:43:55.219]                           }
[17:43:55.219]                           else {
[17:43:55.219]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:55.219]                               info, version)
[17:43:55.219]                           }
[17:43:55.219]                           base::stop(msg)
[17:43:55.219]                         }
[17:43:55.219]                       })
[17:43:55.219]                     }
[17:43:55.219]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:55.219]                     base::options(mc.cores = 1L)
[17:43:55.219]                   }
[17:43:55.219]                   options(future.plan = NULL)
[17:43:55.219]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.219]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:55.219]                 }
[17:43:55.219]                 ...future.workdir <- getwd()
[17:43:55.219]             }
[17:43:55.219]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:55.219]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:55.219]         }
[17:43:55.219]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:55.219]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:55.219]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:55.219]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:55.219]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:55.219]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:55.219]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:55.219]             base::names(...future.oldOptions))
[17:43:55.219]     }
[17:43:55.219]     if (FALSE) {
[17:43:55.219]     }
[17:43:55.219]     else {
[17:43:55.219]         if (TRUE) {
[17:43:55.219]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:55.219]                 open = "w")
[17:43:55.219]         }
[17:43:55.219]         else {
[17:43:55.219]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:55.219]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:55.219]         }
[17:43:55.219]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:55.219]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:55.219]             base::sink(type = "output", split = FALSE)
[17:43:55.219]             base::close(...future.stdout)
[17:43:55.219]         }, add = TRUE)
[17:43:55.219]     }
[17:43:55.219]     ...future.frame <- base::sys.nframe()
[17:43:55.219]     ...future.conditions <- base::list()
[17:43:55.219]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:55.219]     if (FALSE) {
[17:43:55.219]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:55.219]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:55.219]     }
[17:43:55.219]     ...future.result <- base::tryCatch({
[17:43:55.219]         base::withCallingHandlers({
[17:43:55.219]             ...future.value <- base::withVisible(base::local({
[17:43:55.219]                 ...future.makeSendCondition <- local({
[17:43:55.219]                   sendCondition <- NULL
[17:43:55.219]                   function(frame = 1L) {
[17:43:55.219]                     if (is.function(sendCondition)) 
[17:43:55.219]                       return(sendCondition)
[17:43:55.219]                     ns <- getNamespace("parallel")
[17:43:55.219]                     if (exists("sendData", mode = "function", 
[17:43:55.219]                       envir = ns)) {
[17:43:55.219]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:55.219]                         envir = ns)
[17:43:55.219]                       envir <- sys.frame(frame)
[17:43:55.219]                       master <- NULL
[17:43:55.219]                       while (!identical(envir, .GlobalEnv) && 
[17:43:55.219]                         !identical(envir, emptyenv())) {
[17:43:55.219]                         if (exists("master", mode = "list", envir = envir, 
[17:43:55.219]                           inherits = FALSE)) {
[17:43:55.219]                           master <- get("master", mode = "list", 
[17:43:55.219]                             envir = envir, inherits = FALSE)
[17:43:55.219]                           if (inherits(master, c("SOCKnode", 
[17:43:55.219]                             "SOCK0node"))) {
[17:43:55.219]                             sendCondition <<- function(cond) {
[17:43:55.219]                               data <- list(type = "VALUE", value = cond, 
[17:43:55.219]                                 success = TRUE)
[17:43:55.219]                               parallel_sendData(master, data)
[17:43:55.219]                             }
[17:43:55.219]                             return(sendCondition)
[17:43:55.219]                           }
[17:43:55.219]                         }
[17:43:55.219]                         frame <- frame + 1L
[17:43:55.219]                         envir <- sys.frame(frame)
[17:43:55.219]                       }
[17:43:55.219]                     }
[17:43:55.219]                     sendCondition <<- function(cond) NULL
[17:43:55.219]                   }
[17:43:55.219]                 })
[17:43:55.219]                 withCallingHandlers({
[17:43:55.219]                   2
[17:43:55.219]                 }, immediateCondition = function(cond) {
[17:43:55.219]                   sendCondition <- ...future.makeSendCondition()
[17:43:55.219]                   sendCondition(cond)
[17:43:55.219]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.219]                   {
[17:43:55.219]                     inherits <- base::inherits
[17:43:55.219]                     invokeRestart <- base::invokeRestart
[17:43:55.219]                     is.null <- base::is.null
[17:43:55.219]                     muffled <- FALSE
[17:43:55.219]                     if (inherits(cond, "message")) {
[17:43:55.219]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:55.219]                       if (muffled) 
[17:43:55.219]                         invokeRestart("muffleMessage")
[17:43:55.219]                     }
[17:43:55.219]                     else if (inherits(cond, "warning")) {
[17:43:55.219]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:55.219]                       if (muffled) 
[17:43:55.219]                         invokeRestart("muffleWarning")
[17:43:55.219]                     }
[17:43:55.219]                     else if (inherits(cond, "condition")) {
[17:43:55.219]                       if (!is.null(pattern)) {
[17:43:55.219]                         computeRestarts <- base::computeRestarts
[17:43:55.219]                         grepl <- base::grepl
[17:43:55.219]                         restarts <- computeRestarts(cond)
[17:43:55.219]                         for (restart in restarts) {
[17:43:55.219]                           name <- restart$name
[17:43:55.219]                           if (is.null(name)) 
[17:43:55.219]                             next
[17:43:55.219]                           if (!grepl(pattern, name)) 
[17:43:55.219]                             next
[17:43:55.219]                           invokeRestart(restart)
[17:43:55.219]                           muffled <- TRUE
[17:43:55.219]                           break
[17:43:55.219]                         }
[17:43:55.219]                       }
[17:43:55.219]                     }
[17:43:55.219]                     invisible(muffled)
[17:43:55.219]                   }
[17:43:55.219]                   muffleCondition(cond)
[17:43:55.219]                 })
[17:43:55.219]             }))
[17:43:55.219]             future::FutureResult(value = ...future.value$value, 
[17:43:55.219]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.219]                   ...future.rng), globalenv = if (FALSE) 
[17:43:55.219]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:55.219]                     ...future.globalenv.names))
[17:43:55.219]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:55.219]         }, condition = base::local({
[17:43:55.219]             c <- base::c
[17:43:55.219]             inherits <- base::inherits
[17:43:55.219]             invokeRestart <- base::invokeRestart
[17:43:55.219]             length <- base::length
[17:43:55.219]             list <- base::list
[17:43:55.219]             seq.int <- base::seq.int
[17:43:55.219]             signalCondition <- base::signalCondition
[17:43:55.219]             sys.calls <- base::sys.calls
[17:43:55.219]             `[[` <- base::`[[`
[17:43:55.219]             `+` <- base::`+`
[17:43:55.219]             `<<-` <- base::`<<-`
[17:43:55.219]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:55.219]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:55.219]                   3L)]
[17:43:55.219]             }
[17:43:55.219]             function(cond) {
[17:43:55.219]                 is_error <- inherits(cond, "error")
[17:43:55.219]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:55.219]                   NULL)
[17:43:55.219]                 if (is_error) {
[17:43:55.219]                   sessionInformation <- function() {
[17:43:55.219]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:55.219]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:55.219]                       search = base::search(), system = base::Sys.info())
[17:43:55.219]                   }
[17:43:55.219]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.219]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:55.219]                     cond$call), session = sessionInformation(), 
[17:43:55.219]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:55.219]                   signalCondition(cond)
[17:43:55.219]                 }
[17:43:55.219]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:55.219]                 "immediateCondition"))) {
[17:43:55.219]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:55.219]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.219]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:55.219]                   if (TRUE && !signal) {
[17:43:55.219]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.219]                     {
[17:43:55.219]                       inherits <- base::inherits
[17:43:55.219]                       invokeRestart <- base::invokeRestart
[17:43:55.219]                       is.null <- base::is.null
[17:43:55.219]                       muffled <- FALSE
[17:43:55.219]                       if (inherits(cond, "message")) {
[17:43:55.219]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.219]                         if (muffled) 
[17:43:55.219]                           invokeRestart("muffleMessage")
[17:43:55.219]                       }
[17:43:55.219]                       else if (inherits(cond, "warning")) {
[17:43:55.219]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.219]                         if (muffled) 
[17:43:55.219]                           invokeRestart("muffleWarning")
[17:43:55.219]                       }
[17:43:55.219]                       else if (inherits(cond, "condition")) {
[17:43:55.219]                         if (!is.null(pattern)) {
[17:43:55.219]                           computeRestarts <- base::computeRestarts
[17:43:55.219]                           grepl <- base::grepl
[17:43:55.219]                           restarts <- computeRestarts(cond)
[17:43:55.219]                           for (restart in restarts) {
[17:43:55.219]                             name <- restart$name
[17:43:55.219]                             if (is.null(name)) 
[17:43:55.219]                               next
[17:43:55.219]                             if (!grepl(pattern, name)) 
[17:43:55.219]                               next
[17:43:55.219]                             invokeRestart(restart)
[17:43:55.219]                             muffled <- TRUE
[17:43:55.219]                             break
[17:43:55.219]                           }
[17:43:55.219]                         }
[17:43:55.219]                       }
[17:43:55.219]                       invisible(muffled)
[17:43:55.219]                     }
[17:43:55.219]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.219]                   }
[17:43:55.219]                 }
[17:43:55.219]                 else {
[17:43:55.219]                   if (TRUE) {
[17:43:55.219]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.219]                     {
[17:43:55.219]                       inherits <- base::inherits
[17:43:55.219]                       invokeRestart <- base::invokeRestart
[17:43:55.219]                       is.null <- base::is.null
[17:43:55.219]                       muffled <- FALSE
[17:43:55.219]                       if (inherits(cond, "message")) {
[17:43:55.219]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.219]                         if (muffled) 
[17:43:55.219]                           invokeRestart("muffleMessage")
[17:43:55.219]                       }
[17:43:55.219]                       else if (inherits(cond, "warning")) {
[17:43:55.219]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.219]                         if (muffled) 
[17:43:55.219]                           invokeRestart("muffleWarning")
[17:43:55.219]                       }
[17:43:55.219]                       else if (inherits(cond, "condition")) {
[17:43:55.219]                         if (!is.null(pattern)) {
[17:43:55.219]                           computeRestarts <- base::computeRestarts
[17:43:55.219]                           grepl <- base::grepl
[17:43:55.219]                           restarts <- computeRestarts(cond)
[17:43:55.219]                           for (restart in restarts) {
[17:43:55.219]                             name <- restart$name
[17:43:55.219]                             if (is.null(name)) 
[17:43:55.219]                               next
[17:43:55.219]                             if (!grepl(pattern, name)) 
[17:43:55.219]                               next
[17:43:55.219]                             invokeRestart(restart)
[17:43:55.219]                             muffled <- TRUE
[17:43:55.219]                             break
[17:43:55.219]                           }
[17:43:55.219]                         }
[17:43:55.219]                       }
[17:43:55.219]                       invisible(muffled)
[17:43:55.219]                     }
[17:43:55.219]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.219]                   }
[17:43:55.219]                 }
[17:43:55.219]             }
[17:43:55.219]         }))
[17:43:55.219]     }, error = function(ex) {
[17:43:55.219]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:55.219]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.219]                 ...future.rng), started = ...future.startTime, 
[17:43:55.219]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:55.219]             version = "1.8"), class = "FutureResult")
[17:43:55.219]     }, finally = {
[17:43:55.219]         if (!identical(...future.workdir, getwd())) 
[17:43:55.219]             setwd(...future.workdir)
[17:43:55.219]         {
[17:43:55.219]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:55.219]                 ...future.oldOptions$nwarnings <- NULL
[17:43:55.219]             }
[17:43:55.219]             base::options(...future.oldOptions)
[17:43:55.219]             if (.Platform$OS.type == "windows") {
[17:43:55.219]                 old_names <- names(...future.oldEnvVars)
[17:43:55.219]                 envs <- base::Sys.getenv()
[17:43:55.219]                 names <- names(envs)
[17:43:55.219]                 common <- intersect(names, old_names)
[17:43:55.219]                 added <- setdiff(names, old_names)
[17:43:55.219]                 removed <- setdiff(old_names, names)
[17:43:55.219]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:55.219]                   envs[common]]
[17:43:55.219]                 NAMES <- toupper(changed)
[17:43:55.219]                 args <- list()
[17:43:55.219]                 for (kk in seq_along(NAMES)) {
[17:43:55.219]                   name <- changed[[kk]]
[17:43:55.219]                   NAME <- NAMES[[kk]]
[17:43:55.219]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.219]                     next
[17:43:55.219]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.219]                 }
[17:43:55.219]                 NAMES <- toupper(added)
[17:43:55.219]                 for (kk in seq_along(NAMES)) {
[17:43:55.219]                   name <- added[[kk]]
[17:43:55.219]                   NAME <- NAMES[[kk]]
[17:43:55.219]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.219]                     next
[17:43:55.219]                   args[[name]] <- ""
[17:43:55.219]                 }
[17:43:55.219]                 NAMES <- toupper(removed)
[17:43:55.219]                 for (kk in seq_along(NAMES)) {
[17:43:55.219]                   name <- removed[[kk]]
[17:43:55.219]                   NAME <- NAMES[[kk]]
[17:43:55.219]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.219]                     next
[17:43:55.219]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.219]                 }
[17:43:55.219]                 if (length(args) > 0) 
[17:43:55.219]                   base::do.call(base::Sys.setenv, args = args)
[17:43:55.219]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:55.219]             }
[17:43:55.219]             else {
[17:43:55.219]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:55.219]             }
[17:43:55.219]             {
[17:43:55.219]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:55.219]                   0L) {
[17:43:55.219]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:55.219]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:55.219]                   base::options(opts)
[17:43:55.219]                 }
[17:43:55.219]                 {
[17:43:55.219]                   {
[17:43:55.219]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:55.219]                     NULL
[17:43:55.219]                   }
[17:43:55.219]                   options(future.plan = NULL)
[17:43:55.219]                   if (is.na(NA_character_)) 
[17:43:55.219]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.219]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:55.219]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:55.219]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:55.219]                     envir = parent.frame()) 
[17:43:55.219]                   {
[17:43:55.219]                     if (is.function(workers)) 
[17:43:55.219]                       workers <- workers()
[17:43:55.219]                     workers <- structure(as.integer(workers), 
[17:43:55.219]                       class = class(workers))
[17:43:55.219]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:55.219]                       workers >= 1)
[17:43:55.219]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:55.219]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:55.219]                     }
[17:43:55.219]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:55.219]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:55.219]                       envir = envir)
[17:43:55.219]                     if (!future$lazy) 
[17:43:55.219]                       future <- run(future)
[17:43:55.219]                     invisible(future)
[17:43:55.219]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:55.219]                 }
[17:43:55.219]             }
[17:43:55.219]         }
[17:43:55.219]     })
[17:43:55.219]     if (TRUE) {
[17:43:55.219]         base::sink(type = "output", split = FALSE)
[17:43:55.219]         if (TRUE) {
[17:43:55.219]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:55.219]         }
[17:43:55.219]         else {
[17:43:55.219]             ...future.result["stdout"] <- base::list(NULL)
[17:43:55.219]         }
[17:43:55.219]         base::close(...future.stdout)
[17:43:55.219]         ...future.stdout <- NULL
[17:43:55.219]     }
[17:43:55.219]     ...future.result$conditions <- ...future.conditions
[17:43:55.219]     ...future.result$finished <- base::Sys.time()
[17:43:55.219]     ...future.result
[17:43:55.219] }
[17:43:55.223] MultisessionFuture started
[17:43:55.223] - Launch lazy future ... done
[17:43:55.223] run() for ‘MultisessionFuture’ ... done
[17:43:55.223] resolve() on environment ...
[17:43:55.223]  recursive: 0
[17:43:55.224]  elements: [3] ‘a’, ‘b’, ‘c’
[17:43:55.245]  length: 2 (resolved future 3)
[17:43:55.256] receiveMessageFromWorker() for ClusterFuture ...
[17:43:55.256] - Validating connection of MultisessionFuture
[17:43:55.257] - received message: FutureResult
[17:43:55.257] - Received FutureResult
[17:43:55.257] - Erased future from FutureRegistry
[17:43:55.257] result() for ClusterFuture ...
[17:43:55.257] - result already collected: FutureResult
[17:43:55.257] result() for ClusterFuture ... done
[17:43:55.257] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:55.257] Future #1
[17:43:55.257]  length: 1 (resolved future 1)
[17:43:55.268] receiveMessageFromWorker() for ClusterFuture ...
[17:43:55.268] - Validating connection of MultisessionFuture
[17:43:55.268] - received message: FutureResult
[17:43:55.268] - Received FutureResult
[17:43:55.268] - Erased future from FutureRegistry
[17:43:55.268] result() for ClusterFuture ...
[17:43:55.268] - result already collected: FutureResult
[17:43:55.269] result() for ClusterFuture ... done
[17:43:55.269] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:55.269] Future #2
[17:43:55.269]  length: 0 (resolved future 2)
[17:43:55.269] resolve() on environment ... DONE
[17:43:55.270] getGlobalsAndPackages() ...
[17:43:55.270] Searching for globals...
[17:43:55.270] - globals found: [1] ‘{’
[17:43:55.271] Searching for globals ... DONE
[17:43:55.271] Resolving globals: FALSE
[17:43:55.271] 
[17:43:55.271] 
[17:43:55.271] getGlobalsAndPackages() ... DONE
[17:43:55.271] run() for ‘Future’ ...
[17:43:55.272] - state: ‘created’
[17:43:55.272] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:55.287] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:55.288] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:55.288]   - Field: ‘node’
[17:43:55.288]   - Field: ‘label’
[17:43:55.288]   - Field: ‘local’
[17:43:55.288]   - Field: ‘owner’
[17:43:55.288]   - Field: ‘envir’
[17:43:55.288]   - Field: ‘workers’
[17:43:55.288]   - Field: ‘packages’
[17:43:55.288]   - Field: ‘gc’
[17:43:55.288]   - Field: ‘conditions’
[17:43:55.289]   - Field: ‘persistent’
[17:43:55.289]   - Field: ‘expr’
[17:43:55.289]   - Field: ‘uuid’
[17:43:55.289]   - Field: ‘seed’
[17:43:55.289]   - Field: ‘version’
[17:43:55.289]   - Field: ‘result’
[17:43:55.289]   - Field: ‘asynchronous’
[17:43:55.289]   - Field: ‘calls’
[17:43:55.289]   - Field: ‘globals’
[17:43:55.289]   - Field: ‘stdout’
[17:43:55.289]   - Field: ‘earlySignal’
[17:43:55.290]   - Field: ‘lazy’
[17:43:55.290]   - Field: ‘state’
[17:43:55.290] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:55.290] - Launch lazy future ...
[17:43:55.290] Packages needed by the future expression (n = 0): <none>
[17:43:55.290] Packages needed by future strategies (n = 0): <none>
[17:43:55.291] {
[17:43:55.291]     {
[17:43:55.291]         {
[17:43:55.291]             ...future.startTime <- base::Sys.time()
[17:43:55.291]             {
[17:43:55.291]                 {
[17:43:55.291]                   {
[17:43:55.291]                     {
[17:43:55.291]                       base::local({
[17:43:55.291]                         has_future <- base::requireNamespace("future", 
[17:43:55.291]                           quietly = TRUE)
[17:43:55.291]                         if (has_future) {
[17:43:55.291]                           ns <- base::getNamespace("future")
[17:43:55.291]                           version <- ns[[".package"]][["version"]]
[17:43:55.291]                           if (is.null(version)) 
[17:43:55.291]                             version <- utils::packageVersion("future")
[17:43:55.291]                         }
[17:43:55.291]                         else {
[17:43:55.291]                           version <- NULL
[17:43:55.291]                         }
[17:43:55.291]                         if (!has_future || version < "1.8.0") {
[17:43:55.291]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:55.291]                             "", base::R.version$version.string), 
[17:43:55.291]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:55.291]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:55.291]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:55.291]                               "release", "version")], collapse = " "), 
[17:43:55.291]                             hostname = base::Sys.info()[["nodename"]])
[17:43:55.291]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:55.291]                             info)
[17:43:55.291]                           info <- base::paste(info, collapse = "; ")
[17:43:55.291]                           if (!has_future) {
[17:43:55.291]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:55.291]                               info)
[17:43:55.291]                           }
[17:43:55.291]                           else {
[17:43:55.291]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:55.291]                               info, version)
[17:43:55.291]                           }
[17:43:55.291]                           base::stop(msg)
[17:43:55.291]                         }
[17:43:55.291]                       })
[17:43:55.291]                     }
[17:43:55.291]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:55.291]                     base::options(mc.cores = 1L)
[17:43:55.291]                   }
[17:43:55.291]                   options(future.plan = NULL)
[17:43:55.291]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.291]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:55.291]                 }
[17:43:55.291]                 ...future.workdir <- getwd()
[17:43:55.291]             }
[17:43:55.291]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:55.291]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:55.291]         }
[17:43:55.291]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:55.291]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:55.291]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:55.291]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:55.291]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:55.291]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:55.291]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:55.291]             base::names(...future.oldOptions))
[17:43:55.291]     }
[17:43:55.291]     if (FALSE) {
[17:43:55.291]     }
[17:43:55.291]     else {
[17:43:55.291]         if (TRUE) {
[17:43:55.291]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:55.291]                 open = "w")
[17:43:55.291]         }
[17:43:55.291]         else {
[17:43:55.291]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:55.291]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:55.291]         }
[17:43:55.291]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:55.291]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:55.291]             base::sink(type = "output", split = FALSE)
[17:43:55.291]             base::close(...future.stdout)
[17:43:55.291]         }, add = TRUE)
[17:43:55.291]     }
[17:43:55.291]     ...future.frame <- base::sys.nframe()
[17:43:55.291]     ...future.conditions <- base::list()
[17:43:55.291]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:55.291]     if (FALSE) {
[17:43:55.291]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:55.291]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:55.291]     }
[17:43:55.291]     ...future.result <- base::tryCatch({
[17:43:55.291]         base::withCallingHandlers({
[17:43:55.291]             ...future.value <- base::withVisible(base::local({
[17:43:55.291]                 ...future.makeSendCondition <- local({
[17:43:55.291]                   sendCondition <- NULL
[17:43:55.291]                   function(frame = 1L) {
[17:43:55.291]                     if (is.function(sendCondition)) 
[17:43:55.291]                       return(sendCondition)
[17:43:55.291]                     ns <- getNamespace("parallel")
[17:43:55.291]                     if (exists("sendData", mode = "function", 
[17:43:55.291]                       envir = ns)) {
[17:43:55.291]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:55.291]                         envir = ns)
[17:43:55.291]                       envir <- sys.frame(frame)
[17:43:55.291]                       master <- NULL
[17:43:55.291]                       while (!identical(envir, .GlobalEnv) && 
[17:43:55.291]                         !identical(envir, emptyenv())) {
[17:43:55.291]                         if (exists("master", mode = "list", envir = envir, 
[17:43:55.291]                           inherits = FALSE)) {
[17:43:55.291]                           master <- get("master", mode = "list", 
[17:43:55.291]                             envir = envir, inherits = FALSE)
[17:43:55.291]                           if (inherits(master, c("SOCKnode", 
[17:43:55.291]                             "SOCK0node"))) {
[17:43:55.291]                             sendCondition <<- function(cond) {
[17:43:55.291]                               data <- list(type = "VALUE", value = cond, 
[17:43:55.291]                                 success = TRUE)
[17:43:55.291]                               parallel_sendData(master, data)
[17:43:55.291]                             }
[17:43:55.291]                             return(sendCondition)
[17:43:55.291]                           }
[17:43:55.291]                         }
[17:43:55.291]                         frame <- frame + 1L
[17:43:55.291]                         envir <- sys.frame(frame)
[17:43:55.291]                       }
[17:43:55.291]                     }
[17:43:55.291]                     sendCondition <<- function(cond) NULL
[17:43:55.291]                   }
[17:43:55.291]                 })
[17:43:55.291]                 withCallingHandlers({
[17:43:55.291]                   {
[17:43:55.291]                     1
[17:43:55.291]                   }
[17:43:55.291]                 }, immediateCondition = function(cond) {
[17:43:55.291]                   sendCondition <- ...future.makeSendCondition()
[17:43:55.291]                   sendCondition(cond)
[17:43:55.291]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.291]                   {
[17:43:55.291]                     inherits <- base::inherits
[17:43:55.291]                     invokeRestart <- base::invokeRestart
[17:43:55.291]                     is.null <- base::is.null
[17:43:55.291]                     muffled <- FALSE
[17:43:55.291]                     if (inherits(cond, "message")) {
[17:43:55.291]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:55.291]                       if (muffled) 
[17:43:55.291]                         invokeRestart("muffleMessage")
[17:43:55.291]                     }
[17:43:55.291]                     else if (inherits(cond, "warning")) {
[17:43:55.291]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:55.291]                       if (muffled) 
[17:43:55.291]                         invokeRestart("muffleWarning")
[17:43:55.291]                     }
[17:43:55.291]                     else if (inherits(cond, "condition")) {
[17:43:55.291]                       if (!is.null(pattern)) {
[17:43:55.291]                         computeRestarts <- base::computeRestarts
[17:43:55.291]                         grepl <- base::grepl
[17:43:55.291]                         restarts <- computeRestarts(cond)
[17:43:55.291]                         for (restart in restarts) {
[17:43:55.291]                           name <- restart$name
[17:43:55.291]                           if (is.null(name)) 
[17:43:55.291]                             next
[17:43:55.291]                           if (!grepl(pattern, name)) 
[17:43:55.291]                             next
[17:43:55.291]                           invokeRestart(restart)
[17:43:55.291]                           muffled <- TRUE
[17:43:55.291]                           break
[17:43:55.291]                         }
[17:43:55.291]                       }
[17:43:55.291]                     }
[17:43:55.291]                     invisible(muffled)
[17:43:55.291]                   }
[17:43:55.291]                   muffleCondition(cond)
[17:43:55.291]                 })
[17:43:55.291]             }))
[17:43:55.291]             future::FutureResult(value = ...future.value$value, 
[17:43:55.291]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.291]                   ...future.rng), globalenv = if (FALSE) 
[17:43:55.291]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:55.291]                     ...future.globalenv.names))
[17:43:55.291]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:55.291]         }, condition = base::local({
[17:43:55.291]             c <- base::c
[17:43:55.291]             inherits <- base::inherits
[17:43:55.291]             invokeRestart <- base::invokeRestart
[17:43:55.291]             length <- base::length
[17:43:55.291]             list <- base::list
[17:43:55.291]             seq.int <- base::seq.int
[17:43:55.291]             signalCondition <- base::signalCondition
[17:43:55.291]             sys.calls <- base::sys.calls
[17:43:55.291]             `[[` <- base::`[[`
[17:43:55.291]             `+` <- base::`+`
[17:43:55.291]             `<<-` <- base::`<<-`
[17:43:55.291]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:55.291]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:55.291]                   3L)]
[17:43:55.291]             }
[17:43:55.291]             function(cond) {
[17:43:55.291]                 is_error <- inherits(cond, "error")
[17:43:55.291]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:55.291]                   NULL)
[17:43:55.291]                 if (is_error) {
[17:43:55.291]                   sessionInformation <- function() {
[17:43:55.291]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:55.291]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:55.291]                       search = base::search(), system = base::Sys.info())
[17:43:55.291]                   }
[17:43:55.291]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.291]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:55.291]                     cond$call), session = sessionInformation(), 
[17:43:55.291]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:55.291]                   signalCondition(cond)
[17:43:55.291]                 }
[17:43:55.291]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:55.291]                 "immediateCondition"))) {
[17:43:55.291]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:55.291]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.291]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:55.291]                   if (TRUE && !signal) {
[17:43:55.291]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.291]                     {
[17:43:55.291]                       inherits <- base::inherits
[17:43:55.291]                       invokeRestart <- base::invokeRestart
[17:43:55.291]                       is.null <- base::is.null
[17:43:55.291]                       muffled <- FALSE
[17:43:55.291]                       if (inherits(cond, "message")) {
[17:43:55.291]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.291]                         if (muffled) 
[17:43:55.291]                           invokeRestart("muffleMessage")
[17:43:55.291]                       }
[17:43:55.291]                       else if (inherits(cond, "warning")) {
[17:43:55.291]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.291]                         if (muffled) 
[17:43:55.291]                           invokeRestart("muffleWarning")
[17:43:55.291]                       }
[17:43:55.291]                       else if (inherits(cond, "condition")) {
[17:43:55.291]                         if (!is.null(pattern)) {
[17:43:55.291]                           computeRestarts <- base::computeRestarts
[17:43:55.291]                           grepl <- base::grepl
[17:43:55.291]                           restarts <- computeRestarts(cond)
[17:43:55.291]                           for (restart in restarts) {
[17:43:55.291]                             name <- restart$name
[17:43:55.291]                             if (is.null(name)) 
[17:43:55.291]                               next
[17:43:55.291]                             if (!grepl(pattern, name)) 
[17:43:55.291]                               next
[17:43:55.291]                             invokeRestart(restart)
[17:43:55.291]                             muffled <- TRUE
[17:43:55.291]                             break
[17:43:55.291]                           }
[17:43:55.291]                         }
[17:43:55.291]                       }
[17:43:55.291]                       invisible(muffled)
[17:43:55.291]                     }
[17:43:55.291]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.291]                   }
[17:43:55.291]                 }
[17:43:55.291]                 else {
[17:43:55.291]                   if (TRUE) {
[17:43:55.291]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.291]                     {
[17:43:55.291]                       inherits <- base::inherits
[17:43:55.291]                       invokeRestart <- base::invokeRestart
[17:43:55.291]                       is.null <- base::is.null
[17:43:55.291]                       muffled <- FALSE
[17:43:55.291]                       if (inherits(cond, "message")) {
[17:43:55.291]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.291]                         if (muffled) 
[17:43:55.291]                           invokeRestart("muffleMessage")
[17:43:55.291]                       }
[17:43:55.291]                       else if (inherits(cond, "warning")) {
[17:43:55.291]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.291]                         if (muffled) 
[17:43:55.291]                           invokeRestart("muffleWarning")
[17:43:55.291]                       }
[17:43:55.291]                       else if (inherits(cond, "condition")) {
[17:43:55.291]                         if (!is.null(pattern)) {
[17:43:55.291]                           computeRestarts <- base::computeRestarts
[17:43:55.291]                           grepl <- base::grepl
[17:43:55.291]                           restarts <- computeRestarts(cond)
[17:43:55.291]                           for (restart in restarts) {
[17:43:55.291]                             name <- restart$name
[17:43:55.291]                             if (is.null(name)) 
[17:43:55.291]                               next
[17:43:55.291]                             if (!grepl(pattern, name)) 
[17:43:55.291]                               next
[17:43:55.291]                             invokeRestart(restart)
[17:43:55.291]                             muffled <- TRUE
[17:43:55.291]                             break
[17:43:55.291]                           }
[17:43:55.291]                         }
[17:43:55.291]                       }
[17:43:55.291]                       invisible(muffled)
[17:43:55.291]                     }
[17:43:55.291]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.291]                   }
[17:43:55.291]                 }
[17:43:55.291]             }
[17:43:55.291]         }))
[17:43:55.291]     }, error = function(ex) {
[17:43:55.291]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:55.291]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.291]                 ...future.rng), started = ...future.startTime, 
[17:43:55.291]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:55.291]             version = "1.8"), class = "FutureResult")
[17:43:55.291]     }, finally = {
[17:43:55.291]         if (!identical(...future.workdir, getwd())) 
[17:43:55.291]             setwd(...future.workdir)
[17:43:55.291]         {
[17:43:55.291]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:55.291]                 ...future.oldOptions$nwarnings <- NULL
[17:43:55.291]             }
[17:43:55.291]             base::options(...future.oldOptions)
[17:43:55.291]             if (.Platform$OS.type == "windows") {
[17:43:55.291]                 old_names <- names(...future.oldEnvVars)
[17:43:55.291]                 envs <- base::Sys.getenv()
[17:43:55.291]                 names <- names(envs)
[17:43:55.291]                 common <- intersect(names, old_names)
[17:43:55.291]                 added <- setdiff(names, old_names)
[17:43:55.291]                 removed <- setdiff(old_names, names)
[17:43:55.291]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:55.291]                   envs[common]]
[17:43:55.291]                 NAMES <- toupper(changed)
[17:43:55.291]                 args <- list()
[17:43:55.291]                 for (kk in seq_along(NAMES)) {
[17:43:55.291]                   name <- changed[[kk]]
[17:43:55.291]                   NAME <- NAMES[[kk]]
[17:43:55.291]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.291]                     next
[17:43:55.291]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.291]                 }
[17:43:55.291]                 NAMES <- toupper(added)
[17:43:55.291]                 for (kk in seq_along(NAMES)) {
[17:43:55.291]                   name <- added[[kk]]
[17:43:55.291]                   NAME <- NAMES[[kk]]
[17:43:55.291]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.291]                     next
[17:43:55.291]                   args[[name]] <- ""
[17:43:55.291]                 }
[17:43:55.291]                 NAMES <- toupper(removed)
[17:43:55.291]                 for (kk in seq_along(NAMES)) {
[17:43:55.291]                   name <- removed[[kk]]
[17:43:55.291]                   NAME <- NAMES[[kk]]
[17:43:55.291]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.291]                     next
[17:43:55.291]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.291]                 }
[17:43:55.291]                 if (length(args) > 0) 
[17:43:55.291]                   base::do.call(base::Sys.setenv, args = args)
[17:43:55.291]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:55.291]             }
[17:43:55.291]             else {
[17:43:55.291]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:55.291]             }
[17:43:55.291]             {
[17:43:55.291]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:55.291]                   0L) {
[17:43:55.291]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:55.291]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:55.291]                   base::options(opts)
[17:43:55.291]                 }
[17:43:55.291]                 {
[17:43:55.291]                   {
[17:43:55.291]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:55.291]                     NULL
[17:43:55.291]                   }
[17:43:55.291]                   options(future.plan = NULL)
[17:43:55.291]                   if (is.na(NA_character_)) 
[17:43:55.291]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.291]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:55.291]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:55.291]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:55.291]                     envir = parent.frame()) 
[17:43:55.291]                   {
[17:43:55.291]                     if (is.function(workers)) 
[17:43:55.291]                       workers <- workers()
[17:43:55.291]                     workers <- structure(as.integer(workers), 
[17:43:55.291]                       class = class(workers))
[17:43:55.291]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:55.291]                       workers >= 1)
[17:43:55.291]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:55.291]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:55.291]                     }
[17:43:55.291]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:55.291]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:55.291]                       envir = envir)
[17:43:55.291]                     if (!future$lazy) 
[17:43:55.291]                       future <- run(future)
[17:43:55.291]                     invisible(future)
[17:43:55.291]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:55.291]                 }
[17:43:55.291]             }
[17:43:55.291]         }
[17:43:55.291]     })
[17:43:55.291]     if (TRUE) {
[17:43:55.291]         base::sink(type = "output", split = FALSE)
[17:43:55.291]         if (TRUE) {
[17:43:55.291]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:55.291]         }
[17:43:55.291]         else {
[17:43:55.291]             ...future.result["stdout"] <- base::list(NULL)
[17:43:55.291]         }
[17:43:55.291]         base::close(...future.stdout)
[17:43:55.291]         ...future.stdout <- NULL
[17:43:55.291]     }
[17:43:55.291]     ...future.result$conditions <- ...future.conditions
[17:43:55.291]     ...future.result$finished <- base::Sys.time()
[17:43:55.291]     ...future.result
[17:43:55.291] }
[17:43:55.294] MultisessionFuture started
[17:43:55.294] - Launch lazy future ... done
[17:43:55.294] run() for ‘MultisessionFuture’ ... done
[17:43:55.295] getGlobalsAndPackages() ...
[17:43:55.295] Searching for globals...
[17:43:55.295] - globals found: [1] ‘{’
[17:43:55.296] Searching for globals ... DONE
[17:43:55.296] Resolving globals: FALSE
[17:43:55.296] 
[17:43:55.296] 
[17:43:55.296] getGlobalsAndPackages() ... DONE
[17:43:55.296] run() for ‘Future’ ...
[17:43:55.297] - state: ‘created’
[17:43:55.297] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:55.312] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:55.312] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:55.312]   - Field: ‘node’
[17:43:55.312]   - Field: ‘label’
[17:43:55.312]   - Field: ‘local’
[17:43:55.312]   - Field: ‘owner’
[17:43:55.312]   - Field: ‘envir’
[17:43:55.312]   - Field: ‘workers’
[17:43:55.312]   - Field: ‘packages’
[17:43:55.313]   - Field: ‘gc’
[17:43:55.313]   - Field: ‘conditions’
[17:43:55.313]   - Field: ‘persistent’
[17:43:55.313]   - Field: ‘expr’
[17:43:55.313]   - Field: ‘uuid’
[17:43:55.313]   - Field: ‘seed’
[17:43:55.313]   - Field: ‘version’
[17:43:55.313]   - Field: ‘result’
[17:43:55.313]   - Field: ‘asynchronous’
[17:43:55.313]   - Field: ‘calls’
[17:43:55.313]   - Field: ‘globals’
[17:43:55.314]   - Field: ‘stdout’
[17:43:55.314]   - Field: ‘earlySignal’
[17:43:55.314]   - Field: ‘lazy’
[17:43:55.314]   - Field: ‘state’
[17:43:55.314] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:55.314] - Launch lazy future ...
[17:43:55.314] Packages needed by the future expression (n = 0): <none>
[17:43:55.314] Packages needed by future strategies (n = 0): <none>
[17:43:55.315] {
[17:43:55.315]     {
[17:43:55.315]         {
[17:43:55.315]             ...future.startTime <- base::Sys.time()
[17:43:55.315]             {
[17:43:55.315]                 {
[17:43:55.315]                   {
[17:43:55.315]                     {
[17:43:55.315]                       base::local({
[17:43:55.315]                         has_future <- base::requireNamespace("future", 
[17:43:55.315]                           quietly = TRUE)
[17:43:55.315]                         if (has_future) {
[17:43:55.315]                           ns <- base::getNamespace("future")
[17:43:55.315]                           version <- ns[[".package"]][["version"]]
[17:43:55.315]                           if (is.null(version)) 
[17:43:55.315]                             version <- utils::packageVersion("future")
[17:43:55.315]                         }
[17:43:55.315]                         else {
[17:43:55.315]                           version <- NULL
[17:43:55.315]                         }
[17:43:55.315]                         if (!has_future || version < "1.8.0") {
[17:43:55.315]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:55.315]                             "", base::R.version$version.string), 
[17:43:55.315]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:55.315]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:55.315]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:55.315]                               "release", "version")], collapse = " "), 
[17:43:55.315]                             hostname = base::Sys.info()[["nodename"]])
[17:43:55.315]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:55.315]                             info)
[17:43:55.315]                           info <- base::paste(info, collapse = "; ")
[17:43:55.315]                           if (!has_future) {
[17:43:55.315]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:55.315]                               info)
[17:43:55.315]                           }
[17:43:55.315]                           else {
[17:43:55.315]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:55.315]                               info, version)
[17:43:55.315]                           }
[17:43:55.315]                           base::stop(msg)
[17:43:55.315]                         }
[17:43:55.315]                       })
[17:43:55.315]                     }
[17:43:55.315]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:55.315]                     base::options(mc.cores = 1L)
[17:43:55.315]                   }
[17:43:55.315]                   options(future.plan = NULL)
[17:43:55.315]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.315]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:55.315]                 }
[17:43:55.315]                 ...future.workdir <- getwd()
[17:43:55.315]             }
[17:43:55.315]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:55.315]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:55.315]         }
[17:43:55.315]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:55.315]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:55.315]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:55.315]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:55.315]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:55.315]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:55.315]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:55.315]             base::names(...future.oldOptions))
[17:43:55.315]     }
[17:43:55.315]     if (FALSE) {
[17:43:55.315]     }
[17:43:55.315]     else {
[17:43:55.315]         if (TRUE) {
[17:43:55.315]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:55.315]                 open = "w")
[17:43:55.315]         }
[17:43:55.315]         else {
[17:43:55.315]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:55.315]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:55.315]         }
[17:43:55.315]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:55.315]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:55.315]             base::sink(type = "output", split = FALSE)
[17:43:55.315]             base::close(...future.stdout)
[17:43:55.315]         }, add = TRUE)
[17:43:55.315]     }
[17:43:55.315]     ...future.frame <- base::sys.nframe()
[17:43:55.315]     ...future.conditions <- base::list()
[17:43:55.315]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:55.315]     if (FALSE) {
[17:43:55.315]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:55.315]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:55.315]     }
[17:43:55.315]     ...future.result <- base::tryCatch({
[17:43:55.315]         base::withCallingHandlers({
[17:43:55.315]             ...future.value <- base::withVisible(base::local({
[17:43:55.315]                 ...future.makeSendCondition <- local({
[17:43:55.315]                   sendCondition <- NULL
[17:43:55.315]                   function(frame = 1L) {
[17:43:55.315]                     if (is.function(sendCondition)) 
[17:43:55.315]                       return(sendCondition)
[17:43:55.315]                     ns <- getNamespace("parallel")
[17:43:55.315]                     if (exists("sendData", mode = "function", 
[17:43:55.315]                       envir = ns)) {
[17:43:55.315]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:55.315]                         envir = ns)
[17:43:55.315]                       envir <- sys.frame(frame)
[17:43:55.315]                       master <- NULL
[17:43:55.315]                       while (!identical(envir, .GlobalEnv) && 
[17:43:55.315]                         !identical(envir, emptyenv())) {
[17:43:55.315]                         if (exists("master", mode = "list", envir = envir, 
[17:43:55.315]                           inherits = FALSE)) {
[17:43:55.315]                           master <- get("master", mode = "list", 
[17:43:55.315]                             envir = envir, inherits = FALSE)
[17:43:55.315]                           if (inherits(master, c("SOCKnode", 
[17:43:55.315]                             "SOCK0node"))) {
[17:43:55.315]                             sendCondition <<- function(cond) {
[17:43:55.315]                               data <- list(type = "VALUE", value = cond, 
[17:43:55.315]                                 success = TRUE)
[17:43:55.315]                               parallel_sendData(master, data)
[17:43:55.315]                             }
[17:43:55.315]                             return(sendCondition)
[17:43:55.315]                           }
[17:43:55.315]                         }
[17:43:55.315]                         frame <- frame + 1L
[17:43:55.315]                         envir <- sys.frame(frame)
[17:43:55.315]                       }
[17:43:55.315]                     }
[17:43:55.315]                     sendCondition <<- function(cond) NULL
[17:43:55.315]                   }
[17:43:55.315]                 })
[17:43:55.315]                 withCallingHandlers({
[17:43:55.315]                   {
[17:43:55.315]                     2
[17:43:55.315]                   }
[17:43:55.315]                 }, immediateCondition = function(cond) {
[17:43:55.315]                   sendCondition <- ...future.makeSendCondition()
[17:43:55.315]                   sendCondition(cond)
[17:43:55.315]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.315]                   {
[17:43:55.315]                     inherits <- base::inherits
[17:43:55.315]                     invokeRestart <- base::invokeRestart
[17:43:55.315]                     is.null <- base::is.null
[17:43:55.315]                     muffled <- FALSE
[17:43:55.315]                     if (inherits(cond, "message")) {
[17:43:55.315]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:55.315]                       if (muffled) 
[17:43:55.315]                         invokeRestart("muffleMessage")
[17:43:55.315]                     }
[17:43:55.315]                     else if (inherits(cond, "warning")) {
[17:43:55.315]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:55.315]                       if (muffled) 
[17:43:55.315]                         invokeRestart("muffleWarning")
[17:43:55.315]                     }
[17:43:55.315]                     else if (inherits(cond, "condition")) {
[17:43:55.315]                       if (!is.null(pattern)) {
[17:43:55.315]                         computeRestarts <- base::computeRestarts
[17:43:55.315]                         grepl <- base::grepl
[17:43:55.315]                         restarts <- computeRestarts(cond)
[17:43:55.315]                         for (restart in restarts) {
[17:43:55.315]                           name <- restart$name
[17:43:55.315]                           if (is.null(name)) 
[17:43:55.315]                             next
[17:43:55.315]                           if (!grepl(pattern, name)) 
[17:43:55.315]                             next
[17:43:55.315]                           invokeRestart(restart)
[17:43:55.315]                           muffled <- TRUE
[17:43:55.315]                           break
[17:43:55.315]                         }
[17:43:55.315]                       }
[17:43:55.315]                     }
[17:43:55.315]                     invisible(muffled)
[17:43:55.315]                   }
[17:43:55.315]                   muffleCondition(cond)
[17:43:55.315]                 })
[17:43:55.315]             }))
[17:43:55.315]             future::FutureResult(value = ...future.value$value, 
[17:43:55.315]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.315]                   ...future.rng), globalenv = if (FALSE) 
[17:43:55.315]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:55.315]                     ...future.globalenv.names))
[17:43:55.315]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:55.315]         }, condition = base::local({
[17:43:55.315]             c <- base::c
[17:43:55.315]             inherits <- base::inherits
[17:43:55.315]             invokeRestart <- base::invokeRestart
[17:43:55.315]             length <- base::length
[17:43:55.315]             list <- base::list
[17:43:55.315]             seq.int <- base::seq.int
[17:43:55.315]             signalCondition <- base::signalCondition
[17:43:55.315]             sys.calls <- base::sys.calls
[17:43:55.315]             `[[` <- base::`[[`
[17:43:55.315]             `+` <- base::`+`
[17:43:55.315]             `<<-` <- base::`<<-`
[17:43:55.315]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:55.315]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:55.315]                   3L)]
[17:43:55.315]             }
[17:43:55.315]             function(cond) {
[17:43:55.315]                 is_error <- inherits(cond, "error")
[17:43:55.315]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:55.315]                   NULL)
[17:43:55.315]                 if (is_error) {
[17:43:55.315]                   sessionInformation <- function() {
[17:43:55.315]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:55.315]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:55.315]                       search = base::search(), system = base::Sys.info())
[17:43:55.315]                   }
[17:43:55.315]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.315]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:55.315]                     cond$call), session = sessionInformation(), 
[17:43:55.315]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:55.315]                   signalCondition(cond)
[17:43:55.315]                 }
[17:43:55.315]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:55.315]                 "immediateCondition"))) {
[17:43:55.315]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:55.315]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.315]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:55.315]                   if (TRUE && !signal) {
[17:43:55.315]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.315]                     {
[17:43:55.315]                       inherits <- base::inherits
[17:43:55.315]                       invokeRestart <- base::invokeRestart
[17:43:55.315]                       is.null <- base::is.null
[17:43:55.315]                       muffled <- FALSE
[17:43:55.315]                       if (inherits(cond, "message")) {
[17:43:55.315]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.315]                         if (muffled) 
[17:43:55.315]                           invokeRestart("muffleMessage")
[17:43:55.315]                       }
[17:43:55.315]                       else if (inherits(cond, "warning")) {
[17:43:55.315]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.315]                         if (muffled) 
[17:43:55.315]                           invokeRestart("muffleWarning")
[17:43:55.315]                       }
[17:43:55.315]                       else if (inherits(cond, "condition")) {
[17:43:55.315]                         if (!is.null(pattern)) {
[17:43:55.315]                           computeRestarts <- base::computeRestarts
[17:43:55.315]                           grepl <- base::grepl
[17:43:55.315]                           restarts <- computeRestarts(cond)
[17:43:55.315]                           for (restart in restarts) {
[17:43:55.315]                             name <- restart$name
[17:43:55.315]                             if (is.null(name)) 
[17:43:55.315]                               next
[17:43:55.315]                             if (!grepl(pattern, name)) 
[17:43:55.315]                               next
[17:43:55.315]                             invokeRestart(restart)
[17:43:55.315]                             muffled <- TRUE
[17:43:55.315]                             break
[17:43:55.315]                           }
[17:43:55.315]                         }
[17:43:55.315]                       }
[17:43:55.315]                       invisible(muffled)
[17:43:55.315]                     }
[17:43:55.315]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.315]                   }
[17:43:55.315]                 }
[17:43:55.315]                 else {
[17:43:55.315]                   if (TRUE) {
[17:43:55.315]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.315]                     {
[17:43:55.315]                       inherits <- base::inherits
[17:43:55.315]                       invokeRestart <- base::invokeRestart
[17:43:55.315]                       is.null <- base::is.null
[17:43:55.315]                       muffled <- FALSE
[17:43:55.315]                       if (inherits(cond, "message")) {
[17:43:55.315]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.315]                         if (muffled) 
[17:43:55.315]                           invokeRestart("muffleMessage")
[17:43:55.315]                       }
[17:43:55.315]                       else if (inherits(cond, "warning")) {
[17:43:55.315]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.315]                         if (muffled) 
[17:43:55.315]                           invokeRestart("muffleWarning")
[17:43:55.315]                       }
[17:43:55.315]                       else if (inherits(cond, "condition")) {
[17:43:55.315]                         if (!is.null(pattern)) {
[17:43:55.315]                           computeRestarts <- base::computeRestarts
[17:43:55.315]                           grepl <- base::grepl
[17:43:55.315]                           restarts <- computeRestarts(cond)
[17:43:55.315]                           for (restart in restarts) {
[17:43:55.315]                             name <- restart$name
[17:43:55.315]                             if (is.null(name)) 
[17:43:55.315]                               next
[17:43:55.315]                             if (!grepl(pattern, name)) 
[17:43:55.315]                               next
[17:43:55.315]                             invokeRestart(restart)
[17:43:55.315]                             muffled <- TRUE
[17:43:55.315]                             break
[17:43:55.315]                           }
[17:43:55.315]                         }
[17:43:55.315]                       }
[17:43:55.315]                       invisible(muffled)
[17:43:55.315]                     }
[17:43:55.315]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.315]                   }
[17:43:55.315]                 }
[17:43:55.315]             }
[17:43:55.315]         }))
[17:43:55.315]     }, error = function(ex) {
[17:43:55.315]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:55.315]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.315]                 ...future.rng), started = ...future.startTime, 
[17:43:55.315]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:55.315]             version = "1.8"), class = "FutureResult")
[17:43:55.315]     }, finally = {
[17:43:55.315]         if (!identical(...future.workdir, getwd())) 
[17:43:55.315]             setwd(...future.workdir)
[17:43:55.315]         {
[17:43:55.315]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:55.315]                 ...future.oldOptions$nwarnings <- NULL
[17:43:55.315]             }
[17:43:55.315]             base::options(...future.oldOptions)
[17:43:55.315]             if (.Platform$OS.type == "windows") {
[17:43:55.315]                 old_names <- names(...future.oldEnvVars)
[17:43:55.315]                 envs <- base::Sys.getenv()
[17:43:55.315]                 names <- names(envs)
[17:43:55.315]                 common <- intersect(names, old_names)
[17:43:55.315]                 added <- setdiff(names, old_names)
[17:43:55.315]                 removed <- setdiff(old_names, names)
[17:43:55.315]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:55.315]                   envs[common]]
[17:43:55.315]                 NAMES <- toupper(changed)
[17:43:55.315]                 args <- list()
[17:43:55.315]                 for (kk in seq_along(NAMES)) {
[17:43:55.315]                   name <- changed[[kk]]
[17:43:55.315]                   NAME <- NAMES[[kk]]
[17:43:55.315]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.315]                     next
[17:43:55.315]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.315]                 }
[17:43:55.315]                 NAMES <- toupper(added)
[17:43:55.315]                 for (kk in seq_along(NAMES)) {
[17:43:55.315]                   name <- added[[kk]]
[17:43:55.315]                   NAME <- NAMES[[kk]]
[17:43:55.315]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.315]                     next
[17:43:55.315]                   args[[name]] <- ""
[17:43:55.315]                 }
[17:43:55.315]                 NAMES <- toupper(removed)
[17:43:55.315]                 for (kk in seq_along(NAMES)) {
[17:43:55.315]                   name <- removed[[kk]]
[17:43:55.315]                   NAME <- NAMES[[kk]]
[17:43:55.315]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.315]                     next
[17:43:55.315]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.315]                 }
[17:43:55.315]                 if (length(args) > 0) 
[17:43:55.315]                   base::do.call(base::Sys.setenv, args = args)
[17:43:55.315]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:55.315]             }
[17:43:55.315]             else {
[17:43:55.315]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:55.315]             }
[17:43:55.315]             {
[17:43:55.315]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:55.315]                   0L) {
[17:43:55.315]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:55.315]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:55.315]                   base::options(opts)
[17:43:55.315]                 }
[17:43:55.315]                 {
[17:43:55.315]                   {
[17:43:55.315]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:55.315]                     NULL
[17:43:55.315]                   }
[17:43:55.315]                   options(future.plan = NULL)
[17:43:55.315]                   if (is.na(NA_character_)) 
[17:43:55.315]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.315]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:55.315]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:55.315]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:55.315]                     envir = parent.frame()) 
[17:43:55.315]                   {
[17:43:55.315]                     if (is.function(workers)) 
[17:43:55.315]                       workers <- workers()
[17:43:55.315]                     workers <- structure(as.integer(workers), 
[17:43:55.315]                       class = class(workers))
[17:43:55.315]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:55.315]                       workers >= 1)
[17:43:55.315]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:55.315]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:55.315]                     }
[17:43:55.315]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:55.315]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:55.315]                       envir = envir)
[17:43:55.315]                     if (!future$lazy) 
[17:43:55.315]                       future <- run(future)
[17:43:55.315]                     invisible(future)
[17:43:55.315]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:55.315]                 }
[17:43:55.315]             }
[17:43:55.315]         }
[17:43:55.315]     })
[17:43:55.315]     if (TRUE) {
[17:43:55.315]         base::sink(type = "output", split = FALSE)
[17:43:55.315]         if (TRUE) {
[17:43:55.315]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:55.315]         }
[17:43:55.315]         else {
[17:43:55.315]             ...future.result["stdout"] <- base::list(NULL)
[17:43:55.315]         }
[17:43:55.315]         base::close(...future.stdout)
[17:43:55.315]         ...future.stdout <- NULL
[17:43:55.315]     }
[17:43:55.315]     ...future.result$conditions <- ...future.conditions
[17:43:55.315]     ...future.result$finished <- base::Sys.time()
[17:43:55.315]     ...future.result
[17:43:55.315] }
[17:43:55.318] MultisessionFuture started
[17:43:55.318] - Launch lazy future ... done
[17:43:55.318] run() for ‘MultisessionFuture’ ... done
[17:43:55.319] resolve() on environment ...
[17:43:55.319]  recursive: 0
[17:43:55.319]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[17:43:55.340]  length: 2 (resolved future 3)
[17:43:55.352] receiveMessageFromWorker() for ClusterFuture ...
[17:43:55.352] - Validating connection of MultisessionFuture
[17:43:55.352] - received message: FutureResult
[17:43:55.352] - Received FutureResult
[17:43:55.352] - Erased future from FutureRegistry
[17:43:55.352] result() for ClusterFuture ...
[17:43:55.352] - result already collected: FutureResult
[17:43:55.352] result() for ClusterFuture ... done
[17:43:55.353] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:55.353] Future #1
[17:43:55.353]  length: 1 (resolved future 1)
[17:43:55.374] receiveMessageFromWorker() for ClusterFuture ...
[17:43:55.374] - Validating connection of MultisessionFuture
[17:43:55.375] - received message: FutureResult
[17:43:55.375] - Received FutureResult
[17:43:55.375] - Erased future from FutureRegistry
[17:43:55.375] result() for ClusterFuture ...
[17:43:55.375] - result already collected: FutureResult
[17:43:55.375] result() for ClusterFuture ... done
[17:43:55.375] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:55.375] Future #2
[17:43:55.375]  length: 0 (resolved future 2)
[17:43:55.376] resolve() on environment ... DONE
[17:43:55.376] getGlobalsAndPackages() ...
[17:43:55.376] Searching for globals...
[17:43:55.377] - globals found: [1] ‘{’
[17:43:55.377] Searching for globals ... DONE
[17:43:55.377] Resolving globals: FALSE
[17:43:55.377] 
[17:43:55.377] 
[17:43:55.377] getGlobalsAndPackages() ... DONE
[17:43:55.378] run() for ‘Future’ ...
[17:43:55.378] - state: ‘created’
[17:43:55.378] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:55.393] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:55.393] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:55.393]   - Field: ‘node’
[17:43:55.393]   - Field: ‘label’
[17:43:55.393]   - Field: ‘local’
[17:43:55.393]   - Field: ‘owner’
[17:43:55.393]   - Field: ‘envir’
[17:43:55.393]   - Field: ‘workers’
[17:43:55.394]   - Field: ‘packages’
[17:43:55.394]   - Field: ‘gc’
[17:43:55.394]   - Field: ‘conditions’
[17:43:55.394]   - Field: ‘persistent’
[17:43:55.394]   - Field: ‘expr’
[17:43:55.394]   - Field: ‘uuid’
[17:43:55.394]   - Field: ‘seed’
[17:43:55.394]   - Field: ‘version’
[17:43:55.394]   - Field: ‘result’
[17:43:55.394]   - Field: ‘asynchronous’
[17:43:55.394]   - Field: ‘calls’
[17:43:55.395]   - Field: ‘globals’
[17:43:55.395]   - Field: ‘stdout’
[17:43:55.395]   - Field: ‘earlySignal’
[17:43:55.395]   - Field: ‘lazy’
[17:43:55.395]   - Field: ‘state’
[17:43:55.395] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:55.395] - Launch lazy future ...
[17:43:55.395] Packages needed by the future expression (n = 0): <none>
[17:43:55.396] Packages needed by future strategies (n = 0): <none>
[17:43:55.396] {
[17:43:55.396]     {
[17:43:55.396]         {
[17:43:55.396]             ...future.startTime <- base::Sys.time()
[17:43:55.396]             {
[17:43:55.396]                 {
[17:43:55.396]                   {
[17:43:55.396]                     {
[17:43:55.396]                       base::local({
[17:43:55.396]                         has_future <- base::requireNamespace("future", 
[17:43:55.396]                           quietly = TRUE)
[17:43:55.396]                         if (has_future) {
[17:43:55.396]                           ns <- base::getNamespace("future")
[17:43:55.396]                           version <- ns[[".package"]][["version"]]
[17:43:55.396]                           if (is.null(version)) 
[17:43:55.396]                             version <- utils::packageVersion("future")
[17:43:55.396]                         }
[17:43:55.396]                         else {
[17:43:55.396]                           version <- NULL
[17:43:55.396]                         }
[17:43:55.396]                         if (!has_future || version < "1.8.0") {
[17:43:55.396]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:55.396]                             "", base::R.version$version.string), 
[17:43:55.396]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:55.396]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:55.396]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:55.396]                               "release", "version")], collapse = " "), 
[17:43:55.396]                             hostname = base::Sys.info()[["nodename"]])
[17:43:55.396]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:55.396]                             info)
[17:43:55.396]                           info <- base::paste(info, collapse = "; ")
[17:43:55.396]                           if (!has_future) {
[17:43:55.396]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:55.396]                               info)
[17:43:55.396]                           }
[17:43:55.396]                           else {
[17:43:55.396]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:55.396]                               info, version)
[17:43:55.396]                           }
[17:43:55.396]                           base::stop(msg)
[17:43:55.396]                         }
[17:43:55.396]                       })
[17:43:55.396]                     }
[17:43:55.396]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:55.396]                     base::options(mc.cores = 1L)
[17:43:55.396]                   }
[17:43:55.396]                   options(future.plan = NULL)
[17:43:55.396]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.396]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:55.396]                 }
[17:43:55.396]                 ...future.workdir <- getwd()
[17:43:55.396]             }
[17:43:55.396]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:55.396]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:55.396]         }
[17:43:55.396]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:55.396]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:55.396]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:55.396]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:55.396]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:55.396]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:55.396]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:55.396]             base::names(...future.oldOptions))
[17:43:55.396]     }
[17:43:55.396]     if (FALSE) {
[17:43:55.396]     }
[17:43:55.396]     else {
[17:43:55.396]         if (TRUE) {
[17:43:55.396]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:55.396]                 open = "w")
[17:43:55.396]         }
[17:43:55.396]         else {
[17:43:55.396]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:55.396]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:55.396]         }
[17:43:55.396]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:55.396]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:55.396]             base::sink(type = "output", split = FALSE)
[17:43:55.396]             base::close(...future.stdout)
[17:43:55.396]         }, add = TRUE)
[17:43:55.396]     }
[17:43:55.396]     ...future.frame <- base::sys.nframe()
[17:43:55.396]     ...future.conditions <- base::list()
[17:43:55.396]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:55.396]     if (FALSE) {
[17:43:55.396]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:55.396]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:55.396]     }
[17:43:55.396]     ...future.result <- base::tryCatch({
[17:43:55.396]         base::withCallingHandlers({
[17:43:55.396]             ...future.value <- base::withVisible(base::local({
[17:43:55.396]                 ...future.makeSendCondition <- local({
[17:43:55.396]                   sendCondition <- NULL
[17:43:55.396]                   function(frame = 1L) {
[17:43:55.396]                     if (is.function(sendCondition)) 
[17:43:55.396]                       return(sendCondition)
[17:43:55.396]                     ns <- getNamespace("parallel")
[17:43:55.396]                     if (exists("sendData", mode = "function", 
[17:43:55.396]                       envir = ns)) {
[17:43:55.396]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:55.396]                         envir = ns)
[17:43:55.396]                       envir <- sys.frame(frame)
[17:43:55.396]                       master <- NULL
[17:43:55.396]                       while (!identical(envir, .GlobalEnv) && 
[17:43:55.396]                         !identical(envir, emptyenv())) {
[17:43:55.396]                         if (exists("master", mode = "list", envir = envir, 
[17:43:55.396]                           inherits = FALSE)) {
[17:43:55.396]                           master <- get("master", mode = "list", 
[17:43:55.396]                             envir = envir, inherits = FALSE)
[17:43:55.396]                           if (inherits(master, c("SOCKnode", 
[17:43:55.396]                             "SOCK0node"))) {
[17:43:55.396]                             sendCondition <<- function(cond) {
[17:43:55.396]                               data <- list(type = "VALUE", value = cond, 
[17:43:55.396]                                 success = TRUE)
[17:43:55.396]                               parallel_sendData(master, data)
[17:43:55.396]                             }
[17:43:55.396]                             return(sendCondition)
[17:43:55.396]                           }
[17:43:55.396]                         }
[17:43:55.396]                         frame <- frame + 1L
[17:43:55.396]                         envir <- sys.frame(frame)
[17:43:55.396]                       }
[17:43:55.396]                     }
[17:43:55.396]                     sendCondition <<- function(cond) NULL
[17:43:55.396]                   }
[17:43:55.396]                 })
[17:43:55.396]                 withCallingHandlers({
[17:43:55.396]                   {
[17:43:55.396]                     1
[17:43:55.396]                   }
[17:43:55.396]                 }, immediateCondition = function(cond) {
[17:43:55.396]                   sendCondition <- ...future.makeSendCondition()
[17:43:55.396]                   sendCondition(cond)
[17:43:55.396]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.396]                   {
[17:43:55.396]                     inherits <- base::inherits
[17:43:55.396]                     invokeRestart <- base::invokeRestart
[17:43:55.396]                     is.null <- base::is.null
[17:43:55.396]                     muffled <- FALSE
[17:43:55.396]                     if (inherits(cond, "message")) {
[17:43:55.396]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:55.396]                       if (muffled) 
[17:43:55.396]                         invokeRestart("muffleMessage")
[17:43:55.396]                     }
[17:43:55.396]                     else if (inherits(cond, "warning")) {
[17:43:55.396]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:55.396]                       if (muffled) 
[17:43:55.396]                         invokeRestart("muffleWarning")
[17:43:55.396]                     }
[17:43:55.396]                     else if (inherits(cond, "condition")) {
[17:43:55.396]                       if (!is.null(pattern)) {
[17:43:55.396]                         computeRestarts <- base::computeRestarts
[17:43:55.396]                         grepl <- base::grepl
[17:43:55.396]                         restarts <- computeRestarts(cond)
[17:43:55.396]                         for (restart in restarts) {
[17:43:55.396]                           name <- restart$name
[17:43:55.396]                           if (is.null(name)) 
[17:43:55.396]                             next
[17:43:55.396]                           if (!grepl(pattern, name)) 
[17:43:55.396]                             next
[17:43:55.396]                           invokeRestart(restart)
[17:43:55.396]                           muffled <- TRUE
[17:43:55.396]                           break
[17:43:55.396]                         }
[17:43:55.396]                       }
[17:43:55.396]                     }
[17:43:55.396]                     invisible(muffled)
[17:43:55.396]                   }
[17:43:55.396]                   muffleCondition(cond)
[17:43:55.396]                 })
[17:43:55.396]             }))
[17:43:55.396]             future::FutureResult(value = ...future.value$value, 
[17:43:55.396]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.396]                   ...future.rng), globalenv = if (FALSE) 
[17:43:55.396]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:55.396]                     ...future.globalenv.names))
[17:43:55.396]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:55.396]         }, condition = base::local({
[17:43:55.396]             c <- base::c
[17:43:55.396]             inherits <- base::inherits
[17:43:55.396]             invokeRestart <- base::invokeRestart
[17:43:55.396]             length <- base::length
[17:43:55.396]             list <- base::list
[17:43:55.396]             seq.int <- base::seq.int
[17:43:55.396]             signalCondition <- base::signalCondition
[17:43:55.396]             sys.calls <- base::sys.calls
[17:43:55.396]             `[[` <- base::`[[`
[17:43:55.396]             `+` <- base::`+`
[17:43:55.396]             `<<-` <- base::`<<-`
[17:43:55.396]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:55.396]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:55.396]                   3L)]
[17:43:55.396]             }
[17:43:55.396]             function(cond) {
[17:43:55.396]                 is_error <- inherits(cond, "error")
[17:43:55.396]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:55.396]                   NULL)
[17:43:55.396]                 if (is_error) {
[17:43:55.396]                   sessionInformation <- function() {
[17:43:55.396]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:55.396]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:55.396]                       search = base::search(), system = base::Sys.info())
[17:43:55.396]                   }
[17:43:55.396]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.396]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:55.396]                     cond$call), session = sessionInformation(), 
[17:43:55.396]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:55.396]                   signalCondition(cond)
[17:43:55.396]                 }
[17:43:55.396]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:55.396]                 "immediateCondition"))) {
[17:43:55.396]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:55.396]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.396]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:55.396]                   if (TRUE && !signal) {
[17:43:55.396]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.396]                     {
[17:43:55.396]                       inherits <- base::inherits
[17:43:55.396]                       invokeRestart <- base::invokeRestart
[17:43:55.396]                       is.null <- base::is.null
[17:43:55.396]                       muffled <- FALSE
[17:43:55.396]                       if (inherits(cond, "message")) {
[17:43:55.396]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.396]                         if (muffled) 
[17:43:55.396]                           invokeRestart("muffleMessage")
[17:43:55.396]                       }
[17:43:55.396]                       else if (inherits(cond, "warning")) {
[17:43:55.396]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.396]                         if (muffled) 
[17:43:55.396]                           invokeRestart("muffleWarning")
[17:43:55.396]                       }
[17:43:55.396]                       else if (inherits(cond, "condition")) {
[17:43:55.396]                         if (!is.null(pattern)) {
[17:43:55.396]                           computeRestarts <- base::computeRestarts
[17:43:55.396]                           grepl <- base::grepl
[17:43:55.396]                           restarts <- computeRestarts(cond)
[17:43:55.396]                           for (restart in restarts) {
[17:43:55.396]                             name <- restart$name
[17:43:55.396]                             if (is.null(name)) 
[17:43:55.396]                               next
[17:43:55.396]                             if (!grepl(pattern, name)) 
[17:43:55.396]                               next
[17:43:55.396]                             invokeRestart(restart)
[17:43:55.396]                             muffled <- TRUE
[17:43:55.396]                             break
[17:43:55.396]                           }
[17:43:55.396]                         }
[17:43:55.396]                       }
[17:43:55.396]                       invisible(muffled)
[17:43:55.396]                     }
[17:43:55.396]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.396]                   }
[17:43:55.396]                 }
[17:43:55.396]                 else {
[17:43:55.396]                   if (TRUE) {
[17:43:55.396]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.396]                     {
[17:43:55.396]                       inherits <- base::inherits
[17:43:55.396]                       invokeRestart <- base::invokeRestart
[17:43:55.396]                       is.null <- base::is.null
[17:43:55.396]                       muffled <- FALSE
[17:43:55.396]                       if (inherits(cond, "message")) {
[17:43:55.396]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.396]                         if (muffled) 
[17:43:55.396]                           invokeRestart("muffleMessage")
[17:43:55.396]                       }
[17:43:55.396]                       else if (inherits(cond, "warning")) {
[17:43:55.396]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.396]                         if (muffled) 
[17:43:55.396]                           invokeRestart("muffleWarning")
[17:43:55.396]                       }
[17:43:55.396]                       else if (inherits(cond, "condition")) {
[17:43:55.396]                         if (!is.null(pattern)) {
[17:43:55.396]                           computeRestarts <- base::computeRestarts
[17:43:55.396]                           grepl <- base::grepl
[17:43:55.396]                           restarts <- computeRestarts(cond)
[17:43:55.396]                           for (restart in restarts) {
[17:43:55.396]                             name <- restart$name
[17:43:55.396]                             if (is.null(name)) 
[17:43:55.396]                               next
[17:43:55.396]                             if (!grepl(pattern, name)) 
[17:43:55.396]                               next
[17:43:55.396]                             invokeRestart(restart)
[17:43:55.396]                             muffled <- TRUE
[17:43:55.396]                             break
[17:43:55.396]                           }
[17:43:55.396]                         }
[17:43:55.396]                       }
[17:43:55.396]                       invisible(muffled)
[17:43:55.396]                     }
[17:43:55.396]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.396]                   }
[17:43:55.396]                 }
[17:43:55.396]             }
[17:43:55.396]         }))
[17:43:55.396]     }, error = function(ex) {
[17:43:55.396]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:55.396]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.396]                 ...future.rng), started = ...future.startTime, 
[17:43:55.396]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:55.396]             version = "1.8"), class = "FutureResult")
[17:43:55.396]     }, finally = {
[17:43:55.396]         if (!identical(...future.workdir, getwd())) 
[17:43:55.396]             setwd(...future.workdir)
[17:43:55.396]         {
[17:43:55.396]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:55.396]                 ...future.oldOptions$nwarnings <- NULL
[17:43:55.396]             }
[17:43:55.396]             base::options(...future.oldOptions)
[17:43:55.396]             if (.Platform$OS.type == "windows") {
[17:43:55.396]                 old_names <- names(...future.oldEnvVars)
[17:43:55.396]                 envs <- base::Sys.getenv()
[17:43:55.396]                 names <- names(envs)
[17:43:55.396]                 common <- intersect(names, old_names)
[17:43:55.396]                 added <- setdiff(names, old_names)
[17:43:55.396]                 removed <- setdiff(old_names, names)
[17:43:55.396]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:55.396]                   envs[common]]
[17:43:55.396]                 NAMES <- toupper(changed)
[17:43:55.396]                 args <- list()
[17:43:55.396]                 for (kk in seq_along(NAMES)) {
[17:43:55.396]                   name <- changed[[kk]]
[17:43:55.396]                   NAME <- NAMES[[kk]]
[17:43:55.396]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.396]                     next
[17:43:55.396]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.396]                 }
[17:43:55.396]                 NAMES <- toupper(added)
[17:43:55.396]                 for (kk in seq_along(NAMES)) {
[17:43:55.396]                   name <- added[[kk]]
[17:43:55.396]                   NAME <- NAMES[[kk]]
[17:43:55.396]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.396]                     next
[17:43:55.396]                   args[[name]] <- ""
[17:43:55.396]                 }
[17:43:55.396]                 NAMES <- toupper(removed)
[17:43:55.396]                 for (kk in seq_along(NAMES)) {
[17:43:55.396]                   name <- removed[[kk]]
[17:43:55.396]                   NAME <- NAMES[[kk]]
[17:43:55.396]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.396]                     next
[17:43:55.396]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.396]                 }
[17:43:55.396]                 if (length(args) > 0) 
[17:43:55.396]                   base::do.call(base::Sys.setenv, args = args)
[17:43:55.396]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:55.396]             }
[17:43:55.396]             else {
[17:43:55.396]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:55.396]             }
[17:43:55.396]             {
[17:43:55.396]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:55.396]                   0L) {
[17:43:55.396]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:55.396]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:55.396]                   base::options(opts)
[17:43:55.396]                 }
[17:43:55.396]                 {
[17:43:55.396]                   {
[17:43:55.396]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:55.396]                     NULL
[17:43:55.396]                   }
[17:43:55.396]                   options(future.plan = NULL)
[17:43:55.396]                   if (is.na(NA_character_)) 
[17:43:55.396]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.396]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:55.396]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:55.396]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:55.396]                     envir = parent.frame()) 
[17:43:55.396]                   {
[17:43:55.396]                     if (is.function(workers)) 
[17:43:55.396]                       workers <- workers()
[17:43:55.396]                     workers <- structure(as.integer(workers), 
[17:43:55.396]                       class = class(workers))
[17:43:55.396]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:55.396]                       workers >= 1)
[17:43:55.396]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:55.396]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:55.396]                     }
[17:43:55.396]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:55.396]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:55.396]                       envir = envir)
[17:43:55.396]                     if (!future$lazy) 
[17:43:55.396]                       future <- run(future)
[17:43:55.396]                     invisible(future)
[17:43:55.396]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:55.396]                 }
[17:43:55.396]             }
[17:43:55.396]         }
[17:43:55.396]     })
[17:43:55.396]     if (TRUE) {
[17:43:55.396]         base::sink(type = "output", split = FALSE)
[17:43:55.396]         if (TRUE) {
[17:43:55.396]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:55.396]         }
[17:43:55.396]         else {
[17:43:55.396]             ...future.result["stdout"] <- base::list(NULL)
[17:43:55.396]         }
[17:43:55.396]         base::close(...future.stdout)
[17:43:55.396]         ...future.stdout <- NULL
[17:43:55.396]     }
[17:43:55.396]     ...future.result$conditions <- ...future.conditions
[17:43:55.396]     ...future.result$finished <- base::Sys.time()
[17:43:55.396]     ...future.result
[17:43:55.396] }
[17:43:55.399] MultisessionFuture started
[17:43:55.399] - Launch lazy future ... done
[17:43:55.400] run() for ‘MultisessionFuture’ ... done
[17:43:55.400] getGlobalsAndPackages() ...
[17:43:55.400] Searching for globals...
[17:43:55.401] - globals found: [1] ‘{’
[17:43:55.401] Searching for globals ... DONE
[17:43:55.401] Resolving globals: FALSE
[17:43:55.401] 
[17:43:55.401] 
[17:43:55.401] getGlobalsAndPackages() ... DONE
[17:43:55.402] run() for ‘Future’ ...
[17:43:55.402] - state: ‘created’
[17:43:55.402] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:55.417] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:55.417] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:55.417]   - Field: ‘node’
[17:43:55.417]   - Field: ‘label’
[17:43:55.417]   - Field: ‘local’
[17:43:55.417]   - Field: ‘owner’
[17:43:55.418]   - Field: ‘envir’
[17:43:55.418]   - Field: ‘workers’
[17:43:55.418]   - Field: ‘packages’
[17:43:55.418]   - Field: ‘gc’
[17:43:55.418]   - Field: ‘conditions’
[17:43:55.418]   - Field: ‘persistent’
[17:43:55.418]   - Field: ‘expr’
[17:43:55.418]   - Field: ‘uuid’
[17:43:55.418]   - Field: ‘seed’
[17:43:55.418]   - Field: ‘version’
[17:43:55.418]   - Field: ‘result’
[17:43:55.419]   - Field: ‘asynchronous’
[17:43:55.419]   - Field: ‘calls’
[17:43:55.419]   - Field: ‘globals’
[17:43:55.419]   - Field: ‘stdout’
[17:43:55.419]   - Field: ‘earlySignal’
[17:43:55.419]   - Field: ‘lazy’
[17:43:55.419]   - Field: ‘state’
[17:43:55.419] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:55.419] - Launch lazy future ...
[17:43:55.420] Packages needed by the future expression (n = 0): <none>
[17:43:55.420] Packages needed by future strategies (n = 0): <none>
[17:43:55.420] {
[17:43:55.420]     {
[17:43:55.420]         {
[17:43:55.420]             ...future.startTime <- base::Sys.time()
[17:43:55.420]             {
[17:43:55.420]                 {
[17:43:55.420]                   {
[17:43:55.420]                     {
[17:43:55.420]                       base::local({
[17:43:55.420]                         has_future <- base::requireNamespace("future", 
[17:43:55.420]                           quietly = TRUE)
[17:43:55.420]                         if (has_future) {
[17:43:55.420]                           ns <- base::getNamespace("future")
[17:43:55.420]                           version <- ns[[".package"]][["version"]]
[17:43:55.420]                           if (is.null(version)) 
[17:43:55.420]                             version <- utils::packageVersion("future")
[17:43:55.420]                         }
[17:43:55.420]                         else {
[17:43:55.420]                           version <- NULL
[17:43:55.420]                         }
[17:43:55.420]                         if (!has_future || version < "1.8.0") {
[17:43:55.420]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:55.420]                             "", base::R.version$version.string), 
[17:43:55.420]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:55.420]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:55.420]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:55.420]                               "release", "version")], collapse = " "), 
[17:43:55.420]                             hostname = base::Sys.info()[["nodename"]])
[17:43:55.420]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:55.420]                             info)
[17:43:55.420]                           info <- base::paste(info, collapse = "; ")
[17:43:55.420]                           if (!has_future) {
[17:43:55.420]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:55.420]                               info)
[17:43:55.420]                           }
[17:43:55.420]                           else {
[17:43:55.420]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:55.420]                               info, version)
[17:43:55.420]                           }
[17:43:55.420]                           base::stop(msg)
[17:43:55.420]                         }
[17:43:55.420]                       })
[17:43:55.420]                     }
[17:43:55.420]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:55.420]                     base::options(mc.cores = 1L)
[17:43:55.420]                   }
[17:43:55.420]                   options(future.plan = NULL)
[17:43:55.420]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.420]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:55.420]                 }
[17:43:55.420]                 ...future.workdir <- getwd()
[17:43:55.420]             }
[17:43:55.420]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:55.420]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:55.420]         }
[17:43:55.420]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:55.420]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:55.420]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:55.420]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:55.420]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:55.420]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:55.420]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:55.420]             base::names(...future.oldOptions))
[17:43:55.420]     }
[17:43:55.420]     if (FALSE) {
[17:43:55.420]     }
[17:43:55.420]     else {
[17:43:55.420]         if (TRUE) {
[17:43:55.420]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:55.420]                 open = "w")
[17:43:55.420]         }
[17:43:55.420]         else {
[17:43:55.420]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:55.420]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:55.420]         }
[17:43:55.420]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:55.420]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:55.420]             base::sink(type = "output", split = FALSE)
[17:43:55.420]             base::close(...future.stdout)
[17:43:55.420]         }, add = TRUE)
[17:43:55.420]     }
[17:43:55.420]     ...future.frame <- base::sys.nframe()
[17:43:55.420]     ...future.conditions <- base::list()
[17:43:55.420]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:55.420]     if (FALSE) {
[17:43:55.420]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:55.420]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:55.420]     }
[17:43:55.420]     ...future.result <- base::tryCatch({
[17:43:55.420]         base::withCallingHandlers({
[17:43:55.420]             ...future.value <- base::withVisible(base::local({
[17:43:55.420]                 ...future.makeSendCondition <- local({
[17:43:55.420]                   sendCondition <- NULL
[17:43:55.420]                   function(frame = 1L) {
[17:43:55.420]                     if (is.function(sendCondition)) 
[17:43:55.420]                       return(sendCondition)
[17:43:55.420]                     ns <- getNamespace("parallel")
[17:43:55.420]                     if (exists("sendData", mode = "function", 
[17:43:55.420]                       envir = ns)) {
[17:43:55.420]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:55.420]                         envir = ns)
[17:43:55.420]                       envir <- sys.frame(frame)
[17:43:55.420]                       master <- NULL
[17:43:55.420]                       while (!identical(envir, .GlobalEnv) && 
[17:43:55.420]                         !identical(envir, emptyenv())) {
[17:43:55.420]                         if (exists("master", mode = "list", envir = envir, 
[17:43:55.420]                           inherits = FALSE)) {
[17:43:55.420]                           master <- get("master", mode = "list", 
[17:43:55.420]                             envir = envir, inherits = FALSE)
[17:43:55.420]                           if (inherits(master, c("SOCKnode", 
[17:43:55.420]                             "SOCK0node"))) {
[17:43:55.420]                             sendCondition <<- function(cond) {
[17:43:55.420]                               data <- list(type = "VALUE", value = cond, 
[17:43:55.420]                                 success = TRUE)
[17:43:55.420]                               parallel_sendData(master, data)
[17:43:55.420]                             }
[17:43:55.420]                             return(sendCondition)
[17:43:55.420]                           }
[17:43:55.420]                         }
[17:43:55.420]                         frame <- frame + 1L
[17:43:55.420]                         envir <- sys.frame(frame)
[17:43:55.420]                       }
[17:43:55.420]                     }
[17:43:55.420]                     sendCondition <<- function(cond) NULL
[17:43:55.420]                   }
[17:43:55.420]                 })
[17:43:55.420]                 withCallingHandlers({
[17:43:55.420]                   {
[17:43:55.420]                     2
[17:43:55.420]                   }
[17:43:55.420]                 }, immediateCondition = function(cond) {
[17:43:55.420]                   sendCondition <- ...future.makeSendCondition()
[17:43:55.420]                   sendCondition(cond)
[17:43:55.420]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.420]                   {
[17:43:55.420]                     inherits <- base::inherits
[17:43:55.420]                     invokeRestart <- base::invokeRestart
[17:43:55.420]                     is.null <- base::is.null
[17:43:55.420]                     muffled <- FALSE
[17:43:55.420]                     if (inherits(cond, "message")) {
[17:43:55.420]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:55.420]                       if (muffled) 
[17:43:55.420]                         invokeRestart("muffleMessage")
[17:43:55.420]                     }
[17:43:55.420]                     else if (inherits(cond, "warning")) {
[17:43:55.420]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:55.420]                       if (muffled) 
[17:43:55.420]                         invokeRestart("muffleWarning")
[17:43:55.420]                     }
[17:43:55.420]                     else if (inherits(cond, "condition")) {
[17:43:55.420]                       if (!is.null(pattern)) {
[17:43:55.420]                         computeRestarts <- base::computeRestarts
[17:43:55.420]                         grepl <- base::grepl
[17:43:55.420]                         restarts <- computeRestarts(cond)
[17:43:55.420]                         for (restart in restarts) {
[17:43:55.420]                           name <- restart$name
[17:43:55.420]                           if (is.null(name)) 
[17:43:55.420]                             next
[17:43:55.420]                           if (!grepl(pattern, name)) 
[17:43:55.420]                             next
[17:43:55.420]                           invokeRestart(restart)
[17:43:55.420]                           muffled <- TRUE
[17:43:55.420]                           break
[17:43:55.420]                         }
[17:43:55.420]                       }
[17:43:55.420]                     }
[17:43:55.420]                     invisible(muffled)
[17:43:55.420]                   }
[17:43:55.420]                   muffleCondition(cond)
[17:43:55.420]                 })
[17:43:55.420]             }))
[17:43:55.420]             future::FutureResult(value = ...future.value$value, 
[17:43:55.420]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.420]                   ...future.rng), globalenv = if (FALSE) 
[17:43:55.420]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:55.420]                     ...future.globalenv.names))
[17:43:55.420]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:55.420]         }, condition = base::local({
[17:43:55.420]             c <- base::c
[17:43:55.420]             inherits <- base::inherits
[17:43:55.420]             invokeRestart <- base::invokeRestart
[17:43:55.420]             length <- base::length
[17:43:55.420]             list <- base::list
[17:43:55.420]             seq.int <- base::seq.int
[17:43:55.420]             signalCondition <- base::signalCondition
[17:43:55.420]             sys.calls <- base::sys.calls
[17:43:55.420]             `[[` <- base::`[[`
[17:43:55.420]             `+` <- base::`+`
[17:43:55.420]             `<<-` <- base::`<<-`
[17:43:55.420]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:55.420]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:55.420]                   3L)]
[17:43:55.420]             }
[17:43:55.420]             function(cond) {
[17:43:55.420]                 is_error <- inherits(cond, "error")
[17:43:55.420]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:55.420]                   NULL)
[17:43:55.420]                 if (is_error) {
[17:43:55.420]                   sessionInformation <- function() {
[17:43:55.420]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:55.420]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:55.420]                       search = base::search(), system = base::Sys.info())
[17:43:55.420]                   }
[17:43:55.420]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.420]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:55.420]                     cond$call), session = sessionInformation(), 
[17:43:55.420]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:55.420]                   signalCondition(cond)
[17:43:55.420]                 }
[17:43:55.420]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:55.420]                 "immediateCondition"))) {
[17:43:55.420]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:55.420]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.420]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:55.420]                   if (TRUE && !signal) {
[17:43:55.420]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.420]                     {
[17:43:55.420]                       inherits <- base::inherits
[17:43:55.420]                       invokeRestart <- base::invokeRestart
[17:43:55.420]                       is.null <- base::is.null
[17:43:55.420]                       muffled <- FALSE
[17:43:55.420]                       if (inherits(cond, "message")) {
[17:43:55.420]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.420]                         if (muffled) 
[17:43:55.420]                           invokeRestart("muffleMessage")
[17:43:55.420]                       }
[17:43:55.420]                       else if (inherits(cond, "warning")) {
[17:43:55.420]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.420]                         if (muffled) 
[17:43:55.420]                           invokeRestart("muffleWarning")
[17:43:55.420]                       }
[17:43:55.420]                       else if (inherits(cond, "condition")) {
[17:43:55.420]                         if (!is.null(pattern)) {
[17:43:55.420]                           computeRestarts <- base::computeRestarts
[17:43:55.420]                           grepl <- base::grepl
[17:43:55.420]                           restarts <- computeRestarts(cond)
[17:43:55.420]                           for (restart in restarts) {
[17:43:55.420]                             name <- restart$name
[17:43:55.420]                             if (is.null(name)) 
[17:43:55.420]                               next
[17:43:55.420]                             if (!grepl(pattern, name)) 
[17:43:55.420]                               next
[17:43:55.420]                             invokeRestart(restart)
[17:43:55.420]                             muffled <- TRUE
[17:43:55.420]                             break
[17:43:55.420]                           }
[17:43:55.420]                         }
[17:43:55.420]                       }
[17:43:55.420]                       invisible(muffled)
[17:43:55.420]                     }
[17:43:55.420]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.420]                   }
[17:43:55.420]                 }
[17:43:55.420]                 else {
[17:43:55.420]                   if (TRUE) {
[17:43:55.420]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.420]                     {
[17:43:55.420]                       inherits <- base::inherits
[17:43:55.420]                       invokeRestart <- base::invokeRestart
[17:43:55.420]                       is.null <- base::is.null
[17:43:55.420]                       muffled <- FALSE
[17:43:55.420]                       if (inherits(cond, "message")) {
[17:43:55.420]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.420]                         if (muffled) 
[17:43:55.420]                           invokeRestart("muffleMessage")
[17:43:55.420]                       }
[17:43:55.420]                       else if (inherits(cond, "warning")) {
[17:43:55.420]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.420]                         if (muffled) 
[17:43:55.420]                           invokeRestart("muffleWarning")
[17:43:55.420]                       }
[17:43:55.420]                       else if (inherits(cond, "condition")) {
[17:43:55.420]                         if (!is.null(pattern)) {
[17:43:55.420]                           computeRestarts <- base::computeRestarts
[17:43:55.420]                           grepl <- base::grepl
[17:43:55.420]                           restarts <- computeRestarts(cond)
[17:43:55.420]                           for (restart in restarts) {
[17:43:55.420]                             name <- restart$name
[17:43:55.420]                             if (is.null(name)) 
[17:43:55.420]                               next
[17:43:55.420]                             if (!grepl(pattern, name)) 
[17:43:55.420]                               next
[17:43:55.420]                             invokeRestart(restart)
[17:43:55.420]                             muffled <- TRUE
[17:43:55.420]                             break
[17:43:55.420]                           }
[17:43:55.420]                         }
[17:43:55.420]                       }
[17:43:55.420]                       invisible(muffled)
[17:43:55.420]                     }
[17:43:55.420]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.420]                   }
[17:43:55.420]                 }
[17:43:55.420]             }
[17:43:55.420]         }))
[17:43:55.420]     }, error = function(ex) {
[17:43:55.420]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:55.420]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.420]                 ...future.rng), started = ...future.startTime, 
[17:43:55.420]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:55.420]             version = "1.8"), class = "FutureResult")
[17:43:55.420]     }, finally = {
[17:43:55.420]         if (!identical(...future.workdir, getwd())) 
[17:43:55.420]             setwd(...future.workdir)
[17:43:55.420]         {
[17:43:55.420]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:55.420]                 ...future.oldOptions$nwarnings <- NULL
[17:43:55.420]             }
[17:43:55.420]             base::options(...future.oldOptions)
[17:43:55.420]             if (.Platform$OS.type == "windows") {
[17:43:55.420]                 old_names <- names(...future.oldEnvVars)
[17:43:55.420]                 envs <- base::Sys.getenv()
[17:43:55.420]                 names <- names(envs)
[17:43:55.420]                 common <- intersect(names, old_names)
[17:43:55.420]                 added <- setdiff(names, old_names)
[17:43:55.420]                 removed <- setdiff(old_names, names)
[17:43:55.420]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:55.420]                   envs[common]]
[17:43:55.420]                 NAMES <- toupper(changed)
[17:43:55.420]                 args <- list()
[17:43:55.420]                 for (kk in seq_along(NAMES)) {
[17:43:55.420]                   name <- changed[[kk]]
[17:43:55.420]                   NAME <- NAMES[[kk]]
[17:43:55.420]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.420]                     next
[17:43:55.420]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.420]                 }
[17:43:55.420]                 NAMES <- toupper(added)
[17:43:55.420]                 for (kk in seq_along(NAMES)) {
[17:43:55.420]                   name <- added[[kk]]
[17:43:55.420]                   NAME <- NAMES[[kk]]
[17:43:55.420]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.420]                     next
[17:43:55.420]                   args[[name]] <- ""
[17:43:55.420]                 }
[17:43:55.420]                 NAMES <- toupper(removed)
[17:43:55.420]                 for (kk in seq_along(NAMES)) {
[17:43:55.420]                   name <- removed[[kk]]
[17:43:55.420]                   NAME <- NAMES[[kk]]
[17:43:55.420]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.420]                     next
[17:43:55.420]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.420]                 }
[17:43:55.420]                 if (length(args) > 0) 
[17:43:55.420]                   base::do.call(base::Sys.setenv, args = args)
[17:43:55.420]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:55.420]             }
[17:43:55.420]             else {
[17:43:55.420]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:55.420]             }
[17:43:55.420]             {
[17:43:55.420]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:55.420]                   0L) {
[17:43:55.420]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:55.420]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:55.420]                   base::options(opts)
[17:43:55.420]                 }
[17:43:55.420]                 {
[17:43:55.420]                   {
[17:43:55.420]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:55.420]                     NULL
[17:43:55.420]                   }
[17:43:55.420]                   options(future.plan = NULL)
[17:43:55.420]                   if (is.na(NA_character_)) 
[17:43:55.420]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.420]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:55.420]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:55.420]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:55.420]                     envir = parent.frame()) 
[17:43:55.420]                   {
[17:43:55.420]                     if (is.function(workers)) 
[17:43:55.420]                       workers <- workers()
[17:43:55.420]                     workers <- structure(as.integer(workers), 
[17:43:55.420]                       class = class(workers))
[17:43:55.420]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:55.420]                       workers >= 1)
[17:43:55.420]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:55.420]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:55.420]                     }
[17:43:55.420]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:55.420]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:55.420]                       envir = envir)
[17:43:55.420]                     if (!future$lazy) 
[17:43:55.420]                       future <- run(future)
[17:43:55.420]                     invisible(future)
[17:43:55.420]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:55.420]                 }
[17:43:55.420]             }
[17:43:55.420]         }
[17:43:55.420]     })
[17:43:55.420]     if (TRUE) {
[17:43:55.420]         base::sink(type = "output", split = FALSE)
[17:43:55.420]         if (TRUE) {
[17:43:55.420]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:55.420]         }
[17:43:55.420]         else {
[17:43:55.420]             ...future.result["stdout"] <- base::list(NULL)
[17:43:55.420]         }
[17:43:55.420]         base::close(...future.stdout)
[17:43:55.420]         ...future.stdout <- NULL
[17:43:55.420]     }
[17:43:55.420]     ...future.result$conditions <- ...future.conditions
[17:43:55.420]     ...future.result$finished <- base::Sys.time()
[17:43:55.420]     ...future.result
[17:43:55.420] }
[17:43:55.424] MultisessionFuture started
[17:43:55.424] - Launch lazy future ... done
[17:43:55.424] run() for ‘MultisessionFuture’ ... done
[17:43:55.425] resolve() on environment ...
[17:43:55.425]  recursive: 0
[17:43:55.425]  elements: [3] ‘a’
[17:43:55.446]  length: 2 (resolved future 3)
[17:43:55.457] receiveMessageFromWorker() for ClusterFuture ...
[17:43:55.457] - Validating connection of MultisessionFuture
[17:43:55.457] - received message: FutureResult
[17:43:55.457] - Received FutureResult
[17:43:55.458] - Erased future from FutureRegistry
[17:43:55.458] result() for ClusterFuture ...
[17:43:55.458] - result already collected: FutureResult
[17:43:55.458] result() for ClusterFuture ... done
[17:43:55.458] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:55.458] Future #1
[17:43:55.458]  length: 1 (resolved future 1)
[17:43:55.479] receiveMessageFromWorker() for ClusterFuture ...
[17:43:55.480] - Validating connection of MultisessionFuture
[17:43:55.480] - received message: FutureResult
[17:43:55.480] - Received FutureResult
[17:43:55.480] - Erased future from FutureRegistry
[17:43:55.480] result() for ClusterFuture ...
[17:43:55.480] - result already collected: FutureResult
[17:43:55.480] result() for ClusterFuture ... done
[17:43:55.480] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:55.481] Future #2
[17:43:55.481]  length: 0 (resolved future 2)
[17:43:55.481] resolve() on environment ... DONE
[17:43:55.481] resolve() on environment ...
[17:43:55.481]  recursive: 0
[17:43:55.482]  elements: [3] ‘b’
[17:43:55.482] Future #1
[17:43:55.482]  length: 2 (resolved future 1)
[17:43:55.482] Future #2
[17:43:55.482]  length: 1 (resolved future 2)
[17:43:55.483]  length: 0 (resolved future 3)
[17:43:55.483] resolve() on environment ... DONE
[17:43:55.486] resolve() on environment ...
[17:43:55.486]  recursive: 0
[17:43:55.487]  elements: [3] ‘c’
[17:43:55.487] Future #1
[17:43:55.487]  length: 2 (resolved future 1)
[17:43:55.487] Future #2
[17:43:55.487]  length: 1 (resolved future 2)
[17:43:55.488]  length: 0 (resolved future 3)
[17:43:55.488] resolve() on environment ... DONE
[17:43:55.488] resolve() on environment ...
[17:43:55.488]  recursive: 0
[17:43:55.489]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[17:43:55.489] Future #1
[17:43:55.489] result() for ClusterFuture ...
[17:43:55.489] - result already collected: FutureResult
[17:43:55.489] result() for ClusterFuture ... done
[17:43:55.489] result() for ClusterFuture ...
[17:43:55.489] - result already collected: FutureResult
[17:43:55.489] result() for ClusterFuture ... done
[17:43:55.490]  length: 2 (resolved future 1)
[17:43:55.490] Future #2
[17:43:55.490] result() for ClusterFuture ...
[17:43:55.490] - result already collected: FutureResult
[17:43:55.490] result() for ClusterFuture ... done
[17:43:55.490] result() for ClusterFuture ...
[17:43:55.490] - result already collected: FutureResult
[17:43:55.490] result() for ClusterFuture ... done
[17:43:55.490]  length: 1 (resolved future 2)
[17:43:55.490]  length: 0 (resolved future 3)
[17:43:55.490] resolve() on environment ... DONE
[17:43:55.491] resolve() on environment ...
[17:43:55.491]  recursive: 99
[17:43:55.491]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[17:43:55.492] Future #1
[17:43:55.492] result() for ClusterFuture ...
[17:43:55.492] - result already collected: FutureResult
[17:43:55.492] result() for ClusterFuture ... done
[17:43:55.492] result() for ClusterFuture ...
[17:43:55.492] - result already collected: FutureResult
[17:43:55.492] result() for ClusterFuture ... done
[17:43:55.492] A MultisessionFuture was resolved
[17:43:55.492]  length: 2 (resolved future 1)
[17:43:55.492] Future #2
[17:43:55.493] result() for ClusterFuture ...
[17:43:55.493] - result already collected: FutureResult
[17:43:55.493] result() for ClusterFuture ... done
[17:43:55.493] result() for ClusterFuture ...
[17:43:55.493] - result already collected: FutureResult
[17:43:55.493] result() for ClusterFuture ... done
[17:43:55.493] A MultisessionFuture was resolved
[17:43:55.493]  length: 1 (resolved future 2)
[17:43:55.493]  length: 0 (resolved future 3)
[17:43:55.493] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[17:43:55.494] resolve() on list environment ...
[17:43:55.494]  recursive: 0
[17:43:55.495]  length: 2
[17:43:55.495]  elements: ‘a’, ‘b’
[17:43:55.495]  length: 1 (resolved future 1)
[17:43:55.495]  length: 0 (resolved future 2)
[17:43:55.495] resolve() on list environment ... DONE
[17:43:55.495] getGlobalsAndPackages() ...
[17:43:55.495] Searching for globals...
[17:43:55.496] 
[17:43:55.496] Searching for globals ... DONE
[17:43:55.496] - globals: [0] <none>
[17:43:55.496] getGlobalsAndPackages() ... DONE
[17:43:55.496] run() for ‘Future’ ...
[17:43:55.496] - state: ‘created’
[17:43:55.496] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:55.511] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:55.511] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:55.511]   - Field: ‘node’
[17:43:55.511]   - Field: ‘label’
[17:43:55.511]   - Field: ‘local’
[17:43:55.511]   - Field: ‘owner’
[17:43:55.512]   - Field: ‘envir’
[17:43:55.512]   - Field: ‘workers’
[17:43:55.512]   - Field: ‘packages’
[17:43:55.512]   - Field: ‘gc’
[17:43:55.512]   - Field: ‘conditions’
[17:43:55.512]   - Field: ‘persistent’
[17:43:55.512]   - Field: ‘expr’
[17:43:55.512]   - Field: ‘uuid’
[17:43:55.512]   - Field: ‘seed’
[17:43:55.512]   - Field: ‘version’
[17:43:55.513]   - Field: ‘result’
[17:43:55.513]   - Field: ‘asynchronous’
[17:43:55.513]   - Field: ‘calls’
[17:43:55.513]   - Field: ‘globals’
[17:43:55.513]   - Field: ‘stdout’
[17:43:55.513]   - Field: ‘earlySignal’
[17:43:55.513]   - Field: ‘lazy’
[17:43:55.513]   - Field: ‘state’
[17:43:55.513] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:55.513] - Launch lazy future ...
[17:43:55.514] Packages needed by the future expression (n = 0): <none>
[17:43:55.514] Packages needed by future strategies (n = 0): <none>
[17:43:55.514] {
[17:43:55.514]     {
[17:43:55.514]         {
[17:43:55.514]             ...future.startTime <- base::Sys.time()
[17:43:55.514]             {
[17:43:55.514]                 {
[17:43:55.514]                   {
[17:43:55.514]                     {
[17:43:55.514]                       base::local({
[17:43:55.514]                         has_future <- base::requireNamespace("future", 
[17:43:55.514]                           quietly = TRUE)
[17:43:55.514]                         if (has_future) {
[17:43:55.514]                           ns <- base::getNamespace("future")
[17:43:55.514]                           version <- ns[[".package"]][["version"]]
[17:43:55.514]                           if (is.null(version)) 
[17:43:55.514]                             version <- utils::packageVersion("future")
[17:43:55.514]                         }
[17:43:55.514]                         else {
[17:43:55.514]                           version <- NULL
[17:43:55.514]                         }
[17:43:55.514]                         if (!has_future || version < "1.8.0") {
[17:43:55.514]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:55.514]                             "", base::R.version$version.string), 
[17:43:55.514]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:55.514]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:55.514]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:55.514]                               "release", "version")], collapse = " "), 
[17:43:55.514]                             hostname = base::Sys.info()[["nodename"]])
[17:43:55.514]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:55.514]                             info)
[17:43:55.514]                           info <- base::paste(info, collapse = "; ")
[17:43:55.514]                           if (!has_future) {
[17:43:55.514]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:55.514]                               info)
[17:43:55.514]                           }
[17:43:55.514]                           else {
[17:43:55.514]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:55.514]                               info, version)
[17:43:55.514]                           }
[17:43:55.514]                           base::stop(msg)
[17:43:55.514]                         }
[17:43:55.514]                       })
[17:43:55.514]                     }
[17:43:55.514]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:55.514]                     base::options(mc.cores = 1L)
[17:43:55.514]                   }
[17:43:55.514]                   options(future.plan = NULL)
[17:43:55.514]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.514]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:55.514]                 }
[17:43:55.514]                 ...future.workdir <- getwd()
[17:43:55.514]             }
[17:43:55.514]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:55.514]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:55.514]         }
[17:43:55.514]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:55.514]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:55.514]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:55.514]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:55.514]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:55.514]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:55.514]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:55.514]             base::names(...future.oldOptions))
[17:43:55.514]     }
[17:43:55.514]     if (FALSE) {
[17:43:55.514]     }
[17:43:55.514]     else {
[17:43:55.514]         if (TRUE) {
[17:43:55.514]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:55.514]                 open = "w")
[17:43:55.514]         }
[17:43:55.514]         else {
[17:43:55.514]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:55.514]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:55.514]         }
[17:43:55.514]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:55.514]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:55.514]             base::sink(type = "output", split = FALSE)
[17:43:55.514]             base::close(...future.stdout)
[17:43:55.514]         }, add = TRUE)
[17:43:55.514]     }
[17:43:55.514]     ...future.frame <- base::sys.nframe()
[17:43:55.514]     ...future.conditions <- base::list()
[17:43:55.514]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:55.514]     if (FALSE) {
[17:43:55.514]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:55.514]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:55.514]     }
[17:43:55.514]     ...future.result <- base::tryCatch({
[17:43:55.514]         base::withCallingHandlers({
[17:43:55.514]             ...future.value <- base::withVisible(base::local({
[17:43:55.514]                 ...future.makeSendCondition <- local({
[17:43:55.514]                   sendCondition <- NULL
[17:43:55.514]                   function(frame = 1L) {
[17:43:55.514]                     if (is.function(sendCondition)) 
[17:43:55.514]                       return(sendCondition)
[17:43:55.514]                     ns <- getNamespace("parallel")
[17:43:55.514]                     if (exists("sendData", mode = "function", 
[17:43:55.514]                       envir = ns)) {
[17:43:55.514]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:55.514]                         envir = ns)
[17:43:55.514]                       envir <- sys.frame(frame)
[17:43:55.514]                       master <- NULL
[17:43:55.514]                       while (!identical(envir, .GlobalEnv) && 
[17:43:55.514]                         !identical(envir, emptyenv())) {
[17:43:55.514]                         if (exists("master", mode = "list", envir = envir, 
[17:43:55.514]                           inherits = FALSE)) {
[17:43:55.514]                           master <- get("master", mode = "list", 
[17:43:55.514]                             envir = envir, inherits = FALSE)
[17:43:55.514]                           if (inherits(master, c("SOCKnode", 
[17:43:55.514]                             "SOCK0node"))) {
[17:43:55.514]                             sendCondition <<- function(cond) {
[17:43:55.514]                               data <- list(type = "VALUE", value = cond, 
[17:43:55.514]                                 success = TRUE)
[17:43:55.514]                               parallel_sendData(master, data)
[17:43:55.514]                             }
[17:43:55.514]                             return(sendCondition)
[17:43:55.514]                           }
[17:43:55.514]                         }
[17:43:55.514]                         frame <- frame + 1L
[17:43:55.514]                         envir <- sys.frame(frame)
[17:43:55.514]                       }
[17:43:55.514]                     }
[17:43:55.514]                     sendCondition <<- function(cond) NULL
[17:43:55.514]                   }
[17:43:55.514]                 })
[17:43:55.514]                 withCallingHandlers({
[17:43:55.514]                   1
[17:43:55.514]                 }, immediateCondition = function(cond) {
[17:43:55.514]                   sendCondition <- ...future.makeSendCondition()
[17:43:55.514]                   sendCondition(cond)
[17:43:55.514]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.514]                   {
[17:43:55.514]                     inherits <- base::inherits
[17:43:55.514]                     invokeRestart <- base::invokeRestart
[17:43:55.514]                     is.null <- base::is.null
[17:43:55.514]                     muffled <- FALSE
[17:43:55.514]                     if (inherits(cond, "message")) {
[17:43:55.514]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:55.514]                       if (muffled) 
[17:43:55.514]                         invokeRestart("muffleMessage")
[17:43:55.514]                     }
[17:43:55.514]                     else if (inherits(cond, "warning")) {
[17:43:55.514]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:55.514]                       if (muffled) 
[17:43:55.514]                         invokeRestart("muffleWarning")
[17:43:55.514]                     }
[17:43:55.514]                     else if (inherits(cond, "condition")) {
[17:43:55.514]                       if (!is.null(pattern)) {
[17:43:55.514]                         computeRestarts <- base::computeRestarts
[17:43:55.514]                         grepl <- base::grepl
[17:43:55.514]                         restarts <- computeRestarts(cond)
[17:43:55.514]                         for (restart in restarts) {
[17:43:55.514]                           name <- restart$name
[17:43:55.514]                           if (is.null(name)) 
[17:43:55.514]                             next
[17:43:55.514]                           if (!grepl(pattern, name)) 
[17:43:55.514]                             next
[17:43:55.514]                           invokeRestart(restart)
[17:43:55.514]                           muffled <- TRUE
[17:43:55.514]                           break
[17:43:55.514]                         }
[17:43:55.514]                       }
[17:43:55.514]                     }
[17:43:55.514]                     invisible(muffled)
[17:43:55.514]                   }
[17:43:55.514]                   muffleCondition(cond)
[17:43:55.514]                 })
[17:43:55.514]             }))
[17:43:55.514]             future::FutureResult(value = ...future.value$value, 
[17:43:55.514]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.514]                   ...future.rng), globalenv = if (FALSE) 
[17:43:55.514]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:55.514]                     ...future.globalenv.names))
[17:43:55.514]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:55.514]         }, condition = base::local({
[17:43:55.514]             c <- base::c
[17:43:55.514]             inherits <- base::inherits
[17:43:55.514]             invokeRestart <- base::invokeRestart
[17:43:55.514]             length <- base::length
[17:43:55.514]             list <- base::list
[17:43:55.514]             seq.int <- base::seq.int
[17:43:55.514]             signalCondition <- base::signalCondition
[17:43:55.514]             sys.calls <- base::sys.calls
[17:43:55.514]             `[[` <- base::`[[`
[17:43:55.514]             `+` <- base::`+`
[17:43:55.514]             `<<-` <- base::`<<-`
[17:43:55.514]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:55.514]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:55.514]                   3L)]
[17:43:55.514]             }
[17:43:55.514]             function(cond) {
[17:43:55.514]                 is_error <- inherits(cond, "error")
[17:43:55.514]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:55.514]                   NULL)
[17:43:55.514]                 if (is_error) {
[17:43:55.514]                   sessionInformation <- function() {
[17:43:55.514]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:55.514]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:55.514]                       search = base::search(), system = base::Sys.info())
[17:43:55.514]                   }
[17:43:55.514]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.514]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:55.514]                     cond$call), session = sessionInformation(), 
[17:43:55.514]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:55.514]                   signalCondition(cond)
[17:43:55.514]                 }
[17:43:55.514]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:55.514]                 "immediateCondition"))) {
[17:43:55.514]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:55.514]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.514]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:55.514]                   if (TRUE && !signal) {
[17:43:55.514]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.514]                     {
[17:43:55.514]                       inherits <- base::inherits
[17:43:55.514]                       invokeRestart <- base::invokeRestart
[17:43:55.514]                       is.null <- base::is.null
[17:43:55.514]                       muffled <- FALSE
[17:43:55.514]                       if (inherits(cond, "message")) {
[17:43:55.514]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.514]                         if (muffled) 
[17:43:55.514]                           invokeRestart("muffleMessage")
[17:43:55.514]                       }
[17:43:55.514]                       else if (inherits(cond, "warning")) {
[17:43:55.514]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.514]                         if (muffled) 
[17:43:55.514]                           invokeRestart("muffleWarning")
[17:43:55.514]                       }
[17:43:55.514]                       else if (inherits(cond, "condition")) {
[17:43:55.514]                         if (!is.null(pattern)) {
[17:43:55.514]                           computeRestarts <- base::computeRestarts
[17:43:55.514]                           grepl <- base::grepl
[17:43:55.514]                           restarts <- computeRestarts(cond)
[17:43:55.514]                           for (restart in restarts) {
[17:43:55.514]                             name <- restart$name
[17:43:55.514]                             if (is.null(name)) 
[17:43:55.514]                               next
[17:43:55.514]                             if (!grepl(pattern, name)) 
[17:43:55.514]                               next
[17:43:55.514]                             invokeRestart(restart)
[17:43:55.514]                             muffled <- TRUE
[17:43:55.514]                             break
[17:43:55.514]                           }
[17:43:55.514]                         }
[17:43:55.514]                       }
[17:43:55.514]                       invisible(muffled)
[17:43:55.514]                     }
[17:43:55.514]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.514]                   }
[17:43:55.514]                 }
[17:43:55.514]                 else {
[17:43:55.514]                   if (TRUE) {
[17:43:55.514]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.514]                     {
[17:43:55.514]                       inherits <- base::inherits
[17:43:55.514]                       invokeRestart <- base::invokeRestart
[17:43:55.514]                       is.null <- base::is.null
[17:43:55.514]                       muffled <- FALSE
[17:43:55.514]                       if (inherits(cond, "message")) {
[17:43:55.514]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.514]                         if (muffled) 
[17:43:55.514]                           invokeRestart("muffleMessage")
[17:43:55.514]                       }
[17:43:55.514]                       else if (inherits(cond, "warning")) {
[17:43:55.514]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.514]                         if (muffled) 
[17:43:55.514]                           invokeRestart("muffleWarning")
[17:43:55.514]                       }
[17:43:55.514]                       else if (inherits(cond, "condition")) {
[17:43:55.514]                         if (!is.null(pattern)) {
[17:43:55.514]                           computeRestarts <- base::computeRestarts
[17:43:55.514]                           grepl <- base::grepl
[17:43:55.514]                           restarts <- computeRestarts(cond)
[17:43:55.514]                           for (restart in restarts) {
[17:43:55.514]                             name <- restart$name
[17:43:55.514]                             if (is.null(name)) 
[17:43:55.514]                               next
[17:43:55.514]                             if (!grepl(pattern, name)) 
[17:43:55.514]                               next
[17:43:55.514]                             invokeRestart(restart)
[17:43:55.514]                             muffled <- TRUE
[17:43:55.514]                             break
[17:43:55.514]                           }
[17:43:55.514]                         }
[17:43:55.514]                       }
[17:43:55.514]                       invisible(muffled)
[17:43:55.514]                     }
[17:43:55.514]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.514]                   }
[17:43:55.514]                 }
[17:43:55.514]             }
[17:43:55.514]         }))
[17:43:55.514]     }, error = function(ex) {
[17:43:55.514]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:55.514]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.514]                 ...future.rng), started = ...future.startTime, 
[17:43:55.514]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:55.514]             version = "1.8"), class = "FutureResult")
[17:43:55.514]     }, finally = {
[17:43:55.514]         if (!identical(...future.workdir, getwd())) 
[17:43:55.514]             setwd(...future.workdir)
[17:43:55.514]         {
[17:43:55.514]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:55.514]                 ...future.oldOptions$nwarnings <- NULL
[17:43:55.514]             }
[17:43:55.514]             base::options(...future.oldOptions)
[17:43:55.514]             if (.Platform$OS.type == "windows") {
[17:43:55.514]                 old_names <- names(...future.oldEnvVars)
[17:43:55.514]                 envs <- base::Sys.getenv()
[17:43:55.514]                 names <- names(envs)
[17:43:55.514]                 common <- intersect(names, old_names)
[17:43:55.514]                 added <- setdiff(names, old_names)
[17:43:55.514]                 removed <- setdiff(old_names, names)
[17:43:55.514]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:55.514]                   envs[common]]
[17:43:55.514]                 NAMES <- toupper(changed)
[17:43:55.514]                 args <- list()
[17:43:55.514]                 for (kk in seq_along(NAMES)) {
[17:43:55.514]                   name <- changed[[kk]]
[17:43:55.514]                   NAME <- NAMES[[kk]]
[17:43:55.514]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.514]                     next
[17:43:55.514]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.514]                 }
[17:43:55.514]                 NAMES <- toupper(added)
[17:43:55.514]                 for (kk in seq_along(NAMES)) {
[17:43:55.514]                   name <- added[[kk]]
[17:43:55.514]                   NAME <- NAMES[[kk]]
[17:43:55.514]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.514]                     next
[17:43:55.514]                   args[[name]] <- ""
[17:43:55.514]                 }
[17:43:55.514]                 NAMES <- toupper(removed)
[17:43:55.514]                 for (kk in seq_along(NAMES)) {
[17:43:55.514]                   name <- removed[[kk]]
[17:43:55.514]                   NAME <- NAMES[[kk]]
[17:43:55.514]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.514]                     next
[17:43:55.514]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.514]                 }
[17:43:55.514]                 if (length(args) > 0) 
[17:43:55.514]                   base::do.call(base::Sys.setenv, args = args)
[17:43:55.514]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:55.514]             }
[17:43:55.514]             else {
[17:43:55.514]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:55.514]             }
[17:43:55.514]             {
[17:43:55.514]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:55.514]                   0L) {
[17:43:55.514]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:55.514]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:55.514]                   base::options(opts)
[17:43:55.514]                 }
[17:43:55.514]                 {
[17:43:55.514]                   {
[17:43:55.514]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:55.514]                     NULL
[17:43:55.514]                   }
[17:43:55.514]                   options(future.plan = NULL)
[17:43:55.514]                   if (is.na(NA_character_)) 
[17:43:55.514]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.514]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:55.514]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:55.514]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:55.514]                     envir = parent.frame()) 
[17:43:55.514]                   {
[17:43:55.514]                     if (is.function(workers)) 
[17:43:55.514]                       workers <- workers()
[17:43:55.514]                     workers <- structure(as.integer(workers), 
[17:43:55.514]                       class = class(workers))
[17:43:55.514]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:55.514]                       workers >= 1)
[17:43:55.514]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:55.514]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:55.514]                     }
[17:43:55.514]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:55.514]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:55.514]                       envir = envir)
[17:43:55.514]                     if (!future$lazy) 
[17:43:55.514]                       future <- run(future)
[17:43:55.514]                     invisible(future)
[17:43:55.514]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:55.514]                 }
[17:43:55.514]             }
[17:43:55.514]         }
[17:43:55.514]     })
[17:43:55.514]     if (TRUE) {
[17:43:55.514]         base::sink(type = "output", split = FALSE)
[17:43:55.514]         if (TRUE) {
[17:43:55.514]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:55.514]         }
[17:43:55.514]         else {
[17:43:55.514]             ...future.result["stdout"] <- base::list(NULL)
[17:43:55.514]         }
[17:43:55.514]         base::close(...future.stdout)
[17:43:55.514]         ...future.stdout <- NULL
[17:43:55.514]     }
[17:43:55.514]     ...future.result$conditions <- ...future.conditions
[17:43:55.514]     ...future.result$finished <- base::Sys.time()
[17:43:55.514]     ...future.result
[17:43:55.514] }
[17:43:55.517] MultisessionFuture started
[17:43:55.518] - Launch lazy future ... done
[17:43:55.518] run() for ‘MultisessionFuture’ ... done
[17:43:55.518] getGlobalsAndPackages() ...
[17:43:55.518] Searching for globals...
[17:43:55.518] 
[17:43:55.518] Searching for globals ... DONE
[17:43:55.519] - globals: [0] <none>
[17:43:55.519] getGlobalsAndPackages() ... DONE
[17:43:55.519] run() for ‘Future’ ...
[17:43:55.519] - state: ‘created’
[17:43:55.519] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:55.534] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:55.535] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:55.535]   - Field: ‘node’
[17:43:55.535]   - Field: ‘label’
[17:43:55.535]   - Field: ‘local’
[17:43:55.535]   - Field: ‘owner’
[17:43:55.535]   - Field: ‘envir’
[17:43:55.535]   - Field: ‘workers’
[17:43:55.536]   - Field: ‘packages’
[17:43:55.536]   - Field: ‘gc’
[17:43:55.536]   - Field: ‘conditions’
[17:43:55.536]   - Field: ‘persistent’
[17:43:55.536]   - Field: ‘expr’
[17:43:55.536]   - Field: ‘uuid’
[17:43:55.536]   - Field: ‘seed’
[17:43:55.536]   - Field: ‘version’
[17:43:55.536]   - Field: ‘result’
[17:43:55.536]   - Field: ‘asynchronous’
[17:43:55.536]   - Field: ‘calls’
[17:43:55.537]   - Field: ‘globals’
[17:43:55.537]   - Field: ‘stdout’
[17:43:55.537]   - Field: ‘earlySignal’
[17:43:55.537]   - Field: ‘lazy’
[17:43:55.537]   - Field: ‘state’
[17:43:55.537] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:55.537] - Launch lazy future ...
[17:43:55.537] Packages needed by the future expression (n = 0): <none>
[17:43:55.538] Packages needed by future strategies (n = 0): <none>
[17:43:55.538] {
[17:43:55.538]     {
[17:43:55.538]         {
[17:43:55.538]             ...future.startTime <- base::Sys.time()
[17:43:55.538]             {
[17:43:55.538]                 {
[17:43:55.538]                   {
[17:43:55.538]                     {
[17:43:55.538]                       base::local({
[17:43:55.538]                         has_future <- base::requireNamespace("future", 
[17:43:55.538]                           quietly = TRUE)
[17:43:55.538]                         if (has_future) {
[17:43:55.538]                           ns <- base::getNamespace("future")
[17:43:55.538]                           version <- ns[[".package"]][["version"]]
[17:43:55.538]                           if (is.null(version)) 
[17:43:55.538]                             version <- utils::packageVersion("future")
[17:43:55.538]                         }
[17:43:55.538]                         else {
[17:43:55.538]                           version <- NULL
[17:43:55.538]                         }
[17:43:55.538]                         if (!has_future || version < "1.8.0") {
[17:43:55.538]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:55.538]                             "", base::R.version$version.string), 
[17:43:55.538]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:55.538]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:55.538]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:55.538]                               "release", "version")], collapse = " "), 
[17:43:55.538]                             hostname = base::Sys.info()[["nodename"]])
[17:43:55.538]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:55.538]                             info)
[17:43:55.538]                           info <- base::paste(info, collapse = "; ")
[17:43:55.538]                           if (!has_future) {
[17:43:55.538]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:55.538]                               info)
[17:43:55.538]                           }
[17:43:55.538]                           else {
[17:43:55.538]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:55.538]                               info, version)
[17:43:55.538]                           }
[17:43:55.538]                           base::stop(msg)
[17:43:55.538]                         }
[17:43:55.538]                       })
[17:43:55.538]                     }
[17:43:55.538]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:55.538]                     base::options(mc.cores = 1L)
[17:43:55.538]                   }
[17:43:55.538]                   options(future.plan = NULL)
[17:43:55.538]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.538]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:55.538]                 }
[17:43:55.538]                 ...future.workdir <- getwd()
[17:43:55.538]             }
[17:43:55.538]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:55.538]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:55.538]         }
[17:43:55.538]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:55.538]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:55.538]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:55.538]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:55.538]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:55.538]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:55.538]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:55.538]             base::names(...future.oldOptions))
[17:43:55.538]     }
[17:43:55.538]     if (FALSE) {
[17:43:55.538]     }
[17:43:55.538]     else {
[17:43:55.538]         if (TRUE) {
[17:43:55.538]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:55.538]                 open = "w")
[17:43:55.538]         }
[17:43:55.538]         else {
[17:43:55.538]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:55.538]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:55.538]         }
[17:43:55.538]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:55.538]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:55.538]             base::sink(type = "output", split = FALSE)
[17:43:55.538]             base::close(...future.stdout)
[17:43:55.538]         }, add = TRUE)
[17:43:55.538]     }
[17:43:55.538]     ...future.frame <- base::sys.nframe()
[17:43:55.538]     ...future.conditions <- base::list()
[17:43:55.538]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:55.538]     if (FALSE) {
[17:43:55.538]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:55.538]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:55.538]     }
[17:43:55.538]     ...future.result <- base::tryCatch({
[17:43:55.538]         base::withCallingHandlers({
[17:43:55.538]             ...future.value <- base::withVisible(base::local({
[17:43:55.538]                 ...future.makeSendCondition <- local({
[17:43:55.538]                   sendCondition <- NULL
[17:43:55.538]                   function(frame = 1L) {
[17:43:55.538]                     if (is.function(sendCondition)) 
[17:43:55.538]                       return(sendCondition)
[17:43:55.538]                     ns <- getNamespace("parallel")
[17:43:55.538]                     if (exists("sendData", mode = "function", 
[17:43:55.538]                       envir = ns)) {
[17:43:55.538]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:55.538]                         envir = ns)
[17:43:55.538]                       envir <- sys.frame(frame)
[17:43:55.538]                       master <- NULL
[17:43:55.538]                       while (!identical(envir, .GlobalEnv) && 
[17:43:55.538]                         !identical(envir, emptyenv())) {
[17:43:55.538]                         if (exists("master", mode = "list", envir = envir, 
[17:43:55.538]                           inherits = FALSE)) {
[17:43:55.538]                           master <- get("master", mode = "list", 
[17:43:55.538]                             envir = envir, inherits = FALSE)
[17:43:55.538]                           if (inherits(master, c("SOCKnode", 
[17:43:55.538]                             "SOCK0node"))) {
[17:43:55.538]                             sendCondition <<- function(cond) {
[17:43:55.538]                               data <- list(type = "VALUE", value = cond, 
[17:43:55.538]                                 success = TRUE)
[17:43:55.538]                               parallel_sendData(master, data)
[17:43:55.538]                             }
[17:43:55.538]                             return(sendCondition)
[17:43:55.538]                           }
[17:43:55.538]                         }
[17:43:55.538]                         frame <- frame + 1L
[17:43:55.538]                         envir <- sys.frame(frame)
[17:43:55.538]                       }
[17:43:55.538]                     }
[17:43:55.538]                     sendCondition <<- function(cond) NULL
[17:43:55.538]                   }
[17:43:55.538]                 })
[17:43:55.538]                 withCallingHandlers({
[17:43:55.538]                   2
[17:43:55.538]                 }, immediateCondition = function(cond) {
[17:43:55.538]                   sendCondition <- ...future.makeSendCondition()
[17:43:55.538]                   sendCondition(cond)
[17:43:55.538]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.538]                   {
[17:43:55.538]                     inherits <- base::inherits
[17:43:55.538]                     invokeRestart <- base::invokeRestart
[17:43:55.538]                     is.null <- base::is.null
[17:43:55.538]                     muffled <- FALSE
[17:43:55.538]                     if (inherits(cond, "message")) {
[17:43:55.538]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:55.538]                       if (muffled) 
[17:43:55.538]                         invokeRestart("muffleMessage")
[17:43:55.538]                     }
[17:43:55.538]                     else if (inherits(cond, "warning")) {
[17:43:55.538]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:55.538]                       if (muffled) 
[17:43:55.538]                         invokeRestart("muffleWarning")
[17:43:55.538]                     }
[17:43:55.538]                     else if (inherits(cond, "condition")) {
[17:43:55.538]                       if (!is.null(pattern)) {
[17:43:55.538]                         computeRestarts <- base::computeRestarts
[17:43:55.538]                         grepl <- base::grepl
[17:43:55.538]                         restarts <- computeRestarts(cond)
[17:43:55.538]                         for (restart in restarts) {
[17:43:55.538]                           name <- restart$name
[17:43:55.538]                           if (is.null(name)) 
[17:43:55.538]                             next
[17:43:55.538]                           if (!grepl(pattern, name)) 
[17:43:55.538]                             next
[17:43:55.538]                           invokeRestart(restart)
[17:43:55.538]                           muffled <- TRUE
[17:43:55.538]                           break
[17:43:55.538]                         }
[17:43:55.538]                       }
[17:43:55.538]                     }
[17:43:55.538]                     invisible(muffled)
[17:43:55.538]                   }
[17:43:55.538]                   muffleCondition(cond)
[17:43:55.538]                 })
[17:43:55.538]             }))
[17:43:55.538]             future::FutureResult(value = ...future.value$value, 
[17:43:55.538]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.538]                   ...future.rng), globalenv = if (FALSE) 
[17:43:55.538]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:55.538]                     ...future.globalenv.names))
[17:43:55.538]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:55.538]         }, condition = base::local({
[17:43:55.538]             c <- base::c
[17:43:55.538]             inherits <- base::inherits
[17:43:55.538]             invokeRestart <- base::invokeRestart
[17:43:55.538]             length <- base::length
[17:43:55.538]             list <- base::list
[17:43:55.538]             seq.int <- base::seq.int
[17:43:55.538]             signalCondition <- base::signalCondition
[17:43:55.538]             sys.calls <- base::sys.calls
[17:43:55.538]             `[[` <- base::`[[`
[17:43:55.538]             `+` <- base::`+`
[17:43:55.538]             `<<-` <- base::`<<-`
[17:43:55.538]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:55.538]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:55.538]                   3L)]
[17:43:55.538]             }
[17:43:55.538]             function(cond) {
[17:43:55.538]                 is_error <- inherits(cond, "error")
[17:43:55.538]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:55.538]                   NULL)
[17:43:55.538]                 if (is_error) {
[17:43:55.538]                   sessionInformation <- function() {
[17:43:55.538]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:55.538]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:55.538]                       search = base::search(), system = base::Sys.info())
[17:43:55.538]                   }
[17:43:55.538]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.538]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:55.538]                     cond$call), session = sessionInformation(), 
[17:43:55.538]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:55.538]                   signalCondition(cond)
[17:43:55.538]                 }
[17:43:55.538]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:55.538]                 "immediateCondition"))) {
[17:43:55.538]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:55.538]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.538]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:55.538]                   if (TRUE && !signal) {
[17:43:55.538]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.538]                     {
[17:43:55.538]                       inherits <- base::inherits
[17:43:55.538]                       invokeRestart <- base::invokeRestart
[17:43:55.538]                       is.null <- base::is.null
[17:43:55.538]                       muffled <- FALSE
[17:43:55.538]                       if (inherits(cond, "message")) {
[17:43:55.538]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.538]                         if (muffled) 
[17:43:55.538]                           invokeRestart("muffleMessage")
[17:43:55.538]                       }
[17:43:55.538]                       else if (inherits(cond, "warning")) {
[17:43:55.538]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.538]                         if (muffled) 
[17:43:55.538]                           invokeRestart("muffleWarning")
[17:43:55.538]                       }
[17:43:55.538]                       else if (inherits(cond, "condition")) {
[17:43:55.538]                         if (!is.null(pattern)) {
[17:43:55.538]                           computeRestarts <- base::computeRestarts
[17:43:55.538]                           grepl <- base::grepl
[17:43:55.538]                           restarts <- computeRestarts(cond)
[17:43:55.538]                           for (restart in restarts) {
[17:43:55.538]                             name <- restart$name
[17:43:55.538]                             if (is.null(name)) 
[17:43:55.538]                               next
[17:43:55.538]                             if (!grepl(pattern, name)) 
[17:43:55.538]                               next
[17:43:55.538]                             invokeRestart(restart)
[17:43:55.538]                             muffled <- TRUE
[17:43:55.538]                             break
[17:43:55.538]                           }
[17:43:55.538]                         }
[17:43:55.538]                       }
[17:43:55.538]                       invisible(muffled)
[17:43:55.538]                     }
[17:43:55.538]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.538]                   }
[17:43:55.538]                 }
[17:43:55.538]                 else {
[17:43:55.538]                   if (TRUE) {
[17:43:55.538]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.538]                     {
[17:43:55.538]                       inherits <- base::inherits
[17:43:55.538]                       invokeRestart <- base::invokeRestart
[17:43:55.538]                       is.null <- base::is.null
[17:43:55.538]                       muffled <- FALSE
[17:43:55.538]                       if (inherits(cond, "message")) {
[17:43:55.538]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.538]                         if (muffled) 
[17:43:55.538]                           invokeRestart("muffleMessage")
[17:43:55.538]                       }
[17:43:55.538]                       else if (inherits(cond, "warning")) {
[17:43:55.538]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.538]                         if (muffled) 
[17:43:55.538]                           invokeRestart("muffleWarning")
[17:43:55.538]                       }
[17:43:55.538]                       else if (inherits(cond, "condition")) {
[17:43:55.538]                         if (!is.null(pattern)) {
[17:43:55.538]                           computeRestarts <- base::computeRestarts
[17:43:55.538]                           grepl <- base::grepl
[17:43:55.538]                           restarts <- computeRestarts(cond)
[17:43:55.538]                           for (restart in restarts) {
[17:43:55.538]                             name <- restart$name
[17:43:55.538]                             if (is.null(name)) 
[17:43:55.538]                               next
[17:43:55.538]                             if (!grepl(pattern, name)) 
[17:43:55.538]                               next
[17:43:55.538]                             invokeRestart(restart)
[17:43:55.538]                             muffled <- TRUE
[17:43:55.538]                             break
[17:43:55.538]                           }
[17:43:55.538]                         }
[17:43:55.538]                       }
[17:43:55.538]                       invisible(muffled)
[17:43:55.538]                     }
[17:43:55.538]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.538]                   }
[17:43:55.538]                 }
[17:43:55.538]             }
[17:43:55.538]         }))
[17:43:55.538]     }, error = function(ex) {
[17:43:55.538]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:55.538]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.538]                 ...future.rng), started = ...future.startTime, 
[17:43:55.538]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:55.538]             version = "1.8"), class = "FutureResult")
[17:43:55.538]     }, finally = {
[17:43:55.538]         if (!identical(...future.workdir, getwd())) 
[17:43:55.538]             setwd(...future.workdir)
[17:43:55.538]         {
[17:43:55.538]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:55.538]                 ...future.oldOptions$nwarnings <- NULL
[17:43:55.538]             }
[17:43:55.538]             base::options(...future.oldOptions)
[17:43:55.538]             if (.Platform$OS.type == "windows") {
[17:43:55.538]                 old_names <- names(...future.oldEnvVars)
[17:43:55.538]                 envs <- base::Sys.getenv()
[17:43:55.538]                 names <- names(envs)
[17:43:55.538]                 common <- intersect(names, old_names)
[17:43:55.538]                 added <- setdiff(names, old_names)
[17:43:55.538]                 removed <- setdiff(old_names, names)
[17:43:55.538]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:55.538]                   envs[common]]
[17:43:55.538]                 NAMES <- toupper(changed)
[17:43:55.538]                 args <- list()
[17:43:55.538]                 for (kk in seq_along(NAMES)) {
[17:43:55.538]                   name <- changed[[kk]]
[17:43:55.538]                   NAME <- NAMES[[kk]]
[17:43:55.538]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.538]                     next
[17:43:55.538]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.538]                 }
[17:43:55.538]                 NAMES <- toupper(added)
[17:43:55.538]                 for (kk in seq_along(NAMES)) {
[17:43:55.538]                   name <- added[[kk]]
[17:43:55.538]                   NAME <- NAMES[[kk]]
[17:43:55.538]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.538]                     next
[17:43:55.538]                   args[[name]] <- ""
[17:43:55.538]                 }
[17:43:55.538]                 NAMES <- toupper(removed)
[17:43:55.538]                 for (kk in seq_along(NAMES)) {
[17:43:55.538]                   name <- removed[[kk]]
[17:43:55.538]                   NAME <- NAMES[[kk]]
[17:43:55.538]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.538]                     next
[17:43:55.538]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.538]                 }
[17:43:55.538]                 if (length(args) > 0) 
[17:43:55.538]                   base::do.call(base::Sys.setenv, args = args)
[17:43:55.538]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:55.538]             }
[17:43:55.538]             else {
[17:43:55.538]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:55.538]             }
[17:43:55.538]             {
[17:43:55.538]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:55.538]                   0L) {
[17:43:55.538]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:55.538]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:55.538]                   base::options(opts)
[17:43:55.538]                 }
[17:43:55.538]                 {
[17:43:55.538]                   {
[17:43:55.538]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:55.538]                     NULL
[17:43:55.538]                   }
[17:43:55.538]                   options(future.plan = NULL)
[17:43:55.538]                   if (is.na(NA_character_)) 
[17:43:55.538]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.538]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:55.538]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:55.538]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:55.538]                     envir = parent.frame()) 
[17:43:55.538]                   {
[17:43:55.538]                     if (is.function(workers)) 
[17:43:55.538]                       workers <- workers()
[17:43:55.538]                     workers <- structure(as.integer(workers), 
[17:43:55.538]                       class = class(workers))
[17:43:55.538]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:55.538]                       workers >= 1)
[17:43:55.538]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:55.538]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:55.538]                     }
[17:43:55.538]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:55.538]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:55.538]                       envir = envir)
[17:43:55.538]                     if (!future$lazy) 
[17:43:55.538]                       future <- run(future)
[17:43:55.538]                     invisible(future)
[17:43:55.538]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:55.538]                 }
[17:43:55.538]             }
[17:43:55.538]         }
[17:43:55.538]     })
[17:43:55.538]     if (TRUE) {
[17:43:55.538]         base::sink(type = "output", split = FALSE)
[17:43:55.538]         if (TRUE) {
[17:43:55.538]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:55.538]         }
[17:43:55.538]         else {
[17:43:55.538]             ...future.result["stdout"] <- base::list(NULL)
[17:43:55.538]         }
[17:43:55.538]         base::close(...future.stdout)
[17:43:55.538]         ...future.stdout <- NULL
[17:43:55.538]     }
[17:43:55.538]     ...future.result$conditions <- ...future.conditions
[17:43:55.538]     ...future.result$finished <- base::Sys.time()
[17:43:55.538]     ...future.result
[17:43:55.538] }
[17:43:55.541] MultisessionFuture started
[17:43:55.541] - Launch lazy future ... done
[17:43:55.541] run() for ‘MultisessionFuture’ ... done
[17:43:55.542] resolve() on list environment ...
[17:43:55.542]  recursive: 0
[17:43:55.543]  length: 3
[17:43:55.543]  elements: ‘a’, ‘b’, ‘c’
[17:43:55.564]  length: 2 (resolved future 3)
[17:43:55.575] receiveMessageFromWorker() for ClusterFuture ...
[17:43:55.575] - Validating connection of MultisessionFuture
[17:43:55.575] - received message: FutureResult
[17:43:55.575] - Received FutureResult
[17:43:55.576] - Erased future from FutureRegistry
[17:43:55.576] result() for ClusterFuture ...
[17:43:55.576] - result already collected: FutureResult
[17:43:55.576] result() for ClusterFuture ... done
[17:43:55.576] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:55.576] Future #1
[17:43:55.576]  length: 1 (resolved future 1)
[17:43:55.597] receiveMessageFromWorker() for ClusterFuture ...
[17:43:55.597] - Validating connection of MultisessionFuture
[17:43:55.598] - received message: FutureResult
[17:43:55.598] - Received FutureResult
[17:43:55.598] - Erased future from FutureRegistry
[17:43:55.598] result() for ClusterFuture ...
[17:43:55.598] - result already collected: FutureResult
[17:43:55.598] result() for ClusterFuture ... done
[17:43:55.598] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:55.598] Future #2
[17:43:55.598]  length: 0 (resolved future 2)
[17:43:55.599] resolve() on list environment ... DONE
[17:43:55.599] getGlobalsAndPackages() ...
[17:43:55.599] Searching for globals...
[17:43:55.600] - globals found: [1] ‘{’
[17:43:55.600] Searching for globals ... DONE
[17:43:55.600] Resolving globals: FALSE
[17:43:55.601] 
[17:43:55.601] 
[17:43:55.601] getGlobalsAndPackages() ... DONE
[17:43:55.602] run() for ‘Future’ ...
[17:43:55.602] - state: ‘created’
[17:43:55.602] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:55.616] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:55.617] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:55.617]   - Field: ‘node’
[17:43:55.617]   - Field: ‘label’
[17:43:55.617]   - Field: ‘local’
[17:43:55.617]   - Field: ‘owner’
[17:43:55.617]   - Field: ‘envir’
[17:43:55.617]   - Field: ‘workers’
[17:43:55.617]   - Field: ‘packages’
[17:43:55.617]   - Field: ‘gc’
[17:43:55.617]   - Field: ‘conditions’
[17:43:55.618]   - Field: ‘persistent’
[17:43:55.618]   - Field: ‘expr’
[17:43:55.618]   - Field: ‘uuid’
[17:43:55.618]   - Field: ‘seed’
[17:43:55.618]   - Field: ‘version’
[17:43:55.618]   - Field: ‘result’
[17:43:55.618]   - Field: ‘asynchronous’
[17:43:55.618]   - Field: ‘calls’
[17:43:55.618]   - Field: ‘globals’
[17:43:55.618]   - Field: ‘stdout’
[17:43:55.618]   - Field: ‘earlySignal’
[17:43:55.619]   - Field: ‘lazy’
[17:43:55.619]   - Field: ‘state’
[17:43:55.619] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:55.619] - Launch lazy future ...
[17:43:55.619] Packages needed by the future expression (n = 0): <none>
[17:43:55.619] Packages needed by future strategies (n = 0): <none>
[17:43:55.620] {
[17:43:55.620]     {
[17:43:55.620]         {
[17:43:55.620]             ...future.startTime <- base::Sys.time()
[17:43:55.620]             {
[17:43:55.620]                 {
[17:43:55.620]                   {
[17:43:55.620]                     {
[17:43:55.620]                       base::local({
[17:43:55.620]                         has_future <- base::requireNamespace("future", 
[17:43:55.620]                           quietly = TRUE)
[17:43:55.620]                         if (has_future) {
[17:43:55.620]                           ns <- base::getNamespace("future")
[17:43:55.620]                           version <- ns[[".package"]][["version"]]
[17:43:55.620]                           if (is.null(version)) 
[17:43:55.620]                             version <- utils::packageVersion("future")
[17:43:55.620]                         }
[17:43:55.620]                         else {
[17:43:55.620]                           version <- NULL
[17:43:55.620]                         }
[17:43:55.620]                         if (!has_future || version < "1.8.0") {
[17:43:55.620]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:55.620]                             "", base::R.version$version.string), 
[17:43:55.620]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:55.620]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:55.620]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:55.620]                               "release", "version")], collapse = " "), 
[17:43:55.620]                             hostname = base::Sys.info()[["nodename"]])
[17:43:55.620]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:55.620]                             info)
[17:43:55.620]                           info <- base::paste(info, collapse = "; ")
[17:43:55.620]                           if (!has_future) {
[17:43:55.620]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:55.620]                               info)
[17:43:55.620]                           }
[17:43:55.620]                           else {
[17:43:55.620]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:55.620]                               info, version)
[17:43:55.620]                           }
[17:43:55.620]                           base::stop(msg)
[17:43:55.620]                         }
[17:43:55.620]                       })
[17:43:55.620]                     }
[17:43:55.620]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:55.620]                     base::options(mc.cores = 1L)
[17:43:55.620]                   }
[17:43:55.620]                   options(future.plan = NULL)
[17:43:55.620]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.620]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:55.620]                 }
[17:43:55.620]                 ...future.workdir <- getwd()
[17:43:55.620]             }
[17:43:55.620]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:55.620]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:55.620]         }
[17:43:55.620]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:55.620]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:55.620]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:55.620]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:55.620]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:55.620]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:55.620]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:55.620]             base::names(...future.oldOptions))
[17:43:55.620]     }
[17:43:55.620]     if (FALSE) {
[17:43:55.620]     }
[17:43:55.620]     else {
[17:43:55.620]         if (TRUE) {
[17:43:55.620]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:55.620]                 open = "w")
[17:43:55.620]         }
[17:43:55.620]         else {
[17:43:55.620]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:55.620]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:55.620]         }
[17:43:55.620]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:55.620]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:55.620]             base::sink(type = "output", split = FALSE)
[17:43:55.620]             base::close(...future.stdout)
[17:43:55.620]         }, add = TRUE)
[17:43:55.620]     }
[17:43:55.620]     ...future.frame <- base::sys.nframe()
[17:43:55.620]     ...future.conditions <- base::list()
[17:43:55.620]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:55.620]     if (FALSE) {
[17:43:55.620]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:55.620]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:55.620]     }
[17:43:55.620]     ...future.result <- base::tryCatch({
[17:43:55.620]         base::withCallingHandlers({
[17:43:55.620]             ...future.value <- base::withVisible(base::local({
[17:43:55.620]                 ...future.makeSendCondition <- local({
[17:43:55.620]                   sendCondition <- NULL
[17:43:55.620]                   function(frame = 1L) {
[17:43:55.620]                     if (is.function(sendCondition)) 
[17:43:55.620]                       return(sendCondition)
[17:43:55.620]                     ns <- getNamespace("parallel")
[17:43:55.620]                     if (exists("sendData", mode = "function", 
[17:43:55.620]                       envir = ns)) {
[17:43:55.620]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:55.620]                         envir = ns)
[17:43:55.620]                       envir <- sys.frame(frame)
[17:43:55.620]                       master <- NULL
[17:43:55.620]                       while (!identical(envir, .GlobalEnv) && 
[17:43:55.620]                         !identical(envir, emptyenv())) {
[17:43:55.620]                         if (exists("master", mode = "list", envir = envir, 
[17:43:55.620]                           inherits = FALSE)) {
[17:43:55.620]                           master <- get("master", mode = "list", 
[17:43:55.620]                             envir = envir, inherits = FALSE)
[17:43:55.620]                           if (inherits(master, c("SOCKnode", 
[17:43:55.620]                             "SOCK0node"))) {
[17:43:55.620]                             sendCondition <<- function(cond) {
[17:43:55.620]                               data <- list(type = "VALUE", value = cond, 
[17:43:55.620]                                 success = TRUE)
[17:43:55.620]                               parallel_sendData(master, data)
[17:43:55.620]                             }
[17:43:55.620]                             return(sendCondition)
[17:43:55.620]                           }
[17:43:55.620]                         }
[17:43:55.620]                         frame <- frame + 1L
[17:43:55.620]                         envir <- sys.frame(frame)
[17:43:55.620]                       }
[17:43:55.620]                     }
[17:43:55.620]                     sendCondition <<- function(cond) NULL
[17:43:55.620]                   }
[17:43:55.620]                 })
[17:43:55.620]                 withCallingHandlers({
[17:43:55.620]                   {
[17:43:55.620]                     1
[17:43:55.620]                   }
[17:43:55.620]                 }, immediateCondition = function(cond) {
[17:43:55.620]                   sendCondition <- ...future.makeSendCondition()
[17:43:55.620]                   sendCondition(cond)
[17:43:55.620]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.620]                   {
[17:43:55.620]                     inherits <- base::inherits
[17:43:55.620]                     invokeRestart <- base::invokeRestart
[17:43:55.620]                     is.null <- base::is.null
[17:43:55.620]                     muffled <- FALSE
[17:43:55.620]                     if (inherits(cond, "message")) {
[17:43:55.620]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:55.620]                       if (muffled) 
[17:43:55.620]                         invokeRestart("muffleMessage")
[17:43:55.620]                     }
[17:43:55.620]                     else if (inherits(cond, "warning")) {
[17:43:55.620]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:55.620]                       if (muffled) 
[17:43:55.620]                         invokeRestart("muffleWarning")
[17:43:55.620]                     }
[17:43:55.620]                     else if (inherits(cond, "condition")) {
[17:43:55.620]                       if (!is.null(pattern)) {
[17:43:55.620]                         computeRestarts <- base::computeRestarts
[17:43:55.620]                         grepl <- base::grepl
[17:43:55.620]                         restarts <- computeRestarts(cond)
[17:43:55.620]                         for (restart in restarts) {
[17:43:55.620]                           name <- restart$name
[17:43:55.620]                           if (is.null(name)) 
[17:43:55.620]                             next
[17:43:55.620]                           if (!grepl(pattern, name)) 
[17:43:55.620]                             next
[17:43:55.620]                           invokeRestart(restart)
[17:43:55.620]                           muffled <- TRUE
[17:43:55.620]                           break
[17:43:55.620]                         }
[17:43:55.620]                       }
[17:43:55.620]                     }
[17:43:55.620]                     invisible(muffled)
[17:43:55.620]                   }
[17:43:55.620]                   muffleCondition(cond)
[17:43:55.620]                 })
[17:43:55.620]             }))
[17:43:55.620]             future::FutureResult(value = ...future.value$value, 
[17:43:55.620]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.620]                   ...future.rng), globalenv = if (FALSE) 
[17:43:55.620]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:55.620]                     ...future.globalenv.names))
[17:43:55.620]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:55.620]         }, condition = base::local({
[17:43:55.620]             c <- base::c
[17:43:55.620]             inherits <- base::inherits
[17:43:55.620]             invokeRestart <- base::invokeRestart
[17:43:55.620]             length <- base::length
[17:43:55.620]             list <- base::list
[17:43:55.620]             seq.int <- base::seq.int
[17:43:55.620]             signalCondition <- base::signalCondition
[17:43:55.620]             sys.calls <- base::sys.calls
[17:43:55.620]             `[[` <- base::`[[`
[17:43:55.620]             `+` <- base::`+`
[17:43:55.620]             `<<-` <- base::`<<-`
[17:43:55.620]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:55.620]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:55.620]                   3L)]
[17:43:55.620]             }
[17:43:55.620]             function(cond) {
[17:43:55.620]                 is_error <- inherits(cond, "error")
[17:43:55.620]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:55.620]                   NULL)
[17:43:55.620]                 if (is_error) {
[17:43:55.620]                   sessionInformation <- function() {
[17:43:55.620]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:55.620]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:55.620]                       search = base::search(), system = base::Sys.info())
[17:43:55.620]                   }
[17:43:55.620]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.620]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:55.620]                     cond$call), session = sessionInformation(), 
[17:43:55.620]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:55.620]                   signalCondition(cond)
[17:43:55.620]                 }
[17:43:55.620]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:55.620]                 "immediateCondition"))) {
[17:43:55.620]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:55.620]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.620]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:55.620]                   if (TRUE && !signal) {
[17:43:55.620]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.620]                     {
[17:43:55.620]                       inherits <- base::inherits
[17:43:55.620]                       invokeRestart <- base::invokeRestart
[17:43:55.620]                       is.null <- base::is.null
[17:43:55.620]                       muffled <- FALSE
[17:43:55.620]                       if (inherits(cond, "message")) {
[17:43:55.620]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.620]                         if (muffled) 
[17:43:55.620]                           invokeRestart("muffleMessage")
[17:43:55.620]                       }
[17:43:55.620]                       else if (inherits(cond, "warning")) {
[17:43:55.620]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.620]                         if (muffled) 
[17:43:55.620]                           invokeRestart("muffleWarning")
[17:43:55.620]                       }
[17:43:55.620]                       else if (inherits(cond, "condition")) {
[17:43:55.620]                         if (!is.null(pattern)) {
[17:43:55.620]                           computeRestarts <- base::computeRestarts
[17:43:55.620]                           grepl <- base::grepl
[17:43:55.620]                           restarts <- computeRestarts(cond)
[17:43:55.620]                           for (restart in restarts) {
[17:43:55.620]                             name <- restart$name
[17:43:55.620]                             if (is.null(name)) 
[17:43:55.620]                               next
[17:43:55.620]                             if (!grepl(pattern, name)) 
[17:43:55.620]                               next
[17:43:55.620]                             invokeRestart(restart)
[17:43:55.620]                             muffled <- TRUE
[17:43:55.620]                             break
[17:43:55.620]                           }
[17:43:55.620]                         }
[17:43:55.620]                       }
[17:43:55.620]                       invisible(muffled)
[17:43:55.620]                     }
[17:43:55.620]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.620]                   }
[17:43:55.620]                 }
[17:43:55.620]                 else {
[17:43:55.620]                   if (TRUE) {
[17:43:55.620]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.620]                     {
[17:43:55.620]                       inherits <- base::inherits
[17:43:55.620]                       invokeRestart <- base::invokeRestart
[17:43:55.620]                       is.null <- base::is.null
[17:43:55.620]                       muffled <- FALSE
[17:43:55.620]                       if (inherits(cond, "message")) {
[17:43:55.620]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.620]                         if (muffled) 
[17:43:55.620]                           invokeRestart("muffleMessage")
[17:43:55.620]                       }
[17:43:55.620]                       else if (inherits(cond, "warning")) {
[17:43:55.620]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.620]                         if (muffled) 
[17:43:55.620]                           invokeRestart("muffleWarning")
[17:43:55.620]                       }
[17:43:55.620]                       else if (inherits(cond, "condition")) {
[17:43:55.620]                         if (!is.null(pattern)) {
[17:43:55.620]                           computeRestarts <- base::computeRestarts
[17:43:55.620]                           grepl <- base::grepl
[17:43:55.620]                           restarts <- computeRestarts(cond)
[17:43:55.620]                           for (restart in restarts) {
[17:43:55.620]                             name <- restart$name
[17:43:55.620]                             if (is.null(name)) 
[17:43:55.620]                               next
[17:43:55.620]                             if (!grepl(pattern, name)) 
[17:43:55.620]                               next
[17:43:55.620]                             invokeRestart(restart)
[17:43:55.620]                             muffled <- TRUE
[17:43:55.620]                             break
[17:43:55.620]                           }
[17:43:55.620]                         }
[17:43:55.620]                       }
[17:43:55.620]                       invisible(muffled)
[17:43:55.620]                     }
[17:43:55.620]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.620]                   }
[17:43:55.620]                 }
[17:43:55.620]             }
[17:43:55.620]         }))
[17:43:55.620]     }, error = function(ex) {
[17:43:55.620]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:55.620]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.620]                 ...future.rng), started = ...future.startTime, 
[17:43:55.620]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:55.620]             version = "1.8"), class = "FutureResult")
[17:43:55.620]     }, finally = {
[17:43:55.620]         if (!identical(...future.workdir, getwd())) 
[17:43:55.620]             setwd(...future.workdir)
[17:43:55.620]         {
[17:43:55.620]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:55.620]                 ...future.oldOptions$nwarnings <- NULL
[17:43:55.620]             }
[17:43:55.620]             base::options(...future.oldOptions)
[17:43:55.620]             if (.Platform$OS.type == "windows") {
[17:43:55.620]                 old_names <- names(...future.oldEnvVars)
[17:43:55.620]                 envs <- base::Sys.getenv()
[17:43:55.620]                 names <- names(envs)
[17:43:55.620]                 common <- intersect(names, old_names)
[17:43:55.620]                 added <- setdiff(names, old_names)
[17:43:55.620]                 removed <- setdiff(old_names, names)
[17:43:55.620]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:55.620]                   envs[common]]
[17:43:55.620]                 NAMES <- toupper(changed)
[17:43:55.620]                 args <- list()
[17:43:55.620]                 for (kk in seq_along(NAMES)) {
[17:43:55.620]                   name <- changed[[kk]]
[17:43:55.620]                   NAME <- NAMES[[kk]]
[17:43:55.620]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.620]                     next
[17:43:55.620]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.620]                 }
[17:43:55.620]                 NAMES <- toupper(added)
[17:43:55.620]                 for (kk in seq_along(NAMES)) {
[17:43:55.620]                   name <- added[[kk]]
[17:43:55.620]                   NAME <- NAMES[[kk]]
[17:43:55.620]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.620]                     next
[17:43:55.620]                   args[[name]] <- ""
[17:43:55.620]                 }
[17:43:55.620]                 NAMES <- toupper(removed)
[17:43:55.620]                 for (kk in seq_along(NAMES)) {
[17:43:55.620]                   name <- removed[[kk]]
[17:43:55.620]                   NAME <- NAMES[[kk]]
[17:43:55.620]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.620]                     next
[17:43:55.620]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.620]                 }
[17:43:55.620]                 if (length(args) > 0) 
[17:43:55.620]                   base::do.call(base::Sys.setenv, args = args)
[17:43:55.620]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:55.620]             }
[17:43:55.620]             else {
[17:43:55.620]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:55.620]             }
[17:43:55.620]             {
[17:43:55.620]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:55.620]                   0L) {
[17:43:55.620]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:55.620]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:55.620]                   base::options(opts)
[17:43:55.620]                 }
[17:43:55.620]                 {
[17:43:55.620]                   {
[17:43:55.620]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:55.620]                     NULL
[17:43:55.620]                   }
[17:43:55.620]                   options(future.plan = NULL)
[17:43:55.620]                   if (is.na(NA_character_)) 
[17:43:55.620]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.620]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:55.620]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:55.620]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:55.620]                     envir = parent.frame()) 
[17:43:55.620]                   {
[17:43:55.620]                     if (is.function(workers)) 
[17:43:55.620]                       workers <- workers()
[17:43:55.620]                     workers <- structure(as.integer(workers), 
[17:43:55.620]                       class = class(workers))
[17:43:55.620]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:55.620]                       workers >= 1)
[17:43:55.620]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:55.620]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:55.620]                     }
[17:43:55.620]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:55.620]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:55.620]                       envir = envir)
[17:43:55.620]                     if (!future$lazy) 
[17:43:55.620]                       future <- run(future)
[17:43:55.620]                     invisible(future)
[17:43:55.620]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:55.620]                 }
[17:43:55.620]             }
[17:43:55.620]         }
[17:43:55.620]     })
[17:43:55.620]     if (TRUE) {
[17:43:55.620]         base::sink(type = "output", split = FALSE)
[17:43:55.620]         if (TRUE) {
[17:43:55.620]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:55.620]         }
[17:43:55.620]         else {
[17:43:55.620]             ...future.result["stdout"] <- base::list(NULL)
[17:43:55.620]         }
[17:43:55.620]         base::close(...future.stdout)
[17:43:55.620]         ...future.stdout <- NULL
[17:43:55.620]     }
[17:43:55.620]     ...future.result$conditions <- ...future.conditions
[17:43:55.620]     ...future.result$finished <- base::Sys.time()
[17:43:55.620]     ...future.result
[17:43:55.620] }
[17:43:55.623] MultisessionFuture started
[17:43:55.623] - Launch lazy future ... done
[17:43:55.623] run() for ‘MultisessionFuture’ ... done
[17:43:55.624] getGlobalsAndPackages() ...
[17:43:55.624] Searching for globals...
[17:43:55.624] - globals found: [1] ‘{’
[17:43:55.625] Searching for globals ... DONE
[17:43:55.625] Resolving globals: FALSE
[17:43:55.625] 
[17:43:55.625] 
[17:43:55.625] getGlobalsAndPackages() ... DONE
[17:43:55.625] run() for ‘Future’ ...
[17:43:55.626] - state: ‘created’
[17:43:55.626] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:55.640] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:55.641] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:55.641]   - Field: ‘node’
[17:43:55.641]   - Field: ‘label’
[17:43:55.641]   - Field: ‘local’
[17:43:55.641]   - Field: ‘owner’
[17:43:55.641]   - Field: ‘envir’
[17:43:55.641]   - Field: ‘workers’
[17:43:55.641]   - Field: ‘packages’
[17:43:55.641]   - Field: ‘gc’
[17:43:55.641]   - Field: ‘conditions’
[17:43:55.642]   - Field: ‘persistent’
[17:43:55.642]   - Field: ‘expr’
[17:43:55.642]   - Field: ‘uuid’
[17:43:55.642]   - Field: ‘seed’
[17:43:55.642]   - Field: ‘version’
[17:43:55.642]   - Field: ‘result’
[17:43:55.642]   - Field: ‘asynchronous’
[17:43:55.642]   - Field: ‘calls’
[17:43:55.642]   - Field: ‘globals’
[17:43:55.642]   - Field: ‘stdout’
[17:43:55.643]   - Field: ‘earlySignal’
[17:43:55.643]   - Field: ‘lazy’
[17:43:55.643]   - Field: ‘state’
[17:43:55.643] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:55.643] - Launch lazy future ...
[17:43:55.643] Packages needed by the future expression (n = 0): <none>
[17:43:55.643] Packages needed by future strategies (n = 0): <none>
[17:43:55.644] {
[17:43:55.644]     {
[17:43:55.644]         {
[17:43:55.644]             ...future.startTime <- base::Sys.time()
[17:43:55.644]             {
[17:43:55.644]                 {
[17:43:55.644]                   {
[17:43:55.644]                     {
[17:43:55.644]                       base::local({
[17:43:55.644]                         has_future <- base::requireNamespace("future", 
[17:43:55.644]                           quietly = TRUE)
[17:43:55.644]                         if (has_future) {
[17:43:55.644]                           ns <- base::getNamespace("future")
[17:43:55.644]                           version <- ns[[".package"]][["version"]]
[17:43:55.644]                           if (is.null(version)) 
[17:43:55.644]                             version <- utils::packageVersion("future")
[17:43:55.644]                         }
[17:43:55.644]                         else {
[17:43:55.644]                           version <- NULL
[17:43:55.644]                         }
[17:43:55.644]                         if (!has_future || version < "1.8.0") {
[17:43:55.644]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:55.644]                             "", base::R.version$version.string), 
[17:43:55.644]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:55.644]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:55.644]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:55.644]                               "release", "version")], collapse = " "), 
[17:43:55.644]                             hostname = base::Sys.info()[["nodename"]])
[17:43:55.644]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:55.644]                             info)
[17:43:55.644]                           info <- base::paste(info, collapse = "; ")
[17:43:55.644]                           if (!has_future) {
[17:43:55.644]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:55.644]                               info)
[17:43:55.644]                           }
[17:43:55.644]                           else {
[17:43:55.644]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:55.644]                               info, version)
[17:43:55.644]                           }
[17:43:55.644]                           base::stop(msg)
[17:43:55.644]                         }
[17:43:55.644]                       })
[17:43:55.644]                     }
[17:43:55.644]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:55.644]                     base::options(mc.cores = 1L)
[17:43:55.644]                   }
[17:43:55.644]                   options(future.plan = NULL)
[17:43:55.644]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.644]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:55.644]                 }
[17:43:55.644]                 ...future.workdir <- getwd()
[17:43:55.644]             }
[17:43:55.644]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:55.644]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:55.644]         }
[17:43:55.644]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:55.644]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:55.644]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:55.644]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:55.644]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:55.644]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:55.644]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:55.644]             base::names(...future.oldOptions))
[17:43:55.644]     }
[17:43:55.644]     if (FALSE) {
[17:43:55.644]     }
[17:43:55.644]     else {
[17:43:55.644]         if (TRUE) {
[17:43:55.644]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:55.644]                 open = "w")
[17:43:55.644]         }
[17:43:55.644]         else {
[17:43:55.644]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:55.644]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:55.644]         }
[17:43:55.644]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:55.644]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:55.644]             base::sink(type = "output", split = FALSE)
[17:43:55.644]             base::close(...future.stdout)
[17:43:55.644]         }, add = TRUE)
[17:43:55.644]     }
[17:43:55.644]     ...future.frame <- base::sys.nframe()
[17:43:55.644]     ...future.conditions <- base::list()
[17:43:55.644]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:55.644]     if (FALSE) {
[17:43:55.644]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:55.644]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:55.644]     }
[17:43:55.644]     ...future.result <- base::tryCatch({
[17:43:55.644]         base::withCallingHandlers({
[17:43:55.644]             ...future.value <- base::withVisible(base::local({
[17:43:55.644]                 ...future.makeSendCondition <- local({
[17:43:55.644]                   sendCondition <- NULL
[17:43:55.644]                   function(frame = 1L) {
[17:43:55.644]                     if (is.function(sendCondition)) 
[17:43:55.644]                       return(sendCondition)
[17:43:55.644]                     ns <- getNamespace("parallel")
[17:43:55.644]                     if (exists("sendData", mode = "function", 
[17:43:55.644]                       envir = ns)) {
[17:43:55.644]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:55.644]                         envir = ns)
[17:43:55.644]                       envir <- sys.frame(frame)
[17:43:55.644]                       master <- NULL
[17:43:55.644]                       while (!identical(envir, .GlobalEnv) && 
[17:43:55.644]                         !identical(envir, emptyenv())) {
[17:43:55.644]                         if (exists("master", mode = "list", envir = envir, 
[17:43:55.644]                           inherits = FALSE)) {
[17:43:55.644]                           master <- get("master", mode = "list", 
[17:43:55.644]                             envir = envir, inherits = FALSE)
[17:43:55.644]                           if (inherits(master, c("SOCKnode", 
[17:43:55.644]                             "SOCK0node"))) {
[17:43:55.644]                             sendCondition <<- function(cond) {
[17:43:55.644]                               data <- list(type = "VALUE", value = cond, 
[17:43:55.644]                                 success = TRUE)
[17:43:55.644]                               parallel_sendData(master, data)
[17:43:55.644]                             }
[17:43:55.644]                             return(sendCondition)
[17:43:55.644]                           }
[17:43:55.644]                         }
[17:43:55.644]                         frame <- frame + 1L
[17:43:55.644]                         envir <- sys.frame(frame)
[17:43:55.644]                       }
[17:43:55.644]                     }
[17:43:55.644]                     sendCondition <<- function(cond) NULL
[17:43:55.644]                   }
[17:43:55.644]                 })
[17:43:55.644]                 withCallingHandlers({
[17:43:55.644]                   {
[17:43:55.644]                     2
[17:43:55.644]                   }
[17:43:55.644]                 }, immediateCondition = function(cond) {
[17:43:55.644]                   sendCondition <- ...future.makeSendCondition()
[17:43:55.644]                   sendCondition(cond)
[17:43:55.644]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.644]                   {
[17:43:55.644]                     inherits <- base::inherits
[17:43:55.644]                     invokeRestart <- base::invokeRestart
[17:43:55.644]                     is.null <- base::is.null
[17:43:55.644]                     muffled <- FALSE
[17:43:55.644]                     if (inherits(cond, "message")) {
[17:43:55.644]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:55.644]                       if (muffled) 
[17:43:55.644]                         invokeRestart("muffleMessage")
[17:43:55.644]                     }
[17:43:55.644]                     else if (inherits(cond, "warning")) {
[17:43:55.644]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:55.644]                       if (muffled) 
[17:43:55.644]                         invokeRestart("muffleWarning")
[17:43:55.644]                     }
[17:43:55.644]                     else if (inherits(cond, "condition")) {
[17:43:55.644]                       if (!is.null(pattern)) {
[17:43:55.644]                         computeRestarts <- base::computeRestarts
[17:43:55.644]                         grepl <- base::grepl
[17:43:55.644]                         restarts <- computeRestarts(cond)
[17:43:55.644]                         for (restart in restarts) {
[17:43:55.644]                           name <- restart$name
[17:43:55.644]                           if (is.null(name)) 
[17:43:55.644]                             next
[17:43:55.644]                           if (!grepl(pattern, name)) 
[17:43:55.644]                             next
[17:43:55.644]                           invokeRestart(restart)
[17:43:55.644]                           muffled <- TRUE
[17:43:55.644]                           break
[17:43:55.644]                         }
[17:43:55.644]                       }
[17:43:55.644]                     }
[17:43:55.644]                     invisible(muffled)
[17:43:55.644]                   }
[17:43:55.644]                   muffleCondition(cond)
[17:43:55.644]                 })
[17:43:55.644]             }))
[17:43:55.644]             future::FutureResult(value = ...future.value$value, 
[17:43:55.644]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.644]                   ...future.rng), globalenv = if (FALSE) 
[17:43:55.644]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:55.644]                     ...future.globalenv.names))
[17:43:55.644]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:55.644]         }, condition = base::local({
[17:43:55.644]             c <- base::c
[17:43:55.644]             inherits <- base::inherits
[17:43:55.644]             invokeRestart <- base::invokeRestart
[17:43:55.644]             length <- base::length
[17:43:55.644]             list <- base::list
[17:43:55.644]             seq.int <- base::seq.int
[17:43:55.644]             signalCondition <- base::signalCondition
[17:43:55.644]             sys.calls <- base::sys.calls
[17:43:55.644]             `[[` <- base::`[[`
[17:43:55.644]             `+` <- base::`+`
[17:43:55.644]             `<<-` <- base::`<<-`
[17:43:55.644]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:55.644]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:55.644]                   3L)]
[17:43:55.644]             }
[17:43:55.644]             function(cond) {
[17:43:55.644]                 is_error <- inherits(cond, "error")
[17:43:55.644]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:55.644]                   NULL)
[17:43:55.644]                 if (is_error) {
[17:43:55.644]                   sessionInformation <- function() {
[17:43:55.644]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:55.644]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:55.644]                       search = base::search(), system = base::Sys.info())
[17:43:55.644]                   }
[17:43:55.644]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.644]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:55.644]                     cond$call), session = sessionInformation(), 
[17:43:55.644]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:55.644]                   signalCondition(cond)
[17:43:55.644]                 }
[17:43:55.644]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:55.644]                 "immediateCondition"))) {
[17:43:55.644]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:55.644]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.644]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:55.644]                   if (TRUE && !signal) {
[17:43:55.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.644]                     {
[17:43:55.644]                       inherits <- base::inherits
[17:43:55.644]                       invokeRestart <- base::invokeRestart
[17:43:55.644]                       is.null <- base::is.null
[17:43:55.644]                       muffled <- FALSE
[17:43:55.644]                       if (inherits(cond, "message")) {
[17:43:55.644]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.644]                         if (muffled) 
[17:43:55.644]                           invokeRestart("muffleMessage")
[17:43:55.644]                       }
[17:43:55.644]                       else if (inherits(cond, "warning")) {
[17:43:55.644]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.644]                         if (muffled) 
[17:43:55.644]                           invokeRestart("muffleWarning")
[17:43:55.644]                       }
[17:43:55.644]                       else if (inherits(cond, "condition")) {
[17:43:55.644]                         if (!is.null(pattern)) {
[17:43:55.644]                           computeRestarts <- base::computeRestarts
[17:43:55.644]                           grepl <- base::grepl
[17:43:55.644]                           restarts <- computeRestarts(cond)
[17:43:55.644]                           for (restart in restarts) {
[17:43:55.644]                             name <- restart$name
[17:43:55.644]                             if (is.null(name)) 
[17:43:55.644]                               next
[17:43:55.644]                             if (!grepl(pattern, name)) 
[17:43:55.644]                               next
[17:43:55.644]                             invokeRestart(restart)
[17:43:55.644]                             muffled <- TRUE
[17:43:55.644]                             break
[17:43:55.644]                           }
[17:43:55.644]                         }
[17:43:55.644]                       }
[17:43:55.644]                       invisible(muffled)
[17:43:55.644]                     }
[17:43:55.644]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.644]                   }
[17:43:55.644]                 }
[17:43:55.644]                 else {
[17:43:55.644]                   if (TRUE) {
[17:43:55.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.644]                     {
[17:43:55.644]                       inherits <- base::inherits
[17:43:55.644]                       invokeRestart <- base::invokeRestart
[17:43:55.644]                       is.null <- base::is.null
[17:43:55.644]                       muffled <- FALSE
[17:43:55.644]                       if (inherits(cond, "message")) {
[17:43:55.644]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.644]                         if (muffled) 
[17:43:55.644]                           invokeRestart("muffleMessage")
[17:43:55.644]                       }
[17:43:55.644]                       else if (inherits(cond, "warning")) {
[17:43:55.644]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.644]                         if (muffled) 
[17:43:55.644]                           invokeRestart("muffleWarning")
[17:43:55.644]                       }
[17:43:55.644]                       else if (inherits(cond, "condition")) {
[17:43:55.644]                         if (!is.null(pattern)) {
[17:43:55.644]                           computeRestarts <- base::computeRestarts
[17:43:55.644]                           grepl <- base::grepl
[17:43:55.644]                           restarts <- computeRestarts(cond)
[17:43:55.644]                           for (restart in restarts) {
[17:43:55.644]                             name <- restart$name
[17:43:55.644]                             if (is.null(name)) 
[17:43:55.644]                               next
[17:43:55.644]                             if (!grepl(pattern, name)) 
[17:43:55.644]                               next
[17:43:55.644]                             invokeRestart(restart)
[17:43:55.644]                             muffled <- TRUE
[17:43:55.644]                             break
[17:43:55.644]                           }
[17:43:55.644]                         }
[17:43:55.644]                       }
[17:43:55.644]                       invisible(muffled)
[17:43:55.644]                     }
[17:43:55.644]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.644]                   }
[17:43:55.644]                 }
[17:43:55.644]             }
[17:43:55.644]         }))
[17:43:55.644]     }, error = function(ex) {
[17:43:55.644]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:55.644]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.644]                 ...future.rng), started = ...future.startTime, 
[17:43:55.644]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:55.644]             version = "1.8"), class = "FutureResult")
[17:43:55.644]     }, finally = {
[17:43:55.644]         if (!identical(...future.workdir, getwd())) 
[17:43:55.644]             setwd(...future.workdir)
[17:43:55.644]         {
[17:43:55.644]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:55.644]                 ...future.oldOptions$nwarnings <- NULL
[17:43:55.644]             }
[17:43:55.644]             base::options(...future.oldOptions)
[17:43:55.644]             if (.Platform$OS.type == "windows") {
[17:43:55.644]                 old_names <- names(...future.oldEnvVars)
[17:43:55.644]                 envs <- base::Sys.getenv()
[17:43:55.644]                 names <- names(envs)
[17:43:55.644]                 common <- intersect(names, old_names)
[17:43:55.644]                 added <- setdiff(names, old_names)
[17:43:55.644]                 removed <- setdiff(old_names, names)
[17:43:55.644]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:55.644]                   envs[common]]
[17:43:55.644]                 NAMES <- toupper(changed)
[17:43:55.644]                 args <- list()
[17:43:55.644]                 for (kk in seq_along(NAMES)) {
[17:43:55.644]                   name <- changed[[kk]]
[17:43:55.644]                   NAME <- NAMES[[kk]]
[17:43:55.644]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.644]                     next
[17:43:55.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.644]                 }
[17:43:55.644]                 NAMES <- toupper(added)
[17:43:55.644]                 for (kk in seq_along(NAMES)) {
[17:43:55.644]                   name <- added[[kk]]
[17:43:55.644]                   NAME <- NAMES[[kk]]
[17:43:55.644]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.644]                     next
[17:43:55.644]                   args[[name]] <- ""
[17:43:55.644]                 }
[17:43:55.644]                 NAMES <- toupper(removed)
[17:43:55.644]                 for (kk in seq_along(NAMES)) {
[17:43:55.644]                   name <- removed[[kk]]
[17:43:55.644]                   NAME <- NAMES[[kk]]
[17:43:55.644]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.644]                     next
[17:43:55.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.644]                 }
[17:43:55.644]                 if (length(args) > 0) 
[17:43:55.644]                   base::do.call(base::Sys.setenv, args = args)
[17:43:55.644]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:55.644]             }
[17:43:55.644]             else {
[17:43:55.644]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:55.644]             }
[17:43:55.644]             {
[17:43:55.644]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:55.644]                   0L) {
[17:43:55.644]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:55.644]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:55.644]                   base::options(opts)
[17:43:55.644]                 }
[17:43:55.644]                 {
[17:43:55.644]                   {
[17:43:55.644]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:55.644]                     NULL
[17:43:55.644]                   }
[17:43:55.644]                   options(future.plan = NULL)
[17:43:55.644]                   if (is.na(NA_character_)) 
[17:43:55.644]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.644]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:55.644]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:55.644]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:55.644]                     envir = parent.frame()) 
[17:43:55.644]                   {
[17:43:55.644]                     if (is.function(workers)) 
[17:43:55.644]                       workers <- workers()
[17:43:55.644]                     workers <- structure(as.integer(workers), 
[17:43:55.644]                       class = class(workers))
[17:43:55.644]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:55.644]                       workers >= 1)
[17:43:55.644]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:55.644]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:55.644]                     }
[17:43:55.644]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:55.644]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:55.644]                       envir = envir)
[17:43:55.644]                     if (!future$lazy) 
[17:43:55.644]                       future <- run(future)
[17:43:55.644]                     invisible(future)
[17:43:55.644]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:55.644]                 }
[17:43:55.644]             }
[17:43:55.644]         }
[17:43:55.644]     })
[17:43:55.644]     if (TRUE) {
[17:43:55.644]         base::sink(type = "output", split = FALSE)
[17:43:55.644]         if (TRUE) {
[17:43:55.644]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:55.644]         }
[17:43:55.644]         else {
[17:43:55.644]             ...future.result["stdout"] <- base::list(NULL)
[17:43:55.644]         }
[17:43:55.644]         base::close(...future.stdout)
[17:43:55.644]         ...future.stdout <- NULL
[17:43:55.644]     }
[17:43:55.644]     ...future.result$conditions <- ...future.conditions
[17:43:55.644]     ...future.result$finished <- base::Sys.time()
[17:43:55.644]     ...future.result
[17:43:55.644] }
[17:43:55.647] MultisessionFuture started
[17:43:55.647] - Launch lazy future ... done
[17:43:55.647] run() for ‘MultisessionFuture’ ... done
[17:43:55.648] resolve() on list environment ...
[17:43:55.648]  recursive: 0
[17:43:55.649]  length: 3
[17:43:55.649]  elements: ‘a’, ‘b’, ‘c’
[17:43:55.670]  length: 2 (resolved future 3)
[17:43:55.681] receiveMessageFromWorker() for ClusterFuture ...
[17:43:55.681] - Validating connection of MultisessionFuture
[17:43:55.681] - received message: FutureResult
[17:43:55.681] - Received FutureResult
[17:43:55.682] - Erased future from FutureRegistry
[17:43:55.682] result() for ClusterFuture ...
[17:43:55.682] - result already collected: FutureResult
[17:43:55.682] result() for ClusterFuture ... done
[17:43:55.682] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:55.682] Future #1
[17:43:55.682]  length: 1 (resolved future 1)
[17:43:55.703] receiveMessageFromWorker() for ClusterFuture ...
[17:43:55.704] - Validating connection of MultisessionFuture
[17:43:55.704] - received message: FutureResult
[17:43:55.704] - Received FutureResult
[17:43:55.704] - Erased future from FutureRegistry
[17:43:55.704] result() for ClusterFuture ...
[17:43:55.704] - result already collected: FutureResult
[17:43:55.704] result() for ClusterFuture ... done
[17:43:55.705] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:55.705] Future #2
[17:43:55.705]  length: 0 (resolved future 2)
[17:43:55.705] resolve() on list environment ... DONE
[17:43:55.705] getGlobalsAndPackages() ...
[17:43:55.705] Searching for globals...
[17:43:55.706] - globals found: [1] ‘{’
[17:43:55.706] Searching for globals ... DONE
[17:43:55.706] Resolving globals: FALSE
[17:43:55.707] 
[17:43:55.707] 
[17:43:55.707] getGlobalsAndPackages() ... DONE
[17:43:55.707] run() for ‘Future’ ...
[17:43:55.707] - state: ‘created’
[17:43:55.707] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:55.722] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:55.722] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:55.722]   - Field: ‘node’
[17:43:55.722]   - Field: ‘label’
[17:43:55.722]   - Field: ‘local’
[17:43:55.723]   - Field: ‘owner’
[17:43:55.723]   - Field: ‘envir’
[17:43:55.723]   - Field: ‘workers’
[17:43:55.723]   - Field: ‘packages’
[17:43:55.723]   - Field: ‘gc’
[17:43:55.723]   - Field: ‘conditions’
[17:43:55.723]   - Field: ‘persistent’
[17:43:55.723]   - Field: ‘expr’
[17:43:55.723]   - Field: ‘uuid’
[17:43:55.723]   - Field: ‘seed’
[17:43:55.724]   - Field: ‘version’
[17:43:55.724]   - Field: ‘result’
[17:43:55.724]   - Field: ‘asynchronous’
[17:43:55.724]   - Field: ‘calls’
[17:43:55.724]   - Field: ‘globals’
[17:43:55.724]   - Field: ‘stdout’
[17:43:55.724]   - Field: ‘earlySignal’
[17:43:55.724]   - Field: ‘lazy’
[17:43:55.724]   - Field: ‘state’
[17:43:55.724] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:55.724] - Launch lazy future ...
[17:43:55.725] Packages needed by the future expression (n = 0): <none>
[17:43:55.725] Packages needed by future strategies (n = 0): <none>
[17:43:55.725] {
[17:43:55.725]     {
[17:43:55.725]         {
[17:43:55.725]             ...future.startTime <- base::Sys.time()
[17:43:55.725]             {
[17:43:55.725]                 {
[17:43:55.725]                   {
[17:43:55.725]                     {
[17:43:55.725]                       base::local({
[17:43:55.725]                         has_future <- base::requireNamespace("future", 
[17:43:55.725]                           quietly = TRUE)
[17:43:55.725]                         if (has_future) {
[17:43:55.725]                           ns <- base::getNamespace("future")
[17:43:55.725]                           version <- ns[[".package"]][["version"]]
[17:43:55.725]                           if (is.null(version)) 
[17:43:55.725]                             version <- utils::packageVersion("future")
[17:43:55.725]                         }
[17:43:55.725]                         else {
[17:43:55.725]                           version <- NULL
[17:43:55.725]                         }
[17:43:55.725]                         if (!has_future || version < "1.8.0") {
[17:43:55.725]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:55.725]                             "", base::R.version$version.string), 
[17:43:55.725]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:55.725]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:55.725]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:55.725]                               "release", "version")], collapse = " "), 
[17:43:55.725]                             hostname = base::Sys.info()[["nodename"]])
[17:43:55.725]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:55.725]                             info)
[17:43:55.725]                           info <- base::paste(info, collapse = "; ")
[17:43:55.725]                           if (!has_future) {
[17:43:55.725]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:55.725]                               info)
[17:43:55.725]                           }
[17:43:55.725]                           else {
[17:43:55.725]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:55.725]                               info, version)
[17:43:55.725]                           }
[17:43:55.725]                           base::stop(msg)
[17:43:55.725]                         }
[17:43:55.725]                       })
[17:43:55.725]                     }
[17:43:55.725]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:55.725]                     base::options(mc.cores = 1L)
[17:43:55.725]                   }
[17:43:55.725]                   options(future.plan = NULL)
[17:43:55.725]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.725]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:55.725]                 }
[17:43:55.725]                 ...future.workdir <- getwd()
[17:43:55.725]             }
[17:43:55.725]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:55.725]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:55.725]         }
[17:43:55.725]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:55.725]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:55.725]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:55.725]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:55.725]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:55.725]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:55.725]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:55.725]             base::names(...future.oldOptions))
[17:43:55.725]     }
[17:43:55.725]     if (FALSE) {
[17:43:55.725]     }
[17:43:55.725]     else {
[17:43:55.725]         if (TRUE) {
[17:43:55.725]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:55.725]                 open = "w")
[17:43:55.725]         }
[17:43:55.725]         else {
[17:43:55.725]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:55.725]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:55.725]         }
[17:43:55.725]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:55.725]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:55.725]             base::sink(type = "output", split = FALSE)
[17:43:55.725]             base::close(...future.stdout)
[17:43:55.725]         }, add = TRUE)
[17:43:55.725]     }
[17:43:55.725]     ...future.frame <- base::sys.nframe()
[17:43:55.725]     ...future.conditions <- base::list()
[17:43:55.725]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:55.725]     if (FALSE) {
[17:43:55.725]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:55.725]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:55.725]     }
[17:43:55.725]     ...future.result <- base::tryCatch({
[17:43:55.725]         base::withCallingHandlers({
[17:43:55.725]             ...future.value <- base::withVisible(base::local({
[17:43:55.725]                 ...future.makeSendCondition <- local({
[17:43:55.725]                   sendCondition <- NULL
[17:43:55.725]                   function(frame = 1L) {
[17:43:55.725]                     if (is.function(sendCondition)) 
[17:43:55.725]                       return(sendCondition)
[17:43:55.725]                     ns <- getNamespace("parallel")
[17:43:55.725]                     if (exists("sendData", mode = "function", 
[17:43:55.725]                       envir = ns)) {
[17:43:55.725]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:55.725]                         envir = ns)
[17:43:55.725]                       envir <- sys.frame(frame)
[17:43:55.725]                       master <- NULL
[17:43:55.725]                       while (!identical(envir, .GlobalEnv) && 
[17:43:55.725]                         !identical(envir, emptyenv())) {
[17:43:55.725]                         if (exists("master", mode = "list", envir = envir, 
[17:43:55.725]                           inherits = FALSE)) {
[17:43:55.725]                           master <- get("master", mode = "list", 
[17:43:55.725]                             envir = envir, inherits = FALSE)
[17:43:55.725]                           if (inherits(master, c("SOCKnode", 
[17:43:55.725]                             "SOCK0node"))) {
[17:43:55.725]                             sendCondition <<- function(cond) {
[17:43:55.725]                               data <- list(type = "VALUE", value = cond, 
[17:43:55.725]                                 success = TRUE)
[17:43:55.725]                               parallel_sendData(master, data)
[17:43:55.725]                             }
[17:43:55.725]                             return(sendCondition)
[17:43:55.725]                           }
[17:43:55.725]                         }
[17:43:55.725]                         frame <- frame + 1L
[17:43:55.725]                         envir <- sys.frame(frame)
[17:43:55.725]                       }
[17:43:55.725]                     }
[17:43:55.725]                     sendCondition <<- function(cond) NULL
[17:43:55.725]                   }
[17:43:55.725]                 })
[17:43:55.725]                 withCallingHandlers({
[17:43:55.725]                   {
[17:43:55.725]                     1
[17:43:55.725]                   }
[17:43:55.725]                 }, immediateCondition = function(cond) {
[17:43:55.725]                   sendCondition <- ...future.makeSendCondition()
[17:43:55.725]                   sendCondition(cond)
[17:43:55.725]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.725]                   {
[17:43:55.725]                     inherits <- base::inherits
[17:43:55.725]                     invokeRestart <- base::invokeRestart
[17:43:55.725]                     is.null <- base::is.null
[17:43:55.725]                     muffled <- FALSE
[17:43:55.725]                     if (inherits(cond, "message")) {
[17:43:55.725]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:55.725]                       if (muffled) 
[17:43:55.725]                         invokeRestart("muffleMessage")
[17:43:55.725]                     }
[17:43:55.725]                     else if (inherits(cond, "warning")) {
[17:43:55.725]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:55.725]                       if (muffled) 
[17:43:55.725]                         invokeRestart("muffleWarning")
[17:43:55.725]                     }
[17:43:55.725]                     else if (inherits(cond, "condition")) {
[17:43:55.725]                       if (!is.null(pattern)) {
[17:43:55.725]                         computeRestarts <- base::computeRestarts
[17:43:55.725]                         grepl <- base::grepl
[17:43:55.725]                         restarts <- computeRestarts(cond)
[17:43:55.725]                         for (restart in restarts) {
[17:43:55.725]                           name <- restart$name
[17:43:55.725]                           if (is.null(name)) 
[17:43:55.725]                             next
[17:43:55.725]                           if (!grepl(pattern, name)) 
[17:43:55.725]                             next
[17:43:55.725]                           invokeRestart(restart)
[17:43:55.725]                           muffled <- TRUE
[17:43:55.725]                           break
[17:43:55.725]                         }
[17:43:55.725]                       }
[17:43:55.725]                     }
[17:43:55.725]                     invisible(muffled)
[17:43:55.725]                   }
[17:43:55.725]                   muffleCondition(cond)
[17:43:55.725]                 })
[17:43:55.725]             }))
[17:43:55.725]             future::FutureResult(value = ...future.value$value, 
[17:43:55.725]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.725]                   ...future.rng), globalenv = if (FALSE) 
[17:43:55.725]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:55.725]                     ...future.globalenv.names))
[17:43:55.725]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:55.725]         }, condition = base::local({
[17:43:55.725]             c <- base::c
[17:43:55.725]             inherits <- base::inherits
[17:43:55.725]             invokeRestart <- base::invokeRestart
[17:43:55.725]             length <- base::length
[17:43:55.725]             list <- base::list
[17:43:55.725]             seq.int <- base::seq.int
[17:43:55.725]             signalCondition <- base::signalCondition
[17:43:55.725]             sys.calls <- base::sys.calls
[17:43:55.725]             `[[` <- base::`[[`
[17:43:55.725]             `+` <- base::`+`
[17:43:55.725]             `<<-` <- base::`<<-`
[17:43:55.725]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:55.725]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:55.725]                   3L)]
[17:43:55.725]             }
[17:43:55.725]             function(cond) {
[17:43:55.725]                 is_error <- inherits(cond, "error")
[17:43:55.725]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:55.725]                   NULL)
[17:43:55.725]                 if (is_error) {
[17:43:55.725]                   sessionInformation <- function() {
[17:43:55.725]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:55.725]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:55.725]                       search = base::search(), system = base::Sys.info())
[17:43:55.725]                   }
[17:43:55.725]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.725]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:55.725]                     cond$call), session = sessionInformation(), 
[17:43:55.725]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:55.725]                   signalCondition(cond)
[17:43:55.725]                 }
[17:43:55.725]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:55.725]                 "immediateCondition"))) {
[17:43:55.725]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:55.725]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.725]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:55.725]                   if (TRUE && !signal) {
[17:43:55.725]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.725]                     {
[17:43:55.725]                       inherits <- base::inherits
[17:43:55.725]                       invokeRestart <- base::invokeRestart
[17:43:55.725]                       is.null <- base::is.null
[17:43:55.725]                       muffled <- FALSE
[17:43:55.725]                       if (inherits(cond, "message")) {
[17:43:55.725]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.725]                         if (muffled) 
[17:43:55.725]                           invokeRestart("muffleMessage")
[17:43:55.725]                       }
[17:43:55.725]                       else if (inherits(cond, "warning")) {
[17:43:55.725]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.725]                         if (muffled) 
[17:43:55.725]                           invokeRestart("muffleWarning")
[17:43:55.725]                       }
[17:43:55.725]                       else if (inherits(cond, "condition")) {
[17:43:55.725]                         if (!is.null(pattern)) {
[17:43:55.725]                           computeRestarts <- base::computeRestarts
[17:43:55.725]                           grepl <- base::grepl
[17:43:55.725]                           restarts <- computeRestarts(cond)
[17:43:55.725]                           for (restart in restarts) {
[17:43:55.725]                             name <- restart$name
[17:43:55.725]                             if (is.null(name)) 
[17:43:55.725]                               next
[17:43:55.725]                             if (!grepl(pattern, name)) 
[17:43:55.725]                               next
[17:43:55.725]                             invokeRestart(restart)
[17:43:55.725]                             muffled <- TRUE
[17:43:55.725]                             break
[17:43:55.725]                           }
[17:43:55.725]                         }
[17:43:55.725]                       }
[17:43:55.725]                       invisible(muffled)
[17:43:55.725]                     }
[17:43:55.725]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.725]                   }
[17:43:55.725]                 }
[17:43:55.725]                 else {
[17:43:55.725]                   if (TRUE) {
[17:43:55.725]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.725]                     {
[17:43:55.725]                       inherits <- base::inherits
[17:43:55.725]                       invokeRestart <- base::invokeRestart
[17:43:55.725]                       is.null <- base::is.null
[17:43:55.725]                       muffled <- FALSE
[17:43:55.725]                       if (inherits(cond, "message")) {
[17:43:55.725]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.725]                         if (muffled) 
[17:43:55.725]                           invokeRestart("muffleMessage")
[17:43:55.725]                       }
[17:43:55.725]                       else if (inherits(cond, "warning")) {
[17:43:55.725]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.725]                         if (muffled) 
[17:43:55.725]                           invokeRestart("muffleWarning")
[17:43:55.725]                       }
[17:43:55.725]                       else if (inherits(cond, "condition")) {
[17:43:55.725]                         if (!is.null(pattern)) {
[17:43:55.725]                           computeRestarts <- base::computeRestarts
[17:43:55.725]                           grepl <- base::grepl
[17:43:55.725]                           restarts <- computeRestarts(cond)
[17:43:55.725]                           for (restart in restarts) {
[17:43:55.725]                             name <- restart$name
[17:43:55.725]                             if (is.null(name)) 
[17:43:55.725]                               next
[17:43:55.725]                             if (!grepl(pattern, name)) 
[17:43:55.725]                               next
[17:43:55.725]                             invokeRestart(restart)
[17:43:55.725]                             muffled <- TRUE
[17:43:55.725]                             break
[17:43:55.725]                           }
[17:43:55.725]                         }
[17:43:55.725]                       }
[17:43:55.725]                       invisible(muffled)
[17:43:55.725]                     }
[17:43:55.725]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.725]                   }
[17:43:55.725]                 }
[17:43:55.725]             }
[17:43:55.725]         }))
[17:43:55.725]     }, error = function(ex) {
[17:43:55.725]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:55.725]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.725]                 ...future.rng), started = ...future.startTime, 
[17:43:55.725]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:55.725]             version = "1.8"), class = "FutureResult")
[17:43:55.725]     }, finally = {
[17:43:55.725]         if (!identical(...future.workdir, getwd())) 
[17:43:55.725]             setwd(...future.workdir)
[17:43:55.725]         {
[17:43:55.725]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:55.725]                 ...future.oldOptions$nwarnings <- NULL
[17:43:55.725]             }
[17:43:55.725]             base::options(...future.oldOptions)
[17:43:55.725]             if (.Platform$OS.type == "windows") {
[17:43:55.725]                 old_names <- names(...future.oldEnvVars)
[17:43:55.725]                 envs <- base::Sys.getenv()
[17:43:55.725]                 names <- names(envs)
[17:43:55.725]                 common <- intersect(names, old_names)
[17:43:55.725]                 added <- setdiff(names, old_names)
[17:43:55.725]                 removed <- setdiff(old_names, names)
[17:43:55.725]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:55.725]                   envs[common]]
[17:43:55.725]                 NAMES <- toupper(changed)
[17:43:55.725]                 args <- list()
[17:43:55.725]                 for (kk in seq_along(NAMES)) {
[17:43:55.725]                   name <- changed[[kk]]
[17:43:55.725]                   NAME <- NAMES[[kk]]
[17:43:55.725]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.725]                     next
[17:43:55.725]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.725]                 }
[17:43:55.725]                 NAMES <- toupper(added)
[17:43:55.725]                 for (kk in seq_along(NAMES)) {
[17:43:55.725]                   name <- added[[kk]]
[17:43:55.725]                   NAME <- NAMES[[kk]]
[17:43:55.725]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.725]                     next
[17:43:55.725]                   args[[name]] <- ""
[17:43:55.725]                 }
[17:43:55.725]                 NAMES <- toupper(removed)
[17:43:55.725]                 for (kk in seq_along(NAMES)) {
[17:43:55.725]                   name <- removed[[kk]]
[17:43:55.725]                   NAME <- NAMES[[kk]]
[17:43:55.725]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.725]                     next
[17:43:55.725]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.725]                 }
[17:43:55.725]                 if (length(args) > 0) 
[17:43:55.725]                   base::do.call(base::Sys.setenv, args = args)
[17:43:55.725]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:55.725]             }
[17:43:55.725]             else {
[17:43:55.725]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:55.725]             }
[17:43:55.725]             {
[17:43:55.725]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:55.725]                   0L) {
[17:43:55.725]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:55.725]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:55.725]                   base::options(opts)
[17:43:55.725]                 }
[17:43:55.725]                 {
[17:43:55.725]                   {
[17:43:55.725]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:55.725]                     NULL
[17:43:55.725]                   }
[17:43:55.725]                   options(future.plan = NULL)
[17:43:55.725]                   if (is.na(NA_character_)) 
[17:43:55.725]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.725]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:55.725]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:55.725]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:55.725]                     envir = parent.frame()) 
[17:43:55.725]                   {
[17:43:55.725]                     if (is.function(workers)) 
[17:43:55.725]                       workers <- workers()
[17:43:55.725]                     workers <- structure(as.integer(workers), 
[17:43:55.725]                       class = class(workers))
[17:43:55.725]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:55.725]                       workers >= 1)
[17:43:55.725]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:55.725]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:55.725]                     }
[17:43:55.725]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:55.725]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:55.725]                       envir = envir)
[17:43:55.725]                     if (!future$lazy) 
[17:43:55.725]                       future <- run(future)
[17:43:55.725]                     invisible(future)
[17:43:55.725]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:55.725]                 }
[17:43:55.725]             }
[17:43:55.725]         }
[17:43:55.725]     })
[17:43:55.725]     if (TRUE) {
[17:43:55.725]         base::sink(type = "output", split = FALSE)
[17:43:55.725]         if (TRUE) {
[17:43:55.725]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:55.725]         }
[17:43:55.725]         else {
[17:43:55.725]             ...future.result["stdout"] <- base::list(NULL)
[17:43:55.725]         }
[17:43:55.725]         base::close(...future.stdout)
[17:43:55.725]         ...future.stdout <- NULL
[17:43:55.725]     }
[17:43:55.725]     ...future.result$conditions <- ...future.conditions
[17:43:55.725]     ...future.result$finished <- base::Sys.time()
[17:43:55.725]     ...future.result
[17:43:55.725] }
[17:43:55.729] MultisessionFuture started
[17:43:55.729] - Launch lazy future ... done
[17:43:55.729] run() for ‘MultisessionFuture’ ... done
[17:43:55.729] getGlobalsAndPackages() ...
[17:43:55.729] Searching for globals...
[17:43:55.730] - globals found: [2] ‘{’, ‘Sys.sleep’
[17:43:55.730] Searching for globals ... DONE
[17:43:55.731] Resolving globals: FALSE
[17:43:55.731] 
[17:43:55.731] 
[17:43:55.731] getGlobalsAndPackages() ... DONE
[17:43:55.734] run() for ‘Future’ ...
[17:43:55.735] - state: ‘created’
[17:43:55.735] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:55.754] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:55.754] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:55.754]   - Field: ‘node’
[17:43:55.754]   - Field: ‘label’
[17:43:55.754]   - Field: ‘local’
[17:43:55.754]   - Field: ‘owner’
[17:43:55.754]   - Field: ‘envir’
[17:43:55.754]   - Field: ‘workers’
[17:43:55.755]   - Field: ‘packages’
[17:43:55.755]   - Field: ‘gc’
[17:43:55.755]   - Field: ‘conditions’
[17:43:55.755]   - Field: ‘persistent’
[17:43:55.755]   - Field: ‘expr’
[17:43:55.755]   - Field: ‘uuid’
[17:43:55.755]   - Field: ‘seed’
[17:43:55.755]   - Field: ‘version’
[17:43:55.755]   - Field: ‘result’
[17:43:55.755]   - Field: ‘asynchronous’
[17:43:55.755]   - Field: ‘calls’
[17:43:55.756]   - Field: ‘globals’
[17:43:55.756]   - Field: ‘stdout’
[17:43:55.756]   - Field: ‘earlySignal’
[17:43:55.756]   - Field: ‘lazy’
[17:43:55.756]   - Field: ‘state’
[17:43:55.756] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:55.756] - Launch lazy future ...
[17:43:55.756] Packages needed by the future expression (n = 0): <none>
[17:43:55.757] Packages needed by future strategies (n = 0): <none>
[17:43:55.757] {
[17:43:55.757]     {
[17:43:55.757]         {
[17:43:55.757]             ...future.startTime <- base::Sys.time()
[17:43:55.757]             {
[17:43:55.757]                 {
[17:43:55.757]                   {
[17:43:55.757]                     {
[17:43:55.757]                       base::local({
[17:43:55.757]                         has_future <- base::requireNamespace("future", 
[17:43:55.757]                           quietly = TRUE)
[17:43:55.757]                         if (has_future) {
[17:43:55.757]                           ns <- base::getNamespace("future")
[17:43:55.757]                           version <- ns[[".package"]][["version"]]
[17:43:55.757]                           if (is.null(version)) 
[17:43:55.757]                             version <- utils::packageVersion("future")
[17:43:55.757]                         }
[17:43:55.757]                         else {
[17:43:55.757]                           version <- NULL
[17:43:55.757]                         }
[17:43:55.757]                         if (!has_future || version < "1.8.0") {
[17:43:55.757]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:55.757]                             "", base::R.version$version.string), 
[17:43:55.757]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:55.757]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:55.757]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:55.757]                               "release", "version")], collapse = " "), 
[17:43:55.757]                             hostname = base::Sys.info()[["nodename"]])
[17:43:55.757]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:55.757]                             info)
[17:43:55.757]                           info <- base::paste(info, collapse = "; ")
[17:43:55.757]                           if (!has_future) {
[17:43:55.757]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:55.757]                               info)
[17:43:55.757]                           }
[17:43:55.757]                           else {
[17:43:55.757]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:55.757]                               info, version)
[17:43:55.757]                           }
[17:43:55.757]                           base::stop(msg)
[17:43:55.757]                         }
[17:43:55.757]                       })
[17:43:55.757]                     }
[17:43:55.757]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:55.757]                     base::options(mc.cores = 1L)
[17:43:55.757]                   }
[17:43:55.757]                   options(future.plan = NULL)
[17:43:55.757]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.757]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:55.757]                 }
[17:43:55.757]                 ...future.workdir <- getwd()
[17:43:55.757]             }
[17:43:55.757]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:55.757]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:55.757]         }
[17:43:55.757]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:55.757]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:55.757]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:55.757]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:55.757]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:55.757]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:55.757]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:55.757]             base::names(...future.oldOptions))
[17:43:55.757]     }
[17:43:55.757]     if (FALSE) {
[17:43:55.757]     }
[17:43:55.757]     else {
[17:43:55.757]         if (TRUE) {
[17:43:55.757]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:55.757]                 open = "w")
[17:43:55.757]         }
[17:43:55.757]         else {
[17:43:55.757]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:55.757]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:55.757]         }
[17:43:55.757]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:55.757]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:55.757]             base::sink(type = "output", split = FALSE)
[17:43:55.757]             base::close(...future.stdout)
[17:43:55.757]         }, add = TRUE)
[17:43:55.757]     }
[17:43:55.757]     ...future.frame <- base::sys.nframe()
[17:43:55.757]     ...future.conditions <- base::list()
[17:43:55.757]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:55.757]     if (FALSE) {
[17:43:55.757]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:55.757]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:55.757]     }
[17:43:55.757]     ...future.result <- base::tryCatch({
[17:43:55.757]         base::withCallingHandlers({
[17:43:55.757]             ...future.value <- base::withVisible(base::local({
[17:43:55.757]                 ...future.makeSendCondition <- local({
[17:43:55.757]                   sendCondition <- NULL
[17:43:55.757]                   function(frame = 1L) {
[17:43:55.757]                     if (is.function(sendCondition)) 
[17:43:55.757]                       return(sendCondition)
[17:43:55.757]                     ns <- getNamespace("parallel")
[17:43:55.757]                     if (exists("sendData", mode = "function", 
[17:43:55.757]                       envir = ns)) {
[17:43:55.757]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:55.757]                         envir = ns)
[17:43:55.757]                       envir <- sys.frame(frame)
[17:43:55.757]                       master <- NULL
[17:43:55.757]                       while (!identical(envir, .GlobalEnv) && 
[17:43:55.757]                         !identical(envir, emptyenv())) {
[17:43:55.757]                         if (exists("master", mode = "list", envir = envir, 
[17:43:55.757]                           inherits = FALSE)) {
[17:43:55.757]                           master <- get("master", mode = "list", 
[17:43:55.757]                             envir = envir, inherits = FALSE)
[17:43:55.757]                           if (inherits(master, c("SOCKnode", 
[17:43:55.757]                             "SOCK0node"))) {
[17:43:55.757]                             sendCondition <<- function(cond) {
[17:43:55.757]                               data <- list(type = "VALUE", value = cond, 
[17:43:55.757]                                 success = TRUE)
[17:43:55.757]                               parallel_sendData(master, data)
[17:43:55.757]                             }
[17:43:55.757]                             return(sendCondition)
[17:43:55.757]                           }
[17:43:55.757]                         }
[17:43:55.757]                         frame <- frame + 1L
[17:43:55.757]                         envir <- sys.frame(frame)
[17:43:55.757]                       }
[17:43:55.757]                     }
[17:43:55.757]                     sendCondition <<- function(cond) NULL
[17:43:55.757]                   }
[17:43:55.757]                 })
[17:43:55.757]                 withCallingHandlers({
[17:43:55.757]                   {
[17:43:55.757]                     Sys.sleep(0.5)
[17:43:55.757]                     2
[17:43:55.757]                   }
[17:43:55.757]                 }, immediateCondition = function(cond) {
[17:43:55.757]                   sendCondition <- ...future.makeSendCondition()
[17:43:55.757]                   sendCondition(cond)
[17:43:55.757]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.757]                   {
[17:43:55.757]                     inherits <- base::inherits
[17:43:55.757]                     invokeRestart <- base::invokeRestart
[17:43:55.757]                     is.null <- base::is.null
[17:43:55.757]                     muffled <- FALSE
[17:43:55.757]                     if (inherits(cond, "message")) {
[17:43:55.757]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:55.757]                       if (muffled) 
[17:43:55.757]                         invokeRestart("muffleMessage")
[17:43:55.757]                     }
[17:43:55.757]                     else if (inherits(cond, "warning")) {
[17:43:55.757]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:55.757]                       if (muffled) 
[17:43:55.757]                         invokeRestart("muffleWarning")
[17:43:55.757]                     }
[17:43:55.757]                     else if (inherits(cond, "condition")) {
[17:43:55.757]                       if (!is.null(pattern)) {
[17:43:55.757]                         computeRestarts <- base::computeRestarts
[17:43:55.757]                         grepl <- base::grepl
[17:43:55.757]                         restarts <- computeRestarts(cond)
[17:43:55.757]                         for (restart in restarts) {
[17:43:55.757]                           name <- restart$name
[17:43:55.757]                           if (is.null(name)) 
[17:43:55.757]                             next
[17:43:55.757]                           if (!grepl(pattern, name)) 
[17:43:55.757]                             next
[17:43:55.757]                           invokeRestart(restart)
[17:43:55.757]                           muffled <- TRUE
[17:43:55.757]                           break
[17:43:55.757]                         }
[17:43:55.757]                       }
[17:43:55.757]                     }
[17:43:55.757]                     invisible(muffled)
[17:43:55.757]                   }
[17:43:55.757]                   muffleCondition(cond)
[17:43:55.757]                 })
[17:43:55.757]             }))
[17:43:55.757]             future::FutureResult(value = ...future.value$value, 
[17:43:55.757]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.757]                   ...future.rng), globalenv = if (FALSE) 
[17:43:55.757]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:55.757]                     ...future.globalenv.names))
[17:43:55.757]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:55.757]         }, condition = base::local({
[17:43:55.757]             c <- base::c
[17:43:55.757]             inherits <- base::inherits
[17:43:55.757]             invokeRestart <- base::invokeRestart
[17:43:55.757]             length <- base::length
[17:43:55.757]             list <- base::list
[17:43:55.757]             seq.int <- base::seq.int
[17:43:55.757]             signalCondition <- base::signalCondition
[17:43:55.757]             sys.calls <- base::sys.calls
[17:43:55.757]             `[[` <- base::`[[`
[17:43:55.757]             `+` <- base::`+`
[17:43:55.757]             `<<-` <- base::`<<-`
[17:43:55.757]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:55.757]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:55.757]                   3L)]
[17:43:55.757]             }
[17:43:55.757]             function(cond) {
[17:43:55.757]                 is_error <- inherits(cond, "error")
[17:43:55.757]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:55.757]                   NULL)
[17:43:55.757]                 if (is_error) {
[17:43:55.757]                   sessionInformation <- function() {
[17:43:55.757]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:55.757]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:55.757]                       search = base::search(), system = base::Sys.info())
[17:43:55.757]                   }
[17:43:55.757]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.757]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:55.757]                     cond$call), session = sessionInformation(), 
[17:43:55.757]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:55.757]                   signalCondition(cond)
[17:43:55.757]                 }
[17:43:55.757]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:55.757]                 "immediateCondition"))) {
[17:43:55.757]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:55.757]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.757]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:55.757]                   if (TRUE && !signal) {
[17:43:55.757]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.757]                     {
[17:43:55.757]                       inherits <- base::inherits
[17:43:55.757]                       invokeRestart <- base::invokeRestart
[17:43:55.757]                       is.null <- base::is.null
[17:43:55.757]                       muffled <- FALSE
[17:43:55.757]                       if (inherits(cond, "message")) {
[17:43:55.757]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.757]                         if (muffled) 
[17:43:55.757]                           invokeRestart("muffleMessage")
[17:43:55.757]                       }
[17:43:55.757]                       else if (inherits(cond, "warning")) {
[17:43:55.757]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.757]                         if (muffled) 
[17:43:55.757]                           invokeRestart("muffleWarning")
[17:43:55.757]                       }
[17:43:55.757]                       else if (inherits(cond, "condition")) {
[17:43:55.757]                         if (!is.null(pattern)) {
[17:43:55.757]                           computeRestarts <- base::computeRestarts
[17:43:55.757]                           grepl <- base::grepl
[17:43:55.757]                           restarts <- computeRestarts(cond)
[17:43:55.757]                           for (restart in restarts) {
[17:43:55.757]                             name <- restart$name
[17:43:55.757]                             if (is.null(name)) 
[17:43:55.757]                               next
[17:43:55.757]                             if (!grepl(pattern, name)) 
[17:43:55.757]                               next
[17:43:55.757]                             invokeRestart(restart)
[17:43:55.757]                             muffled <- TRUE
[17:43:55.757]                             break
[17:43:55.757]                           }
[17:43:55.757]                         }
[17:43:55.757]                       }
[17:43:55.757]                       invisible(muffled)
[17:43:55.757]                     }
[17:43:55.757]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.757]                   }
[17:43:55.757]                 }
[17:43:55.757]                 else {
[17:43:55.757]                   if (TRUE) {
[17:43:55.757]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.757]                     {
[17:43:55.757]                       inherits <- base::inherits
[17:43:55.757]                       invokeRestart <- base::invokeRestart
[17:43:55.757]                       is.null <- base::is.null
[17:43:55.757]                       muffled <- FALSE
[17:43:55.757]                       if (inherits(cond, "message")) {
[17:43:55.757]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.757]                         if (muffled) 
[17:43:55.757]                           invokeRestart("muffleMessage")
[17:43:55.757]                       }
[17:43:55.757]                       else if (inherits(cond, "warning")) {
[17:43:55.757]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.757]                         if (muffled) 
[17:43:55.757]                           invokeRestart("muffleWarning")
[17:43:55.757]                       }
[17:43:55.757]                       else if (inherits(cond, "condition")) {
[17:43:55.757]                         if (!is.null(pattern)) {
[17:43:55.757]                           computeRestarts <- base::computeRestarts
[17:43:55.757]                           grepl <- base::grepl
[17:43:55.757]                           restarts <- computeRestarts(cond)
[17:43:55.757]                           for (restart in restarts) {
[17:43:55.757]                             name <- restart$name
[17:43:55.757]                             if (is.null(name)) 
[17:43:55.757]                               next
[17:43:55.757]                             if (!grepl(pattern, name)) 
[17:43:55.757]                               next
[17:43:55.757]                             invokeRestart(restart)
[17:43:55.757]                             muffled <- TRUE
[17:43:55.757]                             break
[17:43:55.757]                           }
[17:43:55.757]                         }
[17:43:55.757]                       }
[17:43:55.757]                       invisible(muffled)
[17:43:55.757]                     }
[17:43:55.757]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.757]                   }
[17:43:55.757]                 }
[17:43:55.757]             }
[17:43:55.757]         }))
[17:43:55.757]     }, error = function(ex) {
[17:43:55.757]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:55.757]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.757]                 ...future.rng), started = ...future.startTime, 
[17:43:55.757]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:55.757]             version = "1.8"), class = "FutureResult")
[17:43:55.757]     }, finally = {
[17:43:55.757]         if (!identical(...future.workdir, getwd())) 
[17:43:55.757]             setwd(...future.workdir)
[17:43:55.757]         {
[17:43:55.757]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:55.757]                 ...future.oldOptions$nwarnings <- NULL
[17:43:55.757]             }
[17:43:55.757]             base::options(...future.oldOptions)
[17:43:55.757]             if (.Platform$OS.type == "windows") {
[17:43:55.757]                 old_names <- names(...future.oldEnvVars)
[17:43:55.757]                 envs <- base::Sys.getenv()
[17:43:55.757]                 names <- names(envs)
[17:43:55.757]                 common <- intersect(names, old_names)
[17:43:55.757]                 added <- setdiff(names, old_names)
[17:43:55.757]                 removed <- setdiff(old_names, names)
[17:43:55.757]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:55.757]                   envs[common]]
[17:43:55.757]                 NAMES <- toupper(changed)
[17:43:55.757]                 args <- list()
[17:43:55.757]                 for (kk in seq_along(NAMES)) {
[17:43:55.757]                   name <- changed[[kk]]
[17:43:55.757]                   NAME <- NAMES[[kk]]
[17:43:55.757]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.757]                     next
[17:43:55.757]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.757]                 }
[17:43:55.757]                 NAMES <- toupper(added)
[17:43:55.757]                 for (kk in seq_along(NAMES)) {
[17:43:55.757]                   name <- added[[kk]]
[17:43:55.757]                   NAME <- NAMES[[kk]]
[17:43:55.757]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.757]                     next
[17:43:55.757]                   args[[name]] <- ""
[17:43:55.757]                 }
[17:43:55.757]                 NAMES <- toupper(removed)
[17:43:55.757]                 for (kk in seq_along(NAMES)) {
[17:43:55.757]                   name <- removed[[kk]]
[17:43:55.757]                   NAME <- NAMES[[kk]]
[17:43:55.757]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.757]                     next
[17:43:55.757]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.757]                 }
[17:43:55.757]                 if (length(args) > 0) 
[17:43:55.757]                   base::do.call(base::Sys.setenv, args = args)
[17:43:55.757]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:55.757]             }
[17:43:55.757]             else {
[17:43:55.757]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:55.757]             }
[17:43:55.757]             {
[17:43:55.757]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:55.757]                   0L) {
[17:43:55.757]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:55.757]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:55.757]                   base::options(opts)
[17:43:55.757]                 }
[17:43:55.757]                 {
[17:43:55.757]                   {
[17:43:55.757]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:55.757]                     NULL
[17:43:55.757]                   }
[17:43:55.757]                   options(future.plan = NULL)
[17:43:55.757]                   if (is.na(NA_character_)) 
[17:43:55.757]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.757]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:55.757]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:55.757]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:55.757]                     envir = parent.frame()) 
[17:43:55.757]                   {
[17:43:55.757]                     if (is.function(workers)) 
[17:43:55.757]                       workers <- workers()
[17:43:55.757]                     workers <- structure(as.integer(workers), 
[17:43:55.757]                       class = class(workers))
[17:43:55.757]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:55.757]                       workers >= 1)
[17:43:55.757]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:55.757]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:55.757]                     }
[17:43:55.757]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:55.757]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:55.757]                       envir = envir)
[17:43:55.757]                     if (!future$lazy) 
[17:43:55.757]                       future <- run(future)
[17:43:55.757]                     invisible(future)
[17:43:55.757]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:55.757]                 }
[17:43:55.757]             }
[17:43:55.757]         }
[17:43:55.757]     })
[17:43:55.757]     if (TRUE) {
[17:43:55.757]         base::sink(type = "output", split = FALSE)
[17:43:55.757]         if (TRUE) {
[17:43:55.757]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:55.757]         }
[17:43:55.757]         else {
[17:43:55.757]             ...future.result["stdout"] <- base::list(NULL)
[17:43:55.757]         }
[17:43:55.757]         base::close(...future.stdout)
[17:43:55.757]         ...future.stdout <- NULL
[17:43:55.757]     }
[17:43:55.757]     ...future.result$conditions <- ...future.conditions
[17:43:55.757]     ...future.result$finished <- base::Sys.time()
[17:43:55.757]     ...future.result
[17:43:55.757] }
[17:43:55.760] MultisessionFuture started
[17:43:55.761] - Launch lazy future ... done
[17:43:55.761] run() for ‘MultisessionFuture’ ... done
[17:43:55.761] getGlobalsAndPackages() ...
[17:43:55.761] Searching for globals...
[17:43:55.762] - globals found: [1] ‘{’
[17:43:55.762] Searching for globals ... DONE
[17:43:55.762] Resolving globals: FALSE
[17:43:55.762] 
[17:43:55.762] 
[17:43:55.763] getGlobalsAndPackages() ... DONE
[17:43:55.763] run() for ‘Future’ ...
[17:43:55.763] - state: ‘created’
[17:43:55.763] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:43:55.779] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:43:55.779] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:43:55.779]   - Field: ‘node’
[17:43:55.779]   - Field: ‘label’
[17:43:55.779]   - Field: ‘local’
[17:43:55.779]   - Field: ‘owner’
[17:43:55.780]   - Field: ‘envir’
[17:43:55.780]   - Field: ‘workers’
[17:43:55.780]   - Field: ‘packages’
[17:43:55.780]   - Field: ‘gc’
[17:43:55.780]   - Field: ‘conditions’
[17:43:55.780]   - Field: ‘persistent’
[17:43:55.780]   - Field: ‘expr’
[17:43:55.780]   - Field: ‘uuid’
[17:43:55.780]   - Field: ‘seed’
[17:43:55.780]   - Field: ‘version’
[17:43:55.780]   - Field: ‘result’
[17:43:55.781]   - Field: ‘asynchronous’
[17:43:55.781]   - Field: ‘calls’
[17:43:55.781]   - Field: ‘globals’
[17:43:55.781]   - Field: ‘stdout’
[17:43:55.781]   - Field: ‘earlySignal’
[17:43:55.781]   - Field: ‘lazy’
[17:43:55.781]   - Field: ‘state’
[17:43:55.781] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:43:55.781] - Launch lazy future ...
[17:43:55.782] Packages needed by the future expression (n = 0): <none>
[17:43:55.782] Packages needed by future strategies (n = 0): <none>
[17:43:55.782] {
[17:43:55.782]     {
[17:43:55.782]         {
[17:43:55.782]             ...future.startTime <- base::Sys.time()
[17:43:55.782]             {
[17:43:55.782]                 {
[17:43:55.782]                   {
[17:43:55.782]                     {
[17:43:55.782]                       base::local({
[17:43:55.782]                         has_future <- base::requireNamespace("future", 
[17:43:55.782]                           quietly = TRUE)
[17:43:55.782]                         if (has_future) {
[17:43:55.782]                           ns <- base::getNamespace("future")
[17:43:55.782]                           version <- ns[[".package"]][["version"]]
[17:43:55.782]                           if (is.null(version)) 
[17:43:55.782]                             version <- utils::packageVersion("future")
[17:43:55.782]                         }
[17:43:55.782]                         else {
[17:43:55.782]                           version <- NULL
[17:43:55.782]                         }
[17:43:55.782]                         if (!has_future || version < "1.8.0") {
[17:43:55.782]                           info <- base::c(r_version = base::gsub("R version ", 
[17:43:55.782]                             "", base::R.version$version.string), 
[17:43:55.782]                             platform = base::sprintf("%s (%s-bit)", 
[17:43:55.782]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:43:55.782]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:43:55.782]                               "release", "version")], collapse = " "), 
[17:43:55.782]                             hostname = base::Sys.info()[["nodename"]])
[17:43:55.782]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:43:55.782]                             info)
[17:43:55.782]                           info <- base::paste(info, collapse = "; ")
[17:43:55.782]                           if (!has_future) {
[17:43:55.782]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:43:55.782]                               info)
[17:43:55.782]                           }
[17:43:55.782]                           else {
[17:43:55.782]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:43:55.782]                               info, version)
[17:43:55.782]                           }
[17:43:55.782]                           base::stop(msg)
[17:43:55.782]                         }
[17:43:55.782]                       })
[17:43:55.782]                     }
[17:43:55.782]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:43:55.782]                     base::options(mc.cores = 1L)
[17:43:55.782]                   }
[17:43:55.782]                   options(future.plan = NULL)
[17:43:55.782]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.782]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:43:55.782]                 }
[17:43:55.782]                 ...future.workdir <- getwd()
[17:43:55.782]             }
[17:43:55.782]             ...future.oldOptions <- base::as.list(base::.Options)
[17:43:55.782]             ...future.oldEnvVars <- base::Sys.getenv()
[17:43:55.782]         }
[17:43:55.782]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:43:55.782]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:43:55.782]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:43:55.782]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:43:55.782]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:43:55.782]             future.stdout.windows.reencode = NULL, width = 80L)
[17:43:55.782]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:43:55.782]             base::names(...future.oldOptions))
[17:43:55.782]     }
[17:43:55.782]     if (FALSE) {
[17:43:55.782]     }
[17:43:55.782]     else {
[17:43:55.782]         if (TRUE) {
[17:43:55.782]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:43:55.782]                 open = "w")
[17:43:55.782]         }
[17:43:55.782]         else {
[17:43:55.782]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:43:55.782]                 windows = "NUL", "/dev/null"), open = "w")
[17:43:55.782]         }
[17:43:55.782]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:43:55.782]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:43:55.782]             base::sink(type = "output", split = FALSE)
[17:43:55.782]             base::close(...future.stdout)
[17:43:55.782]         }, add = TRUE)
[17:43:55.782]     }
[17:43:55.782]     ...future.frame <- base::sys.nframe()
[17:43:55.782]     ...future.conditions <- base::list()
[17:43:55.782]     ...future.rng <- base::globalenv()$.Random.seed
[17:43:55.782]     if (FALSE) {
[17:43:55.782]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:43:55.782]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:43:55.782]     }
[17:43:55.782]     ...future.result <- base::tryCatch({
[17:43:55.782]         base::withCallingHandlers({
[17:43:55.782]             ...future.value <- base::withVisible(base::local({
[17:43:55.782]                 ...future.makeSendCondition <- local({
[17:43:55.782]                   sendCondition <- NULL
[17:43:55.782]                   function(frame = 1L) {
[17:43:55.782]                     if (is.function(sendCondition)) 
[17:43:55.782]                       return(sendCondition)
[17:43:55.782]                     ns <- getNamespace("parallel")
[17:43:55.782]                     if (exists("sendData", mode = "function", 
[17:43:55.782]                       envir = ns)) {
[17:43:55.782]                       parallel_sendData <- get("sendData", mode = "function", 
[17:43:55.782]                         envir = ns)
[17:43:55.782]                       envir <- sys.frame(frame)
[17:43:55.782]                       master <- NULL
[17:43:55.782]                       while (!identical(envir, .GlobalEnv) && 
[17:43:55.782]                         !identical(envir, emptyenv())) {
[17:43:55.782]                         if (exists("master", mode = "list", envir = envir, 
[17:43:55.782]                           inherits = FALSE)) {
[17:43:55.782]                           master <- get("master", mode = "list", 
[17:43:55.782]                             envir = envir, inherits = FALSE)
[17:43:55.782]                           if (inherits(master, c("SOCKnode", 
[17:43:55.782]                             "SOCK0node"))) {
[17:43:55.782]                             sendCondition <<- function(cond) {
[17:43:55.782]                               data <- list(type = "VALUE", value = cond, 
[17:43:55.782]                                 success = TRUE)
[17:43:55.782]                               parallel_sendData(master, data)
[17:43:55.782]                             }
[17:43:55.782]                             return(sendCondition)
[17:43:55.782]                           }
[17:43:55.782]                         }
[17:43:55.782]                         frame <- frame + 1L
[17:43:55.782]                         envir <- sys.frame(frame)
[17:43:55.782]                       }
[17:43:55.782]                     }
[17:43:55.782]                     sendCondition <<- function(cond) NULL
[17:43:55.782]                   }
[17:43:55.782]                 })
[17:43:55.782]                 withCallingHandlers({
[17:43:55.782]                   {
[17:43:55.782]                     3
[17:43:55.782]                   }
[17:43:55.782]                 }, immediateCondition = function(cond) {
[17:43:55.782]                   sendCondition <- ...future.makeSendCondition()
[17:43:55.782]                   sendCondition(cond)
[17:43:55.782]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.782]                   {
[17:43:55.782]                     inherits <- base::inherits
[17:43:55.782]                     invokeRestart <- base::invokeRestart
[17:43:55.782]                     is.null <- base::is.null
[17:43:55.782]                     muffled <- FALSE
[17:43:55.782]                     if (inherits(cond, "message")) {
[17:43:55.782]                       muffled <- grepl(pattern, "muffleMessage")
[17:43:55.782]                       if (muffled) 
[17:43:55.782]                         invokeRestart("muffleMessage")
[17:43:55.782]                     }
[17:43:55.782]                     else if (inherits(cond, "warning")) {
[17:43:55.782]                       muffled <- grepl(pattern, "muffleWarning")
[17:43:55.782]                       if (muffled) 
[17:43:55.782]                         invokeRestart("muffleWarning")
[17:43:55.782]                     }
[17:43:55.782]                     else if (inherits(cond, "condition")) {
[17:43:55.782]                       if (!is.null(pattern)) {
[17:43:55.782]                         computeRestarts <- base::computeRestarts
[17:43:55.782]                         grepl <- base::grepl
[17:43:55.782]                         restarts <- computeRestarts(cond)
[17:43:55.782]                         for (restart in restarts) {
[17:43:55.782]                           name <- restart$name
[17:43:55.782]                           if (is.null(name)) 
[17:43:55.782]                             next
[17:43:55.782]                           if (!grepl(pattern, name)) 
[17:43:55.782]                             next
[17:43:55.782]                           invokeRestart(restart)
[17:43:55.782]                           muffled <- TRUE
[17:43:55.782]                           break
[17:43:55.782]                         }
[17:43:55.782]                       }
[17:43:55.782]                     }
[17:43:55.782]                     invisible(muffled)
[17:43:55.782]                   }
[17:43:55.782]                   muffleCondition(cond)
[17:43:55.782]                 })
[17:43:55.782]             }))
[17:43:55.782]             future::FutureResult(value = ...future.value$value, 
[17:43:55.782]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.782]                   ...future.rng), globalenv = if (FALSE) 
[17:43:55.782]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:43:55.782]                     ...future.globalenv.names))
[17:43:55.782]                 else NULL, started = ...future.startTime, version = "1.8")
[17:43:55.782]         }, condition = base::local({
[17:43:55.782]             c <- base::c
[17:43:55.782]             inherits <- base::inherits
[17:43:55.782]             invokeRestart <- base::invokeRestart
[17:43:55.782]             length <- base::length
[17:43:55.782]             list <- base::list
[17:43:55.782]             seq.int <- base::seq.int
[17:43:55.782]             signalCondition <- base::signalCondition
[17:43:55.782]             sys.calls <- base::sys.calls
[17:43:55.782]             `[[` <- base::`[[`
[17:43:55.782]             `+` <- base::`+`
[17:43:55.782]             `<<-` <- base::`<<-`
[17:43:55.782]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:43:55.782]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:43:55.782]                   3L)]
[17:43:55.782]             }
[17:43:55.782]             function(cond) {
[17:43:55.782]                 is_error <- inherits(cond, "error")
[17:43:55.782]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:43:55.782]                   NULL)
[17:43:55.782]                 if (is_error) {
[17:43:55.782]                   sessionInformation <- function() {
[17:43:55.782]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:43:55.782]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:43:55.782]                       search = base::search(), system = base::Sys.info())
[17:43:55.782]                   }
[17:43:55.782]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.782]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:43:55.782]                     cond$call), session = sessionInformation(), 
[17:43:55.782]                     timestamp = base::Sys.time(), signaled = 0L)
[17:43:55.782]                   signalCondition(cond)
[17:43:55.782]                 }
[17:43:55.782]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:43:55.782]                 "immediateCondition"))) {
[17:43:55.782]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:43:55.782]                   ...future.conditions[[length(...future.conditions) + 
[17:43:55.782]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:43:55.782]                   if (TRUE && !signal) {
[17:43:55.782]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.782]                     {
[17:43:55.782]                       inherits <- base::inherits
[17:43:55.782]                       invokeRestart <- base::invokeRestart
[17:43:55.782]                       is.null <- base::is.null
[17:43:55.782]                       muffled <- FALSE
[17:43:55.782]                       if (inherits(cond, "message")) {
[17:43:55.782]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.782]                         if (muffled) 
[17:43:55.782]                           invokeRestart("muffleMessage")
[17:43:55.782]                       }
[17:43:55.782]                       else if (inherits(cond, "warning")) {
[17:43:55.782]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.782]                         if (muffled) 
[17:43:55.782]                           invokeRestart("muffleWarning")
[17:43:55.782]                       }
[17:43:55.782]                       else if (inherits(cond, "condition")) {
[17:43:55.782]                         if (!is.null(pattern)) {
[17:43:55.782]                           computeRestarts <- base::computeRestarts
[17:43:55.782]                           grepl <- base::grepl
[17:43:55.782]                           restarts <- computeRestarts(cond)
[17:43:55.782]                           for (restart in restarts) {
[17:43:55.782]                             name <- restart$name
[17:43:55.782]                             if (is.null(name)) 
[17:43:55.782]                               next
[17:43:55.782]                             if (!grepl(pattern, name)) 
[17:43:55.782]                               next
[17:43:55.782]                             invokeRestart(restart)
[17:43:55.782]                             muffled <- TRUE
[17:43:55.782]                             break
[17:43:55.782]                           }
[17:43:55.782]                         }
[17:43:55.782]                       }
[17:43:55.782]                       invisible(muffled)
[17:43:55.782]                     }
[17:43:55.782]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.782]                   }
[17:43:55.782]                 }
[17:43:55.782]                 else {
[17:43:55.782]                   if (TRUE) {
[17:43:55.782]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:43:55.782]                     {
[17:43:55.782]                       inherits <- base::inherits
[17:43:55.782]                       invokeRestart <- base::invokeRestart
[17:43:55.782]                       is.null <- base::is.null
[17:43:55.782]                       muffled <- FALSE
[17:43:55.782]                       if (inherits(cond, "message")) {
[17:43:55.782]                         muffled <- grepl(pattern, "muffleMessage")
[17:43:55.782]                         if (muffled) 
[17:43:55.782]                           invokeRestart("muffleMessage")
[17:43:55.782]                       }
[17:43:55.782]                       else if (inherits(cond, "warning")) {
[17:43:55.782]                         muffled <- grepl(pattern, "muffleWarning")
[17:43:55.782]                         if (muffled) 
[17:43:55.782]                           invokeRestart("muffleWarning")
[17:43:55.782]                       }
[17:43:55.782]                       else if (inherits(cond, "condition")) {
[17:43:55.782]                         if (!is.null(pattern)) {
[17:43:55.782]                           computeRestarts <- base::computeRestarts
[17:43:55.782]                           grepl <- base::grepl
[17:43:55.782]                           restarts <- computeRestarts(cond)
[17:43:55.782]                           for (restart in restarts) {
[17:43:55.782]                             name <- restart$name
[17:43:55.782]                             if (is.null(name)) 
[17:43:55.782]                               next
[17:43:55.782]                             if (!grepl(pattern, name)) 
[17:43:55.782]                               next
[17:43:55.782]                             invokeRestart(restart)
[17:43:55.782]                             muffled <- TRUE
[17:43:55.782]                             break
[17:43:55.782]                           }
[17:43:55.782]                         }
[17:43:55.782]                       }
[17:43:55.782]                       invisible(muffled)
[17:43:55.782]                     }
[17:43:55.782]                     muffleCondition(cond, pattern = "^muffle")
[17:43:55.782]                   }
[17:43:55.782]                 }
[17:43:55.782]             }
[17:43:55.782]         }))
[17:43:55.782]     }, error = function(ex) {
[17:43:55.782]         base::structure(base::list(value = NULL, visible = NULL, 
[17:43:55.782]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:43:55.782]                 ...future.rng), started = ...future.startTime, 
[17:43:55.782]             finished = Sys.time(), session_uuid = NA_character_, 
[17:43:55.782]             version = "1.8"), class = "FutureResult")
[17:43:55.782]     }, finally = {
[17:43:55.782]         if (!identical(...future.workdir, getwd())) 
[17:43:55.782]             setwd(...future.workdir)
[17:43:55.782]         {
[17:43:55.782]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:43:55.782]                 ...future.oldOptions$nwarnings <- NULL
[17:43:55.782]             }
[17:43:55.782]             base::options(...future.oldOptions)
[17:43:55.782]             if (.Platform$OS.type == "windows") {
[17:43:55.782]                 old_names <- names(...future.oldEnvVars)
[17:43:55.782]                 envs <- base::Sys.getenv()
[17:43:55.782]                 names <- names(envs)
[17:43:55.782]                 common <- intersect(names, old_names)
[17:43:55.782]                 added <- setdiff(names, old_names)
[17:43:55.782]                 removed <- setdiff(old_names, names)
[17:43:55.782]                 changed <- common[...future.oldEnvVars[common] != 
[17:43:55.782]                   envs[common]]
[17:43:55.782]                 NAMES <- toupper(changed)
[17:43:55.782]                 args <- list()
[17:43:55.782]                 for (kk in seq_along(NAMES)) {
[17:43:55.782]                   name <- changed[[kk]]
[17:43:55.782]                   NAME <- NAMES[[kk]]
[17:43:55.782]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.782]                     next
[17:43:55.782]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.782]                 }
[17:43:55.782]                 NAMES <- toupper(added)
[17:43:55.782]                 for (kk in seq_along(NAMES)) {
[17:43:55.782]                   name <- added[[kk]]
[17:43:55.782]                   NAME <- NAMES[[kk]]
[17:43:55.782]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.782]                     next
[17:43:55.782]                   args[[name]] <- ""
[17:43:55.782]                 }
[17:43:55.782]                 NAMES <- toupper(removed)
[17:43:55.782]                 for (kk in seq_along(NAMES)) {
[17:43:55.782]                   name <- removed[[kk]]
[17:43:55.782]                   NAME <- NAMES[[kk]]
[17:43:55.782]                   if (name != NAME && is.element(NAME, old_names)) 
[17:43:55.782]                     next
[17:43:55.782]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:43:55.782]                 }
[17:43:55.782]                 if (length(args) > 0) 
[17:43:55.782]                   base::do.call(base::Sys.setenv, args = args)
[17:43:55.782]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:43:55.782]             }
[17:43:55.782]             else {
[17:43:55.782]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:43:55.782]             }
[17:43:55.782]             {
[17:43:55.782]                 if (base::length(...future.futureOptionsAdded) > 
[17:43:55.782]                   0L) {
[17:43:55.782]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:43:55.782]                   base::names(opts) <- ...future.futureOptionsAdded
[17:43:55.782]                   base::options(opts)
[17:43:55.782]                 }
[17:43:55.782]                 {
[17:43:55.782]                   {
[17:43:55.782]                     base::options(mc.cores = ...future.mc.cores.old)
[17:43:55.782]                     NULL
[17:43:55.782]                   }
[17:43:55.782]                   options(future.plan = NULL)
[17:43:55.782]                   if (is.na(NA_character_)) 
[17:43:55.782]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:43:55.782]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:43:55.782]                   future::plan(list(function (..., workers = availableCores(), 
[17:43:55.782]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:43:55.782]                     envir = parent.frame()) 
[17:43:55.782]                   {
[17:43:55.782]                     if (is.function(workers)) 
[17:43:55.782]                       workers <- workers()
[17:43:55.782]                     workers <- structure(as.integer(workers), 
[17:43:55.782]                       class = class(workers))
[17:43:55.782]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:43:55.782]                       workers >= 1)
[17:43:55.782]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:43:55.782]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:43:55.782]                     }
[17:43:55.782]                     future <- MultisessionFuture(..., workers = workers, 
[17:43:55.782]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:43:55.782]                       envir = envir)
[17:43:55.782]                     if (!future$lazy) 
[17:43:55.782]                       future <- run(future)
[17:43:55.782]                     invisible(future)
[17:43:55.782]                   }), .cleanup = FALSE, .init = FALSE)
[17:43:55.782]                 }
[17:43:55.782]             }
[17:43:55.782]         }
[17:43:55.782]     })
[17:43:55.782]     if (TRUE) {
[17:43:55.782]         base::sink(type = "output", split = FALSE)
[17:43:55.782]         if (TRUE) {
[17:43:55.782]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:43:55.782]         }
[17:43:55.782]         else {
[17:43:55.782]             ...future.result["stdout"] <- base::list(NULL)
[17:43:55.782]         }
[17:43:55.782]         base::close(...future.stdout)
[17:43:55.782]         ...future.stdout <- NULL
[17:43:55.782]     }
[17:43:55.782]     ...future.result$conditions <- ...future.conditions
[17:43:55.782]     ...future.result$finished <- base::Sys.time()
[17:43:55.782]     ...future.result
[17:43:55.782] }
[17:43:55.785] Poll #1 (0): usedNodes() = 2, workers = 2
[17:43:55.796] receiveMessageFromWorker() for ClusterFuture ...
[17:43:55.796] - Validating connection of MultisessionFuture
[17:43:55.796] - received message: FutureResult
[17:43:55.796] - Received FutureResult
[17:43:55.796] - Erased future from FutureRegistry
[17:43:55.796] result() for ClusterFuture ...
[17:43:55.796] - result already collected: FutureResult
[17:43:55.797] result() for ClusterFuture ... done
[17:43:55.797] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:55.797] result() for ClusterFuture ...
[17:43:55.797] - result already collected: FutureResult
[17:43:55.797] result() for ClusterFuture ... done
[17:43:55.797] result() for ClusterFuture ...
[17:43:55.797] - result already collected: FutureResult
[17:43:55.797] result() for ClusterFuture ... done
[17:43:55.798] MultisessionFuture started
[17:43:55.798] - Launch lazy future ... done
[17:43:55.798] run() for ‘MultisessionFuture’ ... done
[17:43:55.799] resolve() on list environment ...
[17:43:55.799]  recursive: 0
[17:43:55.800]  length: 4
[17:43:55.800]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:43:55.800] Future #1
[17:43:55.800]  length: 3 (resolved future 1)
[17:43:55.822]  length: 2 (resolved future 4)
[17:43:55.844] receiveMessageFromWorker() for ClusterFuture ...
[17:43:55.844] - Validating connection of MultisessionFuture
[17:43:55.845] - received message: FutureResult
[17:43:55.845] - Received FutureResult
[17:43:55.845] - Erased future from FutureRegistry
[17:43:55.845] result() for ClusterFuture ...
[17:43:55.845] - result already collected: FutureResult
[17:43:55.845] result() for ClusterFuture ... done
[17:43:55.845] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:55.845] Future #3
[17:43:55.845]  length: 1 (resolved future 3)
[17:43:56.312] receiveMessageFromWorker() for ClusterFuture ...
[17:43:56.313] - Validating connection of MultisessionFuture
[17:43:56.313] - received message: FutureResult
[17:43:56.313] - Received FutureResult
[17:43:56.313] - Erased future from FutureRegistry
[17:43:56.313] result() for ClusterFuture ...
[17:43:56.313] - result already collected: FutureResult
[17:43:56.313] result() for ClusterFuture ... done
[17:43:56.313] receiveMessageFromWorker() for ClusterFuture ... done
[17:43:56.314] Future #2
[17:43:56.314]  length: 0 (resolved future 2)
[17:43:56.314] resolve() on list environment ... DONE
[17:43:56.314] resolve() on list environment ...
[17:43:56.314]  recursive: 0
[17:43:56.315]  length: 4
[17:43:56.315]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:43:56.315] Future #1
[17:43:56.315]  length: 3 (resolved future 1)
[17:43:56.315] Future #2
[17:43:56.316]  length: 2 (resolved future 2)
[17:43:56.316] Future #3
[17:43:56.316]  length: 1 (resolved future 3)
[17:43:56.316]  length: 0 (resolved future 4)
[17:43:56.316] resolve() on list environment ... DONE
[17:43:56.316] resolve() on list environment ...
[17:43:56.317]  recursive: 0
[17:43:56.317]  length: 4
[17:43:56.317]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:43:56.317] Future #1
[17:43:56.318]  length: 3 (resolved future 1)
[17:43:56.318] Future #2
[17:43:56.318]  length: 2 (resolved future 2)
[17:43:56.318] Future #3
[17:43:56.318]  length: 1 (resolved future 3)
[17:43:56.318]  length: 0 (resolved future 4)
[17:43:56.318] resolve() on list environment ... DONE
[17:43:56.319] resolve() on list environment ...
[17:43:56.319]  recursive: 0
[17:43:56.319]  length: 4
[17:43:56.319]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:43:56.320] Future #1
[17:43:56.320]  length: 3 (resolved future 1)
[17:43:56.320] Future #2
[17:43:56.320]  length: 2 (resolved future 2)
[17:43:56.320] Future #3
[17:43:56.320]  length: 1 (resolved future 3)
[17:43:56.320]  length: 0 (resolved future 4)
[17:43:56.320] resolve() on list environment ... DONE
[17:43:56.321] resolve() on list environment ...
[17:43:56.321]  recursive: 0
[17:43:56.321]  length: 4
[17:43:56.322]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:43:56.322] Future #1
[17:43:56.322] result() for ClusterFuture ...
[17:43:56.322] - result already collected: FutureResult
[17:43:56.322] result() for ClusterFuture ... done
[17:43:56.322] result() for ClusterFuture ...
[17:43:56.322] - result already collected: FutureResult
[17:43:56.322] result() for ClusterFuture ... done
[17:43:56.322]  length: 3 (resolved future 1)
[17:43:56.322] Future #2
[17:43:56.323] result() for ClusterFuture ...
[17:43:56.323] - result already collected: FutureResult
[17:43:56.323] result() for ClusterFuture ... done
[17:43:56.323] result() for ClusterFuture ...
[17:43:56.323] - result already collected: FutureResult
[17:43:56.323] result() for ClusterFuture ... done
[17:43:56.323]  length: 2 (resolved future 2)
[17:43:56.323] Future #3
[17:43:56.323] result() for ClusterFuture ...
[17:43:56.323] - result already collected: FutureResult
[17:43:56.324] result() for ClusterFuture ... done
[17:43:56.324] result() for ClusterFuture ...
[17:43:56.324] - result already collected: FutureResult
[17:43:56.324] result() for ClusterFuture ... done
[17:43:56.324]  length: 1 (resolved future 3)
[17:43:56.324]  length: 0 (resolved future 4)
[17:43:56.324] resolve() on list environment ... DONE
[17:43:56.325] resolve() on list environment ...
[17:43:56.325]  recursive: 99
[17:43:56.325]  length: 4
[17:43:56.325]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:43:56.325] Future #1
[17:43:56.326] result() for ClusterFuture ...
[17:43:56.326] - result already collected: FutureResult
[17:43:56.326] result() for ClusterFuture ... done
[17:43:56.326] result() for ClusterFuture ...
[17:43:56.326] - result already collected: FutureResult
[17:43:56.326] result() for ClusterFuture ... done
[17:43:56.326] A MultisessionFuture was resolved
[17:43:56.326]  length: 3 (resolved future 1)
[17:43:56.326] Future #2
[17:43:56.326] result() for ClusterFuture ...
[17:43:56.327] - result already collected: FutureResult
[17:43:56.327] result() for ClusterFuture ... done
[17:43:56.327] result() for ClusterFuture ...
[17:43:56.327] - result already collected: FutureResult
[17:43:56.327] result() for ClusterFuture ... done
[17:43:56.327] A MultisessionFuture was resolved
[17:43:56.327]  length: 2 (resolved future 2)
[17:43:56.327] Future #3
[17:43:56.327] result() for ClusterFuture ...
[17:43:56.327] - result already collected: FutureResult
[17:43:56.328] result() for ClusterFuture ... done
[17:43:56.328] result() for ClusterFuture ...
[17:43:56.328] - result already collected: FutureResult
[17:43:56.328] result() for ClusterFuture ... done
[17:43:56.328] A MultisessionFuture was resolved
[17:43:56.328]  length: 1 (resolved future 3)
[17:43:56.328]  length: 0 (resolved future 4)
[17:43:56.328] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('multisession') ...
> 
> 
> message("*** resolve() - globals with non-trustful length() ...")
*** resolve() - globals with non-trustful length() ...
> 
> length.CantTrustLength <- function(x) length(unclass(x)) + 1L
> 
> .length <- future:::.length
> 
> x <- structure(as.list(1:3), class = c("CantTrustLength", "list"))
> str(list(n = length(x), n_true = .length(x)))
List of 2
 $ n     : int 4
 $ n_true: int 3
> stopifnot(length(x) > .length(x))
> x <- resolve(x)
[17:43:56.331] resolve() on list ...
[17:43:56.331]  recursive: 0
[17:43:56.332]  length: 3
[17:43:56.332] 
[17:43:56.332]  length: 2 (resolved future 1)
[17:43:56.332]  length: 1 (resolved future 2)
[17:43:56.332]  length: 0 (resolved future 3)
[17:43:56.332] resolve() on list ... DONE
> 
> message("*** resolve() - globals with non-trustful length() ... DONE")
*** resolve() - globals with non-trustful length() ... DONE
> 
> 
> message("*** resolved() - default ...")
*** resolved() - default ...
> 
> res <- resolved(42L)
> stopifnot(isTRUE(res))
> 
> message("*** resolved() - default ... DONE")
*** resolved() - default ... DONE
> 
> 
> message("*** resolve() ... DONE")
*** resolve() ... DONE
> 
> source("incl/end.R")
[17:43:56.334] plan(): Setting new future strategy stack:
[17:43:56.334] List of future strategies:
[17:43:56.334] 1. FutureStrategy:
[17:43:56.334]    - args: function (..., envir = parent.frame())
[17:43:56.334]    - tweaked: FALSE
[17:43:56.334]    - call: future::plan(oplan)
[17:43:56.335] plan(): nbrOfWorkers() = 1
> 
