
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[13:21:37.897] plan(): Setting new future strategy stack:
[13:21:37.897] List of future strategies:
[13:21:37.897] 1. sequential:
[13:21:37.897]    - args: function (..., envir = parent.frame())
[13:21:37.897]    - tweaked: FALSE
[13:21:37.897]    - call: future::plan("sequential")
[13:21:37.910] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> strategies <- supportedStrategies()
> 
> message("*** resolve() ...")
*** resolve() ...
> 
> message("*** resolve() for default ...")
*** resolve() for default ...
> 
> x <- 1
> y <- resolve(x)
> stopifnot(identical(y, x))
> 
> message("*** resolve() for default ... DONE")
*** resolve() for default ... DONE
> 
> 
> for (strategy in strategies) {
+   message(sprintf("- plan('%s') ...", strategy))
+   plan(strategy)
+ 
+   if (strategy == "multisession" && availableCores() >= 2) {
+     message("*** resolve() for Future objects ...")
+     
+     for (result in c(FALSE, TRUE)) {
+       for (recursive in list(FALSE, TRUE, -1, 0, 1, 2, Inf)) {
+         message(sprintf("- result = %s, recursive = %s ...", result, recursive))
+       
+         f <- future({
+           Sys.sleep(0.5)
+           list(a = 1, b = 42L)
+         })
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         f <- future({
+           Sys.sleep(0.5)
+           list(a = 1, b = 42L)
+         }, lazy = TRUE)
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         message("- w/ exception ...")
+         f <- future(list(a = 1, b = 42L, c = stop("Nah!")))
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         f <- future(list(a = 1, b = 42L, c = stop("Nah!")), lazy = TRUE)
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         message(sprintf("- result = %s, recursive = %s ... DONE", result, recursive))
+       } ## for (resolve ...)
+     } ## for (result ...)
+     
+     message("*** resolve() for Future objects ... DONE")
+   } ## if (strategy == "multisession" && availableCores() >= 2)
+   
+   message("*** resolve() for lists ...")
+ 
+   x <- list()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   x$a <- 1
+   x$b <- 2
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   x$a <- future(1)
+   x$b <- future(2)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1, lazy = TRUE)
+   x$b <- future(2)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1, lazy = TRUE)
+   x$b <- future(2, lazy = TRUE)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1)
+   x$b <- future({Sys.sleep(0.5); 2})
+   x[[4]] <- 4
+   dim(x) <- c(2, 2)
+   y <- resolve(x, idxs = 1)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x[[1]]))
+   y <- resolve(x, idxs = 2)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x[[2]]))
+   y <- resolve(x, idxs = 3)
+   stopifnot(identical(y, x))
+   y <- resolve(x, idxs = seq_along(x))
+   stopifnot(identical(y, x))
+   y <- resolve(x, idxs = names(x))
+   stopifnot(identical(y, x))
+ 
+   y <- resolve(x, idxs = matrix(c(1, 2), ncol = 2L), result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   for (kk in 1:3) x[[kk]] <- future({ Sys.sleep(0.1); kk })
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   for (kk in 1:3) x[[kk]] <- future({ Sys.sleep(0.1); kk }, lazy = TRUE)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   x <- list()
+   x$a <- 1
+   x$b <- 2
+ 
+   res <- tryCatch(y <- resolve(x, idxs = 0L), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   x <- list(1, 2)
+   res <- tryCatch(x <- resolve(x, idxs = "a"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for lists ... DONE")
+ 
+ 
+   message("*** resolve() for environments ...")
+ 
+   x <- new.env()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- new.env()
+   x$a <- 1
+   x$b <- 2
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 0L)
+ 
+   x <- new.env()
+   x$a <- future(1)
+   x$b <- future(2)
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x$b))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- new.env()
+   x$a %<-% { 1 }
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)  ## FIXME: Should not do value()!
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- new.env()
+   x$a <- future({ 1 })
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "a")
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "b")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "c")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = names(x), result = TRUE)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, recursive = TRUE, result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for environments ... DONE")
+ 
+ 
+   message("*** resolve() for list environments ...")
+ 
+   x <- listenv()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- listenv()
+   x$a <- 1
+   x$b <- 2
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 0L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- listenv()
+   x$a <- future(1)
+   x$b <- future(2)
+   x$c <- 3
+   names <- names(x)
+   dim(x) <- c(1, 3)
+   names(x) <- names
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- listenv()
+   x$a %<-% { 1 }
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)  ## FIXME: Should not do value()!
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x$a, mustExist = FALSE)))
+   #stopifnot(is.na(futureOf(x$b, mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- listenv()
+   x$a <- future({ 1 })
+   x$b %<-% { Sys.sleep(0.5); 2 }
+   x$c %<-% { 3 }
+   x$d <- 4
+   names <- names(x)
+   dim(x) <- c(2, 2)
+   names(x) <- names
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+   y <- resolve(x, idxs = "a")
+   stopifnot(identical(y, x))
+   stopifnot(identical(futureOf(x$a, mustExist = FALSE), x$a))
+   stopifnot(resolved(x$a))
+   y <- resolve(x, idxs = "b")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   idxs <- matrix(c(1, 2), ncol = 2L)
+   y <- resolve(x, idxs = idxs)
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x$c, mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, idxs = 4L)
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x[[4L]], mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, idxs = names(x), result = TRUE)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, recursive = TRUE, result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   res <- tryCatch(y <- resolve(x, idxs = 0L), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for list environments ... DONE")
+ 
+   message(sprintf("- plan('%s') ...", strategy))
+ } ## for (strategy ...)
- plan('sequential') ...
[13:21:38.096] plan(): Setting new future strategy stack:
[13:21:38.096] List of future strategies:
[13:21:38.096] 1. sequential:
[13:21:38.096]    - args: function (..., envir = parent.frame())
[13:21:38.096]    - tweaked: FALSE
[13:21:38.096]    - call: plan(strategy)
[13:21:38.106] plan(): nbrOfWorkers() = 1
*** resolve() for lists ...
[13:21:38.107] resolve() on list ...
[13:21:38.107]  recursive: 0
[13:21:38.107]  length: 2
[13:21:38.107]  elements: ‘a’, ‘b’
[13:21:38.108]  length: 1 (resolved future 1)
[13:21:38.108]  length: 0 (resolved future 2)
[13:21:38.108] resolve() on list ... DONE
[13:21:38.109] getGlobalsAndPackages() ...
[13:21:38.109] Searching for globals...
[13:21:38.111] 
[13:21:38.111] Searching for globals ... DONE
[13:21:38.111] - globals: [0] <none>
[13:21:38.111] getGlobalsAndPackages() ... DONE
[13:21:38.112] run() for ‘Future’ ...
[13:21:38.112] - state: ‘created’
[13:21:38.112] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:38.113] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:38.113] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:38.113]   - Field: ‘label’
[13:21:38.113]   - Field: ‘local’
[13:21:38.113]   - Field: ‘owner’
[13:21:38.113]   - Field: ‘envir’
[13:21:38.113]   - Field: ‘packages’
[13:21:38.113]   - Field: ‘gc’
[13:21:38.113]   - Field: ‘conditions’
[13:21:38.114]   - Field: ‘expr’
[13:21:38.114]   - Field: ‘uuid’
[13:21:38.114]   - Field: ‘seed’
[13:21:38.114]   - Field: ‘version’
[13:21:38.114]   - Field: ‘result’
[13:21:38.114]   - Field: ‘asynchronous’
[13:21:38.114]   - Field: ‘calls’
[13:21:38.114]   - Field: ‘globals’
[13:21:38.114]   - Field: ‘stdout’
[13:21:38.114]   - Field: ‘earlySignal’
[13:21:38.114]   - Field: ‘lazy’
[13:21:38.115]   - Field: ‘state’
[13:21:38.115] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:38.115] - Launch lazy future ...
[13:21:38.116] Packages needed by the future expression (n = 0): <none>
[13:21:38.116] Packages needed by future strategies (n = 0): <none>
[13:21:38.116] {
[13:21:38.116]     {
[13:21:38.116]         {
[13:21:38.116]             ...future.startTime <- base::Sys.time()
[13:21:38.116]             {
[13:21:38.116]                 {
[13:21:38.116]                   {
[13:21:38.116]                     base::local({
[13:21:38.116]                       has_future <- base::requireNamespace("future", 
[13:21:38.116]                         quietly = TRUE)
[13:21:38.116]                       if (has_future) {
[13:21:38.116]                         ns <- base::getNamespace("future")
[13:21:38.116]                         version <- ns[[".package"]][["version"]]
[13:21:38.116]                         if (is.null(version)) 
[13:21:38.116]                           version <- utils::packageVersion("future")
[13:21:38.116]                       }
[13:21:38.116]                       else {
[13:21:38.116]                         version <- NULL
[13:21:38.116]                       }
[13:21:38.116]                       if (!has_future || version < "1.8.0") {
[13:21:38.116]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:38.116]                           "", base::R.version$version.string), 
[13:21:38.116]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:38.116]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:38.116]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:38.116]                             "release", "version")], collapse = " "), 
[13:21:38.116]                           hostname = base::Sys.info()[["nodename"]])
[13:21:38.116]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:38.116]                           info)
[13:21:38.116]                         info <- base::paste(info, collapse = "; ")
[13:21:38.116]                         if (!has_future) {
[13:21:38.116]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:38.116]                             info)
[13:21:38.116]                         }
[13:21:38.116]                         else {
[13:21:38.116]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:38.116]                             info, version)
[13:21:38.116]                         }
[13:21:38.116]                         base::stop(msg)
[13:21:38.116]                       }
[13:21:38.116]                     })
[13:21:38.116]                   }
[13:21:38.116]                   options(future.plan = NULL)
[13:21:38.116]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:38.116]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:38.116]                 }
[13:21:38.116]                 ...future.workdir <- getwd()
[13:21:38.116]             }
[13:21:38.116]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:38.116]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:38.116]         }
[13:21:38.116]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:38.116]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:38.116]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:38.116]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:38.116]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:38.116]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:38.116]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:38.116]             base::names(...future.oldOptions))
[13:21:38.116]     }
[13:21:38.116]     if (FALSE) {
[13:21:38.116]     }
[13:21:38.116]     else {
[13:21:38.116]         if (TRUE) {
[13:21:38.116]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:38.116]                 open = "w")
[13:21:38.116]         }
[13:21:38.116]         else {
[13:21:38.116]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:38.116]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:38.116]         }
[13:21:38.116]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:38.116]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:38.116]             base::sink(type = "output", split = FALSE)
[13:21:38.116]             base::close(...future.stdout)
[13:21:38.116]         }, add = TRUE)
[13:21:38.116]     }
[13:21:38.116]     ...future.frame <- base::sys.nframe()
[13:21:38.116]     ...future.conditions <- base::list()
[13:21:38.116]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:38.116]     if (FALSE) {
[13:21:38.116]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:38.116]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:38.116]     }
[13:21:38.116]     ...future.result <- base::tryCatch({
[13:21:38.116]         base::withCallingHandlers({
[13:21:38.116]             ...future.value <- base::withVisible(base::local(1))
[13:21:38.116]             future::FutureResult(value = ...future.value$value, 
[13:21:38.116]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:38.116]                   ...future.rng), globalenv = if (FALSE) 
[13:21:38.116]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:38.116]                     ...future.globalenv.names))
[13:21:38.116]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:38.116]         }, condition = base::local({
[13:21:38.116]             c <- base::c
[13:21:38.116]             inherits <- base::inherits
[13:21:38.116]             invokeRestart <- base::invokeRestart
[13:21:38.116]             length <- base::length
[13:21:38.116]             list <- base::list
[13:21:38.116]             seq.int <- base::seq.int
[13:21:38.116]             signalCondition <- base::signalCondition
[13:21:38.116]             sys.calls <- base::sys.calls
[13:21:38.116]             `[[` <- base::`[[`
[13:21:38.116]             `+` <- base::`+`
[13:21:38.116]             `<<-` <- base::`<<-`
[13:21:38.116]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:38.116]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:38.116]                   3L)]
[13:21:38.116]             }
[13:21:38.116]             function(cond) {
[13:21:38.116]                 is_error <- inherits(cond, "error")
[13:21:38.116]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:38.116]                   NULL)
[13:21:38.116]                 if (is_error) {
[13:21:38.116]                   sessionInformation <- function() {
[13:21:38.116]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:38.116]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:38.116]                       search = base::search(), system = base::Sys.info())
[13:21:38.116]                   }
[13:21:38.116]                   ...future.conditions[[length(...future.conditions) + 
[13:21:38.116]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:38.116]                     cond$call), session = sessionInformation(), 
[13:21:38.116]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:38.116]                   signalCondition(cond)
[13:21:38.116]                 }
[13:21:38.116]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:38.116]                 "immediateCondition"))) {
[13:21:38.116]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:38.116]                   ...future.conditions[[length(...future.conditions) + 
[13:21:38.116]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:38.116]                   if (TRUE && !signal) {
[13:21:38.116]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:38.116]                     {
[13:21:38.116]                       inherits <- base::inherits
[13:21:38.116]                       invokeRestart <- base::invokeRestart
[13:21:38.116]                       is.null <- base::is.null
[13:21:38.116]                       muffled <- FALSE
[13:21:38.116]                       if (inherits(cond, "message")) {
[13:21:38.116]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:38.116]                         if (muffled) 
[13:21:38.116]                           invokeRestart("muffleMessage")
[13:21:38.116]                       }
[13:21:38.116]                       else if (inherits(cond, "warning")) {
[13:21:38.116]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:38.116]                         if (muffled) 
[13:21:38.116]                           invokeRestart("muffleWarning")
[13:21:38.116]                       }
[13:21:38.116]                       else if (inherits(cond, "condition")) {
[13:21:38.116]                         if (!is.null(pattern)) {
[13:21:38.116]                           computeRestarts <- base::computeRestarts
[13:21:38.116]                           grepl <- base::grepl
[13:21:38.116]                           restarts <- computeRestarts(cond)
[13:21:38.116]                           for (restart in restarts) {
[13:21:38.116]                             name <- restart$name
[13:21:38.116]                             if (is.null(name)) 
[13:21:38.116]                               next
[13:21:38.116]                             if (!grepl(pattern, name)) 
[13:21:38.116]                               next
[13:21:38.116]                             invokeRestart(restart)
[13:21:38.116]                             muffled <- TRUE
[13:21:38.116]                             break
[13:21:38.116]                           }
[13:21:38.116]                         }
[13:21:38.116]                       }
[13:21:38.116]                       invisible(muffled)
[13:21:38.116]                     }
[13:21:38.116]                     muffleCondition(cond, pattern = "^muffle")
[13:21:38.116]                   }
[13:21:38.116]                 }
[13:21:38.116]                 else {
[13:21:38.116]                   if (TRUE) {
[13:21:38.116]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:38.116]                     {
[13:21:38.116]                       inherits <- base::inherits
[13:21:38.116]                       invokeRestart <- base::invokeRestart
[13:21:38.116]                       is.null <- base::is.null
[13:21:38.116]                       muffled <- FALSE
[13:21:38.116]                       if (inherits(cond, "message")) {
[13:21:38.116]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:38.116]                         if (muffled) 
[13:21:38.116]                           invokeRestart("muffleMessage")
[13:21:38.116]                       }
[13:21:38.116]                       else if (inherits(cond, "warning")) {
[13:21:38.116]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:38.116]                         if (muffled) 
[13:21:38.116]                           invokeRestart("muffleWarning")
[13:21:38.116]                       }
[13:21:38.116]                       else if (inherits(cond, "condition")) {
[13:21:38.116]                         if (!is.null(pattern)) {
[13:21:38.116]                           computeRestarts <- base::computeRestarts
[13:21:38.116]                           grepl <- base::grepl
[13:21:38.116]                           restarts <- computeRestarts(cond)
[13:21:38.116]                           for (restart in restarts) {
[13:21:38.116]                             name <- restart$name
[13:21:38.116]                             if (is.null(name)) 
[13:21:38.116]                               next
[13:21:38.116]                             if (!grepl(pattern, name)) 
[13:21:38.116]                               next
[13:21:38.116]                             invokeRestart(restart)
[13:21:38.116]                             muffled <- TRUE
[13:21:38.116]                             break
[13:21:38.116]                           }
[13:21:38.116]                         }
[13:21:38.116]                       }
[13:21:38.116]                       invisible(muffled)
[13:21:38.116]                     }
[13:21:38.116]                     muffleCondition(cond, pattern = "^muffle")
[13:21:38.116]                   }
[13:21:38.116]                 }
[13:21:38.116]             }
[13:21:38.116]         }))
[13:21:38.116]     }, error = function(ex) {
[13:21:38.116]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:38.116]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:38.116]                 ...future.rng), started = ...future.startTime, 
[13:21:38.116]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:38.116]             version = "1.8"), class = "FutureResult")
[13:21:38.116]     }, finally = {
[13:21:38.116]         if (!identical(...future.workdir, getwd())) 
[13:21:38.116]             setwd(...future.workdir)
[13:21:38.116]         {
[13:21:38.116]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:38.116]                 ...future.oldOptions$nwarnings <- NULL
[13:21:38.116]             }
[13:21:38.116]             base::options(...future.oldOptions)
[13:21:38.116]             if (.Platform$OS.type == "windows") {
[13:21:38.116]                 old_names <- names(...future.oldEnvVars)
[13:21:38.116]                 envs <- base::Sys.getenv()
[13:21:38.116]                 names <- names(envs)
[13:21:38.116]                 common <- intersect(names, old_names)
[13:21:38.116]                 added <- setdiff(names, old_names)
[13:21:38.116]                 removed <- setdiff(old_names, names)
[13:21:38.116]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:38.116]                   envs[common]]
[13:21:38.116]                 NAMES <- toupper(changed)
[13:21:38.116]                 args <- list()
[13:21:38.116]                 for (kk in seq_along(NAMES)) {
[13:21:38.116]                   name <- changed[[kk]]
[13:21:38.116]                   NAME <- NAMES[[kk]]
[13:21:38.116]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.116]                     next
[13:21:38.116]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:38.116]                 }
[13:21:38.116]                 NAMES <- toupper(added)
[13:21:38.116]                 for (kk in seq_along(NAMES)) {
[13:21:38.116]                   name <- added[[kk]]
[13:21:38.116]                   NAME <- NAMES[[kk]]
[13:21:38.116]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.116]                     next
[13:21:38.116]                   args[[name]] <- ""
[13:21:38.116]                 }
[13:21:38.116]                 NAMES <- toupper(removed)
[13:21:38.116]                 for (kk in seq_along(NAMES)) {
[13:21:38.116]                   name <- removed[[kk]]
[13:21:38.116]                   NAME <- NAMES[[kk]]
[13:21:38.116]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.116]                     next
[13:21:38.116]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:38.116]                 }
[13:21:38.116]                 if (length(args) > 0) 
[13:21:38.116]                   base::do.call(base::Sys.setenv, args = args)
[13:21:38.116]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:38.116]             }
[13:21:38.116]             else {
[13:21:38.116]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:38.116]             }
[13:21:38.116]             {
[13:21:38.116]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:38.116]                   0L) {
[13:21:38.116]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:38.116]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:38.116]                   base::options(opts)
[13:21:38.116]                 }
[13:21:38.116]                 {
[13:21:38.116]                   {
[13:21:38.116]                     NULL
[13:21:38.116]                     RNGkind("Mersenne-Twister")
[13:21:38.116]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:38.116]                       inherits = FALSE)
[13:21:38.116]                   }
[13:21:38.116]                   options(future.plan = NULL)
[13:21:38.116]                   if (is.na(NA_character_)) 
[13:21:38.116]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:38.116]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:38.116]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:38.116]                   {
[13:21:38.116]                     future <- SequentialFuture(..., envir = envir)
[13:21:38.116]                     if (!future$lazy) 
[13:21:38.116]                       future <- run(future)
[13:21:38.116]                     invisible(future)
[13:21:38.116]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:38.116]                 }
[13:21:38.116]             }
[13:21:38.116]         }
[13:21:38.116]     })
[13:21:38.116]     if (TRUE) {
[13:21:38.116]         base::sink(type = "output", split = FALSE)
[13:21:38.116]         if (TRUE) {
[13:21:38.116]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:38.116]         }
[13:21:38.116]         else {
[13:21:38.116]             ...future.result["stdout"] <- base::list(NULL)
[13:21:38.116]         }
[13:21:38.116]         base::close(...future.stdout)
[13:21:38.116]         ...future.stdout <- NULL
[13:21:38.116]     }
[13:21:38.116]     ...future.result$conditions <- ...future.conditions
[13:21:38.116]     ...future.result$finished <- base::Sys.time()
[13:21:38.116]     ...future.result
[13:21:38.116] }
[13:21:38.119] plan(): Setting new future strategy stack:
[13:21:38.119] List of future strategies:
[13:21:38.119] 1. sequential:
[13:21:38.119]    - args: function (..., envir = parent.frame())
[13:21:38.119]    - tweaked: FALSE
[13:21:38.119]    - call: NULL
[13:21:38.119] plan(): nbrOfWorkers() = 1
[13:21:38.120] plan(): Setting new future strategy stack:
[13:21:38.120] List of future strategies:
[13:21:38.120] 1. sequential:
[13:21:38.120]    - args: function (..., envir = parent.frame())
[13:21:38.120]    - tweaked: FALSE
[13:21:38.120]    - call: plan(strategy)
[13:21:38.121] plan(): nbrOfWorkers() = 1
[13:21:38.121] SequentialFuture started (and completed)
[13:21:38.121] - Launch lazy future ... done
[13:21:38.121] run() for ‘SequentialFuture’ ... done
[13:21:38.122] getGlobalsAndPackages() ...
[13:21:38.122] Searching for globals...
[13:21:38.122] 
[13:21:38.122] Searching for globals ... DONE
[13:21:38.124] - globals: [0] <none>
[13:21:38.124] getGlobalsAndPackages() ... DONE
[13:21:38.124] run() for ‘Future’ ...
[13:21:38.124] - state: ‘created’
[13:21:38.125] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:38.125] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:38.125] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:38.125]   - Field: ‘label’
[13:21:38.125]   - Field: ‘local’
[13:21:38.125]   - Field: ‘owner’
[13:21:38.125]   - Field: ‘envir’
[13:21:38.125]   - Field: ‘packages’
[13:21:38.125]   - Field: ‘gc’
[13:21:38.126]   - Field: ‘conditions’
[13:21:38.126]   - Field: ‘expr’
[13:21:38.126]   - Field: ‘uuid’
[13:21:38.126]   - Field: ‘seed’
[13:21:38.126]   - Field: ‘version’
[13:21:38.126]   - Field: ‘result’
[13:21:38.126]   - Field: ‘asynchronous’
[13:21:38.126]   - Field: ‘calls’
[13:21:38.126]   - Field: ‘globals’
[13:21:38.126]   - Field: ‘stdout’
[13:21:38.126]   - Field: ‘earlySignal’
[13:21:38.127]   - Field: ‘lazy’
[13:21:38.127]   - Field: ‘state’
[13:21:38.127] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:38.127] - Launch lazy future ...
[13:21:38.127] Packages needed by the future expression (n = 0): <none>
[13:21:38.127] Packages needed by future strategies (n = 0): <none>
[13:21:38.128] {
[13:21:38.128]     {
[13:21:38.128]         {
[13:21:38.128]             ...future.startTime <- base::Sys.time()
[13:21:38.128]             {
[13:21:38.128]                 {
[13:21:38.128]                   {
[13:21:38.128]                     base::local({
[13:21:38.128]                       has_future <- base::requireNamespace("future", 
[13:21:38.128]                         quietly = TRUE)
[13:21:38.128]                       if (has_future) {
[13:21:38.128]                         ns <- base::getNamespace("future")
[13:21:38.128]                         version <- ns[[".package"]][["version"]]
[13:21:38.128]                         if (is.null(version)) 
[13:21:38.128]                           version <- utils::packageVersion("future")
[13:21:38.128]                       }
[13:21:38.128]                       else {
[13:21:38.128]                         version <- NULL
[13:21:38.128]                       }
[13:21:38.128]                       if (!has_future || version < "1.8.0") {
[13:21:38.128]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:38.128]                           "", base::R.version$version.string), 
[13:21:38.128]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:38.128]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:38.128]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:38.128]                             "release", "version")], collapse = " "), 
[13:21:38.128]                           hostname = base::Sys.info()[["nodename"]])
[13:21:38.128]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:38.128]                           info)
[13:21:38.128]                         info <- base::paste(info, collapse = "; ")
[13:21:38.128]                         if (!has_future) {
[13:21:38.128]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:38.128]                             info)
[13:21:38.128]                         }
[13:21:38.128]                         else {
[13:21:38.128]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:38.128]                             info, version)
[13:21:38.128]                         }
[13:21:38.128]                         base::stop(msg)
[13:21:38.128]                       }
[13:21:38.128]                     })
[13:21:38.128]                   }
[13:21:38.128]                   options(future.plan = NULL)
[13:21:38.128]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:38.128]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:38.128]                 }
[13:21:38.128]                 ...future.workdir <- getwd()
[13:21:38.128]             }
[13:21:38.128]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:38.128]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:38.128]         }
[13:21:38.128]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:38.128]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:38.128]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:38.128]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:38.128]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:38.128]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:38.128]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:38.128]             base::names(...future.oldOptions))
[13:21:38.128]     }
[13:21:38.128]     if (FALSE) {
[13:21:38.128]     }
[13:21:38.128]     else {
[13:21:38.128]         if (TRUE) {
[13:21:38.128]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:38.128]                 open = "w")
[13:21:38.128]         }
[13:21:38.128]         else {
[13:21:38.128]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:38.128]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:38.128]         }
[13:21:38.128]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:38.128]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:38.128]             base::sink(type = "output", split = FALSE)
[13:21:38.128]             base::close(...future.stdout)
[13:21:38.128]         }, add = TRUE)
[13:21:38.128]     }
[13:21:38.128]     ...future.frame <- base::sys.nframe()
[13:21:38.128]     ...future.conditions <- base::list()
[13:21:38.128]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:38.128]     if (FALSE) {
[13:21:38.128]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:38.128]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:38.128]     }
[13:21:38.128]     ...future.result <- base::tryCatch({
[13:21:38.128]         base::withCallingHandlers({
[13:21:38.128]             ...future.value <- base::withVisible(base::local(2))
[13:21:38.128]             future::FutureResult(value = ...future.value$value, 
[13:21:38.128]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:38.128]                   ...future.rng), globalenv = if (FALSE) 
[13:21:38.128]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:38.128]                     ...future.globalenv.names))
[13:21:38.128]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:38.128]         }, condition = base::local({
[13:21:38.128]             c <- base::c
[13:21:38.128]             inherits <- base::inherits
[13:21:38.128]             invokeRestart <- base::invokeRestart
[13:21:38.128]             length <- base::length
[13:21:38.128]             list <- base::list
[13:21:38.128]             seq.int <- base::seq.int
[13:21:38.128]             signalCondition <- base::signalCondition
[13:21:38.128]             sys.calls <- base::sys.calls
[13:21:38.128]             `[[` <- base::`[[`
[13:21:38.128]             `+` <- base::`+`
[13:21:38.128]             `<<-` <- base::`<<-`
[13:21:38.128]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:38.128]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:38.128]                   3L)]
[13:21:38.128]             }
[13:21:38.128]             function(cond) {
[13:21:38.128]                 is_error <- inherits(cond, "error")
[13:21:38.128]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:38.128]                   NULL)
[13:21:38.128]                 if (is_error) {
[13:21:38.128]                   sessionInformation <- function() {
[13:21:38.128]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:38.128]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:38.128]                       search = base::search(), system = base::Sys.info())
[13:21:38.128]                   }
[13:21:38.128]                   ...future.conditions[[length(...future.conditions) + 
[13:21:38.128]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:38.128]                     cond$call), session = sessionInformation(), 
[13:21:38.128]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:38.128]                   signalCondition(cond)
[13:21:38.128]                 }
[13:21:38.128]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:38.128]                 "immediateCondition"))) {
[13:21:38.128]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:38.128]                   ...future.conditions[[length(...future.conditions) + 
[13:21:38.128]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:38.128]                   if (TRUE && !signal) {
[13:21:38.128]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:38.128]                     {
[13:21:38.128]                       inherits <- base::inherits
[13:21:38.128]                       invokeRestart <- base::invokeRestart
[13:21:38.128]                       is.null <- base::is.null
[13:21:38.128]                       muffled <- FALSE
[13:21:38.128]                       if (inherits(cond, "message")) {
[13:21:38.128]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:38.128]                         if (muffled) 
[13:21:38.128]                           invokeRestart("muffleMessage")
[13:21:38.128]                       }
[13:21:38.128]                       else if (inherits(cond, "warning")) {
[13:21:38.128]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:38.128]                         if (muffled) 
[13:21:38.128]                           invokeRestart("muffleWarning")
[13:21:38.128]                       }
[13:21:38.128]                       else if (inherits(cond, "condition")) {
[13:21:38.128]                         if (!is.null(pattern)) {
[13:21:38.128]                           computeRestarts <- base::computeRestarts
[13:21:38.128]                           grepl <- base::grepl
[13:21:38.128]                           restarts <- computeRestarts(cond)
[13:21:38.128]                           for (restart in restarts) {
[13:21:38.128]                             name <- restart$name
[13:21:38.128]                             if (is.null(name)) 
[13:21:38.128]                               next
[13:21:38.128]                             if (!grepl(pattern, name)) 
[13:21:38.128]                               next
[13:21:38.128]                             invokeRestart(restart)
[13:21:38.128]                             muffled <- TRUE
[13:21:38.128]                             break
[13:21:38.128]                           }
[13:21:38.128]                         }
[13:21:38.128]                       }
[13:21:38.128]                       invisible(muffled)
[13:21:38.128]                     }
[13:21:38.128]                     muffleCondition(cond, pattern = "^muffle")
[13:21:38.128]                   }
[13:21:38.128]                 }
[13:21:38.128]                 else {
[13:21:38.128]                   if (TRUE) {
[13:21:38.128]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:38.128]                     {
[13:21:38.128]                       inherits <- base::inherits
[13:21:38.128]                       invokeRestart <- base::invokeRestart
[13:21:38.128]                       is.null <- base::is.null
[13:21:38.128]                       muffled <- FALSE
[13:21:38.128]                       if (inherits(cond, "message")) {
[13:21:38.128]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:38.128]                         if (muffled) 
[13:21:38.128]                           invokeRestart("muffleMessage")
[13:21:38.128]                       }
[13:21:38.128]                       else if (inherits(cond, "warning")) {
[13:21:38.128]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:38.128]                         if (muffled) 
[13:21:38.128]                           invokeRestart("muffleWarning")
[13:21:38.128]                       }
[13:21:38.128]                       else if (inherits(cond, "condition")) {
[13:21:38.128]                         if (!is.null(pattern)) {
[13:21:38.128]                           computeRestarts <- base::computeRestarts
[13:21:38.128]                           grepl <- base::grepl
[13:21:38.128]                           restarts <- computeRestarts(cond)
[13:21:38.128]                           for (restart in restarts) {
[13:21:38.128]                             name <- restart$name
[13:21:38.128]                             if (is.null(name)) 
[13:21:38.128]                               next
[13:21:38.128]                             if (!grepl(pattern, name)) 
[13:21:38.128]                               next
[13:21:38.128]                             invokeRestart(restart)
[13:21:38.128]                             muffled <- TRUE
[13:21:38.128]                             break
[13:21:38.128]                           }
[13:21:38.128]                         }
[13:21:38.128]                       }
[13:21:38.128]                       invisible(muffled)
[13:21:38.128]                     }
[13:21:38.128]                     muffleCondition(cond, pattern = "^muffle")
[13:21:38.128]                   }
[13:21:38.128]                 }
[13:21:38.128]             }
[13:21:38.128]         }))
[13:21:38.128]     }, error = function(ex) {
[13:21:38.128]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:38.128]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:38.128]                 ...future.rng), started = ...future.startTime, 
[13:21:38.128]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:38.128]             version = "1.8"), class = "FutureResult")
[13:21:38.128]     }, finally = {
[13:21:38.128]         if (!identical(...future.workdir, getwd())) 
[13:21:38.128]             setwd(...future.workdir)
[13:21:38.128]         {
[13:21:38.128]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:38.128]                 ...future.oldOptions$nwarnings <- NULL
[13:21:38.128]             }
[13:21:38.128]             base::options(...future.oldOptions)
[13:21:38.128]             if (.Platform$OS.type == "windows") {
[13:21:38.128]                 old_names <- names(...future.oldEnvVars)
[13:21:38.128]                 envs <- base::Sys.getenv()
[13:21:38.128]                 names <- names(envs)
[13:21:38.128]                 common <- intersect(names, old_names)
[13:21:38.128]                 added <- setdiff(names, old_names)
[13:21:38.128]                 removed <- setdiff(old_names, names)
[13:21:38.128]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:38.128]                   envs[common]]
[13:21:38.128]                 NAMES <- toupper(changed)
[13:21:38.128]                 args <- list()
[13:21:38.128]                 for (kk in seq_along(NAMES)) {
[13:21:38.128]                   name <- changed[[kk]]
[13:21:38.128]                   NAME <- NAMES[[kk]]
[13:21:38.128]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.128]                     next
[13:21:38.128]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:38.128]                 }
[13:21:38.128]                 NAMES <- toupper(added)
[13:21:38.128]                 for (kk in seq_along(NAMES)) {
[13:21:38.128]                   name <- added[[kk]]
[13:21:38.128]                   NAME <- NAMES[[kk]]
[13:21:38.128]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.128]                     next
[13:21:38.128]                   args[[name]] <- ""
[13:21:38.128]                 }
[13:21:38.128]                 NAMES <- toupper(removed)
[13:21:38.128]                 for (kk in seq_along(NAMES)) {
[13:21:38.128]                   name <- removed[[kk]]
[13:21:38.128]                   NAME <- NAMES[[kk]]
[13:21:38.128]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.128]                     next
[13:21:38.128]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:38.128]                 }
[13:21:38.128]                 if (length(args) > 0) 
[13:21:38.128]                   base::do.call(base::Sys.setenv, args = args)
[13:21:38.128]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:38.128]             }
[13:21:38.128]             else {
[13:21:38.128]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:38.128]             }
[13:21:38.128]             {
[13:21:38.128]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:38.128]                   0L) {
[13:21:38.128]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:38.128]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:38.128]                   base::options(opts)
[13:21:38.128]                 }
[13:21:38.128]                 {
[13:21:38.128]                   {
[13:21:38.128]                     NULL
[13:21:38.128]                     RNGkind("Mersenne-Twister")
[13:21:38.128]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:38.128]                       inherits = FALSE)
[13:21:38.128]                   }
[13:21:38.128]                   options(future.plan = NULL)
[13:21:38.128]                   if (is.na(NA_character_)) 
[13:21:38.128]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:38.128]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:38.128]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:38.128]                   {
[13:21:38.128]                     future <- SequentialFuture(..., envir = envir)
[13:21:38.128]                     if (!future$lazy) 
[13:21:38.128]                       future <- run(future)
[13:21:38.128]                     invisible(future)
[13:21:38.128]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:38.128]                 }
[13:21:38.128]             }
[13:21:38.128]         }
[13:21:38.128]     })
[13:21:38.128]     if (TRUE) {
[13:21:38.128]         base::sink(type = "output", split = FALSE)
[13:21:38.128]         if (TRUE) {
[13:21:38.128]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:38.128]         }
[13:21:38.128]         else {
[13:21:38.128]             ...future.result["stdout"] <- base::list(NULL)
[13:21:38.128]         }
[13:21:38.128]         base::close(...future.stdout)
[13:21:38.128]         ...future.stdout <- NULL
[13:21:38.128]     }
[13:21:38.128]     ...future.result$conditions <- ...future.conditions
[13:21:38.128]     ...future.result$finished <- base::Sys.time()
[13:21:38.128]     ...future.result
[13:21:38.128] }
[13:21:38.129] plan(): Setting new future strategy stack:
[13:21:38.129] List of future strategies:
[13:21:38.129] 1. sequential:
[13:21:38.129]    - args: function (..., envir = parent.frame())
[13:21:38.129]    - tweaked: FALSE
[13:21:38.129]    - call: NULL
[13:21:38.130] plan(): nbrOfWorkers() = 1
[13:21:38.130] plan(): Setting new future strategy stack:
[13:21:38.130] List of future strategies:
[13:21:38.130] 1. sequential:
[13:21:38.130]    - args: function (..., envir = parent.frame())
[13:21:38.130]    - tweaked: FALSE
[13:21:38.130]    - call: plan(strategy)
[13:21:38.131] plan(): nbrOfWorkers() = 1
[13:21:38.131] SequentialFuture started (and completed)
[13:21:38.131] - Launch lazy future ... done
[13:21:38.131] run() for ‘SequentialFuture’ ... done
[13:21:38.131] resolve() on list ...
[13:21:38.131]  recursive: 0
[13:21:38.131]  length: 3
[13:21:38.132]  elements: ‘a’, ‘b’, ‘’
[13:21:38.132] resolved() for ‘SequentialFuture’ ...
[13:21:38.132] - state: ‘finished’
[13:21:38.132] - run: TRUE
[13:21:38.132] - result: ‘FutureResult’
[13:21:38.132] resolved() for ‘SequentialFuture’ ... done
[13:21:38.132] Future #1
[13:21:38.133]  length: 2 (resolved future 1)
[13:21:38.133] resolved() for ‘SequentialFuture’ ...
[13:21:38.133] - state: ‘finished’
[13:21:38.133] - run: TRUE
[13:21:38.133] - result: ‘FutureResult’
[13:21:38.133] resolved() for ‘SequentialFuture’ ... done
[13:21:38.133] Future #2
[13:21:38.133]  length: 1 (resolved future 2)
[13:21:38.133]  length: 0 (resolved future 3)
[13:21:38.133] resolve() on list ... DONE
[13:21:38.134] resolved() for ‘SequentialFuture’ ...
[13:21:38.134] - state: ‘finished’
[13:21:38.134] - run: TRUE
[13:21:38.134] - result: ‘FutureResult’
[13:21:38.134] resolved() for ‘SequentialFuture’ ... done
[13:21:38.134] resolved() for ‘SequentialFuture’ ...
[13:21:38.134] - state: ‘finished’
[13:21:38.134] - run: TRUE
[13:21:38.134] - result: ‘FutureResult’
[13:21:38.134] resolved() for ‘SequentialFuture’ ... done
[13:21:38.134] getGlobalsAndPackages() ...
[13:21:38.135] Searching for globals...
[13:21:38.135] 
[13:21:38.135] Searching for globals ... DONE
[13:21:38.135] - globals: [0] <none>
[13:21:38.135] getGlobalsAndPackages() ... DONE
[13:21:38.135] getGlobalsAndPackages() ...
[13:21:38.135] Searching for globals...
[13:21:38.136] 
[13:21:38.136] Searching for globals ... DONE
[13:21:38.136] - globals: [0] <none>
[13:21:38.136] getGlobalsAndPackages() ... DONE
[13:21:38.136] run() for ‘Future’ ...
[13:21:38.136] - state: ‘created’
[13:21:38.136] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:38.137] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:38.137] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:38.137]   - Field: ‘label’
[13:21:38.137]   - Field: ‘local’
[13:21:38.137]   - Field: ‘owner’
[13:21:38.137]   - Field: ‘envir’
[13:21:38.137]   - Field: ‘packages’
[13:21:38.137]   - Field: ‘gc’
[13:21:38.138]   - Field: ‘conditions’
[13:21:38.138]   - Field: ‘expr’
[13:21:38.138]   - Field: ‘uuid’
[13:21:38.138]   - Field: ‘seed’
[13:21:38.138]   - Field: ‘version’
[13:21:38.138]   - Field: ‘result’
[13:21:38.138]   - Field: ‘asynchronous’
[13:21:38.138]   - Field: ‘calls’
[13:21:38.138]   - Field: ‘globals’
[13:21:38.138]   - Field: ‘stdout’
[13:21:38.138]   - Field: ‘earlySignal’
[13:21:38.139]   - Field: ‘lazy’
[13:21:38.139]   - Field: ‘state’
[13:21:38.139] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:38.139] - Launch lazy future ...
[13:21:38.139] Packages needed by the future expression (n = 0): <none>
[13:21:38.139] Packages needed by future strategies (n = 0): <none>
[13:21:38.140] {
[13:21:38.140]     {
[13:21:38.140]         {
[13:21:38.140]             ...future.startTime <- base::Sys.time()
[13:21:38.140]             {
[13:21:38.140]                 {
[13:21:38.140]                   {
[13:21:38.140]                     base::local({
[13:21:38.140]                       has_future <- base::requireNamespace("future", 
[13:21:38.140]                         quietly = TRUE)
[13:21:38.140]                       if (has_future) {
[13:21:38.140]                         ns <- base::getNamespace("future")
[13:21:38.140]                         version <- ns[[".package"]][["version"]]
[13:21:38.140]                         if (is.null(version)) 
[13:21:38.140]                           version <- utils::packageVersion("future")
[13:21:38.140]                       }
[13:21:38.140]                       else {
[13:21:38.140]                         version <- NULL
[13:21:38.140]                       }
[13:21:38.140]                       if (!has_future || version < "1.8.0") {
[13:21:38.140]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:38.140]                           "", base::R.version$version.string), 
[13:21:38.140]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:38.140]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:38.140]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:38.140]                             "release", "version")], collapse = " "), 
[13:21:38.140]                           hostname = base::Sys.info()[["nodename"]])
[13:21:38.140]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:38.140]                           info)
[13:21:38.140]                         info <- base::paste(info, collapse = "; ")
[13:21:38.140]                         if (!has_future) {
[13:21:38.140]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:38.140]                             info)
[13:21:38.140]                         }
[13:21:38.140]                         else {
[13:21:38.140]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:38.140]                             info, version)
[13:21:38.140]                         }
[13:21:38.140]                         base::stop(msg)
[13:21:38.140]                       }
[13:21:38.140]                     })
[13:21:38.140]                   }
[13:21:38.140]                   options(future.plan = NULL)
[13:21:38.140]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:38.140]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:38.140]                 }
[13:21:38.140]                 ...future.workdir <- getwd()
[13:21:38.140]             }
[13:21:38.140]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:38.140]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:38.140]         }
[13:21:38.140]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:38.140]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:38.140]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:38.140]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:38.140]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:38.140]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:38.140]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:38.140]             base::names(...future.oldOptions))
[13:21:38.140]     }
[13:21:38.140]     if (FALSE) {
[13:21:38.140]     }
[13:21:38.140]     else {
[13:21:38.140]         if (TRUE) {
[13:21:38.140]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:38.140]                 open = "w")
[13:21:38.140]         }
[13:21:38.140]         else {
[13:21:38.140]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:38.140]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:38.140]         }
[13:21:38.140]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:38.140]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:38.140]             base::sink(type = "output", split = FALSE)
[13:21:38.140]             base::close(...future.stdout)
[13:21:38.140]         }, add = TRUE)
[13:21:38.140]     }
[13:21:38.140]     ...future.frame <- base::sys.nframe()
[13:21:38.140]     ...future.conditions <- base::list()
[13:21:38.140]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:38.140]     if (FALSE) {
[13:21:38.140]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:38.140]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:38.140]     }
[13:21:38.140]     ...future.result <- base::tryCatch({
[13:21:38.140]         base::withCallingHandlers({
[13:21:38.140]             ...future.value <- base::withVisible(base::local(2))
[13:21:38.140]             future::FutureResult(value = ...future.value$value, 
[13:21:38.140]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:38.140]                   ...future.rng), globalenv = if (FALSE) 
[13:21:38.140]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:38.140]                     ...future.globalenv.names))
[13:21:38.140]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:38.140]         }, condition = base::local({
[13:21:38.140]             c <- base::c
[13:21:38.140]             inherits <- base::inherits
[13:21:38.140]             invokeRestart <- base::invokeRestart
[13:21:38.140]             length <- base::length
[13:21:38.140]             list <- base::list
[13:21:38.140]             seq.int <- base::seq.int
[13:21:38.140]             signalCondition <- base::signalCondition
[13:21:38.140]             sys.calls <- base::sys.calls
[13:21:38.140]             `[[` <- base::`[[`
[13:21:38.140]             `+` <- base::`+`
[13:21:38.140]             `<<-` <- base::`<<-`
[13:21:38.140]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:38.140]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:38.140]                   3L)]
[13:21:38.140]             }
[13:21:38.140]             function(cond) {
[13:21:38.140]                 is_error <- inherits(cond, "error")
[13:21:38.140]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:38.140]                   NULL)
[13:21:38.140]                 if (is_error) {
[13:21:38.140]                   sessionInformation <- function() {
[13:21:38.140]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:38.140]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:38.140]                       search = base::search(), system = base::Sys.info())
[13:21:38.140]                   }
[13:21:38.140]                   ...future.conditions[[length(...future.conditions) + 
[13:21:38.140]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:38.140]                     cond$call), session = sessionInformation(), 
[13:21:38.140]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:38.140]                   signalCondition(cond)
[13:21:38.140]                 }
[13:21:38.140]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:38.140]                 "immediateCondition"))) {
[13:21:38.140]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:38.140]                   ...future.conditions[[length(...future.conditions) + 
[13:21:38.140]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:38.140]                   if (TRUE && !signal) {
[13:21:38.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:38.140]                     {
[13:21:38.140]                       inherits <- base::inherits
[13:21:38.140]                       invokeRestart <- base::invokeRestart
[13:21:38.140]                       is.null <- base::is.null
[13:21:38.140]                       muffled <- FALSE
[13:21:38.140]                       if (inherits(cond, "message")) {
[13:21:38.140]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:38.140]                         if (muffled) 
[13:21:38.140]                           invokeRestart("muffleMessage")
[13:21:38.140]                       }
[13:21:38.140]                       else if (inherits(cond, "warning")) {
[13:21:38.140]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:38.140]                         if (muffled) 
[13:21:38.140]                           invokeRestart("muffleWarning")
[13:21:38.140]                       }
[13:21:38.140]                       else if (inherits(cond, "condition")) {
[13:21:38.140]                         if (!is.null(pattern)) {
[13:21:38.140]                           computeRestarts <- base::computeRestarts
[13:21:38.140]                           grepl <- base::grepl
[13:21:38.140]                           restarts <- computeRestarts(cond)
[13:21:38.140]                           for (restart in restarts) {
[13:21:38.140]                             name <- restart$name
[13:21:38.140]                             if (is.null(name)) 
[13:21:38.140]                               next
[13:21:38.140]                             if (!grepl(pattern, name)) 
[13:21:38.140]                               next
[13:21:38.140]                             invokeRestart(restart)
[13:21:38.140]                             muffled <- TRUE
[13:21:38.140]                             break
[13:21:38.140]                           }
[13:21:38.140]                         }
[13:21:38.140]                       }
[13:21:38.140]                       invisible(muffled)
[13:21:38.140]                     }
[13:21:38.140]                     muffleCondition(cond, pattern = "^muffle")
[13:21:38.140]                   }
[13:21:38.140]                 }
[13:21:38.140]                 else {
[13:21:38.140]                   if (TRUE) {
[13:21:38.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:38.140]                     {
[13:21:38.140]                       inherits <- base::inherits
[13:21:38.140]                       invokeRestart <- base::invokeRestart
[13:21:38.140]                       is.null <- base::is.null
[13:21:38.140]                       muffled <- FALSE
[13:21:38.140]                       if (inherits(cond, "message")) {
[13:21:38.140]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:38.140]                         if (muffled) 
[13:21:38.140]                           invokeRestart("muffleMessage")
[13:21:38.140]                       }
[13:21:38.140]                       else if (inherits(cond, "warning")) {
[13:21:38.140]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:38.140]                         if (muffled) 
[13:21:38.140]                           invokeRestart("muffleWarning")
[13:21:38.140]                       }
[13:21:38.140]                       else if (inherits(cond, "condition")) {
[13:21:38.140]                         if (!is.null(pattern)) {
[13:21:38.140]                           computeRestarts <- base::computeRestarts
[13:21:38.140]                           grepl <- base::grepl
[13:21:38.140]                           restarts <- computeRestarts(cond)
[13:21:38.140]                           for (restart in restarts) {
[13:21:38.140]                             name <- restart$name
[13:21:38.140]                             if (is.null(name)) 
[13:21:38.140]                               next
[13:21:38.140]                             if (!grepl(pattern, name)) 
[13:21:38.140]                               next
[13:21:38.140]                             invokeRestart(restart)
[13:21:38.140]                             muffled <- TRUE
[13:21:38.140]                             break
[13:21:38.140]                           }
[13:21:38.140]                         }
[13:21:38.140]                       }
[13:21:38.140]                       invisible(muffled)
[13:21:38.140]                     }
[13:21:38.140]                     muffleCondition(cond, pattern = "^muffle")
[13:21:38.140]                   }
[13:21:38.140]                 }
[13:21:38.140]             }
[13:21:38.140]         }))
[13:21:38.140]     }, error = function(ex) {
[13:21:38.140]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:38.140]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:38.140]                 ...future.rng), started = ...future.startTime, 
[13:21:38.140]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:38.140]             version = "1.8"), class = "FutureResult")
[13:21:38.140]     }, finally = {
[13:21:38.140]         if (!identical(...future.workdir, getwd())) 
[13:21:38.140]             setwd(...future.workdir)
[13:21:38.140]         {
[13:21:38.140]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:38.140]                 ...future.oldOptions$nwarnings <- NULL
[13:21:38.140]             }
[13:21:38.140]             base::options(...future.oldOptions)
[13:21:38.140]             if (.Platform$OS.type == "windows") {
[13:21:38.140]                 old_names <- names(...future.oldEnvVars)
[13:21:38.140]                 envs <- base::Sys.getenv()
[13:21:38.140]                 names <- names(envs)
[13:21:38.140]                 common <- intersect(names, old_names)
[13:21:38.140]                 added <- setdiff(names, old_names)
[13:21:38.140]                 removed <- setdiff(old_names, names)
[13:21:38.140]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:38.140]                   envs[common]]
[13:21:38.140]                 NAMES <- toupper(changed)
[13:21:38.140]                 args <- list()
[13:21:38.140]                 for (kk in seq_along(NAMES)) {
[13:21:38.140]                   name <- changed[[kk]]
[13:21:38.140]                   NAME <- NAMES[[kk]]
[13:21:38.140]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.140]                     next
[13:21:38.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:38.140]                 }
[13:21:38.140]                 NAMES <- toupper(added)
[13:21:38.140]                 for (kk in seq_along(NAMES)) {
[13:21:38.140]                   name <- added[[kk]]
[13:21:38.140]                   NAME <- NAMES[[kk]]
[13:21:38.140]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.140]                     next
[13:21:38.140]                   args[[name]] <- ""
[13:21:38.140]                 }
[13:21:38.140]                 NAMES <- toupper(removed)
[13:21:38.140]                 for (kk in seq_along(NAMES)) {
[13:21:38.140]                   name <- removed[[kk]]
[13:21:38.140]                   NAME <- NAMES[[kk]]
[13:21:38.140]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.140]                     next
[13:21:38.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:38.140]                 }
[13:21:38.140]                 if (length(args) > 0) 
[13:21:38.140]                   base::do.call(base::Sys.setenv, args = args)
[13:21:38.140]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:38.140]             }
[13:21:38.140]             else {
[13:21:38.140]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:38.140]             }
[13:21:38.140]             {
[13:21:38.140]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:38.140]                   0L) {
[13:21:38.140]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:38.140]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:38.140]                   base::options(opts)
[13:21:38.140]                 }
[13:21:38.140]                 {
[13:21:38.140]                   {
[13:21:38.140]                     NULL
[13:21:38.140]                     RNGkind("Mersenne-Twister")
[13:21:38.140]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:38.140]                       inherits = FALSE)
[13:21:38.140]                   }
[13:21:38.140]                   options(future.plan = NULL)
[13:21:38.140]                   if (is.na(NA_character_)) 
[13:21:38.140]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:38.140]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:38.140]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:38.140]                   {
[13:21:38.140]                     future <- SequentialFuture(..., envir = envir)
[13:21:38.140]                     if (!future$lazy) 
[13:21:38.140]                       future <- run(future)
[13:21:38.140]                     invisible(future)
[13:21:38.140]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:38.140]                 }
[13:21:38.140]             }
[13:21:38.140]         }
[13:21:38.140]     })
[13:21:38.140]     if (TRUE) {
[13:21:38.140]         base::sink(type = "output", split = FALSE)
[13:21:38.140]         if (TRUE) {
[13:21:38.140]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:38.140]         }
[13:21:38.140]         else {
[13:21:38.140]             ...future.result["stdout"] <- base::list(NULL)
[13:21:38.140]         }
[13:21:38.140]         base::close(...future.stdout)
[13:21:38.140]         ...future.stdout <- NULL
[13:21:38.140]     }
[13:21:38.140]     ...future.result$conditions <- ...future.conditions
[13:21:38.140]     ...future.result$finished <- base::Sys.time()
[13:21:38.140]     ...future.result
[13:21:38.140] }
[13:21:38.141] plan(): Setting new future strategy stack:
[13:21:38.141] List of future strategies:
[13:21:38.141] 1. sequential:
[13:21:38.141]    - args: function (..., envir = parent.frame())
[13:21:38.141]    - tweaked: FALSE
[13:21:38.141]    - call: NULL
[13:21:38.142] plan(): nbrOfWorkers() = 1
[13:21:38.143] plan(): Setting new future strategy stack:
[13:21:38.143] List of future strategies:
[13:21:38.143] 1. sequential:
[13:21:38.143]    - args: function (..., envir = parent.frame())
[13:21:38.143]    - tweaked: FALSE
[13:21:38.143]    - call: plan(strategy)
[13:21:38.143] plan(): nbrOfWorkers() = 1
[13:21:38.143] SequentialFuture started (and completed)
[13:21:38.143] - Launch lazy future ... done
[13:21:38.143] run() for ‘SequentialFuture’ ... done
[13:21:38.144] resolve() on list ...
[13:21:38.144]  recursive: 0
[13:21:38.144]  length: 3
[13:21:38.144]  elements: ‘a’, ‘b’, ‘’
[13:21:38.144] run() for ‘Future’ ...
[13:21:38.144] - state: ‘created’
[13:21:38.144] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:38.144] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:38.144] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:38.145]   - Field: ‘label’
[13:21:38.145]   - Field: ‘local’
[13:21:38.145]   - Field: ‘owner’
[13:21:38.145]   - Field: ‘envir’
[13:21:38.145]   - Field: ‘packages’
[13:21:38.145]   - Field: ‘gc’
[13:21:38.145]   - Field: ‘conditions’
[13:21:38.145]   - Field: ‘expr’
[13:21:38.145]   - Field: ‘uuid’
[13:21:38.145]   - Field: ‘seed’
[13:21:38.146]   - Field: ‘version’
[13:21:38.146]   - Field: ‘result’
[13:21:38.146]   - Field: ‘asynchronous’
[13:21:38.146]   - Field: ‘calls’
[13:21:38.146]   - Field: ‘globals’
[13:21:38.146]   - Field: ‘stdout’
[13:21:38.146]   - Field: ‘earlySignal’
[13:21:38.146]   - Field: ‘lazy’
[13:21:38.146]   - Field: ‘state’
[13:21:38.146] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:38.146] - Launch lazy future ...
[13:21:38.147] Packages needed by the future expression (n = 0): <none>
[13:21:38.147] Packages needed by future strategies (n = 0): <none>
[13:21:38.147] {
[13:21:38.147]     {
[13:21:38.147]         {
[13:21:38.147]             ...future.startTime <- base::Sys.time()
[13:21:38.147]             {
[13:21:38.147]                 {
[13:21:38.147]                   {
[13:21:38.147]                     base::local({
[13:21:38.147]                       has_future <- base::requireNamespace("future", 
[13:21:38.147]                         quietly = TRUE)
[13:21:38.147]                       if (has_future) {
[13:21:38.147]                         ns <- base::getNamespace("future")
[13:21:38.147]                         version <- ns[[".package"]][["version"]]
[13:21:38.147]                         if (is.null(version)) 
[13:21:38.147]                           version <- utils::packageVersion("future")
[13:21:38.147]                       }
[13:21:38.147]                       else {
[13:21:38.147]                         version <- NULL
[13:21:38.147]                       }
[13:21:38.147]                       if (!has_future || version < "1.8.0") {
[13:21:38.147]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:38.147]                           "", base::R.version$version.string), 
[13:21:38.147]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:38.147]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:38.147]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:38.147]                             "release", "version")], collapse = " "), 
[13:21:38.147]                           hostname = base::Sys.info()[["nodename"]])
[13:21:38.147]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:38.147]                           info)
[13:21:38.147]                         info <- base::paste(info, collapse = "; ")
[13:21:38.147]                         if (!has_future) {
[13:21:38.147]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:38.147]                             info)
[13:21:38.147]                         }
[13:21:38.147]                         else {
[13:21:38.147]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:38.147]                             info, version)
[13:21:38.147]                         }
[13:21:38.147]                         base::stop(msg)
[13:21:38.147]                       }
[13:21:38.147]                     })
[13:21:38.147]                   }
[13:21:38.147]                   options(future.plan = NULL)
[13:21:38.147]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:38.147]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:38.147]                 }
[13:21:38.147]                 ...future.workdir <- getwd()
[13:21:38.147]             }
[13:21:38.147]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:38.147]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:38.147]         }
[13:21:38.147]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:38.147]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:38.147]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:38.147]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:38.147]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:38.147]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:38.147]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:38.147]             base::names(...future.oldOptions))
[13:21:38.147]     }
[13:21:38.147]     if (FALSE) {
[13:21:38.147]     }
[13:21:38.147]     else {
[13:21:38.147]         if (TRUE) {
[13:21:38.147]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:38.147]                 open = "w")
[13:21:38.147]         }
[13:21:38.147]         else {
[13:21:38.147]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:38.147]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:38.147]         }
[13:21:38.147]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:38.147]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:38.147]             base::sink(type = "output", split = FALSE)
[13:21:38.147]             base::close(...future.stdout)
[13:21:38.147]         }, add = TRUE)
[13:21:38.147]     }
[13:21:38.147]     ...future.frame <- base::sys.nframe()
[13:21:38.147]     ...future.conditions <- base::list()
[13:21:38.147]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:38.147]     if (FALSE) {
[13:21:38.147]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:38.147]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:38.147]     }
[13:21:38.147]     ...future.result <- base::tryCatch({
[13:21:38.147]         base::withCallingHandlers({
[13:21:38.147]             ...future.value <- base::withVisible(base::local(1))
[13:21:38.147]             future::FutureResult(value = ...future.value$value, 
[13:21:38.147]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:38.147]                   ...future.rng), globalenv = if (FALSE) 
[13:21:38.147]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:38.147]                     ...future.globalenv.names))
[13:21:38.147]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:38.147]         }, condition = base::local({
[13:21:38.147]             c <- base::c
[13:21:38.147]             inherits <- base::inherits
[13:21:38.147]             invokeRestart <- base::invokeRestart
[13:21:38.147]             length <- base::length
[13:21:38.147]             list <- base::list
[13:21:38.147]             seq.int <- base::seq.int
[13:21:38.147]             signalCondition <- base::signalCondition
[13:21:38.147]             sys.calls <- base::sys.calls
[13:21:38.147]             `[[` <- base::`[[`
[13:21:38.147]             `+` <- base::`+`
[13:21:38.147]             `<<-` <- base::`<<-`
[13:21:38.147]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:38.147]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:38.147]                   3L)]
[13:21:38.147]             }
[13:21:38.147]             function(cond) {
[13:21:38.147]                 is_error <- inherits(cond, "error")
[13:21:38.147]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:38.147]                   NULL)
[13:21:38.147]                 if (is_error) {
[13:21:38.147]                   sessionInformation <- function() {
[13:21:38.147]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:38.147]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:38.147]                       search = base::search(), system = base::Sys.info())
[13:21:38.147]                   }
[13:21:38.147]                   ...future.conditions[[length(...future.conditions) + 
[13:21:38.147]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:38.147]                     cond$call), session = sessionInformation(), 
[13:21:38.147]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:38.147]                   signalCondition(cond)
[13:21:38.147]                 }
[13:21:38.147]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:38.147]                 "immediateCondition"))) {
[13:21:38.147]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:38.147]                   ...future.conditions[[length(...future.conditions) + 
[13:21:38.147]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:38.147]                   if (TRUE && !signal) {
[13:21:38.147]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:38.147]                     {
[13:21:38.147]                       inherits <- base::inherits
[13:21:38.147]                       invokeRestart <- base::invokeRestart
[13:21:38.147]                       is.null <- base::is.null
[13:21:38.147]                       muffled <- FALSE
[13:21:38.147]                       if (inherits(cond, "message")) {
[13:21:38.147]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:38.147]                         if (muffled) 
[13:21:38.147]                           invokeRestart("muffleMessage")
[13:21:38.147]                       }
[13:21:38.147]                       else if (inherits(cond, "warning")) {
[13:21:38.147]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:38.147]                         if (muffled) 
[13:21:38.147]                           invokeRestart("muffleWarning")
[13:21:38.147]                       }
[13:21:38.147]                       else if (inherits(cond, "condition")) {
[13:21:38.147]                         if (!is.null(pattern)) {
[13:21:38.147]                           computeRestarts <- base::computeRestarts
[13:21:38.147]                           grepl <- base::grepl
[13:21:38.147]                           restarts <- computeRestarts(cond)
[13:21:38.147]                           for (restart in restarts) {
[13:21:38.147]                             name <- restart$name
[13:21:38.147]                             if (is.null(name)) 
[13:21:38.147]                               next
[13:21:38.147]                             if (!grepl(pattern, name)) 
[13:21:38.147]                               next
[13:21:38.147]                             invokeRestart(restart)
[13:21:38.147]                             muffled <- TRUE
[13:21:38.147]                             break
[13:21:38.147]                           }
[13:21:38.147]                         }
[13:21:38.147]                       }
[13:21:38.147]                       invisible(muffled)
[13:21:38.147]                     }
[13:21:38.147]                     muffleCondition(cond, pattern = "^muffle")
[13:21:38.147]                   }
[13:21:38.147]                 }
[13:21:38.147]                 else {
[13:21:38.147]                   if (TRUE) {
[13:21:38.147]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:38.147]                     {
[13:21:38.147]                       inherits <- base::inherits
[13:21:38.147]                       invokeRestart <- base::invokeRestart
[13:21:38.147]                       is.null <- base::is.null
[13:21:38.147]                       muffled <- FALSE
[13:21:38.147]                       if (inherits(cond, "message")) {
[13:21:38.147]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:38.147]                         if (muffled) 
[13:21:38.147]                           invokeRestart("muffleMessage")
[13:21:38.147]                       }
[13:21:38.147]                       else if (inherits(cond, "warning")) {
[13:21:38.147]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:38.147]                         if (muffled) 
[13:21:38.147]                           invokeRestart("muffleWarning")
[13:21:38.147]                       }
[13:21:38.147]                       else if (inherits(cond, "condition")) {
[13:21:38.147]                         if (!is.null(pattern)) {
[13:21:38.147]                           computeRestarts <- base::computeRestarts
[13:21:38.147]                           grepl <- base::grepl
[13:21:38.147]                           restarts <- computeRestarts(cond)
[13:21:38.147]                           for (restart in restarts) {
[13:21:38.147]                             name <- restart$name
[13:21:38.147]                             if (is.null(name)) 
[13:21:38.147]                               next
[13:21:38.147]                             if (!grepl(pattern, name)) 
[13:21:38.147]                               next
[13:21:38.147]                             invokeRestart(restart)
[13:21:38.147]                             muffled <- TRUE
[13:21:38.147]                             break
[13:21:38.147]                           }
[13:21:38.147]                         }
[13:21:38.147]                       }
[13:21:38.147]                       invisible(muffled)
[13:21:38.147]                     }
[13:21:38.147]                     muffleCondition(cond, pattern = "^muffle")
[13:21:38.147]                   }
[13:21:38.147]                 }
[13:21:38.147]             }
[13:21:38.147]         }))
[13:21:38.147]     }, error = function(ex) {
[13:21:38.147]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:38.147]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:38.147]                 ...future.rng), started = ...future.startTime, 
[13:21:38.147]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:38.147]             version = "1.8"), class = "FutureResult")
[13:21:38.147]     }, finally = {
[13:21:38.147]         if (!identical(...future.workdir, getwd())) 
[13:21:38.147]             setwd(...future.workdir)
[13:21:38.147]         {
[13:21:38.147]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:38.147]                 ...future.oldOptions$nwarnings <- NULL
[13:21:38.147]             }
[13:21:38.147]             base::options(...future.oldOptions)
[13:21:38.147]             if (.Platform$OS.type == "windows") {
[13:21:38.147]                 old_names <- names(...future.oldEnvVars)
[13:21:38.147]                 envs <- base::Sys.getenv()
[13:21:38.147]                 names <- names(envs)
[13:21:38.147]                 common <- intersect(names, old_names)
[13:21:38.147]                 added <- setdiff(names, old_names)
[13:21:38.147]                 removed <- setdiff(old_names, names)
[13:21:38.147]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:38.147]                   envs[common]]
[13:21:38.147]                 NAMES <- toupper(changed)
[13:21:38.147]                 args <- list()
[13:21:38.147]                 for (kk in seq_along(NAMES)) {
[13:21:38.147]                   name <- changed[[kk]]
[13:21:38.147]                   NAME <- NAMES[[kk]]
[13:21:38.147]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.147]                     next
[13:21:38.147]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:38.147]                 }
[13:21:38.147]                 NAMES <- toupper(added)
[13:21:38.147]                 for (kk in seq_along(NAMES)) {
[13:21:38.147]                   name <- added[[kk]]
[13:21:38.147]                   NAME <- NAMES[[kk]]
[13:21:38.147]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.147]                     next
[13:21:38.147]                   args[[name]] <- ""
[13:21:38.147]                 }
[13:21:38.147]                 NAMES <- toupper(removed)
[13:21:38.147]                 for (kk in seq_along(NAMES)) {
[13:21:38.147]                   name <- removed[[kk]]
[13:21:38.147]                   NAME <- NAMES[[kk]]
[13:21:38.147]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.147]                     next
[13:21:38.147]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:38.147]                 }
[13:21:38.147]                 if (length(args) > 0) 
[13:21:38.147]                   base::do.call(base::Sys.setenv, args = args)
[13:21:38.147]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:38.147]             }
[13:21:38.147]             else {
[13:21:38.147]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:38.147]             }
[13:21:38.147]             {
[13:21:38.147]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:38.147]                   0L) {
[13:21:38.147]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:38.147]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:38.147]                   base::options(opts)
[13:21:38.147]                 }
[13:21:38.147]                 {
[13:21:38.147]                   {
[13:21:38.147]                     NULL
[13:21:38.147]                     RNGkind("Mersenne-Twister")
[13:21:38.147]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:38.147]                       inherits = FALSE)
[13:21:38.147]                   }
[13:21:38.147]                   options(future.plan = NULL)
[13:21:38.147]                   if (is.na(NA_character_)) 
[13:21:38.147]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:38.147]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:38.147]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:38.147]                   {
[13:21:38.147]                     future <- SequentialFuture(..., envir = envir)
[13:21:38.147]                     if (!future$lazy) 
[13:21:38.147]                       future <- run(future)
[13:21:38.147]                     invisible(future)
[13:21:38.147]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:38.147]                 }
[13:21:38.147]             }
[13:21:38.147]         }
[13:21:38.147]     })
[13:21:38.147]     if (TRUE) {
[13:21:38.147]         base::sink(type = "output", split = FALSE)
[13:21:38.147]         if (TRUE) {
[13:21:38.147]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:38.147]         }
[13:21:38.147]         else {
[13:21:38.147]             ...future.result["stdout"] <- base::list(NULL)
[13:21:38.147]         }
[13:21:38.147]         base::close(...future.stdout)
[13:21:38.147]         ...future.stdout <- NULL
[13:21:38.147]     }
[13:21:38.147]     ...future.result$conditions <- ...future.conditions
[13:21:38.147]     ...future.result$finished <- base::Sys.time()
[13:21:38.147]     ...future.result
[13:21:38.147] }
[13:21:38.149] plan(): Setting new future strategy stack:
[13:21:38.149] List of future strategies:
[13:21:38.149] 1. sequential:
[13:21:38.149]    - args: function (..., envir = parent.frame())
[13:21:38.149]    - tweaked: FALSE
[13:21:38.149]    - call: NULL
[13:21:38.149] plan(): nbrOfWorkers() = 1
[13:21:38.150] plan(): Setting new future strategy stack:
[13:21:38.150] List of future strategies:
[13:21:38.150] 1. sequential:
[13:21:38.150]    - args: function (..., envir = parent.frame())
[13:21:38.150]    - tweaked: FALSE
[13:21:38.150]    - call: plan(strategy)
[13:21:38.150] plan(): nbrOfWorkers() = 1
[13:21:38.151] SequentialFuture started (and completed)
[13:21:38.151] - Launch lazy future ... done
[13:21:38.151] run() for ‘SequentialFuture’ ... done
[13:21:38.151] resolved() for ‘SequentialFuture’ ...
[13:21:38.151] - state: ‘finished’
[13:21:38.151] - run: TRUE
[13:21:38.151] - result: ‘FutureResult’
[13:21:38.151] resolved() for ‘SequentialFuture’ ... done
[13:21:38.151] Future #1
[13:21:38.151]  length: 2 (resolved future 1)
[13:21:38.152] resolved() for ‘SequentialFuture’ ...
[13:21:38.152] - state: ‘finished’
[13:21:38.152] - run: TRUE
[13:21:38.152] - result: ‘FutureResult’
[13:21:38.152] resolved() for ‘SequentialFuture’ ... done
[13:21:38.152] Future #2
[13:21:38.152]  length: 1 (resolved future 2)
[13:21:38.152]  length: 0 (resolved future 3)
[13:21:38.152] resolve() on list ... DONE
[13:21:38.152] resolved() for ‘SequentialFuture’ ...
[13:21:38.153] - state: ‘finished’
[13:21:38.153] - run: TRUE
[13:21:38.153] - result: ‘FutureResult’
[13:21:38.153] resolved() for ‘SequentialFuture’ ... done
[13:21:38.153] resolved() for ‘SequentialFuture’ ...
[13:21:38.153] - state: ‘finished’
[13:21:38.153] - run: TRUE
[13:21:38.153] - result: ‘FutureResult’
[13:21:38.153] resolved() for ‘SequentialFuture’ ... done
[13:21:38.153] getGlobalsAndPackages() ...
[13:21:38.153] Searching for globals...
[13:21:38.154] 
[13:21:38.154] Searching for globals ... DONE
[13:21:38.154] - globals: [0] <none>
[13:21:38.154] getGlobalsAndPackages() ... DONE
[13:21:38.154] getGlobalsAndPackages() ...
[13:21:38.154] Searching for globals...
[13:21:38.155] 
[13:21:38.155] Searching for globals ... DONE
[13:21:38.155] - globals: [0] <none>
[13:21:38.155] getGlobalsAndPackages() ... DONE
[13:21:38.155] resolve() on list ...
[13:21:38.155]  recursive: 0
[13:21:38.155]  length: 3
[13:21:38.155]  elements: ‘a’, ‘b’, ‘’
[13:21:38.155] run() for ‘Future’ ...
[13:21:38.155] - state: ‘created’
[13:21:38.156] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:38.157] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:38.158] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:38.158]   - Field: ‘label’
[13:21:38.158]   - Field: ‘local’
[13:21:38.158]   - Field: ‘owner’
[13:21:38.158]   - Field: ‘envir’
[13:21:38.158]   - Field: ‘packages’
[13:21:38.158]   - Field: ‘gc’
[13:21:38.158]   - Field: ‘conditions’
[13:21:38.158]   - Field: ‘expr’
[13:21:38.158]   - Field: ‘uuid’
[13:21:38.158]   - Field: ‘seed’
[13:21:38.159]   - Field: ‘version’
[13:21:38.159]   - Field: ‘result’
[13:21:38.159]   - Field: ‘asynchronous’
[13:21:38.159]   - Field: ‘calls’
[13:21:38.159]   - Field: ‘globals’
[13:21:38.159]   - Field: ‘stdout’
[13:21:38.159]   - Field: ‘earlySignal’
[13:21:38.159]   - Field: ‘lazy’
[13:21:38.159]   - Field: ‘state’
[13:21:38.159] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:38.160] - Launch lazy future ...
[13:21:38.160] Packages needed by the future expression (n = 0): <none>
[13:21:38.160] Packages needed by future strategies (n = 0): <none>
[13:21:38.160] {
[13:21:38.160]     {
[13:21:38.160]         {
[13:21:38.160]             ...future.startTime <- base::Sys.time()
[13:21:38.160]             {
[13:21:38.160]                 {
[13:21:38.160]                   {
[13:21:38.160]                     base::local({
[13:21:38.160]                       has_future <- base::requireNamespace("future", 
[13:21:38.160]                         quietly = TRUE)
[13:21:38.160]                       if (has_future) {
[13:21:38.160]                         ns <- base::getNamespace("future")
[13:21:38.160]                         version <- ns[[".package"]][["version"]]
[13:21:38.160]                         if (is.null(version)) 
[13:21:38.160]                           version <- utils::packageVersion("future")
[13:21:38.160]                       }
[13:21:38.160]                       else {
[13:21:38.160]                         version <- NULL
[13:21:38.160]                       }
[13:21:38.160]                       if (!has_future || version < "1.8.0") {
[13:21:38.160]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:38.160]                           "", base::R.version$version.string), 
[13:21:38.160]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:38.160]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:38.160]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:38.160]                             "release", "version")], collapse = " "), 
[13:21:38.160]                           hostname = base::Sys.info()[["nodename"]])
[13:21:38.160]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:38.160]                           info)
[13:21:38.160]                         info <- base::paste(info, collapse = "; ")
[13:21:38.160]                         if (!has_future) {
[13:21:38.160]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:38.160]                             info)
[13:21:38.160]                         }
[13:21:38.160]                         else {
[13:21:38.160]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:38.160]                             info, version)
[13:21:38.160]                         }
[13:21:38.160]                         base::stop(msg)
[13:21:38.160]                       }
[13:21:38.160]                     })
[13:21:38.160]                   }
[13:21:38.160]                   options(future.plan = NULL)
[13:21:38.160]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:38.160]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:38.160]                 }
[13:21:38.160]                 ...future.workdir <- getwd()
[13:21:38.160]             }
[13:21:38.160]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:38.160]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:38.160]         }
[13:21:38.160]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:38.160]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:38.160]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:38.160]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:38.160]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:38.160]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:38.160]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:38.160]             base::names(...future.oldOptions))
[13:21:38.160]     }
[13:21:38.160]     if (FALSE) {
[13:21:38.160]     }
[13:21:38.160]     else {
[13:21:38.160]         if (TRUE) {
[13:21:38.160]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:38.160]                 open = "w")
[13:21:38.160]         }
[13:21:38.160]         else {
[13:21:38.160]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:38.160]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:38.160]         }
[13:21:38.160]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:38.160]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:38.160]             base::sink(type = "output", split = FALSE)
[13:21:38.160]             base::close(...future.stdout)
[13:21:38.160]         }, add = TRUE)
[13:21:38.160]     }
[13:21:38.160]     ...future.frame <- base::sys.nframe()
[13:21:38.160]     ...future.conditions <- base::list()
[13:21:38.160]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:38.160]     if (FALSE) {
[13:21:38.160]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:38.160]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:38.160]     }
[13:21:38.160]     ...future.result <- base::tryCatch({
[13:21:38.160]         base::withCallingHandlers({
[13:21:38.160]             ...future.value <- base::withVisible(base::local(1))
[13:21:38.160]             future::FutureResult(value = ...future.value$value, 
[13:21:38.160]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:38.160]                   ...future.rng), globalenv = if (FALSE) 
[13:21:38.160]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:38.160]                     ...future.globalenv.names))
[13:21:38.160]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:38.160]         }, condition = base::local({
[13:21:38.160]             c <- base::c
[13:21:38.160]             inherits <- base::inherits
[13:21:38.160]             invokeRestart <- base::invokeRestart
[13:21:38.160]             length <- base::length
[13:21:38.160]             list <- base::list
[13:21:38.160]             seq.int <- base::seq.int
[13:21:38.160]             signalCondition <- base::signalCondition
[13:21:38.160]             sys.calls <- base::sys.calls
[13:21:38.160]             `[[` <- base::`[[`
[13:21:38.160]             `+` <- base::`+`
[13:21:38.160]             `<<-` <- base::`<<-`
[13:21:38.160]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:38.160]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:38.160]                   3L)]
[13:21:38.160]             }
[13:21:38.160]             function(cond) {
[13:21:38.160]                 is_error <- inherits(cond, "error")
[13:21:38.160]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:38.160]                   NULL)
[13:21:38.160]                 if (is_error) {
[13:21:38.160]                   sessionInformation <- function() {
[13:21:38.160]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:38.160]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:38.160]                       search = base::search(), system = base::Sys.info())
[13:21:38.160]                   }
[13:21:38.160]                   ...future.conditions[[length(...future.conditions) + 
[13:21:38.160]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:38.160]                     cond$call), session = sessionInformation(), 
[13:21:38.160]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:38.160]                   signalCondition(cond)
[13:21:38.160]                 }
[13:21:38.160]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:38.160]                 "immediateCondition"))) {
[13:21:38.160]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:38.160]                   ...future.conditions[[length(...future.conditions) + 
[13:21:38.160]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:38.160]                   if (TRUE && !signal) {
[13:21:38.160]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:38.160]                     {
[13:21:38.160]                       inherits <- base::inherits
[13:21:38.160]                       invokeRestart <- base::invokeRestart
[13:21:38.160]                       is.null <- base::is.null
[13:21:38.160]                       muffled <- FALSE
[13:21:38.160]                       if (inherits(cond, "message")) {
[13:21:38.160]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:38.160]                         if (muffled) 
[13:21:38.160]                           invokeRestart("muffleMessage")
[13:21:38.160]                       }
[13:21:38.160]                       else if (inherits(cond, "warning")) {
[13:21:38.160]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:38.160]                         if (muffled) 
[13:21:38.160]                           invokeRestart("muffleWarning")
[13:21:38.160]                       }
[13:21:38.160]                       else if (inherits(cond, "condition")) {
[13:21:38.160]                         if (!is.null(pattern)) {
[13:21:38.160]                           computeRestarts <- base::computeRestarts
[13:21:38.160]                           grepl <- base::grepl
[13:21:38.160]                           restarts <- computeRestarts(cond)
[13:21:38.160]                           for (restart in restarts) {
[13:21:38.160]                             name <- restart$name
[13:21:38.160]                             if (is.null(name)) 
[13:21:38.160]                               next
[13:21:38.160]                             if (!grepl(pattern, name)) 
[13:21:38.160]                               next
[13:21:38.160]                             invokeRestart(restart)
[13:21:38.160]                             muffled <- TRUE
[13:21:38.160]                             break
[13:21:38.160]                           }
[13:21:38.160]                         }
[13:21:38.160]                       }
[13:21:38.160]                       invisible(muffled)
[13:21:38.160]                     }
[13:21:38.160]                     muffleCondition(cond, pattern = "^muffle")
[13:21:38.160]                   }
[13:21:38.160]                 }
[13:21:38.160]                 else {
[13:21:38.160]                   if (TRUE) {
[13:21:38.160]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:38.160]                     {
[13:21:38.160]                       inherits <- base::inherits
[13:21:38.160]                       invokeRestart <- base::invokeRestart
[13:21:38.160]                       is.null <- base::is.null
[13:21:38.160]                       muffled <- FALSE
[13:21:38.160]                       if (inherits(cond, "message")) {
[13:21:38.160]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:38.160]                         if (muffled) 
[13:21:38.160]                           invokeRestart("muffleMessage")
[13:21:38.160]                       }
[13:21:38.160]                       else if (inherits(cond, "warning")) {
[13:21:38.160]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:38.160]                         if (muffled) 
[13:21:38.160]                           invokeRestart("muffleWarning")
[13:21:38.160]                       }
[13:21:38.160]                       else if (inherits(cond, "condition")) {
[13:21:38.160]                         if (!is.null(pattern)) {
[13:21:38.160]                           computeRestarts <- base::computeRestarts
[13:21:38.160]                           grepl <- base::grepl
[13:21:38.160]                           restarts <- computeRestarts(cond)
[13:21:38.160]                           for (restart in restarts) {
[13:21:38.160]                             name <- restart$name
[13:21:38.160]                             if (is.null(name)) 
[13:21:38.160]                               next
[13:21:38.160]                             if (!grepl(pattern, name)) 
[13:21:38.160]                               next
[13:21:38.160]                             invokeRestart(restart)
[13:21:38.160]                             muffled <- TRUE
[13:21:38.160]                             break
[13:21:38.160]                           }
[13:21:38.160]                         }
[13:21:38.160]                       }
[13:21:38.160]                       invisible(muffled)
[13:21:38.160]                     }
[13:21:38.160]                     muffleCondition(cond, pattern = "^muffle")
[13:21:38.160]                   }
[13:21:38.160]                 }
[13:21:38.160]             }
[13:21:38.160]         }))
[13:21:38.160]     }, error = function(ex) {
[13:21:38.160]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:38.160]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:38.160]                 ...future.rng), started = ...future.startTime, 
[13:21:38.160]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:38.160]             version = "1.8"), class = "FutureResult")
[13:21:38.160]     }, finally = {
[13:21:38.160]         if (!identical(...future.workdir, getwd())) 
[13:21:38.160]             setwd(...future.workdir)
[13:21:38.160]         {
[13:21:38.160]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:38.160]                 ...future.oldOptions$nwarnings <- NULL
[13:21:38.160]             }
[13:21:38.160]             base::options(...future.oldOptions)
[13:21:38.160]             if (.Platform$OS.type == "windows") {
[13:21:38.160]                 old_names <- names(...future.oldEnvVars)
[13:21:38.160]                 envs <- base::Sys.getenv()
[13:21:38.160]                 names <- names(envs)
[13:21:38.160]                 common <- intersect(names, old_names)
[13:21:38.160]                 added <- setdiff(names, old_names)
[13:21:38.160]                 removed <- setdiff(old_names, names)
[13:21:38.160]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:38.160]                   envs[common]]
[13:21:38.160]                 NAMES <- toupper(changed)
[13:21:38.160]                 args <- list()
[13:21:38.160]                 for (kk in seq_along(NAMES)) {
[13:21:38.160]                   name <- changed[[kk]]
[13:21:38.160]                   NAME <- NAMES[[kk]]
[13:21:38.160]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.160]                     next
[13:21:38.160]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:38.160]                 }
[13:21:38.160]                 NAMES <- toupper(added)
[13:21:38.160]                 for (kk in seq_along(NAMES)) {
[13:21:38.160]                   name <- added[[kk]]
[13:21:38.160]                   NAME <- NAMES[[kk]]
[13:21:38.160]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.160]                     next
[13:21:38.160]                   args[[name]] <- ""
[13:21:38.160]                 }
[13:21:38.160]                 NAMES <- toupper(removed)
[13:21:38.160]                 for (kk in seq_along(NAMES)) {
[13:21:38.160]                   name <- removed[[kk]]
[13:21:38.160]                   NAME <- NAMES[[kk]]
[13:21:38.160]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.160]                     next
[13:21:38.160]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:38.160]                 }
[13:21:38.160]                 if (length(args) > 0) 
[13:21:38.160]                   base::do.call(base::Sys.setenv, args = args)
[13:21:38.160]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:38.160]             }
[13:21:38.160]             else {
[13:21:38.160]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:38.160]             }
[13:21:38.160]             {
[13:21:38.160]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:38.160]                   0L) {
[13:21:38.160]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:38.160]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:38.160]                   base::options(opts)
[13:21:38.160]                 }
[13:21:38.160]                 {
[13:21:38.160]                   {
[13:21:38.160]                     NULL
[13:21:38.160]                     RNGkind("Mersenne-Twister")
[13:21:38.160]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:38.160]                       inherits = FALSE)
[13:21:38.160]                   }
[13:21:38.160]                   options(future.plan = NULL)
[13:21:38.160]                   if (is.na(NA_character_)) 
[13:21:38.160]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:38.160]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:38.160]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:38.160]                   {
[13:21:38.160]                     future <- SequentialFuture(..., envir = envir)
[13:21:38.160]                     if (!future$lazy) 
[13:21:38.160]                       future <- run(future)
[13:21:38.160]                     invisible(future)
[13:21:38.160]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:38.160]                 }
[13:21:38.160]             }
[13:21:38.160]         }
[13:21:38.160]     })
[13:21:38.160]     if (TRUE) {
[13:21:38.160]         base::sink(type = "output", split = FALSE)
[13:21:38.160]         if (TRUE) {
[13:21:38.160]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:38.160]         }
[13:21:38.160]         else {
[13:21:38.160]             ...future.result["stdout"] <- base::list(NULL)
[13:21:38.160]         }
[13:21:38.160]         base::close(...future.stdout)
[13:21:38.160]         ...future.stdout <- NULL
[13:21:38.160]     }
[13:21:38.160]     ...future.result$conditions <- ...future.conditions
[13:21:38.160]     ...future.result$finished <- base::Sys.time()
[13:21:38.160]     ...future.result
[13:21:38.160] }
[13:21:38.162] plan(): Setting new future strategy stack:
[13:21:38.162] List of future strategies:
[13:21:38.162] 1. sequential:
[13:21:38.162]    - args: function (..., envir = parent.frame())
[13:21:38.162]    - tweaked: FALSE
[13:21:38.162]    - call: NULL
[13:21:38.162] plan(): nbrOfWorkers() = 1
[13:21:38.163] plan(): Setting new future strategy stack:
[13:21:38.163] List of future strategies:
[13:21:38.163] 1. sequential:
[13:21:38.163]    - args: function (..., envir = parent.frame())
[13:21:38.163]    - tweaked: FALSE
[13:21:38.163]    - call: plan(strategy)
[13:21:38.164] plan(): nbrOfWorkers() = 1
[13:21:38.164] SequentialFuture started (and completed)
[13:21:38.164] - Launch lazy future ... done
[13:21:38.164] run() for ‘SequentialFuture’ ... done
[13:21:38.164] resolved() for ‘SequentialFuture’ ...
[13:21:38.164] - state: ‘finished’
[13:21:38.164] - run: TRUE
[13:21:38.164] - result: ‘FutureResult’
[13:21:38.164] resolved() for ‘SequentialFuture’ ... done
[13:21:38.164] Future #1
[13:21:38.165]  length: 2 (resolved future 1)
[13:21:38.165] run() for ‘Future’ ...
[13:21:38.165] - state: ‘created’
[13:21:38.165] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:38.165] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:38.165] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:38.165]   - Field: ‘label’
[13:21:38.165]   - Field: ‘local’
[13:21:38.166]   - Field: ‘owner’
[13:21:38.166]   - Field: ‘envir’
[13:21:38.166]   - Field: ‘packages’
[13:21:38.166]   - Field: ‘gc’
[13:21:38.166]   - Field: ‘conditions’
[13:21:38.166]   - Field: ‘expr’
[13:21:38.166]   - Field: ‘uuid’
[13:21:38.166]   - Field: ‘seed’
[13:21:38.166]   - Field: ‘version’
[13:21:38.166]   - Field: ‘result’
[13:21:38.166]   - Field: ‘asynchronous’
[13:21:38.167]   - Field: ‘calls’
[13:21:38.167]   - Field: ‘globals’
[13:21:38.167]   - Field: ‘stdout’
[13:21:38.167]   - Field: ‘earlySignal’
[13:21:38.167]   - Field: ‘lazy’
[13:21:38.167]   - Field: ‘state’
[13:21:38.167] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:38.167] - Launch lazy future ...
[13:21:38.167] Packages needed by the future expression (n = 0): <none>
[13:21:38.168] Packages needed by future strategies (n = 0): <none>
[13:21:38.168] {
[13:21:38.168]     {
[13:21:38.168]         {
[13:21:38.168]             ...future.startTime <- base::Sys.time()
[13:21:38.168]             {
[13:21:38.168]                 {
[13:21:38.168]                   {
[13:21:38.168]                     base::local({
[13:21:38.168]                       has_future <- base::requireNamespace("future", 
[13:21:38.168]                         quietly = TRUE)
[13:21:38.168]                       if (has_future) {
[13:21:38.168]                         ns <- base::getNamespace("future")
[13:21:38.168]                         version <- ns[[".package"]][["version"]]
[13:21:38.168]                         if (is.null(version)) 
[13:21:38.168]                           version <- utils::packageVersion("future")
[13:21:38.168]                       }
[13:21:38.168]                       else {
[13:21:38.168]                         version <- NULL
[13:21:38.168]                       }
[13:21:38.168]                       if (!has_future || version < "1.8.0") {
[13:21:38.168]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:38.168]                           "", base::R.version$version.string), 
[13:21:38.168]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:38.168]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:38.168]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:38.168]                             "release", "version")], collapse = " "), 
[13:21:38.168]                           hostname = base::Sys.info()[["nodename"]])
[13:21:38.168]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:38.168]                           info)
[13:21:38.168]                         info <- base::paste(info, collapse = "; ")
[13:21:38.168]                         if (!has_future) {
[13:21:38.168]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:38.168]                             info)
[13:21:38.168]                         }
[13:21:38.168]                         else {
[13:21:38.168]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:38.168]                             info, version)
[13:21:38.168]                         }
[13:21:38.168]                         base::stop(msg)
[13:21:38.168]                       }
[13:21:38.168]                     })
[13:21:38.168]                   }
[13:21:38.168]                   options(future.plan = NULL)
[13:21:38.168]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:38.168]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:38.168]                 }
[13:21:38.168]                 ...future.workdir <- getwd()
[13:21:38.168]             }
[13:21:38.168]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:38.168]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:38.168]         }
[13:21:38.168]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:38.168]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:38.168]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:38.168]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:38.168]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:38.168]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:38.168]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:38.168]             base::names(...future.oldOptions))
[13:21:38.168]     }
[13:21:38.168]     if (FALSE) {
[13:21:38.168]     }
[13:21:38.168]     else {
[13:21:38.168]         if (TRUE) {
[13:21:38.168]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:38.168]                 open = "w")
[13:21:38.168]         }
[13:21:38.168]         else {
[13:21:38.168]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:38.168]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:38.168]         }
[13:21:38.168]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:38.168]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:38.168]             base::sink(type = "output", split = FALSE)
[13:21:38.168]             base::close(...future.stdout)
[13:21:38.168]         }, add = TRUE)
[13:21:38.168]     }
[13:21:38.168]     ...future.frame <- base::sys.nframe()
[13:21:38.168]     ...future.conditions <- base::list()
[13:21:38.168]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:38.168]     if (FALSE) {
[13:21:38.168]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:38.168]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:38.168]     }
[13:21:38.168]     ...future.result <- base::tryCatch({
[13:21:38.168]         base::withCallingHandlers({
[13:21:38.168]             ...future.value <- base::withVisible(base::local(2))
[13:21:38.168]             future::FutureResult(value = ...future.value$value, 
[13:21:38.168]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:38.168]                   ...future.rng), globalenv = if (FALSE) 
[13:21:38.168]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:38.168]                     ...future.globalenv.names))
[13:21:38.168]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:38.168]         }, condition = base::local({
[13:21:38.168]             c <- base::c
[13:21:38.168]             inherits <- base::inherits
[13:21:38.168]             invokeRestart <- base::invokeRestart
[13:21:38.168]             length <- base::length
[13:21:38.168]             list <- base::list
[13:21:38.168]             seq.int <- base::seq.int
[13:21:38.168]             signalCondition <- base::signalCondition
[13:21:38.168]             sys.calls <- base::sys.calls
[13:21:38.168]             `[[` <- base::`[[`
[13:21:38.168]             `+` <- base::`+`
[13:21:38.168]             `<<-` <- base::`<<-`
[13:21:38.168]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:38.168]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:38.168]                   3L)]
[13:21:38.168]             }
[13:21:38.168]             function(cond) {
[13:21:38.168]                 is_error <- inherits(cond, "error")
[13:21:38.168]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:38.168]                   NULL)
[13:21:38.168]                 if (is_error) {
[13:21:38.168]                   sessionInformation <- function() {
[13:21:38.168]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:38.168]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:38.168]                       search = base::search(), system = base::Sys.info())
[13:21:38.168]                   }
[13:21:38.168]                   ...future.conditions[[length(...future.conditions) + 
[13:21:38.168]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:38.168]                     cond$call), session = sessionInformation(), 
[13:21:38.168]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:38.168]                   signalCondition(cond)
[13:21:38.168]                 }
[13:21:38.168]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:38.168]                 "immediateCondition"))) {
[13:21:38.168]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:38.168]                   ...future.conditions[[length(...future.conditions) + 
[13:21:38.168]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:38.168]                   if (TRUE && !signal) {
[13:21:38.168]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:38.168]                     {
[13:21:38.168]                       inherits <- base::inherits
[13:21:38.168]                       invokeRestart <- base::invokeRestart
[13:21:38.168]                       is.null <- base::is.null
[13:21:38.168]                       muffled <- FALSE
[13:21:38.168]                       if (inherits(cond, "message")) {
[13:21:38.168]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:38.168]                         if (muffled) 
[13:21:38.168]                           invokeRestart("muffleMessage")
[13:21:38.168]                       }
[13:21:38.168]                       else if (inherits(cond, "warning")) {
[13:21:38.168]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:38.168]                         if (muffled) 
[13:21:38.168]                           invokeRestart("muffleWarning")
[13:21:38.168]                       }
[13:21:38.168]                       else if (inherits(cond, "condition")) {
[13:21:38.168]                         if (!is.null(pattern)) {
[13:21:38.168]                           computeRestarts <- base::computeRestarts
[13:21:38.168]                           grepl <- base::grepl
[13:21:38.168]                           restarts <- computeRestarts(cond)
[13:21:38.168]                           for (restart in restarts) {
[13:21:38.168]                             name <- restart$name
[13:21:38.168]                             if (is.null(name)) 
[13:21:38.168]                               next
[13:21:38.168]                             if (!grepl(pattern, name)) 
[13:21:38.168]                               next
[13:21:38.168]                             invokeRestart(restart)
[13:21:38.168]                             muffled <- TRUE
[13:21:38.168]                             break
[13:21:38.168]                           }
[13:21:38.168]                         }
[13:21:38.168]                       }
[13:21:38.168]                       invisible(muffled)
[13:21:38.168]                     }
[13:21:38.168]                     muffleCondition(cond, pattern = "^muffle")
[13:21:38.168]                   }
[13:21:38.168]                 }
[13:21:38.168]                 else {
[13:21:38.168]                   if (TRUE) {
[13:21:38.168]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:38.168]                     {
[13:21:38.168]                       inherits <- base::inherits
[13:21:38.168]                       invokeRestart <- base::invokeRestart
[13:21:38.168]                       is.null <- base::is.null
[13:21:38.168]                       muffled <- FALSE
[13:21:38.168]                       if (inherits(cond, "message")) {
[13:21:38.168]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:38.168]                         if (muffled) 
[13:21:38.168]                           invokeRestart("muffleMessage")
[13:21:38.168]                       }
[13:21:38.168]                       else if (inherits(cond, "warning")) {
[13:21:38.168]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:38.168]                         if (muffled) 
[13:21:38.168]                           invokeRestart("muffleWarning")
[13:21:38.168]                       }
[13:21:38.168]                       else if (inherits(cond, "condition")) {
[13:21:38.168]                         if (!is.null(pattern)) {
[13:21:38.168]                           computeRestarts <- base::computeRestarts
[13:21:38.168]                           grepl <- base::grepl
[13:21:38.168]                           restarts <- computeRestarts(cond)
[13:21:38.168]                           for (restart in restarts) {
[13:21:38.168]                             name <- restart$name
[13:21:38.168]                             if (is.null(name)) 
[13:21:38.168]                               next
[13:21:38.168]                             if (!grepl(pattern, name)) 
[13:21:38.168]                               next
[13:21:38.168]                             invokeRestart(restart)
[13:21:38.168]                             muffled <- TRUE
[13:21:38.168]                             break
[13:21:38.168]                           }
[13:21:38.168]                         }
[13:21:38.168]                       }
[13:21:38.168]                       invisible(muffled)
[13:21:38.168]                     }
[13:21:38.168]                     muffleCondition(cond, pattern = "^muffle")
[13:21:38.168]                   }
[13:21:38.168]                 }
[13:21:38.168]             }
[13:21:38.168]         }))
[13:21:38.168]     }, error = function(ex) {
[13:21:38.168]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:38.168]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:38.168]                 ...future.rng), started = ...future.startTime, 
[13:21:38.168]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:38.168]             version = "1.8"), class = "FutureResult")
[13:21:38.168]     }, finally = {
[13:21:38.168]         if (!identical(...future.workdir, getwd())) 
[13:21:38.168]             setwd(...future.workdir)
[13:21:38.168]         {
[13:21:38.168]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:38.168]                 ...future.oldOptions$nwarnings <- NULL
[13:21:38.168]             }
[13:21:38.168]             base::options(...future.oldOptions)
[13:21:38.168]             if (.Platform$OS.type == "windows") {
[13:21:38.168]                 old_names <- names(...future.oldEnvVars)
[13:21:38.168]                 envs <- base::Sys.getenv()
[13:21:38.168]                 names <- names(envs)
[13:21:38.168]                 common <- intersect(names, old_names)
[13:21:38.168]                 added <- setdiff(names, old_names)
[13:21:38.168]                 removed <- setdiff(old_names, names)
[13:21:38.168]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:38.168]                   envs[common]]
[13:21:38.168]                 NAMES <- toupper(changed)
[13:21:38.168]                 args <- list()
[13:21:38.168]                 for (kk in seq_along(NAMES)) {
[13:21:38.168]                   name <- changed[[kk]]
[13:21:38.168]                   NAME <- NAMES[[kk]]
[13:21:38.168]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.168]                     next
[13:21:38.168]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:38.168]                 }
[13:21:38.168]                 NAMES <- toupper(added)
[13:21:38.168]                 for (kk in seq_along(NAMES)) {
[13:21:38.168]                   name <- added[[kk]]
[13:21:38.168]                   NAME <- NAMES[[kk]]
[13:21:38.168]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.168]                     next
[13:21:38.168]                   args[[name]] <- ""
[13:21:38.168]                 }
[13:21:38.168]                 NAMES <- toupper(removed)
[13:21:38.168]                 for (kk in seq_along(NAMES)) {
[13:21:38.168]                   name <- removed[[kk]]
[13:21:38.168]                   NAME <- NAMES[[kk]]
[13:21:38.168]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.168]                     next
[13:21:38.168]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:38.168]                 }
[13:21:38.168]                 if (length(args) > 0) 
[13:21:38.168]                   base::do.call(base::Sys.setenv, args = args)
[13:21:38.168]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:38.168]             }
[13:21:38.168]             else {
[13:21:38.168]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:38.168]             }
[13:21:38.168]             {
[13:21:38.168]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:38.168]                   0L) {
[13:21:38.168]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:38.168]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:38.168]                   base::options(opts)
[13:21:38.168]                 }
[13:21:38.168]                 {
[13:21:38.168]                   {
[13:21:38.168]                     NULL
[13:21:38.168]                     RNGkind("Mersenne-Twister")
[13:21:38.168]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:38.168]                       inherits = FALSE)
[13:21:38.168]                   }
[13:21:38.168]                   options(future.plan = NULL)
[13:21:38.168]                   if (is.na(NA_character_)) 
[13:21:38.168]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:38.168]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:38.168]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:38.168]                   {
[13:21:38.168]                     future <- SequentialFuture(..., envir = envir)
[13:21:38.168]                     if (!future$lazy) 
[13:21:38.168]                       future <- run(future)
[13:21:38.168]                     invisible(future)
[13:21:38.168]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:38.168]                 }
[13:21:38.168]             }
[13:21:38.168]         }
[13:21:38.168]     })
[13:21:38.168]     if (TRUE) {
[13:21:38.168]         base::sink(type = "output", split = FALSE)
[13:21:38.168]         if (TRUE) {
[13:21:38.168]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:38.168]         }
[13:21:38.168]         else {
[13:21:38.168]             ...future.result["stdout"] <- base::list(NULL)
[13:21:38.168]         }
[13:21:38.168]         base::close(...future.stdout)
[13:21:38.168]         ...future.stdout <- NULL
[13:21:38.168]     }
[13:21:38.168]     ...future.result$conditions <- ...future.conditions
[13:21:38.168]     ...future.result$finished <- base::Sys.time()
[13:21:38.168]     ...future.result
[13:21:38.168] }
[13:21:38.170] plan(): Setting new future strategy stack:
[13:21:38.170] List of future strategies:
[13:21:38.170] 1. sequential:
[13:21:38.170]    - args: function (..., envir = parent.frame())
[13:21:38.170]    - tweaked: FALSE
[13:21:38.170]    - call: NULL
[13:21:38.170] plan(): nbrOfWorkers() = 1
[13:21:38.171] plan(): Setting new future strategy stack:
[13:21:38.171] List of future strategies:
[13:21:38.171] 1. sequential:
[13:21:38.171]    - args: function (..., envir = parent.frame())
[13:21:38.171]    - tweaked: FALSE
[13:21:38.171]    - call: plan(strategy)
[13:21:38.171] plan(): nbrOfWorkers() = 1
[13:21:38.171] SequentialFuture started (and completed)
[13:21:38.172] - Launch lazy future ... done
[13:21:38.172] run() for ‘SequentialFuture’ ... done
[13:21:38.172] resolved() for ‘SequentialFuture’ ...
[13:21:38.172] - state: ‘finished’
[13:21:38.172] - run: TRUE
[13:21:38.172] - result: ‘FutureResult’
[13:21:38.172] resolved() for ‘SequentialFuture’ ... done
[13:21:38.172] Future #2
[13:21:38.172]  length: 1 (resolved future 2)
[13:21:38.172]  length: 0 (resolved future 3)
[13:21:38.173] resolve() on list ... DONE
[13:21:38.173] resolved() for ‘SequentialFuture’ ...
[13:21:38.173] - state: ‘finished’
[13:21:38.173] - run: TRUE
[13:21:38.173] - result: ‘FutureResult’
[13:21:38.173] resolved() for ‘SequentialFuture’ ... done
[13:21:38.173] resolved() for ‘SequentialFuture’ ...
[13:21:38.173] - state: ‘finished’
[13:21:38.173] - run: TRUE
[13:21:38.173] - result: ‘FutureResult’
[13:21:38.174] resolved() for ‘SequentialFuture’ ... done
[13:21:38.174] getGlobalsAndPackages() ...
[13:21:38.174] Searching for globals...
[13:21:38.174] 
[13:21:38.174] Searching for globals ... DONE
[13:21:38.174] - globals: [0] <none>
[13:21:38.174] getGlobalsAndPackages() ... DONE
[13:21:38.174] run() for ‘Future’ ...
[13:21:38.175] - state: ‘created’
[13:21:38.175] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:38.175] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:38.175] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:38.175]   - Field: ‘label’
[13:21:38.175]   - Field: ‘local’
[13:21:38.175]   - Field: ‘owner’
[13:21:38.175]   - Field: ‘envir’
[13:21:38.176]   - Field: ‘packages’
[13:21:38.176]   - Field: ‘gc’
[13:21:38.176]   - Field: ‘conditions’
[13:21:38.176]   - Field: ‘expr’
[13:21:38.176]   - Field: ‘uuid’
[13:21:38.176]   - Field: ‘seed’
[13:21:38.176]   - Field: ‘version’
[13:21:38.176]   - Field: ‘result’
[13:21:38.176]   - Field: ‘asynchronous’
[13:21:38.176]   - Field: ‘calls’
[13:21:38.176]   - Field: ‘globals’
[13:21:38.177]   - Field: ‘stdout’
[13:21:38.177]   - Field: ‘earlySignal’
[13:21:38.177]   - Field: ‘lazy’
[13:21:38.177]   - Field: ‘state’
[13:21:38.177] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:38.177] - Launch lazy future ...
[13:21:38.177] Packages needed by the future expression (n = 0): <none>
[13:21:38.177] Packages needed by future strategies (n = 0): <none>
[13:21:38.178] {
[13:21:38.178]     {
[13:21:38.178]         {
[13:21:38.178]             ...future.startTime <- base::Sys.time()
[13:21:38.178]             {
[13:21:38.178]                 {
[13:21:38.178]                   {
[13:21:38.178]                     base::local({
[13:21:38.178]                       has_future <- base::requireNamespace("future", 
[13:21:38.178]                         quietly = TRUE)
[13:21:38.178]                       if (has_future) {
[13:21:38.178]                         ns <- base::getNamespace("future")
[13:21:38.178]                         version <- ns[[".package"]][["version"]]
[13:21:38.178]                         if (is.null(version)) 
[13:21:38.178]                           version <- utils::packageVersion("future")
[13:21:38.178]                       }
[13:21:38.178]                       else {
[13:21:38.178]                         version <- NULL
[13:21:38.178]                       }
[13:21:38.178]                       if (!has_future || version < "1.8.0") {
[13:21:38.178]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:38.178]                           "", base::R.version$version.string), 
[13:21:38.178]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:38.178]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:38.178]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:38.178]                             "release", "version")], collapse = " "), 
[13:21:38.178]                           hostname = base::Sys.info()[["nodename"]])
[13:21:38.178]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:38.178]                           info)
[13:21:38.178]                         info <- base::paste(info, collapse = "; ")
[13:21:38.178]                         if (!has_future) {
[13:21:38.178]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:38.178]                             info)
[13:21:38.178]                         }
[13:21:38.178]                         else {
[13:21:38.178]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:38.178]                             info, version)
[13:21:38.178]                         }
[13:21:38.178]                         base::stop(msg)
[13:21:38.178]                       }
[13:21:38.178]                     })
[13:21:38.178]                   }
[13:21:38.178]                   options(future.plan = NULL)
[13:21:38.178]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:38.178]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:38.178]                 }
[13:21:38.178]                 ...future.workdir <- getwd()
[13:21:38.178]             }
[13:21:38.178]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:38.178]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:38.178]         }
[13:21:38.178]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:38.178]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:38.178]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:38.178]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:38.178]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:38.178]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:38.178]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:38.178]             base::names(...future.oldOptions))
[13:21:38.178]     }
[13:21:38.178]     if (FALSE) {
[13:21:38.178]     }
[13:21:38.178]     else {
[13:21:38.178]         if (TRUE) {
[13:21:38.178]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:38.178]                 open = "w")
[13:21:38.178]         }
[13:21:38.178]         else {
[13:21:38.178]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:38.178]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:38.178]         }
[13:21:38.178]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:38.178]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:38.178]             base::sink(type = "output", split = FALSE)
[13:21:38.178]             base::close(...future.stdout)
[13:21:38.178]         }, add = TRUE)
[13:21:38.178]     }
[13:21:38.178]     ...future.frame <- base::sys.nframe()
[13:21:38.178]     ...future.conditions <- base::list()
[13:21:38.178]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:38.178]     if (FALSE) {
[13:21:38.178]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:38.178]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:38.178]     }
[13:21:38.178]     ...future.result <- base::tryCatch({
[13:21:38.178]         base::withCallingHandlers({
[13:21:38.178]             ...future.value <- base::withVisible(base::local(1))
[13:21:38.178]             future::FutureResult(value = ...future.value$value, 
[13:21:38.178]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:38.178]                   ...future.rng), globalenv = if (FALSE) 
[13:21:38.178]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:38.178]                     ...future.globalenv.names))
[13:21:38.178]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:38.178]         }, condition = base::local({
[13:21:38.178]             c <- base::c
[13:21:38.178]             inherits <- base::inherits
[13:21:38.178]             invokeRestart <- base::invokeRestart
[13:21:38.178]             length <- base::length
[13:21:38.178]             list <- base::list
[13:21:38.178]             seq.int <- base::seq.int
[13:21:38.178]             signalCondition <- base::signalCondition
[13:21:38.178]             sys.calls <- base::sys.calls
[13:21:38.178]             `[[` <- base::`[[`
[13:21:38.178]             `+` <- base::`+`
[13:21:38.178]             `<<-` <- base::`<<-`
[13:21:38.178]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:38.178]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:38.178]                   3L)]
[13:21:38.178]             }
[13:21:38.178]             function(cond) {
[13:21:38.178]                 is_error <- inherits(cond, "error")
[13:21:38.178]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:38.178]                   NULL)
[13:21:38.178]                 if (is_error) {
[13:21:38.178]                   sessionInformation <- function() {
[13:21:38.178]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:38.178]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:38.178]                       search = base::search(), system = base::Sys.info())
[13:21:38.178]                   }
[13:21:38.178]                   ...future.conditions[[length(...future.conditions) + 
[13:21:38.178]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:38.178]                     cond$call), session = sessionInformation(), 
[13:21:38.178]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:38.178]                   signalCondition(cond)
[13:21:38.178]                 }
[13:21:38.178]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:38.178]                 "immediateCondition"))) {
[13:21:38.178]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:38.178]                   ...future.conditions[[length(...future.conditions) + 
[13:21:38.178]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:38.178]                   if (TRUE && !signal) {
[13:21:38.178]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:38.178]                     {
[13:21:38.178]                       inherits <- base::inherits
[13:21:38.178]                       invokeRestart <- base::invokeRestart
[13:21:38.178]                       is.null <- base::is.null
[13:21:38.178]                       muffled <- FALSE
[13:21:38.178]                       if (inherits(cond, "message")) {
[13:21:38.178]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:38.178]                         if (muffled) 
[13:21:38.178]                           invokeRestart("muffleMessage")
[13:21:38.178]                       }
[13:21:38.178]                       else if (inherits(cond, "warning")) {
[13:21:38.178]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:38.178]                         if (muffled) 
[13:21:38.178]                           invokeRestart("muffleWarning")
[13:21:38.178]                       }
[13:21:38.178]                       else if (inherits(cond, "condition")) {
[13:21:38.178]                         if (!is.null(pattern)) {
[13:21:38.178]                           computeRestarts <- base::computeRestarts
[13:21:38.178]                           grepl <- base::grepl
[13:21:38.178]                           restarts <- computeRestarts(cond)
[13:21:38.178]                           for (restart in restarts) {
[13:21:38.178]                             name <- restart$name
[13:21:38.178]                             if (is.null(name)) 
[13:21:38.178]                               next
[13:21:38.178]                             if (!grepl(pattern, name)) 
[13:21:38.178]                               next
[13:21:38.178]                             invokeRestart(restart)
[13:21:38.178]                             muffled <- TRUE
[13:21:38.178]                             break
[13:21:38.178]                           }
[13:21:38.178]                         }
[13:21:38.178]                       }
[13:21:38.178]                       invisible(muffled)
[13:21:38.178]                     }
[13:21:38.178]                     muffleCondition(cond, pattern = "^muffle")
[13:21:38.178]                   }
[13:21:38.178]                 }
[13:21:38.178]                 else {
[13:21:38.178]                   if (TRUE) {
[13:21:38.178]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:38.178]                     {
[13:21:38.178]                       inherits <- base::inherits
[13:21:38.178]                       invokeRestart <- base::invokeRestart
[13:21:38.178]                       is.null <- base::is.null
[13:21:38.178]                       muffled <- FALSE
[13:21:38.178]                       if (inherits(cond, "message")) {
[13:21:38.178]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:38.178]                         if (muffled) 
[13:21:38.178]                           invokeRestart("muffleMessage")
[13:21:38.178]                       }
[13:21:38.178]                       else if (inherits(cond, "warning")) {
[13:21:38.178]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:38.178]                         if (muffled) 
[13:21:38.178]                           invokeRestart("muffleWarning")
[13:21:38.178]                       }
[13:21:38.178]                       else if (inherits(cond, "condition")) {
[13:21:38.178]                         if (!is.null(pattern)) {
[13:21:38.178]                           computeRestarts <- base::computeRestarts
[13:21:38.178]                           grepl <- base::grepl
[13:21:38.178]                           restarts <- computeRestarts(cond)
[13:21:38.178]                           for (restart in restarts) {
[13:21:38.178]                             name <- restart$name
[13:21:38.178]                             if (is.null(name)) 
[13:21:38.178]                               next
[13:21:38.178]                             if (!grepl(pattern, name)) 
[13:21:38.178]                               next
[13:21:38.178]                             invokeRestart(restart)
[13:21:38.178]                             muffled <- TRUE
[13:21:38.178]                             break
[13:21:38.178]                           }
[13:21:38.178]                         }
[13:21:38.178]                       }
[13:21:38.178]                       invisible(muffled)
[13:21:38.178]                     }
[13:21:38.178]                     muffleCondition(cond, pattern = "^muffle")
[13:21:38.178]                   }
[13:21:38.178]                 }
[13:21:38.178]             }
[13:21:38.178]         }))
[13:21:38.178]     }, error = function(ex) {
[13:21:38.178]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:38.178]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:38.178]                 ...future.rng), started = ...future.startTime, 
[13:21:38.178]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:38.178]             version = "1.8"), class = "FutureResult")
[13:21:38.178]     }, finally = {
[13:21:38.178]         if (!identical(...future.workdir, getwd())) 
[13:21:38.178]             setwd(...future.workdir)
[13:21:38.178]         {
[13:21:38.178]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:38.178]                 ...future.oldOptions$nwarnings <- NULL
[13:21:38.178]             }
[13:21:38.178]             base::options(...future.oldOptions)
[13:21:38.178]             if (.Platform$OS.type == "windows") {
[13:21:38.178]                 old_names <- names(...future.oldEnvVars)
[13:21:38.178]                 envs <- base::Sys.getenv()
[13:21:38.178]                 names <- names(envs)
[13:21:38.178]                 common <- intersect(names, old_names)
[13:21:38.178]                 added <- setdiff(names, old_names)
[13:21:38.178]                 removed <- setdiff(old_names, names)
[13:21:38.178]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:38.178]                   envs[common]]
[13:21:38.178]                 NAMES <- toupper(changed)
[13:21:38.178]                 args <- list()
[13:21:38.178]                 for (kk in seq_along(NAMES)) {
[13:21:38.178]                   name <- changed[[kk]]
[13:21:38.178]                   NAME <- NAMES[[kk]]
[13:21:38.178]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.178]                     next
[13:21:38.178]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:38.178]                 }
[13:21:38.178]                 NAMES <- toupper(added)
[13:21:38.178]                 for (kk in seq_along(NAMES)) {
[13:21:38.178]                   name <- added[[kk]]
[13:21:38.178]                   NAME <- NAMES[[kk]]
[13:21:38.178]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.178]                     next
[13:21:38.178]                   args[[name]] <- ""
[13:21:38.178]                 }
[13:21:38.178]                 NAMES <- toupper(removed)
[13:21:38.178]                 for (kk in seq_along(NAMES)) {
[13:21:38.178]                   name <- removed[[kk]]
[13:21:38.178]                   NAME <- NAMES[[kk]]
[13:21:38.178]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.178]                     next
[13:21:38.178]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:38.178]                 }
[13:21:38.178]                 if (length(args) > 0) 
[13:21:38.178]                   base::do.call(base::Sys.setenv, args = args)
[13:21:38.178]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:38.178]             }
[13:21:38.178]             else {
[13:21:38.178]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:38.178]             }
[13:21:38.178]             {
[13:21:38.178]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:38.178]                   0L) {
[13:21:38.178]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:38.178]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:38.178]                   base::options(opts)
[13:21:38.178]                 }
[13:21:38.178]                 {
[13:21:38.178]                   {
[13:21:38.178]                     NULL
[13:21:38.178]                     RNGkind("Mersenne-Twister")
[13:21:38.178]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:38.178]                       inherits = FALSE)
[13:21:38.178]                   }
[13:21:38.178]                   options(future.plan = NULL)
[13:21:38.178]                   if (is.na(NA_character_)) 
[13:21:38.178]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:38.178]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:38.178]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:38.178]                   {
[13:21:38.178]                     future <- SequentialFuture(..., envir = envir)
[13:21:38.178]                     if (!future$lazy) 
[13:21:38.178]                       future <- run(future)
[13:21:38.178]                     invisible(future)
[13:21:38.178]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:38.178]                 }
[13:21:38.178]             }
[13:21:38.178]         }
[13:21:38.178]     })
[13:21:38.178]     if (TRUE) {
[13:21:38.178]         base::sink(type = "output", split = FALSE)
[13:21:38.178]         if (TRUE) {
[13:21:38.178]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:38.178]         }
[13:21:38.178]         else {
[13:21:38.178]             ...future.result["stdout"] <- base::list(NULL)
[13:21:38.178]         }
[13:21:38.178]         base::close(...future.stdout)
[13:21:38.178]         ...future.stdout <- NULL
[13:21:38.178]     }
[13:21:38.178]     ...future.result$conditions <- ...future.conditions
[13:21:38.178]     ...future.result$finished <- base::Sys.time()
[13:21:38.178]     ...future.result
[13:21:38.178] }
[13:21:38.179] plan(): Setting new future strategy stack:
[13:21:38.180] List of future strategies:
[13:21:38.180] 1. sequential:
[13:21:38.180]    - args: function (..., envir = parent.frame())
[13:21:38.180]    - tweaked: FALSE
[13:21:38.180]    - call: NULL
[13:21:38.180] plan(): nbrOfWorkers() = 1
[13:21:38.181] plan(): Setting new future strategy stack:
[13:21:38.181] List of future strategies:
[13:21:38.181] 1. sequential:
[13:21:38.181]    - args: function (..., envir = parent.frame())
[13:21:38.181]    - tweaked: FALSE
[13:21:38.181]    - call: plan(strategy)
[13:21:38.181] plan(): nbrOfWorkers() = 1
[13:21:38.181] SequentialFuture started (and completed)
[13:21:38.181] - Launch lazy future ... done
[13:21:38.181] run() for ‘SequentialFuture’ ... done
[13:21:38.182] getGlobalsAndPackages() ...
[13:21:38.182] Searching for globals...
[13:21:38.186] - globals found: [2] ‘{’, ‘Sys.sleep’
[13:21:38.186] Searching for globals ... DONE
[13:21:38.187] Resolving globals: FALSE
[13:21:38.187] 
[13:21:38.187] 
[13:21:38.187] getGlobalsAndPackages() ... DONE
[13:21:38.188] run() for ‘Future’ ...
[13:21:38.188] - state: ‘created’
[13:21:38.188] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:38.188] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:38.188] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:38.188]   - Field: ‘label’
[13:21:38.188]   - Field: ‘local’
[13:21:38.188]   - Field: ‘owner’
[13:21:38.189]   - Field: ‘envir’
[13:21:38.189]   - Field: ‘packages’
[13:21:38.189]   - Field: ‘gc’
[13:21:38.189]   - Field: ‘conditions’
[13:21:38.189]   - Field: ‘expr’
[13:21:38.189]   - Field: ‘uuid’
[13:21:38.189]   - Field: ‘seed’
[13:21:38.191]   - Field: ‘version’
[13:21:38.191]   - Field: ‘result’
[13:21:38.191]   - Field: ‘asynchronous’
[13:21:38.191]   - Field: ‘calls’
[13:21:38.192]   - Field: ‘globals’
[13:21:38.192]   - Field: ‘stdout’
[13:21:38.192]   - Field: ‘earlySignal’
[13:21:38.192]   - Field: ‘lazy’
[13:21:38.192]   - Field: ‘state’
[13:21:38.192] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:38.192] - Launch lazy future ...
[13:21:38.192] Packages needed by the future expression (n = 0): <none>
[13:21:38.192] Packages needed by future strategies (n = 0): <none>
[13:21:38.193] {
[13:21:38.193]     {
[13:21:38.193]         {
[13:21:38.193]             ...future.startTime <- base::Sys.time()
[13:21:38.193]             {
[13:21:38.193]                 {
[13:21:38.193]                   {
[13:21:38.193]                     base::local({
[13:21:38.193]                       has_future <- base::requireNamespace("future", 
[13:21:38.193]                         quietly = TRUE)
[13:21:38.193]                       if (has_future) {
[13:21:38.193]                         ns <- base::getNamespace("future")
[13:21:38.193]                         version <- ns[[".package"]][["version"]]
[13:21:38.193]                         if (is.null(version)) 
[13:21:38.193]                           version <- utils::packageVersion("future")
[13:21:38.193]                       }
[13:21:38.193]                       else {
[13:21:38.193]                         version <- NULL
[13:21:38.193]                       }
[13:21:38.193]                       if (!has_future || version < "1.8.0") {
[13:21:38.193]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:38.193]                           "", base::R.version$version.string), 
[13:21:38.193]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:38.193]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:38.193]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:38.193]                             "release", "version")], collapse = " "), 
[13:21:38.193]                           hostname = base::Sys.info()[["nodename"]])
[13:21:38.193]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:38.193]                           info)
[13:21:38.193]                         info <- base::paste(info, collapse = "; ")
[13:21:38.193]                         if (!has_future) {
[13:21:38.193]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:38.193]                             info)
[13:21:38.193]                         }
[13:21:38.193]                         else {
[13:21:38.193]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:38.193]                             info, version)
[13:21:38.193]                         }
[13:21:38.193]                         base::stop(msg)
[13:21:38.193]                       }
[13:21:38.193]                     })
[13:21:38.193]                   }
[13:21:38.193]                   options(future.plan = NULL)
[13:21:38.193]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:38.193]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:38.193]                 }
[13:21:38.193]                 ...future.workdir <- getwd()
[13:21:38.193]             }
[13:21:38.193]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:38.193]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:38.193]         }
[13:21:38.193]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:38.193]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:38.193]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:38.193]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:38.193]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:38.193]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:38.193]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:38.193]             base::names(...future.oldOptions))
[13:21:38.193]     }
[13:21:38.193]     if (FALSE) {
[13:21:38.193]     }
[13:21:38.193]     else {
[13:21:38.193]         if (TRUE) {
[13:21:38.193]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:38.193]                 open = "w")
[13:21:38.193]         }
[13:21:38.193]         else {
[13:21:38.193]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:38.193]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:38.193]         }
[13:21:38.193]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:38.193]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:38.193]             base::sink(type = "output", split = FALSE)
[13:21:38.193]             base::close(...future.stdout)
[13:21:38.193]         }, add = TRUE)
[13:21:38.193]     }
[13:21:38.193]     ...future.frame <- base::sys.nframe()
[13:21:38.193]     ...future.conditions <- base::list()
[13:21:38.193]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:38.193]     if (FALSE) {
[13:21:38.193]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:38.193]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:38.193]     }
[13:21:38.193]     ...future.result <- base::tryCatch({
[13:21:38.193]         base::withCallingHandlers({
[13:21:38.193]             ...future.value <- base::withVisible(base::local({
[13:21:38.193]                 Sys.sleep(0.5)
[13:21:38.193]                 2
[13:21:38.193]             }))
[13:21:38.193]             future::FutureResult(value = ...future.value$value, 
[13:21:38.193]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:38.193]                   ...future.rng), globalenv = if (FALSE) 
[13:21:38.193]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:38.193]                     ...future.globalenv.names))
[13:21:38.193]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:38.193]         }, condition = base::local({
[13:21:38.193]             c <- base::c
[13:21:38.193]             inherits <- base::inherits
[13:21:38.193]             invokeRestart <- base::invokeRestart
[13:21:38.193]             length <- base::length
[13:21:38.193]             list <- base::list
[13:21:38.193]             seq.int <- base::seq.int
[13:21:38.193]             signalCondition <- base::signalCondition
[13:21:38.193]             sys.calls <- base::sys.calls
[13:21:38.193]             `[[` <- base::`[[`
[13:21:38.193]             `+` <- base::`+`
[13:21:38.193]             `<<-` <- base::`<<-`
[13:21:38.193]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:38.193]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:38.193]                   3L)]
[13:21:38.193]             }
[13:21:38.193]             function(cond) {
[13:21:38.193]                 is_error <- inherits(cond, "error")
[13:21:38.193]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:38.193]                   NULL)
[13:21:38.193]                 if (is_error) {
[13:21:38.193]                   sessionInformation <- function() {
[13:21:38.193]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:38.193]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:38.193]                       search = base::search(), system = base::Sys.info())
[13:21:38.193]                   }
[13:21:38.193]                   ...future.conditions[[length(...future.conditions) + 
[13:21:38.193]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:38.193]                     cond$call), session = sessionInformation(), 
[13:21:38.193]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:38.193]                   signalCondition(cond)
[13:21:38.193]                 }
[13:21:38.193]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:38.193]                 "immediateCondition"))) {
[13:21:38.193]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:38.193]                   ...future.conditions[[length(...future.conditions) + 
[13:21:38.193]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:38.193]                   if (TRUE && !signal) {
[13:21:38.193]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:38.193]                     {
[13:21:38.193]                       inherits <- base::inherits
[13:21:38.193]                       invokeRestart <- base::invokeRestart
[13:21:38.193]                       is.null <- base::is.null
[13:21:38.193]                       muffled <- FALSE
[13:21:38.193]                       if (inherits(cond, "message")) {
[13:21:38.193]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:38.193]                         if (muffled) 
[13:21:38.193]                           invokeRestart("muffleMessage")
[13:21:38.193]                       }
[13:21:38.193]                       else if (inherits(cond, "warning")) {
[13:21:38.193]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:38.193]                         if (muffled) 
[13:21:38.193]                           invokeRestart("muffleWarning")
[13:21:38.193]                       }
[13:21:38.193]                       else if (inherits(cond, "condition")) {
[13:21:38.193]                         if (!is.null(pattern)) {
[13:21:38.193]                           computeRestarts <- base::computeRestarts
[13:21:38.193]                           grepl <- base::grepl
[13:21:38.193]                           restarts <- computeRestarts(cond)
[13:21:38.193]                           for (restart in restarts) {
[13:21:38.193]                             name <- restart$name
[13:21:38.193]                             if (is.null(name)) 
[13:21:38.193]                               next
[13:21:38.193]                             if (!grepl(pattern, name)) 
[13:21:38.193]                               next
[13:21:38.193]                             invokeRestart(restart)
[13:21:38.193]                             muffled <- TRUE
[13:21:38.193]                             break
[13:21:38.193]                           }
[13:21:38.193]                         }
[13:21:38.193]                       }
[13:21:38.193]                       invisible(muffled)
[13:21:38.193]                     }
[13:21:38.193]                     muffleCondition(cond, pattern = "^muffle")
[13:21:38.193]                   }
[13:21:38.193]                 }
[13:21:38.193]                 else {
[13:21:38.193]                   if (TRUE) {
[13:21:38.193]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:38.193]                     {
[13:21:38.193]                       inherits <- base::inherits
[13:21:38.193]                       invokeRestart <- base::invokeRestart
[13:21:38.193]                       is.null <- base::is.null
[13:21:38.193]                       muffled <- FALSE
[13:21:38.193]                       if (inherits(cond, "message")) {
[13:21:38.193]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:38.193]                         if (muffled) 
[13:21:38.193]                           invokeRestart("muffleMessage")
[13:21:38.193]                       }
[13:21:38.193]                       else if (inherits(cond, "warning")) {
[13:21:38.193]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:38.193]                         if (muffled) 
[13:21:38.193]                           invokeRestart("muffleWarning")
[13:21:38.193]                       }
[13:21:38.193]                       else if (inherits(cond, "condition")) {
[13:21:38.193]                         if (!is.null(pattern)) {
[13:21:38.193]                           computeRestarts <- base::computeRestarts
[13:21:38.193]                           grepl <- base::grepl
[13:21:38.193]                           restarts <- computeRestarts(cond)
[13:21:38.193]                           for (restart in restarts) {
[13:21:38.193]                             name <- restart$name
[13:21:38.193]                             if (is.null(name)) 
[13:21:38.193]                               next
[13:21:38.193]                             if (!grepl(pattern, name)) 
[13:21:38.193]                               next
[13:21:38.193]                             invokeRestart(restart)
[13:21:38.193]                             muffled <- TRUE
[13:21:38.193]                             break
[13:21:38.193]                           }
[13:21:38.193]                         }
[13:21:38.193]                       }
[13:21:38.193]                       invisible(muffled)
[13:21:38.193]                     }
[13:21:38.193]                     muffleCondition(cond, pattern = "^muffle")
[13:21:38.193]                   }
[13:21:38.193]                 }
[13:21:38.193]             }
[13:21:38.193]         }))
[13:21:38.193]     }, error = function(ex) {
[13:21:38.193]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:38.193]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:38.193]                 ...future.rng), started = ...future.startTime, 
[13:21:38.193]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:38.193]             version = "1.8"), class = "FutureResult")
[13:21:38.193]     }, finally = {
[13:21:38.193]         if (!identical(...future.workdir, getwd())) 
[13:21:38.193]             setwd(...future.workdir)
[13:21:38.193]         {
[13:21:38.193]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:38.193]                 ...future.oldOptions$nwarnings <- NULL
[13:21:38.193]             }
[13:21:38.193]             base::options(...future.oldOptions)
[13:21:38.193]             if (.Platform$OS.type == "windows") {
[13:21:38.193]                 old_names <- names(...future.oldEnvVars)
[13:21:38.193]                 envs <- base::Sys.getenv()
[13:21:38.193]                 names <- names(envs)
[13:21:38.193]                 common <- intersect(names, old_names)
[13:21:38.193]                 added <- setdiff(names, old_names)
[13:21:38.193]                 removed <- setdiff(old_names, names)
[13:21:38.193]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:38.193]                   envs[common]]
[13:21:38.193]                 NAMES <- toupper(changed)
[13:21:38.193]                 args <- list()
[13:21:38.193]                 for (kk in seq_along(NAMES)) {
[13:21:38.193]                   name <- changed[[kk]]
[13:21:38.193]                   NAME <- NAMES[[kk]]
[13:21:38.193]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.193]                     next
[13:21:38.193]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:38.193]                 }
[13:21:38.193]                 NAMES <- toupper(added)
[13:21:38.193]                 for (kk in seq_along(NAMES)) {
[13:21:38.193]                   name <- added[[kk]]
[13:21:38.193]                   NAME <- NAMES[[kk]]
[13:21:38.193]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.193]                     next
[13:21:38.193]                   args[[name]] <- ""
[13:21:38.193]                 }
[13:21:38.193]                 NAMES <- toupper(removed)
[13:21:38.193]                 for (kk in seq_along(NAMES)) {
[13:21:38.193]                   name <- removed[[kk]]
[13:21:38.193]                   NAME <- NAMES[[kk]]
[13:21:38.193]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.193]                     next
[13:21:38.193]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:38.193]                 }
[13:21:38.193]                 if (length(args) > 0) 
[13:21:38.193]                   base::do.call(base::Sys.setenv, args = args)
[13:21:38.193]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:38.193]             }
[13:21:38.193]             else {
[13:21:38.193]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:38.193]             }
[13:21:38.193]             {
[13:21:38.193]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:38.193]                   0L) {
[13:21:38.193]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:38.193]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:38.193]                   base::options(opts)
[13:21:38.193]                 }
[13:21:38.193]                 {
[13:21:38.193]                   {
[13:21:38.193]                     NULL
[13:21:38.193]                     RNGkind("Mersenne-Twister")
[13:21:38.193]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:38.193]                       inherits = FALSE)
[13:21:38.193]                   }
[13:21:38.193]                   options(future.plan = NULL)
[13:21:38.193]                   if (is.na(NA_character_)) 
[13:21:38.193]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:38.193]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:38.193]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:38.193]                   {
[13:21:38.193]                     future <- SequentialFuture(..., envir = envir)
[13:21:38.193]                     if (!future$lazy) 
[13:21:38.193]                       future <- run(future)
[13:21:38.193]                     invisible(future)
[13:21:38.193]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:38.193]                 }
[13:21:38.193]             }
[13:21:38.193]         }
[13:21:38.193]     })
[13:21:38.193]     if (TRUE) {
[13:21:38.193]         base::sink(type = "output", split = FALSE)
[13:21:38.193]         if (TRUE) {
[13:21:38.193]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:38.193]         }
[13:21:38.193]         else {
[13:21:38.193]             ...future.result["stdout"] <- base::list(NULL)
[13:21:38.193]         }
[13:21:38.193]         base::close(...future.stdout)
[13:21:38.193]         ...future.stdout <- NULL
[13:21:38.193]     }
[13:21:38.193]     ...future.result$conditions <- ...future.conditions
[13:21:38.193]     ...future.result$finished <- base::Sys.time()
[13:21:38.193]     ...future.result
[13:21:38.193] }
[13:21:38.195] plan(): Setting new future strategy stack:
[13:21:38.195] List of future strategies:
[13:21:38.195] 1. sequential:
[13:21:38.195]    - args: function (..., envir = parent.frame())
[13:21:38.195]    - tweaked: FALSE
[13:21:38.195]    - call: NULL
[13:21:38.195] plan(): nbrOfWorkers() = 1
[13:21:38.697] plan(): Setting new future strategy stack:
[13:21:38.697] List of future strategies:
[13:21:38.697] 1. sequential:
[13:21:38.697]    - args: function (..., envir = parent.frame())
[13:21:38.697]    - tweaked: FALSE
[13:21:38.697]    - call: plan(strategy)
[13:21:38.697] plan(): nbrOfWorkers() = 1
[13:21:38.698] SequentialFuture started (and completed)
[13:21:38.698] - Launch lazy future ... done
[13:21:38.698] run() for ‘SequentialFuture’ ... done
[13:21:38.699] resolve() on list ...
[13:21:38.699]  recursive: 0
[13:21:38.699]  length: 1
[13:21:38.699] 
[13:21:38.699] resolved() for ‘SequentialFuture’ ...
[13:21:38.699] - state: ‘finished’
[13:21:38.699] - run: TRUE
[13:21:38.699] - result: ‘FutureResult’
[13:21:38.699] resolved() for ‘SequentialFuture’ ... done
[13:21:38.699] Future #1
[13:21:38.699]  length: 0 (resolved future 1)
[13:21:38.700] resolve() on list ... DONE
[13:21:38.700] resolved() for ‘SequentialFuture’ ...
[13:21:38.700] - state: ‘finished’
[13:21:38.700] - run: TRUE
[13:21:38.700] - result: ‘FutureResult’
[13:21:38.700] resolved() for ‘SequentialFuture’ ... done
[13:21:38.700] resolve() on list ...
[13:21:38.700]  recursive: 0
[13:21:38.700]  length: 1
[13:21:38.701] 
[13:21:38.701] resolved() for ‘SequentialFuture’ ...
[13:21:38.701] - state: ‘finished’
[13:21:38.701] - run: TRUE
[13:21:38.701] - result: ‘FutureResult’
[13:21:38.701] resolved() for ‘SequentialFuture’ ... done
[13:21:38.701] Future #1
[13:21:38.701]  length: 0 (resolved future 1)
[13:21:38.701] resolve() on list ... DONE
[13:21:38.701] resolved() for ‘SequentialFuture’ ...
[13:21:38.701] - state: ‘finished’
[13:21:38.702] - run: TRUE
[13:21:38.702] - result: ‘FutureResult’
[13:21:38.702] resolved() for ‘SequentialFuture’ ... done
[13:21:38.702] resolve() on list ...
[13:21:38.702]  recursive: 0
[13:21:38.702]  length: 1
[13:21:38.702] 
[13:21:38.702]  length: 0 (resolved future 1)
[13:21:38.702] resolve() on list ... DONE
[13:21:38.703] resolve() on list ...
[13:21:38.703]  recursive: 0
[13:21:38.703]  length: 4
[13:21:38.703] 
[13:21:38.703] resolved() for ‘SequentialFuture’ ...
[13:21:38.703] - state: ‘finished’
[13:21:38.703] - run: TRUE
[13:21:38.703] - result: ‘FutureResult’
[13:21:38.703] resolved() for ‘SequentialFuture’ ... done
[13:21:38.703] Future #1
[13:21:38.703]  length: 3 (resolved future 1)
[13:21:38.704] resolved() for ‘SequentialFuture’ ...
[13:21:38.704] - state: ‘finished’
[13:21:38.704] - run: TRUE
[13:21:38.704] - result: ‘FutureResult’
[13:21:38.704] resolved() for ‘SequentialFuture’ ... done
[13:21:38.704] Future #2
[13:21:38.704]  length: 2 (resolved future 2)
[13:21:38.704]  length: 1 (resolved future 3)
[13:21:38.704]  length: 0 (resolved future 4)
[13:21:38.705] resolve() on list ... DONE
[13:21:38.705] resolve() on list ...
[13:21:38.705]  recursive: 0
[13:21:38.705]  length: 4
[13:21:38.705] 
[13:21:38.705] resolved() for ‘SequentialFuture’ ...
[13:21:38.705] - state: ‘finished’
[13:21:38.705] - run: TRUE
[13:21:38.705] - result: ‘FutureResult’
[13:21:38.705] resolved() for ‘SequentialFuture’ ... done
[13:21:38.706] Future #1
[13:21:38.706]  length: 3 (resolved future 1)
[13:21:38.706] resolved() for ‘SequentialFuture’ ...
[13:21:38.706] - state: ‘finished’
[13:21:38.706] - run: TRUE
[13:21:38.706] - result: ‘FutureResult’
[13:21:38.706] resolved() for ‘SequentialFuture’ ... done
[13:21:38.706] Future #2
[13:21:38.706]  length: 2 (resolved future 2)
[13:21:38.706]  length: 1 (resolved future 3)
[13:21:38.706]  length: 0 (resolved future 4)
[13:21:38.707] resolve() on list ... DONE
[13:21:38.707] resolve() on list ...
[13:21:38.707]  recursive: 0
[13:21:38.707]  length: 1
[13:21:38.707] 
[13:21:38.707]  length: 0 (resolved future 1)
[13:21:38.707] resolve() on list ... DONE
[13:21:38.707] getGlobalsAndPackages() ...
[13:21:38.708] Searching for globals...
[13:21:38.709] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:21:38.709] Searching for globals ... DONE
[13:21:38.709] Resolving globals: FALSE
[13:21:38.710] The total size of the 1 globals is 56 bytes (56 bytes)
[13:21:38.710] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:21:38.710] - globals: [1] ‘kk’
[13:21:38.710] 
[13:21:38.710] getGlobalsAndPackages() ... DONE
[13:21:38.711] run() for ‘Future’ ...
[13:21:38.711] - state: ‘created’
[13:21:38.711] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:38.711] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:38.711] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:38.711]   - Field: ‘label’
[13:21:38.712]   - Field: ‘local’
[13:21:38.712]   - Field: ‘owner’
[13:21:38.712]   - Field: ‘envir’
[13:21:38.712]   - Field: ‘packages’
[13:21:38.712]   - Field: ‘gc’
[13:21:38.712]   - Field: ‘conditions’
[13:21:38.712]   - Field: ‘expr’
[13:21:38.712]   - Field: ‘uuid’
[13:21:38.712]   - Field: ‘seed’
[13:21:38.712]   - Field: ‘version’
[13:21:38.712]   - Field: ‘result’
[13:21:38.713]   - Field: ‘asynchronous’
[13:21:38.713]   - Field: ‘calls’
[13:21:38.713]   - Field: ‘globals’
[13:21:38.713]   - Field: ‘stdout’
[13:21:38.713]   - Field: ‘earlySignal’
[13:21:38.713]   - Field: ‘lazy’
[13:21:38.713]   - Field: ‘state’
[13:21:38.713] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:38.713] - Launch lazy future ...
[13:21:38.714] Packages needed by the future expression (n = 0): <none>
[13:21:38.714] Packages needed by future strategies (n = 0): <none>
[13:21:38.714] {
[13:21:38.714]     {
[13:21:38.714]         {
[13:21:38.714]             ...future.startTime <- base::Sys.time()
[13:21:38.714]             {
[13:21:38.714]                 {
[13:21:38.714]                   {
[13:21:38.714]                     base::local({
[13:21:38.714]                       has_future <- base::requireNamespace("future", 
[13:21:38.714]                         quietly = TRUE)
[13:21:38.714]                       if (has_future) {
[13:21:38.714]                         ns <- base::getNamespace("future")
[13:21:38.714]                         version <- ns[[".package"]][["version"]]
[13:21:38.714]                         if (is.null(version)) 
[13:21:38.714]                           version <- utils::packageVersion("future")
[13:21:38.714]                       }
[13:21:38.714]                       else {
[13:21:38.714]                         version <- NULL
[13:21:38.714]                       }
[13:21:38.714]                       if (!has_future || version < "1.8.0") {
[13:21:38.714]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:38.714]                           "", base::R.version$version.string), 
[13:21:38.714]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:38.714]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:38.714]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:38.714]                             "release", "version")], collapse = " "), 
[13:21:38.714]                           hostname = base::Sys.info()[["nodename"]])
[13:21:38.714]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:38.714]                           info)
[13:21:38.714]                         info <- base::paste(info, collapse = "; ")
[13:21:38.714]                         if (!has_future) {
[13:21:38.714]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:38.714]                             info)
[13:21:38.714]                         }
[13:21:38.714]                         else {
[13:21:38.714]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:38.714]                             info, version)
[13:21:38.714]                         }
[13:21:38.714]                         base::stop(msg)
[13:21:38.714]                       }
[13:21:38.714]                     })
[13:21:38.714]                   }
[13:21:38.714]                   options(future.plan = NULL)
[13:21:38.714]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:38.714]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:38.714]                 }
[13:21:38.714]                 ...future.workdir <- getwd()
[13:21:38.714]             }
[13:21:38.714]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:38.714]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:38.714]         }
[13:21:38.714]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:38.714]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:38.714]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:38.714]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:38.714]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:38.714]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:38.714]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:38.714]             base::names(...future.oldOptions))
[13:21:38.714]     }
[13:21:38.714]     if (FALSE) {
[13:21:38.714]     }
[13:21:38.714]     else {
[13:21:38.714]         if (TRUE) {
[13:21:38.714]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:38.714]                 open = "w")
[13:21:38.714]         }
[13:21:38.714]         else {
[13:21:38.714]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:38.714]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:38.714]         }
[13:21:38.714]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:38.714]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:38.714]             base::sink(type = "output", split = FALSE)
[13:21:38.714]             base::close(...future.stdout)
[13:21:38.714]         }, add = TRUE)
[13:21:38.714]     }
[13:21:38.714]     ...future.frame <- base::sys.nframe()
[13:21:38.714]     ...future.conditions <- base::list()
[13:21:38.714]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:38.714]     if (FALSE) {
[13:21:38.714]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:38.714]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:38.714]     }
[13:21:38.714]     ...future.result <- base::tryCatch({
[13:21:38.714]         base::withCallingHandlers({
[13:21:38.714]             ...future.value <- base::withVisible(base::local({
[13:21:38.714]                 Sys.sleep(0.1)
[13:21:38.714]                 kk
[13:21:38.714]             }))
[13:21:38.714]             future::FutureResult(value = ...future.value$value, 
[13:21:38.714]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:38.714]                   ...future.rng), globalenv = if (FALSE) 
[13:21:38.714]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:38.714]                     ...future.globalenv.names))
[13:21:38.714]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:38.714]         }, condition = base::local({
[13:21:38.714]             c <- base::c
[13:21:38.714]             inherits <- base::inherits
[13:21:38.714]             invokeRestart <- base::invokeRestart
[13:21:38.714]             length <- base::length
[13:21:38.714]             list <- base::list
[13:21:38.714]             seq.int <- base::seq.int
[13:21:38.714]             signalCondition <- base::signalCondition
[13:21:38.714]             sys.calls <- base::sys.calls
[13:21:38.714]             `[[` <- base::`[[`
[13:21:38.714]             `+` <- base::`+`
[13:21:38.714]             `<<-` <- base::`<<-`
[13:21:38.714]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:38.714]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:38.714]                   3L)]
[13:21:38.714]             }
[13:21:38.714]             function(cond) {
[13:21:38.714]                 is_error <- inherits(cond, "error")
[13:21:38.714]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:38.714]                   NULL)
[13:21:38.714]                 if (is_error) {
[13:21:38.714]                   sessionInformation <- function() {
[13:21:38.714]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:38.714]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:38.714]                       search = base::search(), system = base::Sys.info())
[13:21:38.714]                   }
[13:21:38.714]                   ...future.conditions[[length(...future.conditions) + 
[13:21:38.714]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:38.714]                     cond$call), session = sessionInformation(), 
[13:21:38.714]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:38.714]                   signalCondition(cond)
[13:21:38.714]                 }
[13:21:38.714]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:38.714]                 "immediateCondition"))) {
[13:21:38.714]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:38.714]                   ...future.conditions[[length(...future.conditions) + 
[13:21:38.714]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:38.714]                   if (TRUE && !signal) {
[13:21:38.714]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:38.714]                     {
[13:21:38.714]                       inherits <- base::inherits
[13:21:38.714]                       invokeRestart <- base::invokeRestart
[13:21:38.714]                       is.null <- base::is.null
[13:21:38.714]                       muffled <- FALSE
[13:21:38.714]                       if (inherits(cond, "message")) {
[13:21:38.714]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:38.714]                         if (muffled) 
[13:21:38.714]                           invokeRestart("muffleMessage")
[13:21:38.714]                       }
[13:21:38.714]                       else if (inherits(cond, "warning")) {
[13:21:38.714]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:38.714]                         if (muffled) 
[13:21:38.714]                           invokeRestart("muffleWarning")
[13:21:38.714]                       }
[13:21:38.714]                       else if (inherits(cond, "condition")) {
[13:21:38.714]                         if (!is.null(pattern)) {
[13:21:38.714]                           computeRestarts <- base::computeRestarts
[13:21:38.714]                           grepl <- base::grepl
[13:21:38.714]                           restarts <- computeRestarts(cond)
[13:21:38.714]                           for (restart in restarts) {
[13:21:38.714]                             name <- restart$name
[13:21:38.714]                             if (is.null(name)) 
[13:21:38.714]                               next
[13:21:38.714]                             if (!grepl(pattern, name)) 
[13:21:38.714]                               next
[13:21:38.714]                             invokeRestart(restart)
[13:21:38.714]                             muffled <- TRUE
[13:21:38.714]                             break
[13:21:38.714]                           }
[13:21:38.714]                         }
[13:21:38.714]                       }
[13:21:38.714]                       invisible(muffled)
[13:21:38.714]                     }
[13:21:38.714]                     muffleCondition(cond, pattern = "^muffle")
[13:21:38.714]                   }
[13:21:38.714]                 }
[13:21:38.714]                 else {
[13:21:38.714]                   if (TRUE) {
[13:21:38.714]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:38.714]                     {
[13:21:38.714]                       inherits <- base::inherits
[13:21:38.714]                       invokeRestart <- base::invokeRestart
[13:21:38.714]                       is.null <- base::is.null
[13:21:38.714]                       muffled <- FALSE
[13:21:38.714]                       if (inherits(cond, "message")) {
[13:21:38.714]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:38.714]                         if (muffled) 
[13:21:38.714]                           invokeRestart("muffleMessage")
[13:21:38.714]                       }
[13:21:38.714]                       else if (inherits(cond, "warning")) {
[13:21:38.714]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:38.714]                         if (muffled) 
[13:21:38.714]                           invokeRestart("muffleWarning")
[13:21:38.714]                       }
[13:21:38.714]                       else if (inherits(cond, "condition")) {
[13:21:38.714]                         if (!is.null(pattern)) {
[13:21:38.714]                           computeRestarts <- base::computeRestarts
[13:21:38.714]                           grepl <- base::grepl
[13:21:38.714]                           restarts <- computeRestarts(cond)
[13:21:38.714]                           for (restart in restarts) {
[13:21:38.714]                             name <- restart$name
[13:21:38.714]                             if (is.null(name)) 
[13:21:38.714]                               next
[13:21:38.714]                             if (!grepl(pattern, name)) 
[13:21:38.714]                               next
[13:21:38.714]                             invokeRestart(restart)
[13:21:38.714]                             muffled <- TRUE
[13:21:38.714]                             break
[13:21:38.714]                           }
[13:21:38.714]                         }
[13:21:38.714]                       }
[13:21:38.714]                       invisible(muffled)
[13:21:38.714]                     }
[13:21:38.714]                     muffleCondition(cond, pattern = "^muffle")
[13:21:38.714]                   }
[13:21:38.714]                 }
[13:21:38.714]             }
[13:21:38.714]         }))
[13:21:38.714]     }, error = function(ex) {
[13:21:38.714]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:38.714]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:38.714]                 ...future.rng), started = ...future.startTime, 
[13:21:38.714]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:38.714]             version = "1.8"), class = "FutureResult")
[13:21:38.714]     }, finally = {
[13:21:38.714]         if (!identical(...future.workdir, getwd())) 
[13:21:38.714]             setwd(...future.workdir)
[13:21:38.714]         {
[13:21:38.714]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:38.714]                 ...future.oldOptions$nwarnings <- NULL
[13:21:38.714]             }
[13:21:38.714]             base::options(...future.oldOptions)
[13:21:38.714]             if (.Platform$OS.type == "windows") {
[13:21:38.714]                 old_names <- names(...future.oldEnvVars)
[13:21:38.714]                 envs <- base::Sys.getenv()
[13:21:38.714]                 names <- names(envs)
[13:21:38.714]                 common <- intersect(names, old_names)
[13:21:38.714]                 added <- setdiff(names, old_names)
[13:21:38.714]                 removed <- setdiff(old_names, names)
[13:21:38.714]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:38.714]                   envs[common]]
[13:21:38.714]                 NAMES <- toupper(changed)
[13:21:38.714]                 args <- list()
[13:21:38.714]                 for (kk in seq_along(NAMES)) {
[13:21:38.714]                   name <- changed[[kk]]
[13:21:38.714]                   NAME <- NAMES[[kk]]
[13:21:38.714]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.714]                     next
[13:21:38.714]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:38.714]                 }
[13:21:38.714]                 NAMES <- toupper(added)
[13:21:38.714]                 for (kk in seq_along(NAMES)) {
[13:21:38.714]                   name <- added[[kk]]
[13:21:38.714]                   NAME <- NAMES[[kk]]
[13:21:38.714]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.714]                     next
[13:21:38.714]                   args[[name]] <- ""
[13:21:38.714]                 }
[13:21:38.714]                 NAMES <- toupper(removed)
[13:21:38.714]                 for (kk in seq_along(NAMES)) {
[13:21:38.714]                   name <- removed[[kk]]
[13:21:38.714]                   NAME <- NAMES[[kk]]
[13:21:38.714]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.714]                     next
[13:21:38.714]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:38.714]                 }
[13:21:38.714]                 if (length(args) > 0) 
[13:21:38.714]                   base::do.call(base::Sys.setenv, args = args)
[13:21:38.714]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:38.714]             }
[13:21:38.714]             else {
[13:21:38.714]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:38.714]             }
[13:21:38.714]             {
[13:21:38.714]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:38.714]                   0L) {
[13:21:38.714]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:38.714]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:38.714]                   base::options(opts)
[13:21:38.714]                 }
[13:21:38.714]                 {
[13:21:38.714]                   {
[13:21:38.714]                     NULL
[13:21:38.714]                     RNGkind("Mersenne-Twister")
[13:21:38.714]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:38.714]                       inherits = FALSE)
[13:21:38.714]                   }
[13:21:38.714]                   options(future.plan = NULL)
[13:21:38.714]                   if (is.na(NA_character_)) 
[13:21:38.714]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:38.714]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:38.714]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:38.714]                   {
[13:21:38.714]                     future <- SequentialFuture(..., envir = envir)
[13:21:38.714]                     if (!future$lazy) 
[13:21:38.714]                       future <- run(future)
[13:21:38.714]                     invisible(future)
[13:21:38.714]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:38.714]                 }
[13:21:38.714]             }
[13:21:38.714]         }
[13:21:38.714]     })
[13:21:38.714]     if (TRUE) {
[13:21:38.714]         base::sink(type = "output", split = FALSE)
[13:21:38.714]         if (TRUE) {
[13:21:38.714]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:38.714]         }
[13:21:38.714]         else {
[13:21:38.714]             ...future.result["stdout"] <- base::list(NULL)
[13:21:38.714]         }
[13:21:38.714]         base::close(...future.stdout)
[13:21:38.714]         ...future.stdout <- NULL
[13:21:38.714]     }
[13:21:38.714]     ...future.result$conditions <- ...future.conditions
[13:21:38.714]     ...future.result$finished <- base::Sys.time()
[13:21:38.714]     ...future.result
[13:21:38.714] }
[13:21:38.716] assign_globals() ...
[13:21:38.716] List of 1
[13:21:38.716]  $ kk: int 1
[13:21:38.716]  - attr(*, "where")=List of 1
[13:21:38.716]   ..$ kk:<environment: R_EmptyEnv> 
[13:21:38.716]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:38.716]  - attr(*, "resolved")= logi FALSE
[13:21:38.716]  - attr(*, "total_size")= num 56
[13:21:38.716]  - attr(*, "already-done")= logi TRUE
[13:21:38.721] - copied ‘kk’ to environment
[13:21:38.721] assign_globals() ... done
[13:21:38.721] plan(): Setting new future strategy stack:
[13:21:38.722] List of future strategies:
[13:21:38.722] 1. sequential:
[13:21:38.722]    - args: function (..., envir = parent.frame())
[13:21:38.722]    - tweaked: FALSE
[13:21:38.722]    - call: NULL
[13:21:38.722] plan(): nbrOfWorkers() = 1
[13:21:38.823] plan(): Setting new future strategy stack:
[13:21:38.823] List of future strategies:
[13:21:38.823] 1. sequential:
[13:21:38.823]    - args: function (..., envir = parent.frame())
[13:21:38.823]    - tweaked: FALSE
[13:21:38.823]    - call: plan(strategy)
[13:21:38.824] plan(): nbrOfWorkers() = 1
[13:21:38.826] SequentialFuture started (and completed)
[13:21:38.827] - Launch lazy future ... done
[13:21:38.827] run() for ‘SequentialFuture’ ... done
[13:21:38.827] getGlobalsAndPackages() ...
[13:21:38.827] Searching for globals...
[13:21:38.828] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:21:38.828] Searching for globals ... DONE
[13:21:38.828] Resolving globals: FALSE
[13:21:38.829] The total size of the 1 globals is 56 bytes (56 bytes)
[13:21:38.829] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:21:38.829] - globals: [1] ‘kk’
[13:21:38.829] 
[13:21:38.829] getGlobalsAndPackages() ... DONE
[13:21:38.830] run() for ‘Future’ ...
[13:21:38.830] - state: ‘created’
[13:21:38.830] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:38.830] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:38.830] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:38.830]   - Field: ‘label’
[13:21:38.831]   - Field: ‘local’
[13:21:38.831]   - Field: ‘owner’
[13:21:38.831]   - Field: ‘envir’
[13:21:38.831]   - Field: ‘packages’
[13:21:38.831]   - Field: ‘gc’
[13:21:38.831]   - Field: ‘conditions’
[13:21:38.831]   - Field: ‘expr’
[13:21:38.831]   - Field: ‘uuid’
[13:21:38.831]   - Field: ‘seed’
[13:21:38.831]   - Field: ‘version’
[13:21:38.831]   - Field: ‘result’
[13:21:38.832]   - Field: ‘asynchronous’
[13:21:38.832]   - Field: ‘calls’
[13:21:38.832]   - Field: ‘globals’
[13:21:38.832]   - Field: ‘stdout’
[13:21:38.832]   - Field: ‘earlySignal’
[13:21:38.832]   - Field: ‘lazy’
[13:21:38.832]   - Field: ‘state’
[13:21:38.832] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:38.832] - Launch lazy future ...
[13:21:38.833] Packages needed by the future expression (n = 0): <none>
[13:21:38.833] Packages needed by future strategies (n = 0): <none>
[13:21:38.833] {
[13:21:38.833]     {
[13:21:38.833]         {
[13:21:38.833]             ...future.startTime <- base::Sys.time()
[13:21:38.833]             {
[13:21:38.833]                 {
[13:21:38.833]                   {
[13:21:38.833]                     base::local({
[13:21:38.833]                       has_future <- base::requireNamespace("future", 
[13:21:38.833]                         quietly = TRUE)
[13:21:38.833]                       if (has_future) {
[13:21:38.833]                         ns <- base::getNamespace("future")
[13:21:38.833]                         version <- ns[[".package"]][["version"]]
[13:21:38.833]                         if (is.null(version)) 
[13:21:38.833]                           version <- utils::packageVersion("future")
[13:21:38.833]                       }
[13:21:38.833]                       else {
[13:21:38.833]                         version <- NULL
[13:21:38.833]                       }
[13:21:38.833]                       if (!has_future || version < "1.8.0") {
[13:21:38.833]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:38.833]                           "", base::R.version$version.string), 
[13:21:38.833]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:38.833]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:38.833]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:38.833]                             "release", "version")], collapse = " "), 
[13:21:38.833]                           hostname = base::Sys.info()[["nodename"]])
[13:21:38.833]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:38.833]                           info)
[13:21:38.833]                         info <- base::paste(info, collapse = "; ")
[13:21:38.833]                         if (!has_future) {
[13:21:38.833]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:38.833]                             info)
[13:21:38.833]                         }
[13:21:38.833]                         else {
[13:21:38.833]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:38.833]                             info, version)
[13:21:38.833]                         }
[13:21:38.833]                         base::stop(msg)
[13:21:38.833]                       }
[13:21:38.833]                     })
[13:21:38.833]                   }
[13:21:38.833]                   options(future.plan = NULL)
[13:21:38.833]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:38.833]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:38.833]                 }
[13:21:38.833]                 ...future.workdir <- getwd()
[13:21:38.833]             }
[13:21:38.833]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:38.833]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:38.833]         }
[13:21:38.833]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:38.833]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:38.833]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:38.833]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:38.833]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:38.833]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:38.833]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:38.833]             base::names(...future.oldOptions))
[13:21:38.833]     }
[13:21:38.833]     if (FALSE) {
[13:21:38.833]     }
[13:21:38.833]     else {
[13:21:38.833]         if (TRUE) {
[13:21:38.833]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:38.833]                 open = "w")
[13:21:38.833]         }
[13:21:38.833]         else {
[13:21:38.833]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:38.833]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:38.833]         }
[13:21:38.833]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:38.833]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:38.833]             base::sink(type = "output", split = FALSE)
[13:21:38.833]             base::close(...future.stdout)
[13:21:38.833]         }, add = TRUE)
[13:21:38.833]     }
[13:21:38.833]     ...future.frame <- base::sys.nframe()
[13:21:38.833]     ...future.conditions <- base::list()
[13:21:38.833]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:38.833]     if (FALSE) {
[13:21:38.833]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:38.833]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:38.833]     }
[13:21:38.833]     ...future.result <- base::tryCatch({
[13:21:38.833]         base::withCallingHandlers({
[13:21:38.833]             ...future.value <- base::withVisible(base::local({
[13:21:38.833]                 Sys.sleep(0.1)
[13:21:38.833]                 kk
[13:21:38.833]             }))
[13:21:38.833]             future::FutureResult(value = ...future.value$value, 
[13:21:38.833]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:38.833]                   ...future.rng), globalenv = if (FALSE) 
[13:21:38.833]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:38.833]                     ...future.globalenv.names))
[13:21:38.833]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:38.833]         }, condition = base::local({
[13:21:38.833]             c <- base::c
[13:21:38.833]             inherits <- base::inherits
[13:21:38.833]             invokeRestart <- base::invokeRestart
[13:21:38.833]             length <- base::length
[13:21:38.833]             list <- base::list
[13:21:38.833]             seq.int <- base::seq.int
[13:21:38.833]             signalCondition <- base::signalCondition
[13:21:38.833]             sys.calls <- base::sys.calls
[13:21:38.833]             `[[` <- base::`[[`
[13:21:38.833]             `+` <- base::`+`
[13:21:38.833]             `<<-` <- base::`<<-`
[13:21:38.833]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:38.833]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:38.833]                   3L)]
[13:21:38.833]             }
[13:21:38.833]             function(cond) {
[13:21:38.833]                 is_error <- inherits(cond, "error")
[13:21:38.833]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:38.833]                   NULL)
[13:21:38.833]                 if (is_error) {
[13:21:38.833]                   sessionInformation <- function() {
[13:21:38.833]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:38.833]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:38.833]                       search = base::search(), system = base::Sys.info())
[13:21:38.833]                   }
[13:21:38.833]                   ...future.conditions[[length(...future.conditions) + 
[13:21:38.833]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:38.833]                     cond$call), session = sessionInformation(), 
[13:21:38.833]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:38.833]                   signalCondition(cond)
[13:21:38.833]                 }
[13:21:38.833]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:38.833]                 "immediateCondition"))) {
[13:21:38.833]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:38.833]                   ...future.conditions[[length(...future.conditions) + 
[13:21:38.833]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:38.833]                   if (TRUE && !signal) {
[13:21:38.833]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:38.833]                     {
[13:21:38.833]                       inherits <- base::inherits
[13:21:38.833]                       invokeRestart <- base::invokeRestart
[13:21:38.833]                       is.null <- base::is.null
[13:21:38.833]                       muffled <- FALSE
[13:21:38.833]                       if (inherits(cond, "message")) {
[13:21:38.833]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:38.833]                         if (muffled) 
[13:21:38.833]                           invokeRestart("muffleMessage")
[13:21:38.833]                       }
[13:21:38.833]                       else if (inherits(cond, "warning")) {
[13:21:38.833]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:38.833]                         if (muffled) 
[13:21:38.833]                           invokeRestart("muffleWarning")
[13:21:38.833]                       }
[13:21:38.833]                       else if (inherits(cond, "condition")) {
[13:21:38.833]                         if (!is.null(pattern)) {
[13:21:38.833]                           computeRestarts <- base::computeRestarts
[13:21:38.833]                           grepl <- base::grepl
[13:21:38.833]                           restarts <- computeRestarts(cond)
[13:21:38.833]                           for (restart in restarts) {
[13:21:38.833]                             name <- restart$name
[13:21:38.833]                             if (is.null(name)) 
[13:21:38.833]                               next
[13:21:38.833]                             if (!grepl(pattern, name)) 
[13:21:38.833]                               next
[13:21:38.833]                             invokeRestart(restart)
[13:21:38.833]                             muffled <- TRUE
[13:21:38.833]                             break
[13:21:38.833]                           }
[13:21:38.833]                         }
[13:21:38.833]                       }
[13:21:38.833]                       invisible(muffled)
[13:21:38.833]                     }
[13:21:38.833]                     muffleCondition(cond, pattern = "^muffle")
[13:21:38.833]                   }
[13:21:38.833]                 }
[13:21:38.833]                 else {
[13:21:38.833]                   if (TRUE) {
[13:21:38.833]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:38.833]                     {
[13:21:38.833]                       inherits <- base::inherits
[13:21:38.833]                       invokeRestart <- base::invokeRestart
[13:21:38.833]                       is.null <- base::is.null
[13:21:38.833]                       muffled <- FALSE
[13:21:38.833]                       if (inherits(cond, "message")) {
[13:21:38.833]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:38.833]                         if (muffled) 
[13:21:38.833]                           invokeRestart("muffleMessage")
[13:21:38.833]                       }
[13:21:38.833]                       else if (inherits(cond, "warning")) {
[13:21:38.833]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:38.833]                         if (muffled) 
[13:21:38.833]                           invokeRestart("muffleWarning")
[13:21:38.833]                       }
[13:21:38.833]                       else if (inherits(cond, "condition")) {
[13:21:38.833]                         if (!is.null(pattern)) {
[13:21:38.833]                           computeRestarts <- base::computeRestarts
[13:21:38.833]                           grepl <- base::grepl
[13:21:38.833]                           restarts <- computeRestarts(cond)
[13:21:38.833]                           for (restart in restarts) {
[13:21:38.833]                             name <- restart$name
[13:21:38.833]                             if (is.null(name)) 
[13:21:38.833]                               next
[13:21:38.833]                             if (!grepl(pattern, name)) 
[13:21:38.833]                               next
[13:21:38.833]                             invokeRestart(restart)
[13:21:38.833]                             muffled <- TRUE
[13:21:38.833]                             break
[13:21:38.833]                           }
[13:21:38.833]                         }
[13:21:38.833]                       }
[13:21:38.833]                       invisible(muffled)
[13:21:38.833]                     }
[13:21:38.833]                     muffleCondition(cond, pattern = "^muffle")
[13:21:38.833]                   }
[13:21:38.833]                 }
[13:21:38.833]             }
[13:21:38.833]         }))
[13:21:38.833]     }, error = function(ex) {
[13:21:38.833]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:38.833]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:38.833]                 ...future.rng), started = ...future.startTime, 
[13:21:38.833]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:38.833]             version = "1.8"), class = "FutureResult")
[13:21:38.833]     }, finally = {
[13:21:38.833]         if (!identical(...future.workdir, getwd())) 
[13:21:38.833]             setwd(...future.workdir)
[13:21:38.833]         {
[13:21:38.833]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:38.833]                 ...future.oldOptions$nwarnings <- NULL
[13:21:38.833]             }
[13:21:38.833]             base::options(...future.oldOptions)
[13:21:38.833]             if (.Platform$OS.type == "windows") {
[13:21:38.833]                 old_names <- names(...future.oldEnvVars)
[13:21:38.833]                 envs <- base::Sys.getenv()
[13:21:38.833]                 names <- names(envs)
[13:21:38.833]                 common <- intersect(names, old_names)
[13:21:38.833]                 added <- setdiff(names, old_names)
[13:21:38.833]                 removed <- setdiff(old_names, names)
[13:21:38.833]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:38.833]                   envs[common]]
[13:21:38.833]                 NAMES <- toupper(changed)
[13:21:38.833]                 args <- list()
[13:21:38.833]                 for (kk in seq_along(NAMES)) {
[13:21:38.833]                   name <- changed[[kk]]
[13:21:38.833]                   NAME <- NAMES[[kk]]
[13:21:38.833]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.833]                     next
[13:21:38.833]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:38.833]                 }
[13:21:38.833]                 NAMES <- toupper(added)
[13:21:38.833]                 for (kk in seq_along(NAMES)) {
[13:21:38.833]                   name <- added[[kk]]
[13:21:38.833]                   NAME <- NAMES[[kk]]
[13:21:38.833]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.833]                     next
[13:21:38.833]                   args[[name]] <- ""
[13:21:38.833]                 }
[13:21:38.833]                 NAMES <- toupper(removed)
[13:21:38.833]                 for (kk in seq_along(NAMES)) {
[13:21:38.833]                   name <- removed[[kk]]
[13:21:38.833]                   NAME <- NAMES[[kk]]
[13:21:38.833]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.833]                     next
[13:21:38.833]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:38.833]                 }
[13:21:38.833]                 if (length(args) > 0) 
[13:21:38.833]                   base::do.call(base::Sys.setenv, args = args)
[13:21:38.833]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:38.833]             }
[13:21:38.833]             else {
[13:21:38.833]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:38.833]             }
[13:21:38.833]             {
[13:21:38.833]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:38.833]                   0L) {
[13:21:38.833]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:38.833]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:38.833]                   base::options(opts)
[13:21:38.833]                 }
[13:21:38.833]                 {
[13:21:38.833]                   {
[13:21:38.833]                     NULL
[13:21:38.833]                     RNGkind("Mersenne-Twister")
[13:21:38.833]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:38.833]                       inherits = FALSE)
[13:21:38.833]                   }
[13:21:38.833]                   options(future.plan = NULL)
[13:21:38.833]                   if (is.na(NA_character_)) 
[13:21:38.833]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:38.833]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:38.833]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:38.833]                   {
[13:21:38.833]                     future <- SequentialFuture(..., envir = envir)
[13:21:38.833]                     if (!future$lazy) 
[13:21:38.833]                       future <- run(future)
[13:21:38.833]                     invisible(future)
[13:21:38.833]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:38.833]                 }
[13:21:38.833]             }
[13:21:38.833]         }
[13:21:38.833]     })
[13:21:38.833]     if (TRUE) {
[13:21:38.833]         base::sink(type = "output", split = FALSE)
[13:21:38.833]         if (TRUE) {
[13:21:38.833]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:38.833]         }
[13:21:38.833]         else {
[13:21:38.833]             ...future.result["stdout"] <- base::list(NULL)
[13:21:38.833]         }
[13:21:38.833]         base::close(...future.stdout)
[13:21:38.833]         ...future.stdout <- NULL
[13:21:38.833]     }
[13:21:38.833]     ...future.result$conditions <- ...future.conditions
[13:21:38.833]     ...future.result$finished <- base::Sys.time()
[13:21:38.833]     ...future.result
[13:21:38.833] }
[13:21:38.835] assign_globals() ...
[13:21:38.835] List of 1
[13:21:38.835]  $ kk: int 2
[13:21:38.835]  - attr(*, "where")=List of 1
[13:21:38.835]   ..$ kk:<environment: R_EmptyEnv> 
[13:21:38.835]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:38.835]  - attr(*, "resolved")= logi FALSE
[13:21:38.835]  - attr(*, "total_size")= num 56
[13:21:38.835]  - attr(*, "already-done")= logi TRUE
[13:21:38.837] - copied ‘kk’ to environment
[13:21:38.838] assign_globals() ... done
[13:21:38.838] plan(): Setting new future strategy stack:
[13:21:38.838] List of future strategies:
[13:21:38.838] 1. sequential:
[13:21:38.838]    - args: function (..., envir = parent.frame())
[13:21:38.838]    - tweaked: FALSE
[13:21:38.838]    - call: NULL
[13:21:38.838] plan(): nbrOfWorkers() = 1
[13:21:38.939] plan(): Setting new future strategy stack:
[13:21:38.940] List of future strategies:
[13:21:38.940] 1. sequential:
[13:21:38.940]    - args: function (..., envir = parent.frame())
[13:21:38.940]    - tweaked: FALSE
[13:21:38.940]    - call: plan(strategy)
[13:21:38.940] plan(): nbrOfWorkers() = 1
[13:21:38.940] SequentialFuture started (and completed)
[13:21:38.940] - Launch lazy future ... done
[13:21:38.941] run() for ‘SequentialFuture’ ... done
[13:21:38.941] getGlobalsAndPackages() ...
[13:21:38.941] Searching for globals...
[13:21:38.942] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:21:38.942] Searching for globals ... DONE
[13:21:38.942] Resolving globals: FALSE
[13:21:38.943] The total size of the 1 globals is 56 bytes (56 bytes)
[13:21:38.943] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:21:38.943] - globals: [1] ‘kk’
[13:21:38.943] 
[13:21:38.943] getGlobalsAndPackages() ... DONE
[13:21:38.943] run() for ‘Future’ ...
[13:21:38.944] - state: ‘created’
[13:21:38.944] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:38.944] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:38.944] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:38.944]   - Field: ‘label’
[13:21:38.944]   - Field: ‘local’
[13:21:38.944]   - Field: ‘owner’
[13:21:38.944]   - Field: ‘envir’
[13:21:38.945]   - Field: ‘packages’
[13:21:38.945]   - Field: ‘gc’
[13:21:38.945]   - Field: ‘conditions’
[13:21:38.945]   - Field: ‘expr’
[13:21:38.945]   - Field: ‘uuid’
[13:21:38.945]   - Field: ‘seed’
[13:21:38.945]   - Field: ‘version’
[13:21:38.945]   - Field: ‘result’
[13:21:38.945]   - Field: ‘asynchronous’
[13:21:38.945]   - Field: ‘calls’
[13:21:38.945]   - Field: ‘globals’
[13:21:38.946]   - Field: ‘stdout’
[13:21:38.946]   - Field: ‘earlySignal’
[13:21:38.946]   - Field: ‘lazy’
[13:21:38.946]   - Field: ‘state’
[13:21:38.946] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:38.946] - Launch lazy future ...
[13:21:38.946] Packages needed by the future expression (n = 0): <none>
[13:21:38.946] Packages needed by future strategies (n = 0): <none>
[13:21:38.947] {
[13:21:38.947]     {
[13:21:38.947]         {
[13:21:38.947]             ...future.startTime <- base::Sys.time()
[13:21:38.947]             {
[13:21:38.947]                 {
[13:21:38.947]                   {
[13:21:38.947]                     base::local({
[13:21:38.947]                       has_future <- base::requireNamespace("future", 
[13:21:38.947]                         quietly = TRUE)
[13:21:38.947]                       if (has_future) {
[13:21:38.947]                         ns <- base::getNamespace("future")
[13:21:38.947]                         version <- ns[[".package"]][["version"]]
[13:21:38.947]                         if (is.null(version)) 
[13:21:38.947]                           version <- utils::packageVersion("future")
[13:21:38.947]                       }
[13:21:38.947]                       else {
[13:21:38.947]                         version <- NULL
[13:21:38.947]                       }
[13:21:38.947]                       if (!has_future || version < "1.8.0") {
[13:21:38.947]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:38.947]                           "", base::R.version$version.string), 
[13:21:38.947]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:38.947]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:38.947]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:38.947]                             "release", "version")], collapse = " "), 
[13:21:38.947]                           hostname = base::Sys.info()[["nodename"]])
[13:21:38.947]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:38.947]                           info)
[13:21:38.947]                         info <- base::paste(info, collapse = "; ")
[13:21:38.947]                         if (!has_future) {
[13:21:38.947]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:38.947]                             info)
[13:21:38.947]                         }
[13:21:38.947]                         else {
[13:21:38.947]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:38.947]                             info, version)
[13:21:38.947]                         }
[13:21:38.947]                         base::stop(msg)
[13:21:38.947]                       }
[13:21:38.947]                     })
[13:21:38.947]                   }
[13:21:38.947]                   options(future.plan = NULL)
[13:21:38.947]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:38.947]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:38.947]                 }
[13:21:38.947]                 ...future.workdir <- getwd()
[13:21:38.947]             }
[13:21:38.947]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:38.947]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:38.947]         }
[13:21:38.947]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:38.947]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:38.947]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:38.947]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:38.947]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:38.947]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:38.947]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:38.947]             base::names(...future.oldOptions))
[13:21:38.947]     }
[13:21:38.947]     if (FALSE) {
[13:21:38.947]     }
[13:21:38.947]     else {
[13:21:38.947]         if (TRUE) {
[13:21:38.947]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:38.947]                 open = "w")
[13:21:38.947]         }
[13:21:38.947]         else {
[13:21:38.947]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:38.947]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:38.947]         }
[13:21:38.947]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:38.947]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:38.947]             base::sink(type = "output", split = FALSE)
[13:21:38.947]             base::close(...future.stdout)
[13:21:38.947]         }, add = TRUE)
[13:21:38.947]     }
[13:21:38.947]     ...future.frame <- base::sys.nframe()
[13:21:38.947]     ...future.conditions <- base::list()
[13:21:38.947]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:38.947]     if (FALSE) {
[13:21:38.947]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:38.947]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:38.947]     }
[13:21:38.947]     ...future.result <- base::tryCatch({
[13:21:38.947]         base::withCallingHandlers({
[13:21:38.947]             ...future.value <- base::withVisible(base::local({
[13:21:38.947]                 Sys.sleep(0.1)
[13:21:38.947]                 kk
[13:21:38.947]             }))
[13:21:38.947]             future::FutureResult(value = ...future.value$value, 
[13:21:38.947]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:38.947]                   ...future.rng), globalenv = if (FALSE) 
[13:21:38.947]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:38.947]                     ...future.globalenv.names))
[13:21:38.947]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:38.947]         }, condition = base::local({
[13:21:38.947]             c <- base::c
[13:21:38.947]             inherits <- base::inherits
[13:21:38.947]             invokeRestart <- base::invokeRestart
[13:21:38.947]             length <- base::length
[13:21:38.947]             list <- base::list
[13:21:38.947]             seq.int <- base::seq.int
[13:21:38.947]             signalCondition <- base::signalCondition
[13:21:38.947]             sys.calls <- base::sys.calls
[13:21:38.947]             `[[` <- base::`[[`
[13:21:38.947]             `+` <- base::`+`
[13:21:38.947]             `<<-` <- base::`<<-`
[13:21:38.947]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:38.947]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:38.947]                   3L)]
[13:21:38.947]             }
[13:21:38.947]             function(cond) {
[13:21:38.947]                 is_error <- inherits(cond, "error")
[13:21:38.947]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:38.947]                   NULL)
[13:21:38.947]                 if (is_error) {
[13:21:38.947]                   sessionInformation <- function() {
[13:21:38.947]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:38.947]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:38.947]                       search = base::search(), system = base::Sys.info())
[13:21:38.947]                   }
[13:21:38.947]                   ...future.conditions[[length(...future.conditions) + 
[13:21:38.947]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:38.947]                     cond$call), session = sessionInformation(), 
[13:21:38.947]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:38.947]                   signalCondition(cond)
[13:21:38.947]                 }
[13:21:38.947]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:38.947]                 "immediateCondition"))) {
[13:21:38.947]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:38.947]                   ...future.conditions[[length(...future.conditions) + 
[13:21:38.947]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:38.947]                   if (TRUE && !signal) {
[13:21:38.947]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:38.947]                     {
[13:21:38.947]                       inherits <- base::inherits
[13:21:38.947]                       invokeRestart <- base::invokeRestart
[13:21:38.947]                       is.null <- base::is.null
[13:21:38.947]                       muffled <- FALSE
[13:21:38.947]                       if (inherits(cond, "message")) {
[13:21:38.947]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:38.947]                         if (muffled) 
[13:21:38.947]                           invokeRestart("muffleMessage")
[13:21:38.947]                       }
[13:21:38.947]                       else if (inherits(cond, "warning")) {
[13:21:38.947]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:38.947]                         if (muffled) 
[13:21:38.947]                           invokeRestart("muffleWarning")
[13:21:38.947]                       }
[13:21:38.947]                       else if (inherits(cond, "condition")) {
[13:21:38.947]                         if (!is.null(pattern)) {
[13:21:38.947]                           computeRestarts <- base::computeRestarts
[13:21:38.947]                           grepl <- base::grepl
[13:21:38.947]                           restarts <- computeRestarts(cond)
[13:21:38.947]                           for (restart in restarts) {
[13:21:38.947]                             name <- restart$name
[13:21:38.947]                             if (is.null(name)) 
[13:21:38.947]                               next
[13:21:38.947]                             if (!grepl(pattern, name)) 
[13:21:38.947]                               next
[13:21:38.947]                             invokeRestart(restart)
[13:21:38.947]                             muffled <- TRUE
[13:21:38.947]                             break
[13:21:38.947]                           }
[13:21:38.947]                         }
[13:21:38.947]                       }
[13:21:38.947]                       invisible(muffled)
[13:21:38.947]                     }
[13:21:38.947]                     muffleCondition(cond, pattern = "^muffle")
[13:21:38.947]                   }
[13:21:38.947]                 }
[13:21:38.947]                 else {
[13:21:38.947]                   if (TRUE) {
[13:21:38.947]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:38.947]                     {
[13:21:38.947]                       inherits <- base::inherits
[13:21:38.947]                       invokeRestart <- base::invokeRestart
[13:21:38.947]                       is.null <- base::is.null
[13:21:38.947]                       muffled <- FALSE
[13:21:38.947]                       if (inherits(cond, "message")) {
[13:21:38.947]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:38.947]                         if (muffled) 
[13:21:38.947]                           invokeRestart("muffleMessage")
[13:21:38.947]                       }
[13:21:38.947]                       else if (inherits(cond, "warning")) {
[13:21:38.947]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:38.947]                         if (muffled) 
[13:21:38.947]                           invokeRestart("muffleWarning")
[13:21:38.947]                       }
[13:21:38.947]                       else if (inherits(cond, "condition")) {
[13:21:38.947]                         if (!is.null(pattern)) {
[13:21:38.947]                           computeRestarts <- base::computeRestarts
[13:21:38.947]                           grepl <- base::grepl
[13:21:38.947]                           restarts <- computeRestarts(cond)
[13:21:38.947]                           for (restart in restarts) {
[13:21:38.947]                             name <- restart$name
[13:21:38.947]                             if (is.null(name)) 
[13:21:38.947]                               next
[13:21:38.947]                             if (!grepl(pattern, name)) 
[13:21:38.947]                               next
[13:21:38.947]                             invokeRestart(restart)
[13:21:38.947]                             muffled <- TRUE
[13:21:38.947]                             break
[13:21:38.947]                           }
[13:21:38.947]                         }
[13:21:38.947]                       }
[13:21:38.947]                       invisible(muffled)
[13:21:38.947]                     }
[13:21:38.947]                     muffleCondition(cond, pattern = "^muffle")
[13:21:38.947]                   }
[13:21:38.947]                 }
[13:21:38.947]             }
[13:21:38.947]         }))
[13:21:38.947]     }, error = function(ex) {
[13:21:38.947]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:38.947]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:38.947]                 ...future.rng), started = ...future.startTime, 
[13:21:38.947]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:38.947]             version = "1.8"), class = "FutureResult")
[13:21:38.947]     }, finally = {
[13:21:38.947]         if (!identical(...future.workdir, getwd())) 
[13:21:38.947]             setwd(...future.workdir)
[13:21:38.947]         {
[13:21:38.947]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:38.947]                 ...future.oldOptions$nwarnings <- NULL
[13:21:38.947]             }
[13:21:38.947]             base::options(...future.oldOptions)
[13:21:38.947]             if (.Platform$OS.type == "windows") {
[13:21:38.947]                 old_names <- names(...future.oldEnvVars)
[13:21:38.947]                 envs <- base::Sys.getenv()
[13:21:38.947]                 names <- names(envs)
[13:21:38.947]                 common <- intersect(names, old_names)
[13:21:38.947]                 added <- setdiff(names, old_names)
[13:21:38.947]                 removed <- setdiff(old_names, names)
[13:21:38.947]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:38.947]                   envs[common]]
[13:21:38.947]                 NAMES <- toupper(changed)
[13:21:38.947]                 args <- list()
[13:21:38.947]                 for (kk in seq_along(NAMES)) {
[13:21:38.947]                   name <- changed[[kk]]
[13:21:38.947]                   NAME <- NAMES[[kk]]
[13:21:38.947]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.947]                     next
[13:21:38.947]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:38.947]                 }
[13:21:38.947]                 NAMES <- toupper(added)
[13:21:38.947]                 for (kk in seq_along(NAMES)) {
[13:21:38.947]                   name <- added[[kk]]
[13:21:38.947]                   NAME <- NAMES[[kk]]
[13:21:38.947]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.947]                     next
[13:21:38.947]                   args[[name]] <- ""
[13:21:38.947]                 }
[13:21:38.947]                 NAMES <- toupper(removed)
[13:21:38.947]                 for (kk in seq_along(NAMES)) {
[13:21:38.947]                   name <- removed[[kk]]
[13:21:38.947]                   NAME <- NAMES[[kk]]
[13:21:38.947]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:38.947]                     next
[13:21:38.947]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:38.947]                 }
[13:21:38.947]                 if (length(args) > 0) 
[13:21:38.947]                   base::do.call(base::Sys.setenv, args = args)
[13:21:38.947]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:38.947]             }
[13:21:38.947]             else {
[13:21:38.947]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:38.947]             }
[13:21:38.947]             {
[13:21:38.947]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:38.947]                   0L) {
[13:21:38.947]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:38.947]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:38.947]                   base::options(opts)
[13:21:38.947]                 }
[13:21:38.947]                 {
[13:21:38.947]                   {
[13:21:38.947]                     NULL
[13:21:38.947]                     RNGkind("Mersenne-Twister")
[13:21:38.947]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:38.947]                       inherits = FALSE)
[13:21:38.947]                   }
[13:21:38.947]                   options(future.plan = NULL)
[13:21:38.947]                   if (is.na(NA_character_)) 
[13:21:38.947]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:38.947]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:38.947]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:38.947]                   {
[13:21:38.947]                     future <- SequentialFuture(..., envir = envir)
[13:21:38.947]                     if (!future$lazy) 
[13:21:38.947]                       future <- run(future)
[13:21:38.947]                     invisible(future)
[13:21:38.947]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:38.947]                 }
[13:21:38.947]             }
[13:21:38.947]         }
[13:21:38.947]     })
[13:21:38.947]     if (TRUE) {
[13:21:38.947]         base::sink(type = "output", split = FALSE)
[13:21:38.947]         if (TRUE) {
[13:21:38.947]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:38.947]         }
[13:21:38.947]         else {
[13:21:38.947]             ...future.result["stdout"] <- base::list(NULL)
[13:21:38.947]         }
[13:21:38.947]         base::close(...future.stdout)
[13:21:38.947]         ...future.stdout <- NULL
[13:21:38.947]     }
[13:21:38.947]     ...future.result$conditions <- ...future.conditions
[13:21:38.947]     ...future.result$finished <- base::Sys.time()
[13:21:38.947]     ...future.result
[13:21:38.947] }
[13:21:38.948] assign_globals() ...
[13:21:38.949] List of 1
[13:21:38.949]  $ kk: int 3
[13:21:38.949]  - attr(*, "where")=List of 1
[13:21:38.949]   ..$ kk:<environment: R_EmptyEnv> 
[13:21:38.949]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:38.949]  - attr(*, "resolved")= logi FALSE
[13:21:38.949]  - attr(*, "total_size")= num 56
[13:21:38.949]  - attr(*, "already-done")= logi TRUE
[13:21:38.951] - copied ‘kk’ to environment
[13:21:38.951] assign_globals() ... done
[13:21:38.951] plan(): Setting new future strategy stack:
[13:21:38.952] List of future strategies:
[13:21:38.952] 1. sequential:
[13:21:38.952]    - args: function (..., envir = parent.frame())
[13:21:38.952]    - tweaked: FALSE
[13:21:38.952]    - call: NULL
[13:21:38.952] plan(): nbrOfWorkers() = 1
[13:21:39.053] plan(): Setting new future strategy stack:
[13:21:39.053] List of future strategies:
[13:21:39.053] 1. sequential:
[13:21:39.053]    - args: function (..., envir = parent.frame())
[13:21:39.053]    - tweaked: FALSE
[13:21:39.053]    - call: plan(strategy)
[13:21:39.054] plan(): nbrOfWorkers() = 1
[13:21:39.054] SequentialFuture started (and completed)
[13:21:39.054] - Launch lazy future ... done
[13:21:39.054] run() for ‘SequentialFuture’ ... done
[13:21:39.054] resolve() on list ...
[13:21:39.054]  recursive: 0
[13:21:39.054]  length: 3
[13:21:39.055] 
[13:21:39.055] resolved() for ‘SequentialFuture’ ...
[13:21:39.055] - state: ‘finished’
[13:21:39.055] - run: TRUE
[13:21:39.055] - result: ‘FutureResult’
[13:21:39.055] resolved() for ‘SequentialFuture’ ... done
[13:21:39.055] Future #1
[13:21:39.055]  length: 2 (resolved future 1)
[13:21:39.055] resolved() for ‘SequentialFuture’ ...
[13:21:39.055] - state: ‘finished’
[13:21:39.055] - run: TRUE
[13:21:39.056] - result: ‘FutureResult’
[13:21:39.056] resolved() for ‘SequentialFuture’ ... done
[13:21:39.056] Future #2
[13:21:39.058]  length: 1 (resolved future 2)
[13:21:39.058] resolved() for ‘SequentialFuture’ ...
[13:21:39.058] - state: ‘finished’
[13:21:39.058] - run: TRUE
[13:21:39.058] - result: ‘FutureResult’
[13:21:39.058] resolved() for ‘SequentialFuture’ ... done
[13:21:39.058] Future #3
[13:21:39.058]  length: 0 (resolved future 3)
[13:21:39.058] resolve() on list ... DONE
[13:21:39.058] getGlobalsAndPackages() ...
[13:21:39.058] Searching for globals...
[13:21:39.060] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:21:39.060] Searching for globals ... DONE
[13:21:39.060] Resolving globals: FALSE
[13:21:39.060] The total size of the 1 globals is 56 bytes (56 bytes)
[13:21:39.060] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:21:39.061] - globals: [1] ‘kk’
[13:21:39.061] 
[13:21:39.061] getGlobalsAndPackages() ... DONE
[13:21:39.061] getGlobalsAndPackages() ...
[13:21:39.061] Searching for globals...
[13:21:39.062] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:21:39.062] Searching for globals ... DONE
[13:21:39.062] Resolving globals: FALSE
[13:21:39.063] The total size of the 1 globals is 56 bytes (56 bytes)
[13:21:39.063] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:21:39.063] - globals: [1] ‘kk’
[13:21:39.063] 
[13:21:39.063] getGlobalsAndPackages() ... DONE
[13:21:39.063] getGlobalsAndPackages() ...
[13:21:39.064] Searching for globals...
[13:21:39.064] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:21:39.065] Searching for globals ... DONE
[13:21:39.065] Resolving globals: FALSE
[13:21:39.065] The total size of the 1 globals is 56 bytes (56 bytes)
[13:21:39.065] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:21:39.065] - globals: [1] ‘kk’
[13:21:39.065] 
[13:21:39.066] getGlobalsAndPackages() ... DONE
[13:21:39.066] resolve() on list ...
[13:21:39.066]  recursive: 0
[13:21:39.066]  length: 3
[13:21:39.066] 
[13:21:39.066] run() for ‘Future’ ...
[13:21:39.066] - state: ‘created’
[13:21:39.066] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:39.067] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:39.067] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:39.067]   - Field: ‘label’
[13:21:39.067]   - Field: ‘local’
[13:21:39.067]   - Field: ‘owner’
[13:21:39.067]   - Field: ‘envir’
[13:21:39.067]   - Field: ‘packages’
[13:21:39.067]   - Field: ‘gc’
[13:21:39.067]   - Field: ‘conditions’
[13:21:39.067]   - Field: ‘expr’
[13:21:39.068]   - Field: ‘uuid’
[13:21:39.068]   - Field: ‘seed’
[13:21:39.068]   - Field: ‘version’
[13:21:39.068]   - Field: ‘result’
[13:21:39.068]   - Field: ‘asynchronous’
[13:21:39.068]   - Field: ‘calls’
[13:21:39.068]   - Field: ‘globals’
[13:21:39.068]   - Field: ‘stdout’
[13:21:39.068]   - Field: ‘earlySignal’
[13:21:39.068]   - Field: ‘lazy’
[13:21:39.068]   - Field: ‘state’
[13:21:39.069] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:39.069] - Launch lazy future ...
[13:21:39.069] Packages needed by the future expression (n = 0): <none>
[13:21:39.069] Packages needed by future strategies (n = 0): <none>
[13:21:39.069] {
[13:21:39.069]     {
[13:21:39.069]         {
[13:21:39.069]             ...future.startTime <- base::Sys.time()
[13:21:39.069]             {
[13:21:39.069]                 {
[13:21:39.069]                   {
[13:21:39.069]                     base::local({
[13:21:39.069]                       has_future <- base::requireNamespace("future", 
[13:21:39.069]                         quietly = TRUE)
[13:21:39.069]                       if (has_future) {
[13:21:39.069]                         ns <- base::getNamespace("future")
[13:21:39.069]                         version <- ns[[".package"]][["version"]]
[13:21:39.069]                         if (is.null(version)) 
[13:21:39.069]                           version <- utils::packageVersion("future")
[13:21:39.069]                       }
[13:21:39.069]                       else {
[13:21:39.069]                         version <- NULL
[13:21:39.069]                       }
[13:21:39.069]                       if (!has_future || version < "1.8.0") {
[13:21:39.069]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:39.069]                           "", base::R.version$version.string), 
[13:21:39.069]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:39.069]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:39.069]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:39.069]                             "release", "version")], collapse = " "), 
[13:21:39.069]                           hostname = base::Sys.info()[["nodename"]])
[13:21:39.069]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:39.069]                           info)
[13:21:39.069]                         info <- base::paste(info, collapse = "; ")
[13:21:39.069]                         if (!has_future) {
[13:21:39.069]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:39.069]                             info)
[13:21:39.069]                         }
[13:21:39.069]                         else {
[13:21:39.069]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:39.069]                             info, version)
[13:21:39.069]                         }
[13:21:39.069]                         base::stop(msg)
[13:21:39.069]                       }
[13:21:39.069]                     })
[13:21:39.069]                   }
[13:21:39.069]                   options(future.plan = NULL)
[13:21:39.069]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:39.069]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:39.069]                 }
[13:21:39.069]                 ...future.workdir <- getwd()
[13:21:39.069]             }
[13:21:39.069]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:39.069]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:39.069]         }
[13:21:39.069]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:39.069]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:39.069]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:39.069]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:39.069]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:39.069]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:39.069]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:39.069]             base::names(...future.oldOptions))
[13:21:39.069]     }
[13:21:39.069]     if (FALSE) {
[13:21:39.069]     }
[13:21:39.069]     else {
[13:21:39.069]         if (TRUE) {
[13:21:39.069]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:39.069]                 open = "w")
[13:21:39.069]         }
[13:21:39.069]         else {
[13:21:39.069]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:39.069]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:39.069]         }
[13:21:39.069]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:39.069]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:39.069]             base::sink(type = "output", split = FALSE)
[13:21:39.069]             base::close(...future.stdout)
[13:21:39.069]         }, add = TRUE)
[13:21:39.069]     }
[13:21:39.069]     ...future.frame <- base::sys.nframe()
[13:21:39.069]     ...future.conditions <- base::list()
[13:21:39.069]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:39.069]     if (FALSE) {
[13:21:39.069]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:39.069]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:39.069]     }
[13:21:39.069]     ...future.result <- base::tryCatch({
[13:21:39.069]         base::withCallingHandlers({
[13:21:39.069]             ...future.value <- base::withVisible(base::local({
[13:21:39.069]                 Sys.sleep(0.1)
[13:21:39.069]                 kk
[13:21:39.069]             }))
[13:21:39.069]             future::FutureResult(value = ...future.value$value, 
[13:21:39.069]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:39.069]                   ...future.rng), globalenv = if (FALSE) 
[13:21:39.069]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:39.069]                     ...future.globalenv.names))
[13:21:39.069]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:39.069]         }, condition = base::local({
[13:21:39.069]             c <- base::c
[13:21:39.069]             inherits <- base::inherits
[13:21:39.069]             invokeRestart <- base::invokeRestart
[13:21:39.069]             length <- base::length
[13:21:39.069]             list <- base::list
[13:21:39.069]             seq.int <- base::seq.int
[13:21:39.069]             signalCondition <- base::signalCondition
[13:21:39.069]             sys.calls <- base::sys.calls
[13:21:39.069]             `[[` <- base::`[[`
[13:21:39.069]             `+` <- base::`+`
[13:21:39.069]             `<<-` <- base::`<<-`
[13:21:39.069]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:39.069]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:39.069]                   3L)]
[13:21:39.069]             }
[13:21:39.069]             function(cond) {
[13:21:39.069]                 is_error <- inherits(cond, "error")
[13:21:39.069]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:39.069]                   NULL)
[13:21:39.069]                 if (is_error) {
[13:21:39.069]                   sessionInformation <- function() {
[13:21:39.069]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:39.069]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:39.069]                       search = base::search(), system = base::Sys.info())
[13:21:39.069]                   }
[13:21:39.069]                   ...future.conditions[[length(...future.conditions) + 
[13:21:39.069]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:39.069]                     cond$call), session = sessionInformation(), 
[13:21:39.069]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:39.069]                   signalCondition(cond)
[13:21:39.069]                 }
[13:21:39.069]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:39.069]                 "immediateCondition"))) {
[13:21:39.069]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:39.069]                   ...future.conditions[[length(...future.conditions) + 
[13:21:39.069]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:39.069]                   if (TRUE && !signal) {
[13:21:39.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.069]                     {
[13:21:39.069]                       inherits <- base::inherits
[13:21:39.069]                       invokeRestart <- base::invokeRestart
[13:21:39.069]                       is.null <- base::is.null
[13:21:39.069]                       muffled <- FALSE
[13:21:39.069]                       if (inherits(cond, "message")) {
[13:21:39.069]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:39.069]                         if (muffled) 
[13:21:39.069]                           invokeRestart("muffleMessage")
[13:21:39.069]                       }
[13:21:39.069]                       else if (inherits(cond, "warning")) {
[13:21:39.069]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:39.069]                         if (muffled) 
[13:21:39.069]                           invokeRestart("muffleWarning")
[13:21:39.069]                       }
[13:21:39.069]                       else if (inherits(cond, "condition")) {
[13:21:39.069]                         if (!is.null(pattern)) {
[13:21:39.069]                           computeRestarts <- base::computeRestarts
[13:21:39.069]                           grepl <- base::grepl
[13:21:39.069]                           restarts <- computeRestarts(cond)
[13:21:39.069]                           for (restart in restarts) {
[13:21:39.069]                             name <- restart$name
[13:21:39.069]                             if (is.null(name)) 
[13:21:39.069]                               next
[13:21:39.069]                             if (!grepl(pattern, name)) 
[13:21:39.069]                               next
[13:21:39.069]                             invokeRestart(restart)
[13:21:39.069]                             muffled <- TRUE
[13:21:39.069]                             break
[13:21:39.069]                           }
[13:21:39.069]                         }
[13:21:39.069]                       }
[13:21:39.069]                       invisible(muffled)
[13:21:39.069]                     }
[13:21:39.069]                     muffleCondition(cond, pattern = "^muffle")
[13:21:39.069]                   }
[13:21:39.069]                 }
[13:21:39.069]                 else {
[13:21:39.069]                   if (TRUE) {
[13:21:39.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.069]                     {
[13:21:39.069]                       inherits <- base::inherits
[13:21:39.069]                       invokeRestart <- base::invokeRestart
[13:21:39.069]                       is.null <- base::is.null
[13:21:39.069]                       muffled <- FALSE
[13:21:39.069]                       if (inherits(cond, "message")) {
[13:21:39.069]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:39.069]                         if (muffled) 
[13:21:39.069]                           invokeRestart("muffleMessage")
[13:21:39.069]                       }
[13:21:39.069]                       else if (inherits(cond, "warning")) {
[13:21:39.069]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:39.069]                         if (muffled) 
[13:21:39.069]                           invokeRestart("muffleWarning")
[13:21:39.069]                       }
[13:21:39.069]                       else if (inherits(cond, "condition")) {
[13:21:39.069]                         if (!is.null(pattern)) {
[13:21:39.069]                           computeRestarts <- base::computeRestarts
[13:21:39.069]                           grepl <- base::grepl
[13:21:39.069]                           restarts <- computeRestarts(cond)
[13:21:39.069]                           for (restart in restarts) {
[13:21:39.069]                             name <- restart$name
[13:21:39.069]                             if (is.null(name)) 
[13:21:39.069]                               next
[13:21:39.069]                             if (!grepl(pattern, name)) 
[13:21:39.069]                               next
[13:21:39.069]                             invokeRestart(restart)
[13:21:39.069]                             muffled <- TRUE
[13:21:39.069]                             break
[13:21:39.069]                           }
[13:21:39.069]                         }
[13:21:39.069]                       }
[13:21:39.069]                       invisible(muffled)
[13:21:39.069]                     }
[13:21:39.069]                     muffleCondition(cond, pattern = "^muffle")
[13:21:39.069]                   }
[13:21:39.069]                 }
[13:21:39.069]             }
[13:21:39.069]         }))
[13:21:39.069]     }, error = function(ex) {
[13:21:39.069]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:39.069]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:39.069]                 ...future.rng), started = ...future.startTime, 
[13:21:39.069]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:39.069]             version = "1.8"), class = "FutureResult")
[13:21:39.069]     }, finally = {
[13:21:39.069]         if (!identical(...future.workdir, getwd())) 
[13:21:39.069]             setwd(...future.workdir)
[13:21:39.069]         {
[13:21:39.069]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:39.069]                 ...future.oldOptions$nwarnings <- NULL
[13:21:39.069]             }
[13:21:39.069]             base::options(...future.oldOptions)
[13:21:39.069]             if (.Platform$OS.type == "windows") {
[13:21:39.069]                 old_names <- names(...future.oldEnvVars)
[13:21:39.069]                 envs <- base::Sys.getenv()
[13:21:39.069]                 names <- names(envs)
[13:21:39.069]                 common <- intersect(names, old_names)
[13:21:39.069]                 added <- setdiff(names, old_names)
[13:21:39.069]                 removed <- setdiff(old_names, names)
[13:21:39.069]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:39.069]                   envs[common]]
[13:21:39.069]                 NAMES <- toupper(changed)
[13:21:39.069]                 args <- list()
[13:21:39.069]                 for (kk in seq_along(NAMES)) {
[13:21:39.069]                   name <- changed[[kk]]
[13:21:39.069]                   NAME <- NAMES[[kk]]
[13:21:39.069]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.069]                     next
[13:21:39.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:39.069]                 }
[13:21:39.069]                 NAMES <- toupper(added)
[13:21:39.069]                 for (kk in seq_along(NAMES)) {
[13:21:39.069]                   name <- added[[kk]]
[13:21:39.069]                   NAME <- NAMES[[kk]]
[13:21:39.069]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.069]                     next
[13:21:39.069]                   args[[name]] <- ""
[13:21:39.069]                 }
[13:21:39.069]                 NAMES <- toupper(removed)
[13:21:39.069]                 for (kk in seq_along(NAMES)) {
[13:21:39.069]                   name <- removed[[kk]]
[13:21:39.069]                   NAME <- NAMES[[kk]]
[13:21:39.069]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.069]                     next
[13:21:39.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:39.069]                 }
[13:21:39.069]                 if (length(args) > 0) 
[13:21:39.069]                   base::do.call(base::Sys.setenv, args = args)
[13:21:39.069]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:39.069]             }
[13:21:39.069]             else {
[13:21:39.069]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:39.069]             }
[13:21:39.069]             {
[13:21:39.069]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:39.069]                   0L) {
[13:21:39.069]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:39.069]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:39.069]                   base::options(opts)
[13:21:39.069]                 }
[13:21:39.069]                 {
[13:21:39.069]                   {
[13:21:39.069]                     NULL
[13:21:39.069]                     RNGkind("Mersenne-Twister")
[13:21:39.069]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:39.069]                       inherits = FALSE)
[13:21:39.069]                   }
[13:21:39.069]                   options(future.plan = NULL)
[13:21:39.069]                   if (is.na(NA_character_)) 
[13:21:39.069]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:39.069]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:39.069]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:39.069]                   {
[13:21:39.069]                     future <- SequentialFuture(..., envir = envir)
[13:21:39.069]                     if (!future$lazy) 
[13:21:39.069]                       future <- run(future)
[13:21:39.069]                     invisible(future)
[13:21:39.069]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:39.069]                 }
[13:21:39.069]             }
[13:21:39.069]         }
[13:21:39.069]     })
[13:21:39.069]     if (TRUE) {
[13:21:39.069]         base::sink(type = "output", split = FALSE)
[13:21:39.069]         if (TRUE) {
[13:21:39.069]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:39.069]         }
[13:21:39.069]         else {
[13:21:39.069]             ...future.result["stdout"] <- base::list(NULL)
[13:21:39.069]         }
[13:21:39.069]         base::close(...future.stdout)
[13:21:39.069]         ...future.stdout <- NULL
[13:21:39.069]     }
[13:21:39.069]     ...future.result$conditions <- ...future.conditions
[13:21:39.069]     ...future.result$finished <- base::Sys.time()
[13:21:39.069]     ...future.result
[13:21:39.069] }
[13:21:39.071] assign_globals() ...
[13:21:39.071] List of 1
[13:21:39.071]  $ kk: int 1
[13:21:39.071]  - attr(*, "where")=List of 1
[13:21:39.071]   ..$ kk:<environment: R_EmptyEnv> 
[13:21:39.071]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:39.071]  - attr(*, "resolved")= logi FALSE
[13:21:39.071]  - attr(*, "total_size")= num 56
[13:21:39.071]  - attr(*, "already-done")= logi TRUE
[13:21:39.074] - copied ‘kk’ to environment
[13:21:39.074] assign_globals() ... done
[13:21:39.074] plan(): Setting new future strategy stack:
[13:21:39.074] List of future strategies:
[13:21:39.074] 1. sequential:
[13:21:39.074]    - args: function (..., envir = parent.frame())
[13:21:39.074]    - tweaked: FALSE
[13:21:39.074]    - call: NULL
[13:21:39.074] plan(): nbrOfWorkers() = 1
[13:21:39.176] plan(): Setting new future strategy stack:
[13:21:39.176] List of future strategies:
[13:21:39.176] 1. sequential:
[13:21:39.176]    - args: function (..., envir = parent.frame())
[13:21:39.176]    - tweaked: FALSE
[13:21:39.176]    - call: plan(strategy)
[13:21:39.176] plan(): nbrOfWorkers() = 1
[13:21:39.177] SequentialFuture started (and completed)
[13:21:39.177] - Launch lazy future ... done
[13:21:39.177] run() for ‘SequentialFuture’ ... done
[13:21:39.177] resolved() for ‘SequentialFuture’ ...
[13:21:39.177] - state: ‘finished’
[13:21:39.177] - run: TRUE
[13:21:39.177] - result: ‘FutureResult’
[13:21:39.177] resolved() for ‘SequentialFuture’ ... done
[13:21:39.177] Future #1
[13:21:39.178]  length: 2 (resolved future 1)
[13:21:39.178] run() for ‘Future’ ...
[13:21:39.178] - state: ‘created’
[13:21:39.178] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:39.178] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:39.178] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:39.178]   - Field: ‘label’
[13:21:39.179]   - Field: ‘local’
[13:21:39.179]   - Field: ‘owner’
[13:21:39.179]   - Field: ‘envir’
[13:21:39.179]   - Field: ‘packages’
[13:21:39.179]   - Field: ‘gc’
[13:21:39.179]   - Field: ‘conditions’
[13:21:39.179]   - Field: ‘expr’
[13:21:39.179]   - Field: ‘uuid’
[13:21:39.179]   - Field: ‘seed’
[13:21:39.179]   - Field: ‘version’
[13:21:39.180]   - Field: ‘result’
[13:21:39.180]   - Field: ‘asynchronous’
[13:21:39.180]   - Field: ‘calls’
[13:21:39.180]   - Field: ‘globals’
[13:21:39.180]   - Field: ‘stdout’
[13:21:39.180]   - Field: ‘earlySignal’
[13:21:39.180]   - Field: ‘lazy’
[13:21:39.180]   - Field: ‘state’
[13:21:39.180] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:39.180] - Launch lazy future ...
[13:21:39.181] Packages needed by the future expression (n = 0): <none>
[13:21:39.181] Packages needed by future strategies (n = 0): <none>
[13:21:39.181] {
[13:21:39.181]     {
[13:21:39.181]         {
[13:21:39.181]             ...future.startTime <- base::Sys.time()
[13:21:39.181]             {
[13:21:39.181]                 {
[13:21:39.181]                   {
[13:21:39.181]                     base::local({
[13:21:39.181]                       has_future <- base::requireNamespace("future", 
[13:21:39.181]                         quietly = TRUE)
[13:21:39.181]                       if (has_future) {
[13:21:39.181]                         ns <- base::getNamespace("future")
[13:21:39.181]                         version <- ns[[".package"]][["version"]]
[13:21:39.181]                         if (is.null(version)) 
[13:21:39.181]                           version <- utils::packageVersion("future")
[13:21:39.181]                       }
[13:21:39.181]                       else {
[13:21:39.181]                         version <- NULL
[13:21:39.181]                       }
[13:21:39.181]                       if (!has_future || version < "1.8.0") {
[13:21:39.181]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:39.181]                           "", base::R.version$version.string), 
[13:21:39.181]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:39.181]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:39.181]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:39.181]                             "release", "version")], collapse = " "), 
[13:21:39.181]                           hostname = base::Sys.info()[["nodename"]])
[13:21:39.181]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:39.181]                           info)
[13:21:39.181]                         info <- base::paste(info, collapse = "; ")
[13:21:39.181]                         if (!has_future) {
[13:21:39.181]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:39.181]                             info)
[13:21:39.181]                         }
[13:21:39.181]                         else {
[13:21:39.181]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:39.181]                             info, version)
[13:21:39.181]                         }
[13:21:39.181]                         base::stop(msg)
[13:21:39.181]                       }
[13:21:39.181]                     })
[13:21:39.181]                   }
[13:21:39.181]                   options(future.plan = NULL)
[13:21:39.181]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:39.181]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:39.181]                 }
[13:21:39.181]                 ...future.workdir <- getwd()
[13:21:39.181]             }
[13:21:39.181]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:39.181]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:39.181]         }
[13:21:39.181]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:39.181]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:39.181]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:39.181]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:39.181]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:39.181]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:39.181]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:39.181]             base::names(...future.oldOptions))
[13:21:39.181]     }
[13:21:39.181]     if (FALSE) {
[13:21:39.181]     }
[13:21:39.181]     else {
[13:21:39.181]         if (TRUE) {
[13:21:39.181]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:39.181]                 open = "w")
[13:21:39.181]         }
[13:21:39.181]         else {
[13:21:39.181]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:39.181]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:39.181]         }
[13:21:39.181]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:39.181]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:39.181]             base::sink(type = "output", split = FALSE)
[13:21:39.181]             base::close(...future.stdout)
[13:21:39.181]         }, add = TRUE)
[13:21:39.181]     }
[13:21:39.181]     ...future.frame <- base::sys.nframe()
[13:21:39.181]     ...future.conditions <- base::list()
[13:21:39.181]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:39.181]     if (FALSE) {
[13:21:39.181]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:39.181]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:39.181]     }
[13:21:39.181]     ...future.result <- base::tryCatch({
[13:21:39.181]         base::withCallingHandlers({
[13:21:39.181]             ...future.value <- base::withVisible(base::local({
[13:21:39.181]                 Sys.sleep(0.1)
[13:21:39.181]                 kk
[13:21:39.181]             }))
[13:21:39.181]             future::FutureResult(value = ...future.value$value, 
[13:21:39.181]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:39.181]                   ...future.rng), globalenv = if (FALSE) 
[13:21:39.181]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:39.181]                     ...future.globalenv.names))
[13:21:39.181]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:39.181]         }, condition = base::local({
[13:21:39.181]             c <- base::c
[13:21:39.181]             inherits <- base::inherits
[13:21:39.181]             invokeRestart <- base::invokeRestart
[13:21:39.181]             length <- base::length
[13:21:39.181]             list <- base::list
[13:21:39.181]             seq.int <- base::seq.int
[13:21:39.181]             signalCondition <- base::signalCondition
[13:21:39.181]             sys.calls <- base::sys.calls
[13:21:39.181]             `[[` <- base::`[[`
[13:21:39.181]             `+` <- base::`+`
[13:21:39.181]             `<<-` <- base::`<<-`
[13:21:39.181]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:39.181]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:39.181]                   3L)]
[13:21:39.181]             }
[13:21:39.181]             function(cond) {
[13:21:39.181]                 is_error <- inherits(cond, "error")
[13:21:39.181]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:39.181]                   NULL)
[13:21:39.181]                 if (is_error) {
[13:21:39.181]                   sessionInformation <- function() {
[13:21:39.181]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:39.181]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:39.181]                       search = base::search(), system = base::Sys.info())
[13:21:39.181]                   }
[13:21:39.181]                   ...future.conditions[[length(...future.conditions) + 
[13:21:39.181]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:39.181]                     cond$call), session = sessionInformation(), 
[13:21:39.181]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:39.181]                   signalCondition(cond)
[13:21:39.181]                 }
[13:21:39.181]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:39.181]                 "immediateCondition"))) {
[13:21:39.181]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:39.181]                   ...future.conditions[[length(...future.conditions) + 
[13:21:39.181]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:39.181]                   if (TRUE && !signal) {
[13:21:39.181]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.181]                     {
[13:21:39.181]                       inherits <- base::inherits
[13:21:39.181]                       invokeRestart <- base::invokeRestart
[13:21:39.181]                       is.null <- base::is.null
[13:21:39.181]                       muffled <- FALSE
[13:21:39.181]                       if (inherits(cond, "message")) {
[13:21:39.181]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:39.181]                         if (muffled) 
[13:21:39.181]                           invokeRestart("muffleMessage")
[13:21:39.181]                       }
[13:21:39.181]                       else if (inherits(cond, "warning")) {
[13:21:39.181]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:39.181]                         if (muffled) 
[13:21:39.181]                           invokeRestart("muffleWarning")
[13:21:39.181]                       }
[13:21:39.181]                       else if (inherits(cond, "condition")) {
[13:21:39.181]                         if (!is.null(pattern)) {
[13:21:39.181]                           computeRestarts <- base::computeRestarts
[13:21:39.181]                           grepl <- base::grepl
[13:21:39.181]                           restarts <- computeRestarts(cond)
[13:21:39.181]                           for (restart in restarts) {
[13:21:39.181]                             name <- restart$name
[13:21:39.181]                             if (is.null(name)) 
[13:21:39.181]                               next
[13:21:39.181]                             if (!grepl(pattern, name)) 
[13:21:39.181]                               next
[13:21:39.181]                             invokeRestart(restart)
[13:21:39.181]                             muffled <- TRUE
[13:21:39.181]                             break
[13:21:39.181]                           }
[13:21:39.181]                         }
[13:21:39.181]                       }
[13:21:39.181]                       invisible(muffled)
[13:21:39.181]                     }
[13:21:39.181]                     muffleCondition(cond, pattern = "^muffle")
[13:21:39.181]                   }
[13:21:39.181]                 }
[13:21:39.181]                 else {
[13:21:39.181]                   if (TRUE) {
[13:21:39.181]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.181]                     {
[13:21:39.181]                       inherits <- base::inherits
[13:21:39.181]                       invokeRestart <- base::invokeRestart
[13:21:39.181]                       is.null <- base::is.null
[13:21:39.181]                       muffled <- FALSE
[13:21:39.181]                       if (inherits(cond, "message")) {
[13:21:39.181]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:39.181]                         if (muffled) 
[13:21:39.181]                           invokeRestart("muffleMessage")
[13:21:39.181]                       }
[13:21:39.181]                       else if (inherits(cond, "warning")) {
[13:21:39.181]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:39.181]                         if (muffled) 
[13:21:39.181]                           invokeRestart("muffleWarning")
[13:21:39.181]                       }
[13:21:39.181]                       else if (inherits(cond, "condition")) {
[13:21:39.181]                         if (!is.null(pattern)) {
[13:21:39.181]                           computeRestarts <- base::computeRestarts
[13:21:39.181]                           grepl <- base::grepl
[13:21:39.181]                           restarts <- computeRestarts(cond)
[13:21:39.181]                           for (restart in restarts) {
[13:21:39.181]                             name <- restart$name
[13:21:39.181]                             if (is.null(name)) 
[13:21:39.181]                               next
[13:21:39.181]                             if (!grepl(pattern, name)) 
[13:21:39.181]                               next
[13:21:39.181]                             invokeRestart(restart)
[13:21:39.181]                             muffled <- TRUE
[13:21:39.181]                             break
[13:21:39.181]                           }
[13:21:39.181]                         }
[13:21:39.181]                       }
[13:21:39.181]                       invisible(muffled)
[13:21:39.181]                     }
[13:21:39.181]                     muffleCondition(cond, pattern = "^muffle")
[13:21:39.181]                   }
[13:21:39.181]                 }
[13:21:39.181]             }
[13:21:39.181]         }))
[13:21:39.181]     }, error = function(ex) {
[13:21:39.181]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:39.181]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:39.181]                 ...future.rng), started = ...future.startTime, 
[13:21:39.181]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:39.181]             version = "1.8"), class = "FutureResult")
[13:21:39.181]     }, finally = {
[13:21:39.181]         if (!identical(...future.workdir, getwd())) 
[13:21:39.181]             setwd(...future.workdir)
[13:21:39.181]         {
[13:21:39.181]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:39.181]                 ...future.oldOptions$nwarnings <- NULL
[13:21:39.181]             }
[13:21:39.181]             base::options(...future.oldOptions)
[13:21:39.181]             if (.Platform$OS.type == "windows") {
[13:21:39.181]                 old_names <- names(...future.oldEnvVars)
[13:21:39.181]                 envs <- base::Sys.getenv()
[13:21:39.181]                 names <- names(envs)
[13:21:39.181]                 common <- intersect(names, old_names)
[13:21:39.181]                 added <- setdiff(names, old_names)
[13:21:39.181]                 removed <- setdiff(old_names, names)
[13:21:39.181]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:39.181]                   envs[common]]
[13:21:39.181]                 NAMES <- toupper(changed)
[13:21:39.181]                 args <- list()
[13:21:39.181]                 for (kk in seq_along(NAMES)) {
[13:21:39.181]                   name <- changed[[kk]]
[13:21:39.181]                   NAME <- NAMES[[kk]]
[13:21:39.181]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.181]                     next
[13:21:39.181]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:39.181]                 }
[13:21:39.181]                 NAMES <- toupper(added)
[13:21:39.181]                 for (kk in seq_along(NAMES)) {
[13:21:39.181]                   name <- added[[kk]]
[13:21:39.181]                   NAME <- NAMES[[kk]]
[13:21:39.181]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.181]                     next
[13:21:39.181]                   args[[name]] <- ""
[13:21:39.181]                 }
[13:21:39.181]                 NAMES <- toupper(removed)
[13:21:39.181]                 for (kk in seq_along(NAMES)) {
[13:21:39.181]                   name <- removed[[kk]]
[13:21:39.181]                   NAME <- NAMES[[kk]]
[13:21:39.181]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.181]                     next
[13:21:39.181]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:39.181]                 }
[13:21:39.181]                 if (length(args) > 0) 
[13:21:39.181]                   base::do.call(base::Sys.setenv, args = args)
[13:21:39.181]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:39.181]             }
[13:21:39.181]             else {
[13:21:39.181]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:39.181]             }
[13:21:39.181]             {
[13:21:39.181]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:39.181]                   0L) {
[13:21:39.181]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:39.181]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:39.181]                   base::options(opts)
[13:21:39.181]                 }
[13:21:39.181]                 {
[13:21:39.181]                   {
[13:21:39.181]                     NULL
[13:21:39.181]                     RNGkind("Mersenne-Twister")
[13:21:39.181]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:39.181]                       inherits = FALSE)
[13:21:39.181]                   }
[13:21:39.181]                   options(future.plan = NULL)
[13:21:39.181]                   if (is.na(NA_character_)) 
[13:21:39.181]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:39.181]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:39.181]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:39.181]                   {
[13:21:39.181]                     future <- SequentialFuture(..., envir = envir)
[13:21:39.181]                     if (!future$lazy) 
[13:21:39.181]                       future <- run(future)
[13:21:39.181]                     invisible(future)
[13:21:39.181]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:39.181]                 }
[13:21:39.181]             }
[13:21:39.181]         }
[13:21:39.181]     })
[13:21:39.181]     if (TRUE) {
[13:21:39.181]         base::sink(type = "output", split = FALSE)
[13:21:39.181]         if (TRUE) {
[13:21:39.181]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:39.181]         }
[13:21:39.181]         else {
[13:21:39.181]             ...future.result["stdout"] <- base::list(NULL)
[13:21:39.181]         }
[13:21:39.181]         base::close(...future.stdout)
[13:21:39.181]         ...future.stdout <- NULL
[13:21:39.181]     }
[13:21:39.181]     ...future.result$conditions <- ...future.conditions
[13:21:39.181]     ...future.result$finished <- base::Sys.time()
[13:21:39.181]     ...future.result
[13:21:39.181] }
[13:21:39.183] assign_globals() ...
[13:21:39.183] List of 1
[13:21:39.183]  $ kk: int 2
[13:21:39.183]  - attr(*, "where")=List of 1
[13:21:39.183]   ..$ kk:<environment: R_EmptyEnv> 
[13:21:39.183]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:39.183]  - attr(*, "resolved")= logi FALSE
[13:21:39.183]  - attr(*, "total_size")= num 56
[13:21:39.183]  - attr(*, "already-done")= logi TRUE
[13:21:39.187] - copied ‘kk’ to environment
[13:21:39.188] assign_globals() ... done
[13:21:39.188] plan(): Setting new future strategy stack:
[13:21:39.188] List of future strategies:
[13:21:39.188] 1. sequential:
[13:21:39.188]    - args: function (..., envir = parent.frame())
[13:21:39.188]    - tweaked: FALSE
[13:21:39.188]    - call: NULL
[13:21:39.188] plan(): nbrOfWorkers() = 1
[13:21:39.290] plan(): Setting new future strategy stack:
[13:21:39.290] List of future strategies:
[13:21:39.290] 1. sequential:
[13:21:39.290]    - args: function (..., envir = parent.frame())
[13:21:39.290]    - tweaked: FALSE
[13:21:39.290]    - call: plan(strategy)
[13:21:39.290] plan(): nbrOfWorkers() = 1
[13:21:39.290] SequentialFuture started (and completed)
[13:21:39.291] - Launch lazy future ... done
[13:21:39.291] run() for ‘SequentialFuture’ ... done
[13:21:39.291] resolved() for ‘SequentialFuture’ ...
[13:21:39.291] - state: ‘finished’
[13:21:39.291] - run: TRUE
[13:21:39.291] - result: ‘FutureResult’
[13:21:39.291] resolved() for ‘SequentialFuture’ ... done
[13:21:39.291] Future #2
[13:21:39.291]  length: 1 (resolved future 2)
[13:21:39.291] run() for ‘Future’ ...
[13:21:39.292] - state: ‘created’
[13:21:39.292] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:39.292] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:39.292] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:39.292]   - Field: ‘label’
[13:21:39.292]   - Field: ‘local’
[13:21:39.292]   - Field: ‘owner’
[13:21:39.293]   - Field: ‘envir’
[13:21:39.293]   - Field: ‘packages’
[13:21:39.293]   - Field: ‘gc’
[13:21:39.293]   - Field: ‘conditions’
[13:21:39.293]   - Field: ‘expr’
[13:21:39.293]   - Field: ‘uuid’
[13:21:39.293]   - Field: ‘seed’
[13:21:39.293]   - Field: ‘version’
[13:21:39.293]   - Field: ‘result’
[13:21:39.293]   - Field: ‘asynchronous’
[13:21:39.294]   - Field: ‘calls’
[13:21:39.294]   - Field: ‘globals’
[13:21:39.294]   - Field: ‘stdout’
[13:21:39.294]   - Field: ‘earlySignal’
[13:21:39.294]   - Field: ‘lazy’
[13:21:39.294]   - Field: ‘state’
[13:21:39.294] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:39.294] - Launch lazy future ...
[13:21:39.294] Packages needed by the future expression (n = 0): <none>
[13:21:39.294] Packages needed by future strategies (n = 0): <none>
[13:21:39.295] {
[13:21:39.295]     {
[13:21:39.295]         {
[13:21:39.295]             ...future.startTime <- base::Sys.time()
[13:21:39.295]             {
[13:21:39.295]                 {
[13:21:39.295]                   {
[13:21:39.295]                     base::local({
[13:21:39.295]                       has_future <- base::requireNamespace("future", 
[13:21:39.295]                         quietly = TRUE)
[13:21:39.295]                       if (has_future) {
[13:21:39.295]                         ns <- base::getNamespace("future")
[13:21:39.295]                         version <- ns[[".package"]][["version"]]
[13:21:39.295]                         if (is.null(version)) 
[13:21:39.295]                           version <- utils::packageVersion("future")
[13:21:39.295]                       }
[13:21:39.295]                       else {
[13:21:39.295]                         version <- NULL
[13:21:39.295]                       }
[13:21:39.295]                       if (!has_future || version < "1.8.0") {
[13:21:39.295]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:39.295]                           "", base::R.version$version.string), 
[13:21:39.295]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:39.295]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:39.295]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:39.295]                             "release", "version")], collapse = " "), 
[13:21:39.295]                           hostname = base::Sys.info()[["nodename"]])
[13:21:39.295]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:39.295]                           info)
[13:21:39.295]                         info <- base::paste(info, collapse = "; ")
[13:21:39.295]                         if (!has_future) {
[13:21:39.295]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:39.295]                             info)
[13:21:39.295]                         }
[13:21:39.295]                         else {
[13:21:39.295]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:39.295]                             info, version)
[13:21:39.295]                         }
[13:21:39.295]                         base::stop(msg)
[13:21:39.295]                       }
[13:21:39.295]                     })
[13:21:39.295]                   }
[13:21:39.295]                   options(future.plan = NULL)
[13:21:39.295]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:39.295]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:39.295]                 }
[13:21:39.295]                 ...future.workdir <- getwd()
[13:21:39.295]             }
[13:21:39.295]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:39.295]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:39.295]         }
[13:21:39.295]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:39.295]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:39.295]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:39.295]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:39.295]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:39.295]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:39.295]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:39.295]             base::names(...future.oldOptions))
[13:21:39.295]     }
[13:21:39.295]     if (FALSE) {
[13:21:39.295]     }
[13:21:39.295]     else {
[13:21:39.295]         if (TRUE) {
[13:21:39.295]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:39.295]                 open = "w")
[13:21:39.295]         }
[13:21:39.295]         else {
[13:21:39.295]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:39.295]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:39.295]         }
[13:21:39.295]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:39.295]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:39.295]             base::sink(type = "output", split = FALSE)
[13:21:39.295]             base::close(...future.stdout)
[13:21:39.295]         }, add = TRUE)
[13:21:39.295]     }
[13:21:39.295]     ...future.frame <- base::sys.nframe()
[13:21:39.295]     ...future.conditions <- base::list()
[13:21:39.295]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:39.295]     if (FALSE) {
[13:21:39.295]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:39.295]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:39.295]     }
[13:21:39.295]     ...future.result <- base::tryCatch({
[13:21:39.295]         base::withCallingHandlers({
[13:21:39.295]             ...future.value <- base::withVisible(base::local({
[13:21:39.295]                 Sys.sleep(0.1)
[13:21:39.295]                 kk
[13:21:39.295]             }))
[13:21:39.295]             future::FutureResult(value = ...future.value$value, 
[13:21:39.295]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:39.295]                   ...future.rng), globalenv = if (FALSE) 
[13:21:39.295]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:39.295]                     ...future.globalenv.names))
[13:21:39.295]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:39.295]         }, condition = base::local({
[13:21:39.295]             c <- base::c
[13:21:39.295]             inherits <- base::inherits
[13:21:39.295]             invokeRestart <- base::invokeRestart
[13:21:39.295]             length <- base::length
[13:21:39.295]             list <- base::list
[13:21:39.295]             seq.int <- base::seq.int
[13:21:39.295]             signalCondition <- base::signalCondition
[13:21:39.295]             sys.calls <- base::sys.calls
[13:21:39.295]             `[[` <- base::`[[`
[13:21:39.295]             `+` <- base::`+`
[13:21:39.295]             `<<-` <- base::`<<-`
[13:21:39.295]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:39.295]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:39.295]                   3L)]
[13:21:39.295]             }
[13:21:39.295]             function(cond) {
[13:21:39.295]                 is_error <- inherits(cond, "error")
[13:21:39.295]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:39.295]                   NULL)
[13:21:39.295]                 if (is_error) {
[13:21:39.295]                   sessionInformation <- function() {
[13:21:39.295]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:39.295]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:39.295]                       search = base::search(), system = base::Sys.info())
[13:21:39.295]                   }
[13:21:39.295]                   ...future.conditions[[length(...future.conditions) + 
[13:21:39.295]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:39.295]                     cond$call), session = sessionInformation(), 
[13:21:39.295]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:39.295]                   signalCondition(cond)
[13:21:39.295]                 }
[13:21:39.295]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:39.295]                 "immediateCondition"))) {
[13:21:39.295]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:39.295]                   ...future.conditions[[length(...future.conditions) + 
[13:21:39.295]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:39.295]                   if (TRUE && !signal) {
[13:21:39.295]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.295]                     {
[13:21:39.295]                       inherits <- base::inherits
[13:21:39.295]                       invokeRestart <- base::invokeRestart
[13:21:39.295]                       is.null <- base::is.null
[13:21:39.295]                       muffled <- FALSE
[13:21:39.295]                       if (inherits(cond, "message")) {
[13:21:39.295]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:39.295]                         if (muffled) 
[13:21:39.295]                           invokeRestart("muffleMessage")
[13:21:39.295]                       }
[13:21:39.295]                       else if (inherits(cond, "warning")) {
[13:21:39.295]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:39.295]                         if (muffled) 
[13:21:39.295]                           invokeRestart("muffleWarning")
[13:21:39.295]                       }
[13:21:39.295]                       else if (inherits(cond, "condition")) {
[13:21:39.295]                         if (!is.null(pattern)) {
[13:21:39.295]                           computeRestarts <- base::computeRestarts
[13:21:39.295]                           grepl <- base::grepl
[13:21:39.295]                           restarts <- computeRestarts(cond)
[13:21:39.295]                           for (restart in restarts) {
[13:21:39.295]                             name <- restart$name
[13:21:39.295]                             if (is.null(name)) 
[13:21:39.295]                               next
[13:21:39.295]                             if (!grepl(pattern, name)) 
[13:21:39.295]                               next
[13:21:39.295]                             invokeRestart(restart)
[13:21:39.295]                             muffled <- TRUE
[13:21:39.295]                             break
[13:21:39.295]                           }
[13:21:39.295]                         }
[13:21:39.295]                       }
[13:21:39.295]                       invisible(muffled)
[13:21:39.295]                     }
[13:21:39.295]                     muffleCondition(cond, pattern = "^muffle")
[13:21:39.295]                   }
[13:21:39.295]                 }
[13:21:39.295]                 else {
[13:21:39.295]                   if (TRUE) {
[13:21:39.295]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.295]                     {
[13:21:39.295]                       inherits <- base::inherits
[13:21:39.295]                       invokeRestart <- base::invokeRestart
[13:21:39.295]                       is.null <- base::is.null
[13:21:39.295]                       muffled <- FALSE
[13:21:39.295]                       if (inherits(cond, "message")) {
[13:21:39.295]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:39.295]                         if (muffled) 
[13:21:39.295]                           invokeRestart("muffleMessage")
[13:21:39.295]                       }
[13:21:39.295]                       else if (inherits(cond, "warning")) {
[13:21:39.295]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:39.295]                         if (muffled) 
[13:21:39.295]                           invokeRestart("muffleWarning")
[13:21:39.295]                       }
[13:21:39.295]                       else if (inherits(cond, "condition")) {
[13:21:39.295]                         if (!is.null(pattern)) {
[13:21:39.295]                           computeRestarts <- base::computeRestarts
[13:21:39.295]                           grepl <- base::grepl
[13:21:39.295]                           restarts <- computeRestarts(cond)
[13:21:39.295]                           for (restart in restarts) {
[13:21:39.295]                             name <- restart$name
[13:21:39.295]                             if (is.null(name)) 
[13:21:39.295]                               next
[13:21:39.295]                             if (!grepl(pattern, name)) 
[13:21:39.295]                               next
[13:21:39.295]                             invokeRestart(restart)
[13:21:39.295]                             muffled <- TRUE
[13:21:39.295]                             break
[13:21:39.295]                           }
[13:21:39.295]                         }
[13:21:39.295]                       }
[13:21:39.295]                       invisible(muffled)
[13:21:39.295]                     }
[13:21:39.295]                     muffleCondition(cond, pattern = "^muffle")
[13:21:39.295]                   }
[13:21:39.295]                 }
[13:21:39.295]             }
[13:21:39.295]         }))
[13:21:39.295]     }, error = function(ex) {
[13:21:39.295]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:39.295]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:39.295]                 ...future.rng), started = ...future.startTime, 
[13:21:39.295]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:39.295]             version = "1.8"), class = "FutureResult")
[13:21:39.295]     }, finally = {
[13:21:39.295]         if (!identical(...future.workdir, getwd())) 
[13:21:39.295]             setwd(...future.workdir)
[13:21:39.295]         {
[13:21:39.295]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:39.295]                 ...future.oldOptions$nwarnings <- NULL
[13:21:39.295]             }
[13:21:39.295]             base::options(...future.oldOptions)
[13:21:39.295]             if (.Platform$OS.type == "windows") {
[13:21:39.295]                 old_names <- names(...future.oldEnvVars)
[13:21:39.295]                 envs <- base::Sys.getenv()
[13:21:39.295]                 names <- names(envs)
[13:21:39.295]                 common <- intersect(names, old_names)
[13:21:39.295]                 added <- setdiff(names, old_names)
[13:21:39.295]                 removed <- setdiff(old_names, names)
[13:21:39.295]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:39.295]                   envs[common]]
[13:21:39.295]                 NAMES <- toupper(changed)
[13:21:39.295]                 args <- list()
[13:21:39.295]                 for (kk in seq_along(NAMES)) {
[13:21:39.295]                   name <- changed[[kk]]
[13:21:39.295]                   NAME <- NAMES[[kk]]
[13:21:39.295]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.295]                     next
[13:21:39.295]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:39.295]                 }
[13:21:39.295]                 NAMES <- toupper(added)
[13:21:39.295]                 for (kk in seq_along(NAMES)) {
[13:21:39.295]                   name <- added[[kk]]
[13:21:39.295]                   NAME <- NAMES[[kk]]
[13:21:39.295]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.295]                     next
[13:21:39.295]                   args[[name]] <- ""
[13:21:39.295]                 }
[13:21:39.295]                 NAMES <- toupper(removed)
[13:21:39.295]                 for (kk in seq_along(NAMES)) {
[13:21:39.295]                   name <- removed[[kk]]
[13:21:39.295]                   NAME <- NAMES[[kk]]
[13:21:39.295]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.295]                     next
[13:21:39.295]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:39.295]                 }
[13:21:39.295]                 if (length(args) > 0) 
[13:21:39.295]                   base::do.call(base::Sys.setenv, args = args)
[13:21:39.295]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:39.295]             }
[13:21:39.295]             else {
[13:21:39.295]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:39.295]             }
[13:21:39.295]             {
[13:21:39.295]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:39.295]                   0L) {
[13:21:39.295]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:39.295]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:39.295]                   base::options(opts)
[13:21:39.295]                 }
[13:21:39.295]                 {
[13:21:39.295]                   {
[13:21:39.295]                     NULL
[13:21:39.295]                     RNGkind("Mersenne-Twister")
[13:21:39.295]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:39.295]                       inherits = FALSE)
[13:21:39.295]                   }
[13:21:39.295]                   options(future.plan = NULL)
[13:21:39.295]                   if (is.na(NA_character_)) 
[13:21:39.295]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:39.295]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:39.295]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:39.295]                   {
[13:21:39.295]                     future <- SequentialFuture(..., envir = envir)
[13:21:39.295]                     if (!future$lazy) 
[13:21:39.295]                       future <- run(future)
[13:21:39.295]                     invisible(future)
[13:21:39.295]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:39.295]                 }
[13:21:39.295]             }
[13:21:39.295]         }
[13:21:39.295]     })
[13:21:39.295]     if (TRUE) {
[13:21:39.295]         base::sink(type = "output", split = FALSE)
[13:21:39.295]         if (TRUE) {
[13:21:39.295]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:39.295]         }
[13:21:39.295]         else {
[13:21:39.295]             ...future.result["stdout"] <- base::list(NULL)
[13:21:39.295]         }
[13:21:39.295]         base::close(...future.stdout)
[13:21:39.295]         ...future.stdout <- NULL
[13:21:39.295]     }
[13:21:39.295]     ...future.result$conditions <- ...future.conditions
[13:21:39.295]     ...future.result$finished <- base::Sys.time()
[13:21:39.295]     ...future.result
[13:21:39.295] }
[13:21:39.297] assign_globals() ...
[13:21:39.297] List of 1
[13:21:39.297]  $ kk: int 3
[13:21:39.297]  - attr(*, "where")=List of 1
[13:21:39.297]   ..$ kk:<environment: R_EmptyEnv> 
[13:21:39.297]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:39.297]  - attr(*, "resolved")= logi FALSE
[13:21:39.297]  - attr(*, "total_size")= num 56
[13:21:39.297]  - attr(*, "already-done")= logi TRUE
[13:21:39.299] - copied ‘kk’ to environment
[13:21:39.299] assign_globals() ... done
[13:21:39.300] plan(): Setting new future strategy stack:
[13:21:39.300] List of future strategies:
[13:21:39.300] 1. sequential:
[13:21:39.300]    - args: function (..., envir = parent.frame())
[13:21:39.300]    - tweaked: FALSE
[13:21:39.300]    - call: NULL
[13:21:39.300] plan(): nbrOfWorkers() = 1
[13:21:39.401] plan(): Setting new future strategy stack:
[13:21:39.401] List of future strategies:
[13:21:39.401] 1. sequential:
[13:21:39.401]    - args: function (..., envir = parent.frame())
[13:21:39.401]    - tweaked: FALSE
[13:21:39.401]    - call: plan(strategy)
[13:21:39.402] plan(): nbrOfWorkers() = 1
[13:21:39.402] SequentialFuture started (and completed)
[13:21:39.402] - Launch lazy future ... done
[13:21:39.402] run() for ‘SequentialFuture’ ... done
[13:21:39.403] resolved() for ‘SequentialFuture’ ...
[13:21:39.403] - state: ‘finished’
[13:21:39.403] - run: TRUE
[13:21:39.403] - result: ‘FutureResult’
[13:21:39.403] resolved() for ‘SequentialFuture’ ... done
[13:21:39.403] Future #3
[13:21:39.403]  length: 0 (resolved future 3)
[13:21:39.403] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[13:21:39.404] resolve() on environment ...
[13:21:39.404]  recursive: 0
[13:21:39.406]  elements: [2] ‘a’, ‘b’
[13:21:39.406]  length: 1 (resolved future 1)
[13:21:39.406]  length: 0 (resolved future 2)
[13:21:39.406] resolve() on environment ... DONE
[13:21:39.406] getGlobalsAndPackages() ...
[13:21:39.406] Searching for globals...
[13:21:39.407] 
[13:21:39.407] Searching for globals ... DONE
[13:21:39.407] - globals: [0] <none>
[13:21:39.407] getGlobalsAndPackages() ... DONE
[13:21:39.407] run() for ‘Future’ ...
[13:21:39.407] - state: ‘created’
[13:21:39.408] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:39.408] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:39.408] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:39.408]   - Field: ‘label’
[13:21:39.408]   - Field: ‘local’
[13:21:39.408]   - Field: ‘owner’
[13:21:39.408]   - Field: ‘envir’
[13:21:39.408]   - Field: ‘packages’
[13:21:39.409]   - Field: ‘gc’
[13:21:39.409]   - Field: ‘conditions’
[13:21:39.409]   - Field: ‘expr’
[13:21:39.409]   - Field: ‘uuid’
[13:21:39.409]   - Field: ‘seed’
[13:21:39.409]   - Field: ‘version’
[13:21:39.409]   - Field: ‘result’
[13:21:39.409]   - Field: ‘asynchronous’
[13:21:39.409]   - Field: ‘calls’
[13:21:39.409]   - Field: ‘globals’
[13:21:39.409]   - Field: ‘stdout’
[13:21:39.410]   - Field: ‘earlySignal’
[13:21:39.410]   - Field: ‘lazy’
[13:21:39.410]   - Field: ‘state’
[13:21:39.410] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:39.410] - Launch lazy future ...
[13:21:39.410] Packages needed by the future expression (n = 0): <none>
[13:21:39.410] Packages needed by future strategies (n = 0): <none>
[13:21:39.411] {
[13:21:39.411]     {
[13:21:39.411]         {
[13:21:39.411]             ...future.startTime <- base::Sys.time()
[13:21:39.411]             {
[13:21:39.411]                 {
[13:21:39.411]                   {
[13:21:39.411]                     base::local({
[13:21:39.411]                       has_future <- base::requireNamespace("future", 
[13:21:39.411]                         quietly = TRUE)
[13:21:39.411]                       if (has_future) {
[13:21:39.411]                         ns <- base::getNamespace("future")
[13:21:39.411]                         version <- ns[[".package"]][["version"]]
[13:21:39.411]                         if (is.null(version)) 
[13:21:39.411]                           version <- utils::packageVersion("future")
[13:21:39.411]                       }
[13:21:39.411]                       else {
[13:21:39.411]                         version <- NULL
[13:21:39.411]                       }
[13:21:39.411]                       if (!has_future || version < "1.8.0") {
[13:21:39.411]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:39.411]                           "", base::R.version$version.string), 
[13:21:39.411]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:39.411]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:39.411]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:39.411]                             "release", "version")], collapse = " "), 
[13:21:39.411]                           hostname = base::Sys.info()[["nodename"]])
[13:21:39.411]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:39.411]                           info)
[13:21:39.411]                         info <- base::paste(info, collapse = "; ")
[13:21:39.411]                         if (!has_future) {
[13:21:39.411]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:39.411]                             info)
[13:21:39.411]                         }
[13:21:39.411]                         else {
[13:21:39.411]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:39.411]                             info, version)
[13:21:39.411]                         }
[13:21:39.411]                         base::stop(msg)
[13:21:39.411]                       }
[13:21:39.411]                     })
[13:21:39.411]                   }
[13:21:39.411]                   options(future.plan = NULL)
[13:21:39.411]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:39.411]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:39.411]                 }
[13:21:39.411]                 ...future.workdir <- getwd()
[13:21:39.411]             }
[13:21:39.411]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:39.411]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:39.411]         }
[13:21:39.411]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:39.411]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:39.411]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:39.411]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:39.411]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:39.411]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:39.411]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:39.411]             base::names(...future.oldOptions))
[13:21:39.411]     }
[13:21:39.411]     if (FALSE) {
[13:21:39.411]     }
[13:21:39.411]     else {
[13:21:39.411]         if (TRUE) {
[13:21:39.411]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:39.411]                 open = "w")
[13:21:39.411]         }
[13:21:39.411]         else {
[13:21:39.411]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:39.411]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:39.411]         }
[13:21:39.411]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:39.411]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:39.411]             base::sink(type = "output", split = FALSE)
[13:21:39.411]             base::close(...future.stdout)
[13:21:39.411]         }, add = TRUE)
[13:21:39.411]     }
[13:21:39.411]     ...future.frame <- base::sys.nframe()
[13:21:39.411]     ...future.conditions <- base::list()
[13:21:39.411]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:39.411]     if (FALSE) {
[13:21:39.411]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:39.411]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:39.411]     }
[13:21:39.411]     ...future.result <- base::tryCatch({
[13:21:39.411]         base::withCallingHandlers({
[13:21:39.411]             ...future.value <- base::withVisible(base::local(1))
[13:21:39.411]             future::FutureResult(value = ...future.value$value, 
[13:21:39.411]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:39.411]                   ...future.rng), globalenv = if (FALSE) 
[13:21:39.411]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:39.411]                     ...future.globalenv.names))
[13:21:39.411]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:39.411]         }, condition = base::local({
[13:21:39.411]             c <- base::c
[13:21:39.411]             inherits <- base::inherits
[13:21:39.411]             invokeRestart <- base::invokeRestart
[13:21:39.411]             length <- base::length
[13:21:39.411]             list <- base::list
[13:21:39.411]             seq.int <- base::seq.int
[13:21:39.411]             signalCondition <- base::signalCondition
[13:21:39.411]             sys.calls <- base::sys.calls
[13:21:39.411]             `[[` <- base::`[[`
[13:21:39.411]             `+` <- base::`+`
[13:21:39.411]             `<<-` <- base::`<<-`
[13:21:39.411]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:39.411]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:39.411]                   3L)]
[13:21:39.411]             }
[13:21:39.411]             function(cond) {
[13:21:39.411]                 is_error <- inherits(cond, "error")
[13:21:39.411]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:39.411]                   NULL)
[13:21:39.411]                 if (is_error) {
[13:21:39.411]                   sessionInformation <- function() {
[13:21:39.411]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:39.411]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:39.411]                       search = base::search(), system = base::Sys.info())
[13:21:39.411]                   }
[13:21:39.411]                   ...future.conditions[[length(...future.conditions) + 
[13:21:39.411]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:39.411]                     cond$call), session = sessionInformation(), 
[13:21:39.411]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:39.411]                   signalCondition(cond)
[13:21:39.411]                 }
[13:21:39.411]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:39.411]                 "immediateCondition"))) {
[13:21:39.411]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:39.411]                   ...future.conditions[[length(...future.conditions) + 
[13:21:39.411]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:39.411]                   if (TRUE && !signal) {
[13:21:39.411]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.411]                     {
[13:21:39.411]                       inherits <- base::inherits
[13:21:39.411]                       invokeRestart <- base::invokeRestart
[13:21:39.411]                       is.null <- base::is.null
[13:21:39.411]                       muffled <- FALSE
[13:21:39.411]                       if (inherits(cond, "message")) {
[13:21:39.411]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:39.411]                         if (muffled) 
[13:21:39.411]                           invokeRestart("muffleMessage")
[13:21:39.411]                       }
[13:21:39.411]                       else if (inherits(cond, "warning")) {
[13:21:39.411]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:39.411]                         if (muffled) 
[13:21:39.411]                           invokeRestart("muffleWarning")
[13:21:39.411]                       }
[13:21:39.411]                       else if (inherits(cond, "condition")) {
[13:21:39.411]                         if (!is.null(pattern)) {
[13:21:39.411]                           computeRestarts <- base::computeRestarts
[13:21:39.411]                           grepl <- base::grepl
[13:21:39.411]                           restarts <- computeRestarts(cond)
[13:21:39.411]                           for (restart in restarts) {
[13:21:39.411]                             name <- restart$name
[13:21:39.411]                             if (is.null(name)) 
[13:21:39.411]                               next
[13:21:39.411]                             if (!grepl(pattern, name)) 
[13:21:39.411]                               next
[13:21:39.411]                             invokeRestart(restart)
[13:21:39.411]                             muffled <- TRUE
[13:21:39.411]                             break
[13:21:39.411]                           }
[13:21:39.411]                         }
[13:21:39.411]                       }
[13:21:39.411]                       invisible(muffled)
[13:21:39.411]                     }
[13:21:39.411]                     muffleCondition(cond, pattern = "^muffle")
[13:21:39.411]                   }
[13:21:39.411]                 }
[13:21:39.411]                 else {
[13:21:39.411]                   if (TRUE) {
[13:21:39.411]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.411]                     {
[13:21:39.411]                       inherits <- base::inherits
[13:21:39.411]                       invokeRestart <- base::invokeRestart
[13:21:39.411]                       is.null <- base::is.null
[13:21:39.411]                       muffled <- FALSE
[13:21:39.411]                       if (inherits(cond, "message")) {
[13:21:39.411]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:39.411]                         if (muffled) 
[13:21:39.411]                           invokeRestart("muffleMessage")
[13:21:39.411]                       }
[13:21:39.411]                       else if (inherits(cond, "warning")) {
[13:21:39.411]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:39.411]                         if (muffled) 
[13:21:39.411]                           invokeRestart("muffleWarning")
[13:21:39.411]                       }
[13:21:39.411]                       else if (inherits(cond, "condition")) {
[13:21:39.411]                         if (!is.null(pattern)) {
[13:21:39.411]                           computeRestarts <- base::computeRestarts
[13:21:39.411]                           grepl <- base::grepl
[13:21:39.411]                           restarts <- computeRestarts(cond)
[13:21:39.411]                           for (restart in restarts) {
[13:21:39.411]                             name <- restart$name
[13:21:39.411]                             if (is.null(name)) 
[13:21:39.411]                               next
[13:21:39.411]                             if (!grepl(pattern, name)) 
[13:21:39.411]                               next
[13:21:39.411]                             invokeRestart(restart)
[13:21:39.411]                             muffled <- TRUE
[13:21:39.411]                             break
[13:21:39.411]                           }
[13:21:39.411]                         }
[13:21:39.411]                       }
[13:21:39.411]                       invisible(muffled)
[13:21:39.411]                     }
[13:21:39.411]                     muffleCondition(cond, pattern = "^muffle")
[13:21:39.411]                   }
[13:21:39.411]                 }
[13:21:39.411]             }
[13:21:39.411]         }))
[13:21:39.411]     }, error = function(ex) {
[13:21:39.411]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:39.411]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:39.411]                 ...future.rng), started = ...future.startTime, 
[13:21:39.411]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:39.411]             version = "1.8"), class = "FutureResult")
[13:21:39.411]     }, finally = {
[13:21:39.411]         if (!identical(...future.workdir, getwd())) 
[13:21:39.411]             setwd(...future.workdir)
[13:21:39.411]         {
[13:21:39.411]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:39.411]                 ...future.oldOptions$nwarnings <- NULL
[13:21:39.411]             }
[13:21:39.411]             base::options(...future.oldOptions)
[13:21:39.411]             if (.Platform$OS.type == "windows") {
[13:21:39.411]                 old_names <- names(...future.oldEnvVars)
[13:21:39.411]                 envs <- base::Sys.getenv()
[13:21:39.411]                 names <- names(envs)
[13:21:39.411]                 common <- intersect(names, old_names)
[13:21:39.411]                 added <- setdiff(names, old_names)
[13:21:39.411]                 removed <- setdiff(old_names, names)
[13:21:39.411]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:39.411]                   envs[common]]
[13:21:39.411]                 NAMES <- toupper(changed)
[13:21:39.411]                 args <- list()
[13:21:39.411]                 for (kk in seq_along(NAMES)) {
[13:21:39.411]                   name <- changed[[kk]]
[13:21:39.411]                   NAME <- NAMES[[kk]]
[13:21:39.411]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.411]                     next
[13:21:39.411]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:39.411]                 }
[13:21:39.411]                 NAMES <- toupper(added)
[13:21:39.411]                 for (kk in seq_along(NAMES)) {
[13:21:39.411]                   name <- added[[kk]]
[13:21:39.411]                   NAME <- NAMES[[kk]]
[13:21:39.411]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.411]                     next
[13:21:39.411]                   args[[name]] <- ""
[13:21:39.411]                 }
[13:21:39.411]                 NAMES <- toupper(removed)
[13:21:39.411]                 for (kk in seq_along(NAMES)) {
[13:21:39.411]                   name <- removed[[kk]]
[13:21:39.411]                   NAME <- NAMES[[kk]]
[13:21:39.411]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.411]                     next
[13:21:39.411]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:39.411]                 }
[13:21:39.411]                 if (length(args) > 0) 
[13:21:39.411]                   base::do.call(base::Sys.setenv, args = args)
[13:21:39.411]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:39.411]             }
[13:21:39.411]             else {
[13:21:39.411]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:39.411]             }
[13:21:39.411]             {
[13:21:39.411]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:39.411]                   0L) {
[13:21:39.411]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:39.411]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:39.411]                   base::options(opts)
[13:21:39.411]                 }
[13:21:39.411]                 {
[13:21:39.411]                   {
[13:21:39.411]                     NULL
[13:21:39.411]                     RNGkind("Mersenne-Twister")
[13:21:39.411]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:39.411]                       inherits = FALSE)
[13:21:39.411]                   }
[13:21:39.411]                   options(future.plan = NULL)
[13:21:39.411]                   if (is.na(NA_character_)) 
[13:21:39.411]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:39.411]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:39.411]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:39.411]                   {
[13:21:39.411]                     future <- SequentialFuture(..., envir = envir)
[13:21:39.411]                     if (!future$lazy) 
[13:21:39.411]                       future <- run(future)
[13:21:39.411]                     invisible(future)
[13:21:39.411]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:39.411]                 }
[13:21:39.411]             }
[13:21:39.411]         }
[13:21:39.411]     })
[13:21:39.411]     if (TRUE) {
[13:21:39.411]         base::sink(type = "output", split = FALSE)
[13:21:39.411]         if (TRUE) {
[13:21:39.411]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:39.411]         }
[13:21:39.411]         else {
[13:21:39.411]             ...future.result["stdout"] <- base::list(NULL)
[13:21:39.411]         }
[13:21:39.411]         base::close(...future.stdout)
[13:21:39.411]         ...future.stdout <- NULL
[13:21:39.411]     }
[13:21:39.411]     ...future.result$conditions <- ...future.conditions
[13:21:39.411]     ...future.result$finished <- base::Sys.time()
[13:21:39.411]     ...future.result
[13:21:39.411] }
[13:21:39.412] plan(): Setting new future strategy stack:
[13:21:39.413] List of future strategies:
[13:21:39.413] 1. sequential:
[13:21:39.413]    - args: function (..., envir = parent.frame())
[13:21:39.413]    - tweaked: FALSE
[13:21:39.413]    - call: NULL
[13:21:39.413] plan(): nbrOfWorkers() = 1
[13:21:39.414] plan(): Setting new future strategy stack:
[13:21:39.414] List of future strategies:
[13:21:39.414] 1. sequential:
[13:21:39.414]    - args: function (..., envir = parent.frame())
[13:21:39.414]    - tweaked: FALSE
[13:21:39.414]    - call: plan(strategy)
[13:21:39.414] plan(): nbrOfWorkers() = 1
[13:21:39.414] SequentialFuture started (and completed)
[13:21:39.414] - Launch lazy future ... done
[13:21:39.415] run() for ‘SequentialFuture’ ... done
[13:21:39.415] getGlobalsAndPackages() ...
[13:21:39.415] Searching for globals...
[13:21:39.415] 
[13:21:39.415] Searching for globals ... DONE
[13:21:39.415] - globals: [0] <none>
[13:21:39.415] getGlobalsAndPackages() ... DONE
[13:21:39.416] run() for ‘Future’ ...
[13:21:39.416] - state: ‘created’
[13:21:39.416] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:39.416] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:39.416] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:39.416]   - Field: ‘label’
[13:21:39.416]   - Field: ‘local’
[13:21:39.416]   - Field: ‘owner’
[13:21:39.416]   - Field: ‘envir’
[13:21:39.417]   - Field: ‘packages’
[13:21:39.417]   - Field: ‘gc’
[13:21:39.417]   - Field: ‘conditions’
[13:21:39.419]   - Field: ‘expr’
[13:21:39.419]   - Field: ‘uuid’
[13:21:39.419]   - Field: ‘seed’
[13:21:39.419]   - Field: ‘version’
[13:21:39.419]   - Field: ‘result’
[13:21:39.419]   - Field: ‘asynchronous’
[13:21:39.419]   - Field: ‘calls’
[13:21:39.419]   - Field: ‘globals’
[13:21:39.419]   - Field: ‘stdout’
[13:21:39.420]   - Field: ‘earlySignal’
[13:21:39.420]   - Field: ‘lazy’
[13:21:39.420]   - Field: ‘state’
[13:21:39.420] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:39.420] - Launch lazy future ...
[13:21:39.420] Packages needed by the future expression (n = 0): <none>
[13:21:39.420] Packages needed by future strategies (n = 0): <none>
[13:21:39.421] {
[13:21:39.421]     {
[13:21:39.421]         {
[13:21:39.421]             ...future.startTime <- base::Sys.time()
[13:21:39.421]             {
[13:21:39.421]                 {
[13:21:39.421]                   {
[13:21:39.421]                     base::local({
[13:21:39.421]                       has_future <- base::requireNamespace("future", 
[13:21:39.421]                         quietly = TRUE)
[13:21:39.421]                       if (has_future) {
[13:21:39.421]                         ns <- base::getNamespace("future")
[13:21:39.421]                         version <- ns[[".package"]][["version"]]
[13:21:39.421]                         if (is.null(version)) 
[13:21:39.421]                           version <- utils::packageVersion("future")
[13:21:39.421]                       }
[13:21:39.421]                       else {
[13:21:39.421]                         version <- NULL
[13:21:39.421]                       }
[13:21:39.421]                       if (!has_future || version < "1.8.0") {
[13:21:39.421]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:39.421]                           "", base::R.version$version.string), 
[13:21:39.421]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:39.421]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:39.421]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:39.421]                             "release", "version")], collapse = " "), 
[13:21:39.421]                           hostname = base::Sys.info()[["nodename"]])
[13:21:39.421]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:39.421]                           info)
[13:21:39.421]                         info <- base::paste(info, collapse = "; ")
[13:21:39.421]                         if (!has_future) {
[13:21:39.421]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:39.421]                             info)
[13:21:39.421]                         }
[13:21:39.421]                         else {
[13:21:39.421]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:39.421]                             info, version)
[13:21:39.421]                         }
[13:21:39.421]                         base::stop(msg)
[13:21:39.421]                       }
[13:21:39.421]                     })
[13:21:39.421]                   }
[13:21:39.421]                   options(future.plan = NULL)
[13:21:39.421]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:39.421]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:39.421]                 }
[13:21:39.421]                 ...future.workdir <- getwd()
[13:21:39.421]             }
[13:21:39.421]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:39.421]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:39.421]         }
[13:21:39.421]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:39.421]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:39.421]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:39.421]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:39.421]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:39.421]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:39.421]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:39.421]             base::names(...future.oldOptions))
[13:21:39.421]     }
[13:21:39.421]     if (FALSE) {
[13:21:39.421]     }
[13:21:39.421]     else {
[13:21:39.421]         if (TRUE) {
[13:21:39.421]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:39.421]                 open = "w")
[13:21:39.421]         }
[13:21:39.421]         else {
[13:21:39.421]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:39.421]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:39.421]         }
[13:21:39.421]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:39.421]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:39.421]             base::sink(type = "output", split = FALSE)
[13:21:39.421]             base::close(...future.stdout)
[13:21:39.421]         }, add = TRUE)
[13:21:39.421]     }
[13:21:39.421]     ...future.frame <- base::sys.nframe()
[13:21:39.421]     ...future.conditions <- base::list()
[13:21:39.421]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:39.421]     if (FALSE) {
[13:21:39.421]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:39.421]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:39.421]     }
[13:21:39.421]     ...future.result <- base::tryCatch({
[13:21:39.421]         base::withCallingHandlers({
[13:21:39.421]             ...future.value <- base::withVisible(base::local(2))
[13:21:39.421]             future::FutureResult(value = ...future.value$value, 
[13:21:39.421]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:39.421]                   ...future.rng), globalenv = if (FALSE) 
[13:21:39.421]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:39.421]                     ...future.globalenv.names))
[13:21:39.421]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:39.421]         }, condition = base::local({
[13:21:39.421]             c <- base::c
[13:21:39.421]             inherits <- base::inherits
[13:21:39.421]             invokeRestart <- base::invokeRestart
[13:21:39.421]             length <- base::length
[13:21:39.421]             list <- base::list
[13:21:39.421]             seq.int <- base::seq.int
[13:21:39.421]             signalCondition <- base::signalCondition
[13:21:39.421]             sys.calls <- base::sys.calls
[13:21:39.421]             `[[` <- base::`[[`
[13:21:39.421]             `+` <- base::`+`
[13:21:39.421]             `<<-` <- base::`<<-`
[13:21:39.421]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:39.421]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:39.421]                   3L)]
[13:21:39.421]             }
[13:21:39.421]             function(cond) {
[13:21:39.421]                 is_error <- inherits(cond, "error")
[13:21:39.421]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:39.421]                   NULL)
[13:21:39.421]                 if (is_error) {
[13:21:39.421]                   sessionInformation <- function() {
[13:21:39.421]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:39.421]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:39.421]                       search = base::search(), system = base::Sys.info())
[13:21:39.421]                   }
[13:21:39.421]                   ...future.conditions[[length(...future.conditions) + 
[13:21:39.421]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:39.421]                     cond$call), session = sessionInformation(), 
[13:21:39.421]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:39.421]                   signalCondition(cond)
[13:21:39.421]                 }
[13:21:39.421]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:39.421]                 "immediateCondition"))) {
[13:21:39.421]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:39.421]                   ...future.conditions[[length(...future.conditions) + 
[13:21:39.421]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:39.421]                   if (TRUE && !signal) {
[13:21:39.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.421]                     {
[13:21:39.421]                       inherits <- base::inherits
[13:21:39.421]                       invokeRestart <- base::invokeRestart
[13:21:39.421]                       is.null <- base::is.null
[13:21:39.421]                       muffled <- FALSE
[13:21:39.421]                       if (inherits(cond, "message")) {
[13:21:39.421]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:39.421]                         if (muffled) 
[13:21:39.421]                           invokeRestart("muffleMessage")
[13:21:39.421]                       }
[13:21:39.421]                       else if (inherits(cond, "warning")) {
[13:21:39.421]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:39.421]                         if (muffled) 
[13:21:39.421]                           invokeRestart("muffleWarning")
[13:21:39.421]                       }
[13:21:39.421]                       else if (inherits(cond, "condition")) {
[13:21:39.421]                         if (!is.null(pattern)) {
[13:21:39.421]                           computeRestarts <- base::computeRestarts
[13:21:39.421]                           grepl <- base::grepl
[13:21:39.421]                           restarts <- computeRestarts(cond)
[13:21:39.421]                           for (restart in restarts) {
[13:21:39.421]                             name <- restart$name
[13:21:39.421]                             if (is.null(name)) 
[13:21:39.421]                               next
[13:21:39.421]                             if (!grepl(pattern, name)) 
[13:21:39.421]                               next
[13:21:39.421]                             invokeRestart(restart)
[13:21:39.421]                             muffled <- TRUE
[13:21:39.421]                             break
[13:21:39.421]                           }
[13:21:39.421]                         }
[13:21:39.421]                       }
[13:21:39.421]                       invisible(muffled)
[13:21:39.421]                     }
[13:21:39.421]                     muffleCondition(cond, pattern = "^muffle")
[13:21:39.421]                   }
[13:21:39.421]                 }
[13:21:39.421]                 else {
[13:21:39.421]                   if (TRUE) {
[13:21:39.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.421]                     {
[13:21:39.421]                       inherits <- base::inherits
[13:21:39.421]                       invokeRestart <- base::invokeRestart
[13:21:39.421]                       is.null <- base::is.null
[13:21:39.421]                       muffled <- FALSE
[13:21:39.421]                       if (inherits(cond, "message")) {
[13:21:39.421]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:39.421]                         if (muffled) 
[13:21:39.421]                           invokeRestart("muffleMessage")
[13:21:39.421]                       }
[13:21:39.421]                       else if (inherits(cond, "warning")) {
[13:21:39.421]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:39.421]                         if (muffled) 
[13:21:39.421]                           invokeRestart("muffleWarning")
[13:21:39.421]                       }
[13:21:39.421]                       else if (inherits(cond, "condition")) {
[13:21:39.421]                         if (!is.null(pattern)) {
[13:21:39.421]                           computeRestarts <- base::computeRestarts
[13:21:39.421]                           grepl <- base::grepl
[13:21:39.421]                           restarts <- computeRestarts(cond)
[13:21:39.421]                           for (restart in restarts) {
[13:21:39.421]                             name <- restart$name
[13:21:39.421]                             if (is.null(name)) 
[13:21:39.421]                               next
[13:21:39.421]                             if (!grepl(pattern, name)) 
[13:21:39.421]                               next
[13:21:39.421]                             invokeRestart(restart)
[13:21:39.421]                             muffled <- TRUE
[13:21:39.421]                             break
[13:21:39.421]                           }
[13:21:39.421]                         }
[13:21:39.421]                       }
[13:21:39.421]                       invisible(muffled)
[13:21:39.421]                     }
[13:21:39.421]                     muffleCondition(cond, pattern = "^muffle")
[13:21:39.421]                   }
[13:21:39.421]                 }
[13:21:39.421]             }
[13:21:39.421]         }))
[13:21:39.421]     }, error = function(ex) {
[13:21:39.421]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:39.421]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:39.421]                 ...future.rng), started = ...future.startTime, 
[13:21:39.421]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:39.421]             version = "1.8"), class = "FutureResult")
[13:21:39.421]     }, finally = {
[13:21:39.421]         if (!identical(...future.workdir, getwd())) 
[13:21:39.421]             setwd(...future.workdir)
[13:21:39.421]         {
[13:21:39.421]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:39.421]                 ...future.oldOptions$nwarnings <- NULL
[13:21:39.421]             }
[13:21:39.421]             base::options(...future.oldOptions)
[13:21:39.421]             if (.Platform$OS.type == "windows") {
[13:21:39.421]                 old_names <- names(...future.oldEnvVars)
[13:21:39.421]                 envs <- base::Sys.getenv()
[13:21:39.421]                 names <- names(envs)
[13:21:39.421]                 common <- intersect(names, old_names)
[13:21:39.421]                 added <- setdiff(names, old_names)
[13:21:39.421]                 removed <- setdiff(old_names, names)
[13:21:39.421]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:39.421]                   envs[common]]
[13:21:39.421]                 NAMES <- toupper(changed)
[13:21:39.421]                 args <- list()
[13:21:39.421]                 for (kk in seq_along(NAMES)) {
[13:21:39.421]                   name <- changed[[kk]]
[13:21:39.421]                   NAME <- NAMES[[kk]]
[13:21:39.421]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.421]                     next
[13:21:39.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:39.421]                 }
[13:21:39.421]                 NAMES <- toupper(added)
[13:21:39.421]                 for (kk in seq_along(NAMES)) {
[13:21:39.421]                   name <- added[[kk]]
[13:21:39.421]                   NAME <- NAMES[[kk]]
[13:21:39.421]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.421]                     next
[13:21:39.421]                   args[[name]] <- ""
[13:21:39.421]                 }
[13:21:39.421]                 NAMES <- toupper(removed)
[13:21:39.421]                 for (kk in seq_along(NAMES)) {
[13:21:39.421]                   name <- removed[[kk]]
[13:21:39.421]                   NAME <- NAMES[[kk]]
[13:21:39.421]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.421]                     next
[13:21:39.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:39.421]                 }
[13:21:39.421]                 if (length(args) > 0) 
[13:21:39.421]                   base::do.call(base::Sys.setenv, args = args)
[13:21:39.421]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:39.421]             }
[13:21:39.421]             else {
[13:21:39.421]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:39.421]             }
[13:21:39.421]             {
[13:21:39.421]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:39.421]                   0L) {
[13:21:39.421]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:39.421]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:39.421]                   base::options(opts)
[13:21:39.421]                 }
[13:21:39.421]                 {
[13:21:39.421]                   {
[13:21:39.421]                     NULL
[13:21:39.421]                     RNGkind("Mersenne-Twister")
[13:21:39.421]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:39.421]                       inherits = FALSE)
[13:21:39.421]                   }
[13:21:39.421]                   options(future.plan = NULL)
[13:21:39.421]                   if (is.na(NA_character_)) 
[13:21:39.421]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:39.421]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:39.421]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:39.421]                   {
[13:21:39.421]                     future <- SequentialFuture(..., envir = envir)
[13:21:39.421]                     if (!future$lazy) 
[13:21:39.421]                       future <- run(future)
[13:21:39.421]                     invisible(future)
[13:21:39.421]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:39.421]                 }
[13:21:39.421]             }
[13:21:39.421]         }
[13:21:39.421]     })
[13:21:39.421]     if (TRUE) {
[13:21:39.421]         base::sink(type = "output", split = FALSE)
[13:21:39.421]         if (TRUE) {
[13:21:39.421]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:39.421]         }
[13:21:39.421]         else {
[13:21:39.421]             ...future.result["stdout"] <- base::list(NULL)
[13:21:39.421]         }
[13:21:39.421]         base::close(...future.stdout)
[13:21:39.421]         ...future.stdout <- NULL
[13:21:39.421]     }
[13:21:39.421]     ...future.result$conditions <- ...future.conditions
[13:21:39.421]     ...future.result$finished <- base::Sys.time()
[13:21:39.421]     ...future.result
[13:21:39.421] }
[13:21:39.422] plan(): Setting new future strategy stack:
[13:21:39.423] List of future strategies:
[13:21:39.423] 1. sequential:
[13:21:39.423]    - args: function (..., envir = parent.frame())
[13:21:39.423]    - tweaked: FALSE
[13:21:39.423]    - call: NULL
[13:21:39.423] plan(): nbrOfWorkers() = 1
[13:21:39.424] plan(): Setting new future strategy stack:
[13:21:39.424] List of future strategies:
[13:21:39.424] 1. sequential:
[13:21:39.424]    - args: function (..., envir = parent.frame())
[13:21:39.424]    - tweaked: FALSE
[13:21:39.424]    - call: plan(strategy)
[13:21:39.424] plan(): nbrOfWorkers() = 1
[13:21:39.424] SequentialFuture started (and completed)
[13:21:39.424] - Launch lazy future ... done
[13:21:39.424] run() for ‘SequentialFuture’ ... done
[13:21:39.425] resolve() on environment ...
[13:21:39.425]  recursive: 0
[13:21:39.425]  elements: [3] ‘a’, ‘b’, ‘c’
[13:21:39.426] resolved() for ‘SequentialFuture’ ...
[13:21:39.426] - state: ‘finished’
[13:21:39.426] - run: TRUE
[13:21:39.426] - result: ‘FutureResult’
[13:21:39.426] resolved() for ‘SequentialFuture’ ... done
[13:21:39.426] Future #1
[13:21:39.426]  length: 2 (resolved future 1)
[13:21:39.426] resolved() for ‘SequentialFuture’ ...
[13:21:39.426] - state: ‘finished’
[13:21:39.426] - run: TRUE
[13:21:39.427] - result: ‘FutureResult’
[13:21:39.427] resolved() for ‘SequentialFuture’ ... done
[13:21:39.427] Future #2
[13:21:39.427]  length: 1 (resolved future 2)
[13:21:39.427]  length: 0 (resolved future 3)
[13:21:39.427] resolve() on environment ... DONE
[13:21:39.427] resolved() for ‘SequentialFuture’ ...
[13:21:39.427] - state: ‘finished’
[13:21:39.427] - run: TRUE
[13:21:39.427] - result: ‘FutureResult’
[13:21:39.428] resolved() for ‘SequentialFuture’ ... done
[13:21:39.428] resolved() for ‘SequentialFuture’ ...
[13:21:39.428] - state: ‘finished’
[13:21:39.428] - run: TRUE
[13:21:39.428] - result: ‘FutureResult’
[13:21:39.428] resolved() for ‘SequentialFuture’ ... done
[13:21:39.429] getGlobalsAndPackages() ...
[13:21:39.429] Searching for globals...
[13:21:39.430] - globals found: [1] ‘{’
[13:21:39.430] Searching for globals ... DONE
[13:21:39.430] Resolving globals: FALSE
[13:21:39.430] 
[13:21:39.430] 
[13:21:39.430] getGlobalsAndPackages() ... DONE
[13:21:39.430] run() for ‘Future’ ...
[13:21:39.431] - state: ‘created’
[13:21:39.431] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:39.431] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:39.431] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:39.431]   - Field: ‘label’
[13:21:39.431]   - Field: ‘local’
[13:21:39.431]   - Field: ‘owner’
[13:21:39.431]   - Field: ‘envir’
[13:21:39.432]   - Field: ‘packages’
[13:21:39.432]   - Field: ‘gc’
[13:21:39.432]   - Field: ‘conditions’
[13:21:39.432]   - Field: ‘expr’
[13:21:39.432]   - Field: ‘uuid’
[13:21:39.432]   - Field: ‘seed’
[13:21:39.432]   - Field: ‘version’
[13:21:39.432]   - Field: ‘result’
[13:21:39.432]   - Field: ‘asynchronous’
[13:21:39.432]   - Field: ‘calls’
[13:21:39.432]   - Field: ‘globals’
[13:21:39.433]   - Field: ‘stdout’
[13:21:39.433]   - Field: ‘earlySignal’
[13:21:39.433]   - Field: ‘lazy’
[13:21:39.433]   - Field: ‘state’
[13:21:39.433] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:39.433] - Launch lazy future ...
[13:21:39.433] Packages needed by the future expression (n = 0): <none>
[13:21:39.433] Packages needed by future strategies (n = 0): <none>
[13:21:39.434] {
[13:21:39.434]     {
[13:21:39.434]         {
[13:21:39.434]             ...future.startTime <- base::Sys.time()
[13:21:39.434]             {
[13:21:39.434]                 {
[13:21:39.434]                   {
[13:21:39.434]                     base::local({
[13:21:39.434]                       has_future <- base::requireNamespace("future", 
[13:21:39.434]                         quietly = TRUE)
[13:21:39.434]                       if (has_future) {
[13:21:39.434]                         ns <- base::getNamespace("future")
[13:21:39.434]                         version <- ns[[".package"]][["version"]]
[13:21:39.434]                         if (is.null(version)) 
[13:21:39.434]                           version <- utils::packageVersion("future")
[13:21:39.434]                       }
[13:21:39.434]                       else {
[13:21:39.434]                         version <- NULL
[13:21:39.434]                       }
[13:21:39.434]                       if (!has_future || version < "1.8.0") {
[13:21:39.434]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:39.434]                           "", base::R.version$version.string), 
[13:21:39.434]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:39.434]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:39.434]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:39.434]                             "release", "version")], collapse = " "), 
[13:21:39.434]                           hostname = base::Sys.info()[["nodename"]])
[13:21:39.434]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:39.434]                           info)
[13:21:39.434]                         info <- base::paste(info, collapse = "; ")
[13:21:39.434]                         if (!has_future) {
[13:21:39.434]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:39.434]                             info)
[13:21:39.434]                         }
[13:21:39.434]                         else {
[13:21:39.434]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:39.434]                             info, version)
[13:21:39.434]                         }
[13:21:39.434]                         base::stop(msg)
[13:21:39.434]                       }
[13:21:39.434]                     })
[13:21:39.434]                   }
[13:21:39.434]                   options(future.plan = NULL)
[13:21:39.434]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:39.434]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:39.434]                 }
[13:21:39.434]                 ...future.workdir <- getwd()
[13:21:39.434]             }
[13:21:39.434]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:39.434]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:39.434]         }
[13:21:39.434]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:39.434]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:39.434]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:39.434]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:39.434]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:39.434]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:39.434]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:39.434]             base::names(...future.oldOptions))
[13:21:39.434]     }
[13:21:39.434]     if (FALSE) {
[13:21:39.434]     }
[13:21:39.434]     else {
[13:21:39.434]         if (TRUE) {
[13:21:39.434]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:39.434]                 open = "w")
[13:21:39.434]         }
[13:21:39.434]         else {
[13:21:39.434]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:39.434]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:39.434]         }
[13:21:39.434]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:39.434]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:39.434]             base::sink(type = "output", split = FALSE)
[13:21:39.434]             base::close(...future.stdout)
[13:21:39.434]         }, add = TRUE)
[13:21:39.434]     }
[13:21:39.434]     ...future.frame <- base::sys.nframe()
[13:21:39.434]     ...future.conditions <- base::list()
[13:21:39.434]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:39.434]     if (FALSE) {
[13:21:39.434]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:39.434]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:39.434]     }
[13:21:39.434]     ...future.result <- base::tryCatch({
[13:21:39.434]         base::withCallingHandlers({
[13:21:39.434]             ...future.value <- base::withVisible(base::local({
[13:21:39.434]                 1
[13:21:39.434]             }))
[13:21:39.434]             future::FutureResult(value = ...future.value$value, 
[13:21:39.434]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:39.434]                   ...future.rng), globalenv = if (FALSE) 
[13:21:39.434]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:39.434]                     ...future.globalenv.names))
[13:21:39.434]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:39.434]         }, condition = base::local({
[13:21:39.434]             c <- base::c
[13:21:39.434]             inherits <- base::inherits
[13:21:39.434]             invokeRestart <- base::invokeRestart
[13:21:39.434]             length <- base::length
[13:21:39.434]             list <- base::list
[13:21:39.434]             seq.int <- base::seq.int
[13:21:39.434]             signalCondition <- base::signalCondition
[13:21:39.434]             sys.calls <- base::sys.calls
[13:21:39.434]             `[[` <- base::`[[`
[13:21:39.434]             `+` <- base::`+`
[13:21:39.434]             `<<-` <- base::`<<-`
[13:21:39.434]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:39.434]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:39.434]                   3L)]
[13:21:39.434]             }
[13:21:39.434]             function(cond) {
[13:21:39.434]                 is_error <- inherits(cond, "error")
[13:21:39.434]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:39.434]                   NULL)
[13:21:39.434]                 if (is_error) {
[13:21:39.434]                   sessionInformation <- function() {
[13:21:39.434]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:39.434]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:39.434]                       search = base::search(), system = base::Sys.info())
[13:21:39.434]                   }
[13:21:39.434]                   ...future.conditions[[length(...future.conditions) + 
[13:21:39.434]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:39.434]                     cond$call), session = sessionInformation(), 
[13:21:39.434]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:39.434]                   signalCondition(cond)
[13:21:39.434]                 }
[13:21:39.434]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:39.434]                 "immediateCondition"))) {
[13:21:39.434]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:39.434]                   ...future.conditions[[length(...future.conditions) + 
[13:21:39.434]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:39.434]                   if (TRUE && !signal) {
[13:21:39.434]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.434]                     {
[13:21:39.434]                       inherits <- base::inherits
[13:21:39.434]                       invokeRestart <- base::invokeRestart
[13:21:39.434]                       is.null <- base::is.null
[13:21:39.434]                       muffled <- FALSE
[13:21:39.434]                       if (inherits(cond, "message")) {
[13:21:39.434]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:39.434]                         if (muffled) 
[13:21:39.434]                           invokeRestart("muffleMessage")
[13:21:39.434]                       }
[13:21:39.434]                       else if (inherits(cond, "warning")) {
[13:21:39.434]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:39.434]                         if (muffled) 
[13:21:39.434]                           invokeRestart("muffleWarning")
[13:21:39.434]                       }
[13:21:39.434]                       else if (inherits(cond, "condition")) {
[13:21:39.434]                         if (!is.null(pattern)) {
[13:21:39.434]                           computeRestarts <- base::computeRestarts
[13:21:39.434]                           grepl <- base::grepl
[13:21:39.434]                           restarts <- computeRestarts(cond)
[13:21:39.434]                           for (restart in restarts) {
[13:21:39.434]                             name <- restart$name
[13:21:39.434]                             if (is.null(name)) 
[13:21:39.434]                               next
[13:21:39.434]                             if (!grepl(pattern, name)) 
[13:21:39.434]                               next
[13:21:39.434]                             invokeRestart(restart)
[13:21:39.434]                             muffled <- TRUE
[13:21:39.434]                             break
[13:21:39.434]                           }
[13:21:39.434]                         }
[13:21:39.434]                       }
[13:21:39.434]                       invisible(muffled)
[13:21:39.434]                     }
[13:21:39.434]                     muffleCondition(cond, pattern = "^muffle")
[13:21:39.434]                   }
[13:21:39.434]                 }
[13:21:39.434]                 else {
[13:21:39.434]                   if (TRUE) {
[13:21:39.434]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.434]                     {
[13:21:39.434]                       inherits <- base::inherits
[13:21:39.434]                       invokeRestart <- base::invokeRestart
[13:21:39.434]                       is.null <- base::is.null
[13:21:39.434]                       muffled <- FALSE
[13:21:39.434]                       if (inherits(cond, "message")) {
[13:21:39.434]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:39.434]                         if (muffled) 
[13:21:39.434]                           invokeRestart("muffleMessage")
[13:21:39.434]                       }
[13:21:39.434]                       else if (inherits(cond, "warning")) {
[13:21:39.434]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:39.434]                         if (muffled) 
[13:21:39.434]                           invokeRestart("muffleWarning")
[13:21:39.434]                       }
[13:21:39.434]                       else if (inherits(cond, "condition")) {
[13:21:39.434]                         if (!is.null(pattern)) {
[13:21:39.434]                           computeRestarts <- base::computeRestarts
[13:21:39.434]                           grepl <- base::grepl
[13:21:39.434]                           restarts <- computeRestarts(cond)
[13:21:39.434]                           for (restart in restarts) {
[13:21:39.434]                             name <- restart$name
[13:21:39.434]                             if (is.null(name)) 
[13:21:39.434]                               next
[13:21:39.434]                             if (!grepl(pattern, name)) 
[13:21:39.434]                               next
[13:21:39.434]                             invokeRestart(restart)
[13:21:39.434]                             muffled <- TRUE
[13:21:39.434]                             break
[13:21:39.434]                           }
[13:21:39.434]                         }
[13:21:39.434]                       }
[13:21:39.434]                       invisible(muffled)
[13:21:39.434]                     }
[13:21:39.434]                     muffleCondition(cond, pattern = "^muffle")
[13:21:39.434]                   }
[13:21:39.434]                 }
[13:21:39.434]             }
[13:21:39.434]         }))
[13:21:39.434]     }, error = function(ex) {
[13:21:39.434]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:39.434]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:39.434]                 ...future.rng), started = ...future.startTime, 
[13:21:39.434]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:39.434]             version = "1.8"), class = "FutureResult")
[13:21:39.434]     }, finally = {
[13:21:39.434]         if (!identical(...future.workdir, getwd())) 
[13:21:39.434]             setwd(...future.workdir)
[13:21:39.434]         {
[13:21:39.434]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:39.434]                 ...future.oldOptions$nwarnings <- NULL
[13:21:39.434]             }
[13:21:39.434]             base::options(...future.oldOptions)
[13:21:39.434]             if (.Platform$OS.type == "windows") {
[13:21:39.434]                 old_names <- names(...future.oldEnvVars)
[13:21:39.434]                 envs <- base::Sys.getenv()
[13:21:39.434]                 names <- names(envs)
[13:21:39.434]                 common <- intersect(names, old_names)
[13:21:39.434]                 added <- setdiff(names, old_names)
[13:21:39.434]                 removed <- setdiff(old_names, names)
[13:21:39.434]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:39.434]                   envs[common]]
[13:21:39.434]                 NAMES <- toupper(changed)
[13:21:39.434]                 args <- list()
[13:21:39.434]                 for (kk in seq_along(NAMES)) {
[13:21:39.434]                   name <- changed[[kk]]
[13:21:39.434]                   NAME <- NAMES[[kk]]
[13:21:39.434]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.434]                     next
[13:21:39.434]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:39.434]                 }
[13:21:39.434]                 NAMES <- toupper(added)
[13:21:39.434]                 for (kk in seq_along(NAMES)) {
[13:21:39.434]                   name <- added[[kk]]
[13:21:39.434]                   NAME <- NAMES[[kk]]
[13:21:39.434]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.434]                     next
[13:21:39.434]                   args[[name]] <- ""
[13:21:39.434]                 }
[13:21:39.434]                 NAMES <- toupper(removed)
[13:21:39.434]                 for (kk in seq_along(NAMES)) {
[13:21:39.434]                   name <- removed[[kk]]
[13:21:39.434]                   NAME <- NAMES[[kk]]
[13:21:39.434]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.434]                     next
[13:21:39.434]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:39.434]                 }
[13:21:39.434]                 if (length(args) > 0) 
[13:21:39.434]                   base::do.call(base::Sys.setenv, args = args)
[13:21:39.434]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:39.434]             }
[13:21:39.434]             else {
[13:21:39.434]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:39.434]             }
[13:21:39.434]             {
[13:21:39.434]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:39.434]                   0L) {
[13:21:39.434]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:39.434]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:39.434]                   base::options(opts)
[13:21:39.434]                 }
[13:21:39.434]                 {
[13:21:39.434]                   {
[13:21:39.434]                     NULL
[13:21:39.434]                     RNGkind("Mersenne-Twister")
[13:21:39.434]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:39.434]                       inherits = FALSE)
[13:21:39.434]                   }
[13:21:39.434]                   options(future.plan = NULL)
[13:21:39.434]                   if (is.na(NA_character_)) 
[13:21:39.434]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:39.434]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:39.434]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:39.434]                   {
[13:21:39.434]                     future <- SequentialFuture(..., envir = envir)
[13:21:39.434]                     if (!future$lazy) 
[13:21:39.434]                       future <- run(future)
[13:21:39.434]                     invisible(future)
[13:21:39.434]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:39.434]                 }
[13:21:39.434]             }
[13:21:39.434]         }
[13:21:39.434]     })
[13:21:39.434]     if (TRUE) {
[13:21:39.434]         base::sink(type = "output", split = FALSE)
[13:21:39.434]         if (TRUE) {
[13:21:39.434]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:39.434]         }
[13:21:39.434]         else {
[13:21:39.434]             ...future.result["stdout"] <- base::list(NULL)
[13:21:39.434]         }
[13:21:39.434]         base::close(...future.stdout)
[13:21:39.434]         ...future.stdout <- NULL
[13:21:39.434]     }
[13:21:39.434]     ...future.result$conditions <- ...future.conditions
[13:21:39.434]     ...future.result$finished <- base::Sys.time()
[13:21:39.434]     ...future.result
[13:21:39.434] }
[13:21:39.436] plan(): Setting new future strategy stack:
[13:21:39.436] List of future strategies:
[13:21:39.436] 1. sequential:
[13:21:39.436]    - args: function (..., envir = parent.frame())
[13:21:39.436]    - tweaked: FALSE
[13:21:39.436]    - call: NULL
[13:21:39.436] plan(): nbrOfWorkers() = 1
[13:21:39.437] plan(): Setting new future strategy stack:
[13:21:39.437] List of future strategies:
[13:21:39.437] 1. sequential:
[13:21:39.437]    - args: function (..., envir = parent.frame())
[13:21:39.437]    - tweaked: FALSE
[13:21:39.437]    - call: plan(strategy)
[13:21:39.437] plan(): nbrOfWorkers() = 1
[13:21:39.437] SequentialFuture started (and completed)
[13:21:39.437] - Launch lazy future ... done
[13:21:39.438] run() for ‘SequentialFuture’ ... done
[13:21:39.438] getGlobalsAndPackages() ...
[13:21:39.438] Searching for globals...
[13:21:39.439] - globals found: [1] ‘{’
[13:21:39.439] Searching for globals ... DONE
[13:21:39.439] Resolving globals: FALSE
[13:21:39.439] 
[13:21:39.439] 
[13:21:39.439] getGlobalsAndPackages() ... DONE
[13:21:39.439] run() for ‘Future’ ...
[13:21:39.440] - state: ‘created’
[13:21:39.440] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:39.440] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:39.440] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:39.440]   - Field: ‘label’
[13:21:39.440]   - Field: ‘local’
[13:21:39.440]   - Field: ‘owner’
[13:21:39.440]   - Field: ‘envir’
[13:21:39.440]   - Field: ‘packages’
[13:21:39.441]   - Field: ‘gc’
[13:21:39.441]   - Field: ‘conditions’
[13:21:39.441]   - Field: ‘expr’
[13:21:39.441]   - Field: ‘uuid’
[13:21:39.441]   - Field: ‘seed’
[13:21:39.441]   - Field: ‘version’
[13:21:39.441]   - Field: ‘result’
[13:21:39.441]   - Field: ‘asynchronous’
[13:21:39.441]   - Field: ‘calls’
[13:21:39.441]   - Field: ‘globals’
[13:21:39.441]   - Field: ‘stdout’
[13:21:39.442]   - Field: ‘earlySignal’
[13:21:39.442]   - Field: ‘lazy’
[13:21:39.442]   - Field: ‘state’
[13:21:39.442] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:39.442] - Launch lazy future ...
[13:21:39.442] Packages needed by the future expression (n = 0): <none>
[13:21:39.442] Packages needed by future strategies (n = 0): <none>
[13:21:39.443] {
[13:21:39.443]     {
[13:21:39.443]         {
[13:21:39.443]             ...future.startTime <- base::Sys.time()
[13:21:39.443]             {
[13:21:39.443]                 {
[13:21:39.443]                   {
[13:21:39.443]                     base::local({
[13:21:39.443]                       has_future <- base::requireNamespace("future", 
[13:21:39.443]                         quietly = TRUE)
[13:21:39.443]                       if (has_future) {
[13:21:39.443]                         ns <- base::getNamespace("future")
[13:21:39.443]                         version <- ns[[".package"]][["version"]]
[13:21:39.443]                         if (is.null(version)) 
[13:21:39.443]                           version <- utils::packageVersion("future")
[13:21:39.443]                       }
[13:21:39.443]                       else {
[13:21:39.443]                         version <- NULL
[13:21:39.443]                       }
[13:21:39.443]                       if (!has_future || version < "1.8.0") {
[13:21:39.443]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:39.443]                           "", base::R.version$version.string), 
[13:21:39.443]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:39.443]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:39.443]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:39.443]                             "release", "version")], collapse = " "), 
[13:21:39.443]                           hostname = base::Sys.info()[["nodename"]])
[13:21:39.443]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:39.443]                           info)
[13:21:39.443]                         info <- base::paste(info, collapse = "; ")
[13:21:39.443]                         if (!has_future) {
[13:21:39.443]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:39.443]                             info)
[13:21:39.443]                         }
[13:21:39.443]                         else {
[13:21:39.443]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:39.443]                             info, version)
[13:21:39.443]                         }
[13:21:39.443]                         base::stop(msg)
[13:21:39.443]                       }
[13:21:39.443]                     })
[13:21:39.443]                   }
[13:21:39.443]                   options(future.plan = NULL)
[13:21:39.443]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:39.443]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:39.443]                 }
[13:21:39.443]                 ...future.workdir <- getwd()
[13:21:39.443]             }
[13:21:39.443]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:39.443]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:39.443]         }
[13:21:39.443]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:39.443]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:39.443]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:39.443]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:39.443]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:39.443]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:39.443]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:39.443]             base::names(...future.oldOptions))
[13:21:39.443]     }
[13:21:39.443]     if (FALSE) {
[13:21:39.443]     }
[13:21:39.443]     else {
[13:21:39.443]         if (TRUE) {
[13:21:39.443]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:39.443]                 open = "w")
[13:21:39.443]         }
[13:21:39.443]         else {
[13:21:39.443]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:39.443]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:39.443]         }
[13:21:39.443]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:39.443]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:39.443]             base::sink(type = "output", split = FALSE)
[13:21:39.443]             base::close(...future.stdout)
[13:21:39.443]         }, add = TRUE)
[13:21:39.443]     }
[13:21:39.443]     ...future.frame <- base::sys.nframe()
[13:21:39.443]     ...future.conditions <- base::list()
[13:21:39.443]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:39.443]     if (FALSE) {
[13:21:39.443]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:39.443]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:39.443]     }
[13:21:39.443]     ...future.result <- base::tryCatch({
[13:21:39.443]         base::withCallingHandlers({
[13:21:39.443]             ...future.value <- base::withVisible(base::local({
[13:21:39.443]                 2
[13:21:39.443]             }))
[13:21:39.443]             future::FutureResult(value = ...future.value$value, 
[13:21:39.443]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:39.443]                   ...future.rng), globalenv = if (FALSE) 
[13:21:39.443]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:39.443]                     ...future.globalenv.names))
[13:21:39.443]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:39.443]         }, condition = base::local({
[13:21:39.443]             c <- base::c
[13:21:39.443]             inherits <- base::inherits
[13:21:39.443]             invokeRestart <- base::invokeRestart
[13:21:39.443]             length <- base::length
[13:21:39.443]             list <- base::list
[13:21:39.443]             seq.int <- base::seq.int
[13:21:39.443]             signalCondition <- base::signalCondition
[13:21:39.443]             sys.calls <- base::sys.calls
[13:21:39.443]             `[[` <- base::`[[`
[13:21:39.443]             `+` <- base::`+`
[13:21:39.443]             `<<-` <- base::`<<-`
[13:21:39.443]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:39.443]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:39.443]                   3L)]
[13:21:39.443]             }
[13:21:39.443]             function(cond) {
[13:21:39.443]                 is_error <- inherits(cond, "error")
[13:21:39.443]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:39.443]                   NULL)
[13:21:39.443]                 if (is_error) {
[13:21:39.443]                   sessionInformation <- function() {
[13:21:39.443]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:39.443]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:39.443]                       search = base::search(), system = base::Sys.info())
[13:21:39.443]                   }
[13:21:39.443]                   ...future.conditions[[length(...future.conditions) + 
[13:21:39.443]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:39.443]                     cond$call), session = sessionInformation(), 
[13:21:39.443]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:39.443]                   signalCondition(cond)
[13:21:39.443]                 }
[13:21:39.443]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:39.443]                 "immediateCondition"))) {
[13:21:39.443]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:39.443]                   ...future.conditions[[length(...future.conditions) + 
[13:21:39.443]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:39.443]                   if (TRUE && !signal) {
[13:21:39.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.443]                     {
[13:21:39.443]                       inherits <- base::inherits
[13:21:39.443]                       invokeRestart <- base::invokeRestart
[13:21:39.443]                       is.null <- base::is.null
[13:21:39.443]                       muffled <- FALSE
[13:21:39.443]                       if (inherits(cond, "message")) {
[13:21:39.443]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:39.443]                         if (muffled) 
[13:21:39.443]                           invokeRestart("muffleMessage")
[13:21:39.443]                       }
[13:21:39.443]                       else if (inherits(cond, "warning")) {
[13:21:39.443]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:39.443]                         if (muffled) 
[13:21:39.443]                           invokeRestart("muffleWarning")
[13:21:39.443]                       }
[13:21:39.443]                       else if (inherits(cond, "condition")) {
[13:21:39.443]                         if (!is.null(pattern)) {
[13:21:39.443]                           computeRestarts <- base::computeRestarts
[13:21:39.443]                           grepl <- base::grepl
[13:21:39.443]                           restarts <- computeRestarts(cond)
[13:21:39.443]                           for (restart in restarts) {
[13:21:39.443]                             name <- restart$name
[13:21:39.443]                             if (is.null(name)) 
[13:21:39.443]                               next
[13:21:39.443]                             if (!grepl(pattern, name)) 
[13:21:39.443]                               next
[13:21:39.443]                             invokeRestart(restart)
[13:21:39.443]                             muffled <- TRUE
[13:21:39.443]                             break
[13:21:39.443]                           }
[13:21:39.443]                         }
[13:21:39.443]                       }
[13:21:39.443]                       invisible(muffled)
[13:21:39.443]                     }
[13:21:39.443]                     muffleCondition(cond, pattern = "^muffle")
[13:21:39.443]                   }
[13:21:39.443]                 }
[13:21:39.443]                 else {
[13:21:39.443]                   if (TRUE) {
[13:21:39.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.443]                     {
[13:21:39.443]                       inherits <- base::inherits
[13:21:39.443]                       invokeRestart <- base::invokeRestart
[13:21:39.443]                       is.null <- base::is.null
[13:21:39.443]                       muffled <- FALSE
[13:21:39.443]                       if (inherits(cond, "message")) {
[13:21:39.443]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:39.443]                         if (muffled) 
[13:21:39.443]                           invokeRestart("muffleMessage")
[13:21:39.443]                       }
[13:21:39.443]                       else if (inherits(cond, "warning")) {
[13:21:39.443]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:39.443]                         if (muffled) 
[13:21:39.443]                           invokeRestart("muffleWarning")
[13:21:39.443]                       }
[13:21:39.443]                       else if (inherits(cond, "condition")) {
[13:21:39.443]                         if (!is.null(pattern)) {
[13:21:39.443]                           computeRestarts <- base::computeRestarts
[13:21:39.443]                           grepl <- base::grepl
[13:21:39.443]                           restarts <- computeRestarts(cond)
[13:21:39.443]                           for (restart in restarts) {
[13:21:39.443]                             name <- restart$name
[13:21:39.443]                             if (is.null(name)) 
[13:21:39.443]                               next
[13:21:39.443]                             if (!grepl(pattern, name)) 
[13:21:39.443]                               next
[13:21:39.443]                             invokeRestart(restart)
[13:21:39.443]                             muffled <- TRUE
[13:21:39.443]                             break
[13:21:39.443]                           }
[13:21:39.443]                         }
[13:21:39.443]                       }
[13:21:39.443]                       invisible(muffled)
[13:21:39.443]                     }
[13:21:39.443]                     muffleCondition(cond, pattern = "^muffle")
[13:21:39.443]                   }
[13:21:39.443]                 }
[13:21:39.443]             }
[13:21:39.443]         }))
[13:21:39.443]     }, error = function(ex) {
[13:21:39.443]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:39.443]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:39.443]                 ...future.rng), started = ...future.startTime, 
[13:21:39.443]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:39.443]             version = "1.8"), class = "FutureResult")
[13:21:39.443]     }, finally = {
[13:21:39.443]         if (!identical(...future.workdir, getwd())) 
[13:21:39.443]             setwd(...future.workdir)
[13:21:39.443]         {
[13:21:39.443]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:39.443]                 ...future.oldOptions$nwarnings <- NULL
[13:21:39.443]             }
[13:21:39.443]             base::options(...future.oldOptions)
[13:21:39.443]             if (.Platform$OS.type == "windows") {
[13:21:39.443]                 old_names <- names(...future.oldEnvVars)
[13:21:39.443]                 envs <- base::Sys.getenv()
[13:21:39.443]                 names <- names(envs)
[13:21:39.443]                 common <- intersect(names, old_names)
[13:21:39.443]                 added <- setdiff(names, old_names)
[13:21:39.443]                 removed <- setdiff(old_names, names)
[13:21:39.443]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:39.443]                   envs[common]]
[13:21:39.443]                 NAMES <- toupper(changed)
[13:21:39.443]                 args <- list()
[13:21:39.443]                 for (kk in seq_along(NAMES)) {
[13:21:39.443]                   name <- changed[[kk]]
[13:21:39.443]                   NAME <- NAMES[[kk]]
[13:21:39.443]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.443]                     next
[13:21:39.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:39.443]                 }
[13:21:39.443]                 NAMES <- toupper(added)
[13:21:39.443]                 for (kk in seq_along(NAMES)) {
[13:21:39.443]                   name <- added[[kk]]
[13:21:39.443]                   NAME <- NAMES[[kk]]
[13:21:39.443]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.443]                     next
[13:21:39.443]                   args[[name]] <- ""
[13:21:39.443]                 }
[13:21:39.443]                 NAMES <- toupper(removed)
[13:21:39.443]                 for (kk in seq_along(NAMES)) {
[13:21:39.443]                   name <- removed[[kk]]
[13:21:39.443]                   NAME <- NAMES[[kk]]
[13:21:39.443]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.443]                     next
[13:21:39.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:39.443]                 }
[13:21:39.443]                 if (length(args) > 0) 
[13:21:39.443]                   base::do.call(base::Sys.setenv, args = args)
[13:21:39.443]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:39.443]             }
[13:21:39.443]             else {
[13:21:39.443]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:39.443]             }
[13:21:39.443]             {
[13:21:39.443]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:39.443]                   0L) {
[13:21:39.443]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:39.443]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:39.443]                   base::options(opts)
[13:21:39.443]                 }
[13:21:39.443]                 {
[13:21:39.443]                   {
[13:21:39.443]                     NULL
[13:21:39.443]                     RNGkind("Mersenne-Twister")
[13:21:39.443]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:39.443]                       inherits = FALSE)
[13:21:39.443]                   }
[13:21:39.443]                   options(future.plan = NULL)
[13:21:39.443]                   if (is.na(NA_character_)) 
[13:21:39.443]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:39.443]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:39.443]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:39.443]                   {
[13:21:39.443]                     future <- SequentialFuture(..., envir = envir)
[13:21:39.443]                     if (!future$lazy) 
[13:21:39.443]                       future <- run(future)
[13:21:39.443]                     invisible(future)
[13:21:39.443]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:39.443]                 }
[13:21:39.443]             }
[13:21:39.443]         }
[13:21:39.443]     })
[13:21:39.443]     if (TRUE) {
[13:21:39.443]         base::sink(type = "output", split = FALSE)
[13:21:39.443]         if (TRUE) {
[13:21:39.443]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:39.443]         }
[13:21:39.443]         else {
[13:21:39.443]             ...future.result["stdout"] <- base::list(NULL)
[13:21:39.443]         }
[13:21:39.443]         base::close(...future.stdout)
[13:21:39.443]         ...future.stdout <- NULL
[13:21:39.443]     }
[13:21:39.443]     ...future.result$conditions <- ...future.conditions
[13:21:39.443]     ...future.result$finished <- base::Sys.time()
[13:21:39.443]     ...future.result
[13:21:39.443] }
[13:21:39.444] plan(): Setting new future strategy stack:
[13:21:39.444] List of future strategies:
[13:21:39.444] 1. sequential:
[13:21:39.444]    - args: function (..., envir = parent.frame())
[13:21:39.444]    - tweaked: FALSE
[13:21:39.444]    - call: NULL
[13:21:39.445] plan(): nbrOfWorkers() = 1
[13:21:39.446] plan(): Setting new future strategy stack:
[13:21:39.446] List of future strategies:
[13:21:39.446] 1. sequential:
[13:21:39.446]    - args: function (..., envir = parent.frame())
[13:21:39.446]    - tweaked: FALSE
[13:21:39.446]    - call: plan(strategy)
[13:21:39.446] plan(): nbrOfWorkers() = 1
[13:21:39.446] SequentialFuture started (and completed)
[13:21:39.448] - Launch lazy future ... done
[13:21:39.448] run() for ‘SequentialFuture’ ... done
[13:21:39.449] resolve() on environment ...
[13:21:39.449]  recursive: 0
[13:21:39.449]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[13:21:39.449] resolved() for ‘SequentialFuture’ ...
[13:21:39.450] - state: ‘finished’
[13:21:39.450] - run: TRUE
[13:21:39.450] - result: ‘FutureResult’
[13:21:39.450] resolved() for ‘SequentialFuture’ ... done
[13:21:39.450] Future #1
[13:21:39.450]  length: 2 (resolved future 1)
[13:21:39.450] resolved() for ‘SequentialFuture’ ...
[13:21:39.450] - state: ‘finished’
[13:21:39.450] - run: TRUE
[13:21:39.451] - result: ‘FutureResult’
[13:21:39.451] resolved() for ‘SequentialFuture’ ... done
[13:21:39.451] Future #2
[13:21:39.451]  length: 1 (resolved future 2)
[13:21:39.451]  length: 0 (resolved future 3)
[13:21:39.451] resolve() on environment ... DONE
[13:21:39.451] getGlobalsAndPackages() ...
[13:21:39.452] Searching for globals...
[13:21:39.452] - globals found: [1] ‘{’
[13:21:39.452] Searching for globals ... DONE
[13:21:39.452] Resolving globals: FALSE
[13:21:39.453] 
[13:21:39.453] 
[13:21:39.453] getGlobalsAndPackages() ... DONE
[13:21:39.453] run() for ‘Future’ ...
[13:21:39.453] - state: ‘created’
[13:21:39.453] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:39.454] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:39.454] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:39.454]   - Field: ‘label’
[13:21:39.454]   - Field: ‘local’
[13:21:39.454]   - Field: ‘owner’
[13:21:39.454]   - Field: ‘envir’
[13:21:39.454]   - Field: ‘packages’
[13:21:39.454]   - Field: ‘gc’
[13:21:39.454]   - Field: ‘conditions’
[13:21:39.454]   - Field: ‘expr’
[13:21:39.455]   - Field: ‘uuid’
[13:21:39.455]   - Field: ‘seed’
[13:21:39.455]   - Field: ‘version’
[13:21:39.455]   - Field: ‘result’
[13:21:39.455]   - Field: ‘asynchronous’
[13:21:39.455]   - Field: ‘calls’
[13:21:39.455]   - Field: ‘globals’
[13:21:39.455]   - Field: ‘stdout’
[13:21:39.455]   - Field: ‘earlySignal’
[13:21:39.455]   - Field: ‘lazy’
[13:21:39.455]   - Field: ‘state’
[13:21:39.456] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:39.456] - Launch lazy future ...
[13:21:39.456] Packages needed by the future expression (n = 0): <none>
[13:21:39.456] Packages needed by future strategies (n = 0): <none>
[13:21:39.456] {
[13:21:39.456]     {
[13:21:39.456]         {
[13:21:39.456]             ...future.startTime <- base::Sys.time()
[13:21:39.456]             {
[13:21:39.456]                 {
[13:21:39.456]                   {
[13:21:39.456]                     base::local({
[13:21:39.456]                       has_future <- base::requireNamespace("future", 
[13:21:39.456]                         quietly = TRUE)
[13:21:39.456]                       if (has_future) {
[13:21:39.456]                         ns <- base::getNamespace("future")
[13:21:39.456]                         version <- ns[[".package"]][["version"]]
[13:21:39.456]                         if (is.null(version)) 
[13:21:39.456]                           version <- utils::packageVersion("future")
[13:21:39.456]                       }
[13:21:39.456]                       else {
[13:21:39.456]                         version <- NULL
[13:21:39.456]                       }
[13:21:39.456]                       if (!has_future || version < "1.8.0") {
[13:21:39.456]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:39.456]                           "", base::R.version$version.string), 
[13:21:39.456]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:39.456]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:39.456]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:39.456]                             "release", "version")], collapse = " "), 
[13:21:39.456]                           hostname = base::Sys.info()[["nodename"]])
[13:21:39.456]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:39.456]                           info)
[13:21:39.456]                         info <- base::paste(info, collapse = "; ")
[13:21:39.456]                         if (!has_future) {
[13:21:39.456]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:39.456]                             info)
[13:21:39.456]                         }
[13:21:39.456]                         else {
[13:21:39.456]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:39.456]                             info, version)
[13:21:39.456]                         }
[13:21:39.456]                         base::stop(msg)
[13:21:39.456]                       }
[13:21:39.456]                     })
[13:21:39.456]                   }
[13:21:39.456]                   options(future.plan = NULL)
[13:21:39.456]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:39.456]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:39.456]                 }
[13:21:39.456]                 ...future.workdir <- getwd()
[13:21:39.456]             }
[13:21:39.456]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:39.456]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:39.456]         }
[13:21:39.456]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:39.456]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:39.456]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:39.456]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:39.456]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:39.456]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:39.456]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:39.456]             base::names(...future.oldOptions))
[13:21:39.456]     }
[13:21:39.456]     if (FALSE) {
[13:21:39.456]     }
[13:21:39.456]     else {
[13:21:39.456]         if (TRUE) {
[13:21:39.456]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:39.456]                 open = "w")
[13:21:39.456]         }
[13:21:39.456]         else {
[13:21:39.456]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:39.456]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:39.456]         }
[13:21:39.456]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:39.456]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:39.456]             base::sink(type = "output", split = FALSE)
[13:21:39.456]             base::close(...future.stdout)
[13:21:39.456]         }, add = TRUE)
[13:21:39.456]     }
[13:21:39.456]     ...future.frame <- base::sys.nframe()
[13:21:39.456]     ...future.conditions <- base::list()
[13:21:39.456]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:39.456]     if (FALSE) {
[13:21:39.456]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:39.456]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:39.456]     }
[13:21:39.456]     ...future.result <- base::tryCatch({
[13:21:39.456]         base::withCallingHandlers({
[13:21:39.456]             ...future.value <- base::withVisible(base::local({
[13:21:39.456]                 1
[13:21:39.456]             }))
[13:21:39.456]             future::FutureResult(value = ...future.value$value, 
[13:21:39.456]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:39.456]                   ...future.rng), globalenv = if (FALSE) 
[13:21:39.456]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:39.456]                     ...future.globalenv.names))
[13:21:39.456]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:39.456]         }, condition = base::local({
[13:21:39.456]             c <- base::c
[13:21:39.456]             inherits <- base::inherits
[13:21:39.456]             invokeRestart <- base::invokeRestart
[13:21:39.456]             length <- base::length
[13:21:39.456]             list <- base::list
[13:21:39.456]             seq.int <- base::seq.int
[13:21:39.456]             signalCondition <- base::signalCondition
[13:21:39.456]             sys.calls <- base::sys.calls
[13:21:39.456]             `[[` <- base::`[[`
[13:21:39.456]             `+` <- base::`+`
[13:21:39.456]             `<<-` <- base::`<<-`
[13:21:39.456]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:39.456]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:39.456]                   3L)]
[13:21:39.456]             }
[13:21:39.456]             function(cond) {
[13:21:39.456]                 is_error <- inherits(cond, "error")
[13:21:39.456]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:39.456]                   NULL)
[13:21:39.456]                 if (is_error) {
[13:21:39.456]                   sessionInformation <- function() {
[13:21:39.456]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:39.456]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:39.456]                       search = base::search(), system = base::Sys.info())
[13:21:39.456]                   }
[13:21:39.456]                   ...future.conditions[[length(...future.conditions) + 
[13:21:39.456]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:39.456]                     cond$call), session = sessionInformation(), 
[13:21:39.456]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:39.456]                   signalCondition(cond)
[13:21:39.456]                 }
[13:21:39.456]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:39.456]                 "immediateCondition"))) {
[13:21:39.456]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:39.456]                   ...future.conditions[[length(...future.conditions) + 
[13:21:39.456]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:39.456]                   if (TRUE && !signal) {
[13:21:39.456]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.456]                     {
[13:21:39.456]                       inherits <- base::inherits
[13:21:39.456]                       invokeRestart <- base::invokeRestart
[13:21:39.456]                       is.null <- base::is.null
[13:21:39.456]                       muffled <- FALSE
[13:21:39.456]                       if (inherits(cond, "message")) {
[13:21:39.456]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:39.456]                         if (muffled) 
[13:21:39.456]                           invokeRestart("muffleMessage")
[13:21:39.456]                       }
[13:21:39.456]                       else if (inherits(cond, "warning")) {
[13:21:39.456]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:39.456]                         if (muffled) 
[13:21:39.456]                           invokeRestart("muffleWarning")
[13:21:39.456]                       }
[13:21:39.456]                       else if (inherits(cond, "condition")) {
[13:21:39.456]                         if (!is.null(pattern)) {
[13:21:39.456]                           computeRestarts <- base::computeRestarts
[13:21:39.456]                           grepl <- base::grepl
[13:21:39.456]                           restarts <- computeRestarts(cond)
[13:21:39.456]                           for (restart in restarts) {
[13:21:39.456]                             name <- restart$name
[13:21:39.456]                             if (is.null(name)) 
[13:21:39.456]                               next
[13:21:39.456]                             if (!grepl(pattern, name)) 
[13:21:39.456]                               next
[13:21:39.456]                             invokeRestart(restart)
[13:21:39.456]                             muffled <- TRUE
[13:21:39.456]                             break
[13:21:39.456]                           }
[13:21:39.456]                         }
[13:21:39.456]                       }
[13:21:39.456]                       invisible(muffled)
[13:21:39.456]                     }
[13:21:39.456]                     muffleCondition(cond, pattern = "^muffle")
[13:21:39.456]                   }
[13:21:39.456]                 }
[13:21:39.456]                 else {
[13:21:39.456]                   if (TRUE) {
[13:21:39.456]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.456]                     {
[13:21:39.456]                       inherits <- base::inherits
[13:21:39.456]                       invokeRestart <- base::invokeRestart
[13:21:39.456]                       is.null <- base::is.null
[13:21:39.456]                       muffled <- FALSE
[13:21:39.456]                       if (inherits(cond, "message")) {
[13:21:39.456]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:39.456]                         if (muffled) 
[13:21:39.456]                           invokeRestart("muffleMessage")
[13:21:39.456]                       }
[13:21:39.456]                       else if (inherits(cond, "warning")) {
[13:21:39.456]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:39.456]                         if (muffled) 
[13:21:39.456]                           invokeRestart("muffleWarning")
[13:21:39.456]                       }
[13:21:39.456]                       else if (inherits(cond, "condition")) {
[13:21:39.456]                         if (!is.null(pattern)) {
[13:21:39.456]                           computeRestarts <- base::computeRestarts
[13:21:39.456]                           grepl <- base::grepl
[13:21:39.456]                           restarts <- computeRestarts(cond)
[13:21:39.456]                           for (restart in restarts) {
[13:21:39.456]                             name <- restart$name
[13:21:39.456]                             if (is.null(name)) 
[13:21:39.456]                               next
[13:21:39.456]                             if (!grepl(pattern, name)) 
[13:21:39.456]                               next
[13:21:39.456]                             invokeRestart(restart)
[13:21:39.456]                             muffled <- TRUE
[13:21:39.456]                             break
[13:21:39.456]                           }
[13:21:39.456]                         }
[13:21:39.456]                       }
[13:21:39.456]                       invisible(muffled)
[13:21:39.456]                     }
[13:21:39.456]                     muffleCondition(cond, pattern = "^muffle")
[13:21:39.456]                   }
[13:21:39.456]                 }
[13:21:39.456]             }
[13:21:39.456]         }))
[13:21:39.456]     }, error = function(ex) {
[13:21:39.456]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:39.456]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:39.456]                 ...future.rng), started = ...future.startTime, 
[13:21:39.456]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:39.456]             version = "1.8"), class = "FutureResult")
[13:21:39.456]     }, finally = {
[13:21:39.456]         if (!identical(...future.workdir, getwd())) 
[13:21:39.456]             setwd(...future.workdir)
[13:21:39.456]         {
[13:21:39.456]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:39.456]                 ...future.oldOptions$nwarnings <- NULL
[13:21:39.456]             }
[13:21:39.456]             base::options(...future.oldOptions)
[13:21:39.456]             if (.Platform$OS.type == "windows") {
[13:21:39.456]                 old_names <- names(...future.oldEnvVars)
[13:21:39.456]                 envs <- base::Sys.getenv()
[13:21:39.456]                 names <- names(envs)
[13:21:39.456]                 common <- intersect(names, old_names)
[13:21:39.456]                 added <- setdiff(names, old_names)
[13:21:39.456]                 removed <- setdiff(old_names, names)
[13:21:39.456]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:39.456]                   envs[common]]
[13:21:39.456]                 NAMES <- toupper(changed)
[13:21:39.456]                 args <- list()
[13:21:39.456]                 for (kk in seq_along(NAMES)) {
[13:21:39.456]                   name <- changed[[kk]]
[13:21:39.456]                   NAME <- NAMES[[kk]]
[13:21:39.456]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.456]                     next
[13:21:39.456]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:39.456]                 }
[13:21:39.456]                 NAMES <- toupper(added)
[13:21:39.456]                 for (kk in seq_along(NAMES)) {
[13:21:39.456]                   name <- added[[kk]]
[13:21:39.456]                   NAME <- NAMES[[kk]]
[13:21:39.456]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.456]                     next
[13:21:39.456]                   args[[name]] <- ""
[13:21:39.456]                 }
[13:21:39.456]                 NAMES <- toupper(removed)
[13:21:39.456]                 for (kk in seq_along(NAMES)) {
[13:21:39.456]                   name <- removed[[kk]]
[13:21:39.456]                   NAME <- NAMES[[kk]]
[13:21:39.456]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.456]                     next
[13:21:39.456]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:39.456]                 }
[13:21:39.456]                 if (length(args) > 0) 
[13:21:39.456]                   base::do.call(base::Sys.setenv, args = args)
[13:21:39.456]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:39.456]             }
[13:21:39.456]             else {
[13:21:39.456]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:39.456]             }
[13:21:39.456]             {
[13:21:39.456]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:39.456]                   0L) {
[13:21:39.456]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:39.456]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:39.456]                   base::options(opts)
[13:21:39.456]                 }
[13:21:39.456]                 {
[13:21:39.456]                   {
[13:21:39.456]                     NULL
[13:21:39.456]                     RNGkind("Mersenne-Twister")
[13:21:39.456]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:39.456]                       inherits = FALSE)
[13:21:39.456]                   }
[13:21:39.456]                   options(future.plan = NULL)
[13:21:39.456]                   if (is.na(NA_character_)) 
[13:21:39.456]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:39.456]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:39.456]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:39.456]                   {
[13:21:39.456]                     future <- SequentialFuture(..., envir = envir)
[13:21:39.456]                     if (!future$lazy) 
[13:21:39.456]                       future <- run(future)
[13:21:39.456]                     invisible(future)
[13:21:39.456]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:39.456]                 }
[13:21:39.456]             }
[13:21:39.456]         }
[13:21:39.456]     })
[13:21:39.456]     if (TRUE) {
[13:21:39.456]         base::sink(type = "output", split = FALSE)
[13:21:39.456]         if (TRUE) {
[13:21:39.456]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:39.456]         }
[13:21:39.456]         else {
[13:21:39.456]             ...future.result["stdout"] <- base::list(NULL)
[13:21:39.456]         }
[13:21:39.456]         base::close(...future.stdout)
[13:21:39.456]         ...future.stdout <- NULL
[13:21:39.456]     }
[13:21:39.456]     ...future.result$conditions <- ...future.conditions
[13:21:39.456]     ...future.result$finished <- base::Sys.time()
[13:21:39.456]     ...future.result
[13:21:39.456] }
[13:21:39.458] plan(): Setting new future strategy stack:
[13:21:39.458] List of future strategies:
[13:21:39.458] 1. sequential:
[13:21:39.458]    - args: function (..., envir = parent.frame())
[13:21:39.458]    - tweaked: FALSE
[13:21:39.458]    - call: NULL
[13:21:39.459] plan(): nbrOfWorkers() = 1
[13:21:39.460] plan(): Setting new future strategy stack:
[13:21:39.460] List of future strategies:
[13:21:39.460] 1. sequential:
[13:21:39.460]    - args: function (..., envir = parent.frame())
[13:21:39.460]    - tweaked: FALSE
[13:21:39.460]    - call: plan(strategy)
[13:21:39.460] plan(): nbrOfWorkers() = 1
[13:21:39.460] SequentialFuture started (and completed)
[13:21:39.460] - Launch lazy future ... done
[13:21:39.460] run() for ‘SequentialFuture’ ... done
[13:21:39.461] getGlobalsAndPackages() ...
[13:21:39.461] Searching for globals...
[13:21:39.461] - globals found: [1] ‘{’
[13:21:39.461] Searching for globals ... DONE
[13:21:39.462] Resolving globals: FALSE
[13:21:39.462] 
[13:21:39.462] 
[13:21:39.462] getGlobalsAndPackages() ... DONE
[13:21:39.462] run() for ‘Future’ ...
[13:21:39.462] - state: ‘created’
[13:21:39.462] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:39.463] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:39.463] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:39.463]   - Field: ‘label’
[13:21:39.463]   - Field: ‘local’
[13:21:39.463]   - Field: ‘owner’
[13:21:39.463]   - Field: ‘envir’
[13:21:39.463]   - Field: ‘packages’
[13:21:39.463]   - Field: ‘gc’
[13:21:39.464]   - Field: ‘conditions’
[13:21:39.464]   - Field: ‘expr’
[13:21:39.464]   - Field: ‘uuid’
[13:21:39.464]   - Field: ‘seed’
[13:21:39.464]   - Field: ‘version’
[13:21:39.464]   - Field: ‘result’
[13:21:39.464]   - Field: ‘asynchronous’
[13:21:39.464]   - Field: ‘calls’
[13:21:39.464]   - Field: ‘globals’
[13:21:39.464]   - Field: ‘stdout’
[13:21:39.464]   - Field: ‘earlySignal’
[13:21:39.465]   - Field: ‘lazy’
[13:21:39.465]   - Field: ‘state’
[13:21:39.465] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:39.465] - Launch lazy future ...
[13:21:39.465] Packages needed by the future expression (n = 0): <none>
[13:21:39.465] Packages needed by future strategies (n = 0): <none>
[13:21:39.466] {
[13:21:39.466]     {
[13:21:39.466]         {
[13:21:39.466]             ...future.startTime <- base::Sys.time()
[13:21:39.466]             {
[13:21:39.466]                 {
[13:21:39.466]                   {
[13:21:39.466]                     base::local({
[13:21:39.466]                       has_future <- base::requireNamespace("future", 
[13:21:39.466]                         quietly = TRUE)
[13:21:39.466]                       if (has_future) {
[13:21:39.466]                         ns <- base::getNamespace("future")
[13:21:39.466]                         version <- ns[[".package"]][["version"]]
[13:21:39.466]                         if (is.null(version)) 
[13:21:39.466]                           version <- utils::packageVersion("future")
[13:21:39.466]                       }
[13:21:39.466]                       else {
[13:21:39.466]                         version <- NULL
[13:21:39.466]                       }
[13:21:39.466]                       if (!has_future || version < "1.8.0") {
[13:21:39.466]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:39.466]                           "", base::R.version$version.string), 
[13:21:39.466]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:39.466]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:39.466]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:39.466]                             "release", "version")], collapse = " "), 
[13:21:39.466]                           hostname = base::Sys.info()[["nodename"]])
[13:21:39.466]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:39.466]                           info)
[13:21:39.466]                         info <- base::paste(info, collapse = "; ")
[13:21:39.466]                         if (!has_future) {
[13:21:39.466]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:39.466]                             info)
[13:21:39.466]                         }
[13:21:39.466]                         else {
[13:21:39.466]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:39.466]                             info, version)
[13:21:39.466]                         }
[13:21:39.466]                         base::stop(msg)
[13:21:39.466]                       }
[13:21:39.466]                     })
[13:21:39.466]                   }
[13:21:39.466]                   options(future.plan = NULL)
[13:21:39.466]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:39.466]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:39.466]                 }
[13:21:39.466]                 ...future.workdir <- getwd()
[13:21:39.466]             }
[13:21:39.466]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:39.466]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:39.466]         }
[13:21:39.466]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:39.466]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:39.466]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:39.466]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:39.466]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:39.466]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:39.466]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:39.466]             base::names(...future.oldOptions))
[13:21:39.466]     }
[13:21:39.466]     if (FALSE) {
[13:21:39.466]     }
[13:21:39.466]     else {
[13:21:39.466]         if (TRUE) {
[13:21:39.466]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:39.466]                 open = "w")
[13:21:39.466]         }
[13:21:39.466]         else {
[13:21:39.466]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:39.466]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:39.466]         }
[13:21:39.466]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:39.466]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:39.466]             base::sink(type = "output", split = FALSE)
[13:21:39.466]             base::close(...future.stdout)
[13:21:39.466]         }, add = TRUE)
[13:21:39.466]     }
[13:21:39.466]     ...future.frame <- base::sys.nframe()
[13:21:39.466]     ...future.conditions <- base::list()
[13:21:39.466]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:39.466]     if (FALSE) {
[13:21:39.466]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:39.466]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:39.466]     }
[13:21:39.466]     ...future.result <- base::tryCatch({
[13:21:39.466]         base::withCallingHandlers({
[13:21:39.466]             ...future.value <- base::withVisible(base::local({
[13:21:39.466]                 2
[13:21:39.466]             }))
[13:21:39.466]             future::FutureResult(value = ...future.value$value, 
[13:21:39.466]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:39.466]                   ...future.rng), globalenv = if (FALSE) 
[13:21:39.466]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:39.466]                     ...future.globalenv.names))
[13:21:39.466]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:39.466]         }, condition = base::local({
[13:21:39.466]             c <- base::c
[13:21:39.466]             inherits <- base::inherits
[13:21:39.466]             invokeRestart <- base::invokeRestart
[13:21:39.466]             length <- base::length
[13:21:39.466]             list <- base::list
[13:21:39.466]             seq.int <- base::seq.int
[13:21:39.466]             signalCondition <- base::signalCondition
[13:21:39.466]             sys.calls <- base::sys.calls
[13:21:39.466]             `[[` <- base::`[[`
[13:21:39.466]             `+` <- base::`+`
[13:21:39.466]             `<<-` <- base::`<<-`
[13:21:39.466]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:39.466]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:39.466]                   3L)]
[13:21:39.466]             }
[13:21:39.466]             function(cond) {
[13:21:39.466]                 is_error <- inherits(cond, "error")
[13:21:39.466]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:39.466]                   NULL)
[13:21:39.466]                 if (is_error) {
[13:21:39.466]                   sessionInformation <- function() {
[13:21:39.466]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:39.466]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:39.466]                       search = base::search(), system = base::Sys.info())
[13:21:39.466]                   }
[13:21:39.466]                   ...future.conditions[[length(...future.conditions) + 
[13:21:39.466]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:39.466]                     cond$call), session = sessionInformation(), 
[13:21:39.466]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:39.466]                   signalCondition(cond)
[13:21:39.466]                 }
[13:21:39.466]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:39.466]                 "immediateCondition"))) {
[13:21:39.466]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:39.466]                   ...future.conditions[[length(...future.conditions) + 
[13:21:39.466]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:39.466]                   if (TRUE && !signal) {
[13:21:39.466]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.466]                     {
[13:21:39.466]                       inherits <- base::inherits
[13:21:39.466]                       invokeRestart <- base::invokeRestart
[13:21:39.466]                       is.null <- base::is.null
[13:21:39.466]                       muffled <- FALSE
[13:21:39.466]                       if (inherits(cond, "message")) {
[13:21:39.466]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:39.466]                         if (muffled) 
[13:21:39.466]                           invokeRestart("muffleMessage")
[13:21:39.466]                       }
[13:21:39.466]                       else if (inherits(cond, "warning")) {
[13:21:39.466]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:39.466]                         if (muffled) 
[13:21:39.466]                           invokeRestart("muffleWarning")
[13:21:39.466]                       }
[13:21:39.466]                       else if (inherits(cond, "condition")) {
[13:21:39.466]                         if (!is.null(pattern)) {
[13:21:39.466]                           computeRestarts <- base::computeRestarts
[13:21:39.466]                           grepl <- base::grepl
[13:21:39.466]                           restarts <- computeRestarts(cond)
[13:21:39.466]                           for (restart in restarts) {
[13:21:39.466]                             name <- restart$name
[13:21:39.466]                             if (is.null(name)) 
[13:21:39.466]                               next
[13:21:39.466]                             if (!grepl(pattern, name)) 
[13:21:39.466]                               next
[13:21:39.466]                             invokeRestart(restart)
[13:21:39.466]                             muffled <- TRUE
[13:21:39.466]                             break
[13:21:39.466]                           }
[13:21:39.466]                         }
[13:21:39.466]                       }
[13:21:39.466]                       invisible(muffled)
[13:21:39.466]                     }
[13:21:39.466]                     muffleCondition(cond, pattern = "^muffle")
[13:21:39.466]                   }
[13:21:39.466]                 }
[13:21:39.466]                 else {
[13:21:39.466]                   if (TRUE) {
[13:21:39.466]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.466]                     {
[13:21:39.466]                       inherits <- base::inherits
[13:21:39.466]                       invokeRestart <- base::invokeRestart
[13:21:39.466]                       is.null <- base::is.null
[13:21:39.466]                       muffled <- FALSE
[13:21:39.466]                       if (inherits(cond, "message")) {
[13:21:39.466]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:39.466]                         if (muffled) 
[13:21:39.466]                           invokeRestart("muffleMessage")
[13:21:39.466]                       }
[13:21:39.466]                       else if (inherits(cond, "warning")) {
[13:21:39.466]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:39.466]                         if (muffled) 
[13:21:39.466]                           invokeRestart("muffleWarning")
[13:21:39.466]                       }
[13:21:39.466]                       else if (inherits(cond, "condition")) {
[13:21:39.466]                         if (!is.null(pattern)) {
[13:21:39.466]                           computeRestarts <- base::computeRestarts
[13:21:39.466]                           grepl <- base::grepl
[13:21:39.466]                           restarts <- computeRestarts(cond)
[13:21:39.466]                           for (restart in restarts) {
[13:21:39.466]                             name <- restart$name
[13:21:39.466]                             if (is.null(name)) 
[13:21:39.466]                               next
[13:21:39.466]                             if (!grepl(pattern, name)) 
[13:21:39.466]                               next
[13:21:39.466]                             invokeRestart(restart)
[13:21:39.466]                             muffled <- TRUE
[13:21:39.466]                             break
[13:21:39.466]                           }
[13:21:39.466]                         }
[13:21:39.466]                       }
[13:21:39.466]                       invisible(muffled)
[13:21:39.466]                     }
[13:21:39.466]                     muffleCondition(cond, pattern = "^muffle")
[13:21:39.466]                   }
[13:21:39.466]                 }
[13:21:39.466]             }
[13:21:39.466]         }))
[13:21:39.466]     }, error = function(ex) {
[13:21:39.466]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:39.466]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:39.466]                 ...future.rng), started = ...future.startTime, 
[13:21:39.466]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:39.466]             version = "1.8"), class = "FutureResult")
[13:21:39.466]     }, finally = {
[13:21:39.466]         if (!identical(...future.workdir, getwd())) 
[13:21:39.466]             setwd(...future.workdir)
[13:21:39.466]         {
[13:21:39.466]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:39.466]                 ...future.oldOptions$nwarnings <- NULL
[13:21:39.466]             }
[13:21:39.466]             base::options(...future.oldOptions)
[13:21:39.466]             if (.Platform$OS.type == "windows") {
[13:21:39.466]                 old_names <- names(...future.oldEnvVars)
[13:21:39.466]                 envs <- base::Sys.getenv()
[13:21:39.466]                 names <- names(envs)
[13:21:39.466]                 common <- intersect(names, old_names)
[13:21:39.466]                 added <- setdiff(names, old_names)
[13:21:39.466]                 removed <- setdiff(old_names, names)
[13:21:39.466]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:39.466]                   envs[common]]
[13:21:39.466]                 NAMES <- toupper(changed)
[13:21:39.466]                 args <- list()
[13:21:39.466]                 for (kk in seq_along(NAMES)) {
[13:21:39.466]                   name <- changed[[kk]]
[13:21:39.466]                   NAME <- NAMES[[kk]]
[13:21:39.466]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.466]                     next
[13:21:39.466]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:39.466]                 }
[13:21:39.466]                 NAMES <- toupper(added)
[13:21:39.466]                 for (kk in seq_along(NAMES)) {
[13:21:39.466]                   name <- added[[kk]]
[13:21:39.466]                   NAME <- NAMES[[kk]]
[13:21:39.466]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.466]                     next
[13:21:39.466]                   args[[name]] <- ""
[13:21:39.466]                 }
[13:21:39.466]                 NAMES <- toupper(removed)
[13:21:39.466]                 for (kk in seq_along(NAMES)) {
[13:21:39.466]                   name <- removed[[kk]]
[13:21:39.466]                   NAME <- NAMES[[kk]]
[13:21:39.466]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.466]                     next
[13:21:39.466]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:39.466]                 }
[13:21:39.466]                 if (length(args) > 0) 
[13:21:39.466]                   base::do.call(base::Sys.setenv, args = args)
[13:21:39.466]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:39.466]             }
[13:21:39.466]             else {
[13:21:39.466]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:39.466]             }
[13:21:39.466]             {
[13:21:39.466]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:39.466]                   0L) {
[13:21:39.466]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:39.466]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:39.466]                   base::options(opts)
[13:21:39.466]                 }
[13:21:39.466]                 {
[13:21:39.466]                   {
[13:21:39.466]                     NULL
[13:21:39.466]                     RNGkind("Mersenne-Twister")
[13:21:39.466]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:39.466]                       inherits = FALSE)
[13:21:39.466]                   }
[13:21:39.466]                   options(future.plan = NULL)
[13:21:39.466]                   if (is.na(NA_character_)) 
[13:21:39.466]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:39.466]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:39.466]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:39.466]                   {
[13:21:39.466]                     future <- SequentialFuture(..., envir = envir)
[13:21:39.466]                     if (!future$lazy) 
[13:21:39.466]                       future <- run(future)
[13:21:39.466]                     invisible(future)
[13:21:39.466]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:39.466]                 }
[13:21:39.466]             }
[13:21:39.466]         }
[13:21:39.466]     })
[13:21:39.466]     if (TRUE) {
[13:21:39.466]         base::sink(type = "output", split = FALSE)
[13:21:39.466]         if (TRUE) {
[13:21:39.466]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:39.466]         }
[13:21:39.466]         else {
[13:21:39.466]             ...future.result["stdout"] <- base::list(NULL)
[13:21:39.466]         }
[13:21:39.466]         base::close(...future.stdout)
[13:21:39.466]         ...future.stdout <- NULL
[13:21:39.466]     }
[13:21:39.466]     ...future.result$conditions <- ...future.conditions
[13:21:39.466]     ...future.result$finished <- base::Sys.time()
[13:21:39.466]     ...future.result
[13:21:39.466] }
[13:21:39.467] plan(): Setting new future strategy stack:
[13:21:39.467] List of future strategies:
[13:21:39.467] 1. sequential:
[13:21:39.467]    - args: function (..., envir = parent.frame())
[13:21:39.467]    - tweaked: FALSE
[13:21:39.467]    - call: NULL
[13:21:39.468] plan(): nbrOfWorkers() = 1
[13:21:39.469] plan(): Setting new future strategy stack:
[13:21:39.469] List of future strategies:
[13:21:39.469] 1. sequential:
[13:21:39.469]    - args: function (..., envir = parent.frame())
[13:21:39.469]    - tweaked: FALSE
[13:21:39.469]    - call: plan(strategy)
[13:21:39.469] plan(): nbrOfWorkers() = 1
[13:21:39.469] SequentialFuture started (and completed)
[13:21:39.469] - Launch lazy future ... done
[13:21:39.469] run() for ‘SequentialFuture’ ... done
[13:21:39.470] resolve() on environment ...
[13:21:39.470]  recursive: 0
[13:21:39.470]  elements: [3] ‘a’
[13:21:39.471] resolved() for ‘SequentialFuture’ ...
[13:21:39.471] - state: ‘finished’
[13:21:39.471] - run: TRUE
[13:21:39.471] - result: ‘FutureResult’
[13:21:39.471] resolved() for ‘SequentialFuture’ ... done
[13:21:39.471] Future #1
[13:21:39.471]  length: 2 (resolved future 1)
[13:21:39.471] resolved() for ‘SequentialFuture’ ...
[13:21:39.471] - state: ‘finished’
[13:21:39.471] - run: TRUE
[13:21:39.472] - result: ‘FutureResult’
[13:21:39.472] resolved() for ‘SequentialFuture’ ... done
[13:21:39.472] Future #2
[13:21:39.472]  length: 1 (resolved future 2)
[13:21:39.472]  length: 0 (resolved future 3)
[13:21:39.472] resolve() on environment ... DONE
[13:21:39.472] resolved() for ‘SequentialFuture’ ...
[13:21:39.472] - state: ‘finished’
[13:21:39.472] - run: TRUE
[13:21:39.472] - result: ‘FutureResult’
[13:21:39.472] resolved() for ‘SequentialFuture’ ... done
[13:21:39.473] resolve() on environment ...
[13:21:39.473]  recursive: 0
[13:21:39.473]  elements: [3] ‘b’
[13:21:39.474] resolved() for ‘SequentialFuture’ ...
[13:21:39.474] - state: ‘finished’
[13:21:39.474] - run: TRUE
[13:21:39.474] - result: ‘FutureResult’
[13:21:39.474] resolved() for ‘SequentialFuture’ ... done
[13:21:39.476] Future #1
[13:21:39.476]  length: 2 (resolved future 1)
[13:21:39.476] resolved() for ‘SequentialFuture’ ...
[13:21:39.476] - state: ‘finished’
[13:21:39.476] - run: TRUE
[13:21:39.476] - result: ‘FutureResult’
[13:21:39.476] resolved() for ‘SequentialFuture’ ... done
[13:21:39.476] Future #2
[13:21:39.477]  length: 1 (resolved future 2)
[13:21:39.477]  length: 0 (resolved future 3)
[13:21:39.477] resolve() on environment ... DONE
[13:21:39.477] resolve() on environment ...
[13:21:39.477]  recursive: 0
[13:21:39.478]  elements: [3] ‘c’
[13:21:39.478] resolved() for ‘SequentialFuture’ ...
[13:21:39.478] - state: ‘finished’
[13:21:39.478] - run: TRUE
[13:21:39.478] - result: ‘FutureResult’
[13:21:39.478] resolved() for ‘SequentialFuture’ ... done
[13:21:39.478] Future #1
[13:21:39.478]  length: 2 (resolved future 1)
[13:21:39.479] resolved() for ‘SequentialFuture’ ...
[13:21:39.479] - state: ‘finished’
[13:21:39.479] - run: TRUE
[13:21:39.479] - result: ‘FutureResult’
[13:21:39.479] resolved() for ‘SequentialFuture’ ... done
[13:21:39.479] Future #2
[13:21:39.479]  length: 1 (resolved future 2)
[13:21:39.479]  length: 0 (resolved future 3)
[13:21:39.479] resolve() on environment ... DONE
[13:21:39.480] resolve() on environment ...
[13:21:39.480]  recursive: 0
[13:21:39.480]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[13:21:39.480] resolved() for ‘SequentialFuture’ ...
[13:21:39.480] - state: ‘finished’
[13:21:39.481] - run: TRUE
[13:21:39.481] - result: ‘FutureResult’
[13:21:39.481] resolved() for ‘SequentialFuture’ ... done
[13:21:39.481] Future #1
[13:21:39.481]  length: 2 (resolved future 1)
[13:21:39.481] resolved() for ‘SequentialFuture’ ...
[13:21:39.482] - state: ‘finished’
[13:21:39.482] - run: TRUE
[13:21:39.482] - result: ‘FutureResult’
[13:21:39.482] resolved() for ‘SequentialFuture’ ... done
[13:21:39.482] Future #2
[13:21:39.482]  length: 1 (resolved future 2)
[13:21:39.482]  length: 0 (resolved future 3)
[13:21:39.482] resolve() on environment ... DONE
[13:21:39.483] resolve() on environment ...
[13:21:39.483]  recursive: 99
[13:21:39.483]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[13:21:39.483] resolved() for ‘SequentialFuture’ ...
[13:21:39.483] - state: ‘finished’
[13:21:39.484] - run: TRUE
[13:21:39.484] - result: ‘FutureResult’
[13:21:39.484] resolved() for ‘SequentialFuture’ ... done
[13:21:39.484] Future #1
[13:21:39.484] resolved() for ‘SequentialFuture’ ...
[13:21:39.484] - state: ‘finished’
[13:21:39.484] - run: TRUE
[13:21:39.484] - result: ‘FutureResult’
[13:21:39.484] resolved() for ‘SequentialFuture’ ... done
[13:21:39.484] A SequentialFuture was resolved
[13:21:39.484]  length: 2 (resolved future 1)
[13:21:39.485] resolved() for ‘SequentialFuture’ ...
[13:21:39.485] - state: ‘finished’
[13:21:39.485] - run: TRUE
[13:21:39.485] - result: ‘FutureResult’
[13:21:39.485] resolved() for ‘SequentialFuture’ ... done
[13:21:39.485] Future #2
[13:21:39.485] resolved() for ‘SequentialFuture’ ...
[13:21:39.485] - state: ‘finished’
[13:21:39.485] - run: TRUE
[13:21:39.485] - result: ‘FutureResult’
[13:21:39.486] resolved() for ‘SequentialFuture’ ... done
[13:21:39.486] A SequentialFuture was resolved
[13:21:39.486]  length: 1 (resolved future 2)
[13:21:39.486]  length: 0 (resolved future 3)
[13:21:39.486] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[13:21:39.487] resolve() on list environment ...
[13:21:39.487]  recursive: 0
[13:21:39.488]  length: 2
[13:21:39.488]  elements: ‘a’, ‘b’
[13:21:39.488]  length: 1 (resolved future 1)
[13:21:39.488]  length: 0 (resolved future 2)
[13:21:39.488] resolve() on list environment ... DONE
[13:21:39.489] getGlobalsAndPackages() ...
[13:21:39.489] Searching for globals...
[13:21:39.489] 
[13:21:39.489] Searching for globals ... DONE
[13:21:39.489] - globals: [0] <none>
[13:21:39.489] getGlobalsAndPackages() ... DONE
[13:21:39.489] run() for ‘Future’ ...
[13:21:39.490] - state: ‘created’
[13:21:39.490] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:39.490] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:39.490] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:39.490]   - Field: ‘label’
[13:21:39.490]   - Field: ‘local’
[13:21:39.490]   - Field: ‘owner’
[13:21:39.490]   - Field: ‘envir’
[13:21:39.491]   - Field: ‘packages’
[13:21:39.491]   - Field: ‘gc’
[13:21:39.491]   - Field: ‘conditions’
[13:21:39.491]   - Field: ‘expr’
[13:21:39.491]   - Field: ‘uuid’
[13:21:39.491]   - Field: ‘seed’
[13:21:39.491]   - Field: ‘version’
[13:21:39.491]   - Field: ‘result’
[13:21:39.491]   - Field: ‘asynchronous’
[13:21:39.491]   - Field: ‘calls’
[13:21:39.491]   - Field: ‘globals’
[13:21:39.491]   - Field: ‘stdout’
[13:21:39.492]   - Field: ‘earlySignal’
[13:21:39.492]   - Field: ‘lazy’
[13:21:39.492]   - Field: ‘state’
[13:21:39.492] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:39.492] - Launch lazy future ...
[13:21:39.492] Packages needed by the future expression (n = 0): <none>
[13:21:39.492] Packages needed by future strategies (n = 0): <none>
[13:21:39.493] {
[13:21:39.493]     {
[13:21:39.493]         {
[13:21:39.493]             ...future.startTime <- base::Sys.time()
[13:21:39.493]             {
[13:21:39.493]                 {
[13:21:39.493]                   {
[13:21:39.493]                     base::local({
[13:21:39.493]                       has_future <- base::requireNamespace("future", 
[13:21:39.493]                         quietly = TRUE)
[13:21:39.493]                       if (has_future) {
[13:21:39.493]                         ns <- base::getNamespace("future")
[13:21:39.493]                         version <- ns[[".package"]][["version"]]
[13:21:39.493]                         if (is.null(version)) 
[13:21:39.493]                           version <- utils::packageVersion("future")
[13:21:39.493]                       }
[13:21:39.493]                       else {
[13:21:39.493]                         version <- NULL
[13:21:39.493]                       }
[13:21:39.493]                       if (!has_future || version < "1.8.0") {
[13:21:39.493]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:39.493]                           "", base::R.version$version.string), 
[13:21:39.493]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:39.493]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:39.493]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:39.493]                             "release", "version")], collapse = " "), 
[13:21:39.493]                           hostname = base::Sys.info()[["nodename"]])
[13:21:39.493]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:39.493]                           info)
[13:21:39.493]                         info <- base::paste(info, collapse = "; ")
[13:21:39.493]                         if (!has_future) {
[13:21:39.493]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:39.493]                             info)
[13:21:39.493]                         }
[13:21:39.493]                         else {
[13:21:39.493]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:39.493]                             info, version)
[13:21:39.493]                         }
[13:21:39.493]                         base::stop(msg)
[13:21:39.493]                       }
[13:21:39.493]                     })
[13:21:39.493]                   }
[13:21:39.493]                   options(future.plan = NULL)
[13:21:39.493]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:39.493]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:39.493]                 }
[13:21:39.493]                 ...future.workdir <- getwd()
[13:21:39.493]             }
[13:21:39.493]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:39.493]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:39.493]         }
[13:21:39.493]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:39.493]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:39.493]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:39.493]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:39.493]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:39.493]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:39.493]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:39.493]             base::names(...future.oldOptions))
[13:21:39.493]     }
[13:21:39.493]     if (FALSE) {
[13:21:39.493]     }
[13:21:39.493]     else {
[13:21:39.493]         if (TRUE) {
[13:21:39.493]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:39.493]                 open = "w")
[13:21:39.493]         }
[13:21:39.493]         else {
[13:21:39.493]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:39.493]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:39.493]         }
[13:21:39.493]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:39.493]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:39.493]             base::sink(type = "output", split = FALSE)
[13:21:39.493]             base::close(...future.stdout)
[13:21:39.493]         }, add = TRUE)
[13:21:39.493]     }
[13:21:39.493]     ...future.frame <- base::sys.nframe()
[13:21:39.493]     ...future.conditions <- base::list()
[13:21:39.493]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:39.493]     if (FALSE) {
[13:21:39.493]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:39.493]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:39.493]     }
[13:21:39.493]     ...future.result <- base::tryCatch({
[13:21:39.493]         base::withCallingHandlers({
[13:21:39.493]             ...future.value <- base::withVisible(base::local(1))
[13:21:39.493]             future::FutureResult(value = ...future.value$value, 
[13:21:39.493]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:39.493]                   ...future.rng), globalenv = if (FALSE) 
[13:21:39.493]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:39.493]                     ...future.globalenv.names))
[13:21:39.493]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:39.493]         }, condition = base::local({
[13:21:39.493]             c <- base::c
[13:21:39.493]             inherits <- base::inherits
[13:21:39.493]             invokeRestart <- base::invokeRestart
[13:21:39.493]             length <- base::length
[13:21:39.493]             list <- base::list
[13:21:39.493]             seq.int <- base::seq.int
[13:21:39.493]             signalCondition <- base::signalCondition
[13:21:39.493]             sys.calls <- base::sys.calls
[13:21:39.493]             `[[` <- base::`[[`
[13:21:39.493]             `+` <- base::`+`
[13:21:39.493]             `<<-` <- base::`<<-`
[13:21:39.493]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:39.493]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:39.493]                   3L)]
[13:21:39.493]             }
[13:21:39.493]             function(cond) {
[13:21:39.493]                 is_error <- inherits(cond, "error")
[13:21:39.493]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:39.493]                   NULL)
[13:21:39.493]                 if (is_error) {
[13:21:39.493]                   sessionInformation <- function() {
[13:21:39.493]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:39.493]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:39.493]                       search = base::search(), system = base::Sys.info())
[13:21:39.493]                   }
[13:21:39.493]                   ...future.conditions[[length(...future.conditions) + 
[13:21:39.493]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:39.493]                     cond$call), session = sessionInformation(), 
[13:21:39.493]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:39.493]                   signalCondition(cond)
[13:21:39.493]                 }
[13:21:39.493]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:39.493]                 "immediateCondition"))) {
[13:21:39.493]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:39.493]                   ...future.conditions[[length(...future.conditions) + 
[13:21:39.493]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:39.493]                   if (TRUE && !signal) {
[13:21:39.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.493]                     {
[13:21:39.493]                       inherits <- base::inherits
[13:21:39.493]                       invokeRestart <- base::invokeRestart
[13:21:39.493]                       is.null <- base::is.null
[13:21:39.493]                       muffled <- FALSE
[13:21:39.493]                       if (inherits(cond, "message")) {
[13:21:39.493]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:39.493]                         if (muffled) 
[13:21:39.493]                           invokeRestart("muffleMessage")
[13:21:39.493]                       }
[13:21:39.493]                       else if (inherits(cond, "warning")) {
[13:21:39.493]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:39.493]                         if (muffled) 
[13:21:39.493]                           invokeRestart("muffleWarning")
[13:21:39.493]                       }
[13:21:39.493]                       else if (inherits(cond, "condition")) {
[13:21:39.493]                         if (!is.null(pattern)) {
[13:21:39.493]                           computeRestarts <- base::computeRestarts
[13:21:39.493]                           grepl <- base::grepl
[13:21:39.493]                           restarts <- computeRestarts(cond)
[13:21:39.493]                           for (restart in restarts) {
[13:21:39.493]                             name <- restart$name
[13:21:39.493]                             if (is.null(name)) 
[13:21:39.493]                               next
[13:21:39.493]                             if (!grepl(pattern, name)) 
[13:21:39.493]                               next
[13:21:39.493]                             invokeRestart(restart)
[13:21:39.493]                             muffled <- TRUE
[13:21:39.493]                             break
[13:21:39.493]                           }
[13:21:39.493]                         }
[13:21:39.493]                       }
[13:21:39.493]                       invisible(muffled)
[13:21:39.493]                     }
[13:21:39.493]                     muffleCondition(cond, pattern = "^muffle")
[13:21:39.493]                   }
[13:21:39.493]                 }
[13:21:39.493]                 else {
[13:21:39.493]                   if (TRUE) {
[13:21:39.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.493]                     {
[13:21:39.493]                       inherits <- base::inherits
[13:21:39.493]                       invokeRestart <- base::invokeRestart
[13:21:39.493]                       is.null <- base::is.null
[13:21:39.493]                       muffled <- FALSE
[13:21:39.493]                       if (inherits(cond, "message")) {
[13:21:39.493]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:39.493]                         if (muffled) 
[13:21:39.493]                           invokeRestart("muffleMessage")
[13:21:39.493]                       }
[13:21:39.493]                       else if (inherits(cond, "warning")) {
[13:21:39.493]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:39.493]                         if (muffled) 
[13:21:39.493]                           invokeRestart("muffleWarning")
[13:21:39.493]                       }
[13:21:39.493]                       else if (inherits(cond, "condition")) {
[13:21:39.493]                         if (!is.null(pattern)) {
[13:21:39.493]                           computeRestarts <- base::computeRestarts
[13:21:39.493]                           grepl <- base::grepl
[13:21:39.493]                           restarts <- computeRestarts(cond)
[13:21:39.493]                           for (restart in restarts) {
[13:21:39.493]                             name <- restart$name
[13:21:39.493]                             if (is.null(name)) 
[13:21:39.493]                               next
[13:21:39.493]                             if (!grepl(pattern, name)) 
[13:21:39.493]                               next
[13:21:39.493]                             invokeRestart(restart)
[13:21:39.493]                             muffled <- TRUE
[13:21:39.493]                             break
[13:21:39.493]                           }
[13:21:39.493]                         }
[13:21:39.493]                       }
[13:21:39.493]                       invisible(muffled)
[13:21:39.493]                     }
[13:21:39.493]                     muffleCondition(cond, pattern = "^muffle")
[13:21:39.493]                   }
[13:21:39.493]                 }
[13:21:39.493]             }
[13:21:39.493]         }))
[13:21:39.493]     }, error = function(ex) {
[13:21:39.493]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:39.493]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:39.493]                 ...future.rng), started = ...future.startTime, 
[13:21:39.493]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:39.493]             version = "1.8"), class = "FutureResult")
[13:21:39.493]     }, finally = {
[13:21:39.493]         if (!identical(...future.workdir, getwd())) 
[13:21:39.493]             setwd(...future.workdir)
[13:21:39.493]         {
[13:21:39.493]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:39.493]                 ...future.oldOptions$nwarnings <- NULL
[13:21:39.493]             }
[13:21:39.493]             base::options(...future.oldOptions)
[13:21:39.493]             if (.Platform$OS.type == "windows") {
[13:21:39.493]                 old_names <- names(...future.oldEnvVars)
[13:21:39.493]                 envs <- base::Sys.getenv()
[13:21:39.493]                 names <- names(envs)
[13:21:39.493]                 common <- intersect(names, old_names)
[13:21:39.493]                 added <- setdiff(names, old_names)
[13:21:39.493]                 removed <- setdiff(old_names, names)
[13:21:39.493]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:39.493]                   envs[common]]
[13:21:39.493]                 NAMES <- toupper(changed)
[13:21:39.493]                 args <- list()
[13:21:39.493]                 for (kk in seq_along(NAMES)) {
[13:21:39.493]                   name <- changed[[kk]]
[13:21:39.493]                   NAME <- NAMES[[kk]]
[13:21:39.493]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.493]                     next
[13:21:39.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:39.493]                 }
[13:21:39.493]                 NAMES <- toupper(added)
[13:21:39.493]                 for (kk in seq_along(NAMES)) {
[13:21:39.493]                   name <- added[[kk]]
[13:21:39.493]                   NAME <- NAMES[[kk]]
[13:21:39.493]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.493]                     next
[13:21:39.493]                   args[[name]] <- ""
[13:21:39.493]                 }
[13:21:39.493]                 NAMES <- toupper(removed)
[13:21:39.493]                 for (kk in seq_along(NAMES)) {
[13:21:39.493]                   name <- removed[[kk]]
[13:21:39.493]                   NAME <- NAMES[[kk]]
[13:21:39.493]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.493]                     next
[13:21:39.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:39.493]                 }
[13:21:39.493]                 if (length(args) > 0) 
[13:21:39.493]                   base::do.call(base::Sys.setenv, args = args)
[13:21:39.493]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:39.493]             }
[13:21:39.493]             else {
[13:21:39.493]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:39.493]             }
[13:21:39.493]             {
[13:21:39.493]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:39.493]                   0L) {
[13:21:39.493]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:39.493]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:39.493]                   base::options(opts)
[13:21:39.493]                 }
[13:21:39.493]                 {
[13:21:39.493]                   {
[13:21:39.493]                     NULL
[13:21:39.493]                     RNGkind("Mersenne-Twister")
[13:21:39.493]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:39.493]                       inherits = FALSE)
[13:21:39.493]                   }
[13:21:39.493]                   options(future.plan = NULL)
[13:21:39.493]                   if (is.na(NA_character_)) 
[13:21:39.493]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:39.493]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:39.493]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:39.493]                   {
[13:21:39.493]                     future <- SequentialFuture(..., envir = envir)
[13:21:39.493]                     if (!future$lazy) 
[13:21:39.493]                       future <- run(future)
[13:21:39.493]                     invisible(future)
[13:21:39.493]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:39.493]                 }
[13:21:39.493]             }
[13:21:39.493]         }
[13:21:39.493]     })
[13:21:39.493]     if (TRUE) {
[13:21:39.493]         base::sink(type = "output", split = FALSE)
[13:21:39.493]         if (TRUE) {
[13:21:39.493]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:39.493]         }
[13:21:39.493]         else {
[13:21:39.493]             ...future.result["stdout"] <- base::list(NULL)
[13:21:39.493]         }
[13:21:39.493]         base::close(...future.stdout)
[13:21:39.493]         ...future.stdout <- NULL
[13:21:39.493]     }
[13:21:39.493]     ...future.result$conditions <- ...future.conditions
[13:21:39.493]     ...future.result$finished <- base::Sys.time()
[13:21:39.493]     ...future.result
[13:21:39.493] }
[13:21:39.494] plan(): Setting new future strategy stack:
[13:21:39.494] List of future strategies:
[13:21:39.494] 1. sequential:
[13:21:39.494]    - args: function (..., envir = parent.frame())
[13:21:39.494]    - tweaked: FALSE
[13:21:39.494]    - call: NULL
[13:21:39.495] plan(): nbrOfWorkers() = 1
[13:21:39.495] plan(): Setting new future strategy stack:
[13:21:39.496] List of future strategies:
[13:21:39.496] 1. sequential:
[13:21:39.496]    - args: function (..., envir = parent.frame())
[13:21:39.496]    - tweaked: FALSE
[13:21:39.496]    - call: plan(strategy)
[13:21:39.496] plan(): nbrOfWorkers() = 1
[13:21:39.496] SequentialFuture started (and completed)
[13:21:39.496] - Launch lazy future ... done
[13:21:39.496] run() for ‘SequentialFuture’ ... done
[13:21:39.496] getGlobalsAndPackages() ...
[13:21:39.497] Searching for globals...
[13:21:39.497] 
[13:21:39.497] Searching for globals ... DONE
[13:21:39.497] - globals: [0] <none>
[13:21:39.497] getGlobalsAndPackages() ... DONE
[13:21:39.497] run() for ‘Future’ ...
[13:21:39.497] - state: ‘created’
[13:21:39.498] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:39.498] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:39.498] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:39.498]   - Field: ‘label’
[13:21:39.498]   - Field: ‘local’
[13:21:39.498]   - Field: ‘owner’
[13:21:39.498]   - Field: ‘envir’
[13:21:39.498]   - Field: ‘packages’
[13:21:39.498]   - Field: ‘gc’
[13:21:39.499]   - Field: ‘conditions’
[13:21:39.499]   - Field: ‘expr’
[13:21:39.499]   - Field: ‘uuid’
[13:21:39.499]   - Field: ‘seed’
[13:21:39.499]   - Field: ‘version’
[13:21:39.499]   - Field: ‘result’
[13:21:39.501]   - Field: ‘asynchronous’
[13:21:39.501]   - Field: ‘calls’
[13:21:39.501]   - Field: ‘globals’
[13:21:39.501]   - Field: ‘stdout’
[13:21:39.501]   - Field: ‘earlySignal’
[13:21:39.501]   - Field: ‘lazy’
[13:21:39.501]   - Field: ‘state’
[13:21:39.501] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:39.501] - Launch lazy future ...
[13:21:39.501] Packages needed by the future expression (n = 0): <none>
[13:21:39.502] Packages needed by future strategies (n = 0): <none>
[13:21:39.502] {
[13:21:39.502]     {
[13:21:39.502]         {
[13:21:39.502]             ...future.startTime <- base::Sys.time()
[13:21:39.502]             {
[13:21:39.502]                 {
[13:21:39.502]                   {
[13:21:39.502]                     base::local({
[13:21:39.502]                       has_future <- base::requireNamespace("future", 
[13:21:39.502]                         quietly = TRUE)
[13:21:39.502]                       if (has_future) {
[13:21:39.502]                         ns <- base::getNamespace("future")
[13:21:39.502]                         version <- ns[[".package"]][["version"]]
[13:21:39.502]                         if (is.null(version)) 
[13:21:39.502]                           version <- utils::packageVersion("future")
[13:21:39.502]                       }
[13:21:39.502]                       else {
[13:21:39.502]                         version <- NULL
[13:21:39.502]                       }
[13:21:39.502]                       if (!has_future || version < "1.8.0") {
[13:21:39.502]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:39.502]                           "", base::R.version$version.string), 
[13:21:39.502]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:39.502]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:39.502]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:39.502]                             "release", "version")], collapse = " "), 
[13:21:39.502]                           hostname = base::Sys.info()[["nodename"]])
[13:21:39.502]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:39.502]                           info)
[13:21:39.502]                         info <- base::paste(info, collapse = "; ")
[13:21:39.502]                         if (!has_future) {
[13:21:39.502]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:39.502]                             info)
[13:21:39.502]                         }
[13:21:39.502]                         else {
[13:21:39.502]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:39.502]                             info, version)
[13:21:39.502]                         }
[13:21:39.502]                         base::stop(msg)
[13:21:39.502]                       }
[13:21:39.502]                     })
[13:21:39.502]                   }
[13:21:39.502]                   options(future.plan = NULL)
[13:21:39.502]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:39.502]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:39.502]                 }
[13:21:39.502]                 ...future.workdir <- getwd()
[13:21:39.502]             }
[13:21:39.502]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:39.502]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:39.502]         }
[13:21:39.502]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:39.502]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:39.502]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:39.502]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:39.502]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:39.502]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:39.502]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:39.502]             base::names(...future.oldOptions))
[13:21:39.502]     }
[13:21:39.502]     if (FALSE) {
[13:21:39.502]     }
[13:21:39.502]     else {
[13:21:39.502]         if (TRUE) {
[13:21:39.502]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:39.502]                 open = "w")
[13:21:39.502]         }
[13:21:39.502]         else {
[13:21:39.502]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:39.502]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:39.502]         }
[13:21:39.502]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:39.502]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:39.502]             base::sink(type = "output", split = FALSE)
[13:21:39.502]             base::close(...future.stdout)
[13:21:39.502]         }, add = TRUE)
[13:21:39.502]     }
[13:21:39.502]     ...future.frame <- base::sys.nframe()
[13:21:39.502]     ...future.conditions <- base::list()
[13:21:39.502]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:39.502]     if (FALSE) {
[13:21:39.502]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:39.502]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:39.502]     }
[13:21:39.502]     ...future.result <- base::tryCatch({
[13:21:39.502]         base::withCallingHandlers({
[13:21:39.502]             ...future.value <- base::withVisible(base::local(2))
[13:21:39.502]             future::FutureResult(value = ...future.value$value, 
[13:21:39.502]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:39.502]                   ...future.rng), globalenv = if (FALSE) 
[13:21:39.502]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:39.502]                     ...future.globalenv.names))
[13:21:39.502]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:39.502]         }, condition = base::local({
[13:21:39.502]             c <- base::c
[13:21:39.502]             inherits <- base::inherits
[13:21:39.502]             invokeRestart <- base::invokeRestart
[13:21:39.502]             length <- base::length
[13:21:39.502]             list <- base::list
[13:21:39.502]             seq.int <- base::seq.int
[13:21:39.502]             signalCondition <- base::signalCondition
[13:21:39.502]             sys.calls <- base::sys.calls
[13:21:39.502]             `[[` <- base::`[[`
[13:21:39.502]             `+` <- base::`+`
[13:21:39.502]             `<<-` <- base::`<<-`
[13:21:39.502]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:39.502]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:39.502]                   3L)]
[13:21:39.502]             }
[13:21:39.502]             function(cond) {
[13:21:39.502]                 is_error <- inherits(cond, "error")
[13:21:39.502]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:39.502]                   NULL)
[13:21:39.502]                 if (is_error) {
[13:21:39.502]                   sessionInformation <- function() {
[13:21:39.502]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:39.502]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:39.502]                       search = base::search(), system = base::Sys.info())
[13:21:39.502]                   }
[13:21:39.502]                   ...future.conditions[[length(...future.conditions) + 
[13:21:39.502]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:39.502]                     cond$call), session = sessionInformation(), 
[13:21:39.502]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:39.502]                   signalCondition(cond)
[13:21:39.502]                 }
[13:21:39.502]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:39.502]                 "immediateCondition"))) {
[13:21:39.502]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:39.502]                   ...future.conditions[[length(...future.conditions) + 
[13:21:39.502]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:39.502]                   if (TRUE && !signal) {
[13:21:39.502]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.502]                     {
[13:21:39.502]                       inherits <- base::inherits
[13:21:39.502]                       invokeRestart <- base::invokeRestart
[13:21:39.502]                       is.null <- base::is.null
[13:21:39.502]                       muffled <- FALSE
[13:21:39.502]                       if (inherits(cond, "message")) {
[13:21:39.502]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:39.502]                         if (muffled) 
[13:21:39.502]                           invokeRestart("muffleMessage")
[13:21:39.502]                       }
[13:21:39.502]                       else if (inherits(cond, "warning")) {
[13:21:39.502]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:39.502]                         if (muffled) 
[13:21:39.502]                           invokeRestart("muffleWarning")
[13:21:39.502]                       }
[13:21:39.502]                       else if (inherits(cond, "condition")) {
[13:21:39.502]                         if (!is.null(pattern)) {
[13:21:39.502]                           computeRestarts <- base::computeRestarts
[13:21:39.502]                           grepl <- base::grepl
[13:21:39.502]                           restarts <- computeRestarts(cond)
[13:21:39.502]                           for (restart in restarts) {
[13:21:39.502]                             name <- restart$name
[13:21:39.502]                             if (is.null(name)) 
[13:21:39.502]                               next
[13:21:39.502]                             if (!grepl(pattern, name)) 
[13:21:39.502]                               next
[13:21:39.502]                             invokeRestart(restart)
[13:21:39.502]                             muffled <- TRUE
[13:21:39.502]                             break
[13:21:39.502]                           }
[13:21:39.502]                         }
[13:21:39.502]                       }
[13:21:39.502]                       invisible(muffled)
[13:21:39.502]                     }
[13:21:39.502]                     muffleCondition(cond, pattern = "^muffle")
[13:21:39.502]                   }
[13:21:39.502]                 }
[13:21:39.502]                 else {
[13:21:39.502]                   if (TRUE) {
[13:21:39.502]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.502]                     {
[13:21:39.502]                       inherits <- base::inherits
[13:21:39.502]                       invokeRestart <- base::invokeRestart
[13:21:39.502]                       is.null <- base::is.null
[13:21:39.502]                       muffled <- FALSE
[13:21:39.502]                       if (inherits(cond, "message")) {
[13:21:39.502]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:39.502]                         if (muffled) 
[13:21:39.502]                           invokeRestart("muffleMessage")
[13:21:39.502]                       }
[13:21:39.502]                       else if (inherits(cond, "warning")) {
[13:21:39.502]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:39.502]                         if (muffled) 
[13:21:39.502]                           invokeRestart("muffleWarning")
[13:21:39.502]                       }
[13:21:39.502]                       else if (inherits(cond, "condition")) {
[13:21:39.502]                         if (!is.null(pattern)) {
[13:21:39.502]                           computeRestarts <- base::computeRestarts
[13:21:39.502]                           grepl <- base::grepl
[13:21:39.502]                           restarts <- computeRestarts(cond)
[13:21:39.502]                           for (restart in restarts) {
[13:21:39.502]                             name <- restart$name
[13:21:39.502]                             if (is.null(name)) 
[13:21:39.502]                               next
[13:21:39.502]                             if (!grepl(pattern, name)) 
[13:21:39.502]                               next
[13:21:39.502]                             invokeRestart(restart)
[13:21:39.502]                             muffled <- TRUE
[13:21:39.502]                             break
[13:21:39.502]                           }
[13:21:39.502]                         }
[13:21:39.502]                       }
[13:21:39.502]                       invisible(muffled)
[13:21:39.502]                     }
[13:21:39.502]                     muffleCondition(cond, pattern = "^muffle")
[13:21:39.502]                   }
[13:21:39.502]                 }
[13:21:39.502]             }
[13:21:39.502]         }))
[13:21:39.502]     }, error = function(ex) {
[13:21:39.502]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:39.502]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:39.502]                 ...future.rng), started = ...future.startTime, 
[13:21:39.502]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:39.502]             version = "1.8"), class = "FutureResult")
[13:21:39.502]     }, finally = {
[13:21:39.502]         if (!identical(...future.workdir, getwd())) 
[13:21:39.502]             setwd(...future.workdir)
[13:21:39.502]         {
[13:21:39.502]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:39.502]                 ...future.oldOptions$nwarnings <- NULL
[13:21:39.502]             }
[13:21:39.502]             base::options(...future.oldOptions)
[13:21:39.502]             if (.Platform$OS.type == "windows") {
[13:21:39.502]                 old_names <- names(...future.oldEnvVars)
[13:21:39.502]                 envs <- base::Sys.getenv()
[13:21:39.502]                 names <- names(envs)
[13:21:39.502]                 common <- intersect(names, old_names)
[13:21:39.502]                 added <- setdiff(names, old_names)
[13:21:39.502]                 removed <- setdiff(old_names, names)
[13:21:39.502]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:39.502]                   envs[common]]
[13:21:39.502]                 NAMES <- toupper(changed)
[13:21:39.502]                 args <- list()
[13:21:39.502]                 for (kk in seq_along(NAMES)) {
[13:21:39.502]                   name <- changed[[kk]]
[13:21:39.502]                   NAME <- NAMES[[kk]]
[13:21:39.502]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.502]                     next
[13:21:39.502]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:39.502]                 }
[13:21:39.502]                 NAMES <- toupper(added)
[13:21:39.502]                 for (kk in seq_along(NAMES)) {
[13:21:39.502]                   name <- added[[kk]]
[13:21:39.502]                   NAME <- NAMES[[kk]]
[13:21:39.502]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.502]                     next
[13:21:39.502]                   args[[name]] <- ""
[13:21:39.502]                 }
[13:21:39.502]                 NAMES <- toupper(removed)
[13:21:39.502]                 for (kk in seq_along(NAMES)) {
[13:21:39.502]                   name <- removed[[kk]]
[13:21:39.502]                   NAME <- NAMES[[kk]]
[13:21:39.502]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.502]                     next
[13:21:39.502]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:39.502]                 }
[13:21:39.502]                 if (length(args) > 0) 
[13:21:39.502]                   base::do.call(base::Sys.setenv, args = args)
[13:21:39.502]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:39.502]             }
[13:21:39.502]             else {
[13:21:39.502]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:39.502]             }
[13:21:39.502]             {
[13:21:39.502]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:39.502]                   0L) {
[13:21:39.502]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:39.502]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:39.502]                   base::options(opts)
[13:21:39.502]                 }
[13:21:39.502]                 {
[13:21:39.502]                   {
[13:21:39.502]                     NULL
[13:21:39.502]                     RNGkind("Mersenne-Twister")
[13:21:39.502]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:39.502]                       inherits = FALSE)
[13:21:39.502]                   }
[13:21:39.502]                   options(future.plan = NULL)
[13:21:39.502]                   if (is.na(NA_character_)) 
[13:21:39.502]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:39.502]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:39.502]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:39.502]                   {
[13:21:39.502]                     future <- SequentialFuture(..., envir = envir)
[13:21:39.502]                     if (!future$lazy) 
[13:21:39.502]                       future <- run(future)
[13:21:39.502]                     invisible(future)
[13:21:39.502]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:39.502]                 }
[13:21:39.502]             }
[13:21:39.502]         }
[13:21:39.502]     })
[13:21:39.502]     if (TRUE) {
[13:21:39.502]         base::sink(type = "output", split = FALSE)
[13:21:39.502]         if (TRUE) {
[13:21:39.502]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:39.502]         }
[13:21:39.502]         else {
[13:21:39.502]             ...future.result["stdout"] <- base::list(NULL)
[13:21:39.502]         }
[13:21:39.502]         base::close(...future.stdout)
[13:21:39.502]         ...future.stdout <- NULL
[13:21:39.502]     }
[13:21:39.502]     ...future.result$conditions <- ...future.conditions
[13:21:39.502]     ...future.result$finished <- base::Sys.time()
[13:21:39.502]     ...future.result
[13:21:39.502] }
[13:21:39.504] plan(): Setting new future strategy stack:
[13:21:39.504] List of future strategies:
[13:21:39.504] 1. sequential:
[13:21:39.504]    - args: function (..., envir = parent.frame())
[13:21:39.504]    - tweaked: FALSE
[13:21:39.504]    - call: NULL
[13:21:39.504] plan(): nbrOfWorkers() = 1
[13:21:39.505] plan(): Setting new future strategy stack:
[13:21:39.505] List of future strategies:
[13:21:39.505] 1. sequential:
[13:21:39.505]    - args: function (..., envir = parent.frame())
[13:21:39.505]    - tweaked: FALSE
[13:21:39.505]    - call: plan(strategy)
[13:21:39.505] plan(): nbrOfWorkers() = 1
[13:21:39.505] SequentialFuture started (and completed)
[13:21:39.506] - Launch lazy future ... done
[13:21:39.506] run() for ‘SequentialFuture’ ... done
[13:21:39.506] resolve() on list environment ...
[13:21:39.506]  recursive: 0
[13:21:39.507]  length: 3
[13:21:39.507]  elements: ‘a’, ‘b’, ‘c’
[13:21:39.507] resolved() for ‘SequentialFuture’ ...
[13:21:39.507] - state: ‘finished’
[13:21:39.507] - run: TRUE
[13:21:39.507] - result: ‘FutureResult’
[13:21:39.508] resolved() for ‘SequentialFuture’ ... done
[13:21:39.508] Future #1
[13:21:39.508]  length: 2 (resolved future 1)
[13:21:39.508] resolved() for ‘SequentialFuture’ ...
[13:21:39.508] - state: ‘finished’
[13:21:39.508] - run: TRUE
[13:21:39.508] - result: ‘FutureResult’
[13:21:39.508] resolved() for ‘SequentialFuture’ ... done
[13:21:39.508] Future #2
[13:21:39.508]  length: 1 (resolved future 2)
[13:21:39.509]  length: 0 (resolved future 3)
[13:21:39.509] resolve() on list environment ... DONE
[13:21:39.509] getGlobalsAndPackages() ...
[13:21:39.510] Searching for globals...
[13:21:39.510] - globals found: [1] ‘{’
[13:21:39.510] Searching for globals ... DONE
[13:21:39.510] Resolving globals: FALSE
[13:21:39.511] 
[13:21:39.511] 
[13:21:39.511] getGlobalsAndPackages() ... DONE
[13:21:39.511] run() for ‘Future’ ...
[13:21:39.511] - state: ‘created’
[13:21:39.511] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:39.511] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:39.512] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:39.512]   - Field: ‘label’
[13:21:39.512]   - Field: ‘local’
[13:21:39.512]   - Field: ‘owner’
[13:21:39.512]   - Field: ‘envir’
[13:21:39.512]   - Field: ‘packages’
[13:21:39.512]   - Field: ‘gc’
[13:21:39.512]   - Field: ‘conditions’
[13:21:39.512]   - Field: ‘expr’
[13:21:39.512]   - Field: ‘uuid’
[13:21:39.512]   - Field: ‘seed’
[13:21:39.513]   - Field: ‘version’
[13:21:39.513]   - Field: ‘result’
[13:21:39.513]   - Field: ‘asynchronous’
[13:21:39.513]   - Field: ‘calls’
[13:21:39.513]   - Field: ‘globals’
[13:21:39.513]   - Field: ‘stdout’
[13:21:39.513]   - Field: ‘earlySignal’
[13:21:39.513]   - Field: ‘lazy’
[13:21:39.513]   - Field: ‘state’
[13:21:39.513] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:39.513] - Launch lazy future ...
[13:21:39.514] Packages needed by the future expression (n = 0): <none>
[13:21:39.514] Packages needed by future strategies (n = 0): <none>
[13:21:39.514] {
[13:21:39.514]     {
[13:21:39.514]         {
[13:21:39.514]             ...future.startTime <- base::Sys.time()
[13:21:39.514]             {
[13:21:39.514]                 {
[13:21:39.514]                   {
[13:21:39.514]                     base::local({
[13:21:39.514]                       has_future <- base::requireNamespace("future", 
[13:21:39.514]                         quietly = TRUE)
[13:21:39.514]                       if (has_future) {
[13:21:39.514]                         ns <- base::getNamespace("future")
[13:21:39.514]                         version <- ns[[".package"]][["version"]]
[13:21:39.514]                         if (is.null(version)) 
[13:21:39.514]                           version <- utils::packageVersion("future")
[13:21:39.514]                       }
[13:21:39.514]                       else {
[13:21:39.514]                         version <- NULL
[13:21:39.514]                       }
[13:21:39.514]                       if (!has_future || version < "1.8.0") {
[13:21:39.514]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:39.514]                           "", base::R.version$version.string), 
[13:21:39.514]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:39.514]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:39.514]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:39.514]                             "release", "version")], collapse = " "), 
[13:21:39.514]                           hostname = base::Sys.info()[["nodename"]])
[13:21:39.514]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:39.514]                           info)
[13:21:39.514]                         info <- base::paste(info, collapse = "; ")
[13:21:39.514]                         if (!has_future) {
[13:21:39.514]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:39.514]                             info)
[13:21:39.514]                         }
[13:21:39.514]                         else {
[13:21:39.514]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:39.514]                             info, version)
[13:21:39.514]                         }
[13:21:39.514]                         base::stop(msg)
[13:21:39.514]                       }
[13:21:39.514]                     })
[13:21:39.514]                   }
[13:21:39.514]                   options(future.plan = NULL)
[13:21:39.514]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:39.514]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:39.514]                 }
[13:21:39.514]                 ...future.workdir <- getwd()
[13:21:39.514]             }
[13:21:39.514]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:39.514]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:39.514]         }
[13:21:39.514]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:39.514]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:39.514]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:39.514]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:39.514]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:39.514]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:39.514]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:39.514]             base::names(...future.oldOptions))
[13:21:39.514]     }
[13:21:39.514]     if (FALSE) {
[13:21:39.514]     }
[13:21:39.514]     else {
[13:21:39.514]         if (TRUE) {
[13:21:39.514]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:39.514]                 open = "w")
[13:21:39.514]         }
[13:21:39.514]         else {
[13:21:39.514]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:39.514]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:39.514]         }
[13:21:39.514]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:39.514]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:39.514]             base::sink(type = "output", split = FALSE)
[13:21:39.514]             base::close(...future.stdout)
[13:21:39.514]         }, add = TRUE)
[13:21:39.514]     }
[13:21:39.514]     ...future.frame <- base::sys.nframe()
[13:21:39.514]     ...future.conditions <- base::list()
[13:21:39.514]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:39.514]     if (FALSE) {
[13:21:39.514]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:39.514]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:39.514]     }
[13:21:39.514]     ...future.result <- base::tryCatch({
[13:21:39.514]         base::withCallingHandlers({
[13:21:39.514]             ...future.value <- base::withVisible(base::local({
[13:21:39.514]                 1
[13:21:39.514]             }))
[13:21:39.514]             future::FutureResult(value = ...future.value$value, 
[13:21:39.514]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:39.514]                   ...future.rng), globalenv = if (FALSE) 
[13:21:39.514]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:39.514]                     ...future.globalenv.names))
[13:21:39.514]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:39.514]         }, condition = base::local({
[13:21:39.514]             c <- base::c
[13:21:39.514]             inherits <- base::inherits
[13:21:39.514]             invokeRestart <- base::invokeRestart
[13:21:39.514]             length <- base::length
[13:21:39.514]             list <- base::list
[13:21:39.514]             seq.int <- base::seq.int
[13:21:39.514]             signalCondition <- base::signalCondition
[13:21:39.514]             sys.calls <- base::sys.calls
[13:21:39.514]             `[[` <- base::`[[`
[13:21:39.514]             `+` <- base::`+`
[13:21:39.514]             `<<-` <- base::`<<-`
[13:21:39.514]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:39.514]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:39.514]                   3L)]
[13:21:39.514]             }
[13:21:39.514]             function(cond) {
[13:21:39.514]                 is_error <- inherits(cond, "error")
[13:21:39.514]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:39.514]                   NULL)
[13:21:39.514]                 if (is_error) {
[13:21:39.514]                   sessionInformation <- function() {
[13:21:39.514]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:39.514]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:39.514]                       search = base::search(), system = base::Sys.info())
[13:21:39.514]                   }
[13:21:39.514]                   ...future.conditions[[length(...future.conditions) + 
[13:21:39.514]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:39.514]                     cond$call), session = sessionInformation(), 
[13:21:39.514]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:39.514]                   signalCondition(cond)
[13:21:39.514]                 }
[13:21:39.514]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:39.514]                 "immediateCondition"))) {
[13:21:39.514]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:39.514]                   ...future.conditions[[length(...future.conditions) + 
[13:21:39.514]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:39.514]                   if (TRUE && !signal) {
[13:21:39.514]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.514]                     {
[13:21:39.514]                       inherits <- base::inherits
[13:21:39.514]                       invokeRestart <- base::invokeRestart
[13:21:39.514]                       is.null <- base::is.null
[13:21:39.514]                       muffled <- FALSE
[13:21:39.514]                       if (inherits(cond, "message")) {
[13:21:39.514]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:39.514]                         if (muffled) 
[13:21:39.514]                           invokeRestart("muffleMessage")
[13:21:39.514]                       }
[13:21:39.514]                       else if (inherits(cond, "warning")) {
[13:21:39.514]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:39.514]                         if (muffled) 
[13:21:39.514]                           invokeRestart("muffleWarning")
[13:21:39.514]                       }
[13:21:39.514]                       else if (inherits(cond, "condition")) {
[13:21:39.514]                         if (!is.null(pattern)) {
[13:21:39.514]                           computeRestarts <- base::computeRestarts
[13:21:39.514]                           grepl <- base::grepl
[13:21:39.514]                           restarts <- computeRestarts(cond)
[13:21:39.514]                           for (restart in restarts) {
[13:21:39.514]                             name <- restart$name
[13:21:39.514]                             if (is.null(name)) 
[13:21:39.514]                               next
[13:21:39.514]                             if (!grepl(pattern, name)) 
[13:21:39.514]                               next
[13:21:39.514]                             invokeRestart(restart)
[13:21:39.514]                             muffled <- TRUE
[13:21:39.514]                             break
[13:21:39.514]                           }
[13:21:39.514]                         }
[13:21:39.514]                       }
[13:21:39.514]                       invisible(muffled)
[13:21:39.514]                     }
[13:21:39.514]                     muffleCondition(cond, pattern = "^muffle")
[13:21:39.514]                   }
[13:21:39.514]                 }
[13:21:39.514]                 else {
[13:21:39.514]                   if (TRUE) {
[13:21:39.514]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.514]                     {
[13:21:39.514]                       inherits <- base::inherits
[13:21:39.514]                       invokeRestart <- base::invokeRestart
[13:21:39.514]                       is.null <- base::is.null
[13:21:39.514]                       muffled <- FALSE
[13:21:39.514]                       if (inherits(cond, "message")) {
[13:21:39.514]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:39.514]                         if (muffled) 
[13:21:39.514]                           invokeRestart("muffleMessage")
[13:21:39.514]                       }
[13:21:39.514]                       else if (inherits(cond, "warning")) {
[13:21:39.514]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:39.514]                         if (muffled) 
[13:21:39.514]                           invokeRestart("muffleWarning")
[13:21:39.514]                       }
[13:21:39.514]                       else if (inherits(cond, "condition")) {
[13:21:39.514]                         if (!is.null(pattern)) {
[13:21:39.514]                           computeRestarts <- base::computeRestarts
[13:21:39.514]                           grepl <- base::grepl
[13:21:39.514]                           restarts <- computeRestarts(cond)
[13:21:39.514]                           for (restart in restarts) {
[13:21:39.514]                             name <- restart$name
[13:21:39.514]                             if (is.null(name)) 
[13:21:39.514]                               next
[13:21:39.514]                             if (!grepl(pattern, name)) 
[13:21:39.514]                               next
[13:21:39.514]                             invokeRestart(restart)
[13:21:39.514]                             muffled <- TRUE
[13:21:39.514]                             break
[13:21:39.514]                           }
[13:21:39.514]                         }
[13:21:39.514]                       }
[13:21:39.514]                       invisible(muffled)
[13:21:39.514]                     }
[13:21:39.514]                     muffleCondition(cond, pattern = "^muffle")
[13:21:39.514]                   }
[13:21:39.514]                 }
[13:21:39.514]             }
[13:21:39.514]         }))
[13:21:39.514]     }, error = function(ex) {
[13:21:39.514]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:39.514]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:39.514]                 ...future.rng), started = ...future.startTime, 
[13:21:39.514]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:39.514]             version = "1.8"), class = "FutureResult")
[13:21:39.514]     }, finally = {
[13:21:39.514]         if (!identical(...future.workdir, getwd())) 
[13:21:39.514]             setwd(...future.workdir)
[13:21:39.514]         {
[13:21:39.514]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:39.514]                 ...future.oldOptions$nwarnings <- NULL
[13:21:39.514]             }
[13:21:39.514]             base::options(...future.oldOptions)
[13:21:39.514]             if (.Platform$OS.type == "windows") {
[13:21:39.514]                 old_names <- names(...future.oldEnvVars)
[13:21:39.514]                 envs <- base::Sys.getenv()
[13:21:39.514]                 names <- names(envs)
[13:21:39.514]                 common <- intersect(names, old_names)
[13:21:39.514]                 added <- setdiff(names, old_names)
[13:21:39.514]                 removed <- setdiff(old_names, names)
[13:21:39.514]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:39.514]                   envs[common]]
[13:21:39.514]                 NAMES <- toupper(changed)
[13:21:39.514]                 args <- list()
[13:21:39.514]                 for (kk in seq_along(NAMES)) {
[13:21:39.514]                   name <- changed[[kk]]
[13:21:39.514]                   NAME <- NAMES[[kk]]
[13:21:39.514]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.514]                     next
[13:21:39.514]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:39.514]                 }
[13:21:39.514]                 NAMES <- toupper(added)
[13:21:39.514]                 for (kk in seq_along(NAMES)) {
[13:21:39.514]                   name <- added[[kk]]
[13:21:39.514]                   NAME <- NAMES[[kk]]
[13:21:39.514]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.514]                     next
[13:21:39.514]                   args[[name]] <- ""
[13:21:39.514]                 }
[13:21:39.514]                 NAMES <- toupper(removed)
[13:21:39.514]                 for (kk in seq_along(NAMES)) {
[13:21:39.514]                   name <- removed[[kk]]
[13:21:39.514]                   NAME <- NAMES[[kk]]
[13:21:39.514]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.514]                     next
[13:21:39.514]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:39.514]                 }
[13:21:39.514]                 if (length(args) > 0) 
[13:21:39.514]                   base::do.call(base::Sys.setenv, args = args)
[13:21:39.514]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:39.514]             }
[13:21:39.514]             else {
[13:21:39.514]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:39.514]             }
[13:21:39.514]             {
[13:21:39.514]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:39.514]                   0L) {
[13:21:39.514]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:39.514]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:39.514]                   base::options(opts)
[13:21:39.514]                 }
[13:21:39.514]                 {
[13:21:39.514]                   {
[13:21:39.514]                     NULL
[13:21:39.514]                     RNGkind("Mersenne-Twister")
[13:21:39.514]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:39.514]                       inherits = FALSE)
[13:21:39.514]                   }
[13:21:39.514]                   options(future.plan = NULL)
[13:21:39.514]                   if (is.na(NA_character_)) 
[13:21:39.514]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:39.514]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:39.514]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:39.514]                   {
[13:21:39.514]                     future <- SequentialFuture(..., envir = envir)
[13:21:39.514]                     if (!future$lazy) 
[13:21:39.514]                       future <- run(future)
[13:21:39.514]                     invisible(future)
[13:21:39.514]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:39.514]                 }
[13:21:39.514]             }
[13:21:39.514]         }
[13:21:39.514]     })
[13:21:39.514]     if (TRUE) {
[13:21:39.514]         base::sink(type = "output", split = FALSE)
[13:21:39.514]         if (TRUE) {
[13:21:39.514]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:39.514]         }
[13:21:39.514]         else {
[13:21:39.514]             ...future.result["stdout"] <- base::list(NULL)
[13:21:39.514]         }
[13:21:39.514]         base::close(...future.stdout)
[13:21:39.514]         ...future.stdout <- NULL
[13:21:39.514]     }
[13:21:39.514]     ...future.result$conditions <- ...future.conditions
[13:21:39.514]     ...future.result$finished <- base::Sys.time()
[13:21:39.514]     ...future.result
[13:21:39.514] }
[13:21:39.516] plan(): Setting new future strategy stack:
[13:21:39.516] List of future strategies:
[13:21:39.516] 1. sequential:
[13:21:39.516]    - args: function (..., envir = parent.frame())
[13:21:39.516]    - tweaked: FALSE
[13:21:39.516]    - call: NULL
[13:21:39.516] plan(): nbrOfWorkers() = 1
[13:21:39.517] plan(): Setting new future strategy stack:
[13:21:39.517] List of future strategies:
[13:21:39.517] 1. sequential:
[13:21:39.517]    - args: function (..., envir = parent.frame())
[13:21:39.517]    - tweaked: FALSE
[13:21:39.517]    - call: plan(strategy)
[13:21:39.518] plan(): nbrOfWorkers() = 1
[13:21:39.518] SequentialFuture started (and completed)
[13:21:39.518] - Launch lazy future ... done
[13:21:39.518] run() for ‘SequentialFuture’ ... done
[13:21:39.518] getGlobalsAndPackages() ...
[13:21:39.518] Searching for globals...
[13:21:39.519] - globals found: [1] ‘{’
[13:21:39.519] Searching for globals ... DONE
[13:21:39.519] Resolving globals: FALSE
[13:21:39.519] 
[13:21:39.519] 
[13:21:39.520] getGlobalsAndPackages() ... DONE
[13:21:39.520] run() for ‘Future’ ...
[13:21:39.520] - state: ‘created’
[13:21:39.520] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:39.520] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:39.520] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:39.520]   - Field: ‘label’
[13:21:39.521]   - Field: ‘local’
[13:21:39.521]   - Field: ‘owner’
[13:21:39.521]   - Field: ‘envir’
[13:21:39.521]   - Field: ‘packages’
[13:21:39.521]   - Field: ‘gc’
[13:21:39.521]   - Field: ‘conditions’
[13:21:39.521]   - Field: ‘expr’
[13:21:39.521]   - Field: ‘uuid’
[13:21:39.521]   - Field: ‘seed’
[13:21:39.521]   - Field: ‘version’
[13:21:39.522]   - Field: ‘result’
[13:21:39.522]   - Field: ‘asynchronous’
[13:21:39.522]   - Field: ‘calls’
[13:21:39.522]   - Field: ‘globals’
[13:21:39.522]   - Field: ‘stdout’
[13:21:39.522]   - Field: ‘earlySignal’
[13:21:39.522]   - Field: ‘lazy’
[13:21:39.522]   - Field: ‘state’
[13:21:39.522] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:39.522] - Launch lazy future ...
[13:21:39.523] Packages needed by the future expression (n = 0): <none>
[13:21:39.523] Packages needed by future strategies (n = 0): <none>
[13:21:39.523] {
[13:21:39.523]     {
[13:21:39.523]         {
[13:21:39.523]             ...future.startTime <- base::Sys.time()
[13:21:39.523]             {
[13:21:39.523]                 {
[13:21:39.523]                   {
[13:21:39.523]                     base::local({
[13:21:39.523]                       has_future <- base::requireNamespace("future", 
[13:21:39.523]                         quietly = TRUE)
[13:21:39.523]                       if (has_future) {
[13:21:39.523]                         ns <- base::getNamespace("future")
[13:21:39.523]                         version <- ns[[".package"]][["version"]]
[13:21:39.523]                         if (is.null(version)) 
[13:21:39.523]                           version <- utils::packageVersion("future")
[13:21:39.523]                       }
[13:21:39.523]                       else {
[13:21:39.523]                         version <- NULL
[13:21:39.523]                       }
[13:21:39.523]                       if (!has_future || version < "1.8.0") {
[13:21:39.523]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:39.523]                           "", base::R.version$version.string), 
[13:21:39.523]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:39.523]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:39.523]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:39.523]                             "release", "version")], collapse = " "), 
[13:21:39.523]                           hostname = base::Sys.info()[["nodename"]])
[13:21:39.523]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:39.523]                           info)
[13:21:39.523]                         info <- base::paste(info, collapse = "; ")
[13:21:39.523]                         if (!has_future) {
[13:21:39.523]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:39.523]                             info)
[13:21:39.523]                         }
[13:21:39.523]                         else {
[13:21:39.523]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:39.523]                             info, version)
[13:21:39.523]                         }
[13:21:39.523]                         base::stop(msg)
[13:21:39.523]                       }
[13:21:39.523]                     })
[13:21:39.523]                   }
[13:21:39.523]                   options(future.plan = NULL)
[13:21:39.523]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:39.523]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:39.523]                 }
[13:21:39.523]                 ...future.workdir <- getwd()
[13:21:39.523]             }
[13:21:39.523]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:39.523]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:39.523]         }
[13:21:39.523]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:39.523]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:39.523]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:39.523]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:39.523]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:39.523]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:39.523]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:39.523]             base::names(...future.oldOptions))
[13:21:39.523]     }
[13:21:39.523]     if (FALSE) {
[13:21:39.523]     }
[13:21:39.523]     else {
[13:21:39.523]         if (TRUE) {
[13:21:39.523]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:39.523]                 open = "w")
[13:21:39.523]         }
[13:21:39.523]         else {
[13:21:39.523]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:39.523]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:39.523]         }
[13:21:39.523]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:39.523]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:39.523]             base::sink(type = "output", split = FALSE)
[13:21:39.523]             base::close(...future.stdout)
[13:21:39.523]         }, add = TRUE)
[13:21:39.523]     }
[13:21:39.523]     ...future.frame <- base::sys.nframe()
[13:21:39.523]     ...future.conditions <- base::list()
[13:21:39.523]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:39.523]     if (FALSE) {
[13:21:39.523]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:39.523]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:39.523]     }
[13:21:39.523]     ...future.result <- base::tryCatch({
[13:21:39.523]         base::withCallingHandlers({
[13:21:39.523]             ...future.value <- base::withVisible(base::local({
[13:21:39.523]                 2
[13:21:39.523]             }))
[13:21:39.523]             future::FutureResult(value = ...future.value$value, 
[13:21:39.523]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:39.523]                   ...future.rng), globalenv = if (FALSE) 
[13:21:39.523]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:39.523]                     ...future.globalenv.names))
[13:21:39.523]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:39.523]         }, condition = base::local({
[13:21:39.523]             c <- base::c
[13:21:39.523]             inherits <- base::inherits
[13:21:39.523]             invokeRestart <- base::invokeRestart
[13:21:39.523]             length <- base::length
[13:21:39.523]             list <- base::list
[13:21:39.523]             seq.int <- base::seq.int
[13:21:39.523]             signalCondition <- base::signalCondition
[13:21:39.523]             sys.calls <- base::sys.calls
[13:21:39.523]             `[[` <- base::`[[`
[13:21:39.523]             `+` <- base::`+`
[13:21:39.523]             `<<-` <- base::`<<-`
[13:21:39.523]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:39.523]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:39.523]                   3L)]
[13:21:39.523]             }
[13:21:39.523]             function(cond) {
[13:21:39.523]                 is_error <- inherits(cond, "error")
[13:21:39.523]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:39.523]                   NULL)
[13:21:39.523]                 if (is_error) {
[13:21:39.523]                   sessionInformation <- function() {
[13:21:39.523]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:39.523]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:39.523]                       search = base::search(), system = base::Sys.info())
[13:21:39.523]                   }
[13:21:39.523]                   ...future.conditions[[length(...future.conditions) + 
[13:21:39.523]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:39.523]                     cond$call), session = sessionInformation(), 
[13:21:39.523]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:39.523]                   signalCondition(cond)
[13:21:39.523]                 }
[13:21:39.523]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:39.523]                 "immediateCondition"))) {
[13:21:39.523]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:39.523]                   ...future.conditions[[length(...future.conditions) + 
[13:21:39.523]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:39.523]                   if (TRUE && !signal) {
[13:21:39.523]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.523]                     {
[13:21:39.523]                       inherits <- base::inherits
[13:21:39.523]                       invokeRestart <- base::invokeRestart
[13:21:39.523]                       is.null <- base::is.null
[13:21:39.523]                       muffled <- FALSE
[13:21:39.523]                       if (inherits(cond, "message")) {
[13:21:39.523]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:39.523]                         if (muffled) 
[13:21:39.523]                           invokeRestart("muffleMessage")
[13:21:39.523]                       }
[13:21:39.523]                       else if (inherits(cond, "warning")) {
[13:21:39.523]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:39.523]                         if (muffled) 
[13:21:39.523]                           invokeRestart("muffleWarning")
[13:21:39.523]                       }
[13:21:39.523]                       else if (inherits(cond, "condition")) {
[13:21:39.523]                         if (!is.null(pattern)) {
[13:21:39.523]                           computeRestarts <- base::computeRestarts
[13:21:39.523]                           grepl <- base::grepl
[13:21:39.523]                           restarts <- computeRestarts(cond)
[13:21:39.523]                           for (restart in restarts) {
[13:21:39.523]                             name <- restart$name
[13:21:39.523]                             if (is.null(name)) 
[13:21:39.523]                               next
[13:21:39.523]                             if (!grepl(pattern, name)) 
[13:21:39.523]                               next
[13:21:39.523]                             invokeRestart(restart)
[13:21:39.523]                             muffled <- TRUE
[13:21:39.523]                             break
[13:21:39.523]                           }
[13:21:39.523]                         }
[13:21:39.523]                       }
[13:21:39.523]                       invisible(muffled)
[13:21:39.523]                     }
[13:21:39.523]                     muffleCondition(cond, pattern = "^muffle")
[13:21:39.523]                   }
[13:21:39.523]                 }
[13:21:39.523]                 else {
[13:21:39.523]                   if (TRUE) {
[13:21:39.523]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.523]                     {
[13:21:39.523]                       inherits <- base::inherits
[13:21:39.523]                       invokeRestart <- base::invokeRestart
[13:21:39.523]                       is.null <- base::is.null
[13:21:39.523]                       muffled <- FALSE
[13:21:39.523]                       if (inherits(cond, "message")) {
[13:21:39.523]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:39.523]                         if (muffled) 
[13:21:39.523]                           invokeRestart("muffleMessage")
[13:21:39.523]                       }
[13:21:39.523]                       else if (inherits(cond, "warning")) {
[13:21:39.523]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:39.523]                         if (muffled) 
[13:21:39.523]                           invokeRestart("muffleWarning")
[13:21:39.523]                       }
[13:21:39.523]                       else if (inherits(cond, "condition")) {
[13:21:39.523]                         if (!is.null(pattern)) {
[13:21:39.523]                           computeRestarts <- base::computeRestarts
[13:21:39.523]                           grepl <- base::grepl
[13:21:39.523]                           restarts <- computeRestarts(cond)
[13:21:39.523]                           for (restart in restarts) {
[13:21:39.523]                             name <- restart$name
[13:21:39.523]                             if (is.null(name)) 
[13:21:39.523]                               next
[13:21:39.523]                             if (!grepl(pattern, name)) 
[13:21:39.523]                               next
[13:21:39.523]                             invokeRestart(restart)
[13:21:39.523]                             muffled <- TRUE
[13:21:39.523]                             break
[13:21:39.523]                           }
[13:21:39.523]                         }
[13:21:39.523]                       }
[13:21:39.523]                       invisible(muffled)
[13:21:39.523]                     }
[13:21:39.523]                     muffleCondition(cond, pattern = "^muffle")
[13:21:39.523]                   }
[13:21:39.523]                 }
[13:21:39.523]             }
[13:21:39.523]         }))
[13:21:39.523]     }, error = function(ex) {
[13:21:39.523]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:39.523]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:39.523]                 ...future.rng), started = ...future.startTime, 
[13:21:39.523]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:39.523]             version = "1.8"), class = "FutureResult")
[13:21:39.523]     }, finally = {
[13:21:39.523]         if (!identical(...future.workdir, getwd())) 
[13:21:39.523]             setwd(...future.workdir)
[13:21:39.523]         {
[13:21:39.523]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:39.523]                 ...future.oldOptions$nwarnings <- NULL
[13:21:39.523]             }
[13:21:39.523]             base::options(...future.oldOptions)
[13:21:39.523]             if (.Platform$OS.type == "windows") {
[13:21:39.523]                 old_names <- names(...future.oldEnvVars)
[13:21:39.523]                 envs <- base::Sys.getenv()
[13:21:39.523]                 names <- names(envs)
[13:21:39.523]                 common <- intersect(names, old_names)
[13:21:39.523]                 added <- setdiff(names, old_names)
[13:21:39.523]                 removed <- setdiff(old_names, names)
[13:21:39.523]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:39.523]                   envs[common]]
[13:21:39.523]                 NAMES <- toupper(changed)
[13:21:39.523]                 args <- list()
[13:21:39.523]                 for (kk in seq_along(NAMES)) {
[13:21:39.523]                   name <- changed[[kk]]
[13:21:39.523]                   NAME <- NAMES[[kk]]
[13:21:39.523]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.523]                     next
[13:21:39.523]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:39.523]                 }
[13:21:39.523]                 NAMES <- toupper(added)
[13:21:39.523]                 for (kk in seq_along(NAMES)) {
[13:21:39.523]                   name <- added[[kk]]
[13:21:39.523]                   NAME <- NAMES[[kk]]
[13:21:39.523]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.523]                     next
[13:21:39.523]                   args[[name]] <- ""
[13:21:39.523]                 }
[13:21:39.523]                 NAMES <- toupper(removed)
[13:21:39.523]                 for (kk in seq_along(NAMES)) {
[13:21:39.523]                   name <- removed[[kk]]
[13:21:39.523]                   NAME <- NAMES[[kk]]
[13:21:39.523]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.523]                     next
[13:21:39.523]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:39.523]                 }
[13:21:39.523]                 if (length(args) > 0) 
[13:21:39.523]                   base::do.call(base::Sys.setenv, args = args)
[13:21:39.523]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:39.523]             }
[13:21:39.523]             else {
[13:21:39.523]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:39.523]             }
[13:21:39.523]             {
[13:21:39.523]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:39.523]                   0L) {
[13:21:39.523]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:39.523]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:39.523]                   base::options(opts)
[13:21:39.523]                 }
[13:21:39.523]                 {
[13:21:39.523]                   {
[13:21:39.523]                     NULL
[13:21:39.523]                     RNGkind("Mersenne-Twister")
[13:21:39.523]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:39.523]                       inherits = FALSE)
[13:21:39.523]                   }
[13:21:39.523]                   options(future.plan = NULL)
[13:21:39.523]                   if (is.na(NA_character_)) 
[13:21:39.523]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:39.523]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:39.523]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:39.523]                   {
[13:21:39.523]                     future <- SequentialFuture(..., envir = envir)
[13:21:39.523]                     if (!future$lazy) 
[13:21:39.523]                       future <- run(future)
[13:21:39.523]                     invisible(future)
[13:21:39.523]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:39.523]                 }
[13:21:39.523]             }
[13:21:39.523]         }
[13:21:39.523]     })
[13:21:39.523]     if (TRUE) {
[13:21:39.523]         base::sink(type = "output", split = FALSE)
[13:21:39.523]         if (TRUE) {
[13:21:39.523]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:39.523]         }
[13:21:39.523]         else {
[13:21:39.523]             ...future.result["stdout"] <- base::list(NULL)
[13:21:39.523]         }
[13:21:39.523]         base::close(...future.stdout)
[13:21:39.523]         ...future.stdout <- NULL
[13:21:39.523]     }
[13:21:39.523]     ...future.result$conditions <- ...future.conditions
[13:21:39.523]     ...future.result$finished <- base::Sys.time()
[13:21:39.523]     ...future.result
[13:21:39.523] }
[13:21:39.525] plan(): Setting new future strategy stack:
[13:21:39.525] List of future strategies:
[13:21:39.525] 1. sequential:
[13:21:39.525]    - args: function (..., envir = parent.frame())
[13:21:39.525]    - tweaked: FALSE
[13:21:39.525]    - call: NULL
[13:21:39.525] plan(): nbrOfWorkers() = 1
[13:21:39.526] plan(): Setting new future strategy stack:
[13:21:39.526] List of future strategies:
[13:21:39.526] 1. sequential:
[13:21:39.526]    - args: function (..., envir = parent.frame())
[13:21:39.526]    - tweaked: FALSE
[13:21:39.526]    - call: plan(strategy)
[13:21:39.527] plan(): nbrOfWorkers() = 1
[13:21:39.527] SequentialFuture started (and completed)
[13:21:39.529] - Launch lazy future ... done
[13:21:39.529] run() for ‘SequentialFuture’ ... done
[13:21:39.529] resolve() on list environment ...
[13:21:39.530]  recursive: 0
[13:21:39.530]  length: 3
[13:21:39.530]  elements: ‘a’, ‘b’, ‘c’
[13:21:39.530] resolved() for ‘SequentialFuture’ ...
[13:21:39.530] - state: ‘finished’
[13:21:39.531] - run: TRUE
[13:21:39.531] - result: ‘FutureResult’
[13:21:39.531] resolved() for ‘SequentialFuture’ ... done
[13:21:39.531] Future #1
[13:21:39.531]  length: 2 (resolved future 1)
[13:21:39.531] resolved() for ‘SequentialFuture’ ...
[13:21:39.531] - state: ‘finished’
[13:21:39.531] - run: TRUE
[13:21:39.531] - result: ‘FutureResult’
[13:21:39.531] resolved() for ‘SequentialFuture’ ... done
[13:21:39.532] Future #2
[13:21:39.532]  length: 1 (resolved future 2)
[13:21:39.532]  length: 0 (resolved future 3)
[13:21:39.532] resolve() on list environment ... DONE
[13:21:39.532] getGlobalsAndPackages() ...
[13:21:39.532] Searching for globals...
[13:21:39.533] - globals found: [1] ‘{’
[13:21:39.533] Searching for globals ... DONE
[13:21:39.533] Resolving globals: FALSE
[13:21:39.533] 
[13:21:39.534] 
[13:21:39.534] getGlobalsAndPackages() ... DONE
[13:21:39.534] run() for ‘Future’ ...
[13:21:39.534] - state: ‘created’
[13:21:39.534] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:39.534] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:39.535] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:39.535]   - Field: ‘label’
[13:21:39.535]   - Field: ‘local’
[13:21:39.535]   - Field: ‘owner’
[13:21:39.535]   - Field: ‘envir’
[13:21:39.535]   - Field: ‘packages’
[13:21:39.535]   - Field: ‘gc’
[13:21:39.535]   - Field: ‘conditions’
[13:21:39.535]   - Field: ‘expr’
[13:21:39.535]   - Field: ‘uuid’
[13:21:39.535]   - Field: ‘seed’
[13:21:39.536]   - Field: ‘version’
[13:21:39.536]   - Field: ‘result’
[13:21:39.536]   - Field: ‘asynchronous’
[13:21:39.536]   - Field: ‘calls’
[13:21:39.536]   - Field: ‘globals’
[13:21:39.536]   - Field: ‘stdout’
[13:21:39.536]   - Field: ‘earlySignal’
[13:21:39.536]   - Field: ‘lazy’
[13:21:39.536]   - Field: ‘state’
[13:21:39.536] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:39.536] - Launch lazy future ...
[13:21:39.537] Packages needed by the future expression (n = 0): <none>
[13:21:39.537] Packages needed by future strategies (n = 0): <none>
[13:21:39.537] {
[13:21:39.537]     {
[13:21:39.537]         {
[13:21:39.537]             ...future.startTime <- base::Sys.time()
[13:21:39.537]             {
[13:21:39.537]                 {
[13:21:39.537]                   {
[13:21:39.537]                     base::local({
[13:21:39.537]                       has_future <- base::requireNamespace("future", 
[13:21:39.537]                         quietly = TRUE)
[13:21:39.537]                       if (has_future) {
[13:21:39.537]                         ns <- base::getNamespace("future")
[13:21:39.537]                         version <- ns[[".package"]][["version"]]
[13:21:39.537]                         if (is.null(version)) 
[13:21:39.537]                           version <- utils::packageVersion("future")
[13:21:39.537]                       }
[13:21:39.537]                       else {
[13:21:39.537]                         version <- NULL
[13:21:39.537]                       }
[13:21:39.537]                       if (!has_future || version < "1.8.0") {
[13:21:39.537]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:39.537]                           "", base::R.version$version.string), 
[13:21:39.537]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:39.537]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:39.537]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:39.537]                             "release", "version")], collapse = " "), 
[13:21:39.537]                           hostname = base::Sys.info()[["nodename"]])
[13:21:39.537]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:39.537]                           info)
[13:21:39.537]                         info <- base::paste(info, collapse = "; ")
[13:21:39.537]                         if (!has_future) {
[13:21:39.537]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:39.537]                             info)
[13:21:39.537]                         }
[13:21:39.537]                         else {
[13:21:39.537]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:39.537]                             info, version)
[13:21:39.537]                         }
[13:21:39.537]                         base::stop(msg)
[13:21:39.537]                       }
[13:21:39.537]                     })
[13:21:39.537]                   }
[13:21:39.537]                   options(future.plan = NULL)
[13:21:39.537]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:39.537]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:39.537]                 }
[13:21:39.537]                 ...future.workdir <- getwd()
[13:21:39.537]             }
[13:21:39.537]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:39.537]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:39.537]         }
[13:21:39.537]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:39.537]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:39.537]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:39.537]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:39.537]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:39.537]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:39.537]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:39.537]             base::names(...future.oldOptions))
[13:21:39.537]     }
[13:21:39.537]     if (FALSE) {
[13:21:39.537]     }
[13:21:39.537]     else {
[13:21:39.537]         if (TRUE) {
[13:21:39.537]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:39.537]                 open = "w")
[13:21:39.537]         }
[13:21:39.537]         else {
[13:21:39.537]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:39.537]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:39.537]         }
[13:21:39.537]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:39.537]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:39.537]             base::sink(type = "output", split = FALSE)
[13:21:39.537]             base::close(...future.stdout)
[13:21:39.537]         }, add = TRUE)
[13:21:39.537]     }
[13:21:39.537]     ...future.frame <- base::sys.nframe()
[13:21:39.537]     ...future.conditions <- base::list()
[13:21:39.537]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:39.537]     if (FALSE) {
[13:21:39.537]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:39.537]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:39.537]     }
[13:21:39.537]     ...future.result <- base::tryCatch({
[13:21:39.537]         base::withCallingHandlers({
[13:21:39.537]             ...future.value <- base::withVisible(base::local({
[13:21:39.537]                 1
[13:21:39.537]             }))
[13:21:39.537]             future::FutureResult(value = ...future.value$value, 
[13:21:39.537]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:39.537]                   ...future.rng), globalenv = if (FALSE) 
[13:21:39.537]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:39.537]                     ...future.globalenv.names))
[13:21:39.537]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:39.537]         }, condition = base::local({
[13:21:39.537]             c <- base::c
[13:21:39.537]             inherits <- base::inherits
[13:21:39.537]             invokeRestart <- base::invokeRestart
[13:21:39.537]             length <- base::length
[13:21:39.537]             list <- base::list
[13:21:39.537]             seq.int <- base::seq.int
[13:21:39.537]             signalCondition <- base::signalCondition
[13:21:39.537]             sys.calls <- base::sys.calls
[13:21:39.537]             `[[` <- base::`[[`
[13:21:39.537]             `+` <- base::`+`
[13:21:39.537]             `<<-` <- base::`<<-`
[13:21:39.537]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:39.537]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:39.537]                   3L)]
[13:21:39.537]             }
[13:21:39.537]             function(cond) {
[13:21:39.537]                 is_error <- inherits(cond, "error")
[13:21:39.537]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:39.537]                   NULL)
[13:21:39.537]                 if (is_error) {
[13:21:39.537]                   sessionInformation <- function() {
[13:21:39.537]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:39.537]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:39.537]                       search = base::search(), system = base::Sys.info())
[13:21:39.537]                   }
[13:21:39.537]                   ...future.conditions[[length(...future.conditions) + 
[13:21:39.537]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:39.537]                     cond$call), session = sessionInformation(), 
[13:21:39.537]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:39.537]                   signalCondition(cond)
[13:21:39.537]                 }
[13:21:39.537]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:39.537]                 "immediateCondition"))) {
[13:21:39.537]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:39.537]                   ...future.conditions[[length(...future.conditions) + 
[13:21:39.537]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:39.537]                   if (TRUE && !signal) {
[13:21:39.537]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.537]                     {
[13:21:39.537]                       inherits <- base::inherits
[13:21:39.537]                       invokeRestart <- base::invokeRestart
[13:21:39.537]                       is.null <- base::is.null
[13:21:39.537]                       muffled <- FALSE
[13:21:39.537]                       if (inherits(cond, "message")) {
[13:21:39.537]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:39.537]                         if (muffled) 
[13:21:39.537]                           invokeRestart("muffleMessage")
[13:21:39.537]                       }
[13:21:39.537]                       else if (inherits(cond, "warning")) {
[13:21:39.537]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:39.537]                         if (muffled) 
[13:21:39.537]                           invokeRestart("muffleWarning")
[13:21:39.537]                       }
[13:21:39.537]                       else if (inherits(cond, "condition")) {
[13:21:39.537]                         if (!is.null(pattern)) {
[13:21:39.537]                           computeRestarts <- base::computeRestarts
[13:21:39.537]                           grepl <- base::grepl
[13:21:39.537]                           restarts <- computeRestarts(cond)
[13:21:39.537]                           for (restart in restarts) {
[13:21:39.537]                             name <- restart$name
[13:21:39.537]                             if (is.null(name)) 
[13:21:39.537]                               next
[13:21:39.537]                             if (!grepl(pattern, name)) 
[13:21:39.537]                               next
[13:21:39.537]                             invokeRestart(restart)
[13:21:39.537]                             muffled <- TRUE
[13:21:39.537]                             break
[13:21:39.537]                           }
[13:21:39.537]                         }
[13:21:39.537]                       }
[13:21:39.537]                       invisible(muffled)
[13:21:39.537]                     }
[13:21:39.537]                     muffleCondition(cond, pattern = "^muffle")
[13:21:39.537]                   }
[13:21:39.537]                 }
[13:21:39.537]                 else {
[13:21:39.537]                   if (TRUE) {
[13:21:39.537]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.537]                     {
[13:21:39.537]                       inherits <- base::inherits
[13:21:39.537]                       invokeRestart <- base::invokeRestart
[13:21:39.537]                       is.null <- base::is.null
[13:21:39.537]                       muffled <- FALSE
[13:21:39.537]                       if (inherits(cond, "message")) {
[13:21:39.537]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:39.537]                         if (muffled) 
[13:21:39.537]                           invokeRestart("muffleMessage")
[13:21:39.537]                       }
[13:21:39.537]                       else if (inherits(cond, "warning")) {
[13:21:39.537]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:39.537]                         if (muffled) 
[13:21:39.537]                           invokeRestart("muffleWarning")
[13:21:39.537]                       }
[13:21:39.537]                       else if (inherits(cond, "condition")) {
[13:21:39.537]                         if (!is.null(pattern)) {
[13:21:39.537]                           computeRestarts <- base::computeRestarts
[13:21:39.537]                           grepl <- base::grepl
[13:21:39.537]                           restarts <- computeRestarts(cond)
[13:21:39.537]                           for (restart in restarts) {
[13:21:39.537]                             name <- restart$name
[13:21:39.537]                             if (is.null(name)) 
[13:21:39.537]                               next
[13:21:39.537]                             if (!grepl(pattern, name)) 
[13:21:39.537]                               next
[13:21:39.537]                             invokeRestart(restart)
[13:21:39.537]                             muffled <- TRUE
[13:21:39.537]                             break
[13:21:39.537]                           }
[13:21:39.537]                         }
[13:21:39.537]                       }
[13:21:39.537]                       invisible(muffled)
[13:21:39.537]                     }
[13:21:39.537]                     muffleCondition(cond, pattern = "^muffle")
[13:21:39.537]                   }
[13:21:39.537]                 }
[13:21:39.537]             }
[13:21:39.537]         }))
[13:21:39.537]     }, error = function(ex) {
[13:21:39.537]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:39.537]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:39.537]                 ...future.rng), started = ...future.startTime, 
[13:21:39.537]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:39.537]             version = "1.8"), class = "FutureResult")
[13:21:39.537]     }, finally = {
[13:21:39.537]         if (!identical(...future.workdir, getwd())) 
[13:21:39.537]             setwd(...future.workdir)
[13:21:39.537]         {
[13:21:39.537]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:39.537]                 ...future.oldOptions$nwarnings <- NULL
[13:21:39.537]             }
[13:21:39.537]             base::options(...future.oldOptions)
[13:21:39.537]             if (.Platform$OS.type == "windows") {
[13:21:39.537]                 old_names <- names(...future.oldEnvVars)
[13:21:39.537]                 envs <- base::Sys.getenv()
[13:21:39.537]                 names <- names(envs)
[13:21:39.537]                 common <- intersect(names, old_names)
[13:21:39.537]                 added <- setdiff(names, old_names)
[13:21:39.537]                 removed <- setdiff(old_names, names)
[13:21:39.537]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:39.537]                   envs[common]]
[13:21:39.537]                 NAMES <- toupper(changed)
[13:21:39.537]                 args <- list()
[13:21:39.537]                 for (kk in seq_along(NAMES)) {
[13:21:39.537]                   name <- changed[[kk]]
[13:21:39.537]                   NAME <- NAMES[[kk]]
[13:21:39.537]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.537]                     next
[13:21:39.537]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:39.537]                 }
[13:21:39.537]                 NAMES <- toupper(added)
[13:21:39.537]                 for (kk in seq_along(NAMES)) {
[13:21:39.537]                   name <- added[[kk]]
[13:21:39.537]                   NAME <- NAMES[[kk]]
[13:21:39.537]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.537]                     next
[13:21:39.537]                   args[[name]] <- ""
[13:21:39.537]                 }
[13:21:39.537]                 NAMES <- toupper(removed)
[13:21:39.537]                 for (kk in seq_along(NAMES)) {
[13:21:39.537]                   name <- removed[[kk]]
[13:21:39.537]                   NAME <- NAMES[[kk]]
[13:21:39.537]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.537]                     next
[13:21:39.537]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:39.537]                 }
[13:21:39.537]                 if (length(args) > 0) 
[13:21:39.537]                   base::do.call(base::Sys.setenv, args = args)
[13:21:39.537]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:39.537]             }
[13:21:39.537]             else {
[13:21:39.537]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:39.537]             }
[13:21:39.537]             {
[13:21:39.537]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:39.537]                   0L) {
[13:21:39.537]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:39.537]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:39.537]                   base::options(opts)
[13:21:39.537]                 }
[13:21:39.537]                 {
[13:21:39.537]                   {
[13:21:39.537]                     NULL
[13:21:39.537]                     RNGkind("Mersenne-Twister")
[13:21:39.537]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:39.537]                       inherits = FALSE)
[13:21:39.537]                   }
[13:21:39.537]                   options(future.plan = NULL)
[13:21:39.537]                   if (is.na(NA_character_)) 
[13:21:39.537]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:39.537]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:39.537]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:39.537]                   {
[13:21:39.537]                     future <- SequentialFuture(..., envir = envir)
[13:21:39.537]                     if (!future$lazy) 
[13:21:39.537]                       future <- run(future)
[13:21:39.537]                     invisible(future)
[13:21:39.537]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:39.537]                 }
[13:21:39.537]             }
[13:21:39.537]         }
[13:21:39.537]     })
[13:21:39.537]     if (TRUE) {
[13:21:39.537]         base::sink(type = "output", split = FALSE)
[13:21:39.537]         if (TRUE) {
[13:21:39.537]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:39.537]         }
[13:21:39.537]         else {
[13:21:39.537]             ...future.result["stdout"] <- base::list(NULL)
[13:21:39.537]         }
[13:21:39.537]         base::close(...future.stdout)
[13:21:39.537]         ...future.stdout <- NULL
[13:21:39.537]     }
[13:21:39.537]     ...future.result$conditions <- ...future.conditions
[13:21:39.537]     ...future.result$finished <- base::Sys.time()
[13:21:39.537]     ...future.result
[13:21:39.537] }
[13:21:39.539] plan(): Setting new future strategy stack:
[13:21:39.539] List of future strategies:
[13:21:39.539] 1. sequential:
[13:21:39.539]    - args: function (..., envir = parent.frame())
[13:21:39.539]    - tweaked: FALSE
[13:21:39.539]    - call: NULL
[13:21:39.540] plan(): nbrOfWorkers() = 1
[13:21:39.540] plan(): Setting new future strategy stack:
[13:21:39.540] List of future strategies:
[13:21:39.540] 1. sequential:
[13:21:39.540]    - args: function (..., envir = parent.frame())
[13:21:39.540]    - tweaked: FALSE
[13:21:39.540]    - call: plan(strategy)
[13:21:39.541] plan(): nbrOfWorkers() = 1
[13:21:39.541] SequentialFuture started (and completed)
[13:21:39.541] - Launch lazy future ... done
[13:21:39.541] run() for ‘SequentialFuture’ ... done
[13:21:39.542] getGlobalsAndPackages() ...
[13:21:39.542] Searching for globals...
[13:21:39.543] - globals found: [2] ‘{’, ‘Sys.sleep’
[13:21:39.543] Searching for globals ... DONE
[13:21:39.543] Resolving globals: FALSE
[13:21:39.543] 
[13:21:39.543] 
[13:21:39.543] getGlobalsAndPackages() ... DONE
[13:21:39.544] run() for ‘Future’ ...
[13:21:39.544] - state: ‘created’
[13:21:39.544] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:39.544] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:39.544] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:39.544]   - Field: ‘label’
[13:21:39.544]   - Field: ‘local’
[13:21:39.544]   - Field: ‘owner’
[13:21:39.545]   - Field: ‘envir’
[13:21:39.545]   - Field: ‘packages’
[13:21:39.545]   - Field: ‘gc’
[13:21:39.545]   - Field: ‘conditions’
[13:21:39.545]   - Field: ‘expr’
[13:21:39.545]   - Field: ‘uuid’
[13:21:39.545]   - Field: ‘seed’
[13:21:39.545]   - Field: ‘version’
[13:21:39.545]   - Field: ‘result’
[13:21:39.545]   - Field: ‘asynchronous’
[13:21:39.545]   - Field: ‘calls’
[13:21:39.546]   - Field: ‘globals’
[13:21:39.546]   - Field: ‘stdout’
[13:21:39.546]   - Field: ‘earlySignal’
[13:21:39.546]   - Field: ‘lazy’
[13:21:39.546]   - Field: ‘state’
[13:21:39.546] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:39.546] - Launch lazy future ...
[13:21:39.546] Packages needed by the future expression (n = 0): <none>
[13:21:39.546] Packages needed by future strategies (n = 0): <none>
[13:21:39.547] {
[13:21:39.547]     {
[13:21:39.547]         {
[13:21:39.547]             ...future.startTime <- base::Sys.time()
[13:21:39.547]             {
[13:21:39.547]                 {
[13:21:39.547]                   {
[13:21:39.547]                     base::local({
[13:21:39.547]                       has_future <- base::requireNamespace("future", 
[13:21:39.547]                         quietly = TRUE)
[13:21:39.547]                       if (has_future) {
[13:21:39.547]                         ns <- base::getNamespace("future")
[13:21:39.547]                         version <- ns[[".package"]][["version"]]
[13:21:39.547]                         if (is.null(version)) 
[13:21:39.547]                           version <- utils::packageVersion("future")
[13:21:39.547]                       }
[13:21:39.547]                       else {
[13:21:39.547]                         version <- NULL
[13:21:39.547]                       }
[13:21:39.547]                       if (!has_future || version < "1.8.0") {
[13:21:39.547]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:39.547]                           "", base::R.version$version.string), 
[13:21:39.547]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:39.547]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:39.547]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:39.547]                             "release", "version")], collapse = " "), 
[13:21:39.547]                           hostname = base::Sys.info()[["nodename"]])
[13:21:39.547]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:39.547]                           info)
[13:21:39.547]                         info <- base::paste(info, collapse = "; ")
[13:21:39.547]                         if (!has_future) {
[13:21:39.547]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:39.547]                             info)
[13:21:39.547]                         }
[13:21:39.547]                         else {
[13:21:39.547]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:39.547]                             info, version)
[13:21:39.547]                         }
[13:21:39.547]                         base::stop(msg)
[13:21:39.547]                       }
[13:21:39.547]                     })
[13:21:39.547]                   }
[13:21:39.547]                   options(future.plan = NULL)
[13:21:39.547]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:39.547]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:39.547]                 }
[13:21:39.547]                 ...future.workdir <- getwd()
[13:21:39.547]             }
[13:21:39.547]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:39.547]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:39.547]         }
[13:21:39.547]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:39.547]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:39.547]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:39.547]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:39.547]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:39.547]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:39.547]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:39.547]             base::names(...future.oldOptions))
[13:21:39.547]     }
[13:21:39.547]     if (FALSE) {
[13:21:39.547]     }
[13:21:39.547]     else {
[13:21:39.547]         if (TRUE) {
[13:21:39.547]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:39.547]                 open = "w")
[13:21:39.547]         }
[13:21:39.547]         else {
[13:21:39.547]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:39.547]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:39.547]         }
[13:21:39.547]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:39.547]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:39.547]             base::sink(type = "output", split = FALSE)
[13:21:39.547]             base::close(...future.stdout)
[13:21:39.547]         }, add = TRUE)
[13:21:39.547]     }
[13:21:39.547]     ...future.frame <- base::sys.nframe()
[13:21:39.547]     ...future.conditions <- base::list()
[13:21:39.547]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:39.547]     if (FALSE) {
[13:21:39.547]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:39.547]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:39.547]     }
[13:21:39.547]     ...future.result <- base::tryCatch({
[13:21:39.547]         base::withCallingHandlers({
[13:21:39.547]             ...future.value <- base::withVisible(base::local({
[13:21:39.547]                 Sys.sleep(0.5)
[13:21:39.547]                 2
[13:21:39.547]             }))
[13:21:39.547]             future::FutureResult(value = ...future.value$value, 
[13:21:39.547]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:39.547]                   ...future.rng), globalenv = if (FALSE) 
[13:21:39.547]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:39.547]                     ...future.globalenv.names))
[13:21:39.547]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:39.547]         }, condition = base::local({
[13:21:39.547]             c <- base::c
[13:21:39.547]             inherits <- base::inherits
[13:21:39.547]             invokeRestart <- base::invokeRestart
[13:21:39.547]             length <- base::length
[13:21:39.547]             list <- base::list
[13:21:39.547]             seq.int <- base::seq.int
[13:21:39.547]             signalCondition <- base::signalCondition
[13:21:39.547]             sys.calls <- base::sys.calls
[13:21:39.547]             `[[` <- base::`[[`
[13:21:39.547]             `+` <- base::`+`
[13:21:39.547]             `<<-` <- base::`<<-`
[13:21:39.547]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:39.547]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:39.547]                   3L)]
[13:21:39.547]             }
[13:21:39.547]             function(cond) {
[13:21:39.547]                 is_error <- inherits(cond, "error")
[13:21:39.547]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:39.547]                   NULL)
[13:21:39.547]                 if (is_error) {
[13:21:39.547]                   sessionInformation <- function() {
[13:21:39.547]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:39.547]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:39.547]                       search = base::search(), system = base::Sys.info())
[13:21:39.547]                   }
[13:21:39.547]                   ...future.conditions[[length(...future.conditions) + 
[13:21:39.547]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:39.547]                     cond$call), session = sessionInformation(), 
[13:21:39.547]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:39.547]                   signalCondition(cond)
[13:21:39.547]                 }
[13:21:39.547]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:39.547]                 "immediateCondition"))) {
[13:21:39.547]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:39.547]                   ...future.conditions[[length(...future.conditions) + 
[13:21:39.547]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:39.547]                   if (TRUE && !signal) {
[13:21:39.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.547]                     {
[13:21:39.547]                       inherits <- base::inherits
[13:21:39.547]                       invokeRestart <- base::invokeRestart
[13:21:39.547]                       is.null <- base::is.null
[13:21:39.547]                       muffled <- FALSE
[13:21:39.547]                       if (inherits(cond, "message")) {
[13:21:39.547]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:39.547]                         if (muffled) 
[13:21:39.547]                           invokeRestart("muffleMessage")
[13:21:39.547]                       }
[13:21:39.547]                       else if (inherits(cond, "warning")) {
[13:21:39.547]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:39.547]                         if (muffled) 
[13:21:39.547]                           invokeRestart("muffleWarning")
[13:21:39.547]                       }
[13:21:39.547]                       else if (inherits(cond, "condition")) {
[13:21:39.547]                         if (!is.null(pattern)) {
[13:21:39.547]                           computeRestarts <- base::computeRestarts
[13:21:39.547]                           grepl <- base::grepl
[13:21:39.547]                           restarts <- computeRestarts(cond)
[13:21:39.547]                           for (restart in restarts) {
[13:21:39.547]                             name <- restart$name
[13:21:39.547]                             if (is.null(name)) 
[13:21:39.547]                               next
[13:21:39.547]                             if (!grepl(pattern, name)) 
[13:21:39.547]                               next
[13:21:39.547]                             invokeRestart(restart)
[13:21:39.547]                             muffled <- TRUE
[13:21:39.547]                             break
[13:21:39.547]                           }
[13:21:39.547]                         }
[13:21:39.547]                       }
[13:21:39.547]                       invisible(muffled)
[13:21:39.547]                     }
[13:21:39.547]                     muffleCondition(cond, pattern = "^muffle")
[13:21:39.547]                   }
[13:21:39.547]                 }
[13:21:39.547]                 else {
[13:21:39.547]                   if (TRUE) {
[13:21:39.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:39.547]                     {
[13:21:39.547]                       inherits <- base::inherits
[13:21:39.547]                       invokeRestart <- base::invokeRestart
[13:21:39.547]                       is.null <- base::is.null
[13:21:39.547]                       muffled <- FALSE
[13:21:39.547]                       if (inherits(cond, "message")) {
[13:21:39.547]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:39.547]                         if (muffled) 
[13:21:39.547]                           invokeRestart("muffleMessage")
[13:21:39.547]                       }
[13:21:39.547]                       else if (inherits(cond, "warning")) {
[13:21:39.547]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:39.547]                         if (muffled) 
[13:21:39.547]                           invokeRestart("muffleWarning")
[13:21:39.547]                       }
[13:21:39.547]                       else if (inherits(cond, "condition")) {
[13:21:39.547]                         if (!is.null(pattern)) {
[13:21:39.547]                           computeRestarts <- base::computeRestarts
[13:21:39.547]                           grepl <- base::grepl
[13:21:39.547]                           restarts <- computeRestarts(cond)
[13:21:39.547]                           for (restart in restarts) {
[13:21:39.547]                             name <- restart$name
[13:21:39.547]                             if (is.null(name)) 
[13:21:39.547]                               next
[13:21:39.547]                             if (!grepl(pattern, name)) 
[13:21:39.547]                               next
[13:21:39.547]                             invokeRestart(restart)
[13:21:39.547]                             muffled <- TRUE
[13:21:39.547]                             break
[13:21:39.547]                           }
[13:21:39.547]                         }
[13:21:39.547]                       }
[13:21:39.547]                       invisible(muffled)
[13:21:39.547]                     }
[13:21:39.547]                     muffleCondition(cond, pattern = "^muffle")
[13:21:39.547]                   }
[13:21:39.547]                 }
[13:21:39.547]             }
[13:21:39.547]         }))
[13:21:39.547]     }, error = function(ex) {
[13:21:39.547]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:39.547]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:39.547]                 ...future.rng), started = ...future.startTime, 
[13:21:39.547]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:39.547]             version = "1.8"), class = "FutureResult")
[13:21:39.547]     }, finally = {
[13:21:39.547]         if (!identical(...future.workdir, getwd())) 
[13:21:39.547]             setwd(...future.workdir)
[13:21:39.547]         {
[13:21:39.547]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:39.547]                 ...future.oldOptions$nwarnings <- NULL
[13:21:39.547]             }
[13:21:39.547]             base::options(...future.oldOptions)
[13:21:39.547]             if (.Platform$OS.type == "windows") {
[13:21:39.547]                 old_names <- names(...future.oldEnvVars)
[13:21:39.547]                 envs <- base::Sys.getenv()
[13:21:39.547]                 names <- names(envs)
[13:21:39.547]                 common <- intersect(names, old_names)
[13:21:39.547]                 added <- setdiff(names, old_names)
[13:21:39.547]                 removed <- setdiff(old_names, names)
[13:21:39.547]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:39.547]                   envs[common]]
[13:21:39.547]                 NAMES <- toupper(changed)
[13:21:39.547]                 args <- list()
[13:21:39.547]                 for (kk in seq_along(NAMES)) {
[13:21:39.547]                   name <- changed[[kk]]
[13:21:39.547]                   NAME <- NAMES[[kk]]
[13:21:39.547]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.547]                     next
[13:21:39.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:39.547]                 }
[13:21:39.547]                 NAMES <- toupper(added)
[13:21:39.547]                 for (kk in seq_along(NAMES)) {
[13:21:39.547]                   name <- added[[kk]]
[13:21:39.547]                   NAME <- NAMES[[kk]]
[13:21:39.547]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.547]                     next
[13:21:39.547]                   args[[name]] <- ""
[13:21:39.547]                 }
[13:21:39.547]                 NAMES <- toupper(removed)
[13:21:39.547]                 for (kk in seq_along(NAMES)) {
[13:21:39.547]                   name <- removed[[kk]]
[13:21:39.547]                   NAME <- NAMES[[kk]]
[13:21:39.547]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:39.547]                     next
[13:21:39.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:39.547]                 }
[13:21:39.547]                 if (length(args) > 0) 
[13:21:39.547]                   base::do.call(base::Sys.setenv, args = args)
[13:21:39.547]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:39.547]             }
[13:21:39.547]             else {
[13:21:39.547]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:39.547]             }
[13:21:39.547]             {
[13:21:39.547]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:39.547]                   0L) {
[13:21:39.547]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:39.547]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:39.547]                   base::options(opts)
[13:21:39.547]                 }
[13:21:39.547]                 {
[13:21:39.547]                   {
[13:21:39.547]                     NULL
[13:21:39.547]                     RNGkind("Mersenne-Twister")
[13:21:39.547]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:39.547]                       inherits = FALSE)
[13:21:39.547]                   }
[13:21:39.547]                   options(future.plan = NULL)
[13:21:39.547]                   if (is.na(NA_character_)) 
[13:21:39.547]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:39.547]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:39.547]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:39.547]                   {
[13:21:39.547]                     future <- SequentialFuture(..., envir = envir)
[13:21:39.547]                     if (!future$lazy) 
[13:21:39.547]                       future <- run(future)
[13:21:39.547]                     invisible(future)
[13:21:39.547]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:39.547]                 }
[13:21:39.547]             }
[13:21:39.547]         }
[13:21:39.547]     })
[13:21:39.547]     if (TRUE) {
[13:21:39.547]         base::sink(type = "output", split = FALSE)
[13:21:39.547]         if (TRUE) {
[13:21:39.547]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:39.547]         }
[13:21:39.547]         else {
[13:21:39.547]             ...future.result["stdout"] <- base::list(NULL)
[13:21:39.547]         }
[13:21:39.547]         base::close(...future.stdout)
[13:21:39.547]         ...future.stdout <- NULL
[13:21:39.547]     }
[13:21:39.547]     ...future.result$conditions <- ...future.conditions
[13:21:39.547]     ...future.result$finished <- base::Sys.time()
[13:21:39.547]     ...future.result
[13:21:39.547] }
[13:21:39.549] plan(): Setting new future strategy stack:
[13:21:39.549] List of future strategies:
[13:21:39.549] 1. sequential:
[13:21:39.549]    - args: function (..., envir = parent.frame())
[13:21:39.549]    - tweaked: FALSE
[13:21:39.549]    - call: NULL
[13:21:39.549] plan(): nbrOfWorkers() = 1
[13:21:40.051] plan(): Setting new future strategy stack:
[13:21:40.051] List of future strategies:
[13:21:40.051] 1. sequential:
[13:21:40.051]    - args: function (..., envir = parent.frame())
[13:21:40.051]    - tweaked: FALSE
[13:21:40.051]    - call: plan(strategy)
[13:21:40.051] plan(): nbrOfWorkers() = 1
[13:21:40.052] SequentialFuture started (and completed)
[13:21:40.052] - Launch lazy future ... done
[13:21:40.052] run() for ‘SequentialFuture’ ... done
[13:21:40.052] getGlobalsAndPackages() ...
[13:21:40.052] Searching for globals...
[13:21:40.053] - globals found: [1] ‘{’
[13:21:40.053] Searching for globals ... DONE
[13:21:40.053] Resolving globals: FALSE
[13:21:40.054] 
[13:21:40.054] 
[13:21:40.054] getGlobalsAndPackages() ... DONE
[13:21:40.054] run() for ‘Future’ ...
[13:21:40.054] - state: ‘created’
[13:21:40.054] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:21:40.055] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:21:40.055] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:21:40.055]   - Field: ‘label’
[13:21:40.055]   - Field: ‘local’
[13:21:40.055]   - Field: ‘owner’
[13:21:40.057]   - Field: ‘envir’
[13:21:40.057]   - Field: ‘packages’
[13:21:40.057]   - Field: ‘gc’
[13:21:40.057]   - Field: ‘conditions’
[13:21:40.057]   - Field: ‘expr’
[13:21:40.057]   - Field: ‘uuid’
[13:21:40.058]   - Field: ‘seed’
[13:21:40.058]   - Field: ‘version’
[13:21:40.058]   - Field: ‘result’
[13:21:40.058]   - Field: ‘asynchronous’
[13:21:40.058]   - Field: ‘calls’
[13:21:40.058]   - Field: ‘globals’
[13:21:40.058]   - Field: ‘stdout’
[13:21:40.058]   - Field: ‘earlySignal’
[13:21:40.058]   - Field: ‘lazy’
[13:21:40.058]   - Field: ‘state’
[13:21:40.059] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:21:40.059] - Launch lazy future ...
[13:21:40.059] Packages needed by the future expression (n = 0): <none>
[13:21:40.059] Packages needed by future strategies (n = 0): <none>
[13:21:40.059] {
[13:21:40.059]     {
[13:21:40.059]         {
[13:21:40.059]             ...future.startTime <- base::Sys.time()
[13:21:40.059]             {
[13:21:40.059]                 {
[13:21:40.059]                   {
[13:21:40.059]                     base::local({
[13:21:40.059]                       has_future <- base::requireNamespace("future", 
[13:21:40.059]                         quietly = TRUE)
[13:21:40.059]                       if (has_future) {
[13:21:40.059]                         ns <- base::getNamespace("future")
[13:21:40.059]                         version <- ns[[".package"]][["version"]]
[13:21:40.059]                         if (is.null(version)) 
[13:21:40.059]                           version <- utils::packageVersion("future")
[13:21:40.059]                       }
[13:21:40.059]                       else {
[13:21:40.059]                         version <- NULL
[13:21:40.059]                       }
[13:21:40.059]                       if (!has_future || version < "1.8.0") {
[13:21:40.059]                         info <- base::c(r_version = base::gsub("R version ", 
[13:21:40.059]                           "", base::R.version$version.string), 
[13:21:40.059]                           platform = base::sprintf("%s (%s-bit)", 
[13:21:40.059]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:40.059]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:40.059]                             "release", "version")], collapse = " "), 
[13:21:40.059]                           hostname = base::Sys.info()[["nodename"]])
[13:21:40.059]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:21:40.059]                           info)
[13:21:40.059]                         info <- base::paste(info, collapse = "; ")
[13:21:40.059]                         if (!has_future) {
[13:21:40.059]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:40.059]                             info)
[13:21:40.059]                         }
[13:21:40.059]                         else {
[13:21:40.059]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:40.059]                             info, version)
[13:21:40.059]                         }
[13:21:40.059]                         base::stop(msg)
[13:21:40.059]                       }
[13:21:40.059]                     })
[13:21:40.059]                   }
[13:21:40.059]                   options(future.plan = NULL)
[13:21:40.059]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:40.059]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:40.059]                 }
[13:21:40.059]                 ...future.workdir <- getwd()
[13:21:40.059]             }
[13:21:40.059]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:40.059]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:40.059]         }
[13:21:40.059]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:40.059]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:40.059]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:40.059]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:40.059]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:40.059]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:40.059]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:40.059]             base::names(...future.oldOptions))
[13:21:40.059]     }
[13:21:40.059]     if (FALSE) {
[13:21:40.059]     }
[13:21:40.059]     else {
[13:21:40.059]         if (TRUE) {
[13:21:40.059]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:40.059]                 open = "w")
[13:21:40.059]         }
[13:21:40.059]         else {
[13:21:40.059]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:40.059]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:40.059]         }
[13:21:40.059]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:40.059]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:40.059]             base::sink(type = "output", split = FALSE)
[13:21:40.059]             base::close(...future.stdout)
[13:21:40.059]         }, add = TRUE)
[13:21:40.059]     }
[13:21:40.059]     ...future.frame <- base::sys.nframe()
[13:21:40.059]     ...future.conditions <- base::list()
[13:21:40.059]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:40.059]     if (FALSE) {
[13:21:40.059]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:40.059]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:40.059]     }
[13:21:40.059]     ...future.result <- base::tryCatch({
[13:21:40.059]         base::withCallingHandlers({
[13:21:40.059]             ...future.value <- base::withVisible(base::local({
[13:21:40.059]                 3
[13:21:40.059]             }))
[13:21:40.059]             future::FutureResult(value = ...future.value$value, 
[13:21:40.059]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:40.059]                   ...future.rng), globalenv = if (FALSE) 
[13:21:40.059]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:40.059]                     ...future.globalenv.names))
[13:21:40.059]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:40.059]         }, condition = base::local({
[13:21:40.059]             c <- base::c
[13:21:40.059]             inherits <- base::inherits
[13:21:40.059]             invokeRestart <- base::invokeRestart
[13:21:40.059]             length <- base::length
[13:21:40.059]             list <- base::list
[13:21:40.059]             seq.int <- base::seq.int
[13:21:40.059]             signalCondition <- base::signalCondition
[13:21:40.059]             sys.calls <- base::sys.calls
[13:21:40.059]             `[[` <- base::`[[`
[13:21:40.059]             `+` <- base::`+`
[13:21:40.059]             `<<-` <- base::`<<-`
[13:21:40.059]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:40.059]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:40.059]                   3L)]
[13:21:40.059]             }
[13:21:40.059]             function(cond) {
[13:21:40.059]                 is_error <- inherits(cond, "error")
[13:21:40.059]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:40.059]                   NULL)
[13:21:40.059]                 if (is_error) {
[13:21:40.059]                   sessionInformation <- function() {
[13:21:40.059]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:40.059]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:40.059]                       search = base::search(), system = base::Sys.info())
[13:21:40.059]                   }
[13:21:40.059]                   ...future.conditions[[length(...future.conditions) + 
[13:21:40.059]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:40.059]                     cond$call), session = sessionInformation(), 
[13:21:40.059]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:40.059]                   signalCondition(cond)
[13:21:40.059]                 }
[13:21:40.059]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:40.059]                 "immediateCondition"))) {
[13:21:40.059]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:40.059]                   ...future.conditions[[length(...future.conditions) + 
[13:21:40.059]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:40.059]                   if (TRUE && !signal) {
[13:21:40.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.059]                     {
[13:21:40.059]                       inherits <- base::inherits
[13:21:40.059]                       invokeRestart <- base::invokeRestart
[13:21:40.059]                       is.null <- base::is.null
[13:21:40.059]                       muffled <- FALSE
[13:21:40.059]                       if (inherits(cond, "message")) {
[13:21:40.059]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:40.059]                         if (muffled) 
[13:21:40.059]                           invokeRestart("muffleMessage")
[13:21:40.059]                       }
[13:21:40.059]                       else if (inherits(cond, "warning")) {
[13:21:40.059]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:40.059]                         if (muffled) 
[13:21:40.059]                           invokeRestart("muffleWarning")
[13:21:40.059]                       }
[13:21:40.059]                       else if (inherits(cond, "condition")) {
[13:21:40.059]                         if (!is.null(pattern)) {
[13:21:40.059]                           computeRestarts <- base::computeRestarts
[13:21:40.059]                           grepl <- base::grepl
[13:21:40.059]                           restarts <- computeRestarts(cond)
[13:21:40.059]                           for (restart in restarts) {
[13:21:40.059]                             name <- restart$name
[13:21:40.059]                             if (is.null(name)) 
[13:21:40.059]                               next
[13:21:40.059]                             if (!grepl(pattern, name)) 
[13:21:40.059]                               next
[13:21:40.059]                             invokeRestart(restart)
[13:21:40.059]                             muffled <- TRUE
[13:21:40.059]                             break
[13:21:40.059]                           }
[13:21:40.059]                         }
[13:21:40.059]                       }
[13:21:40.059]                       invisible(muffled)
[13:21:40.059]                     }
[13:21:40.059]                     muffleCondition(cond, pattern = "^muffle")
[13:21:40.059]                   }
[13:21:40.059]                 }
[13:21:40.059]                 else {
[13:21:40.059]                   if (TRUE) {
[13:21:40.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.059]                     {
[13:21:40.059]                       inherits <- base::inherits
[13:21:40.059]                       invokeRestart <- base::invokeRestart
[13:21:40.059]                       is.null <- base::is.null
[13:21:40.059]                       muffled <- FALSE
[13:21:40.059]                       if (inherits(cond, "message")) {
[13:21:40.059]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:40.059]                         if (muffled) 
[13:21:40.059]                           invokeRestart("muffleMessage")
[13:21:40.059]                       }
[13:21:40.059]                       else if (inherits(cond, "warning")) {
[13:21:40.059]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:40.059]                         if (muffled) 
[13:21:40.059]                           invokeRestart("muffleWarning")
[13:21:40.059]                       }
[13:21:40.059]                       else if (inherits(cond, "condition")) {
[13:21:40.059]                         if (!is.null(pattern)) {
[13:21:40.059]                           computeRestarts <- base::computeRestarts
[13:21:40.059]                           grepl <- base::grepl
[13:21:40.059]                           restarts <- computeRestarts(cond)
[13:21:40.059]                           for (restart in restarts) {
[13:21:40.059]                             name <- restart$name
[13:21:40.059]                             if (is.null(name)) 
[13:21:40.059]                               next
[13:21:40.059]                             if (!grepl(pattern, name)) 
[13:21:40.059]                               next
[13:21:40.059]                             invokeRestart(restart)
[13:21:40.059]                             muffled <- TRUE
[13:21:40.059]                             break
[13:21:40.059]                           }
[13:21:40.059]                         }
[13:21:40.059]                       }
[13:21:40.059]                       invisible(muffled)
[13:21:40.059]                     }
[13:21:40.059]                     muffleCondition(cond, pattern = "^muffle")
[13:21:40.059]                   }
[13:21:40.059]                 }
[13:21:40.059]             }
[13:21:40.059]         }))
[13:21:40.059]     }, error = function(ex) {
[13:21:40.059]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:40.059]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:40.059]                 ...future.rng), started = ...future.startTime, 
[13:21:40.059]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:40.059]             version = "1.8"), class = "FutureResult")
[13:21:40.059]     }, finally = {
[13:21:40.059]         if (!identical(...future.workdir, getwd())) 
[13:21:40.059]             setwd(...future.workdir)
[13:21:40.059]         {
[13:21:40.059]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:40.059]                 ...future.oldOptions$nwarnings <- NULL
[13:21:40.059]             }
[13:21:40.059]             base::options(...future.oldOptions)
[13:21:40.059]             if (.Platform$OS.type == "windows") {
[13:21:40.059]                 old_names <- names(...future.oldEnvVars)
[13:21:40.059]                 envs <- base::Sys.getenv()
[13:21:40.059]                 names <- names(envs)
[13:21:40.059]                 common <- intersect(names, old_names)
[13:21:40.059]                 added <- setdiff(names, old_names)
[13:21:40.059]                 removed <- setdiff(old_names, names)
[13:21:40.059]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:40.059]                   envs[common]]
[13:21:40.059]                 NAMES <- toupper(changed)
[13:21:40.059]                 args <- list()
[13:21:40.059]                 for (kk in seq_along(NAMES)) {
[13:21:40.059]                   name <- changed[[kk]]
[13:21:40.059]                   NAME <- NAMES[[kk]]
[13:21:40.059]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.059]                     next
[13:21:40.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:40.059]                 }
[13:21:40.059]                 NAMES <- toupper(added)
[13:21:40.059]                 for (kk in seq_along(NAMES)) {
[13:21:40.059]                   name <- added[[kk]]
[13:21:40.059]                   NAME <- NAMES[[kk]]
[13:21:40.059]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.059]                     next
[13:21:40.059]                   args[[name]] <- ""
[13:21:40.059]                 }
[13:21:40.059]                 NAMES <- toupper(removed)
[13:21:40.059]                 for (kk in seq_along(NAMES)) {
[13:21:40.059]                   name <- removed[[kk]]
[13:21:40.059]                   NAME <- NAMES[[kk]]
[13:21:40.059]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.059]                     next
[13:21:40.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:40.059]                 }
[13:21:40.059]                 if (length(args) > 0) 
[13:21:40.059]                   base::do.call(base::Sys.setenv, args = args)
[13:21:40.059]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:40.059]             }
[13:21:40.059]             else {
[13:21:40.059]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:40.059]             }
[13:21:40.059]             {
[13:21:40.059]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:40.059]                   0L) {
[13:21:40.059]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:40.059]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:40.059]                   base::options(opts)
[13:21:40.059]                 }
[13:21:40.059]                 {
[13:21:40.059]                   {
[13:21:40.059]                     NULL
[13:21:40.059]                     RNGkind("Mersenne-Twister")
[13:21:40.059]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:21:40.059]                       inherits = FALSE)
[13:21:40.059]                   }
[13:21:40.059]                   options(future.plan = NULL)
[13:21:40.059]                   if (is.na(NA_character_)) 
[13:21:40.059]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:40.059]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:40.059]                   future::plan(list(function (..., envir = parent.frame()) 
[13:21:40.059]                   {
[13:21:40.059]                     future <- SequentialFuture(..., envir = envir)
[13:21:40.059]                     if (!future$lazy) 
[13:21:40.059]                       future <- run(future)
[13:21:40.059]                     invisible(future)
[13:21:40.059]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:40.059]                 }
[13:21:40.059]             }
[13:21:40.059]         }
[13:21:40.059]     })
[13:21:40.059]     if (TRUE) {
[13:21:40.059]         base::sink(type = "output", split = FALSE)
[13:21:40.059]         if (TRUE) {
[13:21:40.059]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:40.059]         }
[13:21:40.059]         else {
[13:21:40.059]             ...future.result["stdout"] <- base::list(NULL)
[13:21:40.059]         }
[13:21:40.059]         base::close(...future.stdout)
[13:21:40.059]         ...future.stdout <- NULL
[13:21:40.059]     }
[13:21:40.059]     ...future.result$conditions <- ...future.conditions
[13:21:40.059]     ...future.result$finished <- base::Sys.time()
[13:21:40.059]     ...future.result
[13:21:40.059] }
[13:21:40.061] plan(): Setting new future strategy stack:
[13:21:40.061] List of future strategies:
[13:21:40.061] 1. sequential:
[13:21:40.061]    - args: function (..., envir = parent.frame())
[13:21:40.061]    - tweaked: FALSE
[13:21:40.061]    - call: NULL
[13:21:40.062] plan(): nbrOfWorkers() = 1
[13:21:40.063] plan(): Setting new future strategy stack:
[13:21:40.063] List of future strategies:
[13:21:40.063] 1. sequential:
[13:21:40.063]    - args: function (..., envir = parent.frame())
[13:21:40.063]    - tweaked: FALSE
[13:21:40.063]    - call: plan(strategy)
[13:21:40.063] plan(): nbrOfWorkers() = 1
[13:21:40.063] SequentialFuture started (and completed)
[13:21:40.063] - Launch lazy future ... done
[13:21:40.063] run() for ‘SequentialFuture’ ... done
[13:21:40.064] resolve() on list environment ...
[13:21:40.064]  recursive: 0
[13:21:40.065]  length: 4
[13:21:40.065]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:21:40.065] resolved() for ‘SequentialFuture’ ...
[13:21:40.065] - state: ‘finished’
[13:21:40.065] - run: TRUE
[13:21:40.065] - result: ‘FutureResult’
[13:21:40.066] resolved() for ‘SequentialFuture’ ... done
[13:21:40.066] Future #1
[13:21:40.066]  length: 3 (resolved future 1)
[13:21:40.066] resolved() for ‘SequentialFuture’ ...
[13:21:40.066] - state: ‘finished’
[13:21:40.066] - run: TRUE
[13:21:40.066] - result: ‘FutureResult’
[13:21:40.066] resolved() for ‘SequentialFuture’ ... done
[13:21:40.066] Future #2
[13:21:40.066]  length: 2 (resolved future 2)
[13:21:40.067] resolved() for ‘SequentialFuture’ ...
[13:21:40.067] - state: ‘finished’
[13:21:40.067] - run: TRUE
[13:21:40.067] - result: ‘FutureResult’
[13:21:40.067] resolved() for ‘SequentialFuture’ ... done
[13:21:40.067] Future #3
[13:21:40.067]  length: 1 (resolved future 3)
[13:21:40.067]  length: 0 (resolved future 4)
[13:21:40.067] resolve() on list environment ... DONE
[13:21:40.068] resolved() for ‘SequentialFuture’ ...
[13:21:40.068] - state: ‘finished’
[13:21:40.068] - run: TRUE
[13:21:40.068] - result: ‘FutureResult’
[13:21:40.068] resolved() for ‘SequentialFuture’ ... done
[13:21:40.068] resolve() on list environment ...
[13:21:40.068]  recursive: 0
[13:21:40.069]  length: 4
[13:21:40.069]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:21:40.069] resolved() for ‘SequentialFuture’ ...
[13:21:40.069] - state: ‘finished’
[13:21:40.069] - run: TRUE
[13:21:40.069] - result: ‘FutureResult’
[13:21:40.069] resolved() for ‘SequentialFuture’ ... done
[13:21:40.070] Future #1
[13:21:40.070]  length: 3 (resolved future 1)
[13:21:40.070] resolved() for ‘SequentialFuture’ ...
[13:21:40.070] - state: ‘finished’
[13:21:40.070] - run: TRUE
[13:21:40.070] - result: ‘FutureResult’
[13:21:40.070] resolved() for ‘SequentialFuture’ ... done
[13:21:40.070] Future #2
[13:21:40.070]  length: 2 (resolved future 2)
[13:21:40.070] resolved() for ‘SequentialFuture’ ...
[13:21:40.071] - state: ‘finished’
[13:21:40.071] - run: TRUE
[13:21:40.071] - result: ‘FutureResult’
[13:21:40.071] resolved() for ‘SequentialFuture’ ... done
[13:21:40.071] Future #3
[13:21:40.071]  length: 1 (resolved future 3)
[13:21:40.071]  length: 0 (resolved future 4)
[13:21:40.071] resolve() on list environment ... DONE
[13:21:40.072] resolve() on list environment ...
[13:21:40.072]  recursive: 0
[13:21:40.072]  length: 4
[13:21:40.073]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:21:40.073] resolved() for ‘SequentialFuture’ ...
[13:21:40.073] - state: ‘finished’
[13:21:40.073] - run: TRUE
[13:21:40.073] - result: ‘FutureResult’
[13:21:40.073] resolved() for ‘SequentialFuture’ ... done
[13:21:40.073] Future #1
[13:21:40.073]  length: 3 (resolved future 1)
[13:21:40.073] resolved() for ‘SequentialFuture’ ...
[13:21:40.073] - state: ‘finished’
[13:21:40.074] - run: TRUE
[13:21:40.074] - result: ‘FutureResult’
[13:21:40.074] resolved() for ‘SequentialFuture’ ... done
[13:21:40.074] Future #2
[13:21:40.074]  length: 2 (resolved future 2)
[13:21:40.074] resolved() for ‘SequentialFuture’ ...
[13:21:40.074] - state: ‘finished’
[13:21:40.074] - run: TRUE
[13:21:40.074] - result: ‘FutureResult’
[13:21:40.074] resolved() for ‘SequentialFuture’ ... done
[13:21:40.075] Future #3
[13:21:40.075]  length: 1 (resolved future 3)
[13:21:40.075]  length: 0 (resolved future 4)
[13:21:40.075] resolve() on list environment ... DONE
[13:21:40.075] resolve() on list environment ...
[13:21:40.075]  recursive: 0
[13:21:40.076]  length: 4
[13:21:40.076]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:21:40.076] resolved() for ‘SequentialFuture’ ...
[13:21:40.076] - state: ‘finished’
[13:21:40.076] - run: TRUE
[13:21:40.076] - result: ‘FutureResult’
[13:21:40.077] resolved() for ‘SequentialFuture’ ... done
[13:21:40.077] Future #1
[13:21:40.077]  length: 3 (resolved future 1)
[13:21:40.077] resolved() for ‘SequentialFuture’ ...
[13:21:40.077] - state: ‘finished’
[13:21:40.077] - run: TRUE
[13:21:40.077] - result: ‘FutureResult’
[13:21:40.077] resolved() for ‘SequentialFuture’ ... done
[13:21:40.077] Future #2
[13:21:40.077]  length: 2 (resolved future 2)
[13:21:40.078] resolved() for ‘SequentialFuture’ ...
[13:21:40.078] - state: ‘finished’
[13:21:40.078] - run: TRUE
[13:21:40.078] - result: ‘FutureResult’
[13:21:40.078] resolved() for ‘SequentialFuture’ ... done
[13:21:40.078] Future #3
[13:21:40.078]  length: 1 (resolved future 3)
[13:21:40.078]  length: 0 (resolved future 4)
[13:21:40.078] resolve() on list environment ... DONE
[13:21:40.108] resolve() on list environment ...
[13:21:40.108]  recursive: 0
[13:21:40.109]  length: 4
[13:21:40.109]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:21:40.109] resolved() for ‘SequentialFuture’ ...
[13:21:40.109] - state: ‘finished’
[13:21:40.109] - run: TRUE
[13:21:40.109] - result: ‘FutureResult’
[13:21:40.109] resolved() for ‘SequentialFuture’ ... done
[13:21:40.110] Future #1
[13:21:40.110]  length: 3 (resolved future 1)
[13:21:40.110] resolved() for ‘SequentialFuture’ ...
[13:21:40.110] - state: ‘finished’
[13:21:40.110] - run: TRUE
[13:21:40.110] - result: ‘FutureResult’
[13:21:40.110] resolved() for ‘SequentialFuture’ ... done
[13:21:40.110] Future #2
[13:21:40.110]  length: 2 (resolved future 2)
[13:21:40.111] resolved() for ‘SequentialFuture’ ...
[13:21:40.111] - state: ‘finished’
[13:21:40.111] - run: TRUE
[13:21:40.111] - result: ‘FutureResult’
[13:21:40.111] resolved() for ‘SequentialFuture’ ... done
[13:21:40.111] Future #3
[13:21:40.111]  length: 1 (resolved future 3)
[13:21:40.111]  length: 0 (resolved future 4)
[13:21:40.111] resolve() on list environment ... DONE
[13:21:40.112] resolve() on list environment ...
[13:21:40.112]  recursive: 99
[13:21:40.113]  length: 4
[13:21:40.113]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:21:40.113] resolved() for ‘SequentialFuture’ ...
[13:21:40.113] - state: ‘finished’
[13:21:40.113] - run: TRUE
[13:21:40.113] - result: ‘FutureResult’
[13:21:40.113] resolved() for ‘SequentialFuture’ ... done
[13:21:40.113] Future #1
[13:21:40.114] resolved() for ‘SequentialFuture’ ...
[13:21:40.114] - state: ‘finished’
[13:21:40.114] - run: TRUE
[13:21:40.114] - result: ‘FutureResult’
[13:21:40.114] resolved() for ‘SequentialFuture’ ... done
[13:21:40.114] A SequentialFuture was resolved
[13:21:40.114]  length: 3 (resolved future 1)
[13:21:40.114] resolved() for ‘SequentialFuture’ ...
[13:21:40.114] - state: ‘finished’
[13:21:40.114] - run: TRUE
[13:21:40.114] - result: ‘FutureResult’
[13:21:40.115] resolved() for ‘SequentialFuture’ ... done
[13:21:40.115] Future #2
[13:21:40.115] resolved() for ‘SequentialFuture’ ...
[13:21:40.115] - state: ‘finished’
[13:21:40.115] - run: TRUE
[13:21:40.115] - result: ‘FutureResult’
[13:21:40.115] resolved() for ‘SequentialFuture’ ... done
[13:21:40.115] A SequentialFuture was resolved
[13:21:40.115]  length: 2 (resolved future 2)
[13:21:40.115] resolved() for ‘SequentialFuture’ ...
[13:21:40.116] - state: ‘finished’
[13:21:40.116] - run: TRUE
[13:21:40.116] - result: ‘FutureResult’
[13:21:40.116] resolved() for ‘SequentialFuture’ ... done
[13:21:40.116] Future #3
[13:21:40.116] resolved() for ‘SequentialFuture’ ...
[13:21:40.116] - state: ‘finished’
[13:21:40.116] - run: TRUE
[13:21:40.116] - result: ‘FutureResult’
[13:21:40.116] resolved() for ‘SequentialFuture’ ... done
[13:21:40.117] A SequentialFuture was resolved
[13:21:40.117]  length: 1 (resolved future 3)
[13:21:40.117]  length: 0 (resolved future 4)
[13:21:40.117] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('sequential') ...
- plan('multicore') ...
[13:21:40.118] plan(): Setting new future strategy stack:
[13:21:40.118] List of future strategies:
[13:21:40.118] 1. multicore:
[13:21:40.118]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:40.118]    - tweaked: FALSE
[13:21:40.118]    - call: plan(strategy)
[13:21:40.122] plan(): nbrOfWorkers() = 2
*** resolve() for lists ...
[13:21:40.122] resolve() on list ...
[13:21:40.122]  recursive: 0
[13:21:40.122]  length: 2
[13:21:40.122]  elements: ‘a’, ‘b’
[13:21:40.122]  length: 1 (resolved future 1)
[13:21:40.122]  length: 0 (resolved future 2)
[13:21:40.123] resolve() on list ... DONE
[13:21:40.123] getGlobalsAndPackages() ...
[13:21:40.123] Searching for globals...
[13:21:40.123] 
[13:21:40.123] Searching for globals ... DONE
[13:21:40.123] - globals: [0] <none>
[13:21:40.123] getGlobalsAndPackages() ... DONE
[13:21:40.124] run() for ‘Future’ ...
[13:21:40.124] - state: ‘created’
[13:21:40.124] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:40.127] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:40.127] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:40.128]   - Field: ‘label’
[13:21:40.128]   - Field: ‘local’
[13:21:40.128]   - Field: ‘owner’
[13:21:40.128]   - Field: ‘envir’
[13:21:40.128]   - Field: ‘workers’
[13:21:40.128]   - Field: ‘packages’
[13:21:40.128]   - Field: ‘gc’
[13:21:40.128]   - Field: ‘job’
[13:21:40.128]   - Field: ‘conditions’
[13:21:40.129]   - Field: ‘expr’
[13:21:40.129]   - Field: ‘uuid’
[13:21:40.129]   - Field: ‘seed’
[13:21:40.129]   - Field: ‘version’
[13:21:40.129]   - Field: ‘result’
[13:21:40.129]   - Field: ‘asynchronous’
[13:21:40.129]   - Field: ‘calls’
[13:21:40.129]   - Field: ‘globals’
[13:21:40.129]   - Field: ‘stdout’
[13:21:40.129]   - Field: ‘earlySignal’
[13:21:40.130]   - Field: ‘lazy’
[13:21:40.130]   - Field: ‘state’
[13:21:40.130] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:40.130] - Launch lazy future ...
[13:21:40.131] Packages needed by the future expression (n = 0): <none>
[13:21:40.131] Packages needed by future strategies (n = 0): <none>
[13:21:40.131] {
[13:21:40.131]     {
[13:21:40.131]         {
[13:21:40.131]             ...future.startTime <- base::Sys.time()
[13:21:40.131]             {
[13:21:40.131]                 {
[13:21:40.131]                   {
[13:21:40.131]                     {
[13:21:40.131]                       base::local({
[13:21:40.131]                         has_future <- base::requireNamespace("future", 
[13:21:40.131]                           quietly = TRUE)
[13:21:40.131]                         if (has_future) {
[13:21:40.131]                           ns <- base::getNamespace("future")
[13:21:40.131]                           version <- ns[[".package"]][["version"]]
[13:21:40.131]                           if (is.null(version)) 
[13:21:40.131]                             version <- utils::packageVersion("future")
[13:21:40.131]                         }
[13:21:40.131]                         else {
[13:21:40.131]                           version <- NULL
[13:21:40.131]                         }
[13:21:40.131]                         if (!has_future || version < "1.8.0") {
[13:21:40.131]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:40.131]                             "", base::R.version$version.string), 
[13:21:40.131]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:40.131]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:40.131]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:40.131]                               "release", "version")], collapse = " "), 
[13:21:40.131]                             hostname = base::Sys.info()[["nodename"]])
[13:21:40.131]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:40.131]                             info)
[13:21:40.131]                           info <- base::paste(info, collapse = "; ")
[13:21:40.131]                           if (!has_future) {
[13:21:40.131]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:40.131]                               info)
[13:21:40.131]                           }
[13:21:40.131]                           else {
[13:21:40.131]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:40.131]                               info, version)
[13:21:40.131]                           }
[13:21:40.131]                           base::stop(msg)
[13:21:40.131]                         }
[13:21:40.131]                       })
[13:21:40.131]                     }
[13:21:40.131]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:40.131]                     base::options(mc.cores = 1L)
[13:21:40.131]                   }
[13:21:40.131]                   options(future.plan = NULL)
[13:21:40.131]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:40.131]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:40.131]                 }
[13:21:40.131]                 ...future.workdir <- getwd()
[13:21:40.131]             }
[13:21:40.131]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:40.131]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:40.131]         }
[13:21:40.131]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:40.131]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:40.131]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:40.131]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:40.131]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:40.131]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:40.131]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:40.131]             base::names(...future.oldOptions))
[13:21:40.131]     }
[13:21:40.131]     if (FALSE) {
[13:21:40.131]     }
[13:21:40.131]     else {
[13:21:40.131]         if (TRUE) {
[13:21:40.131]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:40.131]                 open = "w")
[13:21:40.131]         }
[13:21:40.131]         else {
[13:21:40.131]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:40.131]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:40.131]         }
[13:21:40.131]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:40.131]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:40.131]             base::sink(type = "output", split = FALSE)
[13:21:40.131]             base::close(...future.stdout)
[13:21:40.131]         }, add = TRUE)
[13:21:40.131]     }
[13:21:40.131]     ...future.frame <- base::sys.nframe()
[13:21:40.131]     ...future.conditions <- base::list()
[13:21:40.131]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:40.131]     if (FALSE) {
[13:21:40.131]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:40.131]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:40.131]     }
[13:21:40.131]     ...future.result <- base::tryCatch({
[13:21:40.131]         base::withCallingHandlers({
[13:21:40.131]             ...future.value <- base::withVisible(base::local({
[13:21:40.131]                 withCallingHandlers({
[13:21:40.131]                   1
[13:21:40.131]                 }, immediateCondition = function(cond) {
[13:21:40.131]                   save_rds <- function (object, pathname, ...) 
[13:21:40.131]                   {
[13:21:40.131]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:40.131]                     if (file_test("-f", pathname_tmp)) {
[13:21:40.131]                       fi_tmp <- file.info(pathname_tmp)
[13:21:40.131]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:40.131]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:40.131]                         fi_tmp[["mtime"]])
[13:21:40.131]                     }
[13:21:40.131]                     tryCatch({
[13:21:40.131]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:40.131]                     }, error = function(ex) {
[13:21:40.131]                       msg <- conditionMessage(ex)
[13:21:40.131]                       fi_tmp <- file.info(pathname_tmp)
[13:21:40.131]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:40.131]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:40.131]                         fi_tmp[["mtime"]], msg)
[13:21:40.131]                       ex$message <- msg
[13:21:40.131]                       stop(ex)
[13:21:40.131]                     })
[13:21:40.131]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:40.131]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:40.131]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:40.131]                       fi_tmp <- file.info(pathname_tmp)
[13:21:40.131]                       fi <- file.info(pathname)
[13:21:40.131]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:40.131]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:40.131]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:40.131]                         fi[["size"]], fi[["mtime"]])
[13:21:40.131]                       stop(msg)
[13:21:40.131]                     }
[13:21:40.131]                     invisible(pathname)
[13:21:40.131]                   }
[13:21:40.131]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:40.131]                     rootPath = tempdir()) 
[13:21:40.131]                   {
[13:21:40.131]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:40.131]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:40.131]                       tmpdir = path, fileext = ".rds")
[13:21:40.131]                     save_rds(obj, file)
[13:21:40.131]                   }
[13:21:40.131]                   saveImmediateCondition(cond, path = "/tmp/RtmpRIPAyw/.future/immediateConditions")
[13:21:40.131]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.131]                   {
[13:21:40.131]                     inherits <- base::inherits
[13:21:40.131]                     invokeRestart <- base::invokeRestart
[13:21:40.131]                     is.null <- base::is.null
[13:21:40.131]                     muffled <- FALSE
[13:21:40.131]                     if (inherits(cond, "message")) {
[13:21:40.131]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:40.131]                       if (muffled) 
[13:21:40.131]                         invokeRestart("muffleMessage")
[13:21:40.131]                     }
[13:21:40.131]                     else if (inherits(cond, "warning")) {
[13:21:40.131]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:40.131]                       if (muffled) 
[13:21:40.131]                         invokeRestart("muffleWarning")
[13:21:40.131]                     }
[13:21:40.131]                     else if (inherits(cond, "condition")) {
[13:21:40.131]                       if (!is.null(pattern)) {
[13:21:40.131]                         computeRestarts <- base::computeRestarts
[13:21:40.131]                         grepl <- base::grepl
[13:21:40.131]                         restarts <- computeRestarts(cond)
[13:21:40.131]                         for (restart in restarts) {
[13:21:40.131]                           name <- restart$name
[13:21:40.131]                           if (is.null(name)) 
[13:21:40.131]                             next
[13:21:40.131]                           if (!grepl(pattern, name)) 
[13:21:40.131]                             next
[13:21:40.131]                           invokeRestart(restart)
[13:21:40.131]                           muffled <- TRUE
[13:21:40.131]                           break
[13:21:40.131]                         }
[13:21:40.131]                       }
[13:21:40.131]                     }
[13:21:40.131]                     invisible(muffled)
[13:21:40.131]                   }
[13:21:40.131]                   muffleCondition(cond)
[13:21:40.131]                 })
[13:21:40.131]             }))
[13:21:40.131]             future::FutureResult(value = ...future.value$value, 
[13:21:40.131]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:40.131]                   ...future.rng), globalenv = if (FALSE) 
[13:21:40.131]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:40.131]                     ...future.globalenv.names))
[13:21:40.131]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:40.131]         }, condition = base::local({
[13:21:40.131]             c <- base::c
[13:21:40.131]             inherits <- base::inherits
[13:21:40.131]             invokeRestart <- base::invokeRestart
[13:21:40.131]             length <- base::length
[13:21:40.131]             list <- base::list
[13:21:40.131]             seq.int <- base::seq.int
[13:21:40.131]             signalCondition <- base::signalCondition
[13:21:40.131]             sys.calls <- base::sys.calls
[13:21:40.131]             `[[` <- base::`[[`
[13:21:40.131]             `+` <- base::`+`
[13:21:40.131]             `<<-` <- base::`<<-`
[13:21:40.131]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:40.131]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:40.131]                   3L)]
[13:21:40.131]             }
[13:21:40.131]             function(cond) {
[13:21:40.131]                 is_error <- inherits(cond, "error")
[13:21:40.131]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:40.131]                   NULL)
[13:21:40.131]                 if (is_error) {
[13:21:40.131]                   sessionInformation <- function() {
[13:21:40.131]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:40.131]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:40.131]                       search = base::search(), system = base::Sys.info())
[13:21:40.131]                   }
[13:21:40.131]                   ...future.conditions[[length(...future.conditions) + 
[13:21:40.131]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:40.131]                     cond$call), session = sessionInformation(), 
[13:21:40.131]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:40.131]                   signalCondition(cond)
[13:21:40.131]                 }
[13:21:40.131]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:40.131]                 "immediateCondition"))) {
[13:21:40.131]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:40.131]                   ...future.conditions[[length(...future.conditions) + 
[13:21:40.131]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:40.131]                   if (TRUE && !signal) {
[13:21:40.131]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.131]                     {
[13:21:40.131]                       inherits <- base::inherits
[13:21:40.131]                       invokeRestart <- base::invokeRestart
[13:21:40.131]                       is.null <- base::is.null
[13:21:40.131]                       muffled <- FALSE
[13:21:40.131]                       if (inherits(cond, "message")) {
[13:21:40.131]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:40.131]                         if (muffled) 
[13:21:40.131]                           invokeRestart("muffleMessage")
[13:21:40.131]                       }
[13:21:40.131]                       else if (inherits(cond, "warning")) {
[13:21:40.131]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:40.131]                         if (muffled) 
[13:21:40.131]                           invokeRestart("muffleWarning")
[13:21:40.131]                       }
[13:21:40.131]                       else if (inherits(cond, "condition")) {
[13:21:40.131]                         if (!is.null(pattern)) {
[13:21:40.131]                           computeRestarts <- base::computeRestarts
[13:21:40.131]                           grepl <- base::grepl
[13:21:40.131]                           restarts <- computeRestarts(cond)
[13:21:40.131]                           for (restart in restarts) {
[13:21:40.131]                             name <- restart$name
[13:21:40.131]                             if (is.null(name)) 
[13:21:40.131]                               next
[13:21:40.131]                             if (!grepl(pattern, name)) 
[13:21:40.131]                               next
[13:21:40.131]                             invokeRestart(restart)
[13:21:40.131]                             muffled <- TRUE
[13:21:40.131]                             break
[13:21:40.131]                           }
[13:21:40.131]                         }
[13:21:40.131]                       }
[13:21:40.131]                       invisible(muffled)
[13:21:40.131]                     }
[13:21:40.131]                     muffleCondition(cond, pattern = "^muffle")
[13:21:40.131]                   }
[13:21:40.131]                 }
[13:21:40.131]                 else {
[13:21:40.131]                   if (TRUE) {
[13:21:40.131]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.131]                     {
[13:21:40.131]                       inherits <- base::inherits
[13:21:40.131]                       invokeRestart <- base::invokeRestart
[13:21:40.131]                       is.null <- base::is.null
[13:21:40.131]                       muffled <- FALSE
[13:21:40.131]                       if (inherits(cond, "message")) {
[13:21:40.131]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:40.131]                         if (muffled) 
[13:21:40.131]                           invokeRestart("muffleMessage")
[13:21:40.131]                       }
[13:21:40.131]                       else if (inherits(cond, "warning")) {
[13:21:40.131]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:40.131]                         if (muffled) 
[13:21:40.131]                           invokeRestart("muffleWarning")
[13:21:40.131]                       }
[13:21:40.131]                       else if (inherits(cond, "condition")) {
[13:21:40.131]                         if (!is.null(pattern)) {
[13:21:40.131]                           computeRestarts <- base::computeRestarts
[13:21:40.131]                           grepl <- base::grepl
[13:21:40.131]                           restarts <- computeRestarts(cond)
[13:21:40.131]                           for (restart in restarts) {
[13:21:40.131]                             name <- restart$name
[13:21:40.131]                             if (is.null(name)) 
[13:21:40.131]                               next
[13:21:40.131]                             if (!grepl(pattern, name)) 
[13:21:40.131]                               next
[13:21:40.131]                             invokeRestart(restart)
[13:21:40.131]                             muffled <- TRUE
[13:21:40.131]                             break
[13:21:40.131]                           }
[13:21:40.131]                         }
[13:21:40.131]                       }
[13:21:40.131]                       invisible(muffled)
[13:21:40.131]                     }
[13:21:40.131]                     muffleCondition(cond, pattern = "^muffle")
[13:21:40.131]                   }
[13:21:40.131]                 }
[13:21:40.131]             }
[13:21:40.131]         }))
[13:21:40.131]     }, error = function(ex) {
[13:21:40.131]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:40.131]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:40.131]                 ...future.rng), started = ...future.startTime, 
[13:21:40.131]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:40.131]             version = "1.8"), class = "FutureResult")
[13:21:40.131]     }, finally = {
[13:21:40.131]         if (!identical(...future.workdir, getwd())) 
[13:21:40.131]             setwd(...future.workdir)
[13:21:40.131]         {
[13:21:40.131]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:40.131]                 ...future.oldOptions$nwarnings <- NULL
[13:21:40.131]             }
[13:21:40.131]             base::options(...future.oldOptions)
[13:21:40.131]             if (.Platform$OS.type == "windows") {
[13:21:40.131]                 old_names <- names(...future.oldEnvVars)
[13:21:40.131]                 envs <- base::Sys.getenv()
[13:21:40.131]                 names <- names(envs)
[13:21:40.131]                 common <- intersect(names, old_names)
[13:21:40.131]                 added <- setdiff(names, old_names)
[13:21:40.131]                 removed <- setdiff(old_names, names)
[13:21:40.131]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:40.131]                   envs[common]]
[13:21:40.131]                 NAMES <- toupper(changed)
[13:21:40.131]                 args <- list()
[13:21:40.131]                 for (kk in seq_along(NAMES)) {
[13:21:40.131]                   name <- changed[[kk]]
[13:21:40.131]                   NAME <- NAMES[[kk]]
[13:21:40.131]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.131]                     next
[13:21:40.131]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:40.131]                 }
[13:21:40.131]                 NAMES <- toupper(added)
[13:21:40.131]                 for (kk in seq_along(NAMES)) {
[13:21:40.131]                   name <- added[[kk]]
[13:21:40.131]                   NAME <- NAMES[[kk]]
[13:21:40.131]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.131]                     next
[13:21:40.131]                   args[[name]] <- ""
[13:21:40.131]                 }
[13:21:40.131]                 NAMES <- toupper(removed)
[13:21:40.131]                 for (kk in seq_along(NAMES)) {
[13:21:40.131]                   name <- removed[[kk]]
[13:21:40.131]                   NAME <- NAMES[[kk]]
[13:21:40.131]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.131]                     next
[13:21:40.131]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:40.131]                 }
[13:21:40.131]                 if (length(args) > 0) 
[13:21:40.131]                   base::do.call(base::Sys.setenv, args = args)
[13:21:40.131]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:40.131]             }
[13:21:40.131]             else {
[13:21:40.131]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:40.131]             }
[13:21:40.131]             {
[13:21:40.131]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:40.131]                   0L) {
[13:21:40.131]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:40.131]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:40.131]                   base::options(opts)
[13:21:40.131]                 }
[13:21:40.131]                 {
[13:21:40.131]                   {
[13:21:40.131]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:40.131]                     NULL
[13:21:40.131]                   }
[13:21:40.131]                   options(future.plan = NULL)
[13:21:40.131]                   if (is.na(NA_character_)) 
[13:21:40.131]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:40.131]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:40.131]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:40.131]                     envir = parent.frame()) 
[13:21:40.131]                   {
[13:21:40.131]                     default_workers <- missing(workers)
[13:21:40.131]                     if (is.function(workers)) 
[13:21:40.131]                       workers <- workers()
[13:21:40.131]                     workers <- structure(as.integer(workers), 
[13:21:40.131]                       class = class(workers))
[13:21:40.131]                     stop_if_not(is.finite(workers), workers >= 
[13:21:40.131]                       1L)
[13:21:40.131]                     if ((workers == 1L && !inherits(workers, 
[13:21:40.131]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:40.131]                       if (default_workers) 
[13:21:40.131]                         supportsMulticore(warn = TRUE)
[13:21:40.131]                       return(sequential(..., envir = envir))
[13:21:40.131]                     }
[13:21:40.131]                     oopts <- options(mc.cores = workers)
[13:21:40.131]                     on.exit(options(oopts))
[13:21:40.131]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:40.131]                       envir = envir)
[13:21:40.131]                     if (!future$lazy) 
[13:21:40.131]                       future <- run(future)
[13:21:40.131]                     invisible(future)
[13:21:40.131]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:40.131]                 }
[13:21:40.131]             }
[13:21:40.131]         }
[13:21:40.131]     })
[13:21:40.131]     if (TRUE) {
[13:21:40.131]         base::sink(type = "output", split = FALSE)
[13:21:40.131]         if (TRUE) {
[13:21:40.131]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:40.131]         }
[13:21:40.131]         else {
[13:21:40.131]             ...future.result["stdout"] <- base::list(NULL)
[13:21:40.131]         }
[13:21:40.131]         base::close(...future.stdout)
[13:21:40.131]         ...future.stdout <- NULL
[13:21:40.131]     }
[13:21:40.131]     ...future.result$conditions <- ...future.conditions
[13:21:40.131]     ...future.result$finished <- base::Sys.time()
[13:21:40.131]     ...future.result
[13:21:40.131] }
[13:21:40.134] requestCore(): workers = 2
[13:21:40.137] MulticoreFuture started
[13:21:40.137] - Launch lazy future ... done
[13:21:40.138] run() for ‘MulticoreFuture’ ... done
[13:21:40.138] plan(): Setting new future strategy stack:
[13:21:40.138] getGlobalsAndPackages() ...
[13:21:40.138] Searching for globals...
[13:21:40.138] List of future strategies:
[13:21:40.138] 1. sequential:
[13:21:40.138]    - args: function (..., envir = parent.frame())
[13:21:40.138]    - tweaked: FALSE
[13:21:40.138]    - call: NULL
[13:21:40.139] plan(): nbrOfWorkers() = 1
[13:21:40.139] 
[13:21:40.139] Searching for globals ... DONE
[13:21:40.139] - globals: [0] <none>
[13:21:40.139] getGlobalsAndPackages() ... DONE
[13:21:40.140] run() for ‘Future’ ...
[13:21:40.140] - state: ‘created’
[13:21:40.140] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:40.141] plan(): Setting new future strategy stack:
[13:21:40.141] List of future strategies:
[13:21:40.141] 1. multicore:
[13:21:40.141]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:40.141]    - tweaked: FALSE
[13:21:40.141]    - call: plan(strategy)
[13:21:40.146] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:40.146] plan(): nbrOfWorkers() = 2
[13:21:40.146] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:40.146]   - Field: ‘label’
[13:21:40.147]   - Field: ‘local’
[13:21:40.147]   - Field: ‘owner’
[13:21:40.147]   - Field: ‘envir’
[13:21:40.147]   - Field: ‘workers’
[13:21:40.147]   - Field: ‘packages’
[13:21:40.147]   - Field: ‘gc’
[13:21:40.148]   - Field: ‘job’
[13:21:40.148]   - Field: ‘conditions’
[13:21:40.148]   - Field: ‘expr’
[13:21:40.148]   - Field: ‘uuid’
[13:21:40.148]   - Field: ‘seed’
[13:21:40.148]   - Field: ‘version’
[13:21:40.148]   - Field: ‘result’
[13:21:40.149]   - Field: ‘asynchronous’
[13:21:40.149]   - Field: ‘calls’
[13:21:40.149]   - Field: ‘globals’
[13:21:40.149]   - Field: ‘stdout’
[13:21:40.149]   - Field: ‘earlySignal’
[13:21:40.149]   - Field: ‘lazy’
[13:21:40.150]   - Field: ‘state’
[13:21:40.150] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:40.150] - Launch lazy future ...
[13:21:40.150] Packages needed by the future expression (n = 0): <none>
[13:21:40.154] Packages needed by future strategies (n = 0): <none>
[13:21:40.156] {
[13:21:40.156]     {
[13:21:40.156]         {
[13:21:40.156]             ...future.startTime <- base::Sys.time()
[13:21:40.156]             {
[13:21:40.156]                 {
[13:21:40.156]                   {
[13:21:40.156]                     {
[13:21:40.156]                       base::local({
[13:21:40.156]                         has_future <- base::requireNamespace("future", 
[13:21:40.156]                           quietly = TRUE)
[13:21:40.156]                         if (has_future) {
[13:21:40.156]                           ns <- base::getNamespace("future")
[13:21:40.156]                           version <- ns[[".package"]][["version"]]
[13:21:40.156]                           if (is.null(version)) 
[13:21:40.156]                             version <- utils::packageVersion("future")
[13:21:40.156]                         }
[13:21:40.156]                         else {
[13:21:40.156]                           version <- NULL
[13:21:40.156]                         }
[13:21:40.156]                         if (!has_future || version < "1.8.0") {
[13:21:40.156]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:40.156]                             "", base::R.version$version.string), 
[13:21:40.156]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:40.156]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:40.156]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:40.156]                               "release", "version")], collapse = " "), 
[13:21:40.156]                             hostname = base::Sys.info()[["nodename"]])
[13:21:40.156]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:40.156]                             info)
[13:21:40.156]                           info <- base::paste(info, collapse = "; ")
[13:21:40.156]                           if (!has_future) {
[13:21:40.156]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:40.156]                               info)
[13:21:40.156]                           }
[13:21:40.156]                           else {
[13:21:40.156]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:40.156]                               info, version)
[13:21:40.156]                           }
[13:21:40.156]                           base::stop(msg)
[13:21:40.156]                         }
[13:21:40.156]                       })
[13:21:40.156]                     }
[13:21:40.156]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:40.156]                     base::options(mc.cores = 1L)
[13:21:40.156]                   }
[13:21:40.156]                   options(future.plan = NULL)
[13:21:40.156]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:40.156]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:40.156]                 }
[13:21:40.156]                 ...future.workdir <- getwd()
[13:21:40.156]             }
[13:21:40.156]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:40.156]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:40.156]         }
[13:21:40.156]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:40.156]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:40.156]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:40.156]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:40.156]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:40.156]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:40.156]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:40.156]             base::names(...future.oldOptions))
[13:21:40.156]     }
[13:21:40.156]     if (FALSE) {
[13:21:40.156]     }
[13:21:40.156]     else {
[13:21:40.156]         if (TRUE) {
[13:21:40.156]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:40.156]                 open = "w")
[13:21:40.156]         }
[13:21:40.156]         else {
[13:21:40.156]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:40.156]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:40.156]         }
[13:21:40.156]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:40.156]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:40.156]             base::sink(type = "output", split = FALSE)
[13:21:40.156]             base::close(...future.stdout)
[13:21:40.156]         }, add = TRUE)
[13:21:40.156]     }
[13:21:40.156]     ...future.frame <- base::sys.nframe()
[13:21:40.156]     ...future.conditions <- base::list()
[13:21:40.156]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:40.156]     if (FALSE) {
[13:21:40.156]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:40.156]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:40.156]     }
[13:21:40.156]     ...future.result <- base::tryCatch({
[13:21:40.156]         base::withCallingHandlers({
[13:21:40.156]             ...future.value <- base::withVisible(base::local({
[13:21:40.156]                 withCallingHandlers({
[13:21:40.156]                   2
[13:21:40.156]                 }, immediateCondition = function(cond) {
[13:21:40.156]                   save_rds <- function (object, pathname, ...) 
[13:21:40.156]                   {
[13:21:40.156]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:40.156]                     if (file_test("-f", pathname_tmp)) {
[13:21:40.156]                       fi_tmp <- file.info(pathname_tmp)
[13:21:40.156]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:40.156]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:40.156]                         fi_tmp[["mtime"]])
[13:21:40.156]                     }
[13:21:40.156]                     tryCatch({
[13:21:40.156]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:40.156]                     }, error = function(ex) {
[13:21:40.156]                       msg <- conditionMessage(ex)
[13:21:40.156]                       fi_tmp <- file.info(pathname_tmp)
[13:21:40.156]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:40.156]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:40.156]                         fi_tmp[["mtime"]], msg)
[13:21:40.156]                       ex$message <- msg
[13:21:40.156]                       stop(ex)
[13:21:40.156]                     })
[13:21:40.156]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:40.156]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:40.156]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:40.156]                       fi_tmp <- file.info(pathname_tmp)
[13:21:40.156]                       fi <- file.info(pathname)
[13:21:40.156]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:40.156]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:40.156]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:40.156]                         fi[["size"]], fi[["mtime"]])
[13:21:40.156]                       stop(msg)
[13:21:40.156]                     }
[13:21:40.156]                     invisible(pathname)
[13:21:40.156]                   }
[13:21:40.156]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:40.156]                     rootPath = tempdir()) 
[13:21:40.156]                   {
[13:21:40.156]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:40.156]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:40.156]                       tmpdir = path, fileext = ".rds")
[13:21:40.156]                     save_rds(obj, file)
[13:21:40.156]                   }
[13:21:40.156]                   saveImmediateCondition(cond, path = "/tmp/RtmpRIPAyw/.future/immediateConditions")
[13:21:40.156]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.156]                   {
[13:21:40.156]                     inherits <- base::inherits
[13:21:40.156]                     invokeRestart <- base::invokeRestart
[13:21:40.156]                     is.null <- base::is.null
[13:21:40.156]                     muffled <- FALSE
[13:21:40.156]                     if (inherits(cond, "message")) {
[13:21:40.156]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:40.156]                       if (muffled) 
[13:21:40.156]                         invokeRestart("muffleMessage")
[13:21:40.156]                     }
[13:21:40.156]                     else if (inherits(cond, "warning")) {
[13:21:40.156]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:40.156]                       if (muffled) 
[13:21:40.156]                         invokeRestart("muffleWarning")
[13:21:40.156]                     }
[13:21:40.156]                     else if (inherits(cond, "condition")) {
[13:21:40.156]                       if (!is.null(pattern)) {
[13:21:40.156]                         computeRestarts <- base::computeRestarts
[13:21:40.156]                         grepl <- base::grepl
[13:21:40.156]                         restarts <- computeRestarts(cond)
[13:21:40.156]                         for (restart in restarts) {
[13:21:40.156]                           name <- restart$name
[13:21:40.156]                           if (is.null(name)) 
[13:21:40.156]                             next
[13:21:40.156]                           if (!grepl(pattern, name)) 
[13:21:40.156]                             next
[13:21:40.156]                           invokeRestart(restart)
[13:21:40.156]                           muffled <- TRUE
[13:21:40.156]                           break
[13:21:40.156]                         }
[13:21:40.156]                       }
[13:21:40.156]                     }
[13:21:40.156]                     invisible(muffled)
[13:21:40.156]                   }
[13:21:40.156]                   muffleCondition(cond)
[13:21:40.156]                 })
[13:21:40.156]             }))
[13:21:40.156]             future::FutureResult(value = ...future.value$value, 
[13:21:40.156]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:40.156]                   ...future.rng), globalenv = if (FALSE) 
[13:21:40.156]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:40.156]                     ...future.globalenv.names))
[13:21:40.156]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:40.156]         }, condition = base::local({
[13:21:40.156]             c <- base::c
[13:21:40.156]             inherits <- base::inherits
[13:21:40.156]             invokeRestart <- base::invokeRestart
[13:21:40.156]             length <- base::length
[13:21:40.156]             list <- base::list
[13:21:40.156]             seq.int <- base::seq.int
[13:21:40.156]             signalCondition <- base::signalCondition
[13:21:40.156]             sys.calls <- base::sys.calls
[13:21:40.156]             `[[` <- base::`[[`
[13:21:40.156]             `+` <- base::`+`
[13:21:40.156]             `<<-` <- base::`<<-`
[13:21:40.156]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:40.156]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:40.156]                   3L)]
[13:21:40.156]             }
[13:21:40.156]             function(cond) {
[13:21:40.156]                 is_error <- inherits(cond, "error")
[13:21:40.156]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:40.156]                   NULL)
[13:21:40.156]                 if (is_error) {
[13:21:40.156]                   sessionInformation <- function() {
[13:21:40.156]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:40.156]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:40.156]                       search = base::search(), system = base::Sys.info())
[13:21:40.156]                   }
[13:21:40.156]                   ...future.conditions[[length(...future.conditions) + 
[13:21:40.156]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:40.156]                     cond$call), session = sessionInformation(), 
[13:21:40.156]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:40.156]                   signalCondition(cond)
[13:21:40.156]                 }
[13:21:40.156]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:40.156]                 "immediateCondition"))) {
[13:21:40.156]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:40.156]                   ...future.conditions[[length(...future.conditions) + 
[13:21:40.156]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:40.156]                   if (TRUE && !signal) {
[13:21:40.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.156]                     {
[13:21:40.156]                       inherits <- base::inherits
[13:21:40.156]                       invokeRestart <- base::invokeRestart
[13:21:40.156]                       is.null <- base::is.null
[13:21:40.156]                       muffled <- FALSE
[13:21:40.156]                       if (inherits(cond, "message")) {
[13:21:40.156]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:40.156]                         if (muffled) 
[13:21:40.156]                           invokeRestart("muffleMessage")
[13:21:40.156]                       }
[13:21:40.156]                       else if (inherits(cond, "warning")) {
[13:21:40.156]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:40.156]                         if (muffled) 
[13:21:40.156]                           invokeRestart("muffleWarning")
[13:21:40.156]                       }
[13:21:40.156]                       else if (inherits(cond, "condition")) {
[13:21:40.156]                         if (!is.null(pattern)) {
[13:21:40.156]                           computeRestarts <- base::computeRestarts
[13:21:40.156]                           grepl <- base::grepl
[13:21:40.156]                           restarts <- computeRestarts(cond)
[13:21:40.156]                           for (restart in restarts) {
[13:21:40.156]                             name <- restart$name
[13:21:40.156]                             if (is.null(name)) 
[13:21:40.156]                               next
[13:21:40.156]                             if (!grepl(pattern, name)) 
[13:21:40.156]                               next
[13:21:40.156]                             invokeRestart(restart)
[13:21:40.156]                             muffled <- TRUE
[13:21:40.156]                             break
[13:21:40.156]                           }
[13:21:40.156]                         }
[13:21:40.156]                       }
[13:21:40.156]                       invisible(muffled)
[13:21:40.156]                     }
[13:21:40.156]                     muffleCondition(cond, pattern = "^muffle")
[13:21:40.156]                   }
[13:21:40.156]                 }
[13:21:40.156]                 else {
[13:21:40.156]                   if (TRUE) {
[13:21:40.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.156]                     {
[13:21:40.156]                       inherits <- base::inherits
[13:21:40.156]                       invokeRestart <- base::invokeRestart
[13:21:40.156]                       is.null <- base::is.null
[13:21:40.156]                       muffled <- FALSE
[13:21:40.156]                       if (inherits(cond, "message")) {
[13:21:40.156]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:40.156]                         if (muffled) 
[13:21:40.156]                           invokeRestart("muffleMessage")
[13:21:40.156]                       }
[13:21:40.156]                       else if (inherits(cond, "warning")) {
[13:21:40.156]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:40.156]                         if (muffled) 
[13:21:40.156]                           invokeRestart("muffleWarning")
[13:21:40.156]                       }
[13:21:40.156]                       else if (inherits(cond, "condition")) {
[13:21:40.156]                         if (!is.null(pattern)) {
[13:21:40.156]                           computeRestarts <- base::computeRestarts
[13:21:40.156]                           grepl <- base::grepl
[13:21:40.156]                           restarts <- computeRestarts(cond)
[13:21:40.156]                           for (restart in restarts) {
[13:21:40.156]                             name <- restart$name
[13:21:40.156]                             if (is.null(name)) 
[13:21:40.156]                               next
[13:21:40.156]                             if (!grepl(pattern, name)) 
[13:21:40.156]                               next
[13:21:40.156]                             invokeRestart(restart)
[13:21:40.156]                             muffled <- TRUE
[13:21:40.156]                             break
[13:21:40.156]                           }
[13:21:40.156]                         }
[13:21:40.156]                       }
[13:21:40.156]                       invisible(muffled)
[13:21:40.156]                     }
[13:21:40.156]                     muffleCondition(cond, pattern = "^muffle")
[13:21:40.156]                   }
[13:21:40.156]                 }
[13:21:40.156]             }
[13:21:40.156]         }))
[13:21:40.156]     }, error = function(ex) {
[13:21:40.156]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:40.156]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:40.156]                 ...future.rng), started = ...future.startTime, 
[13:21:40.156]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:40.156]             version = "1.8"), class = "FutureResult")
[13:21:40.156]     }, finally = {
[13:21:40.156]         if (!identical(...future.workdir, getwd())) 
[13:21:40.156]             setwd(...future.workdir)
[13:21:40.156]         {
[13:21:40.156]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:40.156]                 ...future.oldOptions$nwarnings <- NULL
[13:21:40.156]             }
[13:21:40.156]             base::options(...future.oldOptions)
[13:21:40.156]             if (.Platform$OS.type == "windows") {
[13:21:40.156]                 old_names <- names(...future.oldEnvVars)
[13:21:40.156]                 envs <- base::Sys.getenv()
[13:21:40.156]                 names <- names(envs)
[13:21:40.156]                 common <- intersect(names, old_names)
[13:21:40.156]                 added <- setdiff(names, old_names)
[13:21:40.156]                 removed <- setdiff(old_names, names)
[13:21:40.156]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:40.156]                   envs[common]]
[13:21:40.156]                 NAMES <- toupper(changed)
[13:21:40.156]                 args <- list()
[13:21:40.156]                 for (kk in seq_along(NAMES)) {
[13:21:40.156]                   name <- changed[[kk]]
[13:21:40.156]                   NAME <- NAMES[[kk]]
[13:21:40.156]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.156]                     next
[13:21:40.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:40.156]                 }
[13:21:40.156]                 NAMES <- toupper(added)
[13:21:40.156]                 for (kk in seq_along(NAMES)) {
[13:21:40.156]                   name <- added[[kk]]
[13:21:40.156]                   NAME <- NAMES[[kk]]
[13:21:40.156]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.156]                     next
[13:21:40.156]                   args[[name]] <- ""
[13:21:40.156]                 }
[13:21:40.156]                 NAMES <- toupper(removed)
[13:21:40.156]                 for (kk in seq_along(NAMES)) {
[13:21:40.156]                   name <- removed[[kk]]
[13:21:40.156]                   NAME <- NAMES[[kk]]
[13:21:40.156]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.156]                     next
[13:21:40.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:40.156]                 }
[13:21:40.156]                 if (length(args) > 0) 
[13:21:40.156]                   base::do.call(base::Sys.setenv, args = args)
[13:21:40.156]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:40.156]             }
[13:21:40.156]             else {
[13:21:40.156]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:40.156]             }
[13:21:40.156]             {
[13:21:40.156]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:40.156]                   0L) {
[13:21:40.156]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:40.156]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:40.156]                   base::options(opts)
[13:21:40.156]                 }
[13:21:40.156]                 {
[13:21:40.156]                   {
[13:21:40.156]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:40.156]                     NULL
[13:21:40.156]                   }
[13:21:40.156]                   options(future.plan = NULL)
[13:21:40.156]                   if (is.na(NA_character_)) 
[13:21:40.156]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:40.156]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:40.156]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:40.156]                     envir = parent.frame()) 
[13:21:40.156]                   {
[13:21:40.156]                     default_workers <- missing(workers)
[13:21:40.156]                     if (is.function(workers)) 
[13:21:40.156]                       workers <- workers()
[13:21:40.156]                     workers <- structure(as.integer(workers), 
[13:21:40.156]                       class = class(workers))
[13:21:40.156]                     stop_if_not(is.finite(workers), workers >= 
[13:21:40.156]                       1L)
[13:21:40.156]                     if ((workers == 1L && !inherits(workers, 
[13:21:40.156]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:40.156]                       if (default_workers) 
[13:21:40.156]                         supportsMulticore(warn = TRUE)
[13:21:40.156]                       return(sequential(..., envir = envir))
[13:21:40.156]                     }
[13:21:40.156]                     oopts <- options(mc.cores = workers)
[13:21:40.156]                     on.exit(options(oopts))
[13:21:40.156]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:40.156]                       envir = envir)
[13:21:40.156]                     if (!future$lazy) 
[13:21:40.156]                       future <- run(future)
[13:21:40.156]                     invisible(future)
[13:21:40.156]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:40.156]                 }
[13:21:40.156]             }
[13:21:40.156]         }
[13:21:40.156]     })
[13:21:40.156]     if (TRUE) {
[13:21:40.156]         base::sink(type = "output", split = FALSE)
[13:21:40.156]         if (TRUE) {
[13:21:40.156]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:40.156]         }
[13:21:40.156]         else {
[13:21:40.156]             ...future.result["stdout"] <- base::list(NULL)
[13:21:40.156]         }
[13:21:40.156]         base::close(...future.stdout)
[13:21:40.156]         ...future.stdout <- NULL
[13:21:40.156]     }
[13:21:40.156]     ...future.result$conditions <- ...future.conditions
[13:21:40.156]     ...future.result$finished <- base::Sys.time()
[13:21:40.156]     ...future.result
[13:21:40.156] }
[13:21:40.159] requestCore(): workers = 2
[13:21:40.166] MulticoreFuture started
[13:21:40.167] - Launch lazy future ... done
[13:21:40.167] run() for ‘MulticoreFuture’ ... done
[13:21:40.168] resolve() on list ...
[13:21:40.168]  recursive: 0
[13:21:40.168] plan(): Setting new future strategy stack:
[13:21:40.168]  length: 3
[13:21:40.168]  elements: ‘a’, ‘b’, ‘’
[13:21:40.168] List of future strategies:
[13:21:40.168] 1. sequential:
[13:21:40.168]    - args: function (..., envir = parent.frame())
[13:21:40.168]    - tweaked: FALSE
[13:21:40.168]    - call: NULL
[13:21:40.169] plan(): nbrOfWorkers() = 1
[13:21:40.171] Future #1
[13:21:40.171]  length: 2 (resolved future 1)
[13:21:40.171] plan(): Setting new future strategy stack:
[13:21:40.171] List of future strategies:
[13:21:40.171] 1. multicore:
[13:21:40.171]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:40.171]    - tweaked: FALSE
[13:21:40.171]    - call: plan(strategy)
[13:21:40.178] plan(): nbrOfWorkers() = 2
[13:21:40.178] Future #2
[13:21:40.178]  length: 1 (resolved future 2)
[13:21:40.179]  length: 0 (resolved future 3)
[13:21:40.179] resolve() on list ... DONE
[13:21:40.179] getGlobalsAndPackages() ...
[13:21:40.180] Searching for globals...
[13:21:40.180] 
[13:21:40.181] Searching for globals ... DONE
[13:21:40.181] - globals: [0] <none>
[13:21:40.181] getGlobalsAndPackages() ... DONE
[13:21:40.181] getGlobalsAndPackages() ...
[13:21:40.182] Searching for globals...
[13:21:40.182] 
[13:21:40.182] Searching for globals ... DONE
[13:21:40.182] - globals: [0] <none>
[13:21:40.183] getGlobalsAndPackages() ... DONE
[13:21:40.183] run() for ‘Future’ ...
[13:21:40.183] - state: ‘created’
[13:21:40.183] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:40.188] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:40.188] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:40.188]   - Field: ‘label’
[13:21:40.188]   - Field: ‘local’
[13:21:40.188]   - Field: ‘owner’
[13:21:40.188]   - Field: ‘envir’
[13:21:40.189]   - Field: ‘workers’
[13:21:40.189]   - Field: ‘packages’
[13:21:40.189]   - Field: ‘gc’
[13:21:40.189]   - Field: ‘job’
[13:21:40.189]   - Field: ‘conditions’
[13:21:40.189]   - Field: ‘expr’
[13:21:40.190]   - Field: ‘uuid’
[13:21:40.190]   - Field: ‘seed’
[13:21:40.190]   - Field: ‘version’
[13:21:40.190]   - Field: ‘result’
[13:21:40.190]   - Field: ‘asynchronous’
[13:21:40.190]   - Field: ‘calls’
[13:21:40.190]   - Field: ‘globals’
[13:21:40.191]   - Field: ‘stdout’
[13:21:40.191]   - Field: ‘earlySignal’
[13:21:40.191]   - Field: ‘lazy’
[13:21:40.191]   - Field: ‘state’
[13:21:40.191] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:40.191] - Launch lazy future ...
[13:21:40.192] Packages needed by the future expression (n = 0): <none>
[13:21:40.192] Packages needed by future strategies (n = 0): <none>
[13:21:40.193] {
[13:21:40.193]     {
[13:21:40.193]         {
[13:21:40.193]             ...future.startTime <- base::Sys.time()
[13:21:40.193]             {
[13:21:40.193]                 {
[13:21:40.193]                   {
[13:21:40.193]                     {
[13:21:40.193]                       base::local({
[13:21:40.193]                         has_future <- base::requireNamespace("future", 
[13:21:40.193]                           quietly = TRUE)
[13:21:40.193]                         if (has_future) {
[13:21:40.193]                           ns <- base::getNamespace("future")
[13:21:40.193]                           version <- ns[[".package"]][["version"]]
[13:21:40.193]                           if (is.null(version)) 
[13:21:40.193]                             version <- utils::packageVersion("future")
[13:21:40.193]                         }
[13:21:40.193]                         else {
[13:21:40.193]                           version <- NULL
[13:21:40.193]                         }
[13:21:40.193]                         if (!has_future || version < "1.8.0") {
[13:21:40.193]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:40.193]                             "", base::R.version$version.string), 
[13:21:40.193]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:40.193]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:40.193]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:40.193]                               "release", "version")], collapse = " "), 
[13:21:40.193]                             hostname = base::Sys.info()[["nodename"]])
[13:21:40.193]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:40.193]                             info)
[13:21:40.193]                           info <- base::paste(info, collapse = "; ")
[13:21:40.193]                           if (!has_future) {
[13:21:40.193]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:40.193]                               info)
[13:21:40.193]                           }
[13:21:40.193]                           else {
[13:21:40.193]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:40.193]                               info, version)
[13:21:40.193]                           }
[13:21:40.193]                           base::stop(msg)
[13:21:40.193]                         }
[13:21:40.193]                       })
[13:21:40.193]                     }
[13:21:40.193]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:40.193]                     base::options(mc.cores = 1L)
[13:21:40.193]                   }
[13:21:40.193]                   options(future.plan = NULL)
[13:21:40.193]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:40.193]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:40.193]                 }
[13:21:40.193]                 ...future.workdir <- getwd()
[13:21:40.193]             }
[13:21:40.193]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:40.193]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:40.193]         }
[13:21:40.193]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:40.193]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:40.193]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:40.193]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:40.193]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:40.193]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:40.193]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:40.193]             base::names(...future.oldOptions))
[13:21:40.193]     }
[13:21:40.193]     if (FALSE) {
[13:21:40.193]     }
[13:21:40.193]     else {
[13:21:40.193]         if (TRUE) {
[13:21:40.193]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:40.193]                 open = "w")
[13:21:40.193]         }
[13:21:40.193]         else {
[13:21:40.193]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:40.193]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:40.193]         }
[13:21:40.193]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:40.193]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:40.193]             base::sink(type = "output", split = FALSE)
[13:21:40.193]             base::close(...future.stdout)
[13:21:40.193]         }, add = TRUE)
[13:21:40.193]     }
[13:21:40.193]     ...future.frame <- base::sys.nframe()
[13:21:40.193]     ...future.conditions <- base::list()
[13:21:40.193]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:40.193]     if (FALSE) {
[13:21:40.193]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:40.193]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:40.193]     }
[13:21:40.193]     ...future.result <- base::tryCatch({
[13:21:40.193]         base::withCallingHandlers({
[13:21:40.193]             ...future.value <- base::withVisible(base::local({
[13:21:40.193]                 withCallingHandlers({
[13:21:40.193]                   2
[13:21:40.193]                 }, immediateCondition = function(cond) {
[13:21:40.193]                   save_rds <- function (object, pathname, ...) 
[13:21:40.193]                   {
[13:21:40.193]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:40.193]                     if (file_test("-f", pathname_tmp)) {
[13:21:40.193]                       fi_tmp <- file.info(pathname_tmp)
[13:21:40.193]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:40.193]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:40.193]                         fi_tmp[["mtime"]])
[13:21:40.193]                     }
[13:21:40.193]                     tryCatch({
[13:21:40.193]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:40.193]                     }, error = function(ex) {
[13:21:40.193]                       msg <- conditionMessage(ex)
[13:21:40.193]                       fi_tmp <- file.info(pathname_tmp)
[13:21:40.193]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:40.193]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:40.193]                         fi_tmp[["mtime"]], msg)
[13:21:40.193]                       ex$message <- msg
[13:21:40.193]                       stop(ex)
[13:21:40.193]                     })
[13:21:40.193]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:40.193]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:40.193]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:40.193]                       fi_tmp <- file.info(pathname_tmp)
[13:21:40.193]                       fi <- file.info(pathname)
[13:21:40.193]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:40.193]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:40.193]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:40.193]                         fi[["size"]], fi[["mtime"]])
[13:21:40.193]                       stop(msg)
[13:21:40.193]                     }
[13:21:40.193]                     invisible(pathname)
[13:21:40.193]                   }
[13:21:40.193]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:40.193]                     rootPath = tempdir()) 
[13:21:40.193]                   {
[13:21:40.193]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:40.193]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:40.193]                       tmpdir = path, fileext = ".rds")
[13:21:40.193]                     save_rds(obj, file)
[13:21:40.193]                   }
[13:21:40.193]                   saveImmediateCondition(cond, path = "/tmp/RtmpRIPAyw/.future/immediateConditions")
[13:21:40.193]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.193]                   {
[13:21:40.193]                     inherits <- base::inherits
[13:21:40.193]                     invokeRestart <- base::invokeRestart
[13:21:40.193]                     is.null <- base::is.null
[13:21:40.193]                     muffled <- FALSE
[13:21:40.193]                     if (inherits(cond, "message")) {
[13:21:40.193]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:40.193]                       if (muffled) 
[13:21:40.193]                         invokeRestart("muffleMessage")
[13:21:40.193]                     }
[13:21:40.193]                     else if (inherits(cond, "warning")) {
[13:21:40.193]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:40.193]                       if (muffled) 
[13:21:40.193]                         invokeRestart("muffleWarning")
[13:21:40.193]                     }
[13:21:40.193]                     else if (inherits(cond, "condition")) {
[13:21:40.193]                       if (!is.null(pattern)) {
[13:21:40.193]                         computeRestarts <- base::computeRestarts
[13:21:40.193]                         grepl <- base::grepl
[13:21:40.193]                         restarts <- computeRestarts(cond)
[13:21:40.193]                         for (restart in restarts) {
[13:21:40.193]                           name <- restart$name
[13:21:40.193]                           if (is.null(name)) 
[13:21:40.193]                             next
[13:21:40.193]                           if (!grepl(pattern, name)) 
[13:21:40.193]                             next
[13:21:40.193]                           invokeRestart(restart)
[13:21:40.193]                           muffled <- TRUE
[13:21:40.193]                           break
[13:21:40.193]                         }
[13:21:40.193]                       }
[13:21:40.193]                     }
[13:21:40.193]                     invisible(muffled)
[13:21:40.193]                   }
[13:21:40.193]                   muffleCondition(cond)
[13:21:40.193]                 })
[13:21:40.193]             }))
[13:21:40.193]             future::FutureResult(value = ...future.value$value, 
[13:21:40.193]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:40.193]                   ...future.rng), globalenv = if (FALSE) 
[13:21:40.193]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:40.193]                     ...future.globalenv.names))
[13:21:40.193]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:40.193]         }, condition = base::local({
[13:21:40.193]             c <- base::c
[13:21:40.193]             inherits <- base::inherits
[13:21:40.193]             invokeRestart <- base::invokeRestart
[13:21:40.193]             length <- base::length
[13:21:40.193]             list <- base::list
[13:21:40.193]             seq.int <- base::seq.int
[13:21:40.193]             signalCondition <- base::signalCondition
[13:21:40.193]             sys.calls <- base::sys.calls
[13:21:40.193]             `[[` <- base::`[[`
[13:21:40.193]             `+` <- base::`+`
[13:21:40.193]             `<<-` <- base::`<<-`
[13:21:40.193]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:40.193]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:40.193]                   3L)]
[13:21:40.193]             }
[13:21:40.193]             function(cond) {
[13:21:40.193]                 is_error <- inherits(cond, "error")
[13:21:40.193]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:40.193]                   NULL)
[13:21:40.193]                 if (is_error) {
[13:21:40.193]                   sessionInformation <- function() {
[13:21:40.193]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:40.193]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:40.193]                       search = base::search(), system = base::Sys.info())
[13:21:40.193]                   }
[13:21:40.193]                   ...future.conditions[[length(...future.conditions) + 
[13:21:40.193]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:40.193]                     cond$call), session = sessionInformation(), 
[13:21:40.193]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:40.193]                   signalCondition(cond)
[13:21:40.193]                 }
[13:21:40.193]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:40.193]                 "immediateCondition"))) {
[13:21:40.193]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:40.193]                   ...future.conditions[[length(...future.conditions) + 
[13:21:40.193]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:40.193]                   if (TRUE && !signal) {
[13:21:40.193]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.193]                     {
[13:21:40.193]                       inherits <- base::inherits
[13:21:40.193]                       invokeRestart <- base::invokeRestart
[13:21:40.193]                       is.null <- base::is.null
[13:21:40.193]                       muffled <- FALSE
[13:21:40.193]                       if (inherits(cond, "message")) {
[13:21:40.193]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:40.193]                         if (muffled) 
[13:21:40.193]                           invokeRestart("muffleMessage")
[13:21:40.193]                       }
[13:21:40.193]                       else if (inherits(cond, "warning")) {
[13:21:40.193]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:40.193]                         if (muffled) 
[13:21:40.193]                           invokeRestart("muffleWarning")
[13:21:40.193]                       }
[13:21:40.193]                       else if (inherits(cond, "condition")) {
[13:21:40.193]                         if (!is.null(pattern)) {
[13:21:40.193]                           computeRestarts <- base::computeRestarts
[13:21:40.193]                           grepl <- base::grepl
[13:21:40.193]                           restarts <- computeRestarts(cond)
[13:21:40.193]                           for (restart in restarts) {
[13:21:40.193]                             name <- restart$name
[13:21:40.193]                             if (is.null(name)) 
[13:21:40.193]                               next
[13:21:40.193]                             if (!grepl(pattern, name)) 
[13:21:40.193]                               next
[13:21:40.193]                             invokeRestart(restart)
[13:21:40.193]                             muffled <- TRUE
[13:21:40.193]                             break
[13:21:40.193]                           }
[13:21:40.193]                         }
[13:21:40.193]                       }
[13:21:40.193]                       invisible(muffled)
[13:21:40.193]                     }
[13:21:40.193]                     muffleCondition(cond, pattern = "^muffle")
[13:21:40.193]                   }
[13:21:40.193]                 }
[13:21:40.193]                 else {
[13:21:40.193]                   if (TRUE) {
[13:21:40.193]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.193]                     {
[13:21:40.193]                       inherits <- base::inherits
[13:21:40.193]                       invokeRestart <- base::invokeRestart
[13:21:40.193]                       is.null <- base::is.null
[13:21:40.193]                       muffled <- FALSE
[13:21:40.193]                       if (inherits(cond, "message")) {
[13:21:40.193]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:40.193]                         if (muffled) 
[13:21:40.193]                           invokeRestart("muffleMessage")
[13:21:40.193]                       }
[13:21:40.193]                       else if (inherits(cond, "warning")) {
[13:21:40.193]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:40.193]                         if (muffled) 
[13:21:40.193]                           invokeRestart("muffleWarning")
[13:21:40.193]                       }
[13:21:40.193]                       else if (inherits(cond, "condition")) {
[13:21:40.193]                         if (!is.null(pattern)) {
[13:21:40.193]                           computeRestarts <- base::computeRestarts
[13:21:40.193]                           grepl <- base::grepl
[13:21:40.193]                           restarts <- computeRestarts(cond)
[13:21:40.193]                           for (restart in restarts) {
[13:21:40.193]                             name <- restart$name
[13:21:40.193]                             if (is.null(name)) 
[13:21:40.193]                               next
[13:21:40.193]                             if (!grepl(pattern, name)) 
[13:21:40.193]                               next
[13:21:40.193]                             invokeRestart(restart)
[13:21:40.193]                             muffled <- TRUE
[13:21:40.193]                             break
[13:21:40.193]                           }
[13:21:40.193]                         }
[13:21:40.193]                       }
[13:21:40.193]                       invisible(muffled)
[13:21:40.193]                     }
[13:21:40.193]                     muffleCondition(cond, pattern = "^muffle")
[13:21:40.193]                   }
[13:21:40.193]                 }
[13:21:40.193]             }
[13:21:40.193]         }))
[13:21:40.193]     }, error = function(ex) {
[13:21:40.193]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:40.193]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:40.193]                 ...future.rng), started = ...future.startTime, 
[13:21:40.193]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:40.193]             version = "1.8"), class = "FutureResult")
[13:21:40.193]     }, finally = {
[13:21:40.193]         if (!identical(...future.workdir, getwd())) 
[13:21:40.193]             setwd(...future.workdir)
[13:21:40.193]         {
[13:21:40.193]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:40.193]                 ...future.oldOptions$nwarnings <- NULL
[13:21:40.193]             }
[13:21:40.193]             base::options(...future.oldOptions)
[13:21:40.193]             if (.Platform$OS.type == "windows") {
[13:21:40.193]                 old_names <- names(...future.oldEnvVars)
[13:21:40.193]                 envs <- base::Sys.getenv()
[13:21:40.193]                 names <- names(envs)
[13:21:40.193]                 common <- intersect(names, old_names)
[13:21:40.193]                 added <- setdiff(names, old_names)
[13:21:40.193]                 removed <- setdiff(old_names, names)
[13:21:40.193]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:40.193]                   envs[common]]
[13:21:40.193]                 NAMES <- toupper(changed)
[13:21:40.193]                 args <- list()
[13:21:40.193]                 for (kk in seq_along(NAMES)) {
[13:21:40.193]                   name <- changed[[kk]]
[13:21:40.193]                   NAME <- NAMES[[kk]]
[13:21:40.193]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.193]                     next
[13:21:40.193]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:40.193]                 }
[13:21:40.193]                 NAMES <- toupper(added)
[13:21:40.193]                 for (kk in seq_along(NAMES)) {
[13:21:40.193]                   name <- added[[kk]]
[13:21:40.193]                   NAME <- NAMES[[kk]]
[13:21:40.193]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.193]                     next
[13:21:40.193]                   args[[name]] <- ""
[13:21:40.193]                 }
[13:21:40.193]                 NAMES <- toupper(removed)
[13:21:40.193]                 for (kk in seq_along(NAMES)) {
[13:21:40.193]                   name <- removed[[kk]]
[13:21:40.193]                   NAME <- NAMES[[kk]]
[13:21:40.193]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.193]                     next
[13:21:40.193]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:40.193]                 }
[13:21:40.193]                 if (length(args) > 0) 
[13:21:40.193]                   base::do.call(base::Sys.setenv, args = args)
[13:21:40.193]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:40.193]             }
[13:21:40.193]             else {
[13:21:40.193]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:40.193]             }
[13:21:40.193]             {
[13:21:40.193]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:40.193]                   0L) {
[13:21:40.193]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:40.193]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:40.193]                   base::options(opts)
[13:21:40.193]                 }
[13:21:40.193]                 {
[13:21:40.193]                   {
[13:21:40.193]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:40.193]                     NULL
[13:21:40.193]                   }
[13:21:40.193]                   options(future.plan = NULL)
[13:21:40.193]                   if (is.na(NA_character_)) 
[13:21:40.193]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:40.193]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:40.193]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:40.193]                     envir = parent.frame()) 
[13:21:40.193]                   {
[13:21:40.193]                     default_workers <- missing(workers)
[13:21:40.193]                     if (is.function(workers)) 
[13:21:40.193]                       workers <- workers()
[13:21:40.193]                     workers <- structure(as.integer(workers), 
[13:21:40.193]                       class = class(workers))
[13:21:40.193]                     stop_if_not(is.finite(workers), workers >= 
[13:21:40.193]                       1L)
[13:21:40.193]                     if ((workers == 1L && !inherits(workers, 
[13:21:40.193]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:40.193]                       if (default_workers) 
[13:21:40.193]                         supportsMulticore(warn = TRUE)
[13:21:40.193]                       return(sequential(..., envir = envir))
[13:21:40.193]                     }
[13:21:40.193]                     oopts <- options(mc.cores = workers)
[13:21:40.193]                     on.exit(options(oopts))
[13:21:40.193]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:40.193]                       envir = envir)
[13:21:40.193]                     if (!future$lazy) 
[13:21:40.193]                       future <- run(future)
[13:21:40.193]                     invisible(future)
[13:21:40.193]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:40.193]                 }
[13:21:40.193]             }
[13:21:40.193]         }
[13:21:40.193]     })
[13:21:40.193]     if (TRUE) {
[13:21:40.193]         base::sink(type = "output", split = FALSE)
[13:21:40.193]         if (TRUE) {
[13:21:40.193]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:40.193]         }
[13:21:40.193]         else {
[13:21:40.193]             ...future.result["stdout"] <- base::list(NULL)
[13:21:40.193]         }
[13:21:40.193]         base::close(...future.stdout)
[13:21:40.193]         ...future.stdout <- NULL
[13:21:40.193]     }
[13:21:40.193]     ...future.result$conditions <- ...future.conditions
[13:21:40.193]     ...future.result$finished <- base::Sys.time()
[13:21:40.193]     ...future.result
[13:21:40.193] }
[13:21:40.196] requestCore(): workers = 2
[13:21:40.197] Poll #1 (0): usedCores() = 2, workers = 2
[13:21:40.213] MulticoreFuture started
[13:21:40.213] - Launch lazy future ... done
[13:21:40.214] run() for ‘MulticoreFuture’ ... done
[13:21:40.214] resolve() on list ...
[13:21:40.214]  recursive: 0
[13:21:40.214] plan(): Setting new future strategy stack:
[13:21:40.214]  length: 3
[13:21:40.215]  elements: ‘a’, ‘b’, ‘’
[13:21:40.215] run() for ‘Future’ ...
[13:21:40.215] - state: ‘created’
[13:21:40.215] List of future strategies:
[13:21:40.215] 1. sequential:
[13:21:40.215]    - args: function (..., envir = parent.frame())
[13:21:40.215]    - tweaked: FALSE
[13:21:40.215]    - call: NULL
[13:21:40.215] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:40.216] plan(): nbrOfWorkers() = 1
[13:21:40.218] plan(): Setting new future strategy stack:
[13:21:40.218] List of future strategies:
[13:21:40.218] 1. multicore:
[13:21:40.218]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:40.218]    - tweaked: FALSE
[13:21:40.218]    - call: plan(strategy)
[13:21:40.221] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:40.221] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:40.221]   - Field: ‘label’
[13:21:40.222]   - Field: ‘local’
[13:21:40.222]   - Field: ‘owner’
[13:21:40.222]   - Field: ‘envir’
[13:21:40.222]   - Field: ‘workers’
[13:21:40.223]   - Field: ‘packages’
[13:21:40.223]   - Field: ‘gc’
[13:21:40.223]   - Field: ‘job’
[13:21:40.223] plan(): nbrOfWorkers() = 2
[13:21:40.223]   - Field: ‘conditions’
[13:21:40.224]   - Field: ‘expr’
[13:21:40.224]   - Field: ‘uuid’
[13:21:40.224]   - Field: ‘seed’
[13:21:40.224]   - Field: ‘version’
[13:21:40.224]   - Field: ‘result’
[13:21:40.224]   - Field: ‘asynchronous’
[13:21:40.225]   - Field: ‘calls’
[13:21:40.225]   - Field: ‘globals’
[13:21:40.225]   - Field: ‘stdout’
[13:21:40.225]   - Field: ‘earlySignal’
[13:21:40.225]   - Field: ‘lazy’
[13:21:40.225]   - Field: ‘state’
[13:21:40.226] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:40.226] - Launch lazy future ...
[13:21:40.226] Packages needed by the future expression (n = 0): <none>
[13:21:40.226] Packages needed by future strategies (n = 0): <none>
[13:21:40.227] {
[13:21:40.227]     {
[13:21:40.227]         {
[13:21:40.227]             ...future.startTime <- base::Sys.time()
[13:21:40.227]             {
[13:21:40.227]                 {
[13:21:40.227]                   {
[13:21:40.227]                     {
[13:21:40.227]                       base::local({
[13:21:40.227]                         has_future <- base::requireNamespace("future", 
[13:21:40.227]                           quietly = TRUE)
[13:21:40.227]                         if (has_future) {
[13:21:40.227]                           ns <- base::getNamespace("future")
[13:21:40.227]                           version <- ns[[".package"]][["version"]]
[13:21:40.227]                           if (is.null(version)) 
[13:21:40.227]                             version <- utils::packageVersion("future")
[13:21:40.227]                         }
[13:21:40.227]                         else {
[13:21:40.227]                           version <- NULL
[13:21:40.227]                         }
[13:21:40.227]                         if (!has_future || version < "1.8.0") {
[13:21:40.227]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:40.227]                             "", base::R.version$version.string), 
[13:21:40.227]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:40.227]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:40.227]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:40.227]                               "release", "version")], collapse = " "), 
[13:21:40.227]                             hostname = base::Sys.info()[["nodename"]])
[13:21:40.227]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:40.227]                             info)
[13:21:40.227]                           info <- base::paste(info, collapse = "; ")
[13:21:40.227]                           if (!has_future) {
[13:21:40.227]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:40.227]                               info)
[13:21:40.227]                           }
[13:21:40.227]                           else {
[13:21:40.227]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:40.227]                               info, version)
[13:21:40.227]                           }
[13:21:40.227]                           base::stop(msg)
[13:21:40.227]                         }
[13:21:40.227]                       })
[13:21:40.227]                     }
[13:21:40.227]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:40.227]                     base::options(mc.cores = 1L)
[13:21:40.227]                   }
[13:21:40.227]                   options(future.plan = NULL)
[13:21:40.227]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:40.227]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:40.227]                 }
[13:21:40.227]                 ...future.workdir <- getwd()
[13:21:40.227]             }
[13:21:40.227]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:40.227]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:40.227]         }
[13:21:40.227]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:40.227]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:40.227]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:40.227]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:40.227]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:40.227]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:40.227]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:40.227]             base::names(...future.oldOptions))
[13:21:40.227]     }
[13:21:40.227]     if (FALSE) {
[13:21:40.227]     }
[13:21:40.227]     else {
[13:21:40.227]         if (TRUE) {
[13:21:40.227]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:40.227]                 open = "w")
[13:21:40.227]         }
[13:21:40.227]         else {
[13:21:40.227]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:40.227]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:40.227]         }
[13:21:40.227]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:40.227]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:40.227]             base::sink(type = "output", split = FALSE)
[13:21:40.227]             base::close(...future.stdout)
[13:21:40.227]         }, add = TRUE)
[13:21:40.227]     }
[13:21:40.227]     ...future.frame <- base::sys.nframe()
[13:21:40.227]     ...future.conditions <- base::list()
[13:21:40.227]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:40.227]     if (FALSE) {
[13:21:40.227]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:40.227]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:40.227]     }
[13:21:40.227]     ...future.result <- base::tryCatch({
[13:21:40.227]         base::withCallingHandlers({
[13:21:40.227]             ...future.value <- base::withVisible(base::local({
[13:21:40.227]                 withCallingHandlers({
[13:21:40.227]                   1
[13:21:40.227]                 }, immediateCondition = function(cond) {
[13:21:40.227]                   save_rds <- function (object, pathname, ...) 
[13:21:40.227]                   {
[13:21:40.227]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:40.227]                     if (file_test("-f", pathname_tmp)) {
[13:21:40.227]                       fi_tmp <- file.info(pathname_tmp)
[13:21:40.227]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:40.227]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:40.227]                         fi_tmp[["mtime"]])
[13:21:40.227]                     }
[13:21:40.227]                     tryCatch({
[13:21:40.227]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:40.227]                     }, error = function(ex) {
[13:21:40.227]                       msg <- conditionMessage(ex)
[13:21:40.227]                       fi_tmp <- file.info(pathname_tmp)
[13:21:40.227]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:40.227]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:40.227]                         fi_tmp[["mtime"]], msg)
[13:21:40.227]                       ex$message <- msg
[13:21:40.227]                       stop(ex)
[13:21:40.227]                     })
[13:21:40.227]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:40.227]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:40.227]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:40.227]                       fi_tmp <- file.info(pathname_tmp)
[13:21:40.227]                       fi <- file.info(pathname)
[13:21:40.227]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:40.227]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:40.227]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:40.227]                         fi[["size"]], fi[["mtime"]])
[13:21:40.227]                       stop(msg)
[13:21:40.227]                     }
[13:21:40.227]                     invisible(pathname)
[13:21:40.227]                   }
[13:21:40.227]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:40.227]                     rootPath = tempdir()) 
[13:21:40.227]                   {
[13:21:40.227]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:40.227]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:40.227]                       tmpdir = path, fileext = ".rds")
[13:21:40.227]                     save_rds(obj, file)
[13:21:40.227]                   }
[13:21:40.227]                   saveImmediateCondition(cond, path = "/tmp/RtmpRIPAyw/.future/immediateConditions")
[13:21:40.227]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.227]                   {
[13:21:40.227]                     inherits <- base::inherits
[13:21:40.227]                     invokeRestart <- base::invokeRestart
[13:21:40.227]                     is.null <- base::is.null
[13:21:40.227]                     muffled <- FALSE
[13:21:40.227]                     if (inherits(cond, "message")) {
[13:21:40.227]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:40.227]                       if (muffled) 
[13:21:40.227]                         invokeRestart("muffleMessage")
[13:21:40.227]                     }
[13:21:40.227]                     else if (inherits(cond, "warning")) {
[13:21:40.227]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:40.227]                       if (muffled) 
[13:21:40.227]                         invokeRestart("muffleWarning")
[13:21:40.227]                     }
[13:21:40.227]                     else if (inherits(cond, "condition")) {
[13:21:40.227]                       if (!is.null(pattern)) {
[13:21:40.227]                         computeRestarts <- base::computeRestarts
[13:21:40.227]                         grepl <- base::grepl
[13:21:40.227]                         restarts <- computeRestarts(cond)
[13:21:40.227]                         for (restart in restarts) {
[13:21:40.227]                           name <- restart$name
[13:21:40.227]                           if (is.null(name)) 
[13:21:40.227]                             next
[13:21:40.227]                           if (!grepl(pattern, name)) 
[13:21:40.227]                             next
[13:21:40.227]                           invokeRestart(restart)
[13:21:40.227]                           muffled <- TRUE
[13:21:40.227]                           break
[13:21:40.227]                         }
[13:21:40.227]                       }
[13:21:40.227]                     }
[13:21:40.227]                     invisible(muffled)
[13:21:40.227]                   }
[13:21:40.227]                   muffleCondition(cond)
[13:21:40.227]                 })
[13:21:40.227]             }))
[13:21:40.227]             future::FutureResult(value = ...future.value$value, 
[13:21:40.227]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:40.227]                   ...future.rng), globalenv = if (FALSE) 
[13:21:40.227]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:40.227]                     ...future.globalenv.names))
[13:21:40.227]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:40.227]         }, condition = base::local({
[13:21:40.227]             c <- base::c
[13:21:40.227]             inherits <- base::inherits
[13:21:40.227]             invokeRestart <- base::invokeRestart
[13:21:40.227]             length <- base::length
[13:21:40.227]             list <- base::list
[13:21:40.227]             seq.int <- base::seq.int
[13:21:40.227]             signalCondition <- base::signalCondition
[13:21:40.227]             sys.calls <- base::sys.calls
[13:21:40.227]             `[[` <- base::`[[`
[13:21:40.227]             `+` <- base::`+`
[13:21:40.227]             `<<-` <- base::`<<-`
[13:21:40.227]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:40.227]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:40.227]                   3L)]
[13:21:40.227]             }
[13:21:40.227]             function(cond) {
[13:21:40.227]                 is_error <- inherits(cond, "error")
[13:21:40.227]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:40.227]                   NULL)
[13:21:40.227]                 if (is_error) {
[13:21:40.227]                   sessionInformation <- function() {
[13:21:40.227]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:40.227]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:40.227]                       search = base::search(), system = base::Sys.info())
[13:21:40.227]                   }
[13:21:40.227]                   ...future.conditions[[length(...future.conditions) + 
[13:21:40.227]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:40.227]                     cond$call), session = sessionInformation(), 
[13:21:40.227]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:40.227]                   signalCondition(cond)
[13:21:40.227]                 }
[13:21:40.227]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:40.227]                 "immediateCondition"))) {
[13:21:40.227]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:40.227]                   ...future.conditions[[length(...future.conditions) + 
[13:21:40.227]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:40.227]                   if (TRUE && !signal) {
[13:21:40.227]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.227]                     {
[13:21:40.227]                       inherits <- base::inherits
[13:21:40.227]                       invokeRestart <- base::invokeRestart
[13:21:40.227]                       is.null <- base::is.null
[13:21:40.227]                       muffled <- FALSE
[13:21:40.227]                       if (inherits(cond, "message")) {
[13:21:40.227]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:40.227]                         if (muffled) 
[13:21:40.227]                           invokeRestart("muffleMessage")
[13:21:40.227]                       }
[13:21:40.227]                       else if (inherits(cond, "warning")) {
[13:21:40.227]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:40.227]                         if (muffled) 
[13:21:40.227]                           invokeRestart("muffleWarning")
[13:21:40.227]                       }
[13:21:40.227]                       else if (inherits(cond, "condition")) {
[13:21:40.227]                         if (!is.null(pattern)) {
[13:21:40.227]                           computeRestarts <- base::computeRestarts
[13:21:40.227]                           grepl <- base::grepl
[13:21:40.227]                           restarts <- computeRestarts(cond)
[13:21:40.227]                           for (restart in restarts) {
[13:21:40.227]                             name <- restart$name
[13:21:40.227]                             if (is.null(name)) 
[13:21:40.227]                               next
[13:21:40.227]                             if (!grepl(pattern, name)) 
[13:21:40.227]                               next
[13:21:40.227]                             invokeRestart(restart)
[13:21:40.227]                             muffled <- TRUE
[13:21:40.227]                             break
[13:21:40.227]                           }
[13:21:40.227]                         }
[13:21:40.227]                       }
[13:21:40.227]                       invisible(muffled)
[13:21:40.227]                     }
[13:21:40.227]                     muffleCondition(cond, pattern = "^muffle")
[13:21:40.227]                   }
[13:21:40.227]                 }
[13:21:40.227]                 else {
[13:21:40.227]                   if (TRUE) {
[13:21:40.227]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.227]                     {
[13:21:40.227]                       inherits <- base::inherits
[13:21:40.227]                       invokeRestart <- base::invokeRestart
[13:21:40.227]                       is.null <- base::is.null
[13:21:40.227]                       muffled <- FALSE
[13:21:40.227]                       if (inherits(cond, "message")) {
[13:21:40.227]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:40.227]                         if (muffled) 
[13:21:40.227]                           invokeRestart("muffleMessage")
[13:21:40.227]                       }
[13:21:40.227]                       else if (inherits(cond, "warning")) {
[13:21:40.227]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:40.227]                         if (muffled) 
[13:21:40.227]                           invokeRestart("muffleWarning")
[13:21:40.227]                       }
[13:21:40.227]                       else if (inherits(cond, "condition")) {
[13:21:40.227]                         if (!is.null(pattern)) {
[13:21:40.227]                           computeRestarts <- base::computeRestarts
[13:21:40.227]                           grepl <- base::grepl
[13:21:40.227]                           restarts <- computeRestarts(cond)
[13:21:40.227]                           for (restart in restarts) {
[13:21:40.227]                             name <- restart$name
[13:21:40.227]                             if (is.null(name)) 
[13:21:40.227]                               next
[13:21:40.227]                             if (!grepl(pattern, name)) 
[13:21:40.227]                               next
[13:21:40.227]                             invokeRestart(restart)
[13:21:40.227]                             muffled <- TRUE
[13:21:40.227]                             break
[13:21:40.227]                           }
[13:21:40.227]                         }
[13:21:40.227]                       }
[13:21:40.227]                       invisible(muffled)
[13:21:40.227]                     }
[13:21:40.227]                     muffleCondition(cond, pattern = "^muffle")
[13:21:40.227]                   }
[13:21:40.227]                 }
[13:21:40.227]             }
[13:21:40.227]         }))
[13:21:40.227]     }, error = function(ex) {
[13:21:40.227]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:40.227]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:40.227]                 ...future.rng), started = ...future.startTime, 
[13:21:40.227]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:40.227]             version = "1.8"), class = "FutureResult")
[13:21:40.227]     }, finally = {
[13:21:40.227]         if (!identical(...future.workdir, getwd())) 
[13:21:40.227]             setwd(...future.workdir)
[13:21:40.227]         {
[13:21:40.227]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:40.227]                 ...future.oldOptions$nwarnings <- NULL
[13:21:40.227]             }
[13:21:40.227]             base::options(...future.oldOptions)
[13:21:40.227]             if (.Platform$OS.type == "windows") {
[13:21:40.227]                 old_names <- names(...future.oldEnvVars)
[13:21:40.227]                 envs <- base::Sys.getenv()
[13:21:40.227]                 names <- names(envs)
[13:21:40.227]                 common <- intersect(names, old_names)
[13:21:40.227]                 added <- setdiff(names, old_names)
[13:21:40.227]                 removed <- setdiff(old_names, names)
[13:21:40.227]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:40.227]                   envs[common]]
[13:21:40.227]                 NAMES <- toupper(changed)
[13:21:40.227]                 args <- list()
[13:21:40.227]                 for (kk in seq_along(NAMES)) {
[13:21:40.227]                   name <- changed[[kk]]
[13:21:40.227]                   NAME <- NAMES[[kk]]
[13:21:40.227]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.227]                     next
[13:21:40.227]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:40.227]                 }
[13:21:40.227]                 NAMES <- toupper(added)
[13:21:40.227]                 for (kk in seq_along(NAMES)) {
[13:21:40.227]                   name <- added[[kk]]
[13:21:40.227]                   NAME <- NAMES[[kk]]
[13:21:40.227]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.227]                     next
[13:21:40.227]                   args[[name]] <- ""
[13:21:40.227]                 }
[13:21:40.227]                 NAMES <- toupper(removed)
[13:21:40.227]                 for (kk in seq_along(NAMES)) {
[13:21:40.227]                   name <- removed[[kk]]
[13:21:40.227]                   NAME <- NAMES[[kk]]
[13:21:40.227]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.227]                     next
[13:21:40.227]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:40.227]                 }
[13:21:40.227]                 if (length(args) > 0) 
[13:21:40.227]                   base::do.call(base::Sys.setenv, args = args)
[13:21:40.227]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:40.227]             }
[13:21:40.227]             else {
[13:21:40.227]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:40.227]             }
[13:21:40.227]             {
[13:21:40.227]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:40.227]                   0L) {
[13:21:40.227]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:40.227]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:40.227]                   base::options(opts)
[13:21:40.227]                 }
[13:21:40.227]                 {
[13:21:40.227]                   {
[13:21:40.227]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:40.227]                     NULL
[13:21:40.227]                   }
[13:21:40.227]                   options(future.plan = NULL)
[13:21:40.227]                   if (is.na(NA_character_)) 
[13:21:40.227]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:40.227]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:40.227]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:40.227]                     envir = parent.frame()) 
[13:21:40.227]                   {
[13:21:40.227]                     default_workers <- missing(workers)
[13:21:40.227]                     if (is.function(workers)) 
[13:21:40.227]                       workers <- workers()
[13:21:40.227]                     workers <- structure(as.integer(workers), 
[13:21:40.227]                       class = class(workers))
[13:21:40.227]                     stop_if_not(is.finite(workers), workers >= 
[13:21:40.227]                       1L)
[13:21:40.227]                     if ((workers == 1L && !inherits(workers, 
[13:21:40.227]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:40.227]                       if (default_workers) 
[13:21:40.227]                         supportsMulticore(warn = TRUE)
[13:21:40.227]                       return(sequential(..., envir = envir))
[13:21:40.227]                     }
[13:21:40.227]                     oopts <- options(mc.cores = workers)
[13:21:40.227]                     on.exit(options(oopts))
[13:21:40.227]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:40.227]                       envir = envir)
[13:21:40.227]                     if (!future$lazy) 
[13:21:40.227]                       future <- run(future)
[13:21:40.227]                     invisible(future)
[13:21:40.227]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:40.227]                 }
[13:21:40.227]             }
[13:21:40.227]         }
[13:21:40.227]     })
[13:21:40.227]     if (TRUE) {
[13:21:40.227]         base::sink(type = "output", split = FALSE)
[13:21:40.227]         if (TRUE) {
[13:21:40.227]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:40.227]         }
[13:21:40.227]         else {
[13:21:40.227]             ...future.result["stdout"] <- base::list(NULL)
[13:21:40.227]         }
[13:21:40.227]         base::close(...future.stdout)
[13:21:40.227]         ...future.stdout <- NULL
[13:21:40.227]     }
[13:21:40.227]     ...future.result$conditions <- ...future.conditions
[13:21:40.227]     ...future.result$finished <- base::Sys.time()
[13:21:40.227]     ...future.result
[13:21:40.227] }
[13:21:40.230] requestCore(): workers = 2
[13:21:40.231] Poll #1 (0): usedCores() = 2, workers = 2
[13:21:40.264] MulticoreFuture started
[13:21:40.265] - Launch lazy future ... done
[13:21:40.265] run() for ‘MulticoreFuture’ ... done
[13:21:40.266] plan(): Setting new future strategy stack:
[13:21:40.266] List of future strategies:
[13:21:40.266] 1. sequential:
[13:21:40.266]    - args: function (..., envir = parent.frame())
[13:21:40.266]    - tweaked: FALSE
[13:21:40.266]    - call: NULL
[13:21:40.267] plan(): nbrOfWorkers() = 1
[13:21:40.269] plan(): Setting new future strategy stack:
[13:21:40.269] List of future strategies:
[13:21:40.269] 1. multicore:
[13:21:40.269]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:40.269]    - tweaked: FALSE
[13:21:40.269]    - call: plan(strategy)
[13:21:40.275] plan(): nbrOfWorkers() = 2
[13:21:40.275] Future #1
[13:21:40.276]  length: 2 (resolved future 1)
[13:21:40.276] Future #2
[13:21:40.276]  length: 1 (resolved future 2)
[13:21:40.276]  length: 0 (resolved future 3)
[13:21:40.277] resolve() on list ... DONE
[13:21:40.277] getGlobalsAndPackages() ...
[13:21:40.277] Searching for globals...
[13:21:40.278] 
[13:21:40.278] Searching for globals ... DONE
[13:21:40.278] - globals: [0] <none>
[13:21:40.279] getGlobalsAndPackages() ... DONE
[13:21:40.279] getGlobalsAndPackages() ...
[13:21:40.279] Searching for globals...
[13:21:40.280] 
[13:21:40.280] Searching for globals ... DONE
[13:21:40.280] - globals: [0] <none>
[13:21:40.280] getGlobalsAndPackages() ... DONE
[13:21:40.280] resolve() on list ...
[13:21:40.281]  recursive: 0
[13:21:40.281]  length: 3
[13:21:40.281]  elements: ‘a’, ‘b’, ‘’
[13:21:40.281] run() for ‘Future’ ...
[13:21:40.281] - state: ‘created’
[13:21:40.282] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:40.286] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:40.286] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:40.286]   - Field: ‘label’
[13:21:40.287]   - Field: ‘local’
[13:21:40.287]   - Field: ‘owner’
[13:21:40.287]   - Field: ‘envir’
[13:21:40.287]   - Field: ‘workers’
[13:21:40.287]   - Field: ‘packages’
[13:21:40.287]   - Field: ‘gc’
[13:21:40.288]   - Field: ‘job’
[13:21:40.288]   - Field: ‘conditions’
[13:21:40.288]   - Field: ‘expr’
[13:21:40.288]   - Field: ‘uuid’
[13:21:40.288]   - Field: ‘seed’
[13:21:40.288]   - Field: ‘version’
[13:21:40.289]   - Field: ‘result’
[13:21:40.289]   - Field: ‘asynchronous’
[13:21:40.289]   - Field: ‘calls’
[13:21:40.289]   - Field: ‘globals’
[13:21:40.289]   - Field: ‘stdout’
[13:21:40.289]   - Field: ‘earlySignal’
[13:21:40.290]   - Field: ‘lazy’
[13:21:40.290]   - Field: ‘state’
[13:21:40.290] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:40.290] - Launch lazy future ...
[13:21:40.290] Packages needed by the future expression (n = 0): <none>
[13:21:40.291] Packages needed by future strategies (n = 0): <none>
[13:21:40.291] {
[13:21:40.291]     {
[13:21:40.291]         {
[13:21:40.291]             ...future.startTime <- base::Sys.time()
[13:21:40.291]             {
[13:21:40.291]                 {
[13:21:40.291]                   {
[13:21:40.291]                     {
[13:21:40.291]                       base::local({
[13:21:40.291]                         has_future <- base::requireNamespace("future", 
[13:21:40.291]                           quietly = TRUE)
[13:21:40.291]                         if (has_future) {
[13:21:40.291]                           ns <- base::getNamespace("future")
[13:21:40.291]                           version <- ns[[".package"]][["version"]]
[13:21:40.291]                           if (is.null(version)) 
[13:21:40.291]                             version <- utils::packageVersion("future")
[13:21:40.291]                         }
[13:21:40.291]                         else {
[13:21:40.291]                           version <- NULL
[13:21:40.291]                         }
[13:21:40.291]                         if (!has_future || version < "1.8.0") {
[13:21:40.291]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:40.291]                             "", base::R.version$version.string), 
[13:21:40.291]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:40.291]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:40.291]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:40.291]                               "release", "version")], collapse = " "), 
[13:21:40.291]                             hostname = base::Sys.info()[["nodename"]])
[13:21:40.291]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:40.291]                             info)
[13:21:40.291]                           info <- base::paste(info, collapse = "; ")
[13:21:40.291]                           if (!has_future) {
[13:21:40.291]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:40.291]                               info)
[13:21:40.291]                           }
[13:21:40.291]                           else {
[13:21:40.291]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:40.291]                               info, version)
[13:21:40.291]                           }
[13:21:40.291]                           base::stop(msg)
[13:21:40.291]                         }
[13:21:40.291]                       })
[13:21:40.291]                     }
[13:21:40.291]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:40.291]                     base::options(mc.cores = 1L)
[13:21:40.291]                   }
[13:21:40.291]                   options(future.plan = NULL)
[13:21:40.291]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:40.291]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:40.291]                 }
[13:21:40.291]                 ...future.workdir <- getwd()
[13:21:40.291]             }
[13:21:40.291]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:40.291]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:40.291]         }
[13:21:40.291]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:40.291]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:40.291]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:40.291]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:40.291]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:40.291]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:40.291]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:40.291]             base::names(...future.oldOptions))
[13:21:40.291]     }
[13:21:40.291]     if (FALSE) {
[13:21:40.291]     }
[13:21:40.291]     else {
[13:21:40.291]         if (TRUE) {
[13:21:40.291]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:40.291]                 open = "w")
[13:21:40.291]         }
[13:21:40.291]         else {
[13:21:40.291]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:40.291]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:40.291]         }
[13:21:40.291]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:40.291]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:40.291]             base::sink(type = "output", split = FALSE)
[13:21:40.291]             base::close(...future.stdout)
[13:21:40.291]         }, add = TRUE)
[13:21:40.291]     }
[13:21:40.291]     ...future.frame <- base::sys.nframe()
[13:21:40.291]     ...future.conditions <- base::list()
[13:21:40.291]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:40.291]     if (FALSE) {
[13:21:40.291]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:40.291]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:40.291]     }
[13:21:40.291]     ...future.result <- base::tryCatch({
[13:21:40.291]         base::withCallingHandlers({
[13:21:40.291]             ...future.value <- base::withVisible(base::local({
[13:21:40.291]                 withCallingHandlers({
[13:21:40.291]                   1
[13:21:40.291]                 }, immediateCondition = function(cond) {
[13:21:40.291]                   save_rds <- function (object, pathname, ...) 
[13:21:40.291]                   {
[13:21:40.291]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:40.291]                     if (file_test("-f", pathname_tmp)) {
[13:21:40.291]                       fi_tmp <- file.info(pathname_tmp)
[13:21:40.291]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:40.291]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:40.291]                         fi_tmp[["mtime"]])
[13:21:40.291]                     }
[13:21:40.291]                     tryCatch({
[13:21:40.291]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:40.291]                     }, error = function(ex) {
[13:21:40.291]                       msg <- conditionMessage(ex)
[13:21:40.291]                       fi_tmp <- file.info(pathname_tmp)
[13:21:40.291]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:40.291]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:40.291]                         fi_tmp[["mtime"]], msg)
[13:21:40.291]                       ex$message <- msg
[13:21:40.291]                       stop(ex)
[13:21:40.291]                     })
[13:21:40.291]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:40.291]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:40.291]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:40.291]                       fi_tmp <- file.info(pathname_tmp)
[13:21:40.291]                       fi <- file.info(pathname)
[13:21:40.291]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:40.291]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:40.291]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:40.291]                         fi[["size"]], fi[["mtime"]])
[13:21:40.291]                       stop(msg)
[13:21:40.291]                     }
[13:21:40.291]                     invisible(pathname)
[13:21:40.291]                   }
[13:21:40.291]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:40.291]                     rootPath = tempdir()) 
[13:21:40.291]                   {
[13:21:40.291]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:40.291]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:40.291]                       tmpdir = path, fileext = ".rds")
[13:21:40.291]                     save_rds(obj, file)
[13:21:40.291]                   }
[13:21:40.291]                   saveImmediateCondition(cond, path = "/tmp/RtmpRIPAyw/.future/immediateConditions")
[13:21:40.291]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.291]                   {
[13:21:40.291]                     inherits <- base::inherits
[13:21:40.291]                     invokeRestart <- base::invokeRestart
[13:21:40.291]                     is.null <- base::is.null
[13:21:40.291]                     muffled <- FALSE
[13:21:40.291]                     if (inherits(cond, "message")) {
[13:21:40.291]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:40.291]                       if (muffled) 
[13:21:40.291]                         invokeRestart("muffleMessage")
[13:21:40.291]                     }
[13:21:40.291]                     else if (inherits(cond, "warning")) {
[13:21:40.291]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:40.291]                       if (muffled) 
[13:21:40.291]                         invokeRestart("muffleWarning")
[13:21:40.291]                     }
[13:21:40.291]                     else if (inherits(cond, "condition")) {
[13:21:40.291]                       if (!is.null(pattern)) {
[13:21:40.291]                         computeRestarts <- base::computeRestarts
[13:21:40.291]                         grepl <- base::grepl
[13:21:40.291]                         restarts <- computeRestarts(cond)
[13:21:40.291]                         for (restart in restarts) {
[13:21:40.291]                           name <- restart$name
[13:21:40.291]                           if (is.null(name)) 
[13:21:40.291]                             next
[13:21:40.291]                           if (!grepl(pattern, name)) 
[13:21:40.291]                             next
[13:21:40.291]                           invokeRestart(restart)
[13:21:40.291]                           muffled <- TRUE
[13:21:40.291]                           break
[13:21:40.291]                         }
[13:21:40.291]                       }
[13:21:40.291]                     }
[13:21:40.291]                     invisible(muffled)
[13:21:40.291]                   }
[13:21:40.291]                   muffleCondition(cond)
[13:21:40.291]                 })
[13:21:40.291]             }))
[13:21:40.291]             future::FutureResult(value = ...future.value$value, 
[13:21:40.291]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:40.291]                   ...future.rng), globalenv = if (FALSE) 
[13:21:40.291]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:40.291]                     ...future.globalenv.names))
[13:21:40.291]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:40.291]         }, condition = base::local({
[13:21:40.291]             c <- base::c
[13:21:40.291]             inherits <- base::inherits
[13:21:40.291]             invokeRestart <- base::invokeRestart
[13:21:40.291]             length <- base::length
[13:21:40.291]             list <- base::list
[13:21:40.291]             seq.int <- base::seq.int
[13:21:40.291]             signalCondition <- base::signalCondition
[13:21:40.291]             sys.calls <- base::sys.calls
[13:21:40.291]             `[[` <- base::`[[`
[13:21:40.291]             `+` <- base::`+`
[13:21:40.291]             `<<-` <- base::`<<-`
[13:21:40.291]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:40.291]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:40.291]                   3L)]
[13:21:40.291]             }
[13:21:40.291]             function(cond) {
[13:21:40.291]                 is_error <- inherits(cond, "error")
[13:21:40.291]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:40.291]                   NULL)
[13:21:40.291]                 if (is_error) {
[13:21:40.291]                   sessionInformation <- function() {
[13:21:40.291]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:40.291]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:40.291]                       search = base::search(), system = base::Sys.info())
[13:21:40.291]                   }
[13:21:40.291]                   ...future.conditions[[length(...future.conditions) + 
[13:21:40.291]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:40.291]                     cond$call), session = sessionInformation(), 
[13:21:40.291]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:40.291]                   signalCondition(cond)
[13:21:40.291]                 }
[13:21:40.291]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:40.291]                 "immediateCondition"))) {
[13:21:40.291]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:40.291]                   ...future.conditions[[length(...future.conditions) + 
[13:21:40.291]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:40.291]                   if (TRUE && !signal) {
[13:21:40.291]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.291]                     {
[13:21:40.291]                       inherits <- base::inherits
[13:21:40.291]                       invokeRestart <- base::invokeRestart
[13:21:40.291]                       is.null <- base::is.null
[13:21:40.291]                       muffled <- FALSE
[13:21:40.291]                       if (inherits(cond, "message")) {
[13:21:40.291]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:40.291]                         if (muffled) 
[13:21:40.291]                           invokeRestart("muffleMessage")
[13:21:40.291]                       }
[13:21:40.291]                       else if (inherits(cond, "warning")) {
[13:21:40.291]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:40.291]                         if (muffled) 
[13:21:40.291]                           invokeRestart("muffleWarning")
[13:21:40.291]                       }
[13:21:40.291]                       else if (inherits(cond, "condition")) {
[13:21:40.291]                         if (!is.null(pattern)) {
[13:21:40.291]                           computeRestarts <- base::computeRestarts
[13:21:40.291]                           grepl <- base::grepl
[13:21:40.291]                           restarts <- computeRestarts(cond)
[13:21:40.291]                           for (restart in restarts) {
[13:21:40.291]                             name <- restart$name
[13:21:40.291]                             if (is.null(name)) 
[13:21:40.291]                               next
[13:21:40.291]                             if (!grepl(pattern, name)) 
[13:21:40.291]                               next
[13:21:40.291]                             invokeRestart(restart)
[13:21:40.291]                             muffled <- TRUE
[13:21:40.291]                             break
[13:21:40.291]                           }
[13:21:40.291]                         }
[13:21:40.291]                       }
[13:21:40.291]                       invisible(muffled)
[13:21:40.291]                     }
[13:21:40.291]                     muffleCondition(cond, pattern = "^muffle")
[13:21:40.291]                   }
[13:21:40.291]                 }
[13:21:40.291]                 else {
[13:21:40.291]                   if (TRUE) {
[13:21:40.291]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.291]                     {
[13:21:40.291]                       inherits <- base::inherits
[13:21:40.291]                       invokeRestart <- base::invokeRestart
[13:21:40.291]                       is.null <- base::is.null
[13:21:40.291]                       muffled <- FALSE
[13:21:40.291]                       if (inherits(cond, "message")) {
[13:21:40.291]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:40.291]                         if (muffled) 
[13:21:40.291]                           invokeRestart("muffleMessage")
[13:21:40.291]                       }
[13:21:40.291]                       else if (inherits(cond, "warning")) {
[13:21:40.291]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:40.291]                         if (muffled) 
[13:21:40.291]                           invokeRestart("muffleWarning")
[13:21:40.291]                       }
[13:21:40.291]                       else if (inherits(cond, "condition")) {
[13:21:40.291]                         if (!is.null(pattern)) {
[13:21:40.291]                           computeRestarts <- base::computeRestarts
[13:21:40.291]                           grepl <- base::grepl
[13:21:40.291]                           restarts <- computeRestarts(cond)
[13:21:40.291]                           for (restart in restarts) {
[13:21:40.291]                             name <- restart$name
[13:21:40.291]                             if (is.null(name)) 
[13:21:40.291]                               next
[13:21:40.291]                             if (!grepl(pattern, name)) 
[13:21:40.291]                               next
[13:21:40.291]                             invokeRestart(restart)
[13:21:40.291]                             muffled <- TRUE
[13:21:40.291]                             break
[13:21:40.291]                           }
[13:21:40.291]                         }
[13:21:40.291]                       }
[13:21:40.291]                       invisible(muffled)
[13:21:40.291]                     }
[13:21:40.291]                     muffleCondition(cond, pattern = "^muffle")
[13:21:40.291]                   }
[13:21:40.291]                 }
[13:21:40.291]             }
[13:21:40.291]         }))
[13:21:40.291]     }, error = function(ex) {
[13:21:40.291]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:40.291]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:40.291]                 ...future.rng), started = ...future.startTime, 
[13:21:40.291]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:40.291]             version = "1.8"), class = "FutureResult")
[13:21:40.291]     }, finally = {
[13:21:40.291]         if (!identical(...future.workdir, getwd())) 
[13:21:40.291]             setwd(...future.workdir)
[13:21:40.291]         {
[13:21:40.291]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:40.291]                 ...future.oldOptions$nwarnings <- NULL
[13:21:40.291]             }
[13:21:40.291]             base::options(...future.oldOptions)
[13:21:40.291]             if (.Platform$OS.type == "windows") {
[13:21:40.291]                 old_names <- names(...future.oldEnvVars)
[13:21:40.291]                 envs <- base::Sys.getenv()
[13:21:40.291]                 names <- names(envs)
[13:21:40.291]                 common <- intersect(names, old_names)
[13:21:40.291]                 added <- setdiff(names, old_names)
[13:21:40.291]                 removed <- setdiff(old_names, names)
[13:21:40.291]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:40.291]                   envs[common]]
[13:21:40.291]                 NAMES <- toupper(changed)
[13:21:40.291]                 args <- list()
[13:21:40.291]                 for (kk in seq_along(NAMES)) {
[13:21:40.291]                   name <- changed[[kk]]
[13:21:40.291]                   NAME <- NAMES[[kk]]
[13:21:40.291]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.291]                     next
[13:21:40.291]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:40.291]                 }
[13:21:40.291]                 NAMES <- toupper(added)
[13:21:40.291]                 for (kk in seq_along(NAMES)) {
[13:21:40.291]                   name <- added[[kk]]
[13:21:40.291]                   NAME <- NAMES[[kk]]
[13:21:40.291]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.291]                     next
[13:21:40.291]                   args[[name]] <- ""
[13:21:40.291]                 }
[13:21:40.291]                 NAMES <- toupper(removed)
[13:21:40.291]                 for (kk in seq_along(NAMES)) {
[13:21:40.291]                   name <- removed[[kk]]
[13:21:40.291]                   NAME <- NAMES[[kk]]
[13:21:40.291]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.291]                     next
[13:21:40.291]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:40.291]                 }
[13:21:40.291]                 if (length(args) > 0) 
[13:21:40.291]                   base::do.call(base::Sys.setenv, args = args)
[13:21:40.291]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:40.291]             }
[13:21:40.291]             else {
[13:21:40.291]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:40.291]             }
[13:21:40.291]             {
[13:21:40.291]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:40.291]                   0L) {
[13:21:40.291]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:40.291]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:40.291]                   base::options(opts)
[13:21:40.291]                 }
[13:21:40.291]                 {
[13:21:40.291]                   {
[13:21:40.291]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:40.291]                     NULL
[13:21:40.291]                   }
[13:21:40.291]                   options(future.plan = NULL)
[13:21:40.291]                   if (is.na(NA_character_)) 
[13:21:40.291]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:40.291]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:40.291]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:40.291]                     envir = parent.frame()) 
[13:21:40.291]                   {
[13:21:40.291]                     default_workers <- missing(workers)
[13:21:40.291]                     if (is.function(workers)) 
[13:21:40.291]                       workers <- workers()
[13:21:40.291]                     workers <- structure(as.integer(workers), 
[13:21:40.291]                       class = class(workers))
[13:21:40.291]                     stop_if_not(is.finite(workers), workers >= 
[13:21:40.291]                       1L)
[13:21:40.291]                     if ((workers == 1L && !inherits(workers, 
[13:21:40.291]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:40.291]                       if (default_workers) 
[13:21:40.291]                         supportsMulticore(warn = TRUE)
[13:21:40.291]                       return(sequential(..., envir = envir))
[13:21:40.291]                     }
[13:21:40.291]                     oopts <- options(mc.cores = workers)
[13:21:40.291]                     on.exit(options(oopts))
[13:21:40.291]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:40.291]                       envir = envir)
[13:21:40.291]                     if (!future$lazy) 
[13:21:40.291]                       future <- run(future)
[13:21:40.291]                     invisible(future)
[13:21:40.291]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:40.291]                 }
[13:21:40.291]             }
[13:21:40.291]         }
[13:21:40.291]     })
[13:21:40.291]     if (TRUE) {
[13:21:40.291]         base::sink(type = "output", split = FALSE)
[13:21:40.291]         if (TRUE) {
[13:21:40.291]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:40.291]         }
[13:21:40.291]         else {
[13:21:40.291]             ...future.result["stdout"] <- base::list(NULL)
[13:21:40.291]         }
[13:21:40.291]         base::close(...future.stdout)
[13:21:40.291]         ...future.stdout <- NULL
[13:21:40.291]     }
[13:21:40.291]     ...future.result$conditions <- ...future.conditions
[13:21:40.291]     ...future.result$finished <- base::Sys.time()
[13:21:40.291]     ...future.result
[13:21:40.291] }
[13:21:40.295] requestCore(): workers = 2
[13:21:40.296] Poll #1 (0): usedCores() = 2, workers = 2
[13:21:40.310] MulticoreFuture started
[13:21:40.310] - Launch lazy future ... done
[13:21:40.311] run() for ‘MulticoreFuture’ ... done
[13:21:40.311] plan(): Setting new future strategy stack:
[13:21:40.311] List of future strategies:
[13:21:40.311] 1. sequential:
[13:21:40.311]    - args: function (..., envir = parent.frame())
[13:21:40.311]    - tweaked: FALSE
[13:21:40.311]    - call: NULL
[13:21:40.312] plan(): nbrOfWorkers() = 1
[13:21:40.314] plan(): Setting new future strategy stack:
[13:21:40.315] List of future strategies:
[13:21:40.315] 1. multicore:
[13:21:40.315]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:40.315]    - tweaked: FALSE
[13:21:40.315]    - call: plan(strategy)
[13:21:40.320] plan(): nbrOfWorkers() = 2
[13:21:40.320] Future #1
[13:21:40.321]  length: 2 (resolved future 1)
[13:21:40.321] run() for ‘Future’ ...
[13:21:40.321] - state: ‘created’
[13:21:40.321] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:40.326] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:40.326] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:40.327]   - Field: ‘label’
[13:21:40.327]   - Field: ‘local’
[13:21:40.327]   - Field: ‘owner’
[13:21:40.327]   - Field: ‘envir’
[13:21:40.327]   - Field: ‘workers’
[13:21:40.327]   - Field: ‘packages’
[13:21:40.327]   - Field: ‘gc’
[13:21:40.328]   - Field: ‘job’
[13:21:40.328]   - Field: ‘conditions’
[13:21:40.328]   - Field: ‘expr’
[13:21:40.328]   - Field: ‘uuid’
[13:21:40.328]   - Field: ‘seed’
[13:21:40.328]   - Field: ‘version’
[13:21:40.329]   - Field: ‘result’
[13:21:40.329]   - Field: ‘asynchronous’
[13:21:40.329]   - Field: ‘calls’
[13:21:40.329]   - Field: ‘globals’
[13:21:40.329]   - Field: ‘stdout’
[13:21:40.329]   - Field: ‘earlySignal’
[13:21:40.330]   - Field: ‘lazy’
[13:21:40.330]   - Field: ‘state’
[13:21:40.330] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:40.330] - Launch lazy future ...
[13:21:40.330] Packages needed by the future expression (n = 0): <none>
[13:21:40.331] Packages needed by future strategies (n = 0): <none>
[13:21:40.331] {
[13:21:40.331]     {
[13:21:40.331]         {
[13:21:40.331]             ...future.startTime <- base::Sys.time()
[13:21:40.331]             {
[13:21:40.331]                 {
[13:21:40.331]                   {
[13:21:40.331]                     {
[13:21:40.331]                       base::local({
[13:21:40.331]                         has_future <- base::requireNamespace("future", 
[13:21:40.331]                           quietly = TRUE)
[13:21:40.331]                         if (has_future) {
[13:21:40.331]                           ns <- base::getNamespace("future")
[13:21:40.331]                           version <- ns[[".package"]][["version"]]
[13:21:40.331]                           if (is.null(version)) 
[13:21:40.331]                             version <- utils::packageVersion("future")
[13:21:40.331]                         }
[13:21:40.331]                         else {
[13:21:40.331]                           version <- NULL
[13:21:40.331]                         }
[13:21:40.331]                         if (!has_future || version < "1.8.0") {
[13:21:40.331]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:40.331]                             "", base::R.version$version.string), 
[13:21:40.331]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:40.331]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:40.331]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:40.331]                               "release", "version")], collapse = " "), 
[13:21:40.331]                             hostname = base::Sys.info()[["nodename"]])
[13:21:40.331]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:40.331]                             info)
[13:21:40.331]                           info <- base::paste(info, collapse = "; ")
[13:21:40.331]                           if (!has_future) {
[13:21:40.331]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:40.331]                               info)
[13:21:40.331]                           }
[13:21:40.331]                           else {
[13:21:40.331]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:40.331]                               info, version)
[13:21:40.331]                           }
[13:21:40.331]                           base::stop(msg)
[13:21:40.331]                         }
[13:21:40.331]                       })
[13:21:40.331]                     }
[13:21:40.331]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:40.331]                     base::options(mc.cores = 1L)
[13:21:40.331]                   }
[13:21:40.331]                   options(future.plan = NULL)
[13:21:40.331]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:40.331]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:40.331]                 }
[13:21:40.331]                 ...future.workdir <- getwd()
[13:21:40.331]             }
[13:21:40.331]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:40.331]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:40.331]         }
[13:21:40.331]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:40.331]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:40.331]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:40.331]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:40.331]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:40.331]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:40.331]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:40.331]             base::names(...future.oldOptions))
[13:21:40.331]     }
[13:21:40.331]     if (FALSE) {
[13:21:40.331]     }
[13:21:40.331]     else {
[13:21:40.331]         if (TRUE) {
[13:21:40.331]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:40.331]                 open = "w")
[13:21:40.331]         }
[13:21:40.331]         else {
[13:21:40.331]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:40.331]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:40.331]         }
[13:21:40.331]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:40.331]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:40.331]             base::sink(type = "output", split = FALSE)
[13:21:40.331]             base::close(...future.stdout)
[13:21:40.331]         }, add = TRUE)
[13:21:40.331]     }
[13:21:40.331]     ...future.frame <- base::sys.nframe()
[13:21:40.331]     ...future.conditions <- base::list()
[13:21:40.331]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:40.331]     if (FALSE) {
[13:21:40.331]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:40.331]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:40.331]     }
[13:21:40.331]     ...future.result <- base::tryCatch({
[13:21:40.331]         base::withCallingHandlers({
[13:21:40.331]             ...future.value <- base::withVisible(base::local({
[13:21:40.331]                 withCallingHandlers({
[13:21:40.331]                   2
[13:21:40.331]                 }, immediateCondition = function(cond) {
[13:21:40.331]                   save_rds <- function (object, pathname, ...) 
[13:21:40.331]                   {
[13:21:40.331]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:40.331]                     if (file_test("-f", pathname_tmp)) {
[13:21:40.331]                       fi_tmp <- file.info(pathname_tmp)
[13:21:40.331]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:40.331]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:40.331]                         fi_tmp[["mtime"]])
[13:21:40.331]                     }
[13:21:40.331]                     tryCatch({
[13:21:40.331]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:40.331]                     }, error = function(ex) {
[13:21:40.331]                       msg <- conditionMessage(ex)
[13:21:40.331]                       fi_tmp <- file.info(pathname_tmp)
[13:21:40.331]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:40.331]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:40.331]                         fi_tmp[["mtime"]], msg)
[13:21:40.331]                       ex$message <- msg
[13:21:40.331]                       stop(ex)
[13:21:40.331]                     })
[13:21:40.331]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:40.331]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:40.331]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:40.331]                       fi_tmp <- file.info(pathname_tmp)
[13:21:40.331]                       fi <- file.info(pathname)
[13:21:40.331]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:40.331]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:40.331]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:40.331]                         fi[["size"]], fi[["mtime"]])
[13:21:40.331]                       stop(msg)
[13:21:40.331]                     }
[13:21:40.331]                     invisible(pathname)
[13:21:40.331]                   }
[13:21:40.331]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:40.331]                     rootPath = tempdir()) 
[13:21:40.331]                   {
[13:21:40.331]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:40.331]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:40.331]                       tmpdir = path, fileext = ".rds")
[13:21:40.331]                     save_rds(obj, file)
[13:21:40.331]                   }
[13:21:40.331]                   saveImmediateCondition(cond, path = "/tmp/RtmpRIPAyw/.future/immediateConditions")
[13:21:40.331]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.331]                   {
[13:21:40.331]                     inherits <- base::inherits
[13:21:40.331]                     invokeRestart <- base::invokeRestart
[13:21:40.331]                     is.null <- base::is.null
[13:21:40.331]                     muffled <- FALSE
[13:21:40.331]                     if (inherits(cond, "message")) {
[13:21:40.331]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:40.331]                       if (muffled) 
[13:21:40.331]                         invokeRestart("muffleMessage")
[13:21:40.331]                     }
[13:21:40.331]                     else if (inherits(cond, "warning")) {
[13:21:40.331]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:40.331]                       if (muffled) 
[13:21:40.331]                         invokeRestart("muffleWarning")
[13:21:40.331]                     }
[13:21:40.331]                     else if (inherits(cond, "condition")) {
[13:21:40.331]                       if (!is.null(pattern)) {
[13:21:40.331]                         computeRestarts <- base::computeRestarts
[13:21:40.331]                         grepl <- base::grepl
[13:21:40.331]                         restarts <- computeRestarts(cond)
[13:21:40.331]                         for (restart in restarts) {
[13:21:40.331]                           name <- restart$name
[13:21:40.331]                           if (is.null(name)) 
[13:21:40.331]                             next
[13:21:40.331]                           if (!grepl(pattern, name)) 
[13:21:40.331]                             next
[13:21:40.331]                           invokeRestart(restart)
[13:21:40.331]                           muffled <- TRUE
[13:21:40.331]                           break
[13:21:40.331]                         }
[13:21:40.331]                       }
[13:21:40.331]                     }
[13:21:40.331]                     invisible(muffled)
[13:21:40.331]                   }
[13:21:40.331]                   muffleCondition(cond)
[13:21:40.331]                 })
[13:21:40.331]             }))
[13:21:40.331]             future::FutureResult(value = ...future.value$value, 
[13:21:40.331]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:40.331]                   ...future.rng), globalenv = if (FALSE) 
[13:21:40.331]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:40.331]                     ...future.globalenv.names))
[13:21:40.331]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:40.331]         }, condition = base::local({
[13:21:40.331]             c <- base::c
[13:21:40.331]             inherits <- base::inherits
[13:21:40.331]             invokeRestart <- base::invokeRestart
[13:21:40.331]             length <- base::length
[13:21:40.331]             list <- base::list
[13:21:40.331]             seq.int <- base::seq.int
[13:21:40.331]             signalCondition <- base::signalCondition
[13:21:40.331]             sys.calls <- base::sys.calls
[13:21:40.331]             `[[` <- base::`[[`
[13:21:40.331]             `+` <- base::`+`
[13:21:40.331]             `<<-` <- base::`<<-`
[13:21:40.331]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:40.331]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:40.331]                   3L)]
[13:21:40.331]             }
[13:21:40.331]             function(cond) {
[13:21:40.331]                 is_error <- inherits(cond, "error")
[13:21:40.331]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:40.331]                   NULL)
[13:21:40.331]                 if (is_error) {
[13:21:40.331]                   sessionInformation <- function() {
[13:21:40.331]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:40.331]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:40.331]                       search = base::search(), system = base::Sys.info())
[13:21:40.331]                   }
[13:21:40.331]                   ...future.conditions[[length(...future.conditions) + 
[13:21:40.331]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:40.331]                     cond$call), session = sessionInformation(), 
[13:21:40.331]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:40.331]                   signalCondition(cond)
[13:21:40.331]                 }
[13:21:40.331]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:40.331]                 "immediateCondition"))) {
[13:21:40.331]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:40.331]                   ...future.conditions[[length(...future.conditions) + 
[13:21:40.331]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:40.331]                   if (TRUE && !signal) {
[13:21:40.331]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.331]                     {
[13:21:40.331]                       inherits <- base::inherits
[13:21:40.331]                       invokeRestart <- base::invokeRestart
[13:21:40.331]                       is.null <- base::is.null
[13:21:40.331]                       muffled <- FALSE
[13:21:40.331]                       if (inherits(cond, "message")) {
[13:21:40.331]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:40.331]                         if (muffled) 
[13:21:40.331]                           invokeRestart("muffleMessage")
[13:21:40.331]                       }
[13:21:40.331]                       else if (inherits(cond, "warning")) {
[13:21:40.331]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:40.331]                         if (muffled) 
[13:21:40.331]                           invokeRestart("muffleWarning")
[13:21:40.331]                       }
[13:21:40.331]                       else if (inherits(cond, "condition")) {
[13:21:40.331]                         if (!is.null(pattern)) {
[13:21:40.331]                           computeRestarts <- base::computeRestarts
[13:21:40.331]                           grepl <- base::grepl
[13:21:40.331]                           restarts <- computeRestarts(cond)
[13:21:40.331]                           for (restart in restarts) {
[13:21:40.331]                             name <- restart$name
[13:21:40.331]                             if (is.null(name)) 
[13:21:40.331]                               next
[13:21:40.331]                             if (!grepl(pattern, name)) 
[13:21:40.331]                               next
[13:21:40.331]                             invokeRestart(restart)
[13:21:40.331]                             muffled <- TRUE
[13:21:40.331]                             break
[13:21:40.331]                           }
[13:21:40.331]                         }
[13:21:40.331]                       }
[13:21:40.331]                       invisible(muffled)
[13:21:40.331]                     }
[13:21:40.331]                     muffleCondition(cond, pattern = "^muffle")
[13:21:40.331]                   }
[13:21:40.331]                 }
[13:21:40.331]                 else {
[13:21:40.331]                   if (TRUE) {
[13:21:40.331]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.331]                     {
[13:21:40.331]                       inherits <- base::inherits
[13:21:40.331]                       invokeRestart <- base::invokeRestart
[13:21:40.331]                       is.null <- base::is.null
[13:21:40.331]                       muffled <- FALSE
[13:21:40.331]                       if (inherits(cond, "message")) {
[13:21:40.331]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:40.331]                         if (muffled) 
[13:21:40.331]                           invokeRestart("muffleMessage")
[13:21:40.331]                       }
[13:21:40.331]                       else if (inherits(cond, "warning")) {
[13:21:40.331]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:40.331]                         if (muffled) 
[13:21:40.331]                           invokeRestart("muffleWarning")
[13:21:40.331]                       }
[13:21:40.331]                       else if (inherits(cond, "condition")) {
[13:21:40.331]                         if (!is.null(pattern)) {
[13:21:40.331]                           computeRestarts <- base::computeRestarts
[13:21:40.331]                           grepl <- base::grepl
[13:21:40.331]                           restarts <- computeRestarts(cond)
[13:21:40.331]                           for (restart in restarts) {
[13:21:40.331]                             name <- restart$name
[13:21:40.331]                             if (is.null(name)) 
[13:21:40.331]                               next
[13:21:40.331]                             if (!grepl(pattern, name)) 
[13:21:40.331]                               next
[13:21:40.331]                             invokeRestart(restart)
[13:21:40.331]                             muffled <- TRUE
[13:21:40.331]                             break
[13:21:40.331]                           }
[13:21:40.331]                         }
[13:21:40.331]                       }
[13:21:40.331]                       invisible(muffled)
[13:21:40.331]                     }
[13:21:40.331]                     muffleCondition(cond, pattern = "^muffle")
[13:21:40.331]                   }
[13:21:40.331]                 }
[13:21:40.331]             }
[13:21:40.331]         }))
[13:21:40.331]     }, error = function(ex) {
[13:21:40.331]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:40.331]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:40.331]                 ...future.rng), started = ...future.startTime, 
[13:21:40.331]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:40.331]             version = "1.8"), class = "FutureResult")
[13:21:40.331]     }, finally = {
[13:21:40.331]         if (!identical(...future.workdir, getwd())) 
[13:21:40.331]             setwd(...future.workdir)
[13:21:40.331]         {
[13:21:40.331]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:40.331]                 ...future.oldOptions$nwarnings <- NULL
[13:21:40.331]             }
[13:21:40.331]             base::options(...future.oldOptions)
[13:21:40.331]             if (.Platform$OS.type == "windows") {
[13:21:40.331]                 old_names <- names(...future.oldEnvVars)
[13:21:40.331]                 envs <- base::Sys.getenv()
[13:21:40.331]                 names <- names(envs)
[13:21:40.331]                 common <- intersect(names, old_names)
[13:21:40.331]                 added <- setdiff(names, old_names)
[13:21:40.331]                 removed <- setdiff(old_names, names)
[13:21:40.331]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:40.331]                   envs[common]]
[13:21:40.331]                 NAMES <- toupper(changed)
[13:21:40.331]                 args <- list()
[13:21:40.331]                 for (kk in seq_along(NAMES)) {
[13:21:40.331]                   name <- changed[[kk]]
[13:21:40.331]                   NAME <- NAMES[[kk]]
[13:21:40.331]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.331]                     next
[13:21:40.331]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:40.331]                 }
[13:21:40.331]                 NAMES <- toupper(added)
[13:21:40.331]                 for (kk in seq_along(NAMES)) {
[13:21:40.331]                   name <- added[[kk]]
[13:21:40.331]                   NAME <- NAMES[[kk]]
[13:21:40.331]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.331]                     next
[13:21:40.331]                   args[[name]] <- ""
[13:21:40.331]                 }
[13:21:40.331]                 NAMES <- toupper(removed)
[13:21:40.331]                 for (kk in seq_along(NAMES)) {
[13:21:40.331]                   name <- removed[[kk]]
[13:21:40.331]                   NAME <- NAMES[[kk]]
[13:21:40.331]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.331]                     next
[13:21:40.331]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:40.331]                 }
[13:21:40.331]                 if (length(args) > 0) 
[13:21:40.331]                   base::do.call(base::Sys.setenv, args = args)
[13:21:40.331]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:40.331]             }
[13:21:40.331]             else {
[13:21:40.331]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:40.331]             }
[13:21:40.331]             {
[13:21:40.331]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:40.331]                   0L) {
[13:21:40.331]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:40.331]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:40.331]                   base::options(opts)
[13:21:40.331]                 }
[13:21:40.331]                 {
[13:21:40.331]                   {
[13:21:40.331]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:40.331]                     NULL
[13:21:40.331]                   }
[13:21:40.331]                   options(future.plan = NULL)
[13:21:40.331]                   if (is.na(NA_character_)) 
[13:21:40.331]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:40.331]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:40.331]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:40.331]                     envir = parent.frame()) 
[13:21:40.331]                   {
[13:21:40.331]                     default_workers <- missing(workers)
[13:21:40.331]                     if (is.function(workers)) 
[13:21:40.331]                       workers <- workers()
[13:21:40.331]                     workers <- structure(as.integer(workers), 
[13:21:40.331]                       class = class(workers))
[13:21:40.331]                     stop_if_not(is.finite(workers), workers >= 
[13:21:40.331]                       1L)
[13:21:40.331]                     if ((workers == 1L && !inherits(workers, 
[13:21:40.331]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:40.331]                       if (default_workers) 
[13:21:40.331]                         supportsMulticore(warn = TRUE)
[13:21:40.331]                       return(sequential(..., envir = envir))
[13:21:40.331]                     }
[13:21:40.331]                     oopts <- options(mc.cores = workers)
[13:21:40.331]                     on.exit(options(oopts))
[13:21:40.331]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:40.331]                       envir = envir)
[13:21:40.331]                     if (!future$lazy) 
[13:21:40.331]                       future <- run(future)
[13:21:40.331]                     invisible(future)
[13:21:40.331]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:40.331]                 }
[13:21:40.331]             }
[13:21:40.331]         }
[13:21:40.331]     })
[13:21:40.331]     if (TRUE) {
[13:21:40.331]         base::sink(type = "output", split = FALSE)
[13:21:40.331]         if (TRUE) {
[13:21:40.331]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:40.331]         }
[13:21:40.331]         else {
[13:21:40.331]             ...future.result["stdout"] <- base::list(NULL)
[13:21:40.331]         }
[13:21:40.331]         base::close(...future.stdout)
[13:21:40.331]         ...future.stdout <- NULL
[13:21:40.331]     }
[13:21:40.331]     ...future.result$conditions <- ...future.conditions
[13:21:40.331]     ...future.result$finished <- base::Sys.time()
[13:21:40.331]     ...future.result
[13:21:40.331] }
[13:21:40.335] requestCore(): workers = 2
[13:21:40.335] Poll #1 (0): usedCores() = 2, workers = 2
[13:21:40.349] MulticoreFuture started
[13:21:40.349] - Launch lazy future ... done
[13:21:40.350] run() for ‘MulticoreFuture’ ... done
[13:21:40.350] plan(): Setting new future strategy stack:
[13:21:40.351] List of future strategies:
[13:21:40.351] 1. sequential:
[13:21:40.351]    - args: function (..., envir = parent.frame())
[13:21:40.351]    - tweaked: FALSE
[13:21:40.351]    - call: NULL
[13:21:40.352] plan(): nbrOfWorkers() = 1
[13:21:40.361]  length: 1 (resolved future 3)
[13:21:40.361] plan(): Setting new future strategy stack:
[13:21:40.361] List of future strategies:
[13:21:40.361] 1. multicore:
[13:21:40.361]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:40.361]    - tweaked: FALSE
[13:21:40.361]    - call: plan(strategy)
[13:21:40.369] plan(): nbrOfWorkers() = 2
[13:21:40.371] Future #2
[13:21:40.371]  length: 0 (resolved future 2)
[13:21:40.375] resolve() on list ... DONE
[13:21:40.376] getGlobalsAndPackages() ...
[13:21:40.376] Searching for globals...
[13:21:40.377] 
[13:21:40.378] Searching for globals ... DONE
[13:21:40.378] - globals: [0] <none>
[13:21:40.378] getGlobalsAndPackages() ... DONE
[13:21:40.379] run() for ‘Future’ ...
[13:21:40.379] - state: ‘created’
[13:21:40.380] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:40.385] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:40.385] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:40.385]   - Field: ‘label’
[13:21:40.385]   - Field: ‘local’
[13:21:40.385]   - Field: ‘owner’
[13:21:40.386]   - Field: ‘envir’
[13:21:40.386]   - Field: ‘workers’
[13:21:40.386]   - Field: ‘packages’
[13:21:40.386]   - Field: ‘gc’
[13:21:40.386]   - Field: ‘job’
[13:21:40.386]   - Field: ‘conditions’
[13:21:40.386]   - Field: ‘expr’
[13:21:40.387]   - Field: ‘uuid’
[13:21:40.387]   - Field: ‘seed’
[13:21:40.387]   - Field: ‘version’
[13:21:40.387]   - Field: ‘result’
[13:21:40.387]   - Field: ‘asynchronous’
[13:21:40.387]   - Field: ‘calls’
[13:21:40.388]   - Field: ‘globals’
[13:21:40.388]   - Field: ‘stdout’
[13:21:40.388]   - Field: ‘earlySignal’
[13:21:40.388]   - Field: ‘lazy’
[13:21:40.389]   - Field: ‘state’
[13:21:40.389] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:40.389] - Launch lazy future ...
[13:21:40.389] Packages needed by the future expression (n = 0): <none>
[13:21:40.389] Packages needed by future strategies (n = 0): <none>
[13:21:40.390] {
[13:21:40.390]     {
[13:21:40.390]         {
[13:21:40.390]             ...future.startTime <- base::Sys.time()
[13:21:40.390]             {
[13:21:40.390]                 {
[13:21:40.390]                   {
[13:21:40.390]                     {
[13:21:40.390]                       base::local({
[13:21:40.390]                         has_future <- base::requireNamespace("future", 
[13:21:40.390]                           quietly = TRUE)
[13:21:40.390]                         if (has_future) {
[13:21:40.390]                           ns <- base::getNamespace("future")
[13:21:40.390]                           version <- ns[[".package"]][["version"]]
[13:21:40.390]                           if (is.null(version)) 
[13:21:40.390]                             version <- utils::packageVersion("future")
[13:21:40.390]                         }
[13:21:40.390]                         else {
[13:21:40.390]                           version <- NULL
[13:21:40.390]                         }
[13:21:40.390]                         if (!has_future || version < "1.8.0") {
[13:21:40.390]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:40.390]                             "", base::R.version$version.string), 
[13:21:40.390]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:40.390]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:40.390]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:40.390]                               "release", "version")], collapse = " "), 
[13:21:40.390]                             hostname = base::Sys.info()[["nodename"]])
[13:21:40.390]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:40.390]                             info)
[13:21:40.390]                           info <- base::paste(info, collapse = "; ")
[13:21:40.390]                           if (!has_future) {
[13:21:40.390]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:40.390]                               info)
[13:21:40.390]                           }
[13:21:40.390]                           else {
[13:21:40.390]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:40.390]                               info, version)
[13:21:40.390]                           }
[13:21:40.390]                           base::stop(msg)
[13:21:40.390]                         }
[13:21:40.390]                       })
[13:21:40.390]                     }
[13:21:40.390]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:40.390]                     base::options(mc.cores = 1L)
[13:21:40.390]                   }
[13:21:40.390]                   options(future.plan = NULL)
[13:21:40.390]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:40.390]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:40.390]                 }
[13:21:40.390]                 ...future.workdir <- getwd()
[13:21:40.390]             }
[13:21:40.390]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:40.390]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:40.390]         }
[13:21:40.390]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:40.390]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:40.390]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:40.390]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:40.390]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:40.390]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:40.390]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:40.390]             base::names(...future.oldOptions))
[13:21:40.390]     }
[13:21:40.390]     if (FALSE) {
[13:21:40.390]     }
[13:21:40.390]     else {
[13:21:40.390]         if (TRUE) {
[13:21:40.390]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:40.390]                 open = "w")
[13:21:40.390]         }
[13:21:40.390]         else {
[13:21:40.390]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:40.390]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:40.390]         }
[13:21:40.390]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:40.390]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:40.390]             base::sink(type = "output", split = FALSE)
[13:21:40.390]             base::close(...future.stdout)
[13:21:40.390]         }, add = TRUE)
[13:21:40.390]     }
[13:21:40.390]     ...future.frame <- base::sys.nframe()
[13:21:40.390]     ...future.conditions <- base::list()
[13:21:40.390]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:40.390]     if (FALSE) {
[13:21:40.390]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:40.390]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:40.390]     }
[13:21:40.390]     ...future.result <- base::tryCatch({
[13:21:40.390]         base::withCallingHandlers({
[13:21:40.390]             ...future.value <- base::withVisible(base::local({
[13:21:40.390]                 withCallingHandlers({
[13:21:40.390]                   1
[13:21:40.390]                 }, immediateCondition = function(cond) {
[13:21:40.390]                   save_rds <- function (object, pathname, ...) 
[13:21:40.390]                   {
[13:21:40.390]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:40.390]                     if (file_test("-f", pathname_tmp)) {
[13:21:40.390]                       fi_tmp <- file.info(pathname_tmp)
[13:21:40.390]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:40.390]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:40.390]                         fi_tmp[["mtime"]])
[13:21:40.390]                     }
[13:21:40.390]                     tryCatch({
[13:21:40.390]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:40.390]                     }, error = function(ex) {
[13:21:40.390]                       msg <- conditionMessage(ex)
[13:21:40.390]                       fi_tmp <- file.info(pathname_tmp)
[13:21:40.390]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:40.390]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:40.390]                         fi_tmp[["mtime"]], msg)
[13:21:40.390]                       ex$message <- msg
[13:21:40.390]                       stop(ex)
[13:21:40.390]                     })
[13:21:40.390]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:40.390]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:40.390]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:40.390]                       fi_tmp <- file.info(pathname_tmp)
[13:21:40.390]                       fi <- file.info(pathname)
[13:21:40.390]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:40.390]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:40.390]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:40.390]                         fi[["size"]], fi[["mtime"]])
[13:21:40.390]                       stop(msg)
[13:21:40.390]                     }
[13:21:40.390]                     invisible(pathname)
[13:21:40.390]                   }
[13:21:40.390]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:40.390]                     rootPath = tempdir()) 
[13:21:40.390]                   {
[13:21:40.390]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:40.390]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:40.390]                       tmpdir = path, fileext = ".rds")
[13:21:40.390]                     save_rds(obj, file)
[13:21:40.390]                   }
[13:21:40.390]                   saveImmediateCondition(cond, path = "/tmp/RtmpRIPAyw/.future/immediateConditions")
[13:21:40.390]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.390]                   {
[13:21:40.390]                     inherits <- base::inherits
[13:21:40.390]                     invokeRestart <- base::invokeRestart
[13:21:40.390]                     is.null <- base::is.null
[13:21:40.390]                     muffled <- FALSE
[13:21:40.390]                     if (inherits(cond, "message")) {
[13:21:40.390]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:40.390]                       if (muffled) 
[13:21:40.390]                         invokeRestart("muffleMessage")
[13:21:40.390]                     }
[13:21:40.390]                     else if (inherits(cond, "warning")) {
[13:21:40.390]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:40.390]                       if (muffled) 
[13:21:40.390]                         invokeRestart("muffleWarning")
[13:21:40.390]                     }
[13:21:40.390]                     else if (inherits(cond, "condition")) {
[13:21:40.390]                       if (!is.null(pattern)) {
[13:21:40.390]                         computeRestarts <- base::computeRestarts
[13:21:40.390]                         grepl <- base::grepl
[13:21:40.390]                         restarts <- computeRestarts(cond)
[13:21:40.390]                         for (restart in restarts) {
[13:21:40.390]                           name <- restart$name
[13:21:40.390]                           if (is.null(name)) 
[13:21:40.390]                             next
[13:21:40.390]                           if (!grepl(pattern, name)) 
[13:21:40.390]                             next
[13:21:40.390]                           invokeRestart(restart)
[13:21:40.390]                           muffled <- TRUE
[13:21:40.390]                           break
[13:21:40.390]                         }
[13:21:40.390]                       }
[13:21:40.390]                     }
[13:21:40.390]                     invisible(muffled)
[13:21:40.390]                   }
[13:21:40.390]                   muffleCondition(cond)
[13:21:40.390]                 })
[13:21:40.390]             }))
[13:21:40.390]             future::FutureResult(value = ...future.value$value, 
[13:21:40.390]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:40.390]                   ...future.rng), globalenv = if (FALSE) 
[13:21:40.390]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:40.390]                     ...future.globalenv.names))
[13:21:40.390]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:40.390]         }, condition = base::local({
[13:21:40.390]             c <- base::c
[13:21:40.390]             inherits <- base::inherits
[13:21:40.390]             invokeRestart <- base::invokeRestart
[13:21:40.390]             length <- base::length
[13:21:40.390]             list <- base::list
[13:21:40.390]             seq.int <- base::seq.int
[13:21:40.390]             signalCondition <- base::signalCondition
[13:21:40.390]             sys.calls <- base::sys.calls
[13:21:40.390]             `[[` <- base::`[[`
[13:21:40.390]             `+` <- base::`+`
[13:21:40.390]             `<<-` <- base::`<<-`
[13:21:40.390]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:40.390]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:40.390]                   3L)]
[13:21:40.390]             }
[13:21:40.390]             function(cond) {
[13:21:40.390]                 is_error <- inherits(cond, "error")
[13:21:40.390]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:40.390]                   NULL)
[13:21:40.390]                 if (is_error) {
[13:21:40.390]                   sessionInformation <- function() {
[13:21:40.390]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:40.390]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:40.390]                       search = base::search(), system = base::Sys.info())
[13:21:40.390]                   }
[13:21:40.390]                   ...future.conditions[[length(...future.conditions) + 
[13:21:40.390]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:40.390]                     cond$call), session = sessionInformation(), 
[13:21:40.390]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:40.390]                   signalCondition(cond)
[13:21:40.390]                 }
[13:21:40.390]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:40.390]                 "immediateCondition"))) {
[13:21:40.390]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:40.390]                   ...future.conditions[[length(...future.conditions) + 
[13:21:40.390]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:40.390]                   if (TRUE && !signal) {
[13:21:40.390]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.390]                     {
[13:21:40.390]                       inherits <- base::inherits
[13:21:40.390]                       invokeRestart <- base::invokeRestart
[13:21:40.390]                       is.null <- base::is.null
[13:21:40.390]                       muffled <- FALSE
[13:21:40.390]                       if (inherits(cond, "message")) {
[13:21:40.390]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:40.390]                         if (muffled) 
[13:21:40.390]                           invokeRestart("muffleMessage")
[13:21:40.390]                       }
[13:21:40.390]                       else if (inherits(cond, "warning")) {
[13:21:40.390]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:40.390]                         if (muffled) 
[13:21:40.390]                           invokeRestart("muffleWarning")
[13:21:40.390]                       }
[13:21:40.390]                       else if (inherits(cond, "condition")) {
[13:21:40.390]                         if (!is.null(pattern)) {
[13:21:40.390]                           computeRestarts <- base::computeRestarts
[13:21:40.390]                           grepl <- base::grepl
[13:21:40.390]                           restarts <- computeRestarts(cond)
[13:21:40.390]                           for (restart in restarts) {
[13:21:40.390]                             name <- restart$name
[13:21:40.390]                             if (is.null(name)) 
[13:21:40.390]                               next
[13:21:40.390]                             if (!grepl(pattern, name)) 
[13:21:40.390]                               next
[13:21:40.390]                             invokeRestart(restart)
[13:21:40.390]                             muffled <- TRUE
[13:21:40.390]                             break
[13:21:40.390]                           }
[13:21:40.390]                         }
[13:21:40.390]                       }
[13:21:40.390]                       invisible(muffled)
[13:21:40.390]                     }
[13:21:40.390]                     muffleCondition(cond, pattern = "^muffle")
[13:21:40.390]                   }
[13:21:40.390]                 }
[13:21:40.390]                 else {
[13:21:40.390]                   if (TRUE) {
[13:21:40.390]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.390]                     {
[13:21:40.390]                       inherits <- base::inherits
[13:21:40.390]                       invokeRestart <- base::invokeRestart
[13:21:40.390]                       is.null <- base::is.null
[13:21:40.390]                       muffled <- FALSE
[13:21:40.390]                       if (inherits(cond, "message")) {
[13:21:40.390]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:40.390]                         if (muffled) 
[13:21:40.390]                           invokeRestart("muffleMessage")
[13:21:40.390]                       }
[13:21:40.390]                       else if (inherits(cond, "warning")) {
[13:21:40.390]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:40.390]                         if (muffled) 
[13:21:40.390]                           invokeRestart("muffleWarning")
[13:21:40.390]                       }
[13:21:40.390]                       else if (inherits(cond, "condition")) {
[13:21:40.390]                         if (!is.null(pattern)) {
[13:21:40.390]                           computeRestarts <- base::computeRestarts
[13:21:40.390]                           grepl <- base::grepl
[13:21:40.390]                           restarts <- computeRestarts(cond)
[13:21:40.390]                           for (restart in restarts) {
[13:21:40.390]                             name <- restart$name
[13:21:40.390]                             if (is.null(name)) 
[13:21:40.390]                               next
[13:21:40.390]                             if (!grepl(pattern, name)) 
[13:21:40.390]                               next
[13:21:40.390]                             invokeRestart(restart)
[13:21:40.390]                             muffled <- TRUE
[13:21:40.390]                             break
[13:21:40.390]                           }
[13:21:40.390]                         }
[13:21:40.390]                       }
[13:21:40.390]                       invisible(muffled)
[13:21:40.390]                     }
[13:21:40.390]                     muffleCondition(cond, pattern = "^muffle")
[13:21:40.390]                   }
[13:21:40.390]                 }
[13:21:40.390]             }
[13:21:40.390]         }))
[13:21:40.390]     }, error = function(ex) {
[13:21:40.390]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:40.390]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:40.390]                 ...future.rng), started = ...future.startTime, 
[13:21:40.390]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:40.390]             version = "1.8"), class = "FutureResult")
[13:21:40.390]     }, finally = {
[13:21:40.390]         if (!identical(...future.workdir, getwd())) 
[13:21:40.390]             setwd(...future.workdir)
[13:21:40.390]         {
[13:21:40.390]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:40.390]                 ...future.oldOptions$nwarnings <- NULL
[13:21:40.390]             }
[13:21:40.390]             base::options(...future.oldOptions)
[13:21:40.390]             if (.Platform$OS.type == "windows") {
[13:21:40.390]                 old_names <- names(...future.oldEnvVars)
[13:21:40.390]                 envs <- base::Sys.getenv()
[13:21:40.390]                 names <- names(envs)
[13:21:40.390]                 common <- intersect(names, old_names)
[13:21:40.390]                 added <- setdiff(names, old_names)
[13:21:40.390]                 removed <- setdiff(old_names, names)
[13:21:40.390]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:40.390]                   envs[common]]
[13:21:40.390]                 NAMES <- toupper(changed)
[13:21:40.390]                 args <- list()
[13:21:40.390]                 for (kk in seq_along(NAMES)) {
[13:21:40.390]                   name <- changed[[kk]]
[13:21:40.390]                   NAME <- NAMES[[kk]]
[13:21:40.390]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.390]                     next
[13:21:40.390]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:40.390]                 }
[13:21:40.390]                 NAMES <- toupper(added)
[13:21:40.390]                 for (kk in seq_along(NAMES)) {
[13:21:40.390]                   name <- added[[kk]]
[13:21:40.390]                   NAME <- NAMES[[kk]]
[13:21:40.390]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.390]                     next
[13:21:40.390]                   args[[name]] <- ""
[13:21:40.390]                 }
[13:21:40.390]                 NAMES <- toupper(removed)
[13:21:40.390]                 for (kk in seq_along(NAMES)) {
[13:21:40.390]                   name <- removed[[kk]]
[13:21:40.390]                   NAME <- NAMES[[kk]]
[13:21:40.390]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.390]                     next
[13:21:40.390]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:40.390]                 }
[13:21:40.390]                 if (length(args) > 0) 
[13:21:40.390]                   base::do.call(base::Sys.setenv, args = args)
[13:21:40.390]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:40.390]             }
[13:21:40.390]             else {
[13:21:40.390]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:40.390]             }
[13:21:40.390]             {
[13:21:40.390]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:40.390]                   0L) {
[13:21:40.390]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:40.390]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:40.390]                   base::options(opts)
[13:21:40.390]                 }
[13:21:40.390]                 {
[13:21:40.390]                   {
[13:21:40.390]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:40.390]                     NULL
[13:21:40.390]                   }
[13:21:40.390]                   options(future.plan = NULL)
[13:21:40.390]                   if (is.na(NA_character_)) 
[13:21:40.390]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:40.390]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:40.390]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:40.390]                     envir = parent.frame()) 
[13:21:40.390]                   {
[13:21:40.390]                     default_workers <- missing(workers)
[13:21:40.390]                     if (is.function(workers)) 
[13:21:40.390]                       workers <- workers()
[13:21:40.390]                     workers <- structure(as.integer(workers), 
[13:21:40.390]                       class = class(workers))
[13:21:40.390]                     stop_if_not(is.finite(workers), workers >= 
[13:21:40.390]                       1L)
[13:21:40.390]                     if ((workers == 1L && !inherits(workers, 
[13:21:40.390]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:40.390]                       if (default_workers) 
[13:21:40.390]                         supportsMulticore(warn = TRUE)
[13:21:40.390]                       return(sequential(..., envir = envir))
[13:21:40.390]                     }
[13:21:40.390]                     oopts <- options(mc.cores = workers)
[13:21:40.390]                     on.exit(options(oopts))
[13:21:40.390]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:40.390]                       envir = envir)
[13:21:40.390]                     if (!future$lazy) 
[13:21:40.390]                       future <- run(future)
[13:21:40.390]                     invisible(future)
[13:21:40.390]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:40.390]                 }
[13:21:40.390]             }
[13:21:40.390]         }
[13:21:40.390]     })
[13:21:40.390]     if (TRUE) {
[13:21:40.390]         base::sink(type = "output", split = FALSE)
[13:21:40.390]         if (TRUE) {
[13:21:40.390]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:40.390]         }
[13:21:40.390]         else {
[13:21:40.390]             ...future.result["stdout"] <- base::list(NULL)
[13:21:40.390]         }
[13:21:40.390]         base::close(...future.stdout)
[13:21:40.390]         ...future.stdout <- NULL
[13:21:40.390]     }
[13:21:40.390]     ...future.result$conditions <- ...future.conditions
[13:21:40.390]     ...future.result$finished <- base::Sys.time()
[13:21:40.390]     ...future.result
[13:21:40.390] }
[13:21:40.393] requestCore(): workers = 2
[13:21:40.393] Poll #1 (0): usedCores() = 2, workers = 2
[13:21:40.407] MulticoreFuture started
[13:21:40.407] - Launch lazy future ... done
[13:21:40.408] run() for ‘MulticoreFuture’ ... done
[13:21:40.408] getGlobalsAndPackages() ...
[13:21:40.408] plan(): Setting new future strategy stack:
[13:21:40.409] Searching for globals...
[13:21:40.409] List of future strategies:
[13:21:40.409] 1. sequential:
[13:21:40.409]    - args: function (..., envir = parent.frame())
[13:21:40.409]    - tweaked: FALSE
[13:21:40.409]    - call: NULL
[13:21:40.410] plan(): nbrOfWorkers() = 1
[13:21:40.412] - globals found: [2] ‘{’, ‘Sys.sleep’
[13:21:40.412] Searching for globals ... DONE
[13:21:40.412] Resolving globals: FALSE
[13:21:40.413] plan(): Setting new future strategy stack:
[13:21:40.413] 
[13:21:40.413] 
[13:21:40.414] getGlobalsAndPackages() ... DONE
[13:21:40.413] List of future strategies:
[13:21:40.413] 1. multicore:
[13:21:40.413]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:40.413]    - tweaked: FALSE
[13:21:40.413]    - call: plan(strategy)
[13:21:40.414] run() for ‘Future’ ...
[13:21:40.415] - state: ‘created’
[13:21:40.415] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:40.419] plan(): nbrOfWorkers() = 2
[13:21:40.420] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:40.420] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:40.420]   - Field: ‘label’
[13:21:40.420]   - Field: ‘local’
[13:21:40.421]   - Field: ‘owner’
[13:21:40.421]   - Field: ‘envir’
[13:21:40.421]   - Field: ‘workers’
[13:21:40.421]   - Field: ‘packages’
[13:21:40.421]   - Field: ‘gc’
[13:21:40.421]   - Field: ‘job’
[13:21:40.422]   - Field: ‘conditions’
[13:21:40.422]   - Field: ‘expr’
[13:21:40.422]   - Field: ‘uuid’
[13:21:40.422]   - Field: ‘seed’
[13:21:40.422]   - Field: ‘version’
[13:21:40.422]   - Field: ‘result’
[13:21:40.422]   - Field: ‘asynchronous’
[13:21:40.423]   - Field: ‘calls’
[13:21:40.423]   - Field: ‘globals’
[13:21:40.423]   - Field: ‘stdout’
[13:21:40.423]   - Field: ‘earlySignal’
[13:21:40.423]   - Field: ‘lazy’
[13:21:40.424]   - Field: ‘state’
[13:21:40.424] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:40.424] - Launch lazy future ...
[13:21:40.424] Packages needed by the future expression (n = 0): <none>
[13:21:40.425] Packages needed by future strategies (n = 0): <none>
[13:21:40.425] {
[13:21:40.425]     {
[13:21:40.425]         {
[13:21:40.425]             ...future.startTime <- base::Sys.time()
[13:21:40.425]             {
[13:21:40.425]                 {
[13:21:40.425]                   {
[13:21:40.425]                     {
[13:21:40.425]                       base::local({
[13:21:40.425]                         has_future <- base::requireNamespace("future", 
[13:21:40.425]                           quietly = TRUE)
[13:21:40.425]                         if (has_future) {
[13:21:40.425]                           ns <- base::getNamespace("future")
[13:21:40.425]                           version <- ns[[".package"]][["version"]]
[13:21:40.425]                           if (is.null(version)) 
[13:21:40.425]                             version <- utils::packageVersion("future")
[13:21:40.425]                         }
[13:21:40.425]                         else {
[13:21:40.425]                           version <- NULL
[13:21:40.425]                         }
[13:21:40.425]                         if (!has_future || version < "1.8.0") {
[13:21:40.425]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:40.425]                             "", base::R.version$version.string), 
[13:21:40.425]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:40.425]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:40.425]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:40.425]                               "release", "version")], collapse = " "), 
[13:21:40.425]                             hostname = base::Sys.info()[["nodename"]])
[13:21:40.425]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:40.425]                             info)
[13:21:40.425]                           info <- base::paste(info, collapse = "; ")
[13:21:40.425]                           if (!has_future) {
[13:21:40.425]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:40.425]                               info)
[13:21:40.425]                           }
[13:21:40.425]                           else {
[13:21:40.425]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:40.425]                               info, version)
[13:21:40.425]                           }
[13:21:40.425]                           base::stop(msg)
[13:21:40.425]                         }
[13:21:40.425]                       })
[13:21:40.425]                     }
[13:21:40.425]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:40.425]                     base::options(mc.cores = 1L)
[13:21:40.425]                   }
[13:21:40.425]                   options(future.plan = NULL)
[13:21:40.425]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:40.425]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:40.425]                 }
[13:21:40.425]                 ...future.workdir <- getwd()
[13:21:40.425]             }
[13:21:40.425]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:40.425]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:40.425]         }
[13:21:40.425]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:40.425]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:40.425]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:40.425]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:40.425]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:40.425]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:40.425]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:40.425]             base::names(...future.oldOptions))
[13:21:40.425]     }
[13:21:40.425]     if (FALSE) {
[13:21:40.425]     }
[13:21:40.425]     else {
[13:21:40.425]         if (TRUE) {
[13:21:40.425]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:40.425]                 open = "w")
[13:21:40.425]         }
[13:21:40.425]         else {
[13:21:40.425]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:40.425]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:40.425]         }
[13:21:40.425]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:40.425]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:40.425]             base::sink(type = "output", split = FALSE)
[13:21:40.425]             base::close(...future.stdout)
[13:21:40.425]         }, add = TRUE)
[13:21:40.425]     }
[13:21:40.425]     ...future.frame <- base::sys.nframe()
[13:21:40.425]     ...future.conditions <- base::list()
[13:21:40.425]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:40.425]     if (FALSE) {
[13:21:40.425]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:40.425]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:40.425]     }
[13:21:40.425]     ...future.result <- base::tryCatch({
[13:21:40.425]         base::withCallingHandlers({
[13:21:40.425]             ...future.value <- base::withVisible(base::local({
[13:21:40.425]                 withCallingHandlers({
[13:21:40.425]                   {
[13:21:40.425]                     Sys.sleep(0.5)
[13:21:40.425]                     2
[13:21:40.425]                   }
[13:21:40.425]                 }, immediateCondition = function(cond) {
[13:21:40.425]                   save_rds <- function (object, pathname, ...) 
[13:21:40.425]                   {
[13:21:40.425]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:40.425]                     if (file_test("-f", pathname_tmp)) {
[13:21:40.425]                       fi_tmp <- file.info(pathname_tmp)
[13:21:40.425]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:40.425]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:40.425]                         fi_tmp[["mtime"]])
[13:21:40.425]                     }
[13:21:40.425]                     tryCatch({
[13:21:40.425]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:40.425]                     }, error = function(ex) {
[13:21:40.425]                       msg <- conditionMessage(ex)
[13:21:40.425]                       fi_tmp <- file.info(pathname_tmp)
[13:21:40.425]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:40.425]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:40.425]                         fi_tmp[["mtime"]], msg)
[13:21:40.425]                       ex$message <- msg
[13:21:40.425]                       stop(ex)
[13:21:40.425]                     })
[13:21:40.425]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:40.425]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:40.425]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:40.425]                       fi_tmp <- file.info(pathname_tmp)
[13:21:40.425]                       fi <- file.info(pathname)
[13:21:40.425]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:40.425]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:40.425]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:40.425]                         fi[["size"]], fi[["mtime"]])
[13:21:40.425]                       stop(msg)
[13:21:40.425]                     }
[13:21:40.425]                     invisible(pathname)
[13:21:40.425]                   }
[13:21:40.425]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:40.425]                     rootPath = tempdir()) 
[13:21:40.425]                   {
[13:21:40.425]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:40.425]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:40.425]                       tmpdir = path, fileext = ".rds")
[13:21:40.425]                     save_rds(obj, file)
[13:21:40.425]                   }
[13:21:40.425]                   saveImmediateCondition(cond, path = "/tmp/RtmpRIPAyw/.future/immediateConditions")
[13:21:40.425]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.425]                   {
[13:21:40.425]                     inherits <- base::inherits
[13:21:40.425]                     invokeRestart <- base::invokeRestart
[13:21:40.425]                     is.null <- base::is.null
[13:21:40.425]                     muffled <- FALSE
[13:21:40.425]                     if (inherits(cond, "message")) {
[13:21:40.425]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:40.425]                       if (muffled) 
[13:21:40.425]                         invokeRestart("muffleMessage")
[13:21:40.425]                     }
[13:21:40.425]                     else if (inherits(cond, "warning")) {
[13:21:40.425]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:40.425]                       if (muffled) 
[13:21:40.425]                         invokeRestart("muffleWarning")
[13:21:40.425]                     }
[13:21:40.425]                     else if (inherits(cond, "condition")) {
[13:21:40.425]                       if (!is.null(pattern)) {
[13:21:40.425]                         computeRestarts <- base::computeRestarts
[13:21:40.425]                         grepl <- base::grepl
[13:21:40.425]                         restarts <- computeRestarts(cond)
[13:21:40.425]                         for (restart in restarts) {
[13:21:40.425]                           name <- restart$name
[13:21:40.425]                           if (is.null(name)) 
[13:21:40.425]                             next
[13:21:40.425]                           if (!grepl(pattern, name)) 
[13:21:40.425]                             next
[13:21:40.425]                           invokeRestart(restart)
[13:21:40.425]                           muffled <- TRUE
[13:21:40.425]                           break
[13:21:40.425]                         }
[13:21:40.425]                       }
[13:21:40.425]                     }
[13:21:40.425]                     invisible(muffled)
[13:21:40.425]                   }
[13:21:40.425]                   muffleCondition(cond)
[13:21:40.425]                 })
[13:21:40.425]             }))
[13:21:40.425]             future::FutureResult(value = ...future.value$value, 
[13:21:40.425]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:40.425]                   ...future.rng), globalenv = if (FALSE) 
[13:21:40.425]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:40.425]                     ...future.globalenv.names))
[13:21:40.425]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:40.425]         }, condition = base::local({
[13:21:40.425]             c <- base::c
[13:21:40.425]             inherits <- base::inherits
[13:21:40.425]             invokeRestart <- base::invokeRestart
[13:21:40.425]             length <- base::length
[13:21:40.425]             list <- base::list
[13:21:40.425]             seq.int <- base::seq.int
[13:21:40.425]             signalCondition <- base::signalCondition
[13:21:40.425]             sys.calls <- base::sys.calls
[13:21:40.425]             `[[` <- base::`[[`
[13:21:40.425]             `+` <- base::`+`
[13:21:40.425]             `<<-` <- base::`<<-`
[13:21:40.425]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:40.425]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:40.425]                   3L)]
[13:21:40.425]             }
[13:21:40.425]             function(cond) {
[13:21:40.425]                 is_error <- inherits(cond, "error")
[13:21:40.425]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:40.425]                   NULL)
[13:21:40.425]                 if (is_error) {
[13:21:40.425]                   sessionInformation <- function() {
[13:21:40.425]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:40.425]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:40.425]                       search = base::search(), system = base::Sys.info())
[13:21:40.425]                   }
[13:21:40.425]                   ...future.conditions[[length(...future.conditions) + 
[13:21:40.425]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:40.425]                     cond$call), session = sessionInformation(), 
[13:21:40.425]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:40.425]                   signalCondition(cond)
[13:21:40.425]                 }
[13:21:40.425]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:40.425]                 "immediateCondition"))) {
[13:21:40.425]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:40.425]                   ...future.conditions[[length(...future.conditions) + 
[13:21:40.425]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:40.425]                   if (TRUE && !signal) {
[13:21:40.425]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.425]                     {
[13:21:40.425]                       inherits <- base::inherits
[13:21:40.425]                       invokeRestart <- base::invokeRestart
[13:21:40.425]                       is.null <- base::is.null
[13:21:40.425]                       muffled <- FALSE
[13:21:40.425]                       if (inherits(cond, "message")) {
[13:21:40.425]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:40.425]                         if (muffled) 
[13:21:40.425]                           invokeRestart("muffleMessage")
[13:21:40.425]                       }
[13:21:40.425]                       else if (inherits(cond, "warning")) {
[13:21:40.425]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:40.425]                         if (muffled) 
[13:21:40.425]                           invokeRestart("muffleWarning")
[13:21:40.425]                       }
[13:21:40.425]                       else if (inherits(cond, "condition")) {
[13:21:40.425]                         if (!is.null(pattern)) {
[13:21:40.425]                           computeRestarts <- base::computeRestarts
[13:21:40.425]                           grepl <- base::grepl
[13:21:40.425]                           restarts <- computeRestarts(cond)
[13:21:40.425]                           for (restart in restarts) {
[13:21:40.425]                             name <- restart$name
[13:21:40.425]                             if (is.null(name)) 
[13:21:40.425]                               next
[13:21:40.425]                             if (!grepl(pattern, name)) 
[13:21:40.425]                               next
[13:21:40.425]                             invokeRestart(restart)
[13:21:40.425]                             muffled <- TRUE
[13:21:40.425]                             break
[13:21:40.425]                           }
[13:21:40.425]                         }
[13:21:40.425]                       }
[13:21:40.425]                       invisible(muffled)
[13:21:40.425]                     }
[13:21:40.425]                     muffleCondition(cond, pattern = "^muffle")
[13:21:40.425]                   }
[13:21:40.425]                 }
[13:21:40.425]                 else {
[13:21:40.425]                   if (TRUE) {
[13:21:40.425]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.425]                     {
[13:21:40.425]                       inherits <- base::inherits
[13:21:40.425]                       invokeRestart <- base::invokeRestart
[13:21:40.425]                       is.null <- base::is.null
[13:21:40.425]                       muffled <- FALSE
[13:21:40.425]                       if (inherits(cond, "message")) {
[13:21:40.425]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:40.425]                         if (muffled) 
[13:21:40.425]                           invokeRestart("muffleMessage")
[13:21:40.425]                       }
[13:21:40.425]                       else if (inherits(cond, "warning")) {
[13:21:40.425]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:40.425]                         if (muffled) 
[13:21:40.425]                           invokeRestart("muffleWarning")
[13:21:40.425]                       }
[13:21:40.425]                       else if (inherits(cond, "condition")) {
[13:21:40.425]                         if (!is.null(pattern)) {
[13:21:40.425]                           computeRestarts <- base::computeRestarts
[13:21:40.425]                           grepl <- base::grepl
[13:21:40.425]                           restarts <- computeRestarts(cond)
[13:21:40.425]                           for (restart in restarts) {
[13:21:40.425]                             name <- restart$name
[13:21:40.425]                             if (is.null(name)) 
[13:21:40.425]                               next
[13:21:40.425]                             if (!grepl(pattern, name)) 
[13:21:40.425]                               next
[13:21:40.425]                             invokeRestart(restart)
[13:21:40.425]                             muffled <- TRUE
[13:21:40.425]                             break
[13:21:40.425]                           }
[13:21:40.425]                         }
[13:21:40.425]                       }
[13:21:40.425]                       invisible(muffled)
[13:21:40.425]                     }
[13:21:40.425]                     muffleCondition(cond, pattern = "^muffle")
[13:21:40.425]                   }
[13:21:40.425]                 }
[13:21:40.425]             }
[13:21:40.425]         }))
[13:21:40.425]     }, error = function(ex) {
[13:21:40.425]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:40.425]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:40.425]                 ...future.rng), started = ...future.startTime, 
[13:21:40.425]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:40.425]             version = "1.8"), class = "FutureResult")
[13:21:40.425]     }, finally = {
[13:21:40.425]         if (!identical(...future.workdir, getwd())) 
[13:21:40.425]             setwd(...future.workdir)
[13:21:40.425]         {
[13:21:40.425]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:40.425]                 ...future.oldOptions$nwarnings <- NULL
[13:21:40.425]             }
[13:21:40.425]             base::options(...future.oldOptions)
[13:21:40.425]             if (.Platform$OS.type == "windows") {
[13:21:40.425]                 old_names <- names(...future.oldEnvVars)
[13:21:40.425]                 envs <- base::Sys.getenv()
[13:21:40.425]                 names <- names(envs)
[13:21:40.425]                 common <- intersect(names, old_names)
[13:21:40.425]                 added <- setdiff(names, old_names)
[13:21:40.425]                 removed <- setdiff(old_names, names)
[13:21:40.425]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:40.425]                   envs[common]]
[13:21:40.425]                 NAMES <- toupper(changed)
[13:21:40.425]                 args <- list()
[13:21:40.425]                 for (kk in seq_along(NAMES)) {
[13:21:40.425]                   name <- changed[[kk]]
[13:21:40.425]                   NAME <- NAMES[[kk]]
[13:21:40.425]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.425]                     next
[13:21:40.425]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:40.425]                 }
[13:21:40.425]                 NAMES <- toupper(added)
[13:21:40.425]                 for (kk in seq_along(NAMES)) {
[13:21:40.425]                   name <- added[[kk]]
[13:21:40.425]                   NAME <- NAMES[[kk]]
[13:21:40.425]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.425]                     next
[13:21:40.425]                   args[[name]] <- ""
[13:21:40.425]                 }
[13:21:40.425]                 NAMES <- toupper(removed)
[13:21:40.425]                 for (kk in seq_along(NAMES)) {
[13:21:40.425]                   name <- removed[[kk]]
[13:21:40.425]                   NAME <- NAMES[[kk]]
[13:21:40.425]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.425]                     next
[13:21:40.425]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:40.425]                 }
[13:21:40.425]                 if (length(args) > 0) 
[13:21:40.425]                   base::do.call(base::Sys.setenv, args = args)
[13:21:40.425]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:40.425]             }
[13:21:40.425]             else {
[13:21:40.425]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:40.425]             }
[13:21:40.425]             {
[13:21:40.425]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:40.425]                   0L) {
[13:21:40.425]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:40.425]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:40.425]                   base::options(opts)
[13:21:40.425]                 }
[13:21:40.425]                 {
[13:21:40.425]                   {
[13:21:40.425]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:40.425]                     NULL
[13:21:40.425]                   }
[13:21:40.425]                   options(future.plan = NULL)
[13:21:40.425]                   if (is.na(NA_character_)) 
[13:21:40.425]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:40.425]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:40.425]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:40.425]                     envir = parent.frame()) 
[13:21:40.425]                   {
[13:21:40.425]                     default_workers <- missing(workers)
[13:21:40.425]                     if (is.function(workers)) 
[13:21:40.425]                       workers <- workers()
[13:21:40.425]                     workers <- structure(as.integer(workers), 
[13:21:40.425]                       class = class(workers))
[13:21:40.425]                     stop_if_not(is.finite(workers), workers >= 
[13:21:40.425]                       1L)
[13:21:40.425]                     if ((workers == 1L && !inherits(workers, 
[13:21:40.425]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:40.425]                       if (default_workers) 
[13:21:40.425]                         supportsMulticore(warn = TRUE)
[13:21:40.425]                       return(sequential(..., envir = envir))
[13:21:40.425]                     }
[13:21:40.425]                     oopts <- options(mc.cores = workers)
[13:21:40.425]                     on.exit(options(oopts))
[13:21:40.425]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:40.425]                       envir = envir)
[13:21:40.425]                     if (!future$lazy) 
[13:21:40.425]                       future <- run(future)
[13:21:40.425]                     invisible(future)
[13:21:40.425]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:40.425]                 }
[13:21:40.425]             }
[13:21:40.425]         }
[13:21:40.425]     })
[13:21:40.425]     if (TRUE) {
[13:21:40.425]         base::sink(type = "output", split = FALSE)
[13:21:40.425]         if (TRUE) {
[13:21:40.425]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:40.425]         }
[13:21:40.425]         else {
[13:21:40.425]             ...future.result["stdout"] <- base::list(NULL)
[13:21:40.425]         }
[13:21:40.425]         base::close(...future.stdout)
[13:21:40.425]         ...future.stdout <- NULL
[13:21:40.425]     }
[13:21:40.425]     ...future.result$conditions <- ...future.conditions
[13:21:40.425]     ...future.result$finished <- base::Sys.time()
[13:21:40.425]     ...future.result
[13:21:40.425] }
[13:21:40.429] requestCore(): workers = 2
[13:21:40.429] Poll #1 (0): usedCores() = 2, workers = 2
[13:21:40.444] MulticoreFuture started
[13:21:40.444] - Launch lazy future ... done
[13:21:40.444] run() for ‘MulticoreFuture’ ... done
[13:21:40.445] plan(): Setting new future strategy stack:
[13:21:40.445] resolve() on list ...
[13:21:40.445]  recursive: 0
[13:21:40.446]  length: 1
[13:21:40.446] 
[13:21:40.445] List of future strategies:
[13:21:40.445] 1. sequential:
[13:21:40.445]    - args: function (..., envir = parent.frame())
[13:21:40.445]    - tweaked: FALSE
[13:21:40.445]    - call: NULL
[13:21:40.446] plan(): nbrOfWorkers() = 1
[13:21:40.446] Future #1
[13:21:40.447]  length: 0 (resolved future 1)
[13:21:40.447] resolve() on list ... DONE
[13:21:40.447] resolve() on list ...
[13:21:40.447]  recursive: 0
[13:21:40.447]  length: 1
[13:21:40.448] 
[13:21:40.949] plan(): Setting new future strategy stack:
[13:21:40.949] List of future strategies:
[13:21:40.949] 1. multicore:
[13:21:40.949]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:40.949]    - tweaked: FALSE
[13:21:40.949]    - call: plan(strategy)
[13:21:40.955] plan(): nbrOfWorkers() = 2
[13:21:40.959] Future #1
[13:21:40.959]  length: 0 (resolved future 1)
[13:21:40.959] resolve() on list ... DONE
[13:21:40.960] resolve() on list ...
[13:21:40.960]  recursive: 0
[13:21:40.960]  length: 1
[13:21:40.960] 
[13:21:40.961]  length: 0 (resolved future 1)
[13:21:40.961] resolve() on list ... DONE
[13:21:40.961] resolve() on list ...
[13:21:40.961]  recursive: 0
[13:21:40.961]  length: 4
[13:21:40.962] 
[13:21:40.962] Future #1
[13:21:40.962]  length: 3 (resolved future 1)
[13:21:40.962] Future #2
[13:21:40.962]  length: 2 (resolved future 2)
[13:21:40.963]  length: 1 (resolved future 3)
[13:21:40.963]  length: 0 (resolved future 4)
[13:21:40.963] resolve() on list ... DONE
[13:21:40.963] resolve() on list ...
[13:21:40.963]  recursive: 0
[13:21:40.964]  length: 4
[13:21:40.964] 
[13:21:40.964] Future #1
[13:21:40.964]  length: 3 (resolved future 1)
[13:21:40.964] Future #2
[13:21:40.965]  length: 2 (resolved future 2)
[13:21:40.965]  length: 1 (resolved future 3)
[13:21:40.965]  length: 0 (resolved future 4)
[13:21:40.965] resolve() on list ... DONE
[13:21:40.965] resolve() on list ...
[13:21:40.966]  recursive: 0
[13:21:40.966]  length: 1
[13:21:40.966] 
[13:21:40.970]  length: 0 (resolved future 1)
[13:21:40.970] resolve() on list ... DONE
[13:21:40.971] getGlobalsAndPackages() ...
[13:21:40.971] Searching for globals...
[13:21:40.974] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:21:40.974] Searching for globals ... DONE
[13:21:40.974] Resolving globals: FALSE
[13:21:40.975] The total size of the 1 globals is 56 bytes (56 bytes)
[13:21:40.976] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:21:40.976] - globals: [1] ‘kk’
[13:21:40.976] 
[13:21:40.976] getGlobalsAndPackages() ... DONE
[13:21:40.977] run() for ‘Future’ ...
[13:21:40.977] - state: ‘created’
[13:21:40.977] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:40.982] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:40.982] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:40.982]   - Field: ‘label’
[13:21:40.983]   - Field: ‘local’
[13:21:40.983]   - Field: ‘owner’
[13:21:40.983]   - Field: ‘envir’
[13:21:40.983]   - Field: ‘workers’
[13:21:40.983]   - Field: ‘packages’
[13:21:40.984]   - Field: ‘gc’
[13:21:40.984]   - Field: ‘job’
[13:21:40.984]   - Field: ‘conditions’
[13:21:40.984]   - Field: ‘expr’
[13:21:40.984]   - Field: ‘uuid’
[13:21:40.984]   - Field: ‘seed’
[13:21:40.984]   - Field: ‘version’
[13:21:40.985]   - Field: ‘result’
[13:21:40.985]   - Field: ‘asynchronous’
[13:21:40.985]   - Field: ‘calls’
[13:21:40.985]   - Field: ‘globals’
[13:21:40.985]   - Field: ‘stdout’
[13:21:40.985]   - Field: ‘earlySignal’
[13:21:40.986]   - Field: ‘lazy’
[13:21:40.986]   - Field: ‘state’
[13:21:40.986] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:40.986] - Launch lazy future ...
[13:21:40.986] Packages needed by the future expression (n = 0): <none>
[13:21:40.987] Packages needed by future strategies (n = 0): <none>
[13:21:40.987] {
[13:21:40.987]     {
[13:21:40.987]         {
[13:21:40.987]             ...future.startTime <- base::Sys.time()
[13:21:40.987]             {
[13:21:40.987]                 {
[13:21:40.987]                   {
[13:21:40.987]                     {
[13:21:40.987]                       base::local({
[13:21:40.987]                         has_future <- base::requireNamespace("future", 
[13:21:40.987]                           quietly = TRUE)
[13:21:40.987]                         if (has_future) {
[13:21:40.987]                           ns <- base::getNamespace("future")
[13:21:40.987]                           version <- ns[[".package"]][["version"]]
[13:21:40.987]                           if (is.null(version)) 
[13:21:40.987]                             version <- utils::packageVersion("future")
[13:21:40.987]                         }
[13:21:40.987]                         else {
[13:21:40.987]                           version <- NULL
[13:21:40.987]                         }
[13:21:40.987]                         if (!has_future || version < "1.8.0") {
[13:21:40.987]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:40.987]                             "", base::R.version$version.string), 
[13:21:40.987]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:40.987]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:40.987]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:40.987]                               "release", "version")], collapse = " "), 
[13:21:40.987]                             hostname = base::Sys.info()[["nodename"]])
[13:21:40.987]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:40.987]                             info)
[13:21:40.987]                           info <- base::paste(info, collapse = "; ")
[13:21:40.987]                           if (!has_future) {
[13:21:40.987]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:40.987]                               info)
[13:21:40.987]                           }
[13:21:40.987]                           else {
[13:21:40.987]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:40.987]                               info, version)
[13:21:40.987]                           }
[13:21:40.987]                           base::stop(msg)
[13:21:40.987]                         }
[13:21:40.987]                       })
[13:21:40.987]                     }
[13:21:40.987]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:40.987]                     base::options(mc.cores = 1L)
[13:21:40.987]                   }
[13:21:40.987]                   options(future.plan = NULL)
[13:21:40.987]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:40.987]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:40.987]                 }
[13:21:40.987]                 ...future.workdir <- getwd()
[13:21:40.987]             }
[13:21:40.987]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:40.987]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:40.987]         }
[13:21:40.987]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:40.987]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:40.987]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:40.987]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:40.987]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:40.987]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:40.987]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:40.987]             base::names(...future.oldOptions))
[13:21:40.987]     }
[13:21:40.987]     if (FALSE) {
[13:21:40.987]     }
[13:21:40.987]     else {
[13:21:40.987]         if (TRUE) {
[13:21:40.987]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:40.987]                 open = "w")
[13:21:40.987]         }
[13:21:40.987]         else {
[13:21:40.987]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:40.987]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:40.987]         }
[13:21:40.987]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:40.987]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:40.987]             base::sink(type = "output", split = FALSE)
[13:21:40.987]             base::close(...future.stdout)
[13:21:40.987]         }, add = TRUE)
[13:21:40.987]     }
[13:21:40.987]     ...future.frame <- base::sys.nframe()
[13:21:40.987]     ...future.conditions <- base::list()
[13:21:40.987]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:40.987]     if (FALSE) {
[13:21:40.987]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:40.987]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:40.987]     }
[13:21:40.987]     ...future.result <- base::tryCatch({
[13:21:40.987]         base::withCallingHandlers({
[13:21:40.987]             ...future.value <- base::withVisible(base::local({
[13:21:40.987]                 withCallingHandlers({
[13:21:40.987]                   {
[13:21:40.987]                     Sys.sleep(0.1)
[13:21:40.987]                     kk
[13:21:40.987]                   }
[13:21:40.987]                 }, immediateCondition = function(cond) {
[13:21:40.987]                   save_rds <- function (object, pathname, ...) 
[13:21:40.987]                   {
[13:21:40.987]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:40.987]                     if (file_test("-f", pathname_tmp)) {
[13:21:40.987]                       fi_tmp <- file.info(pathname_tmp)
[13:21:40.987]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:40.987]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:40.987]                         fi_tmp[["mtime"]])
[13:21:40.987]                     }
[13:21:40.987]                     tryCatch({
[13:21:40.987]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:40.987]                     }, error = function(ex) {
[13:21:40.987]                       msg <- conditionMessage(ex)
[13:21:40.987]                       fi_tmp <- file.info(pathname_tmp)
[13:21:40.987]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:40.987]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:40.987]                         fi_tmp[["mtime"]], msg)
[13:21:40.987]                       ex$message <- msg
[13:21:40.987]                       stop(ex)
[13:21:40.987]                     })
[13:21:40.987]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:40.987]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:40.987]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:40.987]                       fi_tmp <- file.info(pathname_tmp)
[13:21:40.987]                       fi <- file.info(pathname)
[13:21:40.987]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:40.987]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:40.987]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:40.987]                         fi[["size"]], fi[["mtime"]])
[13:21:40.987]                       stop(msg)
[13:21:40.987]                     }
[13:21:40.987]                     invisible(pathname)
[13:21:40.987]                   }
[13:21:40.987]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:40.987]                     rootPath = tempdir()) 
[13:21:40.987]                   {
[13:21:40.987]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:40.987]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:40.987]                       tmpdir = path, fileext = ".rds")
[13:21:40.987]                     save_rds(obj, file)
[13:21:40.987]                   }
[13:21:40.987]                   saveImmediateCondition(cond, path = "/tmp/RtmpRIPAyw/.future/immediateConditions")
[13:21:40.987]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.987]                   {
[13:21:40.987]                     inherits <- base::inherits
[13:21:40.987]                     invokeRestart <- base::invokeRestart
[13:21:40.987]                     is.null <- base::is.null
[13:21:40.987]                     muffled <- FALSE
[13:21:40.987]                     if (inherits(cond, "message")) {
[13:21:40.987]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:40.987]                       if (muffled) 
[13:21:40.987]                         invokeRestart("muffleMessage")
[13:21:40.987]                     }
[13:21:40.987]                     else if (inherits(cond, "warning")) {
[13:21:40.987]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:40.987]                       if (muffled) 
[13:21:40.987]                         invokeRestart("muffleWarning")
[13:21:40.987]                     }
[13:21:40.987]                     else if (inherits(cond, "condition")) {
[13:21:40.987]                       if (!is.null(pattern)) {
[13:21:40.987]                         computeRestarts <- base::computeRestarts
[13:21:40.987]                         grepl <- base::grepl
[13:21:40.987]                         restarts <- computeRestarts(cond)
[13:21:40.987]                         for (restart in restarts) {
[13:21:40.987]                           name <- restart$name
[13:21:40.987]                           if (is.null(name)) 
[13:21:40.987]                             next
[13:21:40.987]                           if (!grepl(pattern, name)) 
[13:21:40.987]                             next
[13:21:40.987]                           invokeRestart(restart)
[13:21:40.987]                           muffled <- TRUE
[13:21:40.987]                           break
[13:21:40.987]                         }
[13:21:40.987]                       }
[13:21:40.987]                     }
[13:21:40.987]                     invisible(muffled)
[13:21:40.987]                   }
[13:21:40.987]                   muffleCondition(cond)
[13:21:40.987]                 })
[13:21:40.987]             }))
[13:21:40.987]             future::FutureResult(value = ...future.value$value, 
[13:21:40.987]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:40.987]                   ...future.rng), globalenv = if (FALSE) 
[13:21:40.987]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:40.987]                     ...future.globalenv.names))
[13:21:40.987]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:40.987]         }, condition = base::local({
[13:21:40.987]             c <- base::c
[13:21:40.987]             inherits <- base::inherits
[13:21:40.987]             invokeRestart <- base::invokeRestart
[13:21:40.987]             length <- base::length
[13:21:40.987]             list <- base::list
[13:21:40.987]             seq.int <- base::seq.int
[13:21:40.987]             signalCondition <- base::signalCondition
[13:21:40.987]             sys.calls <- base::sys.calls
[13:21:40.987]             `[[` <- base::`[[`
[13:21:40.987]             `+` <- base::`+`
[13:21:40.987]             `<<-` <- base::`<<-`
[13:21:40.987]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:40.987]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:40.987]                   3L)]
[13:21:40.987]             }
[13:21:40.987]             function(cond) {
[13:21:40.987]                 is_error <- inherits(cond, "error")
[13:21:40.987]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:40.987]                   NULL)
[13:21:40.987]                 if (is_error) {
[13:21:40.987]                   sessionInformation <- function() {
[13:21:40.987]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:40.987]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:40.987]                       search = base::search(), system = base::Sys.info())
[13:21:40.987]                   }
[13:21:40.987]                   ...future.conditions[[length(...future.conditions) + 
[13:21:40.987]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:40.987]                     cond$call), session = sessionInformation(), 
[13:21:40.987]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:40.987]                   signalCondition(cond)
[13:21:40.987]                 }
[13:21:40.987]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:40.987]                 "immediateCondition"))) {
[13:21:40.987]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:40.987]                   ...future.conditions[[length(...future.conditions) + 
[13:21:40.987]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:40.987]                   if (TRUE && !signal) {
[13:21:40.987]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.987]                     {
[13:21:40.987]                       inherits <- base::inherits
[13:21:40.987]                       invokeRestart <- base::invokeRestart
[13:21:40.987]                       is.null <- base::is.null
[13:21:40.987]                       muffled <- FALSE
[13:21:40.987]                       if (inherits(cond, "message")) {
[13:21:40.987]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:40.987]                         if (muffled) 
[13:21:40.987]                           invokeRestart("muffleMessage")
[13:21:40.987]                       }
[13:21:40.987]                       else if (inherits(cond, "warning")) {
[13:21:40.987]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:40.987]                         if (muffled) 
[13:21:40.987]                           invokeRestart("muffleWarning")
[13:21:40.987]                       }
[13:21:40.987]                       else if (inherits(cond, "condition")) {
[13:21:40.987]                         if (!is.null(pattern)) {
[13:21:40.987]                           computeRestarts <- base::computeRestarts
[13:21:40.987]                           grepl <- base::grepl
[13:21:40.987]                           restarts <- computeRestarts(cond)
[13:21:40.987]                           for (restart in restarts) {
[13:21:40.987]                             name <- restart$name
[13:21:40.987]                             if (is.null(name)) 
[13:21:40.987]                               next
[13:21:40.987]                             if (!grepl(pattern, name)) 
[13:21:40.987]                               next
[13:21:40.987]                             invokeRestart(restart)
[13:21:40.987]                             muffled <- TRUE
[13:21:40.987]                             break
[13:21:40.987]                           }
[13:21:40.987]                         }
[13:21:40.987]                       }
[13:21:40.987]                       invisible(muffled)
[13:21:40.987]                     }
[13:21:40.987]                     muffleCondition(cond, pattern = "^muffle")
[13:21:40.987]                   }
[13:21:40.987]                 }
[13:21:40.987]                 else {
[13:21:40.987]                   if (TRUE) {
[13:21:40.987]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:40.987]                     {
[13:21:40.987]                       inherits <- base::inherits
[13:21:40.987]                       invokeRestart <- base::invokeRestart
[13:21:40.987]                       is.null <- base::is.null
[13:21:40.987]                       muffled <- FALSE
[13:21:40.987]                       if (inherits(cond, "message")) {
[13:21:40.987]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:40.987]                         if (muffled) 
[13:21:40.987]                           invokeRestart("muffleMessage")
[13:21:40.987]                       }
[13:21:40.987]                       else if (inherits(cond, "warning")) {
[13:21:40.987]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:40.987]                         if (muffled) 
[13:21:40.987]                           invokeRestart("muffleWarning")
[13:21:40.987]                       }
[13:21:40.987]                       else if (inherits(cond, "condition")) {
[13:21:40.987]                         if (!is.null(pattern)) {
[13:21:40.987]                           computeRestarts <- base::computeRestarts
[13:21:40.987]                           grepl <- base::grepl
[13:21:40.987]                           restarts <- computeRestarts(cond)
[13:21:40.987]                           for (restart in restarts) {
[13:21:40.987]                             name <- restart$name
[13:21:40.987]                             if (is.null(name)) 
[13:21:40.987]                               next
[13:21:40.987]                             if (!grepl(pattern, name)) 
[13:21:40.987]                               next
[13:21:40.987]                             invokeRestart(restart)
[13:21:40.987]                             muffled <- TRUE
[13:21:40.987]                             break
[13:21:40.987]                           }
[13:21:40.987]                         }
[13:21:40.987]                       }
[13:21:40.987]                       invisible(muffled)
[13:21:40.987]                     }
[13:21:40.987]                     muffleCondition(cond, pattern = "^muffle")
[13:21:40.987]                   }
[13:21:40.987]                 }
[13:21:40.987]             }
[13:21:40.987]         }))
[13:21:40.987]     }, error = function(ex) {
[13:21:40.987]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:40.987]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:40.987]                 ...future.rng), started = ...future.startTime, 
[13:21:40.987]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:40.987]             version = "1.8"), class = "FutureResult")
[13:21:40.987]     }, finally = {
[13:21:40.987]         if (!identical(...future.workdir, getwd())) 
[13:21:40.987]             setwd(...future.workdir)
[13:21:40.987]         {
[13:21:40.987]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:40.987]                 ...future.oldOptions$nwarnings <- NULL
[13:21:40.987]             }
[13:21:40.987]             base::options(...future.oldOptions)
[13:21:40.987]             if (.Platform$OS.type == "windows") {
[13:21:40.987]                 old_names <- names(...future.oldEnvVars)
[13:21:40.987]                 envs <- base::Sys.getenv()
[13:21:40.987]                 names <- names(envs)
[13:21:40.987]                 common <- intersect(names, old_names)
[13:21:40.987]                 added <- setdiff(names, old_names)
[13:21:40.987]                 removed <- setdiff(old_names, names)
[13:21:40.987]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:40.987]                   envs[common]]
[13:21:40.987]                 NAMES <- toupper(changed)
[13:21:40.987]                 args <- list()
[13:21:40.987]                 for (kk in seq_along(NAMES)) {
[13:21:40.987]                   name <- changed[[kk]]
[13:21:40.987]                   NAME <- NAMES[[kk]]
[13:21:40.987]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.987]                     next
[13:21:40.987]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:40.987]                 }
[13:21:40.987]                 NAMES <- toupper(added)
[13:21:40.987]                 for (kk in seq_along(NAMES)) {
[13:21:40.987]                   name <- added[[kk]]
[13:21:40.987]                   NAME <- NAMES[[kk]]
[13:21:40.987]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.987]                     next
[13:21:40.987]                   args[[name]] <- ""
[13:21:40.987]                 }
[13:21:40.987]                 NAMES <- toupper(removed)
[13:21:40.987]                 for (kk in seq_along(NAMES)) {
[13:21:40.987]                   name <- removed[[kk]]
[13:21:40.987]                   NAME <- NAMES[[kk]]
[13:21:40.987]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:40.987]                     next
[13:21:40.987]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:40.987]                 }
[13:21:40.987]                 if (length(args) > 0) 
[13:21:40.987]                   base::do.call(base::Sys.setenv, args = args)
[13:21:40.987]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:40.987]             }
[13:21:40.987]             else {
[13:21:40.987]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:40.987]             }
[13:21:40.987]             {
[13:21:40.987]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:40.987]                   0L) {
[13:21:40.987]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:40.987]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:40.987]                   base::options(opts)
[13:21:40.987]                 }
[13:21:40.987]                 {
[13:21:40.987]                   {
[13:21:40.987]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:40.987]                     NULL
[13:21:40.987]                   }
[13:21:40.987]                   options(future.plan = NULL)
[13:21:40.987]                   if (is.na(NA_character_)) 
[13:21:40.987]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:40.987]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:40.987]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:40.987]                     envir = parent.frame()) 
[13:21:40.987]                   {
[13:21:40.987]                     default_workers <- missing(workers)
[13:21:40.987]                     if (is.function(workers)) 
[13:21:40.987]                       workers <- workers()
[13:21:40.987]                     workers <- structure(as.integer(workers), 
[13:21:40.987]                       class = class(workers))
[13:21:40.987]                     stop_if_not(is.finite(workers), workers >= 
[13:21:40.987]                       1L)
[13:21:40.987]                     if ((workers == 1L && !inherits(workers, 
[13:21:40.987]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:40.987]                       if (default_workers) 
[13:21:40.987]                         supportsMulticore(warn = TRUE)
[13:21:40.987]                       return(sequential(..., envir = envir))
[13:21:40.987]                     }
[13:21:40.987]                     oopts <- options(mc.cores = workers)
[13:21:40.987]                     on.exit(options(oopts))
[13:21:40.987]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:40.987]                       envir = envir)
[13:21:40.987]                     if (!future$lazy) 
[13:21:40.987]                       future <- run(future)
[13:21:40.987]                     invisible(future)
[13:21:40.987]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:40.987]                 }
[13:21:40.987]             }
[13:21:40.987]         }
[13:21:40.987]     })
[13:21:40.987]     if (TRUE) {
[13:21:40.987]         base::sink(type = "output", split = FALSE)
[13:21:40.987]         if (TRUE) {
[13:21:40.987]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:40.987]         }
[13:21:40.987]         else {
[13:21:40.987]             ...future.result["stdout"] <- base::list(NULL)
[13:21:40.987]         }
[13:21:40.987]         base::close(...future.stdout)
[13:21:40.987]         ...future.stdout <- NULL
[13:21:40.987]     }
[13:21:40.987]     ...future.result$conditions <- ...future.conditions
[13:21:40.987]     ...future.result$finished <- base::Sys.time()
[13:21:40.987]     ...future.result
[13:21:40.987] }
[13:21:40.990] assign_globals() ...
[13:21:40.990] List of 1
[13:21:40.990]  $ kk: int 1
[13:21:40.990]  - attr(*, "where")=List of 1
[13:21:40.990]   ..$ kk:<environment: R_EmptyEnv> 
[13:21:40.990]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:40.990]  - attr(*, "resolved")= logi FALSE
[13:21:40.990]  - attr(*, "total_size")= num 56
[13:21:40.990]  - attr(*, "already-done")= logi TRUE
[13:21:40.995] - copied ‘kk’ to environment
[13:21:40.995] assign_globals() ... done
[13:21:40.995] requestCore(): workers = 2
[13:21:40.995] Poll #1 (0): usedCores() = 2, workers = 2
[13:21:41.009] MulticoreFuture started
[13:21:41.009] - Launch lazy future ... done
[13:21:41.010] run() for ‘MulticoreFuture’ ... done
[13:21:41.010] getGlobalsAndPackages() ...
[13:21:41.010] plan(): Setting new future strategy stack:
[13:21:41.010] Searching for globals...
[13:21:41.010] List of future strategies:
[13:21:41.010] 1. sequential:
[13:21:41.010]    - args: function (..., envir = parent.frame())
[13:21:41.010]    - tweaked: FALSE
[13:21:41.010]    - call: NULL
[13:21:41.012] plan(): nbrOfWorkers() = 1
[13:21:41.014] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:21:41.014] Searching for globals ... DONE
[13:21:41.014] Resolving globals: FALSE
[13:21:41.015] The total size of the 1 globals is 56 bytes (56 bytes)
[13:21:41.016] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:21:41.016] - globals: [1] ‘kk’
[13:21:41.016] 
[13:21:41.016] getGlobalsAndPackages() ... DONE
[13:21:41.017] run() for ‘Future’ ...
[13:21:41.017] - state: ‘created’
[13:21:41.017] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:41.022] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:41.023] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:41.023]   - Field: ‘label’
[13:21:41.023]   - Field: ‘local’
[13:21:41.023]   - Field: ‘owner’
[13:21:41.023]   - Field: ‘envir’
[13:21:41.023]   - Field: ‘workers’
[13:21:41.024]   - Field: ‘packages’
[13:21:41.024]   - Field: ‘gc’
[13:21:41.024]   - Field: ‘job’
[13:21:41.024]   - Field: ‘conditions’
[13:21:41.024]   - Field: ‘expr’
[13:21:41.024]   - Field: ‘uuid’
[13:21:41.024]   - Field: ‘seed’
[13:21:41.025]   - Field: ‘version’
[13:21:41.025]   - Field: ‘result’
[13:21:41.025]   - Field: ‘asynchronous’
[13:21:41.025]   - Field: ‘calls’
[13:21:41.025]   - Field: ‘globals’
[13:21:41.025]   - Field: ‘stdout’
[13:21:41.026]   - Field: ‘earlySignal’
[13:21:41.026]   - Field: ‘lazy’
[13:21:41.026]   - Field: ‘state’
[13:21:41.026] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:41.026] - Launch lazy future ...
[13:21:41.027] Packages needed by the future expression (n = 0): <none>
[13:21:41.027] Packages needed by future strategies (n = 0): <none>
[13:21:41.028] {
[13:21:41.028]     {
[13:21:41.028]         {
[13:21:41.028]             ...future.startTime <- base::Sys.time()
[13:21:41.028]             {
[13:21:41.028]                 {
[13:21:41.028]                   {
[13:21:41.028]                     {
[13:21:41.028]                       base::local({
[13:21:41.028]                         has_future <- base::requireNamespace("future", 
[13:21:41.028]                           quietly = TRUE)
[13:21:41.028]                         if (has_future) {
[13:21:41.028]                           ns <- base::getNamespace("future")
[13:21:41.028]                           version <- ns[[".package"]][["version"]]
[13:21:41.028]                           if (is.null(version)) 
[13:21:41.028]                             version <- utils::packageVersion("future")
[13:21:41.028]                         }
[13:21:41.028]                         else {
[13:21:41.028]                           version <- NULL
[13:21:41.028]                         }
[13:21:41.028]                         if (!has_future || version < "1.8.0") {
[13:21:41.028]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:41.028]                             "", base::R.version$version.string), 
[13:21:41.028]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:41.028]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:41.028]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:41.028]                               "release", "version")], collapse = " "), 
[13:21:41.028]                             hostname = base::Sys.info()[["nodename"]])
[13:21:41.028]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:41.028]                             info)
[13:21:41.028]                           info <- base::paste(info, collapse = "; ")
[13:21:41.028]                           if (!has_future) {
[13:21:41.028]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:41.028]                               info)
[13:21:41.028]                           }
[13:21:41.028]                           else {
[13:21:41.028]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:41.028]                               info, version)
[13:21:41.028]                           }
[13:21:41.028]                           base::stop(msg)
[13:21:41.028]                         }
[13:21:41.028]                       })
[13:21:41.028]                     }
[13:21:41.028]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:41.028]                     base::options(mc.cores = 1L)
[13:21:41.028]                   }
[13:21:41.028]                   options(future.plan = NULL)
[13:21:41.028]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.028]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:41.028]                 }
[13:21:41.028]                 ...future.workdir <- getwd()
[13:21:41.028]             }
[13:21:41.028]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:41.028]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:41.028]         }
[13:21:41.028]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:41.028]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:41.028]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:41.028]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:41.028]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:41.028]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:41.028]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:41.028]             base::names(...future.oldOptions))
[13:21:41.028]     }
[13:21:41.028]     if (FALSE) {
[13:21:41.028]     }
[13:21:41.028]     else {
[13:21:41.028]         if (TRUE) {
[13:21:41.028]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:41.028]                 open = "w")
[13:21:41.028]         }
[13:21:41.028]         else {
[13:21:41.028]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:41.028]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:41.028]         }
[13:21:41.028]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:41.028]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:41.028]             base::sink(type = "output", split = FALSE)
[13:21:41.028]             base::close(...future.stdout)
[13:21:41.028]         }, add = TRUE)
[13:21:41.028]     }
[13:21:41.028]     ...future.frame <- base::sys.nframe()
[13:21:41.028]     ...future.conditions <- base::list()
[13:21:41.028]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:41.028]     if (FALSE) {
[13:21:41.028]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:41.028]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:41.028]     }
[13:21:41.028]     ...future.result <- base::tryCatch({
[13:21:41.028]         base::withCallingHandlers({
[13:21:41.028]             ...future.value <- base::withVisible(base::local({
[13:21:41.028]                 withCallingHandlers({
[13:21:41.028]                   {
[13:21:41.028]                     Sys.sleep(0.1)
[13:21:41.028]                     kk
[13:21:41.028]                   }
[13:21:41.028]                 }, immediateCondition = function(cond) {
[13:21:41.028]                   save_rds <- function (object, pathname, ...) 
[13:21:41.028]                   {
[13:21:41.028]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:41.028]                     if (file_test("-f", pathname_tmp)) {
[13:21:41.028]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.028]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:41.028]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.028]                         fi_tmp[["mtime"]])
[13:21:41.028]                     }
[13:21:41.028]                     tryCatch({
[13:21:41.028]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:41.028]                     }, error = function(ex) {
[13:21:41.028]                       msg <- conditionMessage(ex)
[13:21:41.028]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.028]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:41.028]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.028]                         fi_tmp[["mtime"]], msg)
[13:21:41.028]                       ex$message <- msg
[13:21:41.028]                       stop(ex)
[13:21:41.028]                     })
[13:21:41.028]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:41.028]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:41.028]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:41.028]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.028]                       fi <- file.info(pathname)
[13:21:41.028]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:41.028]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.028]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:41.028]                         fi[["size"]], fi[["mtime"]])
[13:21:41.028]                       stop(msg)
[13:21:41.028]                     }
[13:21:41.028]                     invisible(pathname)
[13:21:41.028]                   }
[13:21:41.028]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:41.028]                     rootPath = tempdir()) 
[13:21:41.028]                   {
[13:21:41.028]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:41.028]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:41.028]                       tmpdir = path, fileext = ".rds")
[13:21:41.028]                     save_rds(obj, file)
[13:21:41.028]                   }
[13:21:41.028]                   saveImmediateCondition(cond, path = "/tmp/RtmpRIPAyw/.future/immediateConditions")
[13:21:41.028]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.028]                   {
[13:21:41.028]                     inherits <- base::inherits
[13:21:41.028]                     invokeRestart <- base::invokeRestart
[13:21:41.028]                     is.null <- base::is.null
[13:21:41.028]                     muffled <- FALSE
[13:21:41.028]                     if (inherits(cond, "message")) {
[13:21:41.028]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:41.028]                       if (muffled) 
[13:21:41.028]                         invokeRestart("muffleMessage")
[13:21:41.028]                     }
[13:21:41.028]                     else if (inherits(cond, "warning")) {
[13:21:41.028]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:41.028]                       if (muffled) 
[13:21:41.028]                         invokeRestart("muffleWarning")
[13:21:41.028]                     }
[13:21:41.028]                     else if (inherits(cond, "condition")) {
[13:21:41.028]                       if (!is.null(pattern)) {
[13:21:41.028]                         computeRestarts <- base::computeRestarts
[13:21:41.028]                         grepl <- base::grepl
[13:21:41.028]                         restarts <- computeRestarts(cond)
[13:21:41.028]                         for (restart in restarts) {
[13:21:41.028]                           name <- restart$name
[13:21:41.028]                           if (is.null(name)) 
[13:21:41.028]                             next
[13:21:41.028]                           if (!grepl(pattern, name)) 
[13:21:41.028]                             next
[13:21:41.028]                           invokeRestart(restart)
[13:21:41.028]                           muffled <- TRUE
[13:21:41.028]                           break
[13:21:41.028]                         }
[13:21:41.028]                       }
[13:21:41.028]                     }
[13:21:41.028]                     invisible(muffled)
[13:21:41.028]                   }
[13:21:41.028]                   muffleCondition(cond)
[13:21:41.028]                 })
[13:21:41.028]             }))
[13:21:41.028]             future::FutureResult(value = ...future.value$value, 
[13:21:41.028]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.028]                   ...future.rng), globalenv = if (FALSE) 
[13:21:41.028]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:41.028]                     ...future.globalenv.names))
[13:21:41.028]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:41.028]         }, condition = base::local({
[13:21:41.028]             c <- base::c
[13:21:41.028]             inherits <- base::inherits
[13:21:41.028]             invokeRestart <- base::invokeRestart
[13:21:41.028]             length <- base::length
[13:21:41.028]             list <- base::list
[13:21:41.028]             seq.int <- base::seq.int
[13:21:41.028]             signalCondition <- base::signalCondition
[13:21:41.028]             sys.calls <- base::sys.calls
[13:21:41.028]             `[[` <- base::`[[`
[13:21:41.028]             `+` <- base::`+`
[13:21:41.028]             `<<-` <- base::`<<-`
[13:21:41.028]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:41.028]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:41.028]                   3L)]
[13:21:41.028]             }
[13:21:41.028]             function(cond) {
[13:21:41.028]                 is_error <- inherits(cond, "error")
[13:21:41.028]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:41.028]                   NULL)
[13:21:41.028]                 if (is_error) {
[13:21:41.028]                   sessionInformation <- function() {
[13:21:41.028]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:41.028]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:41.028]                       search = base::search(), system = base::Sys.info())
[13:21:41.028]                   }
[13:21:41.028]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.028]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:41.028]                     cond$call), session = sessionInformation(), 
[13:21:41.028]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:41.028]                   signalCondition(cond)
[13:21:41.028]                 }
[13:21:41.028]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:41.028]                 "immediateCondition"))) {
[13:21:41.028]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:41.028]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.028]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:41.028]                   if (TRUE && !signal) {
[13:21:41.028]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.028]                     {
[13:21:41.028]                       inherits <- base::inherits
[13:21:41.028]                       invokeRestart <- base::invokeRestart
[13:21:41.028]                       is.null <- base::is.null
[13:21:41.028]                       muffled <- FALSE
[13:21:41.028]                       if (inherits(cond, "message")) {
[13:21:41.028]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.028]                         if (muffled) 
[13:21:41.028]                           invokeRestart("muffleMessage")
[13:21:41.028]                       }
[13:21:41.028]                       else if (inherits(cond, "warning")) {
[13:21:41.028]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.028]                         if (muffled) 
[13:21:41.028]                           invokeRestart("muffleWarning")
[13:21:41.028]                       }
[13:21:41.028]                       else if (inherits(cond, "condition")) {
[13:21:41.028]                         if (!is.null(pattern)) {
[13:21:41.028]                           computeRestarts <- base::computeRestarts
[13:21:41.028]                           grepl <- base::grepl
[13:21:41.028]                           restarts <- computeRestarts(cond)
[13:21:41.028]                           for (restart in restarts) {
[13:21:41.028]                             name <- restart$name
[13:21:41.028]                             if (is.null(name)) 
[13:21:41.028]                               next
[13:21:41.028]                             if (!grepl(pattern, name)) 
[13:21:41.028]                               next
[13:21:41.028]                             invokeRestart(restart)
[13:21:41.028]                             muffled <- TRUE
[13:21:41.028]                             break
[13:21:41.028]                           }
[13:21:41.028]                         }
[13:21:41.028]                       }
[13:21:41.028]                       invisible(muffled)
[13:21:41.028]                     }
[13:21:41.028]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.028]                   }
[13:21:41.028]                 }
[13:21:41.028]                 else {
[13:21:41.028]                   if (TRUE) {
[13:21:41.028]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.028]                     {
[13:21:41.028]                       inherits <- base::inherits
[13:21:41.028]                       invokeRestart <- base::invokeRestart
[13:21:41.028]                       is.null <- base::is.null
[13:21:41.028]                       muffled <- FALSE
[13:21:41.028]                       if (inherits(cond, "message")) {
[13:21:41.028]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.028]                         if (muffled) 
[13:21:41.028]                           invokeRestart("muffleMessage")
[13:21:41.028]                       }
[13:21:41.028]                       else if (inherits(cond, "warning")) {
[13:21:41.028]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.028]                         if (muffled) 
[13:21:41.028]                           invokeRestart("muffleWarning")
[13:21:41.028]                       }
[13:21:41.028]                       else if (inherits(cond, "condition")) {
[13:21:41.028]                         if (!is.null(pattern)) {
[13:21:41.028]                           computeRestarts <- base::computeRestarts
[13:21:41.028]                           grepl <- base::grepl
[13:21:41.028]                           restarts <- computeRestarts(cond)
[13:21:41.028]                           for (restart in restarts) {
[13:21:41.028]                             name <- restart$name
[13:21:41.028]                             if (is.null(name)) 
[13:21:41.028]                               next
[13:21:41.028]                             if (!grepl(pattern, name)) 
[13:21:41.028]                               next
[13:21:41.028]                             invokeRestart(restart)
[13:21:41.028]                             muffled <- TRUE
[13:21:41.028]                             break
[13:21:41.028]                           }
[13:21:41.028]                         }
[13:21:41.028]                       }
[13:21:41.028]                       invisible(muffled)
[13:21:41.028]                     }
[13:21:41.028]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.028]                   }
[13:21:41.028]                 }
[13:21:41.028]             }
[13:21:41.028]         }))
[13:21:41.028]     }, error = function(ex) {
[13:21:41.028]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:41.028]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.028]                 ...future.rng), started = ...future.startTime, 
[13:21:41.028]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:41.028]             version = "1.8"), class = "FutureResult")
[13:21:41.028]     }, finally = {
[13:21:41.028]         if (!identical(...future.workdir, getwd())) 
[13:21:41.028]             setwd(...future.workdir)
[13:21:41.028]         {
[13:21:41.028]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:41.028]                 ...future.oldOptions$nwarnings <- NULL
[13:21:41.028]             }
[13:21:41.028]             base::options(...future.oldOptions)
[13:21:41.028]             if (.Platform$OS.type == "windows") {
[13:21:41.028]                 old_names <- names(...future.oldEnvVars)
[13:21:41.028]                 envs <- base::Sys.getenv()
[13:21:41.028]                 names <- names(envs)
[13:21:41.028]                 common <- intersect(names, old_names)
[13:21:41.028]                 added <- setdiff(names, old_names)
[13:21:41.028]                 removed <- setdiff(old_names, names)
[13:21:41.028]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:41.028]                   envs[common]]
[13:21:41.028]                 NAMES <- toupper(changed)
[13:21:41.028]                 args <- list()
[13:21:41.028]                 for (kk in seq_along(NAMES)) {
[13:21:41.028]                   name <- changed[[kk]]
[13:21:41.028]                   NAME <- NAMES[[kk]]
[13:21:41.028]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.028]                     next
[13:21:41.028]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.028]                 }
[13:21:41.028]                 NAMES <- toupper(added)
[13:21:41.028]                 for (kk in seq_along(NAMES)) {
[13:21:41.028]                   name <- added[[kk]]
[13:21:41.028]                   NAME <- NAMES[[kk]]
[13:21:41.028]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.028]                     next
[13:21:41.028]                   args[[name]] <- ""
[13:21:41.028]                 }
[13:21:41.028]                 NAMES <- toupper(removed)
[13:21:41.028]                 for (kk in seq_along(NAMES)) {
[13:21:41.028]                   name <- removed[[kk]]
[13:21:41.028]                   NAME <- NAMES[[kk]]
[13:21:41.028]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.028]                     next
[13:21:41.028]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.028]                 }
[13:21:41.028]                 if (length(args) > 0) 
[13:21:41.028]                   base::do.call(base::Sys.setenv, args = args)
[13:21:41.028]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:41.028]             }
[13:21:41.028]             else {
[13:21:41.028]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:41.028]             }
[13:21:41.028]             {
[13:21:41.028]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:41.028]                   0L) {
[13:21:41.028]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:41.028]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:41.028]                   base::options(opts)
[13:21:41.028]                 }
[13:21:41.028]                 {
[13:21:41.028]                   {
[13:21:41.028]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:41.028]                     NULL
[13:21:41.028]                   }
[13:21:41.028]                   options(future.plan = NULL)
[13:21:41.028]                   if (is.na(NA_character_)) 
[13:21:41.028]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.028]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:41.028]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:41.028]                     envir = parent.frame()) 
[13:21:41.028]                   {
[13:21:41.028]                     default_workers <- missing(workers)
[13:21:41.028]                     if (is.function(workers)) 
[13:21:41.028]                       workers <- workers()
[13:21:41.028]                     workers <- structure(as.integer(workers), 
[13:21:41.028]                       class = class(workers))
[13:21:41.028]                     stop_if_not(is.finite(workers), workers >= 
[13:21:41.028]                       1L)
[13:21:41.028]                     if ((workers == 1L && !inherits(workers, 
[13:21:41.028]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:41.028]                       if (default_workers) 
[13:21:41.028]                         supportsMulticore(warn = TRUE)
[13:21:41.028]                       return(sequential(..., envir = envir))
[13:21:41.028]                     }
[13:21:41.028]                     oopts <- options(mc.cores = workers)
[13:21:41.028]                     on.exit(options(oopts))
[13:21:41.028]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:41.028]                       envir = envir)
[13:21:41.028]                     if (!future$lazy) 
[13:21:41.028]                       future <- run(future)
[13:21:41.028]                     invisible(future)
[13:21:41.028]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:41.028]                 }
[13:21:41.028]             }
[13:21:41.028]         }
[13:21:41.028]     })
[13:21:41.028]     if (TRUE) {
[13:21:41.028]         base::sink(type = "output", split = FALSE)
[13:21:41.028]         if (TRUE) {
[13:21:41.028]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:41.028]         }
[13:21:41.028]         else {
[13:21:41.028]             ...future.result["stdout"] <- base::list(NULL)
[13:21:41.028]         }
[13:21:41.028]         base::close(...future.stdout)
[13:21:41.028]         ...future.stdout <- NULL
[13:21:41.028]     }
[13:21:41.028]     ...future.result$conditions <- ...future.conditions
[13:21:41.028]     ...future.result$finished <- base::Sys.time()
[13:21:41.028]     ...future.result
[13:21:41.028] }
[13:21:41.031] assign_globals() ...
[13:21:41.031] List of 1
[13:21:41.031]  $ kk: int 2
[13:21:41.031]  - attr(*, "where")=List of 1
[13:21:41.031]   ..$ kk:<environment: R_EmptyEnv> 
[13:21:41.031]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:41.031]  - attr(*, "resolved")= logi FALSE
[13:21:41.031]  - attr(*, "total_size")= num 56
[13:21:41.031]  - attr(*, "already-done")= logi TRUE
[13:21:41.035] - copied ‘kk’ to environment
[13:21:41.036] assign_globals() ... done
[13:21:41.036] requestCore(): workers = 2
[13:21:41.036] Poll #1 (0): usedCores() = 2, workers = 2
[13:21:41.054] MulticoreFuture started
[13:21:41.055] - Launch lazy future ... done
[13:21:41.056] plan(): Setting new future strategy stack:
[13:21:41.055] run() for ‘MulticoreFuture’ ... done
[13:21:41.056] getGlobalsAndPackages() ...
[13:21:41.057] Searching for globals...
[13:21:41.056] List of future strategies:
[13:21:41.056] 1. sequential:
[13:21:41.056]    - args: function (..., envir = parent.frame())
[13:21:41.056]    - tweaked: FALSE
[13:21:41.056]    - call: NULL
[13:21:41.058] plan(): nbrOfWorkers() = 1
[13:21:41.061] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:21:41.062] Searching for globals ... DONE
[13:21:41.062] Resolving globals: FALSE
[13:21:41.063] The total size of the 1 globals is 56 bytes (56 bytes)
[13:21:41.064] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:21:41.064] - globals: [1] ‘kk’
[13:21:41.064] 
[13:21:41.064] getGlobalsAndPackages() ... DONE
[13:21:41.065] run() for ‘Future’ ...
[13:21:41.065] - state: ‘created’
[13:21:41.065] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:41.071] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:41.071] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:41.071]   - Field: ‘label’
[13:21:41.072]   - Field: ‘local’
[13:21:41.072]   - Field: ‘owner’
[13:21:41.072]   - Field: ‘envir’
[13:21:41.072]   - Field: ‘workers’
[13:21:41.072]   - Field: ‘packages’
[13:21:41.073]   - Field: ‘gc’
[13:21:41.073]   - Field: ‘job’
[13:21:41.073]   - Field: ‘conditions’
[13:21:41.073]   - Field: ‘expr’
[13:21:41.073]   - Field: ‘uuid’
[13:21:41.073]   - Field: ‘seed’
[13:21:41.074]   - Field: ‘version’
[13:21:41.074]   - Field: ‘result’
[13:21:41.074]   - Field: ‘asynchronous’
[13:21:41.074]   - Field: ‘calls’
[13:21:41.074]   - Field: ‘globals’
[13:21:41.075]   - Field: ‘stdout’
[13:21:41.075]   - Field: ‘earlySignal’
[13:21:41.075]   - Field: ‘lazy’
[13:21:41.075]   - Field: ‘state’
[13:21:41.075] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:41.075] - Launch lazy future ...
[13:21:41.076] Packages needed by the future expression (n = 0): <none>
[13:21:41.076] Packages needed by future strategies (n = 0): <none>
[13:21:41.077] {
[13:21:41.077]     {
[13:21:41.077]         {
[13:21:41.077]             ...future.startTime <- base::Sys.time()
[13:21:41.077]             {
[13:21:41.077]                 {
[13:21:41.077]                   {
[13:21:41.077]                     {
[13:21:41.077]                       base::local({
[13:21:41.077]                         has_future <- base::requireNamespace("future", 
[13:21:41.077]                           quietly = TRUE)
[13:21:41.077]                         if (has_future) {
[13:21:41.077]                           ns <- base::getNamespace("future")
[13:21:41.077]                           version <- ns[[".package"]][["version"]]
[13:21:41.077]                           if (is.null(version)) 
[13:21:41.077]                             version <- utils::packageVersion("future")
[13:21:41.077]                         }
[13:21:41.077]                         else {
[13:21:41.077]                           version <- NULL
[13:21:41.077]                         }
[13:21:41.077]                         if (!has_future || version < "1.8.0") {
[13:21:41.077]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:41.077]                             "", base::R.version$version.string), 
[13:21:41.077]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:41.077]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:41.077]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:41.077]                               "release", "version")], collapse = " "), 
[13:21:41.077]                             hostname = base::Sys.info()[["nodename"]])
[13:21:41.077]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:41.077]                             info)
[13:21:41.077]                           info <- base::paste(info, collapse = "; ")
[13:21:41.077]                           if (!has_future) {
[13:21:41.077]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:41.077]                               info)
[13:21:41.077]                           }
[13:21:41.077]                           else {
[13:21:41.077]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:41.077]                               info, version)
[13:21:41.077]                           }
[13:21:41.077]                           base::stop(msg)
[13:21:41.077]                         }
[13:21:41.077]                       })
[13:21:41.077]                     }
[13:21:41.077]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:41.077]                     base::options(mc.cores = 1L)
[13:21:41.077]                   }
[13:21:41.077]                   options(future.plan = NULL)
[13:21:41.077]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.077]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:41.077]                 }
[13:21:41.077]                 ...future.workdir <- getwd()
[13:21:41.077]             }
[13:21:41.077]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:41.077]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:41.077]         }
[13:21:41.077]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:41.077]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:41.077]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:41.077]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:41.077]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:41.077]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:41.077]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:41.077]             base::names(...future.oldOptions))
[13:21:41.077]     }
[13:21:41.077]     if (FALSE) {
[13:21:41.077]     }
[13:21:41.077]     else {
[13:21:41.077]         if (TRUE) {
[13:21:41.077]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:41.077]                 open = "w")
[13:21:41.077]         }
[13:21:41.077]         else {
[13:21:41.077]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:41.077]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:41.077]         }
[13:21:41.077]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:41.077]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:41.077]             base::sink(type = "output", split = FALSE)
[13:21:41.077]             base::close(...future.stdout)
[13:21:41.077]         }, add = TRUE)
[13:21:41.077]     }
[13:21:41.077]     ...future.frame <- base::sys.nframe()
[13:21:41.077]     ...future.conditions <- base::list()
[13:21:41.077]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:41.077]     if (FALSE) {
[13:21:41.077]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:41.077]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:41.077]     }
[13:21:41.077]     ...future.result <- base::tryCatch({
[13:21:41.077]         base::withCallingHandlers({
[13:21:41.077]             ...future.value <- base::withVisible(base::local({
[13:21:41.077]                 withCallingHandlers({
[13:21:41.077]                   {
[13:21:41.077]                     Sys.sleep(0.1)
[13:21:41.077]                     kk
[13:21:41.077]                   }
[13:21:41.077]                 }, immediateCondition = function(cond) {
[13:21:41.077]                   save_rds <- function (object, pathname, ...) 
[13:21:41.077]                   {
[13:21:41.077]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:41.077]                     if (file_test("-f", pathname_tmp)) {
[13:21:41.077]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.077]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:41.077]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.077]                         fi_tmp[["mtime"]])
[13:21:41.077]                     }
[13:21:41.077]                     tryCatch({
[13:21:41.077]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:41.077]                     }, error = function(ex) {
[13:21:41.077]                       msg <- conditionMessage(ex)
[13:21:41.077]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.077]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:41.077]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.077]                         fi_tmp[["mtime"]], msg)
[13:21:41.077]                       ex$message <- msg
[13:21:41.077]                       stop(ex)
[13:21:41.077]                     })
[13:21:41.077]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:41.077]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:41.077]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:41.077]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.077]                       fi <- file.info(pathname)
[13:21:41.077]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:41.077]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.077]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:41.077]                         fi[["size"]], fi[["mtime"]])
[13:21:41.077]                       stop(msg)
[13:21:41.077]                     }
[13:21:41.077]                     invisible(pathname)
[13:21:41.077]                   }
[13:21:41.077]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:41.077]                     rootPath = tempdir()) 
[13:21:41.077]                   {
[13:21:41.077]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:41.077]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:41.077]                       tmpdir = path, fileext = ".rds")
[13:21:41.077]                     save_rds(obj, file)
[13:21:41.077]                   }
[13:21:41.077]                   saveImmediateCondition(cond, path = "/tmp/RtmpRIPAyw/.future/immediateConditions")
[13:21:41.077]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.077]                   {
[13:21:41.077]                     inherits <- base::inherits
[13:21:41.077]                     invokeRestart <- base::invokeRestart
[13:21:41.077]                     is.null <- base::is.null
[13:21:41.077]                     muffled <- FALSE
[13:21:41.077]                     if (inherits(cond, "message")) {
[13:21:41.077]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:41.077]                       if (muffled) 
[13:21:41.077]                         invokeRestart("muffleMessage")
[13:21:41.077]                     }
[13:21:41.077]                     else if (inherits(cond, "warning")) {
[13:21:41.077]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:41.077]                       if (muffled) 
[13:21:41.077]                         invokeRestart("muffleWarning")
[13:21:41.077]                     }
[13:21:41.077]                     else if (inherits(cond, "condition")) {
[13:21:41.077]                       if (!is.null(pattern)) {
[13:21:41.077]                         computeRestarts <- base::computeRestarts
[13:21:41.077]                         grepl <- base::grepl
[13:21:41.077]                         restarts <- computeRestarts(cond)
[13:21:41.077]                         for (restart in restarts) {
[13:21:41.077]                           name <- restart$name
[13:21:41.077]                           if (is.null(name)) 
[13:21:41.077]                             next
[13:21:41.077]                           if (!grepl(pattern, name)) 
[13:21:41.077]                             next
[13:21:41.077]                           invokeRestart(restart)
[13:21:41.077]                           muffled <- TRUE
[13:21:41.077]                           break
[13:21:41.077]                         }
[13:21:41.077]                       }
[13:21:41.077]                     }
[13:21:41.077]                     invisible(muffled)
[13:21:41.077]                   }
[13:21:41.077]                   muffleCondition(cond)
[13:21:41.077]                 })
[13:21:41.077]             }))
[13:21:41.077]             future::FutureResult(value = ...future.value$value, 
[13:21:41.077]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.077]                   ...future.rng), globalenv = if (FALSE) 
[13:21:41.077]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:41.077]                     ...future.globalenv.names))
[13:21:41.077]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:41.077]         }, condition = base::local({
[13:21:41.077]             c <- base::c
[13:21:41.077]             inherits <- base::inherits
[13:21:41.077]             invokeRestart <- base::invokeRestart
[13:21:41.077]             length <- base::length
[13:21:41.077]             list <- base::list
[13:21:41.077]             seq.int <- base::seq.int
[13:21:41.077]             signalCondition <- base::signalCondition
[13:21:41.077]             sys.calls <- base::sys.calls
[13:21:41.077]             `[[` <- base::`[[`
[13:21:41.077]             `+` <- base::`+`
[13:21:41.077]             `<<-` <- base::`<<-`
[13:21:41.077]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:41.077]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:41.077]                   3L)]
[13:21:41.077]             }
[13:21:41.077]             function(cond) {
[13:21:41.077]                 is_error <- inherits(cond, "error")
[13:21:41.077]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:41.077]                   NULL)
[13:21:41.077]                 if (is_error) {
[13:21:41.077]                   sessionInformation <- function() {
[13:21:41.077]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:41.077]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:41.077]                       search = base::search(), system = base::Sys.info())
[13:21:41.077]                   }
[13:21:41.077]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.077]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:41.077]                     cond$call), session = sessionInformation(), 
[13:21:41.077]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:41.077]                   signalCondition(cond)
[13:21:41.077]                 }
[13:21:41.077]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:41.077]                 "immediateCondition"))) {
[13:21:41.077]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:41.077]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.077]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:41.077]                   if (TRUE && !signal) {
[13:21:41.077]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.077]                     {
[13:21:41.077]                       inherits <- base::inherits
[13:21:41.077]                       invokeRestart <- base::invokeRestart
[13:21:41.077]                       is.null <- base::is.null
[13:21:41.077]                       muffled <- FALSE
[13:21:41.077]                       if (inherits(cond, "message")) {
[13:21:41.077]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.077]                         if (muffled) 
[13:21:41.077]                           invokeRestart("muffleMessage")
[13:21:41.077]                       }
[13:21:41.077]                       else if (inherits(cond, "warning")) {
[13:21:41.077]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.077]                         if (muffled) 
[13:21:41.077]                           invokeRestart("muffleWarning")
[13:21:41.077]                       }
[13:21:41.077]                       else if (inherits(cond, "condition")) {
[13:21:41.077]                         if (!is.null(pattern)) {
[13:21:41.077]                           computeRestarts <- base::computeRestarts
[13:21:41.077]                           grepl <- base::grepl
[13:21:41.077]                           restarts <- computeRestarts(cond)
[13:21:41.077]                           for (restart in restarts) {
[13:21:41.077]                             name <- restart$name
[13:21:41.077]                             if (is.null(name)) 
[13:21:41.077]                               next
[13:21:41.077]                             if (!grepl(pattern, name)) 
[13:21:41.077]                               next
[13:21:41.077]                             invokeRestart(restart)
[13:21:41.077]                             muffled <- TRUE
[13:21:41.077]                             break
[13:21:41.077]                           }
[13:21:41.077]                         }
[13:21:41.077]                       }
[13:21:41.077]                       invisible(muffled)
[13:21:41.077]                     }
[13:21:41.077]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.077]                   }
[13:21:41.077]                 }
[13:21:41.077]                 else {
[13:21:41.077]                   if (TRUE) {
[13:21:41.077]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.077]                     {
[13:21:41.077]                       inherits <- base::inherits
[13:21:41.077]                       invokeRestart <- base::invokeRestart
[13:21:41.077]                       is.null <- base::is.null
[13:21:41.077]                       muffled <- FALSE
[13:21:41.077]                       if (inherits(cond, "message")) {
[13:21:41.077]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.077]                         if (muffled) 
[13:21:41.077]                           invokeRestart("muffleMessage")
[13:21:41.077]                       }
[13:21:41.077]                       else if (inherits(cond, "warning")) {
[13:21:41.077]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.077]                         if (muffled) 
[13:21:41.077]                           invokeRestart("muffleWarning")
[13:21:41.077]                       }
[13:21:41.077]                       else if (inherits(cond, "condition")) {
[13:21:41.077]                         if (!is.null(pattern)) {
[13:21:41.077]                           computeRestarts <- base::computeRestarts
[13:21:41.077]                           grepl <- base::grepl
[13:21:41.077]                           restarts <- computeRestarts(cond)
[13:21:41.077]                           for (restart in restarts) {
[13:21:41.077]                             name <- restart$name
[13:21:41.077]                             if (is.null(name)) 
[13:21:41.077]                               next
[13:21:41.077]                             if (!grepl(pattern, name)) 
[13:21:41.077]                               next
[13:21:41.077]                             invokeRestart(restart)
[13:21:41.077]                             muffled <- TRUE
[13:21:41.077]                             break
[13:21:41.077]                           }
[13:21:41.077]                         }
[13:21:41.077]                       }
[13:21:41.077]                       invisible(muffled)
[13:21:41.077]                     }
[13:21:41.077]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.077]                   }
[13:21:41.077]                 }
[13:21:41.077]             }
[13:21:41.077]         }))
[13:21:41.077]     }, error = function(ex) {
[13:21:41.077]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:41.077]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.077]                 ...future.rng), started = ...future.startTime, 
[13:21:41.077]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:41.077]             version = "1.8"), class = "FutureResult")
[13:21:41.077]     }, finally = {
[13:21:41.077]         if (!identical(...future.workdir, getwd())) 
[13:21:41.077]             setwd(...future.workdir)
[13:21:41.077]         {
[13:21:41.077]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:41.077]                 ...future.oldOptions$nwarnings <- NULL
[13:21:41.077]             }
[13:21:41.077]             base::options(...future.oldOptions)
[13:21:41.077]             if (.Platform$OS.type == "windows") {
[13:21:41.077]                 old_names <- names(...future.oldEnvVars)
[13:21:41.077]                 envs <- base::Sys.getenv()
[13:21:41.077]                 names <- names(envs)
[13:21:41.077]                 common <- intersect(names, old_names)
[13:21:41.077]                 added <- setdiff(names, old_names)
[13:21:41.077]                 removed <- setdiff(old_names, names)
[13:21:41.077]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:41.077]                   envs[common]]
[13:21:41.077]                 NAMES <- toupper(changed)
[13:21:41.077]                 args <- list()
[13:21:41.077]                 for (kk in seq_along(NAMES)) {
[13:21:41.077]                   name <- changed[[kk]]
[13:21:41.077]                   NAME <- NAMES[[kk]]
[13:21:41.077]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.077]                     next
[13:21:41.077]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.077]                 }
[13:21:41.077]                 NAMES <- toupper(added)
[13:21:41.077]                 for (kk in seq_along(NAMES)) {
[13:21:41.077]                   name <- added[[kk]]
[13:21:41.077]                   NAME <- NAMES[[kk]]
[13:21:41.077]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.077]                     next
[13:21:41.077]                   args[[name]] <- ""
[13:21:41.077]                 }
[13:21:41.077]                 NAMES <- toupper(removed)
[13:21:41.077]                 for (kk in seq_along(NAMES)) {
[13:21:41.077]                   name <- removed[[kk]]
[13:21:41.077]                   NAME <- NAMES[[kk]]
[13:21:41.077]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.077]                     next
[13:21:41.077]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.077]                 }
[13:21:41.077]                 if (length(args) > 0) 
[13:21:41.077]                   base::do.call(base::Sys.setenv, args = args)
[13:21:41.077]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:41.077]             }
[13:21:41.077]             else {
[13:21:41.077]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:41.077]             }
[13:21:41.077]             {
[13:21:41.077]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:41.077]                   0L) {
[13:21:41.077]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:41.077]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:41.077]                   base::options(opts)
[13:21:41.077]                 }
[13:21:41.077]                 {
[13:21:41.077]                   {
[13:21:41.077]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:41.077]                     NULL
[13:21:41.077]                   }
[13:21:41.077]                   options(future.plan = NULL)
[13:21:41.077]                   if (is.na(NA_character_)) 
[13:21:41.077]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.077]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:41.077]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:41.077]                     envir = parent.frame()) 
[13:21:41.077]                   {
[13:21:41.077]                     default_workers <- missing(workers)
[13:21:41.077]                     if (is.function(workers)) 
[13:21:41.077]                       workers <- workers()
[13:21:41.077]                     workers <- structure(as.integer(workers), 
[13:21:41.077]                       class = class(workers))
[13:21:41.077]                     stop_if_not(is.finite(workers), workers >= 
[13:21:41.077]                       1L)
[13:21:41.077]                     if ((workers == 1L && !inherits(workers, 
[13:21:41.077]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:41.077]                       if (default_workers) 
[13:21:41.077]                         supportsMulticore(warn = TRUE)
[13:21:41.077]                       return(sequential(..., envir = envir))
[13:21:41.077]                     }
[13:21:41.077]                     oopts <- options(mc.cores = workers)
[13:21:41.077]                     on.exit(options(oopts))
[13:21:41.077]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:41.077]                       envir = envir)
[13:21:41.077]                     if (!future$lazy) 
[13:21:41.077]                       future <- run(future)
[13:21:41.077]                     invisible(future)
[13:21:41.077]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:41.077]                 }
[13:21:41.077]             }
[13:21:41.077]         }
[13:21:41.077]     })
[13:21:41.077]     if (TRUE) {
[13:21:41.077]         base::sink(type = "output", split = FALSE)
[13:21:41.077]         if (TRUE) {
[13:21:41.077]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:41.077]         }
[13:21:41.077]         else {
[13:21:41.077]             ...future.result["stdout"] <- base::list(NULL)
[13:21:41.077]         }
[13:21:41.077]         base::close(...future.stdout)
[13:21:41.077]         ...future.stdout <- NULL
[13:21:41.077]     }
[13:21:41.077]     ...future.result$conditions <- ...future.conditions
[13:21:41.077]     ...future.result$finished <- base::Sys.time()
[13:21:41.077]     ...future.result
[13:21:41.077] }
[13:21:41.080] assign_globals() ...
[13:21:41.081] List of 1
[13:21:41.081]  $ kk: int 3
[13:21:41.081]  - attr(*, "where")=List of 1
[13:21:41.081]   ..$ kk:<environment: R_EmptyEnv> 
[13:21:41.081]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:41.081]  - attr(*, "resolved")= logi FALSE
[13:21:41.081]  - attr(*, "total_size")= num 56
[13:21:41.081]  - attr(*, "already-done")= logi TRUE
[13:21:41.085] - copied ‘kk’ to environment
[13:21:41.085] assign_globals() ... done
[13:21:41.085] requestCore(): workers = 2
[13:21:41.085] Poll #1 (0): usedCores() = 2, workers = 2
[13:21:41.114] plan(): Setting new future strategy stack:
[13:21:41.115] List of future strategies:
[13:21:41.115] 1. multicore:
[13:21:41.115]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:41.115]    - tweaked: FALSE
[13:21:41.115]    - call: plan(strategy)
[13:21:41.117] Poll #2 (0.03 secs): usedCores() = 2, workers = 2
[13:21:41.119] plan(): nbrOfWorkers() = 2
[13:21:41.131] MulticoreFuture started
[13:21:41.132] - Launch lazy future ... done
[13:21:41.132] run() for ‘MulticoreFuture’ ... done
[13:21:41.133] resolve() on list ...
[13:21:41.133] plan(): Setting new future strategy stack:
[13:21:41.133]  recursive: 0
[13:21:41.133]  length: 3
[13:21:41.133] 
[13:21:41.133] Future #1
[13:21:41.133] List of future strategies:
[13:21:41.133] 1. sequential:
[13:21:41.133]    - args: function (..., envir = parent.frame())
[13:21:41.133]    - tweaked: FALSE
[13:21:41.133]    - call: NULL
[13:21:41.134]  length: 2 (resolved future 1)
[13:21:41.134] plan(): nbrOfWorkers() = 1
[13:21:41.161] plan(): Setting new future strategy stack:
[13:21:41.162] List of future strategies:
[13:21:41.162] 1. multicore:
[13:21:41.162]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:41.162]    - tweaked: FALSE
[13:21:41.162]    - call: plan(strategy)
[13:21:41.166] plan(): nbrOfWorkers() = 2
[13:21:41.167] Future #2
[13:21:41.167]  length: 1 (resolved future 2)
[13:21:41.237] plan(): Setting new future strategy stack:
[13:21:41.237] List of future strategies:
[13:21:41.237] 1. multicore:
[13:21:41.237]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:41.237]    - tweaked: FALSE
[13:21:41.237]    - call: plan(strategy)
[13:21:41.243] plan(): nbrOfWorkers() = 2
[13:21:41.249] Future #3
[13:21:41.249]  length: 0 (resolved future 3)
[13:21:41.249] resolve() on list ... DONE
[13:21:41.250] getGlobalsAndPackages() ...
[13:21:41.250] Searching for globals...
[13:21:41.252] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:21:41.252] Searching for globals ... DONE
[13:21:41.252] Resolving globals: FALSE
[13:21:41.253] The total size of the 1 globals is 56 bytes (56 bytes)
[13:21:41.253] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:21:41.254] - globals: [1] ‘kk’
[13:21:41.254] 
[13:21:41.254] getGlobalsAndPackages() ... DONE
[13:21:41.255] getGlobalsAndPackages() ...
[13:21:41.255] Searching for globals...
[13:21:41.256] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:21:41.256] Searching for globals ... DONE
[13:21:41.256] Resolving globals: FALSE
[13:21:41.257] The total size of the 1 globals is 56 bytes (56 bytes)
[13:21:41.258] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:21:41.258] - globals: [1] ‘kk’
[13:21:41.258] 
[13:21:41.258] getGlobalsAndPackages() ... DONE
[13:21:41.258] getGlobalsAndPackages() ...
[13:21:41.259] Searching for globals...
[13:21:41.260] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:21:41.260] Searching for globals ... DONE
[13:21:41.260] Resolving globals: FALSE
[13:21:41.261] The total size of the 1 globals is 56 bytes (56 bytes)
[13:21:41.261] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:21:41.261] - globals: [1] ‘kk’
[13:21:41.262] 
[13:21:41.262] getGlobalsAndPackages() ... DONE
[13:21:41.262] resolve() on list ...
[13:21:41.262]  recursive: 0
[13:21:41.262]  length: 3
[13:21:41.262] 
[13:21:41.263] run() for ‘Future’ ...
[13:21:41.266] - state: ‘created’
[13:21:41.266] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:41.272] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:41.273] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:41.273]   - Field: ‘label’
[13:21:41.273]   - Field: ‘local’
[13:21:41.273]   - Field: ‘owner’
[13:21:41.273]   - Field: ‘envir’
[13:21:41.273]   - Field: ‘workers’
[13:21:41.274]   - Field: ‘packages’
[13:21:41.274]   - Field: ‘gc’
[13:21:41.274]   - Field: ‘job’
[13:21:41.274]   - Field: ‘conditions’
[13:21:41.274]   - Field: ‘expr’
[13:21:41.274]   - Field: ‘uuid’
[13:21:41.275]   - Field: ‘seed’
[13:21:41.275]   - Field: ‘version’
[13:21:41.275]   - Field: ‘result’
[13:21:41.275]   - Field: ‘asynchronous’
[13:21:41.275]   - Field: ‘calls’
[13:21:41.275]   - Field: ‘globals’
[13:21:41.275]   - Field: ‘stdout’
[13:21:41.276]   - Field: ‘earlySignal’
[13:21:41.276]   - Field: ‘lazy’
[13:21:41.276]   - Field: ‘state’
[13:21:41.276] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:41.276] - Launch lazy future ...
[13:21:41.277] Packages needed by the future expression (n = 0): <none>
[13:21:41.277] Packages needed by future strategies (n = 0): <none>
[13:21:41.278] {
[13:21:41.278]     {
[13:21:41.278]         {
[13:21:41.278]             ...future.startTime <- base::Sys.time()
[13:21:41.278]             {
[13:21:41.278]                 {
[13:21:41.278]                   {
[13:21:41.278]                     {
[13:21:41.278]                       base::local({
[13:21:41.278]                         has_future <- base::requireNamespace("future", 
[13:21:41.278]                           quietly = TRUE)
[13:21:41.278]                         if (has_future) {
[13:21:41.278]                           ns <- base::getNamespace("future")
[13:21:41.278]                           version <- ns[[".package"]][["version"]]
[13:21:41.278]                           if (is.null(version)) 
[13:21:41.278]                             version <- utils::packageVersion("future")
[13:21:41.278]                         }
[13:21:41.278]                         else {
[13:21:41.278]                           version <- NULL
[13:21:41.278]                         }
[13:21:41.278]                         if (!has_future || version < "1.8.0") {
[13:21:41.278]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:41.278]                             "", base::R.version$version.string), 
[13:21:41.278]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:41.278]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:41.278]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:41.278]                               "release", "version")], collapse = " "), 
[13:21:41.278]                             hostname = base::Sys.info()[["nodename"]])
[13:21:41.278]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:41.278]                             info)
[13:21:41.278]                           info <- base::paste(info, collapse = "; ")
[13:21:41.278]                           if (!has_future) {
[13:21:41.278]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:41.278]                               info)
[13:21:41.278]                           }
[13:21:41.278]                           else {
[13:21:41.278]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:41.278]                               info, version)
[13:21:41.278]                           }
[13:21:41.278]                           base::stop(msg)
[13:21:41.278]                         }
[13:21:41.278]                       })
[13:21:41.278]                     }
[13:21:41.278]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:41.278]                     base::options(mc.cores = 1L)
[13:21:41.278]                   }
[13:21:41.278]                   options(future.plan = NULL)
[13:21:41.278]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.278]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:41.278]                 }
[13:21:41.278]                 ...future.workdir <- getwd()
[13:21:41.278]             }
[13:21:41.278]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:41.278]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:41.278]         }
[13:21:41.278]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:41.278]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:41.278]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:41.278]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:41.278]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:41.278]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:41.278]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:41.278]             base::names(...future.oldOptions))
[13:21:41.278]     }
[13:21:41.278]     if (FALSE) {
[13:21:41.278]     }
[13:21:41.278]     else {
[13:21:41.278]         if (TRUE) {
[13:21:41.278]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:41.278]                 open = "w")
[13:21:41.278]         }
[13:21:41.278]         else {
[13:21:41.278]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:41.278]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:41.278]         }
[13:21:41.278]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:41.278]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:41.278]             base::sink(type = "output", split = FALSE)
[13:21:41.278]             base::close(...future.stdout)
[13:21:41.278]         }, add = TRUE)
[13:21:41.278]     }
[13:21:41.278]     ...future.frame <- base::sys.nframe()
[13:21:41.278]     ...future.conditions <- base::list()
[13:21:41.278]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:41.278]     if (FALSE) {
[13:21:41.278]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:41.278]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:41.278]     }
[13:21:41.278]     ...future.result <- base::tryCatch({
[13:21:41.278]         base::withCallingHandlers({
[13:21:41.278]             ...future.value <- base::withVisible(base::local({
[13:21:41.278]                 withCallingHandlers({
[13:21:41.278]                   {
[13:21:41.278]                     Sys.sleep(0.1)
[13:21:41.278]                     kk
[13:21:41.278]                   }
[13:21:41.278]                 }, immediateCondition = function(cond) {
[13:21:41.278]                   save_rds <- function (object, pathname, ...) 
[13:21:41.278]                   {
[13:21:41.278]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:41.278]                     if (file_test("-f", pathname_tmp)) {
[13:21:41.278]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.278]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:41.278]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.278]                         fi_tmp[["mtime"]])
[13:21:41.278]                     }
[13:21:41.278]                     tryCatch({
[13:21:41.278]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:41.278]                     }, error = function(ex) {
[13:21:41.278]                       msg <- conditionMessage(ex)
[13:21:41.278]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.278]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:41.278]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.278]                         fi_tmp[["mtime"]], msg)
[13:21:41.278]                       ex$message <- msg
[13:21:41.278]                       stop(ex)
[13:21:41.278]                     })
[13:21:41.278]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:41.278]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:41.278]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:41.278]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.278]                       fi <- file.info(pathname)
[13:21:41.278]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:41.278]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.278]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:41.278]                         fi[["size"]], fi[["mtime"]])
[13:21:41.278]                       stop(msg)
[13:21:41.278]                     }
[13:21:41.278]                     invisible(pathname)
[13:21:41.278]                   }
[13:21:41.278]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:41.278]                     rootPath = tempdir()) 
[13:21:41.278]                   {
[13:21:41.278]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:41.278]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:41.278]                       tmpdir = path, fileext = ".rds")
[13:21:41.278]                     save_rds(obj, file)
[13:21:41.278]                   }
[13:21:41.278]                   saveImmediateCondition(cond, path = "/tmp/RtmpRIPAyw/.future/immediateConditions")
[13:21:41.278]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.278]                   {
[13:21:41.278]                     inherits <- base::inherits
[13:21:41.278]                     invokeRestart <- base::invokeRestart
[13:21:41.278]                     is.null <- base::is.null
[13:21:41.278]                     muffled <- FALSE
[13:21:41.278]                     if (inherits(cond, "message")) {
[13:21:41.278]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:41.278]                       if (muffled) 
[13:21:41.278]                         invokeRestart("muffleMessage")
[13:21:41.278]                     }
[13:21:41.278]                     else if (inherits(cond, "warning")) {
[13:21:41.278]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:41.278]                       if (muffled) 
[13:21:41.278]                         invokeRestart("muffleWarning")
[13:21:41.278]                     }
[13:21:41.278]                     else if (inherits(cond, "condition")) {
[13:21:41.278]                       if (!is.null(pattern)) {
[13:21:41.278]                         computeRestarts <- base::computeRestarts
[13:21:41.278]                         grepl <- base::grepl
[13:21:41.278]                         restarts <- computeRestarts(cond)
[13:21:41.278]                         for (restart in restarts) {
[13:21:41.278]                           name <- restart$name
[13:21:41.278]                           if (is.null(name)) 
[13:21:41.278]                             next
[13:21:41.278]                           if (!grepl(pattern, name)) 
[13:21:41.278]                             next
[13:21:41.278]                           invokeRestart(restart)
[13:21:41.278]                           muffled <- TRUE
[13:21:41.278]                           break
[13:21:41.278]                         }
[13:21:41.278]                       }
[13:21:41.278]                     }
[13:21:41.278]                     invisible(muffled)
[13:21:41.278]                   }
[13:21:41.278]                   muffleCondition(cond)
[13:21:41.278]                 })
[13:21:41.278]             }))
[13:21:41.278]             future::FutureResult(value = ...future.value$value, 
[13:21:41.278]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.278]                   ...future.rng), globalenv = if (FALSE) 
[13:21:41.278]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:41.278]                     ...future.globalenv.names))
[13:21:41.278]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:41.278]         }, condition = base::local({
[13:21:41.278]             c <- base::c
[13:21:41.278]             inherits <- base::inherits
[13:21:41.278]             invokeRestart <- base::invokeRestart
[13:21:41.278]             length <- base::length
[13:21:41.278]             list <- base::list
[13:21:41.278]             seq.int <- base::seq.int
[13:21:41.278]             signalCondition <- base::signalCondition
[13:21:41.278]             sys.calls <- base::sys.calls
[13:21:41.278]             `[[` <- base::`[[`
[13:21:41.278]             `+` <- base::`+`
[13:21:41.278]             `<<-` <- base::`<<-`
[13:21:41.278]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:41.278]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:41.278]                   3L)]
[13:21:41.278]             }
[13:21:41.278]             function(cond) {
[13:21:41.278]                 is_error <- inherits(cond, "error")
[13:21:41.278]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:41.278]                   NULL)
[13:21:41.278]                 if (is_error) {
[13:21:41.278]                   sessionInformation <- function() {
[13:21:41.278]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:41.278]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:41.278]                       search = base::search(), system = base::Sys.info())
[13:21:41.278]                   }
[13:21:41.278]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.278]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:41.278]                     cond$call), session = sessionInformation(), 
[13:21:41.278]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:41.278]                   signalCondition(cond)
[13:21:41.278]                 }
[13:21:41.278]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:41.278]                 "immediateCondition"))) {
[13:21:41.278]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:41.278]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.278]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:41.278]                   if (TRUE && !signal) {
[13:21:41.278]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.278]                     {
[13:21:41.278]                       inherits <- base::inherits
[13:21:41.278]                       invokeRestart <- base::invokeRestart
[13:21:41.278]                       is.null <- base::is.null
[13:21:41.278]                       muffled <- FALSE
[13:21:41.278]                       if (inherits(cond, "message")) {
[13:21:41.278]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.278]                         if (muffled) 
[13:21:41.278]                           invokeRestart("muffleMessage")
[13:21:41.278]                       }
[13:21:41.278]                       else if (inherits(cond, "warning")) {
[13:21:41.278]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.278]                         if (muffled) 
[13:21:41.278]                           invokeRestart("muffleWarning")
[13:21:41.278]                       }
[13:21:41.278]                       else if (inherits(cond, "condition")) {
[13:21:41.278]                         if (!is.null(pattern)) {
[13:21:41.278]                           computeRestarts <- base::computeRestarts
[13:21:41.278]                           grepl <- base::grepl
[13:21:41.278]                           restarts <- computeRestarts(cond)
[13:21:41.278]                           for (restart in restarts) {
[13:21:41.278]                             name <- restart$name
[13:21:41.278]                             if (is.null(name)) 
[13:21:41.278]                               next
[13:21:41.278]                             if (!grepl(pattern, name)) 
[13:21:41.278]                               next
[13:21:41.278]                             invokeRestart(restart)
[13:21:41.278]                             muffled <- TRUE
[13:21:41.278]                             break
[13:21:41.278]                           }
[13:21:41.278]                         }
[13:21:41.278]                       }
[13:21:41.278]                       invisible(muffled)
[13:21:41.278]                     }
[13:21:41.278]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.278]                   }
[13:21:41.278]                 }
[13:21:41.278]                 else {
[13:21:41.278]                   if (TRUE) {
[13:21:41.278]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.278]                     {
[13:21:41.278]                       inherits <- base::inherits
[13:21:41.278]                       invokeRestart <- base::invokeRestart
[13:21:41.278]                       is.null <- base::is.null
[13:21:41.278]                       muffled <- FALSE
[13:21:41.278]                       if (inherits(cond, "message")) {
[13:21:41.278]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.278]                         if (muffled) 
[13:21:41.278]                           invokeRestart("muffleMessage")
[13:21:41.278]                       }
[13:21:41.278]                       else if (inherits(cond, "warning")) {
[13:21:41.278]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.278]                         if (muffled) 
[13:21:41.278]                           invokeRestart("muffleWarning")
[13:21:41.278]                       }
[13:21:41.278]                       else if (inherits(cond, "condition")) {
[13:21:41.278]                         if (!is.null(pattern)) {
[13:21:41.278]                           computeRestarts <- base::computeRestarts
[13:21:41.278]                           grepl <- base::grepl
[13:21:41.278]                           restarts <- computeRestarts(cond)
[13:21:41.278]                           for (restart in restarts) {
[13:21:41.278]                             name <- restart$name
[13:21:41.278]                             if (is.null(name)) 
[13:21:41.278]                               next
[13:21:41.278]                             if (!grepl(pattern, name)) 
[13:21:41.278]                               next
[13:21:41.278]                             invokeRestart(restart)
[13:21:41.278]                             muffled <- TRUE
[13:21:41.278]                             break
[13:21:41.278]                           }
[13:21:41.278]                         }
[13:21:41.278]                       }
[13:21:41.278]                       invisible(muffled)
[13:21:41.278]                     }
[13:21:41.278]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.278]                   }
[13:21:41.278]                 }
[13:21:41.278]             }
[13:21:41.278]         }))
[13:21:41.278]     }, error = function(ex) {
[13:21:41.278]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:41.278]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.278]                 ...future.rng), started = ...future.startTime, 
[13:21:41.278]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:41.278]             version = "1.8"), class = "FutureResult")
[13:21:41.278]     }, finally = {
[13:21:41.278]         if (!identical(...future.workdir, getwd())) 
[13:21:41.278]             setwd(...future.workdir)
[13:21:41.278]         {
[13:21:41.278]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:41.278]                 ...future.oldOptions$nwarnings <- NULL
[13:21:41.278]             }
[13:21:41.278]             base::options(...future.oldOptions)
[13:21:41.278]             if (.Platform$OS.type == "windows") {
[13:21:41.278]                 old_names <- names(...future.oldEnvVars)
[13:21:41.278]                 envs <- base::Sys.getenv()
[13:21:41.278]                 names <- names(envs)
[13:21:41.278]                 common <- intersect(names, old_names)
[13:21:41.278]                 added <- setdiff(names, old_names)
[13:21:41.278]                 removed <- setdiff(old_names, names)
[13:21:41.278]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:41.278]                   envs[common]]
[13:21:41.278]                 NAMES <- toupper(changed)
[13:21:41.278]                 args <- list()
[13:21:41.278]                 for (kk in seq_along(NAMES)) {
[13:21:41.278]                   name <- changed[[kk]]
[13:21:41.278]                   NAME <- NAMES[[kk]]
[13:21:41.278]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.278]                     next
[13:21:41.278]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.278]                 }
[13:21:41.278]                 NAMES <- toupper(added)
[13:21:41.278]                 for (kk in seq_along(NAMES)) {
[13:21:41.278]                   name <- added[[kk]]
[13:21:41.278]                   NAME <- NAMES[[kk]]
[13:21:41.278]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.278]                     next
[13:21:41.278]                   args[[name]] <- ""
[13:21:41.278]                 }
[13:21:41.278]                 NAMES <- toupper(removed)
[13:21:41.278]                 for (kk in seq_along(NAMES)) {
[13:21:41.278]                   name <- removed[[kk]]
[13:21:41.278]                   NAME <- NAMES[[kk]]
[13:21:41.278]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.278]                     next
[13:21:41.278]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.278]                 }
[13:21:41.278]                 if (length(args) > 0) 
[13:21:41.278]                   base::do.call(base::Sys.setenv, args = args)
[13:21:41.278]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:41.278]             }
[13:21:41.278]             else {
[13:21:41.278]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:41.278]             }
[13:21:41.278]             {
[13:21:41.278]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:41.278]                   0L) {
[13:21:41.278]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:41.278]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:41.278]                   base::options(opts)
[13:21:41.278]                 }
[13:21:41.278]                 {
[13:21:41.278]                   {
[13:21:41.278]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:41.278]                     NULL
[13:21:41.278]                   }
[13:21:41.278]                   options(future.plan = NULL)
[13:21:41.278]                   if (is.na(NA_character_)) 
[13:21:41.278]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.278]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:41.278]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:41.278]                     envir = parent.frame()) 
[13:21:41.278]                   {
[13:21:41.278]                     default_workers <- missing(workers)
[13:21:41.278]                     if (is.function(workers)) 
[13:21:41.278]                       workers <- workers()
[13:21:41.278]                     workers <- structure(as.integer(workers), 
[13:21:41.278]                       class = class(workers))
[13:21:41.278]                     stop_if_not(is.finite(workers), workers >= 
[13:21:41.278]                       1L)
[13:21:41.278]                     if ((workers == 1L && !inherits(workers, 
[13:21:41.278]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:41.278]                       if (default_workers) 
[13:21:41.278]                         supportsMulticore(warn = TRUE)
[13:21:41.278]                       return(sequential(..., envir = envir))
[13:21:41.278]                     }
[13:21:41.278]                     oopts <- options(mc.cores = workers)
[13:21:41.278]                     on.exit(options(oopts))
[13:21:41.278]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:41.278]                       envir = envir)
[13:21:41.278]                     if (!future$lazy) 
[13:21:41.278]                       future <- run(future)
[13:21:41.278]                     invisible(future)
[13:21:41.278]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:41.278]                 }
[13:21:41.278]             }
[13:21:41.278]         }
[13:21:41.278]     })
[13:21:41.278]     if (TRUE) {
[13:21:41.278]         base::sink(type = "output", split = FALSE)
[13:21:41.278]         if (TRUE) {
[13:21:41.278]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:41.278]         }
[13:21:41.278]         else {
[13:21:41.278]             ...future.result["stdout"] <- base::list(NULL)
[13:21:41.278]         }
[13:21:41.278]         base::close(...future.stdout)
[13:21:41.278]         ...future.stdout <- NULL
[13:21:41.278]     }
[13:21:41.278]     ...future.result$conditions <- ...future.conditions
[13:21:41.278]     ...future.result$finished <- base::Sys.time()
[13:21:41.278]     ...future.result
[13:21:41.278] }
[13:21:41.281] assign_globals() ...
[13:21:41.281] List of 1
[13:21:41.281]  $ kk: int 1
[13:21:41.281]  - attr(*, "where")=List of 1
[13:21:41.281]   ..$ kk:<environment: R_EmptyEnv> 
[13:21:41.281]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:41.281]  - attr(*, "resolved")= logi FALSE
[13:21:41.281]  - attr(*, "total_size")= num 56
[13:21:41.281]  - attr(*, "already-done")= logi TRUE
[13:21:41.285] - copied ‘kk’ to environment
[13:21:41.285] assign_globals() ... done
[13:21:41.285] requestCore(): workers = 2
[13:21:41.286] Poll #1 (0): usedCores() = 2, workers = 2
[13:21:41.300] MulticoreFuture started
[13:21:41.300] - Launch lazy future ... done
[13:21:41.300] run() for ‘MulticoreFuture’ ... done
[13:21:41.301] plan(): Setting new future strategy stack:
[13:21:41.301] List of future strategies:
[13:21:41.301] 1. sequential:
[13:21:41.301]    - args: function (..., envir = parent.frame())
[13:21:41.301]    - tweaked: FALSE
[13:21:41.301]    - call: NULL
[13:21:41.302] plan(): nbrOfWorkers() = 1
[13:21:41.311] run() for ‘Future’ ...
[13:21:41.312] - state: ‘created’
[13:21:41.312] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:41.317] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:41.318] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:41.318]   - Field: ‘label’
[13:21:41.318]   - Field: ‘local’
[13:21:41.318]   - Field: ‘owner’
[13:21:41.318]   - Field: ‘envir’
[13:21:41.318]   - Field: ‘workers’
[13:21:41.319]   - Field: ‘packages’
[13:21:41.319]   - Field: ‘gc’
[13:21:41.319]   - Field: ‘job’
[13:21:41.319]   - Field: ‘conditions’
[13:21:41.319]   - Field: ‘expr’
[13:21:41.319]   - Field: ‘uuid’
[13:21:41.320]   - Field: ‘seed’
[13:21:41.320]   - Field: ‘version’
[13:21:41.320]   - Field: ‘result’
[13:21:41.320]   - Field: ‘asynchronous’
[13:21:41.320]   - Field: ‘calls’
[13:21:41.320]   - Field: ‘globals’
[13:21:41.321]   - Field: ‘stdout’
[13:21:41.321]   - Field: ‘earlySignal’
[13:21:41.321]   - Field: ‘lazy’
[13:21:41.321]   - Field: ‘state’
[13:21:41.321] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:41.321] - Launch lazy future ...
[13:21:41.322] Packages needed by the future expression (n = 0): <none>
[13:21:41.322] Packages needed by future strategies (n = 0): <none>
[13:21:41.323] {
[13:21:41.323]     {
[13:21:41.323]         {
[13:21:41.323]             ...future.startTime <- base::Sys.time()
[13:21:41.323]             {
[13:21:41.323]                 {
[13:21:41.323]                   {
[13:21:41.323]                     {
[13:21:41.323]                       base::local({
[13:21:41.323]                         has_future <- base::requireNamespace("future", 
[13:21:41.323]                           quietly = TRUE)
[13:21:41.323]                         if (has_future) {
[13:21:41.323]                           ns <- base::getNamespace("future")
[13:21:41.323]                           version <- ns[[".package"]][["version"]]
[13:21:41.323]                           if (is.null(version)) 
[13:21:41.323]                             version <- utils::packageVersion("future")
[13:21:41.323]                         }
[13:21:41.323]                         else {
[13:21:41.323]                           version <- NULL
[13:21:41.323]                         }
[13:21:41.323]                         if (!has_future || version < "1.8.0") {
[13:21:41.323]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:41.323]                             "", base::R.version$version.string), 
[13:21:41.323]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:41.323]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:41.323]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:41.323]                               "release", "version")], collapse = " "), 
[13:21:41.323]                             hostname = base::Sys.info()[["nodename"]])
[13:21:41.323]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:41.323]                             info)
[13:21:41.323]                           info <- base::paste(info, collapse = "; ")
[13:21:41.323]                           if (!has_future) {
[13:21:41.323]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:41.323]                               info)
[13:21:41.323]                           }
[13:21:41.323]                           else {
[13:21:41.323]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:41.323]                               info, version)
[13:21:41.323]                           }
[13:21:41.323]                           base::stop(msg)
[13:21:41.323]                         }
[13:21:41.323]                       })
[13:21:41.323]                     }
[13:21:41.323]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:41.323]                     base::options(mc.cores = 1L)
[13:21:41.323]                   }
[13:21:41.323]                   options(future.plan = NULL)
[13:21:41.323]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.323]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:41.323]                 }
[13:21:41.323]                 ...future.workdir <- getwd()
[13:21:41.323]             }
[13:21:41.323]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:41.323]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:41.323]         }
[13:21:41.323]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:41.323]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:41.323]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:41.323]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:41.323]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:41.323]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:41.323]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:41.323]             base::names(...future.oldOptions))
[13:21:41.323]     }
[13:21:41.323]     if (FALSE) {
[13:21:41.323]     }
[13:21:41.323]     else {
[13:21:41.323]         if (TRUE) {
[13:21:41.323]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:41.323]                 open = "w")
[13:21:41.323]         }
[13:21:41.323]         else {
[13:21:41.323]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:41.323]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:41.323]         }
[13:21:41.323]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:41.323]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:41.323]             base::sink(type = "output", split = FALSE)
[13:21:41.323]             base::close(...future.stdout)
[13:21:41.323]         }, add = TRUE)
[13:21:41.323]     }
[13:21:41.323]     ...future.frame <- base::sys.nframe()
[13:21:41.323]     ...future.conditions <- base::list()
[13:21:41.323]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:41.323]     if (FALSE) {
[13:21:41.323]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:41.323]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:41.323]     }
[13:21:41.323]     ...future.result <- base::tryCatch({
[13:21:41.323]         base::withCallingHandlers({
[13:21:41.323]             ...future.value <- base::withVisible(base::local({
[13:21:41.323]                 withCallingHandlers({
[13:21:41.323]                   {
[13:21:41.323]                     Sys.sleep(0.1)
[13:21:41.323]                     kk
[13:21:41.323]                   }
[13:21:41.323]                 }, immediateCondition = function(cond) {
[13:21:41.323]                   save_rds <- function (object, pathname, ...) 
[13:21:41.323]                   {
[13:21:41.323]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:41.323]                     if (file_test("-f", pathname_tmp)) {
[13:21:41.323]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.323]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:41.323]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.323]                         fi_tmp[["mtime"]])
[13:21:41.323]                     }
[13:21:41.323]                     tryCatch({
[13:21:41.323]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:41.323]                     }, error = function(ex) {
[13:21:41.323]                       msg <- conditionMessage(ex)
[13:21:41.323]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.323]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:41.323]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.323]                         fi_tmp[["mtime"]], msg)
[13:21:41.323]                       ex$message <- msg
[13:21:41.323]                       stop(ex)
[13:21:41.323]                     })
[13:21:41.323]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:41.323]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:41.323]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:41.323]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.323]                       fi <- file.info(pathname)
[13:21:41.323]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:41.323]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.323]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:41.323]                         fi[["size"]], fi[["mtime"]])
[13:21:41.323]                       stop(msg)
[13:21:41.323]                     }
[13:21:41.323]                     invisible(pathname)
[13:21:41.323]                   }
[13:21:41.323]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:41.323]                     rootPath = tempdir()) 
[13:21:41.323]                   {
[13:21:41.323]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:41.323]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:41.323]                       tmpdir = path, fileext = ".rds")
[13:21:41.323]                     save_rds(obj, file)
[13:21:41.323]                   }
[13:21:41.323]                   saveImmediateCondition(cond, path = "/tmp/RtmpRIPAyw/.future/immediateConditions")
[13:21:41.323]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.323]                   {
[13:21:41.323]                     inherits <- base::inherits
[13:21:41.323]                     invokeRestart <- base::invokeRestart
[13:21:41.323]                     is.null <- base::is.null
[13:21:41.323]                     muffled <- FALSE
[13:21:41.323]                     if (inherits(cond, "message")) {
[13:21:41.323]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:41.323]                       if (muffled) 
[13:21:41.323]                         invokeRestart("muffleMessage")
[13:21:41.323]                     }
[13:21:41.323]                     else if (inherits(cond, "warning")) {
[13:21:41.323]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:41.323]                       if (muffled) 
[13:21:41.323]                         invokeRestart("muffleWarning")
[13:21:41.323]                     }
[13:21:41.323]                     else if (inherits(cond, "condition")) {
[13:21:41.323]                       if (!is.null(pattern)) {
[13:21:41.323]                         computeRestarts <- base::computeRestarts
[13:21:41.323]                         grepl <- base::grepl
[13:21:41.323]                         restarts <- computeRestarts(cond)
[13:21:41.323]                         for (restart in restarts) {
[13:21:41.323]                           name <- restart$name
[13:21:41.323]                           if (is.null(name)) 
[13:21:41.323]                             next
[13:21:41.323]                           if (!grepl(pattern, name)) 
[13:21:41.323]                             next
[13:21:41.323]                           invokeRestart(restart)
[13:21:41.323]                           muffled <- TRUE
[13:21:41.323]                           break
[13:21:41.323]                         }
[13:21:41.323]                       }
[13:21:41.323]                     }
[13:21:41.323]                     invisible(muffled)
[13:21:41.323]                   }
[13:21:41.323]                   muffleCondition(cond)
[13:21:41.323]                 })
[13:21:41.323]             }))
[13:21:41.323]             future::FutureResult(value = ...future.value$value, 
[13:21:41.323]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.323]                   ...future.rng), globalenv = if (FALSE) 
[13:21:41.323]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:41.323]                     ...future.globalenv.names))
[13:21:41.323]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:41.323]         }, condition = base::local({
[13:21:41.323]             c <- base::c
[13:21:41.323]             inherits <- base::inherits
[13:21:41.323]             invokeRestart <- base::invokeRestart
[13:21:41.323]             length <- base::length
[13:21:41.323]             list <- base::list
[13:21:41.323]             seq.int <- base::seq.int
[13:21:41.323]             signalCondition <- base::signalCondition
[13:21:41.323]             sys.calls <- base::sys.calls
[13:21:41.323]             `[[` <- base::`[[`
[13:21:41.323]             `+` <- base::`+`
[13:21:41.323]             `<<-` <- base::`<<-`
[13:21:41.323]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:41.323]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:41.323]                   3L)]
[13:21:41.323]             }
[13:21:41.323]             function(cond) {
[13:21:41.323]                 is_error <- inherits(cond, "error")
[13:21:41.323]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:41.323]                   NULL)
[13:21:41.323]                 if (is_error) {
[13:21:41.323]                   sessionInformation <- function() {
[13:21:41.323]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:41.323]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:41.323]                       search = base::search(), system = base::Sys.info())
[13:21:41.323]                   }
[13:21:41.323]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.323]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:41.323]                     cond$call), session = sessionInformation(), 
[13:21:41.323]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:41.323]                   signalCondition(cond)
[13:21:41.323]                 }
[13:21:41.323]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:41.323]                 "immediateCondition"))) {
[13:21:41.323]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:41.323]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.323]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:41.323]                   if (TRUE && !signal) {
[13:21:41.323]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.323]                     {
[13:21:41.323]                       inherits <- base::inherits
[13:21:41.323]                       invokeRestart <- base::invokeRestart
[13:21:41.323]                       is.null <- base::is.null
[13:21:41.323]                       muffled <- FALSE
[13:21:41.323]                       if (inherits(cond, "message")) {
[13:21:41.323]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.323]                         if (muffled) 
[13:21:41.323]                           invokeRestart("muffleMessage")
[13:21:41.323]                       }
[13:21:41.323]                       else if (inherits(cond, "warning")) {
[13:21:41.323]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.323]                         if (muffled) 
[13:21:41.323]                           invokeRestart("muffleWarning")
[13:21:41.323]                       }
[13:21:41.323]                       else if (inherits(cond, "condition")) {
[13:21:41.323]                         if (!is.null(pattern)) {
[13:21:41.323]                           computeRestarts <- base::computeRestarts
[13:21:41.323]                           grepl <- base::grepl
[13:21:41.323]                           restarts <- computeRestarts(cond)
[13:21:41.323]                           for (restart in restarts) {
[13:21:41.323]                             name <- restart$name
[13:21:41.323]                             if (is.null(name)) 
[13:21:41.323]                               next
[13:21:41.323]                             if (!grepl(pattern, name)) 
[13:21:41.323]                               next
[13:21:41.323]                             invokeRestart(restart)
[13:21:41.323]                             muffled <- TRUE
[13:21:41.323]                             break
[13:21:41.323]                           }
[13:21:41.323]                         }
[13:21:41.323]                       }
[13:21:41.323]                       invisible(muffled)
[13:21:41.323]                     }
[13:21:41.323]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.323]                   }
[13:21:41.323]                 }
[13:21:41.323]                 else {
[13:21:41.323]                   if (TRUE) {
[13:21:41.323]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.323]                     {
[13:21:41.323]                       inherits <- base::inherits
[13:21:41.323]                       invokeRestart <- base::invokeRestart
[13:21:41.323]                       is.null <- base::is.null
[13:21:41.323]                       muffled <- FALSE
[13:21:41.323]                       if (inherits(cond, "message")) {
[13:21:41.323]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.323]                         if (muffled) 
[13:21:41.323]                           invokeRestart("muffleMessage")
[13:21:41.323]                       }
[13:21:41.323]                       else if (inherits(cond, "warning")) {
[13:21:41.323]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.323]                         if (muffled) 
[13:21:41.323]                           invokeRestart("muffleWarning")
[13:21:41.323]                       }
[13:21:41.323]                       else if (inherits(cond, "condition")) {
[13:21:41.323]                         if (!is.null(pattern)) {
[13:21:41.323]                           computeRestarts <- base::computeRestarts
[13:21:41.323]                           grepl <- base::grepl
[13:21:41.323]                           restarts <- computeRestarts(cond)
[13:21:41.323]                           for (restart in restarts) {
[13:21:41.323]                             name <- restart$name
[13:21:41.323]                             if (is.null(name)) 
[13:21:41.323]                               next
[13:21:41.323]                             if (!grepl(pattern, name)) 
[13:21:41.323]                               next
[13:21:41.323]                             invokeRestart(restart)
[13:21:41.323]                             muffled <- TRUE
[13:21:41.323]                             break
[13:21:41.323]                           }
[13:21:41.323]                         }
[13:21:41.323]                       }
[13:21:41.323]                       invisible(muffled)
[13:21:41.323]                     }
[13:21:41.323]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.323]                   }
[13:21:41.323]                 }
[13:21:41.323]             }
[13:21:41.323]         }))
[13:21:41.323]     }, error = function(ex) {
[13:21:41.323]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:41.323]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.323]                 ...future.rng), started = ...future.startTime, 
[13:21:41.323]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:41.323]             version = "1.8"), class = "FutureResult")
[13:21:41.323]     }, finally = {
[13:21:41.323]         if (!identical(...future.workdir, getwd())) 
[13:21:41.323]             setwd(...future.workdir)
[13:21:41.323]         {
[13:21:41.323]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:41.323]                 ...future.oldOptions$nwarnings <- NULL
[13:21:41.323]             }
[13:21:41.323]             base::options(...future.oldOptions)
[13:21:41.323]             if (.Platform$OS.type == "windows") {
[13:21:41.323]                 old_names <- names(...future.oldEnvVars)
[13:21:41.323]                 envs <- base::Sys.getenv()
[13:21:41.323]                 names <- names(envs)
[13:21:41.323]                 common <- intersect(names, old_names)
[13:21:41.323]                 added <- setdiff(names, old_names)
[13:21:41.323]                 removed <- setdiff(old_names, names)
[13:21:41.323]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:41.323]                   envs[common]]
[13:21:41.323]                 NAMES <- toupper(changed)
[13:21:41.323]                 args <- list()
[13:21:41.323]                 for (kk in seq_along(NAMES)) {
[13:21:41.323]                   name <- changed[[kk]]
[13:21:41.323]                   NAME <- NAMES[[kk]]
[13:21:41.323]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.323]                     next
[13:21:41.323]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.323]                 }
[13:21:41.323]                 NAMES <- toupper(added)
[13:21:41.323]                 for (kk in seq_along(NAMES)) {
[13:21:41.323]                   name <- added[[kk]]
[13:21:41.323]                   NAME <- NAMES[[kk]]
[13:21:41.323]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.323]                     next
[13:21:41.323]                   args[[name]] <- ""
[13:21:41.323]                 }
[13:21:41.323]                 NAMES <- toupper(removed)
[13:21:41.323]                 for (kk in seq_along(NAMES)) {
[13:21:41.323]                   name <- removed[[kk]]
[13:21:41.323]                   NAME <- NAMES[[kk]]
[13:21:41.323]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.323]                     next
[13:21:41.323]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.323]                 }
[13:21:41.323]                 if (length(args) > 0) 
[13:21:41.323]                   base::do.call(base::Sys.setenv, args = args)
[13:21:41.323]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:41.323]             }
[13:21:41.323]             else {
[13:21:41.323]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:41.323]             }
[13:21:41.323]             {
[13:21:41.323]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:41.323]                   0L) {
[13:21:41.323]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:41.323]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:41.323]                   base::options(opts)
[13:21:41.323]                 }
[13:21:41.323]                 {
[13:21:41.323]                   {
[13:21:41.323]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:41.323]                     NULL
[13:21:41.323]                   }
[13:21:41.323]                   options(future.plan = NULL)
[13:21:41.323]                   if (is.na(NA_character_)) 
[13:21:41.323]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.323]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:41.323]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:41.323]                     envir = parent.frame()) 
[13:21:41.323]                   {
[13:21:41.323]                     default_workers <- missing(workers)
[13:21:41.323]                     if (is.function(workers)) 
[13:21:41.323]                       workers <- workers()
[13:21:41.323]                     workers <- structure(as.integer(workers), 
[13:21:41.323]                       class = class(workers))
[13:21:41.323]                     stop_if_not(is.finite(workers), workers >= 
[13:21:41.323]                       1L)
[13:21:41.323]                     if ((workers == 1L && !inherits(workers, 
[13:21:41.323]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:41.323]                       if (default_workers) 
[13:21:41.323]                         supportsMulticore(warn = TRUE)
[13:21:41.323]                       return(sequential(..., envir = envir))
[13:21:41.323]                     }
[13:21:41.323]                     oopts <- options(mc.cores = workers)
[13:21:41.323]                     on.exit(options(oopts))
[13:21:41.323]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:41.323]                       envir = envir)
[13:21:41.323]                     if (!future$lazy) 
[13:21:41.323]                       future <- run(future)
[13:21:41.323]                     invisible(future)
[13:21:41.323]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:41.323]                 }
[13:21:41.323]             }
[13:21:41.323]         }
[13:21:41.323]     })
[13:21:41.323]     if (TRUE) {
[13:21:41.323]         base::sink(type = "output", split = FALSE)
[13:21:41.323]         if (TRUE) {
[13:21:41.323]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:41.323]         }
[13:21:41.323]         else {
[13:21:41.323]             ...future.result["stdout"] <- base::list(NULL)
[13:21:41.323]         }
[13:21:41.323]         base::close(...future.stdout)
[13:21:41.323]         ...future.stdout <- NULL
[13:21:41.323]     }
[13:21:41.323]     ...future.result$conditions <- ...future.conditions
[13:21:41.323]     ...future.result$finished <- base::Sys.time()
[13:21:41.323]     ...future.result
[13:21:41.323] }
[13:21:41.327] assign_globals() ...
[13:21:41.327] List of 1
[13:21:41.327]  $ kk: int 2
[13:21:41.327]  - attr(*, "where")=List of 1
[13:21:41.327]   ..$ kk:<environment: R_EmptyEnv> 
[13:21:41.327]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:41.327]  - attr(*, "resolved")= logi FALSE
[13:21:41.327]  - attr(*, "total_size")= num 56
[13:21:41.327]  - attr(*, "already-done")= logi TRUE
[13:21:41.331] - copied ‘kk’ to environment
[13:21:41.331] assign_globals() ... done
[13:21:41.331] requestCore(): workers = 2
[13:21:41.331] Poll #1 (0): usedCores() = 2, workers = 2
[13:21:41.345] MulticoreFuture started
[13:21:41.345] - Launch lazy future ... done
[13:21:41.346] run() for ‘MulticoreFuture’ ... done
[13:21:41.346] plan(): Setting new future strategy stack:
[13:21:41.346] List of future strategies:
[13:21:41.346] 1. sequential:
[13:21:41.346]    - args: function (..., envir = parent.frame())
[13:21:41.346]    - tweaked: FALSE
[13:21:41.346]    - call: NULL
[13:21:41.347] plan(): nbrOfWorkers() = 1
[13:21:41.357] run() for ‘Future’ ...
[13:21:41.357] - state: ‘created’
[13:21:41.357] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:41.363] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:41.364] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:41.364]   - Field: ‘label’
[13:21:41.364]   - Field: ‘local’
[13:21:41.364]   - Field: ‘owner’
[13:21:41.364]   - Field: ‘envir’
[13:21:41.364]   - Field: ‘workers’
[13:21:41.365]   - Field: ‘packages’
[13:21:41.365]   - Field: ‘gc’
[13:21:41.365]   - Field: ‘job’
[13:21:41.365]   - Field: ‘conditions’
[13:21:41.365]   - Field: ‘expr’
[13:21:41.366]   - Field: ‘uuid’
[13:21:41.366]   - Field: ‘seed’
[13:21:41.366]   - Field: ‘version’
[13:21:41.366]   - Field: ‘result’
[13:21:41.366]   - Field: ‘asynchronous’
[13:21:41.366]   - Field: ‘calls’
[13:21:41.367]   - Field: ‘globals’
[13:21:41.367]   - Field: ‘stdout’
[13:21:41.367]   - Field: ‘earlySignal’
[13:21:41.367]   - Field: ‘lazy’
[13:21:41.367]   - Field: ‘state’
[13:21:41.367] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:41.367] - Launch lazy future ...
[13:21:41.372] Packages needed by the future expression (n = 0): <none>
[13:21:41.372] Packages needed by future strategies (n = 0): <none>
[13:21:41.374] {
[13:21:41.374]     {
[13:21:41.374]         {
[13:21:41.374]             ...future.startTime <- base::Sys.time()
[13:21:41.374]             {
[13:21:41.374]                 {
[13:21:41.374]                   {
[13:21:41.374]                     {
[13:21:41.374]                       base::local({
[13:21:41.374]                         has_future <- base::requireNamespace("future", 
[13:21:41.374]                           quietly = TRUE)
[13:21:41.374]                         if (has_future) {
[13:21:41.374]                           ns <- base::getNamespace("future")
[13:21:41.374]                           version <- ns[[".package"]][["version"]]
[13:21:41.374]                           if (is.null(version)) 
[13:21:41.374]                             version <- utils::packageVersion("future")
[13:21:41.374]                         }
[13:21:41.374]                         else {
[13:21:41.374]                           version <- NULL
[13:21:41.374]                         }
[13:21:41.374]                         if (!has_future || version < "1.8.0") {
[13:21:41.374]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:41.374]                             "", base::R.version$version.string), 
[13:21:41.374]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:41.374]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:41.374]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:41.374]                               "release", "version")], collapse = " "), 
[13:21:41.374]                             hostname = base::Sys.info()[["nodename"]])
[13:21:41.374]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:41.374]                             info)
[13:21:41.374]                           info <- base::paste(info, collapse = "; ")
[13:21:41.374]                           if (!has_future) {
[13:21:41.374]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:41.374]                               info)
[13:21:41.374]                           }
[13:21:41.374]                           else {
[13:21:41.374]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:41.374]                               info, version)
[13:21:41.374]                           }
[13:21:41.374]                           base::stop(msg)
[13:21:41.374]                         }
[13:21:41.374]                       })
[13:21:41.374]                     }
[13:21:41.374]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:41.374]                     base::options(mc.cores = 1L)
[13:21:41.374]                   }
[13:21:41.374]                   options(future.plan = NULL)
[13:21:41.374]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.374]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:41.374]                 }
[13:21:41.374]                 ...future.workdir <- getwd()
[13:21:41.374]             }
[13:21:41.374]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:41.374]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:41.374]         }
[13:21:41.374]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:41.374]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:41.374]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:41.374]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:41.374]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:41.374]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:41.374]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:41.374]             base::names(...future.oldOptions))
[13:21:41.374]     }
[13:21:41.374]     if (FALSE) {
[13:21:41.374]     }
[13:21:41.374]     else {
[13:21:41.374]         if (TRUE) {
[13:21:41.374]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:41.374]                 open = "w")
[13:21:41.374]         }
[13:21:41.374]         else {
[13:21:41.374]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:41.374]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:41.374]         }
[13:21:41.374]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:41.374]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:41.374]             base::sink(type = "output", split = FALSE)
[13:21:41.374]             base::close(...future.stdout)
[13:21:41.374]         }, add = TRUE)
[13:21:41.374]     }
[13:21:41.374]     ...future.frame <- base::sys.nframe()
[13:21:41.374]     ...future.conditions <- base::list()
[13:21:41.374]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:41.374]     if (FALSE) {
[13:21:41.374]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:41.374]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:41.374]     }
[13:21:41.374]     ...future.result <- base::tryCatch({
[13:21:41.374]         base::withCallingHandlers({
[13:21:41.374]             ...future.value <- base::withVisible(base::local({
[13:21:41.374]                 withCallingHandlers({
[13:21:41.374]                   {
[13:21:41.374]                     Sys.sleep(0.1)
[13:21:41.374]                     kk
[13:21:41.374]                   }
[13:21:41.374]                 }, immediateCondition = function(cond) {
[13:21:41.374]                   save_rds <- function (object, pathname, ...) 
[13:21:41.374]                   {
[13:21:41.374]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:41.374]                     if (file_test("-f", pathname_tmp)) {
[13:21:41.374]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.374]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:41.374]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.374]                         fi_tmp[["mtime"]])
[13:21:41.374]                     }
[13:21:41.374]                     tryCatch({
[13:21:41.374]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:41.374]                     }, error = function(ex) {
[13:21:41.374]                       msg <- conditionMessage(ex)
[13:21:41.374]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.374]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:41.374]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.374]                         fi_tmp[["mtime"]], msg)
[13:21:41.374]                       ex$message <- msg
[13:21:41.374]                       stop(ex)
[13:21:41.374]                     })
[13:21:41.374]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:41.374]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:41.374]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:41.374]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.374]                       fi <- file.info(pathname)
[13:21:41.374]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:41.374]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.374]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:41.374]                         fi[["size"]], fi[["mtime"]])
[13:21:41.374]                       stop(msg)
[13:21:41.374]                     }
[13:21:41.374]                     invisible(pathname)
[13:21:41.374]                   }
[13:21:41.374]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:41.374]                     rootPath = tempdir()) 
[13:21:41.374]                   {
[13:21:41.374]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:41.374]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:41.374]                       tmpdir = path, fileext = ".rds")
[13:21:41.374]                     save_rds(obj, file)
[13:21:41.374]                   }
[13:21:41.374]                   saveImmediateCondition(cond, path = "/tmp/RtmpRIPAyw/.future/immediateConditions")
[13:21:41.374]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.374]                   {
[13:21:41.374]                     inherits <- base::inherits
[13:21:41.374]                     invokeRestart <- base::invokeRestart
[13:21:41.374]                     is.null <- base::is.null
[13:21:41.374]                     muffled <- FALSE
[13:21:41.374]                     if (inherits(cond, "message")) {
[13:21:41.374]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:41.374]                       if (muffled) 
[13:21:41.374]                         invokeRestart("muffleMessage")
[13:21:41.374]                     }
[13:21:41.374]                     else if (inherits(cond, "warning")) {
[13:21:41.374]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:41.374]                       if (muffled) 
[13:21:41.374]                         invokeRestart("muffleWarning")
[13:21:41.374]                     }
[13:21:41.374]                     else if (inherits(cond, "condition")) {
[13:21:41.374]                       if (!is.null(pattern)) {
[13:21:41.374]                         computeRestarts <- base::computeRestarts
[13:21:41.374]                         grepl <- base::grepl
[13:21:41.374]                         restarts <- computeRestarts(cond)
[13:21:41.374]                         for (restart in restarts) {
[13:21:41.374]                           name <- restart$name
[13:21:41.374]                           if (is.null(name)) 
[13:21:41.374]                             next
[13:21:41.374]                           if (!grepl(pattern, name)) 
[13:21:41.374]                             next
[13:21:41.374]                           invokeRestart(restart)
[13:21:41.374]                           muffled <- TRUE
[13:21:41.374]                           break
[13:21:41.374]                         }
[13:21:41.374]                       }
[13:21:41.374]                     }
[13:21:41.374]                     invisible(muffled)
[13:21:41.374]                   }
[13:21:41.374]                   muffleCondition(cond)
[13:21:41.374]                 })
[13:21:41.374]             }))
[13:21:41.374]             future::FutureResult(value = ...future.value$value, 
[13:21:41.374]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.374]                   ...future.rng), globalenv = if (FALSE) 
[13:21:41.374]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:41.374]                     ...future.globalenv.names))
[13:21:41.374]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:41.374]         }, condition = base::local({
[13:21:41.374]             c <- base::c
[13:21:41.374]             inherits <- base::inherits
[13:21:41.374]             invokeRestart <- base::invokeRestart
[13:21:41.374]             length <- base::length
[13:21:41.374]             list <- base::list
[13:21:41.374]             seq.int <- base::seq.int
[13:21:41.374]             signalCondition <- base::signalCondition
[13:21:41.374]             sys.calls <- base::sys.calls
[13:21:41.374]             `[[` <- base::`[[`
[13:21:41.374]             `+` <- base::`+`
[13:21:41.374]             `<<-` <- base::`<<-`
[13:21:41.374]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:41.374]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:41.374]                   3L)]
[13:21:41.374]             }
[13:21:41.374]             function(cond) {
[13:21:41.374]                 is_error <- inherits(cond, "error")
[13:21:41.374]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:41.374]                   NULL)
[13:21:41.374]                 if (is_error) {
[13:21:41.374]                   sessionInformation <- function() {
[13:21:41.374]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:41.374]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:41.374]                       search = base::search(), system = base::Sys.info())
[13:21:41.374]                   }
[13:21:41.374]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.374]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:41.374]                     cond$call), session = sessionInformation(), 
[13:21:41.374]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:41.374]                   signalCondition(cond)
[13:21:41.374]                 }
[13:21:41.374]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:41.374]                 "immediateCondition"))) {
[13:21:41.374]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:41.374]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.374]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:41.374]                   if (TRUE && !signal) {
[13:21:41.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.374]                     {
[13:21:41.374]                       inherits <- base::inherits
[13:21:41.374]                       invokeRestart <- base::invokeRestart
[13:21:41.374]                       is.null <- base::is.null
[13:21:41.374]                       muffled <- FALSE
[13:21:41.374]                       if (inherits(cond, "message")) {
[13:21:41.374]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.374]                         if (muffled) 
[13:21:41.374]                           invokeRestart("muffleMessage")
[13:21:41.374]                       }
[13:21:41.374]                       else if (inherits(cond, "warning")) {
[13:21:41.374]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.374]                         if (muffled) 
[13:21:41.374]                           invokeRestart("muffleWarning")
[13:21:41.374]                       }
[13:21:41.374]                       else if (inherits(cond, "condition")) {
[13:21:41.374]                         if (!is.null(pattern)) {
[13:21:41.374]                           computeRestarts <- base::computeRestarts
[13:21:41.374]                           grepl <- base::grepl
[13:21:41.374]                           restarts <- computeRestarts(cond)
[13:21:41.374]                           for (restart in restarts) {
[13:21:41.374]                             name <- restart$name
[13:21:41.374]                             if (is.null(name)) 
[13:21:41.374]                               next
[13:21:41.374]                             if (!grepl(pattern, name)) 
[13:21:41.374]                               next
[13:21:41.374]                             invokeRestart(restart)
[13:21:41.374]                             muffled <- TRUE
[13:21:41.374]                             break
[13:21:41.374]                           }
[13:21:41.374]                         }
[13:21:41.374]                       }
[13:21:41.374]                       invisible(muffled)
[13:21:41.374]                     }
[13:21:41.374]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.374]                   }
[13:21:41.374]                 }
[13:21:41.374]                 else {
[13:21:41.374]                   if (TRUE) {
[13:21:41.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.374]                     {
[13:21:41.374]                       inherits <- base::inherits
[13:21:41.374]                       invokeRestart <- base::invokeRestart
[13:21:41.374]                       is.null <- base::is.null
[13:21:41.374]                       muffled <- FALSE
[13:21:41.374]                       if (inherits(cond, "message")) {
[13:21:41.374]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.374]                         if (muffled) 
[13:21:41.374]                           invokeRestart("muffleMessage")
[13:21:41.374]                       }
[13:21:41.374]                       else if (inherits(cond, "warning")) {
[13:21:41.374]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.374]                         if (muffled) 
[13:21:41.374]                           invokeRestart("muffleWarning")
[13:21:41.374]                       }
[13:21:41.374]                       else if (inherits(cond, "condition")) {
[13:21:41.374]                         if (!is.null(pattern)) {
[13:21:41.374]                           computeRestarts <- base::computeRestarts
[13:21:41.374]                           grepl <- base::grepl
[13:21:41.374]                           restarts <- computeRestarts(cond)
[13:21:41.374]                           for (restart in restarts) {
[13:21:41.374]                             name <- restart$name
[13:21:41.374]                             if (is.null(name)) 
[13:21:41.374]                               next
[13:21:41.374]                             if (!grepl(pattern, name)) 
[13:21:41.374]                               next
[13:21:41.374]                             invokeRestart(restart)
[13:21:41.374]                             muffled <- TRUE
[13:21:41.374]                             break
[13:21:41.374]                           }
[13:21:41.374]                         }
[13:21:41.374]                       }
[13:21:41.374]                       invisible(muffled)
[13:21:41.374]                     }
[13:21:41.374]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.374]                   }
[13:21:41.374]                 }
[13:21:41.374]             }
[13:21:41.374]         }))
[13:21:41.374]     }, error = function(ex) {
[13:21:41.374]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:41.374]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.374]                 ...future.rng), started = ...future.startTime, 
[13:21:41.374]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:41.374]             version = "1.8"), class = "FutureResult")
[13:21:41.374]     }, finally = {
[13:21:41.374]         if (!identical(...future.workdir, getwd())) 
[13:21:41.374]             setwd(...future.workdir)
[13:21:41.374]         {
[13:21:41.374]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:41.374]                 ...future.oldOptions$nwarnings <- NULL
[13:21:41.374]             }
[13:21:41.374]             base::options(...future.oldOptions)
[13:21:41.374]             if (.Platform$OS.type == "windows") {
[13:21:41.374]                 old_names <- names(...future.oldEnvVars)
[13:21:41.374]                 envs <- base::Sys.getenv()
[13:21:41.374]                 names <- names(envs)
[13:21:41.374]                 common <- intersect(names, old_names)
[13:21:41.374]                 added <- setdiff(names, old_names)
[13:21:41.374]                 removed <- setdiff(old_names, names)
[13:21:41.374]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:41.374]                   envs[common]]
[13:21:41.374]                 NAMES <- toupper(changed)
[13:21:41.374]                 args <- list()
[13:21:41.374]                 for (kk in seq_along(NAMES)) {
[13:21:41.374]                   name <- changed[[kk]]
[13:21:41.374]                   NAME <- NAMES[[kk]]
[13:21:41.374]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.374]                     next
[13:21:41.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.374]                 }
[13:21:41.374]                 NAMES <- toupper(added)
[13:21:41.374]                 for (kk in seq_along(NAMES)) {
[13:21:41.374]                   name <- added[[kk]]
[13:21:41.374]                   NAME <- NAMES[[kk]]
[13:21:41.374]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.374]                     next
[13:21:41.374]                   args[[name]] <- ""
[13:21:41.374]                 }
[13:21:41.374]                 NAMES <- toupper(removed)
[13:21:41.374]                 for (kk in seq_along(NAMES)) {
[13:21:41.374]                   name <- removed[[kk]]
[13:21:41.374]                   NAME <- NAMES[[kk]]
[13:21:41.374]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.374]                     next
[13:21:41.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.374]                 }
[13:21:41.374]                 if (length(args) > 0) 
[13:21:41.374]                   base::do.call(base::Sys.setenv, args = args)
[13:21:41.374]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:41.374]             }
[13:21:41.374]             else {
[13:21:41.374]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:41.374]             }
[13:21:41.374]             {
[13:21:41.374]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:41.374]                   0L) {
[13:21:41.374]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:41.374]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:41.374]                   base::options(opts)
[13:21:41.374]                 }
[13:21:41.374]                 {
[13:21:41.374]                   {
[13:21:41.374]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:41.374]                     NULL
[13:21:41.374]                   }
[13:21:41.374]                   options(future.plan = NULL)
[13:21:41.374]                   if (is.na(NA_character_)) 
[13:21:41.374]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.374]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:41.374]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:41.374]                     envir = parent.frame()) 
[13:21:41.374]                   {
[13:21:41.374]                     default_workers <- missing(workers)
[13:21:41.374]                     if (is.function(workers)) 
[13:21:41.374]                       workers <- workers()
[13:21:41.374]                     workers <- structure(as.integer(workers), 
[13:21:41.374]                       class = class(workers))
[13:21:41.374]                     stop_if_not(is.finite(workers), workers >= 
[13:21:41.374]                       1L)
[13:21:41.374]                     if ((workers == 1L && !inherits(workers, 
[13:21:41.374]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:41.374]                       if (default_workers) 
[13:21:41.374]                         supportsMulticore(warn = TRUE)
[13:21:41.374]                       return(sequential(..., envir = envir))
[13:21:41.374]                     }
[13:21:41.374]                     oopts <- options(mc.cores = workers)
[13:21:41.374]                     on.exit(options(oopts))
[13:21:41.374]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:41.374]                       envir = envir)
[13:21:41.374]                     if (!future$lazy) 
[13:21:41.374]                       future <- run(future)
[13:21:41.374]                     invisible(future)
[13:21:41.374]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:41.374]                 }
[13:21:41.374]             }
[13:21:41.374]         }
[13:21:41.374]     })
[13:21:41.374]     if (TRUE) {
[13:21:41.374]         base::sink(type = "output", split = FALSE)
[13:21:41.374]         if (TRUE) {
[13:21:41.374]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:41.374]         }
[13:21:41.374]         else {
[13:21:41.374]             ...future.result["stdout"] <- base::list(NULL)
[13:21:41.374]         }
[13:21:41.374]         base::close(...future.stdout)
[13:21:41.374]         ...future.stdout <- NULL
[13:21:41.374]     }
[13:21:41.374]     ...future.result$conditions <- ...future.conditions
[13:21:41.374]     ...future.result$finished <- base::Sys.time()
[13:21:41.374]     ...future.result
[13:21:41.374] }
[13:21:41.377] assign_globals() ...
[13:21:41.377] List of 1
[13:21:41.377]  $ kk: int 3
[13:21:41.377]  - attr(*, "where")=List of 1
[13:21:41.377]   ..$ kk:<environment: R_EmptyEnv> 
[13:21:41.377]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:21:41.377]  - attr(*, "resolved")= logi FALSE
[13:21:41.377]  - attr(*, "total_size")= num 56
[13:21:41.377]  - attr(*, "already-done")= logi TRUE
[13:21:41.382] - copied ‘kk’ to environment
[13:21:41.383] assign_globals() ... done
[13:21:41.383] requestCore(): workers = 2
[13:21:41.383] Poll #1 (0): usedCores() = 2, workers = 2
[13:21:41.405] plan(): Setting new future strategy stack:
[13:21:41.405] List of future strategies:
[13:21:41.405] 1. multicore:
[13:21:41.405]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:41.405]    - tweaked: FALSE
[13:21:41.405]    - call: plan(strategy)
[13:21:41.410] plan(): nbrOfWorkers() = 2
[13:21:41.415] Poll #2 (0.03 secs): usedCores() = 2, workers = 2
[13:21:41.429] MulticoreFuture started
[13:21:41.430] - Launch lazy future ... done
[13:21:41.430] run() for ‘MulticoreFuture’ ... done
[13:21:41.431] plan(): Setting new future strategy stack:
[13:21:41.431] List of future strategies:
[13:21:41.431] 1. sequential:
[13:21:41.431]    - args: function (..., envir = parent.frame())
[13:21:41.431]    - tweaked: FALSE
[13:21:41.431]    - call: NULL
[13:21:41.432] plan(): nbrOfWorkers() = 1
[13:21:41.450] plan(): Setting new future strategy stack:
[13:21:41.450] List of future strategies:
[13:21:41.450] 1. multicore:
[13:21:41.450]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:41.450]    - tweaked: FALSE
[13:21:41.450]    - call: plan(strategy)
[13:21:41.451] Future #1
[13:21:41.452]  length: 2 (resolved future 1)
[13:21:41.454] plan(): nbrOfWorkers() = 2
[13:21:41.455] Future #2
[13:21:41.455]  length: 1 (resolved future 2)
[13:21:41.535] plan(): Setting new future strategy stack:
[13:21:41.535] List of future strategies:
[13:21:41.535] 1. multicore:
[13:21:41.535]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:41.535]    - tweaked: FALSE
[13:21:41.535]    - call: plan(strategy)
[13:21:41.541] plan(): nbrOfWorkers() = 2
[13:21:41.541] Future #3
[13:21:41.542]  length: 0 (resolved future 3)
[13:21:41.542] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[13:21:41.543] resolve() on environment ...
[13:21:41.543]  recursive: 0
[13:21:41.544]  elements: [2] ‘a’, ‘b’
[13:21:41.545]  length: 1 (resolved future 1)
[13:21:41.545]  length: 0 (resolved future 2)
[13:21:41.545] resolve() on environment ... DONE
[13:21:41.546] getGlobalsAndPackages() ...
[13:21:41.546] Searching for globals...
[13:21:41.546] 
[13:21:41.547] Searching for globals ... DONE
[13:21:41.547] - globals: [0] <none>
[13:21:41.547] getGlobalsAndPackages() ... DONE
[13:21:41.547] run() for ‘Future’ ...
[13:21:41.547] - state: ‘created’
[13:21:41.548] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:41.552] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:41.552] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:41.553]   - Field: ‘label’
[13:21:41.553]   - Field: ‘local’
[13:21:41.553]   - Field: ‘owner’
[13:21:41.553]   - Field: ‘envir’
[13:21:41.553]   - Field: ‘workers’
[13:21:41.553]   - Field: ‘packages’
[13:21:41.554]   - Field: ‘gc’
[13:21:41.554]   - Field: ‘job’
[13:21:41.554]   - Field: ‘conditions’
[13:21:41.554]   - Field: ‘expr’
[13:21:41.554]   - Field: ‘uuid’
[13:21:41.554]   - Field: ‘seed’
[13:21:41.555]   - Field: ‘version’
[13:21:41.555]   - Field: ‘result’
[13:21:41.555]   - Field: ‘asynchronous’
[13:21:41.555]   - Field: ‘calls’
[13:21:41.555]   - Field: ‘globals’
[13:21:41.555]   - Field: ‘stdout’
[13:21:41.555]   - Field: ‘earlySignal’
[13:21:41.556]   - Field: ‘lazy’
[13:21:41.556]   - Field: ‘state’
[13:21:41.556] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:41.556] - Launch lazy future ...
[13:21:41.557] Packages needed by the future expression (n = 0): <none>
[13:21:41.557] Packages needed by future strategies (n = 0): <none>
[13:21:41.558] {
[13:21:41.558]     {
[13:21:41.558]         {
[13:21:41.558]             ...future.startTime <- base::Sys.time()
[13:21:41.558]             {
[13:21:41.558]                 {
[13:21:41.558]                   {
[13:21:41.558]                     {
[13:21:41.558]                       base::local({
[13:21:41.558]                         has_future <- base::requireNamespace("future", 
[13:21:41.558]                           quietly = TRUE)
[13:21:41.558]                         if (has_future) {
[13:21:41.558]                           ns <- base::getNamespace("future")
[13:21:41.558]                           version <- ns[[".package"]][["version"]]
[13:21:41.558]                           if (is.null(version)) 
[13:21:41.558]                             version <- utils::packageVersion("future")
[13:21:41.558]                         }
[13:21:41.558]                         else {
[13:21:41.558]                           version <- NULL
[13:21:41.558]                         }
[13:21:41.558]                         if (!has_future || version < "1.8.0") {
[13:21:41.558]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:41.558]                             "", base::R.version$version.string), 
[13:21:41.558]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:41.558]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:41.558]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:41.558]                               "release", "version")], collapse = " "), 
[13:21:41.558]                             hostname = base::Sys.info()[["nodename"]])
[13:21:41.558]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:41.558]                             info)
[13:21:41.558]                           info <- base::paste(info, collapse = "; ")
[13:21:41.558]                           if (!has_future) {
[13:21:41.558]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:41.558]                               info)
[13:21:41.558]                           }
[13:21:41.558]                           else {
[13:21:41.558]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:41.558]                               info, version)
[13:21:41.558]                           }
[13:21:41.558]                           base::stop(msg)
[13:21:41.558]                         }
[13:21:41.558]                       })
[13:21:41.558]                     }
[13:21:41.558]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:41.558]                     base::options(mc.cores = 1L)
[13:21:41.558]                   }
[13:21:41.558]                   options(future.plan = NULL)
[13:21:41.558]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.558]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:41.558]                 }
[13:21:41.558]                 ...future.workdir <- getwd()
[13:21:41.558]             }
[13:21:41.558]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:41.558]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:41.558]         }
[13:21:41.558]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:41.558]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:41.558]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:41.558]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:41.558]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:41.558]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:41.558]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:41.558]             base::names(...future.oldOptions))
[13:21:41.558]     }
[13:21:41.558]     if (FALSE) {
[13:21:41.558]     }
[13:21:41.558]     else {
[13:21:41.558]         if (TRUE) {
[13:21:41.558]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:41.558]                 open = "w")
[13:21:41.558]         }
[13:21:41.558]         else {
[13:21:41.558]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:41.558]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:41.558]         }
[13:21:41.558]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:41.558]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:41.558]             base::sink(type = "output", split = FALSE)
[13:21:41.558]             base::close(...future.stdout)
[13:21:41.558]         }, add = TRUE)
[13:21:41.558]     }
[13:21:41.558]     ...future.frame <- base::sys.nframe()
[13:21:41.558]     ...future.conditions <- base::list()
[13:21:41.558]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:41.558]     if (FALSE) {
[13:21:41.558]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:41.558]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:41.558]     }
[13:21:41.558]     ...future.result <- base::tryCatch({
[13:21:41.558]         base::withCallingHandlers({
[13:21:41.558]             ...future.value <- base::withVisible(base::local({
[13:21:41.558]                 withCallingHandlers({
[13:21:41.558]                   1
[13:21:41.558]                 }, immediateCondition = function(cond) {
[13:21:41.558]                   save_rds <- function (object, pathname, ...) 
[13:21:41.558]                   {
[13:21:41.558]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:41.558]                     if (file_test("-f", pathname_tmp)) {
[13:21:41.558]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.558]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:41.558]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.558]                         fi_tmp[["mtime"]])
[13:21:41.558]                     }
[13:21:41.558]                     tryCatch({
[13:21:41.558]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:41.558]                     }, error = function(ex) {
[13:21:41.558]                       msg <- conditionMessage(ex)
[13:21:41.558]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.558]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:41.558]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.558]                         fi_tmp[["mtime"]], msg)
[13:21:41.558]                       ex$message <- msg
[13:21:41.558]                       stop(ex)
[13:21:41.558]                     })
[13:21:41.558]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:41.558]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:41.558]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:41.558]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.558]                       fi <- file.info(pathname)
[13:21:41.558]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:41.558]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.558]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:41.558]                         fi[["size"]], fi[["mtime"]])
[13:21:41.558]                       stop(msg)
[13:21:41.558]                     }
[13:21:41.558]                     invisible(pathname)
[13:21:41.558]                   }
[13:21:41.558]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:41.558]                     rootPath = tempdir()) 
[13:21:41.558]                   {
[13:21:41.558]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:41.558]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:41.558]                       tmpdir = path, fileext = ".rds")
[13:21:41.558]                     save_rds(obj, file)
[13:21:41.558]                   }
[13:21:41.558]                   saveImmediateCondition(cond, path = "/tmp/RtmpRIPAyw/.future/immediateConditions")
[13:21:41.558]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.558]                   {
[13:21:41.558]                     inherits <- base::inherits
[13:21:41.558]                     invokeRestart <- base::invokeRestart
[13:21:41.558]                     is.null <- base::is.null
[13:21:41.558]                     muffled <- FALSE
[13:21:41.558]                     if (inherits(cond, "message")) {
[13:21:41.558]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:41.558]                       if (muffled) 
[13:21:41.558]                         invokeRestart("muffleMessage")
[13:21:41.558]                     }
[13:21:41.558]                     else if (inherits(cond, "warning")) {
[13:21:41.558]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:41.558]                       if (muffled) 
[13:21:41.558]                         invokeRestart("muffleWarning")
[13:21:41.558]                     }
[13:21:41.558]                     else if (inherits(cond, "condition")) {
[13:21:41.558]                       if (!is.null(pattern)) {
[13:21:41.558]                         computeRestarts <- base::computeRestarts
[13:21:41.558]                         grepl <- base::grepl
[13:21:41.558]                         restarts <- computeRestarts(cond)
[13:21:41.558]                         for (restart in restarts) {
[13:21:41.558]                           name <- restart$name
[13:21:41.558]                           if (is.null(name)) 
[13:21:41.558]                             next
[13:21:41.558]                           if (!grepl(pattern, name)) 
[13:21:41.558]                             next
[13:21:41.558]                           invokeRestart(restart)
[13:21:41.558]                           muffled <- TRUE
[13:21:41.558]                           break
[13:21:41.558]                         }
[13:21:41.558]                       }
[13:21:41.558]                     }
[13:21:41.558]                     invisible(muffled)
[13:21:41.558]                   }
[13:21:41.558]                   muffleCondition(cond)
[13:21:41.558]                 })
[13:21:41.558]             }))
[13:21:41.558]             future::FutureResult(value = ...future.value$value, 
[13:21:41.558]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.558]                   ...future.rng), globalenv = if (FALSE) 
[13:21:41.558]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:41.558]                     ...future.globalenv.names))
[13:21:41.558]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:41.558]         }, condition = base::local({
[13:21:41.558]             c <- base::c
[13:21:41.558]             inherits <- base::inherits
[13:21:41.558]             invokeRestart <- base::invokeRestart
[13:21:41.558]             length <- base::length
[13:21:41.558]             list <- base::list
[13:21:41.558]             seq.int <- base::seq.int
[13:21:41.558]             signalCondition <- base::signalCondition
[13:21:41.558]             sys.calls <- base::sys.calls
[13:21:41.558]             `[[` <- base::`[[`
[13:21:41.558]             `+` <- base::`+`
[13:21:41.558]             `<<-` <- base::`<<-`
[13:21:41.558]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:41.558]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:41.558]                   3L)]
[13:21:41.558]             }
[13:21:41.558]             function(cond) {
[13:21:41.558]                 is_error <- inherits(cond, "error")
[13:21:41.558]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:41.558]                   NULL)
[13:21:41.558]                 if (is_error) {
[13:21:41.558]                   sessionInformation <- function() {
[13:21:41.558]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:41.558]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:41.558]                       search = base::search(), system = base::Sys.info())
[13:21:41.558]                   }
[13:21:41.558]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.558]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:41.558]                     cond$call), session = sessionInformation(), 
[13:21:41.558]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:41.558]                   signalCondition(cond)
[13:21:41.558]                 }
[13:21:41.558]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:41.558]                 "immediateCondition"))) {
[13:21:41.558]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:41.558]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.558]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:41.558]                   if (TRUE && !signal) {
[13:21:41.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.558]                     {
[13:21:41.558]                       inherits <- base::inherits
[13:21:41.558]                       invokeRestart <- base::invokeRestart
[13:21:41.558]                       is.null <- base::is.null
[13:21:41.558]                       muffled <- FALSE
[13:21:41.558]                       if (inherits(cond, "message")) {
[13:21:41.558]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.558]                         if (muffled) 
[13:21:41.558]                           invokeRestart("muffleMessage")
[13:21:41.558]                       }
[13:21:41.558]                       else if (inherits(cond, "warning")) {
[13:21:41.558]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.558]                         if (muffled) 
[13:21:41.558]                           invokeRestart("muffleWarning")
[13:21:41.558]                       }
[13:21:41.558]                       else if (inherits(cond, "condition")) {
[13:21:41.558]                         if (!is.null(pattern)) {
[13:21:41.558]                           computeRestarts <- base::computeRestarts
[13:21:41.558]                           grepl <- base::grepl
[13:21:41.558]                           restarts <- computeRestarts(cond)
[13:21:41.558]                           for (restart in restarts) {
[13:21:41.558]                             name <- restart$name
[13:21:41.558]                             if (is.null(name)) 
[13:21:41.558]                               next
[13:21:41.558]                             if (!grepl(pattern, name)) 
[13:21:41.558]                               next
[13:21:41.558]                             invokeRestart(restart)
[13:21:41.558]                             muffled <- TRUE
[13:21:41.558]                             break
[13:21:41.558]                           }
[13:21:41.558]                         }
[13:21:41.558]                       }
[13:21:41.558]                       invisible(muffled)
[13:21:41.558]                     }
[13:21:41.558]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.558]                   }
[13:21:41.558]                 }
[13:21:41.558]                 else {
[13:21:41.558]                   if (TRUE) {
[13:21:41.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.558]                     {
[13:21:41.558]                       inherits <- base::inherits
[13:21:41.558]                       invokeRestart <- base::invokeRestart
[13:21:41.558]                       is.null <- base::is.null
[13:21:41.558]                       muffled <- FALSE
[13:21:41.558]                       if (inherits(cond, "message")) {
[13:21:41.558]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.558]                         if (muffled) 
[13:21:41.558]                           invokeRestart("muffleMessage")
[13:21:41.558]                       }
[13:21:41.558]                       else if (inherits(cond, "warning")) {
[13:21:41.558]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.558]                         if (muffled) 
[13:21:41.558]                           invokeRestart("muffleWarning")
[13:21:41.558]                       }
[13:21:41.558]                       else if (inherits(cond, "condition")) {
[13:21:41.558]                         if (!is.null(pattern)) {
[13:21:41.558]                           computeRestarts <- base::computeRestarts
[13:21:41.558]                           grepl <- base::grepl
[13:21:41.558]                           restarts <- computeRestarts(cond)
[13:21:41.558]                           for (restart in restarts) {
[13:21:41.558]                             name <- restart$name
[13:21:41.558]                             if (is.null(name)) 
[13:21:41.558]                               next
[13:21:41.558]                             if (!grepl(pattern, name)) 
[13:21:41.558]                               next
[13:21:41.558]                             invokeRestart(restart)
[13:21:41.558]                             muffled <- TRUE
[13:21:41.558]                             break
[13:21:41.558]                           }
[13:21:41.558]                         }
[13:21:41.558]                       }
[13:21:41.558]                       invisible(muffled)
[13:21:41.558]                     }
[13:21:41.558]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.558]                   }
[13:21:41.558]                 }
[13:21:41.558]             }
[13:21:41.558]         }))
[13:21:41.558]     }, error = function(ex) {
[13:21:41.558]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:41.558]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.558]                 ...future.rng), started = ...future.startTime, 
[13:21:41.558]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:41.558]             version = "1.8"), class = "FutureResult")
[13:21:41.558]     }, finally = {
[13:21:41.558]         if (!identical(...future.workdir, getwd())) 
[13:21:41.558]             setwd(...future.workdir)
[13:21:41.558]         {
[13:21:41.558]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:41.558]                 ...future.oldOptions$nwarnings <- NULL
[13:21:41.558]             }
[13:21:41.558]             base::options(...future.oldOptions)
[13:21:41.558]             if (.Platform$OS.type == "windows") {
[13:21:41.558]                 old_names <- names(...future.oldEnvVars)
[13:21:41.558]                 envs <- base::Sys.getenv()
[13:21:41.558]                 names <- names(envs)
[13:21:41.558]                 common <- intersect(names, old_names)
[13:21:41.558]                 added <- setdiff(names, old_names)
[13:21:41.558]                 removed <- setdiff(old_names, names)
[13:21:41.558]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:41.558]                   envs[common]]
[13:21:41.558]                 NAMES <- toupper(changed)
[13:21:41.558]                 args <- list()
[13:21:41.558]                 for (kk in seq_along(NAMES)) {
[13:21:41.558]                   name <- changed[[kk]]
[13:21:41.558]                   NAME <- NAMES[[kk]]
[13:21:41.558]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.558]                     next
[13:21:41.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.558]                 }
[13:21:41.558]                 NAMES <- toupper(added)
[13:21:41.558]                 for (kk in seq_along(NAMES)) {
[13:21:41.558]                   name <- added[[kk]]
[13:21:41.558]                   NAME <- NAMES[[kk]]
[13:21:41.558]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.558]                     next
[13:21:41.558]                   args[[name]] <- ""
[13:21:41.558]                 }
[13:21:41.558]                 NAMES <- toupper(removed)
[13:21:41.558]                 for (kk in seq_along(NAMES)) {
[13:21:41.558]                   name <- removed[[kk]]
[13:21:41.558]                   NAME <- NAMES[[kk]]
[13:21:41.558]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.558]                     next
[13:21:41.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.558]                 }
[13:21:41.558]                 if (length(args) > 0) 
[13:21:41.558]                   base::do.call(base::Sys.setenv, args = args)
[13:21:41.558]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:41.558]             }
[13:21:41.558]             else {
[13:21:41.558]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:41.558]             }
[13:21:41.558]             {
[13:21:41.558]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:41.558]                   0L) {
[13:21:41.558]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:41.558]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:41.558]                   base::options(opts)
[13:21:41.558]                 }
[13:21:41.558]                 {
[13:21:41.558]                   {
[13:21:41.558]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:41.558]                     NULL
[13:21:41.558]                   }
[13:21:41.558]                   options(future.plan = NULL)
[13:21:41.558]                   if (is.na(NA_character_)) 
[13:21:41.558]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.558]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:41.558]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:41.558]                     envir = parent.frame()) 
[13:21:41.558]                   {
[13:21:41.558]                     default_workers <- missing(workers)
[13:21:41.558]                     if (is.function(workers)) 
[13:21:41.558]                       workers <- workers()
[13:21:41.558]                     workers <- structure(as.integer(workers), 
[13:21:41.558]                       class = class(workers))
[13:21:41.558]                     stop_if_not(is.finite(workers), workers >= 
[13:21:41.558]                       1L)
[13:21:41.558]                     if ((workers == 1L && !inherits(workers, 
[13:21:41.558]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:41.558]                       if (default_workers) 
[13:21:41.558]                         supportsMulticore(warn = TRUE)
[13:21:41.558]                       return(sequential(..., envir = envir))
[13:21:41.558]                     }
[13:21:41.558]                     oopts <- options(mc.cores = workers)
[13:21:41.558]                     on.exit(options(oopts))
[13:21:41.558]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:41.558]                       envir = envir)
[13:21:41.558]                     if (!future$lazy) 
[13:21:41.558]                       future <- run(future)
[13:21:41.558]                     invisible(future)
[13:21:41.558]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:41.558]                 }
[13:21:41.558]             }
[13:21:41.558]         }
[13:21:41.558]     })
[13:21:41.558]     if (TRUE) {
[13:21:41.558]         base::sink(type = "output", split = FALSE)
[13:21:41.558]         if (TRUE) {
[13:21:41.558]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:41.558]         }
[13:21:41.558]         else {
[13:21:41.558]             ...future.result["stdout"] <- base::list(NULL)
[13:21:41.558]         }
[13:21:41.558]         base::close(...future.stdout)
[13:21:41.558]         ...future.stdout <- NULL
[13:21:41.558]     }
[13:21:41.558]     ...future.result$conditions <- ...future.conditions
[13:21:41.558]     ...future.result$finished <- base::Sys.time()
[13:21:41.558]     ...future.result
[13:21:41.558] }
[13:21:41.561] requestCore(): workers = 2
[13:21:41.561] Poll #1 (0): usedCores() = 2, workers = 2
[13:21:41.576] MulticoreFuture started
[13:21:41.576] - Launch lazy future ... done
[13:21:41.577] run() for ‘MulticoreFuture’ ... done
[13:21:41.577] getGlobalsAndPackages() ...
[13:21:41.577] plan(): Setting new future strategy stack:
[13:21:41.577] Searching for globals...
[13:21:41.577] List of future strategies:
[13:21:41.577] 1. sequential:
[13:21:41.577]    - args: function (..., envir = parent.frame())
[13:21:41.577]    - tweaked: FALSE
[13:21:41.577]    - call: NULL
[13:21:41.578] 
[13:21:41.578] Searching for globals ... DONE
[13:21:41.578] plan(): nbrOfWorkers() = 1
[13:21:41.578] - globals: [0] <none>
[13:21:41.579] getGlobalsAndPackages() ... DONE
[13:21:41.579] run() for ‘Future’ ...
[13:21:41.579] - state: ‘created’
[13:21:41.579] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:41.580] plan(): Setting new future strategy stack:
[13:21:41.580] List of future strategies:
[13:21:41.580] 1. multicore:
[13:21:41.580]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:41.580]    - tweaked: FALSE
[13:21:41.580]    - call: plan(strategy)
[13:21:41.585] plan(): nbrOfWorkers() = 2
[13:21:41.585] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:41.585] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:41.586]   - Field: ‘label’
[13:21:41.586]   - Field: ‘local’
[13:21:41.586]   - Field: ‘owner’
[13:21:41.586]   - Field: ‘envir’
[13:21:41.586]   - Field: ‘workers’
[13:21:41.586]   - Field: ‘packages’
[13:21:41.587]   - Field: ‘gc’
[13:21:41.587]   - Field: ‘job’
[13:21:41.587]   - Field: ‘conditions’
[13:21:41.587]   - Field: ‘expr’
[13:21:41.587]   - Field: ‘uuid’
[13:21:41.587]   - Field: ‘seed’
[13:21:41.587]   - Field: ‘version’
[13:21:41.588]   - Field: ‘result’
[13:21:41.588]   - Field: ‘asynchronous’
[13:21:41.588]   - Field: ‘calls’
[13:21:41.588]   - Field: ‘globals’
[13:21:41.588]   - Field: ‘stdout’
[13:21:41.588]   - Field: ‘earlySignal’
[13:21:41.589]   - Field: ‘lazy’
[13:21:41.589]   - Field: ‘state’
[13:21:41.589] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:41.589] - Launch lazy future ...
[13:21:41.589] Packages needed by the future expression (n = 0): <none>
[13:21:41.590] Packages needed by future strategies (n = 0): <none>
[13:21:41.590] {
[13:21:41.590]     {
[13:21:41.590]         {
[13:21:41.590]             ...future.startTime <- base::Sys.time()
[13:21:41.590]             {
[13:21:41.590]                 {
[13:21:41.590]                   {
[13:21:41.590]                     {
[13:21:41.590]                       base::local({
[13:21:41.590]                         has_future <- base::requireNamespace("future", 
[13:21:41.590]                           quietly = TRUE)
[13:21:41.590]                         if (has_future) {
[13:21:41.590]                           ns <- base::getNamespace("future")
[13:21:41.590]                           version <- ns[[".package"]][["version"]]
[13:21:41.590]                           if (is.null(version)) 
[13:21:41.590]                             version <- utils::packageVersion("future")
[13:21:41.590]                         }
[13:21:41.590]                         else {
[13:21:41.590]                           version <- NULL
[13:21:41.590]                         }
[13:21:41.590]                         if (!has_future || version < "1.8.0") {
[13:21:41.590]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:41.590]                             "", base::R.version$version.string), 
[13:21:41.590]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:41.590]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:41.590]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:41.590]                               "release", "version")], collapse = " "), 
[13:21:41.590]                             hostname = base::Sys.info()[["nodename"]])
[13:21:41.590]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:41.590]                             info)
[13:21:41.590]                           info <- base::paste(info, collapse = "; ")
[13:21:41.590]                           if (!has_future) {
[13:21:41.590]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:41.590]                               info)
[13:21:41.590]                           }
[13:21:41.590]                           else {
[13:21:41.590]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:41.590]                               info, version)
[13:21:41.590]                           }
[13:21:41.590]                           base::stop(msg)
[13:21:41.590]                         }
[13:21:41.590]                       })
[13:21:41.590]                     }
[13:21:41.590]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:41.590]                     base::options(mc.cores = 1L)
[13:21:41.590]                   }
[13:21:41.590]                   options(future.plan = NULL)
[13:21:41.590]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.590]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:41.590]                 }
[13:21:41.590]                 ...future.workdir <- getwd()
[13:21:41.590]             }
[13:21:41.590]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:41.590]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:41.590]         }
[13:21:41.590]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:41.590]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:41.590]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:41.590]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:41.590]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:41.590]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:41.590]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:41.590]             base::names(...future.oldOptions))
[13:21:41.590]     }
[13:21:41.590]     if (FALSE) {
[13:21:41.590]     }
[13:21:41.590]     else {
[13:21:41.590]         if (TRUE) {
[13:21:41.590]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:41.590]                 open = "w")
[13:21:41.590]         }
[13:21:41.590]         else {
[13:21:41.590]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:41.590]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:41.590]         }
[13:21:41.590]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:41.590]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:41.590]             base::sink(type = "output", split = FALSE)
[13:21:41.590]             base::close(...future.stdout)
[13:21:41.590]         }, add = TRUE)
[13:21:41.590]     }
[13:21:41.590]     ...future.frame <- base::sys.nframe()
[13:21:41.590]     ...future.conditions <- base::list()
[13:21:41.590]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:41.590]     if (FALSE) {
[13:21:41.590]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:41.590]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:41.590]     }
[13:21:41.590]     ...future.result <- base::tryCatch({
[13:21:41.590]         base::withCallingHandlers({
[13:21:41.590]             ...future.value <- base::withVisible(base::local({
[13:21:41.590]                 withCallingHandlers({
[13:21:41.590]                   2
[13:21:41.590]                 }, immediateCondition = function(cond) {
[13:21:41.590]                   save_rds <- function (object, pathname, ...) 
[13:21:41.590]                   {
[13:21:41.590]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:41.590]                     if (file_test("-f", pathname_tmp)) {
[13:21:41.590]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.590]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:41.590]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.590]                         fi_tmp[["mtime"]])
[13:21:41.590]                     }
[13:21:41.590]                     tryCatch({
[13:21:41.590]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:41.590]                     }, error = function(ex) {
[13:21:41.590]                       msg <- conditionMessage(ex)
[13:21:41.590]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.590]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:41.590]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.590]                         fi_tmp[["mtime"]], msg)
[13:21:41.590]                       ex$message <- msg
[13:21:41.590]                       stop(ex)
[13:21:41.590]                     })
[13:21:41.590]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:41.590]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:41.590]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:41.590]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.590]                       fi <- file.info(pathname)
[13:21:41.590]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:41.590]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.590]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:41.590]                         fi[["size"]], fi[["mtime"]])
[13:21:41.590]                       stop(msg)
[13:21:41.590]                     }
[13:21:41.590]                     invisible(pathname)
[13:21:41.590]                   }
[13:21:41.590]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:41.590]                     rootPath = tempdir()) 
[13:21:41.590]                   {
[13:21:41.590]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:41.590]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:41.590]                       tmpdir = path, fileext = ".rds")
[13:21:41.590]                     save_rds(obj, file)
[13:21:41.590]                   }
[13:21:41.590]                   saveImmediateCondition(cond, path = "/tmp/RtmpRIPAyw/.future/immediateConditions")
[13:21:41.590]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.590]                   {
[13:21:41.590]                     inherits <- base::inherits
[13:21:41.590]                     invokeRestart <- base::invokeRestart
[13:21:41.590]                     is.null <- base::is.null
[13:21:41.590]                     muffled <- FALSE
[13:21:41.590]                     if (inherits(cond, "message")) {
[13:21:41.590]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:41.590]                       if (muffled) 
[13:21:41.590]                         invokeRestart("muffleMessage")
[13:21:41.590]                     }
[13:21:41.590]                     else if (inherits(cond, "warning")) {
[13:21:41.590]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:41.590]                       if (muffled) 
[13:21:41.590]                         invokeRestart("muffleWarning")
[13:21:41.590]                     }
[13:21:41.590]                     else if (inherits(cond, "condition")) {
[13:21:41.590]                       if (!is.null(pattern)) {
[13:21:41.590]                         computeRestarts <- base::computeRestarts
[13:21:41.590]                         grepl <- base::grepl
[13:21:41.590]                         restarts <- computeRestarts(cond)
[13:21:41.590]                         for (restart in restarts) {
[13:21:41.590]                           name <- restart$name
[13:21:41.590]                           if (is.null(name)) 
[13:21:41.590]                             next
[13:21:41.590]                           if (!grepl(pattern, name)) 
[13:21:41.590]                             next
[13:21:41.590]                           invokeRestart(restart)
[13:21:41.590]                           muffled <- TRUE
[13:21:41.590]                           break
[13:21:41.590]                         }
[13:21:41.590]                       }
[13:21:41.590]                     }
[13:21:41.590]                     invisible(muffled)
[13:21:41.590]                   }
[13:21:41.590]                   muffleCondition(cond)
[13:21:41.590]                 })
[13:21:41.590]             }))
[13:21:41.590]             future::FutureResult(value = ...future.value$value, 
[13:21:41.590]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.590]                   ...future.rng), globalenv = if (FALSE) 
[13:21:41.590]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:41.590]                     ...future.globalenv.names))
[13:21:41.590]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:41.590]         }, condition = base::local({
[13:21:41.590]             c <- base::c
[13:21:41.590]             inherits <- base::inherits
[13:21:41.590]             invokeRestart <- base::invokeRestart
[13:21:41.590]             length <- base::length
[13:21:41.590]             list <- base::list
[13:21:41.590]             seq.int <- base::seq.int
[13:21:41.590]             signalCondition <- base::signalCondition
[13:21:41.590]             sys.calls <- base::sys.calls
[13:21:41.590]             `[[` <- base::`[[`
[13:21:41.590]             `+` <- base::`+`
[13:21:41.590]             `<<-` <- base::`<<-`
[13:21:41.590]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:41.590]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:41.590]                   3L)]
[13:21:41.590]             }
[13:21:41.590]             function(cond) {
[13:21:41.590]                 is_error <- inherits(cond, "error")
[13:21:41.590]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:41.590]                   NULL)
[13:21:41.590]                 if (is_error) {
[13:21:41.590]                   sessionInformation <- function() {
[13:21:41.590]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:41.590]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:41.590]                       search = base::search(), system = base::Sys.info())
[13:21:41.590]                   }
[13:21:41.590]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.590]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:41.590]                     cond$call), session = sessionInformation(), 
[13:21:41.590]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:41.590]                   signalCondition(cond)
[13:21:41.590]                 }
[13:21:41.590]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:41.590]                 "immediateCondition"))) {
[13:21:41.590]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:41.590]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.590]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:41.590]                   if (TRUE && !signal) {
[13:21:41.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.590]                     {
[13:21:41.590]                       inherits <- base::inherits
[13:21:41.590]                       invokeRestart <- base::invokeRestart
[13:21:41.590]                       is.null <- base::is.null
[13:21:41.590]                       muffled <- FALSE
[13:21:41.590]                       if (inherits(cond, "message")) {
[13:21:41.590]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.590]                         if (muffled) 
[13:21:41.590]                           invokeRestart("muffleMessage")
[13:21:41.590]                       }
[13:21:41.590]                       else if (inherits(cond, "warning")) {
[13:21:41.590]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.590]                         if (muffled) 
[13:21:41.590]                           invokeRestart("muffleWarning")
[13:21:41.590]                       }
[13:21:41.590]                       else if (inherits(cond, "condition")) {
[13:21:41.590]                         if (!is.null(pattern)) {
[13:21:41.590]                           computeRestarts <- base::computeRestarts
[13:21:41.590]                           grepl <- base::grepl
[13:21:41.590]                           restarts <- computeRestarts(cond)
[13:21:41.590]                           for (restart in restarts) {
[13:21:41.590]                             name <- restart$name
[13:21:41.590]                             if (is.null(name)) 
[13:21:41.590]                               next
[13:21:41.590]                             if (!grepl(pattern, name)) 
[13:21:41.590]                               next
[13:21:41.590]                             invokeRestart(restart)
[13:21:41.590]                             muffled <- TRUE
[13:21:41.590]                             break
[13:21:41.590]                           }
[13:21:41.590]                         }
[13:21:41.590]                       }
[13:21:41.590]                       invisible(muffled)
[13:21:41.590]                     }
[13:21:41.590]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.590]                   }
[13:21:41.590]                 }
[13:21:41.590]                 else {
[13:21:41.590]                   if (TRUE) {
[13:21:41.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.590]                     {
[13:21:41.590]                       inherits <- base::inherits
[13:21:41.590]                       invokeRestart <- base::invokeRestart
[13:21:41.590]                       is.null <- base::is.null
[13:21:41.590]                       muffled <- FALSE
[13:21:41.590]                       if (inherits(cond, "message")) {
[13:21:41.590]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.590]                         if (muffled) 
[13:21:41.590]                           invokeRestart("muffleMessage")
[13:21:41.590]                       }
[13:21:41.590]                       else if (inherits(cond, "warning")) {
[13:21:41.590]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.590]                         if (muffled) 
[13:21:41.590]                           invokeRestart("muffleWarning")
[13:21:41.590]                       }
[13:21:41.590]                       else if (inherits(cond, "condition")) {
[13:21:41.590]                         if (!is.null(pattern)) {
[13:21:41.590]                           computeRestarts <- base::computeRestarts
[13:21:41.590]                           grepl <- base::grepl
[13:21:41.590]                           restarts <- computeRestarts(cond)
[13:21:41.590]                           for (restart in restarts) {
[13:21:41.590]                             name <- restart$name
[13:21:41.590]                             if (is.null(name)) 
[13:21:41.590]                               next
[13:21:41.590]                             if (!grepl(pattern, name)) 
[13:21:41.590]                               next
[13:21:41.590]                             invokeRestart(restart)
[13:21:41.590]                             muffled <- TRUE
[13:21:41.590]                             break
[13:21:41.590]                           }
[13:21:41.590]                         }
[13:21:41.590]                       }
[13:21:41.590]                       invisible(muffled)
[13:21:41.590]                     }
[13:21:41.590]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.590]                   }
[13:21:41.590]                 }
[13:21:41.590]             }
[13:21:41.590]         }))
[13:21:41.590]     }, error = function(ex) {
[13:21:41.590]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:41.590]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.590]                 ...future.rng), started = ...future.startTime, 
[13:21:41.590]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:41.590]             version = "1.8"), class = "FutureResult")
[13:21:41.590]     }, finally = {
[13:21:41.590]         if (!identical(...future.workdir, getwd())) 
[13:21:41.590]             setwd(...future.workdir)
[13:21:41.590]         {
[13:21:41.590]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:41.590]                 ...future.oldOptions$nwarnings <- NULL
[13:21:41.590]             }
[13:21:41.590]             base::options(...future.oldOptions)
[13:21:41.590]             if (.Platform$OS.type == "windows") {
[13:21:41.590]                 old_names <- names(...future.oldEnvVars)
[13:21:41.590]                 envs <- base::Sys.getenv()
[13:21:41.590]                 names <- names(envs)
[13:21:41.590]                 common <- intersect(names, old_names)
[13:21:41.590]                 added <- setdiff(names, old_names)
[13:21:41.590]                 removed <- setdiff(old_names, names)
[13:21:41.590]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:41.590]                   envs[common]]
[13:21:41.590]                 NAMES <- toupper(changed)
[13:21:41.590]                 args <- list()
[13:21:41.590]                 for (kk in seq_along(NAMES)) {
[13:21:41.590]                   name <- changed[[kk]]
[13:21:41.590]                   NAME <- NAMES[[kk]]
[13:21:41.590]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.590]                     next
[13:21:41.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.590]                 }
[13:21:41.590]                 NAMES <- toupper(added)
[13:21:41.590]                 for (kk in seq_along(NAMES)) {
[13:21:41.590]                   name <- added[[kk]]
[13:21:41.590]                   NAME <- NAMES[[kk]]
[13:21:41.590]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.590]                     next
[13:21:41.590]                   args[[name]] <- ""
[13:21:41.590]                 }
[13:21:41.590]                 NAMES <- toupper(removed)
[13:21:41.590]                 for (kk in seq_along(NAMES)) {
[13:21:41.590]                   name <- removed[[kk]]
[13:21:41.590]                   NAME <- NAMES[[kk]]
[13:21:41.590]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.590]                     next
[13:21:41.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.590]                 }
[13:21:41.590]                 if (length(args) > 0) 
[13:21:41.590]                   base::do.call(base::Sys.setenv, args = args)
[13:21:41.590]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:41.590]             }
[13:21:41.590]             else {
[13:21:41.590]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:41.590]             }
[13:21:41.590]             {
[13:21:41.590]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:41.590]                   0L) {
[13:21:41.590]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:41.590]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:41.590]                   base::options(opts)
[13:21:41.590]                 }
[13:21:41.590]                 {
[13:21:41.590]                   {
[13:21:41.590]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:41.590]                     NULL
[13:21:41.590]                   }
[13:21:41.590]                   options(future.plan = NULL)
[13:21:41.590]                   if (is.na(NA_character_)) 
[13:21:41.590]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.590]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:41.590]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:41.590]                     envir = parent.frame()) 
[13:21:41.590]                   {
[13:21:41.590]                     default_workers <- missing(workers)
[13:21:41.590]                     if (is.function(workers)) 
[13:21:41.590]                       workers <- workers()
[13:21:41.590]                     workers <- structure(as.integer(workers), 
[13:21:41.590]                       class = class(workers))
[13:21:41.590]                     stop_if_not(is.finite(workers), workers >= 
[13:21:41.590]                       1L)
[13:21:41.590]                     if ((workers == 1L && !inherits(workers, 
[13:21:41.590]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:41.590]                       if (default_workers) 
[13:21:41.590]                         supportsMulticore(warn = TRUE)
[13:21:41.590]                       return(sequential(..., envir = envir))
[13:21:41.590]                     }
[13:21:41.590]                     oopts <- options(mc.cores = workers)
[13:21:41.590]                     on.exit(options(oopts))
[13:21:41.590]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:41.590]                       envir = envir)
[13:21:41.590]                     if (!future$lazy) 
[13:21:41.590]                       future <- run(future)
[13:21:41.590]                     invisible(future)
[13:21:41.590]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:41.590]                 }
[13:21:41.590]             }
[13:21:41.590]         }
[13:21:41.590]     })
[13:21:41.590]     if (TRUE) {
[13:21:41.590]         base::sink(type = "output", split = FALSE)
[13:21:41.590]         if (TRUE) {
[13:21:41.590]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:41.590]         }
[13:21:41.590]         else {
[13:21:41.590]             ...future.result["stdout"] <- base::list(NULL)
[13:21:41.590]         }
[13:21:41.590]         base::close(...future.stdout)
[13:21:41.590]         ...future.stdout <- NULL
[13:21:41.590]     }
[13:21:41.590]     ...future.result$conditions <- ...future.conditions
[13:21:41.590]     ...future.result$finished <- base::Sys.time()
[13:21:41.590]     ...future.result
[13:21:41.590] }
[13:21:41.594] requestCore(): workers = 2
[13:21:41.594] Poll #1 (0): usedCores() = 2, workers = 2
[13:21:41.609] MulticoreFuture started
[13:21:41.615] - Launch lazy future ... done
[13:21:41.616] plan(): Setting new future strategy stack:
[13:21:41.616] run() for ‘MulticoreFuture’ ... done
[13:21:41.616] List of future strategies:
[13:21:41.616] 1. sequential:
[13:21:41.616]    - args: function (..., envir = parent.frame())
[13:21:41.616]    - tweaked: FALSE
[13:21:41.616]    - call: NULL
[13:21:41.618] plan(): nbrOfWorkers() = 1
[13:21:41.618] resolve() on environment ...
[13:21:41.619]  recursive: 0
[13:21:41.620] plan(): Setting new future strategy stack:
[13:21:41.621]  elements: [3] ‘a’, ‘b’, ‘c’
[13:21:41.621] List of future strategies:
[13:21:41.621] 1. multicore:
[13:21:41.621]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:41.621]    - tweaked: FALSE
[13:21:41.621]    - call: plan(strategy)
[13:21:41.621] Future #1
[13:21:41.621]  length: 2 (resolved future 1)
[13:21:41.626] plan(): nbrOfWorkers() = 2
[13:21:41.626] Future #2
[13:21:41.626]  length: 1 (resolved future 2)
[13:21:41.627]  length: 0 (resolved future 3)
[13:21:41.627] resolve() on environment ... DONE
[13:21:41.628] getGlobalsAndPackages() ...
[13:21:41.628] Searching for globals...
[13:21:41.630] - globals found: [1] ‘{’
[13:21:41.630] Searching for globals ... DONE
[13:21:41.630] Resolving globals: FALSE
[13:21:41.630] 
[13:21:41.631] 
[13:21:41.631] getGlobalsAndPackages() ... DONE
[13:21:41.632] run() for ‘Future’ ...
[13:21:41.632] - state: ‘created’
[13:21:41.632] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:41.637] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:41.637] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:41.637]   - Field: ‘label’
[13:21:41.637]   - Field: ‘local’
[13:21:41.637]   - Field: ‘owner’
[13:21:41.637]   - Field: ‘envir’
[13:21:41.638]   - Field: ‘workers’
[13:21:41.638]   - Field: ‘packages’
[13:21:41.638]   - Field: ‘gc’
[13:21:41.638]   - Field: ‘job’
[13:21:41.638]   - Field: ‘conditions’
[13:21:41.638]   - Field: ‘expr’
[13:21:41.638]   - Field: ‘uuid’
[13:21:41.639]   - Field: ‘seed’
[13:21:41.639]   - Field: ‘version’
[13:21:41.639]   - Field: ‘result’
[13:21:41.639]   - Field: ‘asynchronous’
[13:21:41.639]   - Field: ‘calls’
[13:21:41.639]   - Field: ‘globals’
[13:21:41.639]   - Field: ‘stdout’
[13:21:41.640]   - Field: ‘earlySignal’
[13:21:41.640]   - Field: ‘lazy’
[13:21:41.640]   - Field: ‘state’
[13:21:41.640] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:41.640] - Launch lazy future ...
[13:21:41.640] Packages needed by the future expression (n = 0): <none>
[13:21:41.641] Packages needed by future strategies (n = 0): <none>
[13:21:41.641] {
[13:21:41.641]     {
[13:21:41.641]         {
[13:21:41.641]             ...future.startTime <- base::Sys.time()
[13:21:41.641]             {
[13:21:41.641]                 {
[13:21:41.641]                   {
[13:21:41.641]                     {
[13:21:41.641]                       base::local({
[13:21:41.641]                         has_future <- base::requireNamespace("future", 
[13:21:41.641]                           quietly = TRUE)
[13:21:41.641]                         if (has_future) {
[13:21:41.641]                           ns <- base::getNamespace("future")
[13:21:41.641]                           version <- ns[[".package"]][["version"]]
[13:21:41.641]                           if (is.null(version)) 
[13:21:41.641]                             version <- utils::packageVersion("future")
[13:21:41.641]                         }
[13:21:41.641]                         else {
[13:21:41.641]                           version <- NULL
[13:21:41.641]                         }
[13:21:41.641]                         if (!has_future || version < "1.8.0") {
[13:21:41.641]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:41.641]                             "", base::R.version$version.string), 
[13:21:41.641]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:41.641]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:41.641]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:41.641]                               "release", "version")], collapse = " "), 
[13:21:41.641]                             hostname = base::Sys.info()[["nodename"]])
[13:21:41.641]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:41.641]                             info)
[13:21:41.641]                           info <- base::paste(info, collapse = "; ")
[13:21:41.641]                           if (!has_future) {
[13:21:41.641]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:41.641]                               info)
[13:21:41.641]                           }
[13:21:41.641]                           else {
[13:21:41.641]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:41.641]                               info, version)
[13:21:41.641]                           }
[13:21:41.641]                           base::stop(msg)
[13:21:41.641]                         }
[13:21:41.641]                       })
[13:21:41.641]                     }
[13:21:41.641]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:41.641]                     base::options(mc.cores = 1L)
[13:21:41.641]                   }
[13:21:41.641]                   options(future.plan = NULL)
[13:21:41.641]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.641]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:41.641]                 }
[13:21:41.641]                 ...future.workdir <- getwd()
[13:21:41.641]             }
[13:21:41.641]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:41.641]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:41.641]         }
[13:21:41.641]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:41.641]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:41.641]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:41.641]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:41.641]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:41.641]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:41.641]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:41.641]             base::names(...future.oldOptions))
[13:21:41.641]     }
[13:21:41.641]     if (FALSE) {
[13:21:41.641]     }
[13:21:41.641]     else {
[13:21:41.641]         if (TRUE) {
[13:21:41.641]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:41.641]                 open = "w")
[13:21:41.641]         }
[13:21:41.641]         else {
[13:21:41.641]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:41.641]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:41.641]         }
[13:21:41.641]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:41.641]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:41.641]             base::sink(type = "output", split = FALSE)
[13:21:41.641]             base::close(...future.stdout)
[13:21:41.641]         }, add = TRUE)
[13:21:41.641]     }
[13:21:41.641]     ...future.frame <- base::sys.nframe()
[13:21:41.641]     ...future.conditions <- base::list()
[13:21:41.641]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:41.641]     if (FALSE) {
[13:21:41.641]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:41.641]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:41.641]     }
[13:21:41.641]     ...future.result <- base::tryCatch({
[13:21:41.641]         base::withCallingHandlers({
[13:21:41.641]             ...future.value <- base::withVisible(base::local({
[13:21:41.641]                 withCallingHandlers({
[13:21:41.641]                   {
[13:21:41.641]                     1
[13:21:41.641]                   }
[13:21:41.641]                 }, immediateCondition = function(cond) {
[13:21:41.641]                   save_rds <- function (object, pathname, ...) 
[13:21:41.641]                   {
[13:21:41.641]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:41.641]                     if (file_test("-f", pathname_tmp)) {
[13:21:41.641]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.641]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:41.641]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.641]                         fi_tmp[["mtime"]])
[13:21:41.641]                     }
[13:21:41.641]                     tryCatch({
[13:21:41.641]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:41.641]                     }, error = function(ex) {
[13:21:41.641]                       msg <- conditionMessage(ex)
[13:21:41.641]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.641]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:41.641]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.641]                         fi_tmp[["mtime"]], msg)
[13:21:41.641]                       ex$message <- msg
[13:21:41.641]                       stop(ex)
[13:21:41.641]                     })
[13:21:41.641]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:41.641]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:41.641]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:41.641]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.641]                       fi <- file.info(pathname)
[13:21:41.641]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:41.641]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.641]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:41.641]                         fi[["size"]], fi[["mtime"]])
[13:21:41.641]                       stop(msg)
[13:21:41.641]                     }
[13:21:41.641]                     invisible(pathname)
[13:21:41.641]                   }
[13:21:41.641]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:41.641]                     rootPath = tempdir()) 
[13:21:41.641]                   {
[13:21:41.641]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:41.641]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:41.641]                       tmpdir = path, fileext = ".rds")
[13:21:41.641]                     save_rds(obj, file)
[13:21:41.641]                   }
[13:21:41.641]                   saveImmediateCondition(cond, path = "/tmp/RtmpRIPAyw/.future/immediateConditions")
[13:21:41.641]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.641]                   {
[13:21:41.641]                     inherits <- base::inherits
[13:21:41.641]                     invokeRestart <- base::invokeRestart
[13:21:41.641]                     is.null <- base::is.null
[13:21:41.641]                     muffled <- FALSE
[13:21:41.641]                     if (inherits(cond, "message")) {
[13:21:41.641]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:41.641]                       if (muffled) 
[13:21:41.641]                         invokeRestart("muffleMessage")
[13:21:41.641]                     }
[13:21:41.641]                     else if (inherits(cond, "warning")) {
[13:21:41.641]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:41.641]                       if (muffled) 
[13:21:41.641]                         invokeRestart("muffleWarning")
[13:21:41.641]                     }
[13:21:41.641]                     else if (inherits(cond, "condition")) {
[13:21:41.641]                       if (!is.null(pattern)) {
[13:21:41.641]                         computeRestarts <- base::computeRestarts
[13:21:41.641]                         grepl <- base::grepl
[13:21:41.641]                         restarts <- computeRestarts(cond)
[13:21:41.641]                         for (restart in restarts) {
[13:21:41.641]                           name <- restart$name
[13:21:41.641]                           if (is.null(name)) 
[13:21:41.641]                             next
[13:21:41.641]                           if (!grepl(pattern, name)) 
[13:21:41.641]                             next
[13:21:41.641]                           invokeRestart(restart)
[13:21:41.641]                           muffled <- TRUE
[13:21:41.641]                           break
[13:21:41.641]                         }
[13:21:41.641]                       }
[13:21:41.641]                     }
[13:21:41.641]                     invisible(muffled)
[13:21:41.641]                   }
[13:21:41.641]                   muffleCondition(cond)
[13:21:41.641]                 })
[13:21:41.641]             }))
[13:21:41.641]             future::FutureResult(value = ...future.value$value, 
[13:21:41.641]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.641]                   ...future.rng), globalenv = if (FALSE) 
[13:21:41.641]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:41.641]                     ...future.globalenv.names))
[13:21:41.641]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:41.641]         }, condition = base::local({
[13:21:41.641]             c <- base::c
[13:21:41.641]             inherits <- base::inherits
[13:21:41.641]             invokeRestart <- base::invokeRestart
[13:21:41.641]             length <- base::length
[13:21:41.641]             list <- base::list
[13:21:41.641]             seq.int <- base::seq.int
[13:21:41.641]             signalCondition <- base::signalCondition
[13:21:41.641]             sys.calls <- base::sys.calls
[13:21:41.641]             `[[` <- base::`[[`
[13:21:41.641]             `+` <- base::`+`
[13:21:41.641]             `<<-` <- base::`<<-`
[13:21:41.641]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:41.641]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:41.641]                   3L)]
[13:21:41.641]             }
[13:21:41.641]             function(cond) {
[13:21:41.641]                 is_error <- inherits(cond, "error")
[13:21:41.641]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:41.641]                   NULL)
[13:21:41.641]                 if (is_error) {
[13:21:41.641]                   sessionInformation <- function() {
[13:21:41.641]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:41.641]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:41.641]                       search = base::search(), system = base::Sys.info())
[13:21:41.641]                   }
[13:21:41.641]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.641]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:41.641]                     cond$call), session = sessionInformation(), 
[13:21:41.641]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:41.641]                   signalCondition(cond)
[13:21:41.641]                 }
[13:21:41.641]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:41.641]                 "immediateCondition"))) {
[13:21:41.641]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:41.641]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.641]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:41.641]                   if (TRUE && !signal) {
[13:21:41.641]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.641]                     {
[13:21:41.641]                       inherits <- base::inherits
[13:21:41.641]                       invokeRestart <- base::invokeRestart
[13:21:41.641]                       is.null <- base::is.null
[13:21:41.641]                       muffled <- FALSE
[13:21:41.641]                       if (inherits(cond, "message")) {
[13:21:41.641]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.641]                         if (muffled) 
[13:21:41.641]                           invokeRestart("muffleMessage")
[13:21:41.641]                       }
[13:21:41.641]                       else if (inherits(cond, "warning")) {
[13:21:41.641]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.641]                         if (muffled) 
[13:21:41.641]                           invokeRestart("muffleWarning")
[13:21:41.641]                       }
[13:21:41.641]                       else if (inherits(cond, "condition")) {
[13:21:41.641]                         if (!is.null(pattern)) {
[13:21:41.641]                           computeRestarts <- base::computeRestarts
[13:21:41.641]                           grepl <- base::grepl
[13:21:41.641]                           restarts <- computeRestarts(cond)
[13:21:41.641]                           for (restart in restarts) {
[13:21:41.641]                             name <- restart$name
[13:21:41.641]                             if (is.null(name)) 
[13:21:41.641]                               next
[13:21:41.641]                             if (!grepl(pattern, name)) 
[13:21:41.641]                               next
[13:21:41.641]                             invokeRestart(restart)
[13:21:41.641]                             muffled <- TRUE
[13:21:41.641]                             break
[13:21:41.641]                           }
[13:21:41.641]                         }
[13:21:41.641]                       }
[13:21:41.641]                       invisible(muffled)
[13:21:41.641]                     }
[13:21:41.641]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.641]                   }
[13:21:41.641]                 }
[13:21:41.641]                 else {
[13:21:41.641]                   if (TRUE) {
[13:21:41.641]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.641]                     {
[13:21:41.641]                       inherits <- base::inherits
[13:21:41.641]                       invokeRestart <- base::invokeRestart
[13:21:41.641]                       is.null <- base::is.null
[13:21:41.641]                       muffled <- FALSE
[13:21:41.641]                       if (inherits(cond, "message")) {
[13:21:41.641]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.641]                         if (muffled) 
[13:21:41.641]                           invokeRestart("muffleMessage")
[13:21:41.641]                       }
[13:21:41.641]                       else if (inherits(cond, "warning")) {
[13:21:41.641]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.641]                         if (muffled) 
[13:21:41.641]                           invokeRestart("muffleWarning")
[13:21:41.641]                       }
[13:21:41.641]                       else if (inherits(cond, "condition")) {
[13:21:41.641]                         if (!is.null(pattern)) {
[13:21:41.641]                           computeRestarts <- base::computeRestarts
[13:21:41.641]                           grepl <- base::grepl
[13:21:41.641]                           restarts <- computeRestarts(cond)
[13:21:41.641]                           for (restart in restarts) {
[13:21:41.641]                             name <- restart$name
[13:21:41.641]                             if (is.null(name)) 
[13:21:41.641]                               next
[13:21:41.641]                             if (!grepl(pattern, name)) 
[13:21:41.641]                               next
[13:21:41.641]                             invokeRestart(restart)
[13:21:41.641]                             muffled <- TRUE
[13:21:41.641]                             break
[13:21:41.641]                           }
[13:21:41.641]                         }
[13:21:41.641]                       }
[13:21:41.641]                       invisible(muffled)
[13:21:41.641]                     }
[13:21:41.641]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.641]                   }
[13:21:41.641]                 }
[13:21:41.641]             }
[13:21:41.641]         }))
[13:21:41.641]     }, error = function(ex) {
[13:21:41.641]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:41.641]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.641]                 ...future.rng), started = ...future.startTime, 
[13:21:41.641]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:41.641]             version = "1.8"), class = "FutureResult")
[13:21:41.641]     }, finally = {
[13:21:41.641]         if (!identical(...future.workdir, getwd())) 
[13:21:41.641]             setwd(...future.workdir)
[13:21:41.641]         {
[13:21:41.641]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:41.641]                 ...future.oldOptions$nwarnings <- NULL
[13:21:41.641]             }
[13:21:41.641]             base::options(...future.oldOptions)
[13:21:41.641]             if (.Platform$OS.type == "windows") {
[13:21:41.641]                 old_names <- names(...future.oldEnvVars)
[13:21:41.641]                 envs <- base::Sys.getenv()
[13:21:41.641]                 names <- names(envs)
[13:21:41.641]                 common <- intersect(names, old_names)
[13:21:41.641]                 added <- setdiff(names, old_names)
[13:21:41.641]                 removed <- setdiff(old_names, names)
[13:21:41.641]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:41.641]                   envs[common]]
[13:21:41.641]                 NAMES <- toupper(changed)
[13:21:41.641]                 args <- list()
[13:21:41.641]                 for (kk in seq_along(NAMES)) {
[13:21:41.641]                   name <- changed[[kk]]
[13:21:41.641]                   NAME <- NAMES[[kk]]
[13:21:41.641]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.641]                     next
[13:21:41.641]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.641]                 }
[13:21:41.641]                 NAMES <- toupper(added)
[13:21:41.641]                 for (kk in seq_along(NAMES)) {
[13:21:41.641]                   name <- added[[kk]]
[13:21:41.641]                   NAME <- NAMES[[kk]]
[13:21:41.641]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.641]                     next
[13:21:41.641]                   args[[name]] <- ""
[13:21:41.641]                 }
[13:21:41.641]                 NAMES <- toupper(removed)
[13:21:41.641]                 for (kk in seq_along(NAMES)) {
[13:21:41.641]                   name <- removed[[kk]]
[13:21:41.641]                   NAME <- NAMES[[kk]]
[13:21:41.641]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.641]                     next
[13:21:41.641]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.641]                 }
[13:21:41.641]                 if (length(args) > 0) 
[13:21:41.641]                   base::do.call(base::Sys.setenv, args = args)
[13:21:41.641]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:41.641]             }
[13:21:41.641]             else {
[13:21:41.641]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:41.641]             }
[13:21:41.641]             {
[13:21:41.641]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:41.641]                   0L) {
[13:21:41.641]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:41.641]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:41.641]                   base::options(opts)
[13:21:41.641]                 }
[13:21:41.641]                 {
[13:21:41.641]                   {
[13:21:41.641]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:41.641]                     NULL
[13:21:41.641]                   }
[13:21:41.641]                   options(future.plan = NULL)
[13:21:41.641]                   if (is.na(NA_character_)) 
[13:21:41.641]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.641]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:41.641]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:41.641]                     envir = parent.frame()) 
[13:21:41.641]                   {
[13:21:41.641]                     default_workers <- missing(workers)
[13:21:41.641]                     if (is.function(workers)) 
[13:21:41.641]                       workers <- workers()
[13:21:41.641]                     workers <- structure(as.integer(workers), 
[13:21:41.641]                       class = class(workers))
[13:21:41.641]                     stop_if_not(is.finite(workers), workers >= 
[13:21:41.641]                       1L)
[13:21:41.641]                     if ((workers == 1L && !inherits(workers, 
[13:21:41.641]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:41.641]                       if (default_workers) 
[13:21:41.641]                         supportsMulticore(warn = TRUE)
[13:21:41.641]                       return(sequential(..., envir = envir))
[13:21:41.641]                     }
[13:21:41.641]                     oopts <- options(mc.cores = workers)
[13:21:41.641]                     on.exit(options(oopts))
[13:21:41.641]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:41.641]                       envir = envir)
[13:21:41.641]                     if (!future$lazy) 
[13:21:41.641]                       future <- run(future)
[13:21:41.641]                     invisible(future)
[13:21:41.641]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:41.641]                 }
[13:21:41.641]             }
[13:21:41.641]         }
[13:21:41.641]     })
[13:21:41.641]     if (TRUE) {
[13:21:41.641]         base::sink(type = "output", split = FALSE)
[13:21:41.641]         if (TRUE) {
[13:21:41.641]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:41.641]         }
[13:21:41.641]         else {
[13:21:41.641]             ...future.result["stdout"] <- base::list(NULL)
[13:21:41.641]         }
[13:21:41.641]         base::close(...future.stdout)
[13:21:41.641]         ...future.stdout <- NULL
[13:21:41.641]     }
[13:21:41.641]     ...future.result$conditions <- ...future.conditions
[13:21:41.641]     ...future.result$finished <- base::Sys.time()
[13:21:41.641]     ...future.result
[13:21:41.641] }
[13:21:41.644] requestCore(): workers = 2
[13:21:41.644] Poll #1 (0): usedCores() = 2, workers = 2
[13:21:41.658] MulticoreFuture started
[13:21:41.658] - Launch lazy future ... done
[13:21:41.659] run() for ‘MulticoreFuture’ ... done
[13:21:41.659] plan(): Setting new future strategy stack:
[13:21:41.660] getGlobalsAndPackages() ...
[13:21:41.660] Searching for globals...
[13:21:41.660] List of future strategies:
[13:21:41.660] 1. sequential:
[13:21:41.660]    - args: function (..., envir = parent.frame())
[13:21:41.660]    - tweaked: FALSE
[13:21:41.660]    - call: NULL
[13:21:41.661] plan(): nbrOfWorkers() = 1
[13:21:41.662] - globals found: [1] ‘{’
[13:21:41.663] Searching for globals ... DONE
[13:21:41.663] Resolving globals: FALSE
[13:21:41.664] 
[13:21:41.664] plan(): Setting new future strategy stack:
[13:21:41.664] 
[13:21:41.664] getGlobalsAndPackages() ... DONE
[13:21:41.664] List of future strategies:
[13:21:41.664] 1. multicore:
[13:21:41.664]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:41.664]    - tweaked: FALSE
[13:21:41.664]    - call: plan(strategy)
[13:21:41.665] run() for ‘Future’ ...
[13:21:41.665] - state: ‘created’
[13:21:41.665] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:41.670] plan(): nbrOfWorkers() = 2
[13:21:41.671] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:41.671] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:41.671]   - Field: ‘label’
[13:21:41.672]   - Field: ‘local’
[13:21:41.672]   - Field: ‘owner’
[13:21:41.672]   - Field: ‘envir’
[13:21:41.672]   - Field: ‘workers’
[13:21:41.672]   - Field: ‘packages’
[13:21:41.672]   - Field: ‘gc’
[13:21:41.673]   - Field: ‘job’
[13:21:41.673]   - Field: ‘conditions’
[13:21:41.673]   - Field: ‘expr’
[13:21:41.673]   - Field: ‘uuid’
[13:21:41.673]   - Field: ‘seed’
[13:21:41.673]   - Field: ‘version’
[13:21:41.673]   - Field: ‘result’
[13:21:41.674]   - Field: ‘asynchronous’
[13:21:41.674]   - Field: ‘calls’
[13:21:41.674]   - Field: ‘globals’
[13:21:41.674]   - Field: ‘stdout’
[13:21:41.674]   - Field: ‘earlySignal’
[13:21:41.674]   - Field: ‘lazy’
[13:21:41.674]   - Field: ‘state’
[13:21:41.675] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:41.675] - Launch lazy future ...
[13:21:41.675] Packages needed by the future expression (n = 0): <none>
[13:21:41.675] Packages needed by future strategies (n = 0): <none>
[13:21:41.676] {
[13:21:41.676]     {
[13:21:41.676]         {
[13:21:41.676]             ...future.startTime <- base::Sys.time()
[13:21:41.676]             {
[13:21:41.676]                 {
[13:21:41.676]                   {
[13:21:41.676]                     {
[13:21:41.676]                       base::local({
[13:21:41.676]                         has_future <- base::requireNamespace("future", 
[13:21:41.676]                           quietly = TRUE)
[13:21:41.676]                         if (has_future) {
[13:21:41.676]                           ns <- base::getNamespace("future")
[13:21:41.676]                           version <- ns[[".package"]][["version"]]
[13:21:41.676]                           if (is.null(version)) 
[13:21:41.676]                             version <- utils::packageVersion("future")
[13:21:41.676]                         }
[13:21:41.676]                         else {
[13:21:41.676]                           version <- NULL
[13:21:41.676]                         }
[13:21:41.676]                         if (!has_future || version < "1.8.0") {
[13:21:41.676]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:41.676]                             "", base::R.version$version.string), 
[13:21:41.676]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:41.676]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:41.676]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:41.676]                               "release", "version")], collapse = " "), 
[13:21:41.676]                             hostname = base::Sys.info()[["nodename"]])
[13:21:41.676]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:41.676]                             info)
[13:21:41.676]                           info <- base::paste(info, collapse = "; ")
[13:21:41.676]                           if (!has_future) {
[13:21:41.676]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:41.676]                               info)
[13:21:41.676]                           }
[13:21:41.676]                           else {
[13:21:41.676]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:41.676]                               info, version)
[13:21:41.676]                           }
[13:21:41.676]                           base::stop(msg)
[13:21:41.676]                         }
[13:21:41.676]                       })
[13:21:41.676]                     }
[13:21:41.676]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:41.676]                     base::options(mc.cores = 1L)
[13:21:41.676]                   }
[13:21:41.676]                   options(future.plan = NULL)
[13:21:41.676]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.676]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:41.676]                 }
[13:21:41.676]                 ...future.workdir <- getwd()
[13:21:41.676]             }
[13:21:41.676]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:41.676]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:41.676]         }
[13:21:41.676]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:41.676]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:41.676]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:41.676]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:41.676]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:41.676]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:41.676]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:41.676]             base::names(...future.oldOptions))
[13:21:41.676]     }
[13:21:41.676]     if (FALSE) {
[13:21:41.676]     }
[13:21:41.676]     else {
[13:21:41.676]         if (TRUE) {
[13:21:41.676]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:41.676]                 open = "w")
[13:21:41.676]         }
[13:21:41.676]         else {
[13:21:41.676]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:41.676]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:41.676]         }
[13:21:41.676]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:41.676]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:41.676]             base::sink(type = "output", split = FALSE)
[13:21:41.676]             base::close(...future.stdout)
[13:21:41.676]         }, add = TRUE)
[13:21:41.676]     }
[13:21:41.676]     ...future.frame <- base::sys.nframe()
[13:21:41.676]     ...future.conditions <- base::list()
[13:21:41.676]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:41.676]     if (FALSE) {
[13:21:41.676]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:41.676]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:41.676]     }
[13:21:41.676]     ...future.result <- base::tryCatch({
[13:21:41.676]         base::withCallingHandlers({
[13:21:41.676]             ...future.value <- base::withVisible(base::local({
[13:21:41.676]                 withCallingHandlers({
[13:21:41.676]                   {
[13:21:41.676]                     2
[13:21:41.676]                   }
[13:21:41.676]                 }, immediateCondition = function(cond) {
[13:21:41.676]                   save_rds <- function (object, pathname, ...) 
[13:21:41.676]                   {
[13:21:41.676]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:41.676]                     if (file_test("-f", pathname_tmp)) {
[13:21:41.676]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.676]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:41.676]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.676]                         fi_tmp[["mtime"]])
[13:21:41.676]                     }
[13:21:41.676]                     tryCatch({
[13:21:41.676]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:41.676]                     }, error = function(ex) {
[13:21:41.676]                       msg <- conditionMessage(ex)
[13:21:41.676]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.676]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:41.676]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.676]                         fi_tmp[["mtime"]], msg)
[13:21:41.676]                       ex$message <- msg
[13:21:41.676]                       stop(ex)
[13:21:41.676]                     })
[13:21:41.676]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:41.676]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:41.676]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:41.676]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.676]                       fi <- file.info(pathname)
[13:21:41.676]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:41.676]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.676]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:41.676]                         fi[["size"]], fi[["mtime"]])
[13:21:41.676]                       stop(msg)
[13:21:41.676]                     }
[13:21:41.676]                     invisible(pathname)
[13:21:41.676]                   }
[13:21:41.676]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:41.676]                     rootPath = tempdir()) 
[13:21:41.676]                   {
[13:21:41.676]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:41.676]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:41.676]                       tmpdir = path, fileext = ".rds")
[13:21:41.676]                     save_rds(obj, file)
[13:21:41.676]                   }
[13:21:41.676]                   saveImmediateCondition(cond, path = "/tmp/RtmpRIPAyw/.future/immediateConditions")
[13:21:41.676]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.676]                   {
[13:21:41.676]                     inherits <- base::inherits
[13:21:41.676]                     invokeRestart <- base::invokeRestart
[13:21:41.676]                     is.null <- base::is.null
[13:21:41.676]                     muffled <- FALSE
[13:21:41.676]                     if (inherits(cond, "message")) {
[13:21:41.676]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:41.676]                       if (muffled) 
[13:21:41.676]                         invokeRestart("muffleMessage")
[13:21:41.676]                     }
[13:21:41.676]                     else if (inherits(cond, "warning")) {
[13:21:41.676]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:41.676]                       if (muffled) 
[13:21:41.676]                         invokeRestart("muffleWarning")
[13:21:41.676]                     }
[13:21:41.676]                     else if (inherits(cond, "condition")) {
[13:21:41.676]                       if (!is.null(pattern)) {
[13:21:41.676]                         computeRestarts <- base::computeRestarts
[13:21:41.676]                         grepl <- base::grepl
[13:21:41.676]                         restarts <- computeRestarts(cond)
[13:21:41.676]                         for (restart in restarts) {
[13:21:41.676]                           name <- restart$name
[13:21:41.676]                           if (is.null(name)) 
[13:21:41.676]                             next
[13:21:41.676]                           if (!grepl(pattern, name)) 
[13:21:41.676]                             next
[13:21:41.676]                           invokeRestart(restart)
[13:21:41.676]                           muffled <- TRUE
[13:21:41.676]                           break
[13:21:41.676]                         }
[13:21:41.676]                       }
[13:21:41.676]                     }
[13:21:41.676]                     invisible(muffled)
[13:21:41.676]                   }
[13:21:41.676]                   muffleCondition(cond)
[13:21:41.676]                 })
[13:21:41.676]             }))
[13:21:41.676]             future::FutureResult(value = ...future.value$value, 
[13:21:41.676]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.676]                   ...future.rng), globalenv = if (FALSE) 
[13:21:41.676]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:41.676]                     ...future.globalenv.names))
[13:21:41.676]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:41.676]         }, condition = base::local({
[13:21:41.676]             c <- base::c
[13:21:41.676]             inherits <- base::inherits
[13:21:41.676]             invokeRestart <- base::invokeRestart
[13:21:41.676]             length <- base::length
[13:21:41.676]             list <- base::list
[13:21:41.676]             seq.int <- base::seq.int
[13:21:41.676]             signalCondition <- base::signalCondition
[13:21:41.676]             sys.calls <- base::sys.calls
[13:21:41.676]             `[[` <- base::`[[`
[13:21:41.676]             `+` <- base::`+`
[13:21:41.676]             `<<-` <- base::`<<-`
[13:21:41.676]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:41.676]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:41.676]                   3L)]
[13:21:41.676]             }
[13:21:41.676]             function(cond) {
[13:21:41.676]                 is_error <- inherits(cond, "error")
[13:21:41.676]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:41.676]                   NULL)
[13:21:41.676]                 if (is_error) {
[13:21:41.676]                   sessionInformation <- function() {
[13:21:41.676]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:41.676]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:41.676]                       search = base::search(), system = base::Sys.info())
[13:21:41.676]                   }
[13:21:41.676]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.676]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:41.676]                     cond$call), session = sessionInformation(), 
[13:21:41.676]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:41.676]                   signalCondition(cond)
[13:21:41.676]                 }
[13:21:41.676]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:41.676]                 "immediateCondition"))) {
[13:21:41.676]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:41.676]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.676]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:41.676]                   if (TRUE && !signal) {
[13:21:41.676]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.676]                     {
[13:21:41.676]                       inherits <- base::inherits
[13:21:41.676]                       invokeRestart <- base::invokeRestart
[13:21:41.676]                       is.null <- base::is.null
[13:21:41.676]                       muffled <- FALSE
[13:21:41.676]                       if (inherits(cond, "message")) {
[13:21:41.676]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.676]                         if (muffled) 
[13:21:41.676]                           invokeRestart("muffleMessage")
[13:21:41.676]                       }
[13:21:41.676]                       else if (inherits(cond, "warning")) {
[13:21:41.676]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.676]                         if (muffled) 
[13:21:41.676]                           invokeRestart("muffleWarning")
[13:21:41.676]                       }
[13:21:41.676]                       else if (inherits(cond, "condition")) {
[13:21:41.676]                         if (!is.null(pattern)) {
[13:21:41.676]                           computeRestarts <- base::computeRestarts
[13:21:41.676]                           grepl <- base::grepl
[13:21:41.676]                           restarts <- computeRestarts(cond)
[13:21:41.676]                           for (restart in restarts) {
[13:21:41.676]                             name <- restart$name
[13:21:41.676]                             if (is.null(name)) 
[13:21:41.676]                               next
[13:21:41.676]                             if (!grepl(pattern, name)) 
[13:21:41.676]                               next
[13:21:41.676]                             invokeRestart(restart)
[13:21:41.676]                             muffled <- TRUE
[13:21:41.676]                             break
[13:21:41.676]                           }
[13:21:41.676]                         }
[13:21:41.676]                       }
[13:21:41.676]                       invisible(muffled)
[13:21:41.676]                     }
[13:21:41.676]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.676]                   }
[13:21:41.676]                 }
[13:21:41.676]                 else {
[13:21:41.676]                   if (TRUE) {
[13:21:41.676]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.676]                     {
[13:21:41.676]                       inherits <- base::inherits
[13:21:41.676]                       invokeRestart <- base::invokeRestart
[13:21:41.676]                       is.null <- base::is.null
[13:21:41.676]                       muffled <- FALSE
[13:21:41.676]                       if (inherits(cond, "message")) {
[13:21:41.676]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.676]                         if (muffled) 
[13:21:41.676]                           invokeRestart("muffleMessage")
[13:21:41.676]                       }
[13:21:41.676]                       else if (inherits(cond, "warning")) {
[13:21:41.676]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.676]                         if (muffled) 
[13:21:41.676]                           invokeRestart("muffleWarning")
[13:21:41.676]                       }
[13:21:41.676]                       else if (inherits(cond, "condition")) {
[13:21:41.676]                         if (!is.null(pattern)) {
[13:21:41.676]                           computeRestarts <- base::computeRestarts
[13:21:41.676]                           grepl <- base::grepl
[13:21:41.676]                           restarts <- computeRestarts(cond)
[13:21:41.676]                           for (restart in restarts) {
[13:21:41.676]                             name <- restart$name
[13:21:41.676]                             if (is.null(name)) 
[13:21:41.676]                               next
[13:21:41.676]                             if (!grepl(pattern, name)) 
[13:21:41.676]                               next
[13:21:41.676]                             invokeRestart(restart)
[13:21:41.676]                             muffled <- TRUE
[13:21:41.676]                             break
[13:21:41.676]                           }
[13:21:41.676]                         }
[13:21:41.676]                       }
[13:21:41.676]                       invisible(muffled)
[13:21:41.676]                     }
[13:21:41.676]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.676]                   }
[13:21:41.676]                 }
[13:21:41.676]             }
[13:21:41.676]         }))
[13:21:41.676]     }, error = function(ex) {
[13:21:41.676]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:41.676]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.676]                 ...future.rng), started = ...future.startTime, 
[13:21:41.676]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:41.676]             version = "1.8"), class = "FutureResult")
[13:21:41.676]     }, finally = {
[13:21:41.676]         if (!identical(...future.workdir, getwd())) 
[13:21:41.676]             setwd(...future.workdir)
[13:21:41.676]         {
[13:21:41.676]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:41.676]                 ...future.oldOptions$nwarnings <- NULL
[13:21:41.676]             }
[13:21:41.676]             base::options(...future.oldOptions)
[13:21:41.676]             if (.Platform$OS.type == "windows") {
[13:21:41.676]                 old_names <- names(...future.oldEnvVars)
[13:21:41.676]                 envs <- base::Sys.getenv()
[13:21:41.676]                 names <- names(envs)
[13:21:41.676]                 common <- intersect(names, old_names)
[13:21:41.676]                 added <- setdiff(names, old_names)
[13:21:41.676]                 removed <- setdiff(old_names, names)
[13:21:41.676]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:41.676]                   envs[common]]
[13:21:41.676]                 NAMES <- toupper(changed)
[13:21:41.676]                 args <- list()
[13:21:41.676]                 for (kk in seq_along(NAMES)) {
[13:21:41.676]                   name <- changed[[kk]]
[13:21:41.676]                   NAME <- NAMES[[kk]]
[13:21:41.676]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.676]                     next
[13:21:41.676]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.676]                 }
[13:21:41.676]                 NAMES <- toupper(added)
[13:21:41.676]                 for (kk in seq_along(NAMES)) {
[13:21:41.676]                   name <- added[[kk]]
[13:21:41.676]                   NAME <- NAMES[[kk]]
[13:21:41.676]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.676]                     next
[13:21:41.676]                   args[[name]] <- ""
[13:21:41.676]                 }
[13:21:41.676]                 NAMES <- toupper(removed)
[13:21:41.676]                 for (kk in seq_along(NAMES)) {
[13:21:41.676]                   name <- removed[[kk]]
[13:21:41.676]                   NAME <- NAMES[[kk]]
[13:21:41.676]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.676]                     next
[13:21:41.676]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.676]                 }
[13:21:41.676]                 if (length(args) > 0) 
[13:21:41.676]                   base::do.call(base::Sys.setenv, args = args)
[13:21:41.676]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:41.676]             }
[13:21:41.676]             else {
[13:21:41.676]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:41.676]             }
[13:21:41.676]             {
[13:21:41.676]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:41.676]                   0L) {
[13:21:41.676]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:41.676]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:41.676]                   base::options(opts)
[13:21:41.676]                 }
[13:21:41.676]                 {
[13:21:41.676]                   {
[13:21:41.676]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:41.676]                     NULL
[13:21:41.676]                   }
[13:21:41.676]                   options(future.plan = NULL)
[13:21:41.676]                   if (is.na(NA_character_)) 
[13:21:41.676]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.676]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:41.676]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:41.676]                     envir = parent.frame()) 
[13:21:41.676]                   {
[13:21:41.676]                     default_workers <- missing(workers)
[13:21:41.676]                     if (is.function(workers)) 
[13:21:41.676]                       workers <- workers()
[13:21:41.676]                     workers <- structure(as.integer(workers), 
[13:21:41.676]                       class = class(workers))
[13:21:41.676]                     stop_if_not(is.finite(workers), workers >= 
[13:21:41.676]                       1L)
[13:21:41.676]                     if ((workers == 1L && !inherits(workers, 
[13:21:41.676]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:41.676]                       if (default_workers) 
[13:21:41.676]                         supportsMulticore(warn = TRUE)
[13:21:41.676]                       return(sequential(..., envir = envir))
[13:21:41.676]                     }
[13:21:41.676]                     oopts <- options(mc.cores = workers)
[13:21:41.676]                     on.exit(options(oopts))
[13:21:41.676]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:41.676]                       envir = envir)
[13:21:41.676]                     if (!future$lazy) 
[13:21:41.676]                       future <- run(future)
[13:21:41.676]                     invisible(future)
[13:21:41.676]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:41.676]                 }
[13:21:41.676]             }
[13:21:41.676]         }
[13:21:41.676]     })
[13:21:41.676]     if (TRUE) {
[13:21:41.676]         base::sink(type = "output", split = FALSE)
[13:21:41.676]         if (TRUE) {
[13:21:41.676]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:41.676]         }
[13:21:41.676]         else {
[13:21:41.676]             ...future.result["stdout"] <- base::list(NULL)
[13:21:41.676]         }
[13:21:41.676]         base::close(...future.stdout)
[13:21:41.676]         ...future.stdout <- NULL
[13:21:41.676]     }
[13:21:41.676]     ...future.result$conditions <- ...future.conditions
[13:21:41.676]     ...future.result$finished <- base::Sys.time()
[13:21:41.676]     ...future.result
[13:21:41.676] }
[13:21:41.680] requestCore(): workers = 2
[13:21:41.680] Poll #1 (0): usedCores() = 2, workers = 2
[13:21:41.694] MulticoreFuture started
[13:21:41.694] - Launch lazy future ... done
[13:21:41.695] run() for ‘MulticoreFuture’ ... done
[13:21:41.695] plan(): Setting new future strategy stack:
[13:21:41.695] List of future strategies:
[13:21:41.695] 1. sequential:
[13:21:41.695]    - args: function (..., envir = parent.frame())
[13:21:41.695]    - tweaked: FALSE
[13:21:41.695]    - call: NULL
[13:21:41.697] resolve() on environment ...
[13:21:41.697] plan(): nbrOfWorkers() = 1
[13:21:41.697]  recursive: 0
[13:21:41.698]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[13:21:41.699] Future #1
[13:21:41.699]  length: 2 (resolved future 1)
[13:21:41.700] plan(): Setting new future strategy stack:
[13:21:41.700] List of future strategies:
[13:21:41.700] 1. multicore:
[13:21:41.700]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:41.700]    - tweaked: FALSE
[13:21:41.700]    - call: plan(strategy)
[13:21:41.705] plan(): nbrOfWorkers() = 2
[13:21:41.705] Future #2
[13:21:41.706]  length: 1 (resolved future 2)
[13:21:41.706]  length: 0 (resolved future 3)
[13:21:41.706] resolve() on environment ... DONE
[13:21:41.707] getGlobalsAndPackages() ...
[13:21:41.707] Searching for globals...
[13:21:41.708] - globals found: [1] ‘{’
[13:21:41.708] Searching for globals ... DONE
[13:21:41.708] Resolving globals: FALSE
[13:21:41.713] 
[13:21:41.713] 
[13:21:41.714] getGlobalsAndPackages() ... DONE
[13:21:41.714] run() for ‘Future’ ...
[13:21:41.715] - state: ‘created’
[13:21:41.715] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:41.721] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:41.721] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:41.721]   - Field: ‘label’
[13:21:41.722]   - Field: ‘local’
[13:21:41.722]   - Field: ‘owner’
[13:21:41.722]   - Field: ‘envir’
[13:21:41.722]   - Field: ‘workers’
[13:21:41.722]   - Field: ‘packages’
[13:21:41.722]   - Field: ‘gc’
[13:21:41.723]   - Field: ‘job’
[13:21:41.723]   - Field: ‘conditions’
[13:21:41.723]   - Field: ‘expr’
[13:21:41.723]   - Field: ‘uuid’
[13:21:41.723]   - Field: ‘seed’
[13:21:41.723]   - Field: ‘version’
[13:21:41.723]   - Field: ‘result’
[13:21:41.724]   - Field: ‘asynchronous’
[13:21:41.724]   - Field: ‘calls’
[13:21:41.724]   - Field: ‘globals’
[13:21:41.724]   - Field: ‘stdout’
[13:21:41.724]   - Field: ‘earlySignal’
[13:21:41.724]   - Field: ‘lazy’
[13:21:41.725]   - Field: ‘state’
[13:21:41.725] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:41.725] - Launch lazy future ...
[13:21:41.726] Packages needed by the future expression (n = 0): <none>
[13:21:41.726] Packages needed by future strategies (n = 0): <none>
[13:21:41.727] {
[13:21:41.727]     {
[13:21:41.727]         {
[13:21:41.727]             ...future.startTime <- base::Sys.time()
[13:21:41.727]             {
[13:21:41.727]                 {
[13:21:41.727]                   {
[13:21:41.727]                     {
[13:21:41.727]                       base::local({
[13:21:41.727]                         has_future <- base::requireNamespace("future", 
[13:21:41.727]                           quietly = TRUE)
[13:21:41.727]                         if (has_future) {
[13:21:41.727]                           ns <- base::getNamespace("future")
[13:21:41.727]                           version <- ns[[".package"]][["version"]]
[13:21:41.727]                           if (is.null(version)) 
[13:21:41.727]                             version <- utils::packageVersion("future")
[13:21:41.727]                         }
[13:21:41.727]                         else {
[13:21:41.727]                           version <- NULL
[13:21:41.727]                         }
[13:21:41.727]                         if (!has_future || version < "1.8.0") {
[13:21:41.727]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:41.727]                             "", base::R.version$version.string), 
[13:21:41.727]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:41.727]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:41.727]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:41.727]                               "release", "version")], collapse = " "), 
[13:21:41.727]                             hostname = base::Sys.info()[["nodename"]])
[13:21:41.727]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:41.727]                             info)
[13:21:41.727]                           info <- base::paste(info, collapse = "; ")
[13:21:41.727]                           if (!has_future) {
[13:21:41.727]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:41.727]                               info)
[13:21:41.727]                           }
[13:21:41.727]                           else {
[13:21:41.727]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:41.727]                               info, version)
[13:21:41.727]                           }
[13:21:41.727]                           base::stop(msg)
[13:21:41.727]                         }
[13:21:41.727]                       })
[13:21:41.727]                     }
[13:21:41.727]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:41.727]                     base::options(mc.cores = 1L)
[13:21:41.727]                   }
[13:21:41.727]                   options(future.plan = NULL)
[13:21:41.727]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.727]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:41.727]                 }
[13:21:41.727]                 ...future.workdir <- getwd()
[13:21:41.727]             }
[13:21:41.727]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:41.727]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:41.727]         }
[13:21:41.727]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:41.727]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:41.727]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:41.727]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:41.727]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:41.727]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:41.727]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:41.727]             base::names(...future.oldOptions))
[13:21:41.727]     }
[13:21:41.727]     if (FALSE) {
[13:21:41.727]     }
[13:21:41.727]     else {
[13:21:41.727]         if (TRUE) {
[13:21:41.727]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:41.727]                 open = "w")
[13:21:41.727]         }
[13:21:41.727]         else {
[13:21:41.727]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:41.727]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:41.727]         }
[13:21:41.727]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:41.727]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:41.727]             base::sink(type = "output", split = FALSE)
[13:21:41.727]             base::close(...future.stdout)
[13:21:41.727]         }, add = TRUE)
[13:21:41.727]     }
[13:21:41.727]     ...future.frame <- base::sys.nframe()
[13:21:41.727]     ...future.conditions <- base::list()
[13:21:41.727]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:41.727]     if (FALSE) {
[13:21:41.727]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:41.727]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:41.727]     }
[13:21:41.727]     ...future.result <- base::tryCatch({
[13:21:41.727]         base::withCallingHandlers({
[13:21:41.727]             ...future.value <- base::withVisible(base::local({
[13:21:41.727]                 withCallingHandlers({
[13:21:41.727]                   {
[13:21:41.727]                     1
[13:21:41.727]                   }
[13:21:41.727]                 }, immediateCondition = function(cond) {
[13:21:41.727]                   save_rds <- function (object, pathname, ...) 
[13:21:41.727]                   {
[13:21:41.727]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:41.727]                     if (file_test("-f", pathname_tmp)) {
[13:21:41.727]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.727]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:41.727]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.727]                         fi_tmp[["mtime"]])
[13:21:41.727]                     }
[13:21:41.727]                     tryCatch({
[13:21:41.727]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:41.727]                     }, error = function(ex) {
[13:21:41.727]                       msg <- conditionMessage(ex)
[13:21:41.727]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.727]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:41.727]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.727]                         fi_tmp[["mtime"]], msg)
[13:21:41.727]                       ex$message <- msg
[13:21:41.727]                       stop(ex)
[13:21:41.727]                     })
[13:21:41.727]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:41.727]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:41.727]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:41.727]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.727]                       fi <- file.info(pathname)
[13:21:41.727]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:41.727]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.727]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:41.727]                         fi[["size"]], fi[["mtime"]])
[13:21:41.727]                       stop(msg)
[13:21:41.727]                     }
[13:21:41.727]                     invisible(pathname)
[13:21:41.727]                   }
[13:21:41.727]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:41.727]                     rootPath = tempdir()) 
[13:21:41.727]                   {
[13:21:41.727]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:41.727]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:41.727]                       tmpdir = path, fileext = ".rds")
[13:21:41.727]                     save_rds(obj, file)
[13:21:41.727]                   }
[13:21:41.727]                   saveImmediateCondition(cond, path = "/tmp/RtmpRIPAyw/.future/immediateConditions")
[13:21:41.727]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.727]                   {
[13:21:41.727]                     inherits <- base::inherits
[13:21:41.727]                     invokeRestart <- base::invokeRestart
[13:21:41.727]                     is.null <- base::is.null
[13:21:41.727]                     muffled <- FALSE
[13:21:41.727]                     if (inherits(cond, "message")) {
[13:21:41.727]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:41.727]                       if (muffled) 
[13:21:41.727]                         invokeRestart("muffleMessage")
[13:21:41.727]                     }
[13:21:41.727]                     else if (inherits(cond, "warning")) {
[13:21:41.727]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:41.727]                       if (muffled) 
[13:21:41.727]                         invokeRestart("muffleWarning")
[13:21:41.727]                     }
[13:21:41.727]                     else if (inherits(cond, "condition")) {
[13:21:41.727]                       if (!is.null(pattern)) {
[13:21:41.727]                         computeRestarts <- base::computeRestarts
[13:21:41.727]                         grepl <- base::grepl
[13:21:41.727]                         restarts <- computeRestarts(cond)
[13:21:41.727]                         for (restart in restarts) {
[13:21:41.727]                           name <- restart$name
[13:21:41.727]                           if (is.null(name)) 
[13:21:41.727]                             next
[13:21:41.727]                           if (!grepl(pattern, name)) 
[13:21:41.727]                             next
[13:21:41.727]                           invokeRestart(restart)
[13:21:41.727]                           muffled <- TRUE
[13:21:41.727]                           break
[13:21:41.727]                         }
[13:21:41.727]                       }
[13:21:41.727]                     }
[13:21:41.727]                     invisible(muffled)
[13:21:41.727]                   }
[13:21:41.727]                   muffleCondition(cond)
[13:21:41.727]                 })
[13:21:41.727]             }))
[13:21:41.727]             future::FutureResult(value = ...future.value$value, 
[13:21:41.727]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.727]                   ...future.rng), globalenv = if (FALSE) 
[13:21:41.727]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:41.727]                     ...future.globalenv.names))
[13:21:41.727]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:41.727]         }, condition = base::local({
[13:21:41.727]             c <- base::c
[13:21:41.727]             inherits <- base::inherits
[13:21:41.727]             invokeRestart <- base::invokeRestart
[13:21:41.727]             length <- base::length
[13:21:41.727]             list <- base::list
[13:21:41.727]             seq.int <- base::seq.int
[13:21:41.727]             signalCondition <- base::signalCondition
[13:21:41.727]             sys.calls <- base::sys.calls
[13:21:41.727]             `[[` <- base::`[[`
[13:21:41.727]             `+` <- base::`+`
[13:21:41.727]             `<<-` <- base::`<<-`
[13:21:41.727]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:41.727]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:41.727]                   3L)]
[13:21:41.727]             }
[13:21:41.727]             function(cond) {
[13:21:41.727]                 is_error <- inherits(cond, "error")
[13:21:41.727]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:41.727]                   NULL)
[13:21:41.727]                 if (is_error) {
[13:21:41.727]                   sessionInformation <- function() {
[13:21:41.727]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:41.727]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:41.727]                       search = base::search(), system = base::Sys.info())
[13:21:41.727]                   }
[13:21:41.727]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.727]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:41.727]                     cond$call), session = sessionInformation(), 
[13:21:41.727]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:41.727]                   signalCondition(cond)
[13:21:41.727]                 }
[13:21:41.727]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:41.727]                 "immediateCondition"))) {
[13:21:41.727]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:41.727]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.727]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:41.727]                   if (TRUE && !signal) {
[13:21:41.727]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.727]                     {
[13:21:41.727]                       inherits <- base::inherits
[13:21:41.727]                       invokeRestart <- base::invokeRestart
[13:21:41.727]                       is.null <- base::is.null
[13:21:41.727]                       muffled <- FALSE
[13:21:41.727]                       if (inherits(cond, "message")) {
[13:21:41.727]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.727]                         if (muffled) 
[13:21:41.727]                           invokeRestart("muffleMessage")
[13:21:41.727]                       }
[13:21:41.727]                       else if (inherits(cond, "warning")) {
[13:21:41.727]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.727]                         if (muffled) 
[13:21:41.727]                           invokeRestart("muffleWarning")
[13:21:41.727]                       }
[13:21:41.727]                       else if (inherits(cond, "condition")) {
[13:21:41.727]                         if (!is.null(pattern)) {
[13:21:41.727]                           computeRestarts <- base::computeRestarts
[13:21:41.727]                           grepl <- base::grepl
[13:21:41.727]                           restarts <- computeRestarts(cond)
[13:21:41.727]                           for (restart in restarts) {
[13:21:41.727]                             name <- restart$name
[13:21:41.727]                             if (is.null(name)) 
[13:21:41.727]                               next
[13:21:41.727]                             if (!grepl(pattern, name)) 
[13:21:41.727]                               next
[13:21:41.727]                             invokeRestart(restart)
[13:21:41.727]                             muffled <- TRUE
[13:21:41.727]                             break
[13:21:41.727]                           }
[13:21:41.727]                         }
[13:21:41.727]                       }
[13:21:41.727]                       invisible(muffled)
[13:21:41.727]                     }
[13:21:41.727]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.727]                   }
[13:21:41.727]                 }
[13:21:41.727]                 else {
[13:21:41.727]                   if (TRUE) {
[13:21:41.727]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.727]                     {
[13:21:41.727]                       inherits <- base::inherits
[13:21:41.727]                       invokeRestart <- base::invokeRestart
[13:21:41.727]                       is.null <- base::is.null
[13:21:41.727]                       muffled <- FALSE
[13:21:41.727]                       if (inherits(cond, "message")) {
[13:21:41.727]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.727]                         if (muffled) 
[13:21:41.727]                           invokeRestart("muffleMessage")
[13:21:41.727]                       }
[13:21:41.727]                       else if (inherits(cond, "warning")) {
[13:21:41.727]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.727]                         if (muffled) 
[13:21:41.727]                           invokeRestart("muffleWarning")
[13:21:41.727]                       }
[13:21:41.727]                       else if (inherits(cond, "condition")) {
[13:21:41.727]                         if (!is.null(pattern)) {
[13:21:41.727]                           computeRestarts <- base::computeRestarts
[13:21:41.727]                           grepl <- base::grepl
[13:21:41.727]                           restarts <- computeRestarts(cond)
[13:21:41.727]                           for (restart in restarts) {
[13:21:41.727]                             name <- restart$name
[13:21:41.727]                             if (is.null(name)) 
[13:21:41.727]                               next
[13:21:41.727]                             if (!grepl(pattern, name)) 
[13:21:41.727]                               next
[13:21:41.727]                             invokeRestart(restart)
[13:21:41.727]                             muffled <- TRUE
[13:21:41.727]                             break
[13:21:41.727]                           }
[13:21:41.727]                         }
[13:21:41.727]                       }
[13:21:41.727]                       invisible(muffled)
[13:21:41.727]                     }
[13:21:41.727]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.727]                   }
[13:21:41.727]                 }
[13:21:41.727]             }
[13:21:41.727]         }))
[13:21:41.727]     }, error = function(ex) {
[13:21:41.727]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:41.727]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.727]                 ...future.rng), started = ...future.startTime, 
[13:21:41.727]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:41.727]             version = "1.8"), class = "FutureResult")
[13:21:41.727]     }, finally = {
[13:21:41.727]         if (!identical(...future.workdir, getwd())) 
[13:21:41.727]             setwd(...future.workdir)
[13:21:41.727]         {
[13:21:41.727]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:41.727]                 ...future.oldOptions$nwarnings <- NULL
[13:21:41.727]             }
[13:21:41.727]             base::options(...future.oldOptions)
[13:21:41.727]             if (.Platform$OS.type == "windows") {
[13:21:41.727]                 old_names <- names(...future.oldEnvVars)
[13:21:41.727]                 envs <- base::Sys.getenv()
[13:21:41.727]                 names <- names(envs)
[13:21:41.727]                 common <- intersect(names, old_names)
[13:21:41.727]                 added <- setdiff(names, old_names)
[13:21:41.727]                 removed <- setdiff(old_names, names)
[13:21:41.727]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:41.727]                   envs[common]]
[13:21:41.727]                 NAMES <- toupper(changed)
[13:21:41.727]                 args <- list()
[13:21:41.727]                 for (kk in seq_along(NAMES)) {
[13:21:41.727]                   name <- changed[[kk]]
[13:21:41.727]                   NAME <- NAMES[[kk]]
[13:21:41.727]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.727]                     next
[13:21:41.727]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.727]                 }
[13:21:41.727]                 NAMES <- toupper(added)
[13:21:41.727]                 for (kk in seq_along(NAMES)) {
[13:21:41.727]                   name <- added[[kk]]
[13:21:41.727]                   NAME <- NAMES[[kk]]
[13:21:41.727]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.727]                     next
[13:21:41.727]                   args[[name]] <- ""
[13:21:41.727]                 }
[13:21:41.727]                 NAMES <- toupper(removed)
[13:21:41.727]                 for (kk in seq_along(NAMES)) {
[13:21:41.727]                   name <- removed[[kk]]
[13:21:41.727]                   NAME <- NAMES[[kk]]
[13:21:41.727]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.727]                     next
[13:21:41.727]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.727]                 }
[13:21:41.727]                 if (length(args) > 0) 
[13:21:41.727]                   base::do.call(base::Sys.setenv, args = args)
[13:21:41.727]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:41.727]             }
[13:21:41.727]             else {
[13:21:41.727]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:41.727]             }
[13:21:41.727]             {
[13:21:41.727]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:41.727]                   0L) {
[13:21:41.727]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:41.727]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:41.727]                   base::options(opts)
[13:21:41.727]                 }
[13:21:41.727]                 {
[13:21:41.727]                   {
[13:21:41.727]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:41.727]                     NULL
[13:21:41.727]                   }
[13:21:41.727]                   options(future.plan = NULL)
[13:21:41.727]                   if (is.na(NA_character_)) 
[13:21:41.727]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.727]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:41.727]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:41.727]                     envir = parent.frame()) 
[13:21:41.727]                   {
[13:21:41.727]                     default_workers <- missing(workers)
[13:21:41.727]                     if (is.function(workers)) 
[13:21:41.727]                       workers <- workers()
[13:21:41.727]                     workers <- structure(as.integer(workers), 
[13:21:41.727]                       class = class(workers))
[13:21:41.727]                     stop_if_not(is.finite(workers), workers >= 
[13:21:41.727]                       1L)
[13:21:41.727]                     if ((workers == 1L && !inherits(workers, 
[13:21:41.727]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:41.727]                       if (default_workers) 
[13:21:41.727]                         supportsMulticore(warn = TRUE)
[13:21:41.727]                       return(sequential(..., envir = envir))
[13:21:41.727]                     }
[13:21:41.727]                     oopts <- options(mc.cores = workers)
[13:21:41.727]                     on.exit(options(oopts))
[13:21:41.727]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:41.727]                       envir = envir)
[13:21:41.727]                     if (!future$lazy) 
[13:21:41.727]                       future <- run(future)
[13:21:41.727]                     invisible(future)
[13:21:41.727]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:41.727]                 }
[13:21:41.727]             }
[13:21:41.727]         }
[13:21:41.727]     })
[13:21:41.727]     if (TRUE) {
[13:21:41.727]         base::sink(type = "output", split = FALSE)
[13:21:41.727]         if (TRUE) {
[13:21:41.727]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:41.727]         }
[13:21:41.727]         else {
[13:21:41.727]             ...future.result["stdout"] <- base::list(NULL)
[13:21:41.727]         }
[13:21:41.727]         base::close(...future.stdout)
[13:21:41.727]         ...future.stdout <- NULL
[13:21:41.727]     }
[13:21:41.727]     ...future.result$conditions <- ...future.conditions
[13:21:41.727]     ...future.result$finished <- base::Sys.time()
[13:21:41.727]     ...future.result
[13:21:41.727] }
[13:21:41.730] requestCore(): workers = 2
[13:21:41.730] Poll #1 (0): usedCores() = 2, workers = 2
[13:21:41.744] MulticoreFuture started
[13:21:41.744] - Launch lazy future ... done
[13:21:41.745] run() for ‘MulticoreFuture’ ... done
[13:21:41.745] plan(): Setting new future strategy stack:
[13:21:41.746] getGlobalsAndPackages() ...
[13:21:41.746] Searching for globals...
[13:21:41.746] List of future strategies:
[13:21:41.746] 1. sequential:
[13:21:41.746]    - args: function (..., envir = parent.frame())
[13:21:41.746]    - tweaked: FALSE
[13:21:41.746]    - call: NULL
[13:21:41.747] plan(): nbrOfWorkers() = 1
[13:21:41.748] - globals found: [1] ‘{’
[13:21:41.749] Searching for globals ... DONE
[13:21:41.749] Resolving globals: FALSE
[13:21:41.750] plan(): Setting new future strategy stack:
[13:21:41.750] 
[13:21:41.750] 
[13:21:41.750] getGlobalsAndPackages() ... DONE
[13:21:41.750] List of future strategies:
[13:21:41.750] 1. multicore:
[13:21:41.750]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:41.750]    - tweaked: FALSE
[13:21:41.750]    - call: plan(strategy)
[13:21:41.751] run() for ‘Future’ ...
[13:21:41.751] - state: ‘created’
[13:21:41.752] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:41.756] plan(): nbrOfWorkers() = 2
[13:21:41.756] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:41.757] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:41.757]   - Field: ‘label’
[13:21:41.757]   - Field: ‘local’
[13:21:41.757]   - Field: ‘owner’
[13:21:41.757]   - Field: ‘envir’
[13:21:41.758]   - Field: ‘workers’
[13:21:41.758]   - Field: ‘packages’
[13:21:41.758]   - Field: ‘gc’
[13:21:41.758]   - Field: ‘job’
[13:21:41.758]   - Field: ‘conditions’
[13:21:41.758]   - Field: ‘expr’
[13:21:41.759]   - Field: ‘uuid’
[13:21:41.759]   - Field: ‘seed’
[13:21:41.759]   - Field: ‘version’
[13:21:41.759]   - Field: ‘result’
[13:21:41.759]   - Field: ‘asynchronous’
[13:21:41.759]   - Field: ‘calls’
[13:21:41.760]   - Field: ‘globals’
[13:21:41.760]   - Field: ‘stdout’
[13:21:41.760]   - Field: ‘earlySignal’
[13:21:41.760]   - Field: ‘lazy’
[13:21:41.760]   - Field: ‘state’
[13:21:41.760] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:41.760] - Launch lazy future ...
[13:21:41.761] Packages needed by the future expression (n = 0): <none>
[13:21:41.761] Packages needed by future strategies (n = 0): <none>
[13:21:41.762] {
[13:21:41.762]     {
[13:21:41.762]         {
[13:21:41.762]             ...future.startTime <- base::Sys.time()
[13:21:41.762]             {
[13:21:41.762]                 {
[13:21:41.762]                   {
[13:21:41.762]                     {
[13:21:41.762]                       base::local({
[13:21:41.762]                         has_future <- base::requireNamespace("future", 
[13:21:41.762]                           quietly = TRUE)
[13:21:41.762]                         if (has_future) {
[13:21:41.762]                           ns <- base::getNamespace("future")
[13:21:41.762]                           version <- ns[[".package"]][["version"]]
[13:21:41.762]                           if (is.null(version)) 
[13:21:41.762]                             version <- utils::packageVersion("future")
[13:21:41.762]                         }
[13:21:41.762]                         else {
[13:21:41.762]                           version <- NULL
[13:21:41.762]                         }
[13:21:41.762]                         if (!has_future || version < "1.8.0") {
[13:21:41.762]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:41.762]                             "", base::R.version$version.string), 
[13:21:41.762]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:41.762]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:41.762]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:41.762]                               "release", "version")], collapse = " "), 
[13:21:41.762]                             hostname = base::Sys.info()[["nodename"]])
[13:21:41.762]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:41.762]                             info)
[13:21:41.762]                           info <- base::paste(info, collapse = "; ")
[13:21:41.762]                           if (!has_future) {
[13:21:41.762]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:41.762]                               info)
[13:21:41.762]                           }
[13:21:41.762]                           else {
[13:21:41.762]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:41.762]                               info, version)
[13:21:41.762]                           }
[13:21:41.762]                           base::stop(msg)
[13:21:41.762]                         }
[13:21:41.762]                       })
[13:21:41.762]                     }
[13:21:41.762]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:41.762]                     base::options(mc.cores = 1L)
[13:21:41.762]                   }
[13:21:41.762]                   options(future.plan = NULL)
[13:21:41.762]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.762]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:41.762]                 }
[13:21:41.762]                 ...future.workdir <- getwd()
[13:21:41.762]             }
[13:21:41.762]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:41.762]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:41.762]         }
[13:21:41.762]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:41.762]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:41.762]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:41.762]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:41.762]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:41.762]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:41.762]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:41.762]             base::names(...future.oldOptions))
[13:21:41.762]     }
[13:21:41.762]     if (FALSE) {
[13:21:41.762]     }
[13:21:41.762]     else {
[13:21:41.762]         if (TRUE) {
[13:21:41.762]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:41.762]                 open = "w")
[13:21:41.762]         }
[13:21:41.762]         else {
[13:21:41.762]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:41.762]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:41.762]         }
[13:21:41.762]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:41.762]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:41.762]             base::sink(type = "output", split = FALSE)
[13:21:41.762]             base::close(...future.stdout)
[13:21:41.762]         }, add = TRUE)
[13:21:41.762]     }
[13:21:41.762]     ...future.frame <- base::sys.nframe()
[13:21:41.762]     ...future.conditions <- base::list()
[13:21:41.762]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:41.762]     if (FALSE) {
[13:21:41.762]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:41.762]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:41.762]     }
[13:21:41.762]     ...future.result <- base::tryCatch({
[13:21:41.762]         base::withCallingHandlers({
[13:21:41.762]             ...future.value <- base::withVisible(base::local({
[13:21:41.762]                 withCallingHandlers({
[13:21:41.762]                   {
[13:21:41.762]                     2
[13:21:41.762]                   }
[13:21:41.762]                 }, immediateCondition = function(cond) {
[13:21:41.762]                   save_rds <- function (object, pathname, ...) 
[13:21:41.762]                   {
[13:21:41.762]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:41.762]                     if (file_test("-f", pathname_tmp)) {
[13:21:41.762]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.762]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:41.762]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.762]                         fi_tmp[["mtime"]])
[13:21:41.762]                     }
[13:21:41.762]                     tryCatch({
[13:21:41.762]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:41.762]                     }, error = function(ex) {
[13:21:41.762]                       msg <- conditionMessage(ex)
[13:21:41.762]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.762]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:41.762]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.762]                         fi_tmp[["mtime"]], msg)
[13:21:41.762]                       ex$message <- msg
[13:21:41.762]                       stop(ex)
[13:21:41.762]                     })
[13:21:41.762]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:41.762]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:41.762]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:41.762]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.762]                       fi <- file.info(pathname)
[13:21:41.762]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:41.762]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.762]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:41.762]                         fi[["size"]], fi[["mtime"]])
[13:21:41.762]                       stop(msg)
[13:21:41.762]                     }
[13:21:41.762]                     invisible(pathname)
[13:21:41.762]                   }
[13:21:41.762]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:41.762]                     rootPath = tempdir()) 
[13:21:41.762]                   {
[13:21:41.762]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:41.762]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:41.762]                       tmpdir = path, fileext = ".rds")
[13:21:41.762]                     save_rds(obj, file)
[13:21:41.762]                   }
[13:21:41.762]                   saveImmediateCondition(cond, path = "/tmp/RtmpRIPAyw/.future/immediateConditions")
[13:21:41.762]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.762]                   {
[13:21:41.762]                     inherits <- base::inherits
[13:21:41.762]                     invokeRestart <- base::invokeRestart
[13:21:41.762]                     is.null <- base::is.null
[13:21:41.762]                     muffled <- FALSE
[13:21:41.762]                     if (inherits(cond, "message")) {
[13:21:41.762]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:41.762]                       if (muffled) 
[13:21:41.762]                         invokeRestart("muffleMessage")
[13:21:41.762]                     }
[13:21:41.762]                     else if (inherits(cond, "warning")) {
[13:21:41.762]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:41.762]                       if (muffled) 
[13:21:41.762]                         invokeRestart("muffleWarning")
[13:21:41.762]                     }
[13:21:41.762]                     else if (inherits(cond, "condition")) {
[13:21:41.762]                       if (!is.null(pattern)) {
[13:21:41.762]                         computeRestarts <- base::computeRestarts
[13:21:41.762]                         grepl <- base::grepl
[13:21:41.762]                         restarts <- computeRestarts(cond)
[13:21:41.762]                         for (restart in restarts) {
[13:21:41.762]                           name <- restart$name
[13:21:41.762]                           if (is.null(name)) 
[13:21:41.762]                             next
[13:21:41.762]                           if (!grepl(pattern, name)) 
[13:21:41.762]                             next
[13:21:41.762]                           invokeRestart(restart)
[13:21:41.762]                           muffled <- TRUE
[13:21:41.762]                           break
[13:21:41.762]                         }
[13:21:41.762]                       }
[13:21:41.762]                     }
[13:21:41.762]                     invisible(muffled)
[13:21:41.762]                   }
[13:21:41.762]                   muffleCondition(cond)
[13:21:41.762]                 })
[13:21:41.762]             }))
[13:21:41.762]             future::FutureResult(value = ...future.value$value, 
[13:21:41.762]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.762]                   ...future.rng), globalenv = if (FALSE) 
[13:21:41.762]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:41.762]                     ...future.globalenv.names))
[13:21:41.762]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:41.762]         }, condition = base::local({
[13:21:41.762]             c <- base::c
[13:21:41.762]             inherits <- base::inherits
[13:21:41.762]             invokeRestart <- base::invokeRestart
[13:21:41.762]             length <- base::length
[13:21:41.762]             list <- base::list
[13:21:41.762]             seq.int <- base::seq.int
[13:21:41.762]             signalCondition <- base::signalCondition
[13:21:41.762]             sys.calls <- base::sys.calls
[13:21:41.762]             `[[` <- base::`[[`
[13:21:41.762]             `+` <- base::`+`
[13:21:41.762]             `<<-` <- base::`<<-`
[13:21:41.762]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:41.762]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:41.762]                   3L)]
[13:21:41.762]             }
[13:21:41.762]             function(cond) {
[13:21:41.762]                 is_error <- inherits(cond, "error")
[13:21:41.762]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:41.762]                   NULL)
[13:21:41.762]                 if (is_error) {
[13:21:41.762]                   sessionInformation <- function() {
[13:21:41.762]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:41.762]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:41.762]                       search = base::search(), system = base::Sys.info())
[13:21:41.762]                   }
[13:21:41.762]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.762]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:41.762]                     cond$call), session = sessionInformation(), 
[13:21:41.762]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:41.762]                   signalCondition(cond)
[13:21:41.762]                 }
[13:21:41.762]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:41.762]                 "immediateCondition"))) {
[13:21:41.762]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:41.762]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.762]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:41.762]                   if (TRUE && !signal) {
[13:21:41.762]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.762]                     {
[13:21:41.762]                       inherits <- base::inherits
[13:21:41.762]                       invokeRestart <- base::invokeRestart
[13:21:41.762]                       is.null <- base::is.null
[13:21:41.762]                       muffled <- FALSE
[13:21:41.762]                       if (inherits(cond, "message")) {
[13:21:41.762]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.762]                         if (muffled) 
[13:21:41.762]                           invokeRestart("muffleMessage")
[13:21:41.762]                       }
[13:21:41.762]                       else if (inherits(cond, "warning")) {
[13:21:41.762]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.762]                         if (muffled) 
[13:21:41.762]                           invokeRestart("muffleWarning")
[13:21:41.762]                       }
[13:21:41.762]                       else if (inherits(cond, "condition")) {
[13:21:41.762]                         if (!is.null(pattern)) {
[13:21:41.762]                           computeRestarts <- base::computeRestarts
[13:21:41.762]                           grepl <- base::grepl
[13:21:41.762]                           restarts <- computeRestarts(cond)
[13:21:41.762]                           for (restart in restarts) {
[13:21:41.762]                             name <- restart$name
[13:21:41.762]                             if (is.null(name)) 
[13:21:41.762]                               next
[13:21:41.762]                             if (!grepl(pattern, name)) 
[13:21:41.762]                               next
[13:21:41.762]                             invokeRestart(restart)
[13:21:41.762]                             muffled <- TRUE
[13:21:41.762]                             break
[13:21:41.762]                           }
[13:21:41.762]                         }
[13:21:41.762]                       }
[13:21:41.762]                       invisible(muffled)
[13:21:41.762]                     }
[13:21:41.762]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.762]                   }
[13:21:41.762]                 }
[13:21:41.762]                 else {
[13:21:41.762]                   if (TRUE) {
[13:21:41.762]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.762]                     {
[13:21:41.762]                       inherits <- base::inherits
[13:21:41.762]                       invokeRestart <- base::invokeRestart
[13:21:41.762]                       is.null <- base::is.null
[13:21:41.762]                       muffled <- FALSE
[13:21:41.762]                       if (inherits(cond, "message")) {
[13:21:41.762]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.762]                         if (muffled) 
[13:21:41.762]                           invokeRestart("muffleMessage")
[13:21:41.762]                       }
[13:21:41.762]                       else if (inherits(cond, "warning")) {
[13:21:41.762]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.762]                         if (muffled) 
[13:21:41.762]                           invokeRestart("muffleWarning")
[13:21:41.762]                       }
[13:21:41.762]                       else if (inherits(cond, "condition")) {
[13:21:41.762]                         if (!is.null(pattern)) {
[13:21:41.762]                           computeRestarts <- base::computeRestarts
[13:21:41.762]                           grepl <- base::grepl
[13:21:41.762]                           restarts <- computeRestarts(cond)
[13:21:41.762]                           for (restart in restarts) {
[13:21:41.762]                             name <- restart$name
[13:21:41.762]                             if (is.null(name)) 
[13:21:41.762]                               next
[13:21:41.762]                             if (!grepl(pattern, name)) 
[13:21:41.762]                               next
[13:21:41.762]                             invokeRestart(restart)
[13:21:41.762]                             muffled <- TRUE
[13:21:41.762]                             break
[13:21:41.762]                           }
[13:21:41.762]                         }
[13:21:41.762]                       }
[13:21:41.762]                       invisible(muffled)
[13:21:41.762]                     }
[13:21:41.762]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.762]                   }
[13:21:41.762]                 }
[13:21:41.762]             }
[13:21:41.762]         }))
[13:21:41.762]     }, error = function(ex) {
[13:21:41.762]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:41.762]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.762]                 ...future.rng), started = ...future.startTime, 
[13:21:41.762]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:41.762]             version = "1.8"), class = "FutureResult")
[13:21:41.762]     }, finally = {
[13:21:41.762]         if (!identical(...future.workdir, getwd())) 
[13:21:41.762]             setwd(...future.workdir)
[13:21:41.762]         {
[13:21:41.762]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:41.762]                 ...future.oldOptions$nwarnings <- NULL
[13:21:41.762]             }
[13:21:41.762]             base::options(...future.oldOptions)
[13:21:41.762]             if (.Platform$OS.type == "windows") {
[13:21:41.762]                 old_names <- names(...future.oldEnvVars)
[13:21:41.762]                 envs <- base::Sys.getenv()
[13:21:41.762]                 names <- names(envs)
[13:21:41.762]                 common <- intersect(names, old_names)
[13:21:41.762]                 added <- setdiff(names, old_names)
[13:21:41.762]                 removed <- setdiff(old_names, names)
[13:21:41.762]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:41.762]                   envs[common]]
[13:21:41.762]                 NAMES <- toupper(changed)
[13:21:41.762]                 args <- list()
[13:21:41.762]                 for (kk in seq_along(NAMES)) {
[13:21:41.762]                   name <- changed[[kk]]
[13:21:41.762]                   NAME <- NAMES[[kk]]
[13:21:41.762]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.762]                     next
[13:21:41.762]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.762]                 }
[13:21:41.762]                 NAMES <- toupper(added)
[13:21:41.762]                 for (kk in seq_along(NAMES)) {
[13:21:41.762]                   name <- added[[kk]]
[13:21:41.762]                   NAME <- NAMES[[kk]]
[13:21:41.762]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.762]                     next
[13:21:41.762]                   args[[name]] <- ""
[13:21:41.762]                 }
[13:21:41.762]                 NAMES <- toupper(removed)
[13:21:41.762]                 for (kk in seq_along(NAMES)) {
[13:21:41.762]                   name <- removed[[kk]]
[13:21:41.762]                   NAME <- NAMES[[kk]]
[13:21:41.762]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.762]                     next
[13:21:41.762]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.762]                 }
[13:21:41.762]                 if (length(args) > 0) 
[13:21:41.762]                   base::do.call(base::Sys.setenv, args = args)
[13:21:41.762]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:41.762]             }
[13:21:41.762]             else {
[13:21:41.762]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:41.762]             }
[13:21:41.762]             {
[13:21:41.762]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:41.762]                   0L) {
[13:21:41.762]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:41.762]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:41.762]                   base::options(opts)
[13:21:41.762]                 }
[13:21:41.762]                 {
[13:21:41.762]                   {
[13:21:41.762]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:41.762]                     NULL
[13:21:41.762]                   }
[13:21:41.762]                   options(future.plan = NULL)
[13:21:41.762]                   if (is.na(NA_character_)) 
[13:21:41.762]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.762]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:41.762]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:41.762]                     envir = parent.frame()) 
[13:21:41.762]                   {
[13:21:41.762]                     default_workers <- missing(workers)
[13:21:41.762]                     if (is.function(workers)) 
[13:21:41.762]                       workers <- workers()
[13:21:41.762]                     workers <- structure(as.integer(workers), 
[13:21:41.762]                       class = class(workers))
[13:21:41.762]                     stop_if_not(is.finite(workers), workers >= 
[13:21:41.762]                       1L)
[13:21:41.762]                     if ((workers == 1L && !inherits(workers, 
[13:21:41.762]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:41.762]                       if (default_workers) 
[13:21:41.762]                         supportsMulticore(warn = TRUE)
[13:21:41.762]                       return(sequential(..., envir = envir))
[13:21:41.762]                     }
[13:21:41.762]                     oopts <- options(mc.cores = workers)
[13:21:41.762]                     on.exit(options(oopts))
[13:21:41.762]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:41.762]                       envir = envir)
[13:21:41.762]                     if (!future$lazy) 
[13:21:41.762]                       future <- run(future)
[13:21:41.762]                     invisible(future)
[13:21:41.762]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:41.762]                 }
[13:21:41.762]             }
[13:21:41.762]         }
[13:21:41.762]     })
[13:21:41.762]     if (TRUE) {
[13:21:41.762]         base::sink(type = "output", split = FALSE)
[13:21:41.762]         if (TRUE) {
[13:21:41.762]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:41.762]         }
[13:21:41.762]         else {
[13:21:41.762]             ...future.result["stdout"] <- base::list(NULL)
[13:21:41.762]         }
[13:21:41.762]         base::close(...future.stdout)
[13:21:41.762]         ...future.stdout <- NULL
[13:21:41.762]     }
[13:21:41.762]     ...future.result$conditions <- ...future.conditions
[13:21:41.762]     ...future.result$finished <- base::Sys.time()
[13:21:41.762]     ...future.result
[13:21:41.762] }
[13:21:41.766] requestCore(): workers = 2
[13:21:41.766] Poll #1 (0): usedCores() = 2, workers = 2
[13:21:41.780] MulticoreFuture started
[13:21:41.781] - Launch lazy future ... done
[13:21:41.781] run() for ‘MulticoreFuture’ ... done
[13:21:41.781] plan(): Setting new future strategy stack:
[13:21:41.782] List of future strategies:
[13:21:41.782] 1. sequential:
[13:21:41.782]    - args: function (..., envir = parent.frame())
[13:21:41.782]    - tweaked: FALSE
[13:21:41.782]    - call: NULL
[13:21:41.783] resolve() on environment ...
[13:21:41.783] plan(): nbrOfWorkers() = 1
[13:21:41.783]  recursive: 0
[13:21:41.784]  elements: [3] ‘a’
[13:21:41.785] Future #1
[13:21:41.785]  length: 2 (resolved future 1)
[13:21:41.786] plan(): Setting new future strategy stack:
[13:21:41.786] List of future strategies:
[13:21:41.786] 1. multicore:
[13:21:41.786]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:41.786]    - tweaked: FALSE
[13:21:41.786]    - call: plan(strategy)
[13:21:41.791] plan(): nbrOfWorkers() = 2
[13:21:41.792] Future #2
[13:21:41.792]  length: 1 (resolved future 2)
[13:21:41.792]  length: 0 (resolved future 3)
[13:21:41.792] resolve() on environment ... DONE
[13:21:41.793] resolve() on environment ...
[13:21:41.793]  recursive: 0
[13:21:41.794]  elements: [3] ‘b’
[13:21:41.794] Future #1
[13:21:41.794]  length: 2 (resolved future 1)
[13:21:41.795] Future #2
[13:21:41.795]  length: 1 (resolved future 2)
[13:21:41.795]  length: 0 (resolved future 3)
[13:21:41.795] resolve() on environment ... DONE
[13:21:41.796] resolve() on environment ...
[13:21:41.796]  recursive: 0
[13:21:41.797]  elements: [3] ‘c’
[13:21:41.797] Future #1
[13:21:41.798]  length: 2 (resolved future 1)
[13:21:41.798] Future #2
[13:21:41.798]  length: 1 (resolved future 2)
[13:21:41.798]  length: 0 (resolved future 3)
[13:21:41.798] resolve() on environment ... DONE
[13:21:41.799] resolve() on environment ...
[13:21:41.799]  recursive: 0
[13:21:41.800]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[13:21:41.800] Future #1
[13:21:41.805]  length: 2 (resolved future 1)
[13:21:41.806] Future #2
[13:21:41.808]  length: 1 (resolved future 2)
[13:21:41.808]  length: 0 (resolved future 3)
[13:21:41.808] resolve() on environment ... DONE
[13:21:41.810] resolve() on environment ...
[13:21:41.810]  recursive: 99
[13:21:41.811]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[13:21:41.811] Future #1
[13:21:41.811] A MulticoreFuture was resolved
[13:21:41.811]  length: 2 (resolved future 1)
[13:21:41.811] Future #2
[13:21:41.811] A MulticoreFuture was resolved
[13:21:41.812]  length: 1 (resolved future 2)
[13:21:41.812]  length: 0 (resolved future 3)
[13:21:41.812] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[13:21:41.813] resolve() on list environment ...
[13:21:41.813]  recursive: 0
[13:21:41.814]  length: 2
[13:21:41.814]  elements: ‘a’, ‘b’
[13:21:41.814]  length: 1 (resolved future 1)
[13:21:41.814]  length: 0 (resolved future 2)
[13:21:41.814] resolve() on list environment ... DONE
[13:21:41.814] getGlobalsAndPackages() ...
[13:21:41.814] Searching for globals...
[13:21:41.815] 
[13:21:41.815] Searching for globals ... DONE
[13:21:41.815] - globals: [0] <none>
[13:21:41.815] getGlobalsAndPackages() ... DONE
[13:21:41.816] run() for ‘Future’ ...
[13:21:41.816] - state: ‘created’
[13:21:41.816] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:41.820] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:41.820] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:41.820]   - Field: ‘label’
[13:21:41.820]   - Field: ‘local’
[13:21:41.821]   - Field: ‘owner’
[13:21:41.821]   - Field: ‘envir’
[13:21:41.821]   - Field: ‘workers’
[13:21:41.821]   - Field: ‘packages’
[13:21:41.821]   - Field: ‘gc’
[13:21:41.821]   - Field: ‘job’
[13:21:41.821]   - Field: ‘conditions’
[13:21:41.821]   - Field: ‘expr’
[13:21:41.821]   - Field: ‘uuid’
[13:21:41.822]   - Field: ‘seed’
[13:21:41.822]   - Field: ‘version’
[13:21:41.822]   - Field: ‘result’
[13:21:41.822]   - Field: ‘asynchronous’
[13:21:41.822]   - Field: ‘calls’
[13:21:41.822]   - Field: ‘globals’
[13:21:41.822]   - Field: ‘stdout’
[13:21:41.822]   - Field: ‘earlySignal’
[13:21:41.822]   - Field: ‘lazy’
[13:21:41.823]   - Field: ‘state’
[13:21:41.823] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:41.823] - Launch lazy future ...
[13:21:41.823] Packages needed by the future expression (n = 0): <none>
[13:21:41.823] Packages needed by future strategies (n = 0): <none>
[13:21:41.824] {
[13:21:41.824]     {
[13:21:41.824]         {
[13:21:41.824]             ...future.startTime <- base::Sys.time()
[13:21:41.824]             {
[13:21:41.824]                 {
[13:21:41.824]                   {
[13:21:41.824]                     {
[13:21:41.824]                       base::local({
[13:21:41.824]                         has_future <- base::requireNamespace("future", 
[13:21:41.824]                           quietly = TRUE)
[13:21:41.824]                         if (has_future) {
[13:21:41.824]                           ns <- base::getNamespace("future")
[13:21:41.824]                           version <- ns[[".package"]][["version"]]
[13:21:41.824]                           if (is.null(version)) 
[13:21:41.824]                             version <- utils::packageVersion("future")
[13:21:41.824]                         }
[13:21:41.824]                         else {
[13:21:41.824]                           version <- NULL
[13:21:41.824]                         }
[13:21:41.824]                         if (!has_future || version < "1.8.0") {
[13:21:41.824]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:41.824]                             "", base::R.version$version.string), 
[13:21:41.824]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:41.824]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:41.824]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:41.824]                               "release", "version")], collapse = " "), 
[13:21:41.824]                             hostname = base::Sys.info()[["nodename"]])
[13:21:41.824]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:41.824]                             info)
[13:21:41.824]                           info <- base::paste(info, collapse = "; ")
[13:21:41.824]                           if (!has_future) {
[13:21:41.824]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:41.824]                               info)
[13:21:41.824]                           }
[13:21:41.824]                           else {
[13:21:41.824]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:41.824]                               info, version)
[13:21:41.824]                           }
[13:21:41.824]                           base::stop(msg)
[13:21:41.824]                         }
[13:21:41.824]                       })
[13:21:41.824]                     }
[13:21:41.824]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:41.824]                     base::options(mc.cores = 1L)
[13:21:41.824]                   }
[13:21:41.824]                   options(future.plan = NULL)
[13:21:41.824]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.824]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:41.824]                 }
[13:21:41.824]                 ...future.workdir <- getwd()
[13:21:41.824]             }
[13:21:41.824]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:41.824]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:41.824]         }
[13:21:41.824]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:41.824]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:41.824]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:41.824]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:41.824]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:41.824]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:41.824]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:41.824]             base::names(...future.oldOptions))
[13:21:41.824]     }
[13:21:41.824]     if (FALSE) {
[13:21:41.824]     }
[13:21:41.824]     else {
[13:21:41.824]         if (TRUE) {
[13:21:41.824]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:41.824]                 open = "w")
[13:21:41.824]         }
[13:21:41.824]         else {
[13:21:41.824]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:41.824]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:41.824]         }
[13:21:41.824]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:41.824]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:41.824]             base::sink(type = "output", split = FALSE)
[13:21:41.824]             base::close(...future.stdout)
[13:21:41.824]         }, add = TRUE)
[13:21:41.824]     }
[13:21:41.824]     ...future.frame <- base::sys.nframe()
[13:21:41.824]     ...future.conditions <- base::list()
[13:21:41.824]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:41.824]     if (FALSE) {
[13:21:41.824]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:41.824]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:41.824]     }
[13:21:41.824]     ...future.result <- base::tryCatch({
[13:21:41.824]         base::withCallingHandlers({
[13:21:41.824]             ...future.value <- base::withVisible(base::local({
[13:21:41.824]                 withCallingHandlers({
[13:21:41.824]                   1
[13:21:41.824]                 }, immediateCondition = function(cond) {
[13:21:41.824]                   save_rds <- function (object, pathname, ...) 
[13:21:41.824]                   {
[13:21:41.824]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:41.824]                     if (file_test("-f", pathname_tmp)) {
[13:21:41.824]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.824]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:41.824]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.824]                         fi_tmp[["mtime"]])
[13:21:41.824]                     }
[13:21:41.824]                     tryCatch({
[13:21:41.824]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:41.824]                     }, error = function(ex) {
[13:21:41.824]                       msg <- conditionMessage(ex)
[13:21:41.824]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.824]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:41.824]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.824]                         fi_tmp[["mtime"]], msg)
[13:21:41.824]                       ex$message <- msg
[13:21:41.824]                       stop(ex)
[13:21:41.824]                     })
[13:21:41.824]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:41.824]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:41.824]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:41.824]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.824]                       fi <- file.info(pathname)
[13:21:41.824]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:41.824]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.824]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:41.824]                         fi[["size"]], fi[["mtime"]])
[13:21:41.824]                       stop(msg)
[13:21:41.824]                     }
[13:21:41.824]                     invisible(pathname)
[13:21:41.824]                   }
[13:21:41.824]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:41.824]                     rootPath = tempdir()) 
[13:21:41.824]                   {
[13:21:41.824]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:41.824]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:41.824]                       tmpdir = path, fileext = ".rds")
[13:21:41.824]                     save_rds(obj, file)
[13:21:41.824]                   }
[13:21:41.824]                   saveImmediateCondition(cond, path = "/tmp/RtmpRIPAyw/.future/immediateConditions")
[13:21:41.824]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.824]                   {
[13:21:41.824]                     inherits <- base::inherits
[13:21:41.824]                     invokeRestart <- base::invokeRestart
[13:21:41.824]                     is.null <- base::is.null
[13:21:41.824]                     muffled <- FALSE
[13:21:41.824]                     if (inherits(cond, "message")) {
[13:21:41.824]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:41.824]                       if (muffled) 
[13:21:41.824]                         invokeRestart("muffleMessage")
[13:21:41.824]                     }
[13:21:41.824]                     else if (inherits(cond, "warning")) {
[13:21:41.824]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:41.824]                       if (muffled) 
[13:21:41.824]                         invokeRestart("muffleWarning")
[13:21:41.824]                     }
[13:21:41.824]                     else if (inherits(cond, "condition")) {
[13:21:41.824]                       if (!is.null(pattern)) {
[13:21:41.824]                         computeRestarts <- base::computeRestarts
[13:21:41.824]                         grepl <- base::grepl
[13:21:41.824]                         restarts <- computeRestarts(cond)
[13:21:41.824]                         for (restart in restarts) {
[13:21:41.824]                           name <- restart$name
[13:21:41.824]                           if (is.null(name)) 
[13:21:41.824]                             next
[13:21:41.824]                           if (!grepl(pattern, name)) 
[13:21:41.824]                             next
[13:21:41.824]                           invokeRestart(restart)
[13:21:41.824]                           muffled <- TRUE
[13:21:41.824]                           break
[13:21:41.824]                         }
[13:21:41.824]                       }
[13:21:41.824]                     }
[13:21:41.824]                     invisible(muffled)
[13:21:41.824]                   }
[13:21:41.824]                   muffleCondition(cond)
[13:21:41.824]                 })
[13:21:41.824]             }))
[13:21:41.824]             future::FutureResult(value = ...future.value$value, 
[13:21:41.824]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.824]                   ...future.rng), globalenv = if (FALSE) 
[13:21:41.824]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:41.824]                     ...future.globalenv.names))
[13:21:41.824]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:41.824]         }, condition = base::local({
[13:21:41.824]             c <- base::c
[13:21:41.824]             inherits <- base::inherits
[13:21:41.824]             invokeRestart <- base::invokeRestart
[13:21:41.824]             length <- base::length
[13:21:41.824]             list <- base::list
[13:21:41.824]             seq.int <- base::seq.int
[13:21:41.824]             signalCondition <- base::signalCondition
[13:21:41.824]             sys.calls <- base::sys.calls
[13:21:41.824]             `[[` <- base::`[[`
[13:21:41.824]             `+` <- base::`+`
[13:21:41.824]             `<<-` <- base::`<<-`
[13:21:41.824]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:41.824]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:41.824]                   3L)]
[13:21:41.824]             }
[13:21:41.824]             function(cond) {
[13:21:41.824]                 is_error <- inherits(cond, "error")
[13:21:41.824]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:41.824]                   NULL)
[13:21:41.824]                 if (is_error) {
[13:21:41.824]                   sessionInformation <- function() {
[13:21:41.824]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:41.824]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:41.824]                       search = base::search(), system = base::Sys.info())
[13:21:41.824]                   }
[13:21:41.824]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.824]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:41.824]                     cond$call), session = sessionInformation(), 
[13:21:41.824]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:41.824]                   signalCondition(cond)
[13:21:41.824]                 }
[13:21:41.824]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:41.824]                 "immediateCondition"))) {
[13:21:41.824]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:41.824]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.824]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:41.824]                   if (TRUE && !signal) {
[13:21:41.824]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.824]                     {
[13:21:41.824]                       inherits <- base::inherits
[13:21:41.824]                       invokeRestart <- base::invokeRestart
[13:21:41.824]                       is.null <- base::is.null
[13:21:41.824]                       muffled <- FALSE
[13:21:41.824]                       if (inherits(cond, "message")) {
[13:21:41.824]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.824]                         if (muffled) 
[13:21:41.824]                           invokeRestart("muffleMessage")
[13:21:41.824]                       }
[13:21:41.824]                       else if (inherits(cond, "warning")) {
[13:21:41.824]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.824]                         if (muffled) 
[13:21:41.824]                           invokeRestart("muffleWarning")
[13:21:41.824]                       }
[13:21:41.824]                       else if (inherits(cond, "condition")) {
[13:21:41.824]                         if (!is.null(pattern)) {
[13:21:41.824]                           computeRestarts <- base::computeRestarts
[13:21:41.824]                           grepl <- base::grepl
[13:21:41.824]                           restarts <- computeRestarts(cond)
[13:21:41.824]                           for (restart in restarts) {
[13:21:41.824]                             name <- restart$name
[13:21:41.824]                             if (is.null(name)) 
[13:21:41.824]                               next
[13:21:41.824]                             if (!grepl(pattern, name)) 
[13:21:41.824]                               next
[13:21:41.824]                             invokeRestart(restart)
[13:21:41.824]                             muffled <- TRUE
[13:21:41.824]                             break
[13:21:41.824]                           }
[13:21:41.824]                         }
[13:21:41.824]                       }
[13:21:41.824]                       invisible(muffled)
[13:21:41.824]                     }
[13:21:41.824]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.824]                   }
[13:21:41.824]                 }
[13:21:41.824]                 else {
[13:21:41.824]                   if (TRUE) {
[13:21:41.824]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.824]                     {
[13:21:41.824]                       inherits <- base::inherits
[13:21:41.824]                       invokeRestart <- base::invokeRestart
[13:21:41.824]                       is.null <- base::is.null
[13:21:41.824]                       muffled <- FALSE
[13:21:41.824]                       if (inherits(cond, "message")) {
[13:21:41.824]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.824]                         if (muffled) 
[13:21:41.824]                           invokeRestart("muffleMessage")
[13:21:41.824]                       }
[13:21:41.824]                       else if (inherits(cond, "warning")) {
[13:21:41.824]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.824]                         if (muffled) 
[13:21:41.824]                           invokeRestart("muffleWarning")
[13:21:41.824]                       }
[13:21:41.824]                       else if (inherits(cond, "condition")) {
[13:21:41.824]                         if (!is.null(pattern)) {
[13:21:41.824]                           computeRestarts <- base::computeRestarts
[13:21:41.824]                           grepl <- base::grepl
[13:21:41.824]                           restarts <- computeRestarts(cond)
[13:21:41.824]                           for (restart in restarts) {
[13:21:41.824]                             name <- restart$name
[13:21:41.824]                             if (is.null(name)) 
[13:21:41.824]                               next
[13:21:41.824]                             if (!grepl(pattern, name)) 
[13:21:41.824]                               next
[13:21:41.824]                             invokeRestart(restart)
[13:21:41.824]                             muffled <- TRUE
[13:21:41.824]                             break
[13:21:41.824]                           }
[13:21:41.824]                         }
[13:21:41.824]                       }
[13:21:41.824]                       invisible(muffled)
[13:21:41.824]                     }
[13:21:41.824]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.824]                   }
[13:21:41.824]                 }
[13:21:41.824]             }
[13:21:41.824]         }))
[13:21:41.824]     }, error = function(ex) {
[13:21:41.824]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:41.824]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.824]                 ...future.rng), started = ...future.startTime, 
[13:21:41.824]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:41.824]             version = "1.8"), class = "FutureResult")
[13:21:41.824]     }, finally = {
[13:21:41.824]         if (!identical(...future.workdir, getwd())) 
[13:21:41.824]             setwd(...future.workdir)
[13:21:41.824]         {
[13:21:41.824]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:41.824]                 ...future.oldOptions$nwarnings <- NULL
[13:21:41.824]             }
[13:21:41.824]             base::options(...future.oldOptions)
[13:21:41.824]             if (.Platform$OS.type == "windows") {
[13:21:41.824]                 old_names <- names(...future.oldEnvVars)
[13:21:41.824]                 envs <- base::Sys.getenv()
[13:21:41.824]                 names <- names(envs)
[13:21:41.824]                 common <- intersect(names, old_names)
[13:21:41.824]                 added <- setdiff(names, old_names)
[13:21:41.824]                 removed <- setdiff(old_names, names)
[13:21:41.824]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:41.824]                   envs[common]]
[13:21:41.824]                 NAMES <- toupper(changed)
[13:21:41.824]                 args <- list()
[13:21:41.824]                 for (kk in seq_along(NAMES)) {
[13:21:41.824]                   name <- changed[[kk]]
[13:21:41.824]                   NAME <- NAMES[[kk]]
[13:21:41.824]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.824]                     next
[13:21:41.824]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.824]                 }
[13:21:41.824]                 NAMES <- toupper(added)
[13:21:41.824]                 for (kk in seq_along(NAMES)) {
[13:21:41.824]                   name <- added[[kk]]
[13:21:41.824]                   NAME <- NAMES[[kk]]
[13:21:41.824]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.824]                     next
[13:21:41.824]                   args[[name]] <- ""
[13:21:41.824]                 }
[13:21:41.824]                 NAMES <- toupper(removed)
[13:21:41.824]                 for (kk in seq_along(NAMES)) {
[13:21:41.824]                   name <- removed[[kk]]
[13:21:41.824]                   NAME <- NAMES[[kk]]
[13:21:41.824]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.824]                     next
[13:21:41.824]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.824]                 }
[13:21:41.824]                 if (length(args) > 0) 
[13:21:41.824]                   base::do.call(base::Sys.setenv, args = args)
[13:21:41.824]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:41.824]             }
[13:21:41.824]             else {
[13:21:41.824]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:41.824]             }
[13:21:41.824]             {
[13:21:41.824]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:41.824]                   0L) {
[13:21:41.824]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:41.824]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:41.824]                   base::options(opts)
[13:21:41.824]                 }
[13:21:41.824]                 {
[13:21:41.824]                   {
[13:21:41.824]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:41.824]                     NULL
[13:21:41.824]                   }
[13:21:41.824]                   options(future.plan = NULL)
[13:21:41.824]                   if (is.na(NA_character_)) 
[13:21:41.824]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.824]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:41.824]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:41.824]                     envir = parent.frame()) 
[13:21:41.824]                   {
[13:21:41.824]                     default_workers <- missing(workers)
[13:21:41.824]                     if (is.function(workers)) 
[13:21:41.824]                       workers <- workers()
[13:21:41.824]                     workers <- structure(as.integer(workers), 
[13:21:41.824]                       class = class(workers))
[13:21:41.824]                     stop_if_not(is.finite(workers), workers >= 
[13:21:41.824]                       1L)
[13:21:41.824]                     if ((workers == 1L && !inherits(workers, 
[13:21:41.824]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:41.824]                       if (default_workers) 
[13:21:41.824]                         supportsMulticore(warn = TRUE)
[13:21:41.824]                       return(sequential(..., envir = envir))
[13:21:41.824]                     }
[13:21:41.824]                     oopts <- options(mc.cores = workers)
[13:21:41.824]                     on.exit(options(oopts))
[13:21:41.824]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:41.824]                       envir = envir)
[13:21:41.824]                     if (!future$lazy) 
[13:21:41.824]                       future <- run(future)
[13:21:41.824]                     invisible(future)
[13:21:41.824]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:41.824]                 }
[13:21:41.824]             }
[13:21:41.824]         }
[13:21:41.824]     })
[13:21:41.824]     if (TRUE) {
[13:21:41.824]         base::sink(type = "output", split = FALSE)
[13:21:41.824]         if (TRUE) {
[13:21:41.824]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:41.824]         }
[13:21:41.824]         else {
[13:21:41.824]             ...future.result["stdout"] <- base::list(NULL)
[13:21:41.824]         }
[13:21:41.824]         base::close(...future.stdout)
[13:21:41.824]         ...future.stdout <- NULL
[13:21:41.824]     }
[13:21:41.824]     ...future.result$conditions <- ...future.conditions
[13:21:41.824]     ...future.result$finished <- base::Sys.time()
[13:21:41.824]     ...future.result
[13:21:41.824] }
[13:21:41.826] requestCore(): workers = 2
[13:21:41.828] MulticoreFuture started
[13:21:41.829] - Launch lazy future ... done
[13:21:41.829] run() for ‘MulticoreFuture’ ... done
[13:21:41.830] getGlobalsAndPackages() ...
[13:21:41.830] plan(): Setting new future strategy stack:
[13:21:41.830] Searching for globals...
[13:21:41.830] List of future strategies:
[13:21:41.830] 1. sequential:
[13:21:41.830]    - args: function (..., envir = parent.frame())
[13:21:41.830]    - tweaked: FALSE
[13:21:41.830]    - call: NULL
[13:21:41.830] 
[13:21:41.831] Searching for globals ... DONE
[13:21:41.831] plan(): nbrOfWorkers() = 1
[13:21:41.831] - globals: [0] <none>
[13:21:41.831] getGlobalsAndPackages() ... DONE
[13:21:41.832] run() for ‘Future’ ...
[13:21:41.832] - state: ‘created’
[13:21:41.832] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:41.833] plan(): Setting new future strategy stack:
[13:21:41.833] List of future strategies:
[13:21:41.833] 1. multicore:
[13:21:41.833]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:41.833]    - tweaked: FALSE
[13:21:41.833]    - call: plan(strategy)
[13:21:41.837] plan(): nbrOfWorkers() = 2
[13:21:41.837] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:41.838] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:41.838]   - Field: ‘label’
[13:21:41.838]   - Field: ‘local’
[13:21:41.838]   - Field: ‘owner’
[13:21:41.838]   - Field: ‘envir’
[13:21:41.839]   - Field: ‘workers’
[13:21:41.839]   - Field: ‘packages’
[13:21:41.839]   - Field: ‘gc’
[13:21:41.839]   - Field: ‘job’
[13:21:41.839]   - Field: ‘conditions’
[13:21:41.840]   - Field: ‘expr’
[13:21:41.840]   - Field: ‘uuid’
[13:21:41.840]   - Field: ‘seed’
[13:21:41.840]   - Field: ‘version’
[13:21:41.840]   - Field: ‘result’
[13:21:41.840]   - Field: ‘asynchronous’
[13:21:41.841]   - Field: ‘calls’
[13:21:41.841]   - Field: ‘globals’
[13:21:41.841]   - Field: ‘stdout’
[13:21:41.841]   - Field: ‘earlySignal’
[13:21:41.841]   - Field: ‘lazy’
[13:21:41.841]   - Field: ‘state’
[13:21:41.842] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:41.842] - Launch lazy future ...
[13:21:41.842] Packages needed by the future expression (n = 0): <none>
[13:21:41.842] Packages needed by future strategies (n = 0): <none>
[13:21:41.843] {
[13:21:41.843]     {
[13:21:41.843]         {
[13:21:41.843]             ...future.startTime <- base::Sys.time()
[13:21:41.843]             {
[13:21:41.843]                 {
[13:21:41.843]                   {
[13:21:41.843]                     {
[13:21:41.843]                       base::local({
[13:21:41.843]                         has_future <- base::requireNamespace("future", 
[13:21:41.843]                           quietly = TRUE)
[13:21:41.843]                         if (has_future) {
[13:21:41.843]                           ns <- base::getNamespace("future")
[13:21:41.843]                           version <- ns[[".package"]][["version"]]
[13:21:41.843]                           if (is.null(version)) 
[13:21:41.843]                             version <- utils::packageVersion("future")
[13:21:41.843]                         }
[13:21:41.843]                         else {
[13:21:41.843]                           version <- NULL
[13:21:41.843]                         }
[13:21:41.843]                         if (!has_future || version < "1.8.0") {
[13:21:41.843]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:41.843]                             "", base::R.version$version.string), 
[13:21:41.843]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:41.843]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:41.843]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:41.843]                               "release", "version")], collapse = " "), 
[13:21:41.843]                             hostname = base::Sys.info()[["nodename"]])
[13:21:41.843]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:41.843]                             info)
[13:21:41.843]                           info <- base::paste(info, collapse = "; ")
[13:21:41.843]                           if (!has_future) {
[13:21:41.843]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:41.843]                               info)
[13:21:41.843]                           }
[13:21:41.843]                           else {
[13:21:41.843]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:41.843]                               info, version)
[13:21:41.843]                           }
[13:21:41.843]                           base::stop(msg)
[13:21:41.843]                         }
[13:21:41.843]                       })
[13:21:41.843]                     }
[13:21:41.843]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:41.843]                     base::options(mc.cores = 1L)
[13:21:41.843]                   }
[13:21:41.843]                   options(future.plan = NULL)
[13:21:41.843]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.843]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:41.843]                 }
[13:21:41.843]                 ...future.workdir <- getwd()
[13:21:41.843]             }
[13:21:41.843]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:41.843]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:41.843]         }
[13:21:41.843]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:41.843]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:41.843]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:41.843]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:41.843]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:41.843]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:41.843]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:41.843]             base::names(...future.oldOptions))
[13:21:41.843]     }
[13:21:41.843]     if (FALSE) {
[13:21:41.843]     }
[13:21:41.843]     else {
[13:21:41.843]         if (TRUE) {
[13:21:41.843]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:41.843]                 open = "w")
[13:21:41.843]         }
[13:21:41.843]         else {
[13:21:41.843]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:41.843]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:41.843]         }
[13:21:41.843]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:41.843]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:41.843]             base::sink(type = "output", split = FALSE)
[13:21:41.843]             base::close(...future.stdout)
[13:21:41.843]         }, add = TRUE)
[13:21:41.843]     }
[13:21:41.843]     ...future.frame <- base::sys.nframe()
[13:21:41.843]     ...future.conditions <- base::list()
[13:21:41.843]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:41.843]     if (FALSE) {
[13:21:41.843]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:41.843]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:41.843]     }
[13:21:41.843]     ...future.result <- base::tryCatch({
[13:21:41.843]         base::withCallingHandlers({
[13:21:41.843]             ...future.value <- base::withVisible(base::local({
[13:21:41.843]                 withCallingHandlers({
[13:21:41.843]                   2
[13:21:41.843]                 }, immediateCondition = function(cond) {
[13:21:41.843]                   save_rds <- function (object, pathname, ...) 
[13:21:41.843]                   {
[13:21:41.843]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:41.843]                     if (file_test("-f", pathname_tmp)) {
[13:21:41.843]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.843]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:41.843]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.843]                         fi_tmp[["mtime"]])
[13:21:41.843]                     }
[13:21:41.843]                     tryCatch({
[13:21:41.843]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:41.843]                     }, error = function(ex) {
[13:21:41.843]                       msg <- conditionMessage(ex)
[13:21:41.843]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.843]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:41.843]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.843]                         fi_tmp[["mtime"]], msg)
[13:21:41.843]                       ex$message <- msg
[13:21:41.843]                       stop(ex)
[13:21:41.843]                     })
[13:21:41.843]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:41.843]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:41.843]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:41.843]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.843]                       fi <- file.info(pathname)
[13:21:41.843]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:41.843]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.843]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:41.843]                         fi[["size"]], fi[["mtime"]])
[13:21:41.843]                       stop(msg)
[13:21:41.843]                     }
[13:21:41.843]                     invisible(pathname)
[13:21:41.843]                   }
[13:21:41.843]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:41.843]                     rootPath = tempdir()) 
[13:21:41.843]                   {
[13:21:41.843]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:41.843]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:41.843]                       tmpdir = path, fileext = ".rds")
[13:21:41.843]                     save_rds(obj, file)
[13:21:41.843]                   }
[13:21:41.843]                   saveImmediateCondition(cond, path = "/tmp/RtmpRIPAyw/.future/immediateConditions")
[13:21:41.843]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.843]                   {
[13:21:41.843]                     inherits <- base::inherits
[13:21:41.843]                     invokeRestart <- base::invokeRestart
[13:21:41.843]                     is.null <- base::is.null
[13:21:41.843]                     muffled <- FALSE
[13:21:41.843]                     if (inherits(cond, "message")) {
[13:21:41.843]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:41.843]                       if (muffled) 
[13:21:41.843]                         invokeRestart("muffleMessage")
[13:21:41.843]                     }
[13:21:41.843]                     else if (inherits(cond, "warning")) {
[13:21:41.843]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:41.843]                       if (muffled) 
[13:21:41.843]                         invokeRestart("muffleWarning")
[13:21:41.843]                     }
[13:21:41.843]                     else if (inherits(cond, "condition")) {
[13:21:41.843]                       if (!is.null(pattern)) {
[13:21:41.843]                         computeRestarts <- base::computeRestarts
[13:21:41.843]                         grepl <- base::grepl
[13:21:41.843]                         restarts <- computeRestarts(cond)
[13:21:41.843]                         for (restart in restarts) {
[13:21:41.843]                           name <- restart$name
[13:21:41.843]                           if (is.null(name)) 
[13:21:41.843]                             next
[13:21:41.843]                           if (!grepl(pattern, name)) 
[13:21:41.843]                             next
[13:21:41.843]                           invokeRestart(restart)
[13:21:41.843]                           muffled <- TRUE
[13:21:41.843]                           break
[13:21:41.843]                         }
[13:21:41.843]                       }
[13:21:41.843]                     }
[13:21:41.843]                     invisible(muffled)
[13:21:41.843]                   }
[13:21:41.843]                   muffleCondition(cond)
[13:21:41.843]                 })
[13:21:41.843]             }))
[13:21:41.843]             future::FutureResult(value = ...future.value$value, 
[13:21:41.843]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.843]                   ...future.rng), globalenv = if (FALSE) 
[13:21:41.843]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:41.843]                     ...future.globalenv.names))
[13:21:41.843]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:41.843]         }, condition = base::local({
[13:21:41.843]             c <- base::c
[13:21:41.843]             inherits <- base::inherits
[13:21:41.843]             invokeRestart <- base::invokeRestart
[13:21:41.843]             length <- base::length
[13:21:41.843]             list <- base::list
[13:21:41.843]             seq.int <- base::seq.int
[13:21:41.843]             signalCondition <- base::signalCondition
[13:21:41.843]             sys.calls <- base::sys.calls
[13:21:41.843]             `[[` <- base::`[[`
[13:21:41.843]             `+` <- base::`+`
[13:21:41.843]             `<<-` <- base::`<<-`
[13:21:41.843]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:41.843]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:41.843]                   3L)]
[13:21:41.843]             }
[13:21:41.843]             function(cond) {
[13:21:41.843]                 is_error <- inherits(cond, "error")
[13:21:41.843]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:41.843]                   NULL)
[13:21:41.843]                 if (is_error) {
[13:21:41.843]                   sessionInformation <- function() {
[13:21:41.843]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:41.843]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:41.843]                       search = base::search(), system = base::Sys.info())
[13:21:41.843]                   }
[13:21:41.843]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.843]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:41.843]                     cond$call), session = sessionInformation(), 
[13:21:41.843]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:41.843]                   signalCondition(cond)
[13:21:41.843]                 }
[13:21:41.843]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:41.843]                 "immediateCondition"))) {
[13:21:41.843]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:41.843]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.843]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:41.843]                   if (TRUE && !signal) {
[13:21:41.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.843]                     {
[13:21:41.843]                       inherits <- base::inherits
[13:21:41.843]                       invokeRestart <- base::invokeRestart
[13:21:41.843]                       is.null <- base::is.null
[13:21:41.843]                       muffled <- FALSE
[13:21:41.843]                       if (inherits(cond, "message")) {
[13:21:41.843]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.843]                         if (muffled) 
[13:21:41.843]                           invokeRestart("muffleMessage")
[13:21:41.843]                       }
[13:21:41.843]                       else if (inherits(cond, "warning")) {
[13:21:41.843]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.843]                         if (muffled) 
[13:21:41.843]                           invokeRestart("muffleWarning")
[13:21:41.843]                       }
[13:21:41.843]                       else if (inherits(cond, "condition")) {
[13:21:41.843]                         if (!is.null(pattern)) {
[13:21:41.843]                           computeRestarts <- base::computeRestarts
[13:21:41.843]                           grepl <- base::grepl
[13:21:41.843]                           restarts <- computeRestarts(cond)
[13:21:41.843]                           for (restart in restarts) {
[13:21:41.843]                             name <- restart$name
[13:21:41.843]                             if (is.null(name)) 
[13:21:41.843]                               next
[13:21:41.843]                             if (!grepl(pattern, name)) 
[13:21:41.843]                               next
[13:21:41.843]                             invokeRestart(restart)
[13:21:41.843]                             muffled <- TRUE
[13:21:41.843]                             break
[13:21:41.843]                           }
[13:21:41.843]                         }
[13:21:41.843]                       }
[13:21:41.843]                       invisible(muffled)
[13:21:41.843]                     }
[13:21:41.843]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.843]                   }
[13:21:41.843]                 }
[13:21:41.843]                 else {
[13:21:41.843]                   if (TRUE) {
[13:21:41.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.843]                     {
[13:21:41.843]                       inherits <- base::inherits
[13:21:41.843]                       invokeRestart <- base::invokeRestart
[13:21:41.843]                       is.null <- base::is.null
[13:21:41.843]                       muffled <- FALSE
[13:21:41.843]                       if (inherits(cond, "message")) {
[13:21:41.843]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.843]                         if (muffled) 
[13:21:41.843]                           invokeRestart("muffleMessage")
[13:21:41.843]                       }
[13:21:41.843]                       else if (inherits(cond, "warning")) {
[13:21:41.843]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.843]                         if (muffled) 
[13:21:41.843]                           invokeRestart("muffleWarning")
[13:21:41.843]                       }
[13:21:41.843]                       else if (inherits(cond, "condition")) {
[13:21:41.843]                         if (!is.null(pattern)) {
[13:21:41.843]                           computeRestarts <- base::computeRestarts
[13:21:41.843]                           grepl <- base::grepl
[13:21:41.843]                           restarts <- computeRestarts(cond)
[13:21:41.843]                           for (restart in restarts) {
[13:21:41.843]                             name <- restart$name
[13:21:41.843]                             if (is.null(name)) 
[13:21:41.843]                               next
[13:21:41.843]                             if (!grepl(pattern, name)) 
[13:21:41.843]                               next
[13:21:41.843]                             invokeRestart(restart)
[13:21:41.843]                             muffled <- TRUE
[13:21:41.843]                             break
[13:21:41.843]                           }
[13:21:41.843]                         }
[13:21:41.843]                       }
[13:21:41.843]                       invisible(muffled)
[13:21:41.843]                     }
[13:21:41.843]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.843]                   }
[13:21:41.843]                 }
[13:21:41.843]             }
[13:21:41.843]         }))
[13:21:41.843]     }, error = function(ex) {
[13:21:41.843]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:41.843]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.843]                 ...future.rng), started = ...future.startTime, 
[13:21:41.843]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:41.843]             version = "1.8"), class = "FutureResult")
[13:21:41.843]     }, finally = {
[13:21:41.843]         if (!identical(...future.workdir, getwd())) 
[13:21:41.843]             setwd(...future.workdir)
[13:21:41.843]         {
[13:21:41.843]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:41.843]                 ...future.oldOptions$nwarnings <- NULL
[13:21:41.843]             }
[13:21:41.843]             base::options(...future.oldOptions)
[13:21:41.843]             if (.Platform$OS.type == "windows") {
[13:21:41.843]                 old_names <- names(...future.oldEnvVars)
[13:21:41.843]                 envs <- base::Sys.getenv()
[13:21:41.843]                 names <- names(envs)
[13:21:41.843]                 common <- intersect(names, old_names)
[13:21:41.843]                 added <- setdiff(names, old_names)
[13:21:41.843]                 removed <- setdiff(old_names, names)
[13:21:41.843]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:41.843]                   envs[common]]
[13:21:41.843]                 NAMES <- toupper(changed)
[13:21:41.843]                 args <- list()
[13:21:41.843]                 for (kk in seq_along(NAMES)) {
[13:21:41.843]                   name <- changed[[kk]]
[13:21:41.843]                   NAME <- NAMES[[kk]]
[13:21:41.843]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.843]                     next
[13:21:41.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.843]                 }
[13:21:41.843]                 NAMES <- toupper(added)
[13:21:41.843]                 for (kk in seq_along(NAMES)) {
[13:21:41.843]                   name <- added[[kk]]
[13:21:41.843]                   NAME <- NAMES[[kk]]
[13:21:41.843]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.843]                     next
[13:21:41.843]                   args[[name]] <- ""
[13:21:41.843]                 }
[13:21:41.843]                 NAMES <- toupper(removed)
[13:21:41.843]                 for (kk in seq_along(NAMES)) {
[13:21:41.843]                   name <- removed[[kk]]
[13:21:41.843]                   NAME <- NAMES[[kk]]
[13:21:41.843]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.843]                     next
[13:21:41.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.843]                 }
[13:21:41.843]                 if (length(args) > 0) 
[13:21:41.843]                   base::do.call(base::Sys.setenv, args = args)
[13:21:41.843]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:41.843]             }
[13:21:41.843]             else {
[13:21:41.843]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:41.843]             }
[13:21:41.843]             {
[13:21:41.843]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:41.843]                   0L) {
[13:21:41.843]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:41.843]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:41.843]                   base::options(opts)
[13:21:41.843]                 }
[13:21:41.843]                 {
[13:21:41.843]                   {
[13:21:41.843]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:41.843]                     NULL
[13:21:41.843]                   }
[13:21:41.843]                   options(future.plan = NULL)
[13:21:41.843]                   if (is.na(NA_character_)) 
[13:21:41.843]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.843]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:41.843]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:41.843]                     envir = parent.frame()) 
[13:21:41.843]                   {
[13:21:41.843]                     default_workers <- missing(workers)
[13:21:41.843]                     if (is.function(workers)) 
[13:21:41.843]                       workers <- workers()
[13:21:41.843]                     workers <- structure(as.integer(workers), 
[13:21:41.843]                       class = class(workers))
[13:21:41.843]                     stop_if_not(is.finite(workers), workers >= 
[13:21:41.843]                       1L)
[13:21:41.843]                     if ((workers == 1L && !inherits(workers, 
[13:21:41.843]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:41.843]                       if (default_workers) 
[13:21:41.843]                         supportsMulticore(warn = TRUE)
[13:21:41.843]                       return(sequential(..., envir = envir))
[13:21:41.843]                     }
[13:21:41.843]                     oopts <- options(mc.cores = workers)
[13:21:41.843]                     on.exit(options(oopts))
[13:21:41.843]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:41.843]                       envir = envir)
[13:21:41.843]                     if (!future$lazy) 
[13:21:41.843]                       future <- run(future)
[13:21:41.843]                     invisible(future)
[13:21:41.843]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:41.843]                 }
[13:21:41.843]             }
[13:21:41.843]         }
[13:21:41.843]     })
[13:21:41.843]     if (TRUE) {
[13:21:41.843]         base::sink(type = "output", split = FALSE)
[13:21:41.843]         if (TRUE) {
[13:21:41.843]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:41.843]         }
[13:21:41.843]         else {
[13:21:41.843]             ...future.result["stdout"] <- base::list(NULL)
[13:21:41.843]         }
[13:21:41.843]         base::close(...future.stdout)
[13:21:41.843]         ...future.stdout <- NULL
[13:21:41.843]     }
[13:21:41.843]     ...future.result$conditions <- ...future.conditions
[13:21:41.843]     ...future.result$finished <- base::Sys.time()
[13:21:41.843]     ...future.result
[13:21:41.843] }
[13:21:41.847] requestCore(): workers = 2
[13:21:41.849] MulticoreFuture started
[13:21:41.850] - Launch lazy future ... done
[13:21:41.850] run() for ‘MulticoreFuture’ ... done
[13:21:41.850] plan(): Setting new future strategy stack:
[13:21:41.851] resolve() on list environment ...
[13:21:41.851] List of future strategies:
[13:21:41.851] 1. sequential:
[13:21:41.851]    - args: function (..., envir = parent.frame())
[13:21:41.851]    - tweaked: FALSE
[13:21:41.851]    - call: NULL
[13:21:41.851]  recursive: 0
[13:21:41.852] plan(): nbrOfWorkers() = 1
[13:21:41.852]  length: 3
[13:21:41.853]  elements: ‘a’, ‘b’, ‘c’
[13:21:41.853] Future #1
[13:21:41.853]  length: 2 (resolved future 1)
[13:21:41.854] plan(): Setting new future strategy stack:
[13:21:41.854] List of future strategies:
[13:21:41.854] 1. multicore:
[13:21:41.854]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:41.854]    - tweaked: FALSE
[13:21:41.854]    - call: plan(strategy)
[13:21:41.859] plan(): nbrOfWorkers() = 2
[13:21:41.860] Future #2
[13:21:41.860]  length: 1 (resolved future 2)
[13:21:41.860]  length: 0 (resolved future 3)
[13:21:41.860] resolve() on list environment ... DONE
[13:21:41.862] getGlobalsAndPackages() ...
[13:21:41.862] Searching for globals...
[13:21:41.863] - globals found: [1] ‘{’
[13:21:41.863] Searching for globals ... DONE
[13:21:41.863] Resolving globals: FALSE
[13:21:41.868] 
[13:21:41.869] 
[13:21:41.869] getGlobalsAndPackages() ... DONE
[13:21:41.870] run() for ‘Future’ ...
[13:21:41.870] - state: ‘created’
[13:21:41.871] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:41.877] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:41.877] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:41.877]   - Field: ‘label’
[13:21:41.877]   - Field: ‘local’
[13:21:41.877]   - Field: ‘owner’
[13:21:41.878]   - Field: ‘envir’
[13:21:41.878]   - Field: ‘workers’
[13:21:41.878]   - Field: ‘packages’
[13:21:41.878]   - Field: ‘gc’
[13:21:41.878]   - Field: ‘job’
[13:21:41.879]   - Field: ‘conditions’
[13:21:41.879]   - Field: ‘expr’
[13:21:41.879]   - Field: ‘uuid’
[13:21:41.879]   - Field: ‘seed’
[13:21:41.879]   - Field: ‘version’
[13:21:41.879]   - Field: ‘result’
[13:21:41.880]   - Field: ‘asynchronous’
[13:21:41.880]   - Field: ‘calls’
[13:21:41.880]   - Field: ‘globals’
[13:21:41.880]   - Field: ‘stdout’
[13:21:41.880]   - Field: ‘earlySignal’
[13:21:41.880]   - Field: ‘lazy’
[13:21:41.881]   - Field: ‘state’
[13:21:41.881] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:41.881] - Launch lazy future ...
[13:21:41.882] Packages needed by the future expression (n = 0): <none>
[13:21:41.882] Packages needed by future strategies (n = 0): <none>
[13:21:41.883] {
[13:21:41.883]     {
[13:21:41.883]         {
[13:21:41.883]             ...future.startTime <- base::Sys.time()
[13:21:41.883]             {
[13:21:41.883]                 {
[13:21:41.883]                   {
[13:21:41.883]                     {
[13:21:41.883]                       base::local({
[13:21:41.883]                         has_future <- base::requireNamespace("future", 
[13:21:41.883]                           quietly = TRUE)
[13:21:41.883]                         if (has_future) {
[13:21:41.883]                           ns <- base::getNamespace("future")
[13:21:41.883]                           version <- ns[[".package"]][["version"]]
[13:21:41.883]                           if (is.null(version)) 
[13:21:41.883]                             version <- utils::packageVersion("future")
[13:21:41.883]                         }
[13:21:41.883]                         else {
[13:21:41.883]                           version <- NULL
[13:21:41.883]                         }
[13:21:41.883]                         if (!has_future || version < "1.8.0") {
[13:21:41.883]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:41.883]                             "", base::R.version$version.string), 
[13:21:41.883]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:41.883]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:41.883]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:41.883]                               "release", "version")], collapse = " "), 
[13:21:41.883]                             hostname = base::Sys.info()[["nodename"]])
[13:21:41.883]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:41.883]                             info)
[13:21:41.883]                           info <- base::paste(info, collapse = "; ")
[13:21:41.883]                           if (!has_future) {
[13:21:41.883]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:41.883]                               info)
[13:21:41.883]                           }
[13:21:41.883]                           else {
[13:21:41.883]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:41.883]                               info, version)
[13:21:41.883]                           }
[13:21:41.883]                           base::stop(msg)
[13:21:41.883]                         }
[13:21:41.883]                       })
[13:21:41.883]                     }
[13:21:41.883]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:41.883]                     base::options(mc.cores = 1L)
[13:21:41.883]                   }
[13:21:41.883]                   options(future.plan = NULL)
[13:21:41.883]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.883]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:41.883]                 }
[13:21:41.883]                 ...future.workdir <- getwd()
[13:21:41.883]             }
[13:21:41.883]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:41.883]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:41.883]         }
[13:21:41.883]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:41.883]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:41.883]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:41.883]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:41.883]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:41.883]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:41.883]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:41.883]             base::names(...future.oldOptions))
[13:21:41.883]     }
[13:21:41.883]     if (FALSE) {
[13:21:41.883]     }
[13:21:41.883]     else {
[13:21:41.883]         if (TRUE) {
[13:21:41.883]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:41.883]                 open = "w")
[13:21:41.883]         }
[13:21:41.883]         else {
[13:21:41.883]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:41.883]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:41.883]         }
[13:21:41.883]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:41.883]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:41.883]             base::sink(type = "output", split = FALSE)
[13:21:41.883]             base::close(...future.stdout)
[13:21:41.883]         }, add = TRUE)
[13:21:41.883]     }
[13:21:41.883]     ...future.frame <- base::sys.nframe()
[13:21:41.883]     ...future.conditions <- base::list()
[13:21:41.883]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:41.883]     if (FALSE) {
[13:21:41.883]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:41.883]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:41.883]     }
[13:21:41.883]     ...future.result <- base::tryCatch({
[13:21:41.883]         base::withCallingHandlers({
[13:21:41.883]             ...future.value <- base::withVisible(base::local({
[13:21:41.883]                 withCallingHandlers({
[13:21:41.883]                   {
[13:21:41.883]                     1
[13:21:41.883]                   }
[13:21:41.883]                 }, immediateCondition = function(cond) {
[13:21:41.883]                   save_rds <- function (object, pathname, ...) 
[13:21:41.883]                   {
[13:21:41.883]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:41.883]                     if (file_test("-f", pathname_tmp)) {
[13:21:41.883]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.883]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:41.883]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.883]                         fi_tmp[["mtime"]])
[13:21:41.883]                     }
[13:21:41.883]                     tryCatch({
[13:21:41.883]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:41.883]                     }, error = function(ex) {
[13:21:41.883]                       msg <- conditionMessage(ex)
[13:21:41.883]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.883]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:41.883]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.883]                         fi_tmp[["mtime"]], msg)
[13:21:41.883]                       ex$message <- msg
[13:21:41.883]                       stop(ex)
[13:21:41.883]                     })
[13:21:41.883]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:41.883]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:41.883]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:41.883]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.883]                       fi <- file.info(pathname)
[13:21:41.883]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:41.883]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.883]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:41.883]                         fi[["size"]], fi[["mtime"]])
[13:21:41.883]                       stop(msg)
[13:21:41.883]                     }
[13:21:41.883]                     invisible(pathname)
[13:21:41.883]                   }
[13:21:41.883]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:41.883]                     rootPath = tempdir()) 
[13:21:41.883]                   {
[13:21:41.883]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:41.883]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:41.883]                       tmpdir = path, fileext = ".rds")
[13:21:41.883]                     save_rds(obj, file)
[13:21:41.883]                   }
[13:21:41.883]                   saveImmediateCondition(cond, path = "/tmp/RtmpRIPAyw/.future/immediateConditions")
[13:21:41.883]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.883]                   {
[13:21:41.883]                     inherits <- base::inherits
[13:21:41.883]                     invokeRestart <- base::invokeRestart
[13:21:41.883]                     is.null <- base::is.null
[13:21:41.883]                     muffled <- FALSE
[13:21:41.883]                     if (inherits(cond, "message")) {
[13:21:41.883]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:41.883]                       if (muffled) 
[13:21:41.883]                         invokeRestart("muffleMessage")
[13:21:41.883]                     }
[13:21:41.883]                     else if (inherits(cond, "warning")) {
[13:21:41.883]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:41.883]                       if (muffled) 
[13:21:41.883]                         invokeRestart("muffleWarning")
[13:21:41.883]                     }
[13:21:41.883]                     else if (inherits(cond, "condition")) {
[13:21:41.883]                       if (!is.null(pattern)) {
[13:21:41.883]                         computeRestarts <- base::computeRestarts
[13:21:41.883]                         grepl <- base::grepl
[13:21:41.883]                         restarts <- computeRestarts(cond)
[13:21:41.883]                         for (restart in restarts) {
[13:21:41.883]                           name <- restart$name
[13:21:41.883]                           if (is.null(name)) 
[13:21:41.883]                             next
[13:21:41.883]                           if (!grepl(pattern, name)) 
[13:21:41.883]                             next
[13:21:41.883]                           invokeRestart(restart)
[13:21:41.883]                           muffled <- TRUE
[13:21:41.883]                           break
[13:21:41.883]                         }
[13:21:41.883]                       }
[13:21:41.883]                     }
[13:21:41.883]                     invisible(muffled)
[13:21:41.883]                   }
[13:21:41.883]                   muffleCondition(cond)
[13:21:41.883]                 })
[13:21:41.883]             }))
[13:21:41.883]             future::FutureResult(value = ...future.value$value, 
[13:21:41.883]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.883]                   ...future.rng), globalenv = if (FALSE) 
[13:21:41.883]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:41.883]                     ...future.globalenv.names))
[13:21:41.883]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:41.883]         }, condition = base::local({
[13:21:41.883]             c <- base::c
[13:21:41.883]             inherits <- base::inherits
[13:21:41.883]             invokeRestart <- base::invokeRestart
[13:21:41.883]             length <- base::length
[13:21:41.883]             list <- base::list
[13:21:41.883]             seq.int <- base::seq.int
[13:21:41.883]             signalCondition <- base::signalCondition
[13:21:41.883]             sys.calls <- base::sys.calls
[13:21:41.883]             `[[` <- base::`[[`
[13:21:41.883]             `+` <- base::`+`
[13:21:41.883]             `<<-` <- base::`<<-`
[13:21:41.883]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:41.883]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:41.883]                   3L)]
[13:21:41.883]             }
[13:21:41.883]             function(cond) {
[13:21:41.883]                 is_error <- inherits(cond, "error")
[13:21:41.883]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:41.883]                   NULL)
[13:21:41.883]                 if (is_error) {
[13:21:41.883]                   sessionInformation <- function() {
[13:21:41.883]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:41.883]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:41.883]                       search = base::search(), system = base::Sys.info())
[13:21:41.883]                   }
[13:21:41.883]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.883]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:41.883]                     cond$call), session = sessionInformation(), 
[13:21:41.883]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:41.883]                   signalCondition(cond)
[13:21:41.883]                 }
[13:21:41.883]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:41.883]                 "immediateCondition"))) {
[13:21:41.883]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:41.883]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.883]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:41.883]                   if (TRUE && !signal) {
[13:21:41.883]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.883]                     {
[13:21:41.883]                       inherits <- base::inherits
[13:21:41.883]                       invokeRestart <- base::invokeRestart
[13:21:41.883]                       is.null <- base::is.null
[13:21:41.883]                       muffled <- FALSE
[13:21:41.883]                       if (inherits(cond, "message")) {
[13:21:41.883]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.883]                         if (muffled) 
[13:21:41.883]                           invokeRestart("muffleMessage")
[13:21:41.883]                       }
[13:21:41.883]                       else if (inherits(cond, "warning")) {
[13:21:41.883]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.883]                         if (muffled) 
[13:21:41.883]                           invokeRestart("muffleWarning")
[13:21:41.883]                       }
[13:21:41.883]                       else if (inherits(cond, "condition")) {
[13:21:41.883]                         if (!is.null(pattern)) {
[13:21:41.883]                           computeRestarts <- base::computeRestarts
[13:21:41.883]                           grepl <- base::grepl
[13:21:41.883]                           restarts <- computeRestarts(cond)
[13:21:41.883]                           for (restart in restarts) {
[13:21:41.883]                             name <- restart$name
[13:21:41.883]                             if (is.null(name)) 
[13:21:41.883]                               next
[13:21:41.883]                             if (!grepl(pattern, name)) 
[13:21:41.883]                               next
[13:21:41.883]                             invokeRestart(restart)
[13:21:41.883]                             muffled <- TRUE
[13:21:41.883]                             break
[13:21:41.883]                           }
[13:21:41.883]                         }
[13:21:41.883]                       }
[13:21:41.883]                       invisible(muffled)
[13:21:41.883]                     }
[13:21:41.883]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.883]                   }
[13:21:41.883]                 }
[13:21:41.883]                 else {
[13:21:41.883]                   if (TRUE) {
[13:21:41.883]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.883]                     {
[13:21:41.883]                       inherits <- base::inherits
[13:21:41.883]                       invokeRestart <- base::invokeRestart
[13:21:41.883]                       is.null <- base::is.null
[13:21:41.883]                       muffled <- FALSE
[13:21:41.883]                       if (inherits(cond, "message")) {
[13:21:41.883]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.883]                         if (muffled) 
[13:21:41.883]                           invokeRestart("muffleMessage")
[13:21:41.883]                       }
[13:21:41.883]                       else if (inherits(cond, "warning")) {
[13:21:41.883]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.883]                         if (muffled) 
[13:21:41.883]                           invokeRestart("muffleWarning")
[13:21:41.883]                       }
[13:21:41.883]                       else if (inherits(cond, "condition")) {
[13:21:41.883]                         if (!is.null(pattern)) {
[13:21:41.883]                           computeRestarts <- base::computeRestarts
[13:21:41.883]                           grepl <- base::grepl
[13:21:41.883]                           restarts <- computeRestarts(cond)
[13:21:41.883]                           for (restart in restarts) {
[13:21:41.883]                             name <- restart$name
[13:21:41.883]                             if (is.null(name)) 
[13:21:41.883]                               next
[13:21:41.883]                             if (!grepl(pattern, name)) 
[13:21:41.883]                               next
[13:21:41.883]                             invokeRestart(restart)
[13:21:41.883]                             muffled <- TRUE
[13:21:41.883]                             break
[13:21:41.883]                           }
[13:21:41.883]                         }
[13:21:41.883]                       }
[13:21:41.883]                       invisible(muffled)
[13:21:41.883]                     }
[13:21:41.883]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.883]                   }
[13:21:41.883]                 }
[13:21:41.883]             }
[13:21:41.883]         }))
[13:21:41.883]     }, error = function(ex) {
[13:21:41.883]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:41.883]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.883]                 ...future.rng), started = ...future.startTime, 
[13:21:41.883]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:41.883]             version = "1.8"), class = "FutureResult")
[13:21:41.883]     }, finally = {
[13:21:41.883]         if (!identical(...future.workdir, getwd())) 
[13:21:41.883]             setwd(...future.workdir)
[13:21:41.883]         {
[13:21:41.883]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:41.883]                 ...future.oldOptions$nwarnings <- NULL
[13:21:41.883]             }
[13:21:41.883]             base::options(...future.oldOptions)
[13:21:41.883]             if (.Platform$OS.type == "windows") {
[13:21:41.883]                 old_names <- names(...future.oldEnvVars)
[13:21:41.883]                 envs <- base::Sys.getenv()
[13:21:41.883]                 names <- names(envs)
[13:21:41.883]                 common <- intersect(names, old_names)
[13:21:41.883]                 added <- setdiff(names, old_names)
[13:21:41.883]                 removed <- setdiff(old_names, names)
[13:21:41.883]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:41.883]                   envs[common]]
[13:21:41.883]                 NAMES <- toupper(changed)
[13:21:41.883]                 args <- list()
[13:21:41.883]                 for (kk in seq_along(NAMES)) {
[13:21:41.883]                   name <- changed[[kk]]
[13:21:41.883]                   NAME <- NAMES[[kk]]
[13:21:41.883]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.883]                     next
[13:21:41.883]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.883]                 }
[13:21:41.883]                 NAMES <- toupper(added)
[13:21:41.883]                 for (kk in seq_along(NAMES)) {
[13:21:41.883]                   name <- added[[kk]]
[13:21:41.883]                   NAME <- NAMES[[kk]]
[13:21:41.883]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.883]                     next
[13:21:41.883]                   args[[name]] <- ""
[13:21:41.883]                 }
[13:21:41.883]                 NAMES <- toupper(removed)
[13:21:41.883]                 for (kk in seq_along(NAMES)) {
[13:21:41.883]                   name <- removed[[kk]]
[13:21:41.883]                   NAME <- NAMES[[kk]]
[13:21:41.883]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.883]                     next
[13:21:41.883]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.883]                 }
[13:21:41.883]                 if (length(args) > 0) 
[13:21:41.883]                   base::do.call(base::Sys.setenv, args = args)
[13:21:41.883]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:41.883]             }
[13:21:41.883]             else {
[13:21:41.883]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:41.883]             }
[13:21:41.883]             {
[13:21:41.883]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:41.883]                   0L) {
[13:21:41.883]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:41.883]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:41.883]                   base::options(opts)
[13:21:41.883]                 }
[13:21:41.883]                 {
[13:21:41.883]                   {
[13:21:41.883]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:41.883]                     NULL
[13:21:41.883]                   }
[13:21:41.883]                   options(future.plan = NULL)
[13:21:41.883]                   if (is.na(NA_character_)) 
[13:21:41.883]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.883]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:41.883]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:41.883]                     envir = parent.frame()) 
[13:21:41.883]                   {
[13:21:41.883]                     default_workers <- missing(workers)
[13:21:41.883]                     if (is.function(workers)) 
[13:21:41.883]                       workers <- workers()
[13:21:41.883]                     workers <- structure(as.integer(workers), 
[13:21:41.883]                       class = class(workers))
[13:21:41.883]                     stop_if_not(is.finite(workers), workers >= 
[13:21:41.883]                       1L)
[13:21:41.883]                     if ((workers == 1L && !inherits(workers, 
[13:21:41.883]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:41.883]                       if (default_workers) 
[13:21:41.883]                         supportsMulticore(warn = TRUE)
[13:21:41.883]                       return(sequential(..., envir = envir))
[13:21:41.883]                     }
[13:21:41.883]                     oopts <- options(mc.cores = workers)
[13:21:41.883]                     on.exit(options(oopts))
[13:21:41.883]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:41.883]                       envir = envir)
[13:21:41.883]                     if (!future$lazy) 
[13:21:41.883]                       future <- run(future)
[13:21:41.883]                     invisible(future)
[13:21:41.883]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:41.883]                 }
[13:21:41.883]             }
[13:21:41.883]         }
[13:21:41.883]     })
[13:21:41.883]     if (TRUE) {
[13:21:41.883]         base::sink(type = "output", split = FALSE)
[13:21:41.883]         if (TRUE) {
[13:21:41.883]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:41.883]         }
[13:21:41.883]         else {
[13:21:41.883]             ...future.result["stdout"] <- base::list(NULL)
[13:21:41.883]         }
[13:21:41.883]         base::close(...future.stdout)
[13:21:41.883]         ...future.stdout <- NULL
[13:21:41.883]     }
[13:21:41.883]     ...future.result$conditions <- ...future.conditions
[13:21:41.883]     ...future.result$finished <- base::Sys.time()
[13:21:41.883]     ...future.result
[13:21:41.883] }
[13:21:41.886] requestCore(): workers = 2
[13:21:41.886] Poll #1 (0): usedCores() = 2, workers = 2
[13:21:41.900] MulticoreFuture started
[13:21:41.900] - Launch lazy future ... done
[13:21:41.901] run() for ‘MulticoreFuture’ ... done
[13:21:41.901] plan(): Setting new future strategy stack:
[13:21:41.902] getGlobalsAndPackages() ...
[13:21:41.902] List of future strategies:
[13:21:41.902] 1. sequential:
[13:21:41.902]    - args: function (..., envir = parent.frame())
[13:21:41.902]    - tweaked: FALSE
[13:21:41.902]    - call: NULL
[13:21:41.903] Searching for globals...
[13:21:41.903] plan(): nbrOfWorkers() = 1
[13:21:41.905] - globals found: [1] ‘{’
[13:21:41.905] Searching for globals ... DONE
[13:21:41.905] Resolving globals: FALSE
[13:21:41.906] plan(): Setting new future strategy stack:
[13:21:41.906] 
[13:21:41.906] 
[13:21:41.906] getGlobalsAndPackages() ... DONE
[13:21:41.906] List of future strategies:
[13:21:41.906] 1. multicore:
[13:21:41.906]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:41.906]    - tweaked: FALSE
[13:21:41.906]    - call: plan(strategy)
[13:21:41.907] run() for ‘Future’ ...
[13:21:41.907] - state: ‘created’
[13:21:41.908] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:41.913] plan(): nbrOfWorkers() = 2
[13:21:41.913] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:41.914] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:41.914]   - Field: ‘label’
[13:21:41.914]   - Field: ‘local’
[13:21:41.914]   - Field: ‘owner’
[13:21:41.914]   - Field: ‘envir’
[13:21:41.915]   - Field: ‘workers’
[13:21:41.915]   - Field: ‘packages’
[13:21:41.915]   - Field: ‘gc’
[13:21:41.915]   - Field: ‘job’
[13:21:41.915]   - Field: ‘conditions’
[13:21:41.915]   - Field: ‘expr’
[13:21:41.915]   - Field: ‘uuid’
[13:21:41.916]   - Field: ‘seed’
[13:21:41.916]   - Field: ‘version’
[13:21:41.916]   - Field: ‘result’
[13:21:41.916]   - Field: ‘asynchronous’
[13:21:41.916]   - Field: ‘calls’
[13:21:41.916]   - Field: ‘globals’
[13:21:41.916]   - Field: ‘stdout’
[13:21:41.917]   - Field: ‘earlySignal’
[13:21:41.917]   - Field: ‘lazy’
[13:21:41.917]   - Field: ‘state’
[13:21:41.917] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:41.917] - Launch lazy future ...
[13:21:41.918] Packages needed by the future expression (n = 0): <none>
[13:21:41.918] Packages needed by future strategies (n = 0): <none>
[13:21:41.919] {
[13:21:41.919]     {
[13:21:41.919]         {
[13:21:41.919]             ...future.startTime <- base::Sys.time()
[13:21:41.919]             {
[13:21:41.919]                 {
[13:21:41.919]                   {
[13:21:41.919]                     {
[13:21:41.919]                       base::local({
[13:21:41.919]                         has_future <- base::requireNamespace("future", 
[13:21:41.919]                           quietly = TRUE)
[13:21:41.919]                         if (has_future) {
[13:21:41.919]                           ns <- base::getNamespace("future")
[13:21:41.919]                           version <- ns[[".package"]][["version"]]
[13:21:41.919]                           if (is.null(version)) 
[13:21:41.919]                             version <- utils::packageVersion("future")
[13:21:41.919]                         }
[13:21:41.919]                         else {
[13:21:41.919]                           version <- NULL
[13:21:41.919]                         }
[13:21:41.919]                         if (!has_future || version < "1.8.0") {
[13:21:41.919]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:41.919]                             "", base::R.version$version.string), 
[13:21:41.919]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:41.919]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:41.919]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:41.919]                               "release", "version")], collapse = " "), 
[13:21:41.919]                             hostname = base::Sys.info()[["nodename"]])
[13:21:41.919]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:41.919]                             info)
[13:21:41.919]                           info <- base::paste(info, collapse = "; ")
[13:21:41.919]                           if (!has_future) {
[13:21:41.919]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:41.919]                               info)
[13:21:41.919]                           }
[13:21:41.919]                           else {
[13:21:41.919]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:41.919]                               info, version)
[13:21:41.919]                           }
[13:21:41.919]                           base::stop(msg)
[13:21:41.919]                         }
[13:21:41.919]                       })
[13:21:41.919]                     }
[13:21:41.919]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:41.919]                     base::options(mc.cores = 1L)
[13:21:41.919]                   }
[13:21:41.919]                   options(future.plan = NULL)
[13:21:41.919]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.919]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:41.919]                 }
[13:21:41.919]                 ...future.workdir <- getwd()
[13:21:41.919]             }
[13:21:41.919]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:41.919]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:41.919]         }
[13:21:41.919]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:41.919]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:41.919]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:41.919]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:41.919]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:41.919]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:41.919]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:41.919]             base::names(...future.oldOptions))
[13:21:41.919]     }
[13:21:41.919]     if (FALSE) {
[13:21:41.919]     }
[13:21:41.919]     else {
[13:21:41.919]         if (TRUE) {
[13:21:41.919]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:41.919]                 open = "w")
[13:21:41.919]         }
[13:21:41.919]         else {
[13:21:41.919]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:41.919]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:41.919]         }
[13:21:41.919]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:41.919]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:41.919]             base::sink(type = "output", split = FALSE)
[13:21:41.919]             base::close(...future.stdout)
[13:21:41.919]         }, add = TRUE)
[13:21:41.919]     }
[13:21:41.919]     ...future.frame <- base::sys.nframe()
[13:21:41.919]     ...future.conditions <- base::list()
[13:21:41.919]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:41.919]     if (FALSE) {
[13:21:41.919]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:41.919]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:41.919]     }
[13:21:41.919]     ...future.result <- base::tryCatch({
[13:21:41.919]         base::withCallingHandlers({
[13:21:41.919]             ...future.value <- base::withVisible(base::local({
[13:21:41.919]                 withCallingHandlers({
[13:21:41.919]                   {
[13:21:41.919]                     2
[13:21:41.919]                   }
[13:21:41.919]                 }, immediateCondition = function(cond) {
[13:21:41.919]                   save_rds <- function (object, pathname, ...) 
[13:21:41.919]                   {
[13:21:41.919]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:41.919]                     if (file_test("-f", pathname_tmp)) {
[13:21:41.919]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.919]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:41.919]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.919]                         fi_tmp[["mtime"]])
[13:21:41.919]                     }
[13:21:41.919]                     tryCatch({
[13:21:41.919]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:41.919]                     }, error = function(ex) {
[13:21:41.919]                       msg <- conditionMessage(ex)
[13:21:41.919]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.919]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:41.919]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.919]                         fi_tmp[["mtime"]], msg)
[13:21:41.919]                       ex$message <- msg
[13:21:41.919]                       stop(ex)
[13:21:41.919]                     })
[13:21:41.919]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:41.919]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:41.919]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:41.919]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.919]                       fi <- file.info(pathname)
[13:21:41.919]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:41.919]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.919]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:41.919]                         fi[["size"]], fi[["mtime"]])
[13:21:41.919]                       stop(msg)
[13:21:41.919]                     }
[13:21:41.919]                     invisible(pathname)
[13:21:41.919]                   }
[13:21:41.919]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:41.919]                     rootPath = tempdir()) 
[13:21:41.919]                   {
[13:21:41.919]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:41.919]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:41.919]                       tmpdir = path, fileext = ".rds")
[13:21:41.919]                     save_rds(obj, file)
[13:21:41.919]                   }
[13:21:41.919]                   saveImmediateCondition(cond, path = "/tmp/RtmpRIPAyw/.future/immediateConditions")
[13:21:41.919]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.919]                   {
[13:21:41.919]                     inherits <- base::inherits
[13:21:41.919]                     invokeRestart <- base::invokeRestart
[13:21:41.919]                     is.null <- base::is.null
[13:21:41.919]                     muffled <- FALSE
[13:21:41.919]                     if (inherits(cond, "message")) {
[13:21:41.919]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:41.919]                       if (muffled) 
[13:21:41.919]                         invokeRestart("muffleMessage")
[13:21:41.919]                     }
[13:21:41.919]                     else if (inherits(cond, "warning")) {
[13:21:41.919]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:41.919]                       if (muffled) 
[13:21:41.919]                         invokeRestart("muffleWarning")
[13:21:41.919]                     }
[13:21:41.919]                     else if (inherits(cond, "condition")) {
[13:21:41.919]                       if (!is.null(pattern)) {
[13:21:41.919]                         computeRestarts <- base::computeRestarts
[13:21:41.919]                         grepl <- base::grepl
[13:21:41.919]                         restarts <- computeRestarts(cond)
[13:21:41.919]                         for (restart in restarts) {
[13:21:41.919]                           name <- restart$name
[13:21:41.919]                           if (is.null(name)) 
[13:21:41.919]                             next
[13:21:41.919]                           if (!grepl(pattern, name)) 
[13:21:41.919]                             next
[13:21:41.919]                           invokeRestart(restart)
[13:21:41.919]                           muffled <- TRUE
[13:21:41.919]                           break
[13:21:41.919]                         }
[13:21:41.919]                       }
[13:21:41.919]                     }
[13:21:41.919]                     invisible(muffled)
[13:21:41.919]                   }
[13:21:41.919]                   muffleCondition(cond)
[13:21:41.919]                 })
[13:21:41.919]             }))
[13:21:41.919]             future::FutureResult(value = ...future.value$value, 
[13:21:41.919]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.919]                   ...future.rng), globalenv = if (FALSE) 
[13:21:41.919]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:41.919]                     ...future.globalenv.names))
[13:21:41.919]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:41.919]         }, condition = base::local({
[13:21:41.919]             c <- base::c
[13:21:41.919]             inherits <- base::inherits
[13:21:41.919]             invokeRestart <- base::invokeRestart
[13:21:41.919]             length <- base::length
[13:21:41.919]             list <- base::list
[13:21:41.919]             seq.int <- base::seq.int
[13:21:41.919]             signalCondition <- base::signalCondition
[13:21:41.919]             sys.calls <- base::sys.calls
[13:21:41.919]             `[[` <- base::`[[`
[13:21:41.919]             `+` <- base::`+`
[13:21:41.919]             `<<-` <- base::`<<-`
[13:21:41.919]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:41.919]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:41.919]                   3L)]
[13:21:41.919]             }
[13:21:41.919]             function(cond) {
[13:21:41.919]                 is_error <- inherits(cond, "error")
[13:21:41.919]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:41.919]                   NULL)
[13:21:41.919]                 if (is_error) {
[13:21:41.919]                   sessionInformation <- function() {
[13:21:41.919]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:41.919]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:41.919]                       search = base::search(), system = base::Sys.info())
[13:21:41.919]                   }
[13:21:41.919]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.919]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:41.919]                     cond$call), session = sessionInformation(), 
[13:21:41.919]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:41.919]                   signalCondition(cond)
[13:21:41.919]                 }
[13:21:41.919]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:41.919]                 "immediateCondition"))) {
[13:21:41.919]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:41.919]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.919]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:41.919]                   if (TRUE && !signal) {
[13:21:41.919]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.919]                     {
[13:21:41.919]                       inherits <- base::inherits
[13:21:41.919]                       invokeRestart <- base::invokeRestart
[13:21:41.919]                       is.null <- base::is.null
[13:21:41.919]                       muffled <- FALSE
[13:21:41.919]                       if (inherits(cond, "message")) {
[13:21:41.919]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.919]                         if (muffled) 
[13:21:41.919]                           invokeRestart("muffleMessage")
[13:21:41.919]                       }
[13:21:41.919]                       else if (inherits(cond, "warning")) {
[13:21:41.919]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.919]                         if (muffled) 
[13:21:41.919]                           invokeRestart("muffleWarning")
[13:21:41.919]                       }
[13:21:41.919]                       else if (inherits(cond, "condition")) {
[13:21:41.919]                         if (!is.null(pattern)) {
[13:21:41.919]                           computeRestarts <- base::computeRestarts
[13:21:41.919]                           grepl <- base::grepl
[13:21:41.919]                           restarts <- computeRestarts(cond)
[13:21:41.919]                           for (restart in restarts) {
[13:21:41.919]                             name <- restart$name
[13:21:41.919]                             if (is.null(name)) 
[13:21:41.919]                               next
[13:21:41.919]                             if (!grepl(pattern, name)) 
[13:21:41.919]                               next
[13:21:41.919]                             invokeRestart(restart)
[13:21:41.919]                             muffled <- TRUE
[13:21:41.919]                             break
[13:21:41.919]                           }
[13:21:41.919]                         }
[13:21:41.919]                       }
[13:21:41.919]                       invisible(muffled)
[13:21:41.919]                     }
[13:21:41.919]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.919]                   }
[13:21:41.919]                 }
[13:21:41.919]                 else {
[13:21:41.919]                   if (TRUE) {
[13:21:41.919]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.919]                     {
[13:21:41.919]                       inherits <- base::inherits
[13:21:41.919]                       invokeRestart <- base::invokeRestart
[13:21:41.919]                       is.null <- base::is.null
[13:21:41.919]                       muffled <- FALSE
[13:21:41.919]                       if (inherits(cond, "message")) {
[13:21:41.919]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.919]                         if (muffled) 
[13:21:41.919]                           invokeRestart("muffleMessage")
[13:21:41.919]                       }
[13:21:41.919]                       else if (inherits(cond, "warning")) {
[13:21:41.919]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.919]                         if (muffled) 
[13:21:41.919]                           invokeRestart("muffleWarning")
[13:21:41.919]                       }
[13:21:41.919]                       else if (inherits(cond, "condition")) {
[13:21:41.919]                         if (!is.null(pattern)) {
[13:21:41.919]                           computeRestarts <- base::computeRestarts
[13:21:41.919]                           grepl <- base::grepl
[13:21:41.919]                           restarts <- computeRestarts(cond)
[13:21:41.919]                           for (restart in restarts) {
[13:21:41.919]                             name <- restart$name
[13:21:41.919]                             if (is.null(name)) 
[13:21:41.919]                               next
[13:21:41.919]                             if (!grepl(pattern, name)) 
[13:21:41.919]                               next
[13:21:41.919]                             invokeRestart(restart)
[13:21:41.919]                             muffled <- TRUE
[13:21:41.919]                             break
[13:21:41.919]                           }
[13:21:41.919]                         }
[13:21:41.919]                       }
[13:21:41.919]                       invisible(muffled)
[13:21:41.919]                     }
[13:21:41.919]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.919]                   }
[13:21:41.919]                 }
[13:21:41.919]             }
[13:21:41.919]         }))
[13:21:41.919]     }, error = function(ex) {
[13:21:41.919]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:41.919]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.919]                 ...future.rng), started = ...future.startTime, 
[13:21:41.919]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:41.919]             version = "1.8"), class = "FutureResult")
[13:21:41.919]     }, finally = {
[13:21:41.919]         if (!identical(...future.workdir, getwd())) 
[13:21:41.919]             setwd(...future.workdir)
[13:21:41.919]         {
[13:21:41.919]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:41.919]                 ...future.oldOptions$nwarnings <- NULL
[13:21:41.919]             }
[13:21:41.919]             base::options(...future.oldOptions)
[13:21:41.919]             if (.Platform$OS.type == "windows") {
[13:21:41.919]                 old_names <- names(...future.oldEnvVars)
[13:21:41.919]                 envs <- base::Sys.getenv()
[13:21:41.919]                 names <- names(envs)
[13:21:41.919]                 common <- intersect(names, old_names)
[13:21:41.919]                 added <- setdiff(names, old_names)
[13:21:41.919]                 removed <- setdiff(old_names, names)
[13:21:41.919]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:41.919]                   envs[common]]
[13:21:41.919]                 NAMES <- toupper(changed)
[13:21:41.919]                 args <- list()
[13:21:41.919]                 for (kk in seq_along(NAMES)) {
[13:21:41.919]                   name <- changed[[kk]]
[13:21:41.919]                   NAME <- NAMES[[kk]]
[13:21:41.919]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.919]                     next
[13:21:41.919]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.919]                 }
[13:21:41.919]                 NAMES <- toupper(added)
[13:21:41.919]                 for (kk in seq_along(NAMES)) {
[13:21:41.919]                   name <- added[[kk]]
[13:21:41.919]                   NAME <- NAMES[[kk]]
[13:21:41.919]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.919]                     next
[13:21:41.919]                   args[[name]] <- ""
[13:21:41.919]                 }
[13:21:41.919]                 NAMES <- toupper(removed)
[13:21:41.919]                 for (kk in seq_along(NAMES)) {
[13:21:41.919]                   name <- removed[[kk]]
[13:21:41.919]                   NAME <- NAMES[[kk]]
[13:21:41.919]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.919]                     next
[13:21:41.919]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.919]                 }
[13:21:41.919]                 if (length(args) > 0) 
[13:21:41.919]                   base::do.call(base::Sys.setenv, args = args)
[13:21:41.919]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:41.919]             }
[13:21:41.919]             else {
[13:21:41.919]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:41.919]             }
[13:21:41.919]             {
[13:21:41.919]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:41.919]                   0L) {
[13:21:41.919]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:41.919]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:41.919]                   base::options(opts)
[13:21:41.919]                 }
[13:21:41.919]                 {
[13:21:41.919]                   {
[13:21:41.919]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:41.919]                     NULL
[13:21:41.919]                   }
[13:21:41.919]                   options(future.plan = NULL)
[13:21:41.919]                   if (is.na(NA_character_)) 
[13:21:41.919]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.919]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:41.919]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:41.919]                     envir = parent.frame()) 
[13:21:41.919]                   {
[13:21:41.919]                     default_workers <- missing(workers)
[13:21:41.919]                     if (is.function(workers)) 
[13:21:41.919]                       workers <- workers()
[13:21:41.919]                     workers <- structure(as.integer(workers), 
[13:21:41.919]                       class = class(workers))
[13:21:41.919]                     stop_if_not(is.finite(workers), workers >= 
[13:21:41.919]                       1L)
[13:21:41.919]                     if ((workers == 1L && !inherits(workers, 
[13:21:41.919]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:41.919]                       if (default_workers) 
[13:21:41.919]                         supportsMulticore(warn = TRUE)
[13:21:41.919]                       return(sequential(..., envir = envir))
[13:21:41.919]                     }
[13:21:41.919]                     oopts <- options(mc.cores = workers)
[13:21:41.919]                     on.exit(options(oopts))
[13:21:41.919]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:41.919]                       envir = envir)
[13:21:41.919]                     if (!future$lazy) 
[13:21:41.919]                       future <- run(future)
[13:21:41.919]                     invisible(future)
[13:21:41.919]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:41.919]                 }
[13:21:41.919]             }
[13:21:41.919]         }
[13:21:41.919]     })
[13:21:41.919]     if (TRUE) {
[13:21:41.919]         base::sink(type = "output", split = FALSE)
[13:21:41.919]         if (TRUE) {
[13:21:41.919]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:41.919]         }
[13:21:41.919]         else {
[13:21:41.919]             ...future.result["stdout"] <- base::list(NULL)
[13:21:41.919]         }
[13:21:41.919]         base::close(...future.stdout)
[13:21:41.919]         ...future.stdout <- NULL
[13:21:41.919]     }
[13:21:41.919]     ...future.result$conditions <- ...future.conditions
[13:21:41.919]     ...future.result$finished <- base::Sys.time()
[13:21:41.919]     ...future.result
[13:21:41.919] }
[13:21:41.922] requestCore(): workers = 2
[13:21:41.923] Poll #1 (0): usedCores() = 2, workers = 2
[13:21:41.937] MulticoreFuture started
[13:21:41.937] - Launch lazy future ... done
[13:21:41.937] run() for ‘MulticoreFuture’ ... done
[13:21:41.938] plan(): Setting new future strategy stack:
[13:21:41.938] List of future strategies:
[13:21:41.938] 1. sequential:
[13:21:41.938]    - args: function (..., envir = parent.frame())
[13:21:41.938]    - tweaked: FALSE
[13:21:41.938]    - call: NULL
[13:21:41.939] resolve() on list environment ...
[13:21:41.940]  recursive: 0
[13:21:41.940] plan(): nbrOfWorkers() = 1
[13:21:41.941]  length: 3
[13:21:41.941]  elements: ‘a’, ‘b’, ‘c’
[13:21:41.942] Future #1
[13:21:41.942]  length: 2 (resolved future 1)
[13:21:41.943] plan(): Setting new future strategy stack:
[13:21:41.943] List of future strategies:
[13:21:41.943] 1. multicore:
[13:21:41.943]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:41.943]    - tweaked: FALSE
[13:21:41.943]    - call: plan(strategy)
[13:21:41.948] plan(): nbrOfWorkers() = 2
[13:21:41.948] Future #2
[13:21:41.949]  length: 1 (resolved future 2)
[13:21:41.949]  length: 0 (resolved future 3)
[13:21:41.949] resolve() on list environment ... DONE
[13:21:41.950] getGlobalsAndPackages() ...
[13:21:41.950] Searching for globals...
[13:21:41.951] - globals found: [1] ‘{’
[13:21:41.951] Searching for globals ... DONE
[13:21:41.952] Resolving globals: FALSE
[13:21:41.952] 
[13:21:41.952] 
[13:21:41.952] getGlobalsAndPackages() ... DONE
[13:21:41.953] run() for ‘Future’ ...
[13:21:41.953] - state: ‘created’
[13:21:41.953] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:41.958] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:41.958] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:41.958]   - Field: ‘label’
[13:21:41.959]   - Field: ‘local’
[13:21:41.959]   - Field: ‘owner’
[13:21:41.959]   - Field: ‘envir’
[13:21:41.959]   - Field: ‘workers’
[13:21:41.959]   - Field: ‘packages’
[13:21:41.959]   - Field: ‘gc’
[13:21:41.960]   - Field: ‘job’
[13:21:41.960]   - Field: ‘conditions’
[13:21:41.964]   - Field: ‘expr’
[13:21:41.964]   - Field: ‘uuid’
[13:21:41.965]   - Field: ‘seed’
[13:21:41.965]   - Field: ‘version’
[13:21:41.965]   - Field: ‘result’
[13:21:41.966]   - Field: ‘asynchronous’
[13:21:41.966]   - Field: ‘calls’
[13:21:41.966]   - Field: ‘globals’
[13:21:41.967]   - Field: ‘stdout’
[13:21:41.967]   - Field: ‘earlySignal’
[13:21:41.967]   - Field: ‘lazy’
[13:21:41.967]   - Field: ‘state’
[13:21:41.968] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:41.968] - Launch lazy future ...
[13:21:41.968] Packages needed by the future expression (n = 0): <none>
[13:21:41.969] Packages needed by future strategies (n = 0): <none>
[13:21:41.969] {
[13:21:41.969]     {
[13:21:41.969]         {
[13:21:41.969]             ...future.startTime <- base::Sys.time()
[13:21:41.969]             {
[13:21:41.969]                 {
[13:21:41.969]                   {
[13:21:41.969]                     {
[13:21:41.969]                       base::local({
[13:21:41.969]                         has_future <- base::requireNamespace("future", 
[13:21:41.969]                           quietly = TRUE)
[13:21:41.969]                         if (has_future) {
[13:21:41.969]                           ns <- base::getNamespace("future")
[13:21:41.969]                           version <- ns[[".package"]][["version"]]
[13:21:41.969]                           if (is.null(version)) 
[13:21:41.969]                             version <- utils::packageVersion("future")
[13:21:41.969]                         }
[13:21:41.969]                         else {
[13:21:41.969]                           version <- NULL
[13:21:41.969]                         }
[13:21:41.969]                         if (!has_future || version < "1.8.0") {
[13:21:41.969]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:41.969]                             "", base::R.version$version.string), 
[13:21:41.969]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:41.969]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:41.969]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:41.969]                               "release", "version")], collapse = " "), 
[13:21:41.969]                             hostname = base::Sys.info()[["nodename"]])
[13:21:41.969]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:41.969]                             info)
[13:21:41.969]                           info <- base::paste(info, collapse = "; ")
[13:21:41.969]                           if (!has_future) {
[13:21:41.969]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:41.969]                               info)
[13:21:41.969]                           }
[13:21:41.969]                           else {
[13:21:41.969]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:41.969]                               info, version)
[13:21:41.969]                           }
[13:21:41.969]                           base::stop(msg)
[13:21:41.969]                         }
[13:21:41.969]                       })
[13:21:41.969]                     }
[13:21:41.969]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:41.969]                     base::options(mc.cores = 1L)
[13:21:41.969]                   }
[13:21:41.969]                   options(future.plan = NULL)
[13:21:41.969]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.969]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:41.969]                 }
[13:21:41.969]                 ...future.workdir <- getwd()
[13:21:41.969]             }
[13:21:41.969]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:41.969]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:41.969]         }
[13:21:41.969]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:41.969]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:41.969]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:41.969]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:41.969]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:41.969]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:41.969]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:41.969]             base::names(...future.oldOptions))
[13:21:41.969]     }
[13:21:41.969]     if (FALSE) {
[13:21:41.969]     }
[13:21:41.969]     else {
[13:21:41.969]         if (TRUE) {
[13:21:41.969]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:41.969]                 open = "w")
[13:21:41.969]         }
[13:21:41.969]         else {
[13:21:41.969]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:41.969]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:41.969]         }
[13:21:41.969]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:41.969]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:41.969]             base::sink(type = "output", split = FALSE)
[13:21:41.969]             base::close(...future.stdout)
[13:21:41.969]         }, add = TRUE)
[13:21:41.969]     }
[13:21:41.969]     ...future.frame <- base::sys.nframe()
[13:21:41.969]     ...future.conditions <- base::list()
[13:21:41.969]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:41.969]     if (FALSE) {
[13:21:41.969]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:41.969]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:41.969]     }
[13:21:41.969]     ...future.result <- base::tryCatch({
[13:21:41.969]         base::withCallingHandlers({
[13:21:41.969]             ...future.value <- base::withVisible(base::local({
[13:21:41.969]                 withCallingHandlers({
[13:21:41.969]                   {
[13:21:41.969]                     1
[13:21:41.969]                   }
[13:21:41.969]                 }, immediateCondition = function(cond) {
[13:21:41.969]                   save_rds <- function (object, pathname, ...) 
[13:21:41.969]                   {
[13:21:41.969]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:41.969]                     if (file_test("-f", pathname_tmp)) {
[13:21:41.969]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.969]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:41.969]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.969]                         fi_tmp[["mtime"]])
[13:21:41.969]                     }
[13:21:41.969]                     tryCatch({
[13:21:41.969]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:41.969]                     }, error = function(ex) {
[13:21:41.969]                       msg <- conditionMessage(ex)
[13:21:41.969]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.969]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:41.969]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.969]                         fi_tmp[["mtime"]], msg)
[13:21:41.969]                       ex$message <- msg
[13:21:41.969]                       stop(ex)
[13:21:41.969]                     })
[13:21:41.969]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:41.969]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:41.969]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:41.969]                       fi_tmp <- file.info(pathname_tmp)
[13:21:41.969]                       fi <- file.info(pathname)
[13:21:41.969]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:41.969]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:41.969]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:41.969]                         fi[["size"]], fi[["mtime"]])
[13:21:41.969]                       stop(msg)
[13:21:41.969]                     }
[13:21:41.969]                     invisible(pathname)
[13:21:41.969]                   }
[13:21:41.969]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:41.969]                     rootPath = tempdir()) 
[13:21:41.969]                   {
[13:21:41.969]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:41.969]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:41.969]                       tmpdir = path, fileext = ".rds")
[13:21:41.969]                     save_rds(obj, file)
[13:21:41.969]                   }
[13:21:41.969]                   saveImmediateCondition(cond, path = "/tmp/RtmpRIPAyw/.future/immediateConditions")
[13:21:41.969]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.969]                   {
[13:21:41.969]                     inherits <- base::inherits
[13:21:41.969]                     invokeRestart <- base::invokeRestart
[13:21:41.969]                     is.null <- base::is.null
[13:21:41.969]                     muffled <- FALSE
[13:21:41.969]                     if (inherits(cond, "message")) {
[13:21:41.969]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:41.969]                       if (muffled) 
[13:21:41.969]                         invokeRestart("muffleMessage")
[13:21:41.969]                     }
[13:21:41.969]                     else if (inherits(cond, "warning")) {
[13:21:41.969]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:41.969]                       if (muffled) 
[13:21:41.969]                         invokeRestart("muffleWarning")
[13:21:41.969]                     }
[13:21:41.969]                     else if (inherits(cond, "condition")) {
[13:21:41.969]                       if (!is.null(pattern)) {
[13:21:41.969]                         computeRestarts <- base::computeRestarts
[13:21:41.969]                         grepl <- base::grepl
[13:21:41.969]                         restarts <- computeRestarts(cond)
[13:21:41.969]                         for (restart in restarts) {
[13:21:41.969]                           name <- restart$name
[13:21:41.969]                           if (is.null(name)) 
[13:21:41.969]                             next
[13:21:41.969]                           if (!grepl(pattern, name)) 
[13:21:41.969]                             next
[13:21:41.969]                           invokeRestart(restart)
[13:21:41.969]                           muffled <- TRUE
[13:21:41.969]                           break
[13:21:41.969]                         }
[13:21:41.969]                       }
[13:21:41.969]                     }
[13:21:41.969]                     invisible(muffled)
[13:21:41.969]                   }
[13:21:41.969]                   muffleCondition(cond)
[13:21:41.969]                 })
[13:21:41.969]             }))
[13:21:41.969]             future::FutureResult(value = ...future.value$value, 
[13:21:41.969]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.969]                   ...future.rng), globalenv = if (FALSE) 
[13:21:41.969]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:41.969]                     ...future.globalenv.names))
[13:21:41.969]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:41.969]         }, condition = base::local({
[13:21:41.969]             c <- base::c
[13:21:41.969]             inherits <- base::inherits
[13:21:41.969]             invokeRestart <- base::invokeRestart
[13:21:41.969]             length <- base::length
[13:21:41.969]             list <- base::list
[13:21:41.969]             seq.int <- base::seq.int
[13:21:41.969]             signalCondition <- base::signalCondition
[13:21:41.969]             sys.calls <- base::sys.calls
[13:21:41.969]             `[[` <- base::`[[`
[13:21:41.969]             `+` <- base::`+`
[13:21:41.969]             `<<-` <- base::`<<-`
[13:21:41.969]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:41.969]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:41.969]                   3L)]
[13:21:41.969]             }
[13:21:41.969]             function(cond) {
[13:21:41.969]                 is_error <- inherits(cond, "error")
[13:21:41.969]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:41.969]                   NULL)
[13:21:41.969]                 if (is_error) {
[13:21:41.969]                   sessionInformation <- function() {
[13:21:41.969]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:41.969]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:41.969]                       search = base::search(), system = base::Sys.info())
[13:21:41.969]                   }
[13:21:41.969]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.969]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:41.969]                     cond$call), session = sessionInformation(), 
[13:21:41.969]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:41.969]                   signalCondition(cond)
[13:21:41.969]                 }
[13:21:41.969]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:41.969]                 "immediateCondition"))) {
[13:21:41.969]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:41.969]                   ...future.conditions[[length(...future.conditions) + 
[13:21:41.969]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:41.969]                   if (TRUE && !signal) {
[13:21:41.969]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.969]                     {
[13:21:41.969]                       inherits <- base::inherits
[13:21:41.969]                       invokeRestart <- base::invokeRestart
[13:21:41.969]                       is.null <- base::is.null
[13:21:41.969]                       muffled <- FALSE
[13:21:41.969]                       if (inherits(cond, "message")) {
[13:21:41.969]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.969]                         if (muffled) 
[13:21:41.969]                           invokeRestart("muffleMessage")
[13:21:41.969]                       }
[13:21:41.969]                       else if (inherits(cond, "warning")) {
[13:21:41.969]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.969]                         if (muffled) 
[13:21:41.969]                           invokeRestart("muffleWarning")
[13:21:41.969]                       }
[13:21:41.969]                       else if (inherits(cond, "condition")) {
[13:21:41.969]                         if (!is.null(pattern)) {
[13:21:41.969]                           computeRestarts <- base::computeRestarts
[13:21:41.969]                           grepl <- base::grepl
[13:21:41.969]                           restarts <- computeRestarts(cond)
[13:21:41.969]                           for (restart in restarts) {
[13:21:41.969]                             name <- restart$name
[13:21:41.969]                             if (is.null(name)) 
[13:21:41.969]                               next
[13:21:41.969]                             if (!grepl(pattern, name)) 
[13:21:41.969]                               next
[13:21:41.969]                             invokeRestart(restart)
[13:21:41.969]                             muffled <- TRUE
[13:21:41.969]                             break
[13:21:41.969]                           }
[13:21:41.969]                         }
[13:21:41.969]                       }
[13:21:41.969]                       invisible(muffled)
[13:21:41.969]                     }
[13:21:41.969]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.969]                   }
[13:21:41.969]                 }
[13:21:41.969]                 else {
[13:21:41.969]                   if (TRUE) {
[13:21:41.969]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:41.969]                     {
[13:21:41.969]                       inherits <- base::inherits
[13:21:41.969]                       invokeRestart <- base::invokeRestart
[13:21:41.969]                       is.null <- base::is.null
[13:21:41.969]                       muffled <- FALSE
[13:21:41.969]                       if (inherits(cond, "message")) {
[13:21:41.969]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:41.969]                         if (muffled) 
[13:21:41.969]                           invokeRestart("muffleMessage")
[13:21:41.969]                       }
[13:21:41.969]                       else if (inherits(cond, "warning")) {
[13:21:41.969]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:41.969]                         if (muffled) 
[13:21:41.969]                           invokeRestart("muffleWarning")
[13:21:41.969]                       }
[13:21:41.969]                       else if (inherits(cond, "condition")) {
[13:21:41.969]                         if (!is.null(pattern)) {
[13:21:41.969]                           computeRestarts <- base::computeRestarts
[13:21:41.969]                           grepl <- base::grepl
[13:21:41.969]                           restarts <- computeRestarts(cond)
[13:21:41.969]                           for (restart in restarts) {
[13:21:41.969]                             name <- restart$name
[13:21:41.969]                             if (is.null(name)) 
[13:21:41.969]                               next
[13:21:41.969]                             if (!grepl(pattern, name)) 
[13:21:41.969]                               next
[13:21:41.969]                             invokeRestart(restart)
[13:21:41.969]                             muffled <- TRUE
[13:21:41.969]                             break
[13:21:41.969]                           }
[13:21:41.969]                         }
[13:21:41.969]                       }
[13:21:41.969]                       invisible(muffled)
[13:21:41.969]                     }
[13:21:41.969]                     muffleCondition(cond, pattern = "^muffle")
[13:21:41.969]                   }
[13:21:41.969]                 }
[13:21:41.969]             }
[13:21:41.969]         }))
[13:21:41.969]     }, error = function(ex) {
[13:21:41.969]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:41.969]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:41.969]                 ...future.rng), started = ...future.startTime, 
[13:21:41.969]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:41.969]             version = "1.8"), class = "FutureResult")
[13:21:41.969]     }, finally = {
[13:21:41.969]         if (!identical(...future.workdir, getwd())) 
[13:21:41.969]             setwd(...future.workdir)
[13:21:41.969]         {
[13:21:41.969]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:41.969]                 ...future.oldOptions$nwarnings <- NULL
[13:21:41.969]             }
[13:21:41.969]             base::options(...future.oldOptions)
[13:21:41.969]             if (.Platform$OS.type == "windows") {
[13:21:41.969]                 old_names <- names(...future.oldEnvVars)
[13:21:41.969]                 envs <- base::Sys.getenv()
[13:21:41.969]                 names <- names(envs)
[13:21:41.969]                 common <- intersect(names, old_names)
[13:21:41.969]                 added <- setdiff(names, old_names)
[13:21:41.969]                 removed <- setdiff(old_names, names)
[13:21:41.969]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:41.969]                   envs[common]]
[13:21:41.969]                 NAMES <- toupper(changed)
[13:21:41.969]                 args <- list()
[13:21:41.969]                 for (kk in seq_along(NAMES)) {
[13:21:41.969]                   name <- changed[[kk]]
[13:21:41.969]                   NAME <- NAMES[[kk]]
[13:21:41.969]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.969]                     next
[13:21:41.969]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.969]                 }
[13:21:41.969]                 NAMES <- toupper(added)
[13:21:41.969]                 for (kk in seq_along(NAMES)) {
[13:21:41.969]                   name <- added[[kk]]
[13:21:41.969]                   NAME <- NAMES[[kk]]
[13:21:41.969]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.969]                     next
[13:21:41.969]                   args[[name]] <- ""
[13:21:41.969]                 }
[13:21:41.969]                 NAMES <- toupper(removed)
[13:21:41.969]                 for (kk in seq_along(NAMES)) {
[13:21:41.969]                   name <- removed[[kk]]
[13:21:41.969]                   NAME <- NAMES[[kk]]
[13:21:41.969]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:41.969]                     next
[13:21:41.969]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:41.969]                 }
[13:21:41.969]                 if (length(args) > 0) 
[13:21:41.969]                   base::do.call(base::Sys.setenv, args = args)
[13:21:41.969]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:41.969]             }
[13:21:41.969]             else {
[13:21:41.969]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:41.969]             }
[13:21:41.969]             {
[13:21:41.969]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:41.969]                   0L) {
[13:21:41.969]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:41.969]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:41.969]                   base::options(opts)
[13:21:41.969]                 }
[13:21:41.969]                 {
[13:21:41.969]                   {
[13:21:41.969]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:41.969]                     NULL
[13:21:41.969]                   }
[13:21:41.969]                   options(future.plan = NULL)
[13:21:41.969]                   if (is.na(NA_character_)) 
[13:21:41.969]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:41.969]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:41.969]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:41.969]                     envir = parent.frame()) 
[13:21:41.969]                   {
[13:21:41.969]                     default_workers <- missing(workers)
[13:21:41.969]                     if (is.function(workers)) 
[13:21:41.969]                       workers <- workers()
[13:21:41.969]                     workers <- structure(as.integer(workers), 
[13:21:41.969]                       class = class(workers))
[13:21:41.969]                     stop_if_not(is.finite(workers), workers >= 
[13:21:41.969]                       1L)
[13:21:41.969]                     if ((workers == 1L && !inherits(workers, 
[13:21:41.969]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:41.969]                       if (default_workers) 
[13:21:41.969]                         supportsMulticore(warn = TRUE)
[13:21:41.969]                       return(sequential(..., envir = envir))
[13:21:41.969]                     }
[13:21:41.969]                     oopts <- options(mc.cores = workers)
[13:21:41.969]                     on.exit(options(oopts))
[13:21:41.969]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:41.969]                       envir = envir)
[13:21:41.969]                     if (!future$lazy) 
[13:21:41.969]                       future <- run(future)
[13:21:41.969]                     invisible(future)
[13:21:41.969]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:41.969]                 }
[13:21:41.969]             }
[13:21:41.969]         }
[13:21:41.969]     })
[13:21:41.969]     if (TRUE) {
[13:21:41.969]         base::sink(type = "output", split = FALSE)
[13:21:41.969]         if (TRUE) {
[13:21:41.969]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:41.969]         }
[13:21:41.969]         else {
[13:21:41.969]             ...future.result["stdout"] <- base::list(NULL)
[13:21:41.969]         }
[13:21:41.969]         base::close(...future.stdout)
[13:21:41.969]         ...future.stdout <- NULL
[13:21:41.969]     }
[13:21:41.969]     ...future.result$conditions <- ...future.conditions
[13:21:41.969]     ...future.result$finished <- base::Sys.time()
[13:21:41.969]     ...future.result
[13:21:41.969] }
[13:21:41.972] requestCore(): workers = 2
[13:21:41.973] Poll #1 (0): usedCores() = 2, workers = 2
[13:21:41.987] MulticoreFuture started
[13:21:41.988] - Launch lazy future ... done
[13:21:41.988] run() for ‘MulticoreFuture’ ... done
[13:21:41.989] plan(): Setting new future strategy stack:
[13:21:41.989] getGlobalsAndPackages() ...
[13:21:41.989] List of future strategies:
[13:21:41.989] 1. sequential:
[13:21:41.989]    - args: function (..., envir = parent.frame())
[13:21:41.989]    - tweaked: FALSE
[13:21:41.989]    - call: NULL
[13:21:41.990] Searching for globals...
[13:21:41.990] plan(): nbrOfWorkers() = 1
[13:21:41.992] plan(): Setting new future strategy stack:
[13:21:41.993] - globals found: [2] ‘{’, ‘Sys.sleep’
[13:21:41.993] Searching for globals ... DONE
[13:21:41.993] Resolving globals: FALSE
[13:21:41.993] List of future strategies:
[13:21:41.993] 1. multicore:
[13:21:41.993]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:41.993]    - tweaked: FALSE
[13:21:41.993]    - call: plan(strategy)
[13:21:41.994] 
[13:21:41.994] 
[13:21:41.994] getGlobalsAndPackages() ... DONE
[13:21:41.995] run() for ‘Future’ ...
[13:21:41.995] - state: ‘created’
[13:21:41.995] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:41.998] plan(): nbrOfWorkers() = 2
[13:21:42.000] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:42.000] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:42.000]   - Field: ‘label’
[13:21:42.000]   - Field: ‘local’
[13:21:42.001]   - Field: ‘owner’
[13:21:42.001]   - Field: ‘envir’
[13:21:42.001]   - Field: ‘workers’
[13:21:42.001]   - Field: ‘packages’
[13:21:42.001]   - Field: ‘gc’
[13:21:42.001]   - Field: ‘job’
[13:21:42.001]   - Field: ‘conditions’
[13:21:42.002]   - Field: ‘expr’
[13:21:42.002]   - Field: ‘uuid’
[13:21:42.002]   - Field: ‘seed’
[13:21:42.002]   - Field: ‘version’
[13:21:42.002]   - Field: ‘result’
[13:21:42.002]   - Field: ‘asynchronous’
[13:21:42.002]   - Field: ‘calls’
[13:21:42.003]   - Field: ‘globals’
[13:21:42.003]   - Field: ‘stdout’
[13:21:42.003]   - Field: ‘earlySignal’
[13:21:42.003]   - Field: ‘lazy’
[13:21:42.003]   - Field: ‘state’
[13:21:42.003] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:42.004] - Launch lazy future ...
[13:21:42.004] Packages needed by the future expression (n = 0): <none>
[13:21:42.004] Packages needed by future strategies (n = 0): <none>
[13:21:42.005] {
[13:21:42.005]     {
[13:21:42.005]         {
[13:21:42.005]             ...future.startTime <- base::Sys.time()
[13:21:42.005]             {
[13:21:42.005]                 {
[13:21:42.005]                   {
[13:21:42.005]                     {
[13:21:42.005]                       base::local({
[13:21:42.005]                         has_future <- base::requireNamespace("future", 
[13:21:42.005]                           quietly = TRUE)
[13:21:42.005]                         if (has_future) {
[13:21:42.005]                           ns <- base::getNamespace("future")
[13:21:42.005]                           version <- ns[[".package"]][["version"]]
[13:21:42.005]                           if (is.null(version)) 
[13:21:42.005]                             version <- utils::packageVersion("future")
[13:21:42.005]                         }
[13:21:42.005]                         else {
[13:21:42.005]                           version <- NULL
[13:21:42.005]                         }
[13:21:42.005]                         if (!has_future || version < "1.8.0") {
[13:21:42.005]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:42.005]                             "", base::R.version$version.string), 
[13:21:42.005]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:42.005]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:42.005]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:42.005]                               "release", "version")], collapse = " "), 
[13:21:42.005]                             hostname = base::Sys.info()[["nodename"]])
[13:21:42.005]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:42.005]                             info)
[13:21:42.005]                           info <- base::paste(info, collapse = "; ")
[13:21:42.005]                           if (!has_future) {
[13:21:42.005]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:42.005]                               info)
[13:21:42.005]                           }
[13:21:42.005]                           else {
[13:21:42.005]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:42.005]                               info, version)
[13:21:42.005]                           }
[13:21:42.005]                           base::stop(msg)
[13:21:42.005]                         }
[13:21:42.005]                       })
[13:21:42.005]                     }
[13:21:42.005]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:42.005]                     base::options(mc.cores = 1L)
[13:21:42.005]                   }
[13:21:42.005]                   options(future.plan = NULL)
[13:21:42.005]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:42.005]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:42.005]                 }
[13:21:42.005]                 ...future.workdir <- getwd()
[13:21:42.005]             }
[13:21:42.005]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:42.005]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:42.005]         }
[13:21:42.005]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:42.005]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:42.005]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:42.005]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:42.005]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:42.005]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:42.005]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:42.005]             base::names(...future.oldOptions))
[13:21:42.005]     }
[13:21:42.005]     if (FALSE) {
[13:21:42.005]     }
[13:21:42.005]     else {
[13:21:42.005]         if (TRUE) {
[13:21:42.005]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:42.005]                 open = "w")
[13:21:42.005]         }
[13:21:42.005]         else {
[13:21:42.005]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:42.005]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:42.005]         }
[13:21:42.005]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:42.005]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:42.005]             base::sink(type = "output", split = FALSE)
[13:21:42.005]             base::close(...future.stdout)
[13:21:42.005]         }, add = TRUE)
[13:21:42.005]     }
[13:21:42.005]     ...future.frame <- base::sys.nframe()
[13:21:42.005]     ...future.conditions <- base::list()
[13:21:42.005]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:42.005]     if (FALSE) {
[13:21:42.005]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:42.005]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:42.005]     }
[13:21:42.005]     ...future.result <- base::tryCatch({
[13:21:42.005]         base::withCallingHandlers({
[13:21:42.005]             ...future.value <- base::withVisible(base::local({
[13:21:42.005]                 withCallingHandlers({
[13:21:42.005]                   {
[13:21:42.005]                     Sys.sleep(0.5)
[13:21:42.005]                     2
[13:21:42.005]                   }
[13:21:42.005]                 }, immediateCondition = function(cond) {
[13:21:42.005]                   save_rds <- function (object, pathname, ...) 
[13:21:42.005]                   {
[13:21:42.005]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:42.005]                     if (file_test("-f", pathname_tmp)) {
[13:21:42.005]                       fi_tmp <- file.info(pathname_tmp)
[13:21:42.005]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:42.005]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:42.005]                         fi_tmp[["mtime"]])
[13:21:42.005]                     }
[13:21:42.005]                     tryCatch({
[13:21:42.005]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:42.005]                     }, error = function(ex) {
[13:21:42.005]                       msg <- conditionMessage(ex)
[13:21:42.005]                       fi_tmp <- file.info(pathname_tmp)
[13:21:42.005]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:42.005]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:42.005]                         fi_tmp[["mtime"]], msg)
[13:21:42.005]                       ex$message <- msg
[13:21:42.005]                       stop(ex)
[13:21:42.005]                     })
[13:21:42.005]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:42.005]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:42.005]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:42.005]                       fi_tmp <- file.info(pathname_tmp)
[13:21:42.005]                       fi <- file.info(pathname)
[13:21:42.005]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:42.005]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:42.005]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:42.005]                         fi[["size"]], fi[["mtime"]])
[13:21:42.005]                       stop(msg)
[13:21:42.005]                     }
[13:21:42.005]                     invisible(pathname)
[13:21:42.005]                   }
[13:21:42.005]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:42.005]                     rootPath = tempdir()) 
[13:21:42.005]                   {
[13:21:42.005]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:42.005]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:42.005]                       tmpdir = path, fileext = ".rds")
[13:21:42.005]                     save_rds(obj, file)
[13:21:42.005]                   }
[13:21:42.005]                   saveImmediateCondition(cond, path = "/tmp/RtmpRIPAyw/.future/immediateConditions")
[13:21:42.005]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:42.005]                   {
[13:21:42.005]                     inherits <- base::inherits
[13:21:42.005]                     invokeRestart <- base::invokeRestart
[13:21:42.005]                     is.null <- base::is.null
[13:21:42.005]                     muffled <- FALSE
[13:21:42.005]                     if (inherits(cond, "message")) {
[13:21:42.005]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:42.005]                       if (muffled) 
[13:21:42.005]                         invokeRestart("muffleMessage")
[13:21:42.005]                     }
[13:21:42.005]                     else if (inherits(cond, "warning")) {
[13:21:42.005]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:42.005]                       if (muffled) 
[13:21:42.005]                         invokeRestart("muffleWarning")
[13:21:42.005]                     }
[13:21:42.005]                     else if (inherits(cond, "condition")) {
[13:21:42.005]                       if (!is.null(pattern)) {
[13:21:42.005]                         computeRestarts <- base::computeRestarts
[13:21:42.005]                         grepl <- base::grepl
[13:21:42.005]                         restarts <- computeRestarts(cond)
[13:21:42.005]                         for (restart in restarts) {
[13:21:42.005]                           name <- restart$name
[13:21:42.005]                           if (is.null(name)) 
[13:21:42.005]                             next
[13:21:42.005]                           if (!grepl(pattern, name)) 
[13:21:42.005]                             next
[13:21:42.005]                           invokeRestart(restart)
[13:21:42.005]                           muffled <- TRUE
[13:21:42.005]                           break
[13:21:42.005]                         }
[13:21:42.005]                       }
[13:21:42.005]                     }
[13:21:42.005]                     invisible(muffled)
[13:21:42.005]                   }
[13:21:42.005]                   muffleCondition(cond)
[13:21:42.005]                 })
[13:21:42.005]             }))
[13:21:42.005]             future::FutureResult(value = ...future.value$value, 
[13:21:42.005]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:42.005]                   ...future.rng), globalenv = if (FALSE) 
[13:21:42.005]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:42.005]                     ...future.globalenv.names))
[13:21:42.005]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:42.005]         }, condition = base::local({
[13:21:42.005]             c <- base::c
[13:21:42.005]             inherits <- base::inherits
[13:21:42.005]             invokeRestart <- base::invokeRestart
[13:21:42.005]             length <- base::length
[13:21:42.005]             list <- base::list
[13:21:42.005]             seq.int <- base::seq.int
[13:21:42.005]             signalCondition <- base::signalCondition
[13:21:42.005]             sys.calls <- base::sys.calls
[13:21:42.005]             `[[` <- base::`[[`
[13:21:42.005]             `+` <- base::`+`
[13:21:42.005]             `<<-` <- base::`<<-`
[13:21:42.005]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:42.005]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:42.005]                   3L)]
[13:21:42.005]             }
[13:21:42.005]             function(cond) {
[13:21:42.005]                 is_error <- inherits(cond, "error")
[13:21:42.005]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:42.005]                   NULL)
[13:21:42.005]                 if (is_error) {
[13:21:42.005]                   sessionInformation <- function() {
[13:21:42.005]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:42.005]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:42.005]                       search = base::search(), system = base::Sys.info())
[13:21:42.005]                   }
[13:21:42.005]                   ...future.conditions[[length(...future.conditions) + 
[13:21:42.005]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:42.005]                     cond$call), session = sessionInformation(), 
[13:21:42.005]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:42.005]                   signalCondition(cond)
[13:21:42.005]                 }
[13:21:42.005]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:42.005]                 "immediateCondition"))) {
[13:21:42.005]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:42.005]                   ...future.conditions[[length(...future.conditions) + 
[13:21:42.005]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:42.005]                   if (TRUE && !signal) {
[13:21:42.005]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:42.005]                     {
[13:21:42.005]                       inherits <- base::inherits
[13:21:42.005]                       invokeRestart <- base::invokeRestart
[13:21:42.005]                       is.null <- base::is.null
[13:21:42.005]                       muffled <- FALSE
[13:21:42.005]                       if (inherits(cond, "message")) {
[13:21:42.005]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:42.005]                         if (muffled) 
[13:21:42.005]                           invokeRestart("muffleMessage")
[13:21:42.005]                       }
[13:21:42.005]                       else if (inherits(cond, "warning")) {
[13:21:42.005]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:42.005]                         if (muffled) 
[13:21:42.005]                           invokeRestart("muffleWarning")
[13:21:42.005]                       }
[13:21:42.005]                       else if (inherits(cond, "condition")) {
[13:21:42.005]                         if (!is.null(pattern)) {
[13:21:42.005]                           computeRestarts <- base::computeRestarts
[13:21:42.005]                           grepl <- base::grepl
[13:21:42.005]                           restarts <- computeRestarts(cond)
[13:21:42.005]                           for (restart in restarts) {
[13:21:42.005]                             name <- restart$name
[13:21:42.005]                             if (is.null(name)) 
[13:21:42.005]                               next
[13:21:42.005]                             if (!grepl(pattern, name)) 
[13:21:42.005]                               next
[13:21:42.005]                             invokeRestart(restart)
[13:21:42.005]                             muffled <- TRUE
[13:21:42.005]                             break
[13:21:42.005]                           }
[13:21:42.005]                         }
[13:21:42.005]                       }
[13:21:42.005]                       invisible(muffled)
[13:21:42.005]                     }
[13:21:42.005]                     muffleCondition(cond, pattern = "^muffle")
[13:21:42.005]                   }
[13:21:42.005]                 }
[13:21:42.005]                 else {
[13:21:42.005]                   if (TRUE) {
[13:21:42.005]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:42.005]                     {
[13:21:42.005]                       inherits <- base::inherits
[13:21:42.005]                       invokeRestart <- base::invokeRestart
[13:21:42.005]                       is.null <- base::is.null
[13:21:42.005]                       muffled <- FALSE
[13:21:42.005]                       if (inherits(cond, "message")) {
[13:21:42.005]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:42.005]                         if (muffled) 
[13:21:42.005]                           invokeRestart("muffleMessage")
[13:21:42.005]                       }
[13:21:42.005]                       else if (inherits(cond, "warning")) {
[13:21:42.005]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:42.005]                         if (muffled) 
[13:21:42.005]                           invokeRestart("muffleWarning")
[13:21:42.005]                       }
[13:21:42.005]                       else if (inherits(cond, "condition")) {
[13:21:42.005]                         if (!is.null(pattern)) {
[13:21:42.005]                           computeRestarts <- base::computeRestarts
[13:21:42.005]                           grepl <- base::grepl
[13:21:42.005]                           restarts <- computeRestarts(cond)
[13:21:42.005]                           for (restart in restarts) {
[13:21:42.005]                             name <- restart$name
[13:21:42.005]                             if (is.null(name)) 
[13:21:42.005]                               next
[13:21:42.005]                             if (!grepl(pattern, name)) 
[13:21:42.005]                               next
[13:21:42.005]                             invokeRestart(restart)
[13:21:42.005]                             muffled <- TRUE
[13:21:42.005]                             break
[13:21:42.005]                           }
[13:21:42.005]                         }
[13:21:42.005]                       }
[13:21:42.005]                       invisible(muffled)
[13:21:42.005]                     }
[13:21:42.005]                     muffleCondition(cond, pattern = "^muffle")
[13:21:42.005]                   }
[13:21:42.005]                 }
[13:21:42.005]             }
[13:21:42.005]         }))
[13:21:42.005]     }, error = function(ex) {
[13:21:42.005]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:42.005]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:42.005]                 ...future.rng), started = ...future.startTime, 
[13:21:42.005]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:42.005]             version = "1.8"), class = "FutureResult")
[13:21:42.005]     }, finally = {
[13:21:42.005]         if (!identical(...future.workdir, getwd())) 
[13:21:42.005]             setwd(...future.workdir)
[13:21:42.005]         {
[13:21:42.005]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:42.005]                 ...future.oldOptions$nwarnings <- NULL
[13:21:42.005]             }
[13:21:42.005]             base::options(...future.oldOptions)
[13:21:42.005]             if (.Platform$OS.type == "windows") {
[13:21:42.005]                 old_names <- names(...future.oldEnvVars)
[13:21:42.005]                 envs <- base::Sys.getenv()
[13:21:42.005]                 names <- names(envs)
[13:21:42.005]                 common <- intersect(names, old_names)
[13:21:42.005]                 added <- setdiff(names, old_names)
[13:21:42.005]                 removed <- setdiff(old_names, names)
[13:21:42.005]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:42.005]                   envs[common]]
[13:21:42.005]                 NAMES <- toupper(changed)
[13:21:42.005]                 args <- list()
[13:21:42.005]                 for (kk in seq_along(NAMES)) {
[13:21:42.005]                   name <- changed[[kk]]
[13:21:42.005]                   NAME <- NAMES[[kk]]
[13:21:42.005]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:42.005]                     next
[13:21:42.005]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:42.005]                 }
[13:21:42.005]                 NAMES <- toupper(added)
[13:21:42.005]                 for (kk in seq_along(NAMES)) {
[13:21:42.005]                   name <- added[[kk]]
[13:21:42.005]                   NAME <- NAMES[[kk]]
[13:21:42.005]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:42.005]                     next
[13:21:42.005]                   args[[name]] <- ""
[13:21:42.005]                 }
[13:21:42.005]                 NAMES <- toupper(removed)
[13:21:42.005]                 for (kk in seq_along(NAMES)) {
[13:21:42.005]                   name <- removed[[kk]]
[13:21:42.005]                   NAME <- NAMES[[kk]]
[13:21:42.005]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:42.005]                     next
[13:21:42.005]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:42.005]                 }
[13:21:42.005]                 if (length(args) > 0) 
[13:21:42.005]                   base::do.call(base::Sys.setenv, args = args)
[13:21:42.005]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:42.005]             }
[13:21:42.005]             else {
[13:21:42.005]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:42.005]             }
[13:21:42.005]             {
[13:21:42.005]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:42.005]                   0L) {
[13:21:42.005]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:42.005]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:42.005]                   base::options(opts)
[13:21:42.005]                 }
[13:21:42.005]                 {
[13:21:42.005]                   {
[13:21:42.005]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:42.005]                     NULL
[13:21:42.005]                   }
[13:21:42.005]                   options(future.plan = NULL)
[13:21:42.005]                   if (is.na(NA_character_)) 
[13:21:42.005]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:42.005]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:42.005]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:42.005]                     envir = parent.frame()) 
[13:21:42.005]                   {
[13:21:42.005]                     default_workers <- missing(workers)
[13:21:42.005]                     if (is.function(workers)) 
[13:21:42.005]                       workers <- workers()
[13:21:42.005]                     workers <- structure(as.integer(workers), 
[13:21:42.005]                       class = class(workers))
[13:21:42.005]                     stop_if_not(is.finite(workers), workers >= 
[13:21:42.005]                       1L)
[13:21:42.005]                     if ((workers == 1L && !inherits(workers, 
[13:21:42.005]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:42.005]                       if (default_workers) 
[13:21:42.005]                         supportsMulticore(warn = TRUE)
[13:21:42.005]                       return(sequential(..., envir = envir))
[13:21:42.005]                     }
[13:21:42.005]                     oopts <- options(mc.cores = workers)
[13:21:42.005]                     on.exit(options(oopts))
[13:21:42.005]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:42.005]                       envir = envir)
[13:21:42.005]                     if (!future$lazy) 
[13:21:42.005]                       future <- run(future)
[13:21:42.005]                     invisible(future)
[13:21:42.005]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:42.005]                 }
[13:21:42.005]             }
[13:21:42.005]         }
[13:21:42.005]     })
[13:21:42.005]     if (TRUE) {
[13:21:42.005]         base::sink(type = "output", split = FALSE)
[13:21:42.005]         if (TRUE) {
[13:21:42.005]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:42.005]         }
[13:21:42.005]         else {
[13:21:42.005]             ...future.result["stdout"] <- base::list(NULL)
[13:21:42.005]         }
[13:21:42.005]         base::close(...future.stdout)
[13:21:42.005]         ...future.stdout <- NULL
[13:21:42.005]     }
[13:21:42.005]     ...future.result$conditions <- ...future.conditions
[13:21:42.005]     ...future.result$finished <- base::Sys.time()
[13:21:42.005]     ...future.result
[13:21:42.005] }
[13:21:42.009] requestCore(): workers = 2
[13:21:42.009] Poll #1 (0): usedCores() = 2, workers = 2
[13:21:42.024] MulticoreFuture started
[13:21:42.025] - Launch lazy future ... done
[13:21:42.025] run() for ‘MulticoreFuture’ ... done
[13:21:42.025] plan(): Setting new future strategy stack:
[13:21:42.026] getGlobalsAndPackages() ...
[13:21:42.025] List of future strategies:
[13:21:42.025] 1. sequential:
[13:21:42.025]    - args: function (..., envir = parent.frame())
[13:21:42.025]    - tweaked: FALSE
[13:21:42.025]    - call: NULL
[13:21:42.026] Searching for globals...
[13:21:42.026] plan(): nbrOfWorkers() = 1
[13:21:42.028] - globals found: [1] ‘{’
[13:21:42.028] Searching for globals ... DONE
[13:21:42.028] Resolving globals: FALSE
[13:21:42.029] 
[13:21:42.029] 
[13:21:42.029] getGlobalsAndPackages() ... DONE
[13:21:42.029] run() for ‘Future’ ...
[13:21:42.030] - state: ‘created’
[13:21:42.030] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:21:42.035] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:42.035] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:21:42.035]   - Field: ‘label’
[13:21:42.036]   - Field: ‘local’
[13:21:42.036]   - Field: ‘owner’
[13:21:42.036]   - Field: ‘envir’
[13:21:42.036]   - Field: ‘workers’
[13:21:42.036]   - Field: ‘packages’
[13:21:42.036]   - Field: ‘gc’
[13:21:42.036]   - Field: ‘job’
[13:21:42.037]   - Field: ‘conditions’
[13:21:42.037]   - Field: ‘expr’
[13:21:42.037]   - Field: ‘uuid’
[13:21:42.037]   - Field: ‘seed’
[13:21:42.037]   - Field: ‘version’
[13:21:42.037]   - Field: ‘result’
[13:21:42.038]   - Field: ‘asynchronous’
[13:21:42.038]   - Field: ‘calls’
[13:21:42.038]   - Field: ‘globals’
[13:21:42.038]   - Field: ‘stdout’
[13:21:42.038]   - Field: ‘earlySignal’
[13:21:42.038]   - Field: ‘lazy’
[13:21:42.038]   - Field: ‘state’
[13:21:42.038] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:21:42.039] - Launch lazy future ...
[13:21:42.039] Packages needed by the future expression (n = 0): <none>
[13:21:42.039] Packages needed by future strategies (n = 0): <none>
[13:21:42.040] {
[13:21:42.040]     {
[13:21:42.040]         {
[13:21:42.040]             ...future.startTime <- base::Sys.time()
[13:21:42.040]             {
[13:21:42.040]                 {
[13:21:42.040]                   {
[13:21:42.040]                     {
[13:21:42.040]                       base::local({
[13:21:42.040]                         has_future <- base::requireNamespace("future", 
[13:21:42.040]                           quietly = TRUE)
[13:21:42.040]                         if (has_future) {
[13:21:42.040]                           ns <- base::getNamespace("future")
[13:21:42.040]                           version <- ns[[".package"]][["version"]]
[13:21:42.040]                           if (is.null(version)) 
[13:21:42.040]                             version <- utils::packageVersion("future")
[13:21:42.040]                         }
[13:21:42.040]                         else {
[13:21:42.040]                           version <- NULL
[13:21:42.040]                         }
[13:21:42.040]                         if (!has_future || version < "1.8.0") {
[13:21:42.040]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:42.040]                             "", base::R.version$version.string), 
[13:21:42.040]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:42.040]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:42.040]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:42.040]                               "release", "version")], collapse = " "), 
[13:21:42.040]                             hostname = base::Sys.info()[["nodename"]])
[13:21:42.040]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:42.040]                             info)
[13:21:42.040]                           info <- base::paste(info, collapse = "; ")
[13:21:42.040]                           if (!has_future) {
[13:21:42.040]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:42.040]                               info)
[13:21:42.040]                           }
[13:21:42.040]                           else {
[13:21:42.040]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:42.040]                               info, version)
[13:21:42.040]                           }
[13:21:42.040]                           base::stop(msg)
[13:21:42.040]                         }
[13:21:42.040]                       })
[13:21:42.040]                     }
[13:21:42.040]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:42.040]                     base::options(mc.cores = 1L)
[13:21:42.040]                   }
[13:21:42.040]                   options(future.plan = NULL)
[13:21:42.040]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:42.040]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:42.040]                 }
[13:21:42.040]                 ...future.workdir <- getwd()
[13:21:42.040]             }
[13:21:42.040]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:42.040]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:42.040]         }
[13:21:42.040]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:42.040]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:42.040]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:42.040]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:42.040]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:42.040]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:42.040]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:42.040]             base::names(...future.oldOptions))
[13:21:42.040]     }
[13:21:42.040]     if (FALSE) {
[13:21:42.040]     }
[13:21:42.040]     else {
[13:21:42.040]         if (TRUE) {
[13:21:42.040]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:42.040]                 open = "w")
[13:21:42.040]         }
[13:21:42.040]         else {
[13:21:42.040]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:42.040]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:42.040]         }
[13:21:42.040]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:42.040]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:42.040]             base::sink(type = "output", split = FALSE)
[13:21:42.040]             base::close(...future.stdout)
[13:21:42.040]         }, add = TRUE)
[13:21:42.040]     }
[13:21:42.040]     ...future.frame <- base::sys.nframe()
[13:21:42.040]     ...future.conditions <- base::list()
[13:21:42.040]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:42.040]     if (FALSE) {
[13:21:42.040]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:42.040]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:42.040]     }
[13:21:42.040]     ...future.result <- base::tryCatch({
[13:21:42.040]         base::withCallingHandlers({
[13:21:42.040]             ...future.value <- base::withVisible(base::local({
[13:21:42.040]                 withCallingHandlers({
[13:21:42.040]                   {
[13:21:42.040]                     3
[13:21:42.040]                   }
[13:21:42.040]                 }, immediateCondition = function(cond) {
[13:21:42.040]                   save_rds <- function (object, pathname, ...) 
[13:21:42.040]                   {
[13:21:42.040]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:21:42.040]                     if (file_test("-f", pathname_tmp)) {
[13:21:42.040]                       fi_tmp <- file.info(pathname_tmp)
[13:21:42.040]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:21:42.040]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:42.040]                         fi_tmp[["mtime"]])
[13:21:42.040]                     }
[13:21:42.040]                     tryCatch({
[13:21:42.040]                       saveRDS(object, file = pathname_tmp, ...)
[13:21:42.040]                     }, error = function(ex) {
[13:21:42.040]                       msg <- conditionMessage(ex)
[13:21:42.040]                       fi_tmp <- file.info(pathname_tmp)
[13:21:42.040]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:21:42.040]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:42.040]                         fi_tmp[["mtime"]], msg)
[13:21:42.040]                       ex$message <- msg
[13:21:42.040]                       stop(ex)
[13:21:42.040]                     })
[13:21:42.040]                     stopifnot(file_test("-f", pathname_tmp))
[13:21:42.040]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:21:42.040]                     if (!res || file_test("-f", pathname_tmp)) {
[13:21:42.040]                       fi_tmp <- file.info(pathname_tmp)
[13:21:42.040]                       fi <- file.info(pathname)
[13:21:42.040]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:21:42.040]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:21:42.040]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:21:42.040]                         fi[["size"]], fi[["mtime"]])
[13:21:42.040]                       stop(msg)
[13:21:42.040]                     }
[13:21:42.040]                     invisible(pathname)
[13:21:42.040]                   }
[13:21:42.040]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:21:42.040]                     rootPath = tempdir()) 
[13:21:42.040]                   {
[13:21:42.040]                     obj <- list(time = Sys.time(), condition = cond)
[13:21:42.040]                     file <- tempfile(pattern = class(cond)[1], 
[13:21:42.040]                       tmpdir = path, fileext = ".rds")
[13:21:42.040]                     save_rds(obj, file)
[13:21:42.040]                   }
[13:21:42.040]                   saveImmediateCondition(cond, path = "/tmp/RtmpRIPAyw/.future/immediateConditions")
[13:21:42.040]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:42.040]                   {
[13:21:42.040]                     inherits <- base::inherits
[13:21:42.040]                     invokeRestart <- base::invokeRestart
[13:21:42.040]                     is.null <- base::is.null
[13:21:42.040]                     muffled <- FALSE
[13:21:42.040]                     if (inherits(cond, "message")) {
[13:21:42.040]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:42.040]                       if (muffled) 
[13:21:42.040]                         invokeRestart("muffleMessage")
[13:21:42.040]                     }
[13:21:42.040]                     else if (inherits(cond, "warning")) {
[13:21:42.040]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:42.040]                       if (muffled) 
[13:21:42.040]                         invokeRestart("muffleWarning")
[13:21:42.040]                     }
[13:21:42.040]                     else if (inherits(cond, "condition")) {
[13:21:42.040]                       if (!is.null(pattern)) {
[13:21:42.040]                         computeRestarts <- base::computeRestarts
[13:21:42.040]                         grepl <- base::grepl
[13:21:42.040]                         restarts <- computeRestarts(cond)
[13:21:42.040]                         for (restart in restarts) {
[13:21:42.040]                           name <- restart$name
[13:21:42.040]                           if (is.null(name)) 
[13:21:42.040]                             next
[13:21:42.040]                           if (!grepl(pattern, name)) 
[13:21:42.040]                             next
[13:21:42.040]                           invokeRestart(restart)
[13:21:42.040]                           muffled <- TRUE
[13:21:42.040]                           break
[13:21:42.040]                         }
[13:21:42.040]                       }
[13:21:42.040]                     }
[13:21:42.040]                     invisible(muffled)
[13:21:42.040]                   }
[13:21:42.040]                   muffleCondition(cond)
[13:21:42.040]                 })
[13:21:42.040]             }))
[13:21:42.040]             future::FutureResult(value = ...future.value$value, 
[13:21:42.040]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:42.040]                   ...future.rng), globalenv = if (FALSE) 
[13:21:42.040]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:42.040]                     ...future.globalenv.names))
[13:21:42.040]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:42.040]         }, condition = base::local({
[13:21:42.040]             c <- base::c
[13:21:42.040]             inherits <- base::inherits
[13:21:42.040]             invokeRestart <- base::invokeRestart
[13:21:42.040]             length <- base::length
[13:21:42.040]             list <- base::list
[13:21:42.040]             seq.int <- base::seq.int
[13:21:42.040]             signalCondition <- base::signalCondition
[13:21:42.040]             sys.calls <- base::sys.calls
[13:21:42.040]             `[[` <- base::`[[`
[13:21:42.040]             `+` <- base::`+`
[13:21:42.040]             `<<-` <- base::`<<-`
[13:21:42.040]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:42.040]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:42.040]                   3L)]
[13:21:42.040]             }
[13:21:42.040]             function(cond) {
[13:21:42.040]                 is_error <- inherits(cond, "error")
[13:21:42.040]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:42.040]                   NULL)
[13:21:42.040]                 if (is_error) {
[13:21:42.040]                   sessionInformation <- function() {
[13:21:42.040]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:42.040]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:42.040]                       search = base::search(), system = base::Sys.info())
[13:21:42.040]                   }
[13:21:42.040]                   ...future.conditions[[length(...future.conditions) + 
[13:21:42.040]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:42.040]                     cond$call), session = sessionInformation(), 
[13:21:42.040]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:42.040]                   signalCondition(cond)
[13:21:42.040]                 }
[13:21:42.040]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:42.040]                 "immediateCondition"))) {
[13:21:42.040]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:42.040]                   ...future.conditions[[length(...future.conditions) + 
[13:21:42.040]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:42.040]                   if (TRUE && !signal) {
[13:21:42.040]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:42.040]                     {
[13:21:42.040]                       inherits <- base::inherits
[13:21:42.040]                       invokeRestart <- base::invokeRestart
[13:21:42.040]                       is.null <- base::is.null
[13:21:42.040]                       muffled <- FALSE
[13:21:42.040]                       if (inherits(cond, "message")) {
[13:21:42.040]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:42.040]                         if (muffled) 
[13:21:42.040]                           invokeRestart("muffleMessage")
[13:21:42.040]                       }
[13:21:42.040]                       else if (inherits(cond, "warning")) {
[13:21:42.040]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:42.040]                         if (muffled) 
[13:21:42.040]                           invokeRestart("muffleWarning")
[13:21:42.040]                       }
[13:21:42.040]                       else if (inherits(cond, "condition")) {
[13:21:42.040]                         if (!is.null(pattern)) {
[13:21:42.040]                           computeRestarts <- base::computeRestarts
[13:21:42.040]                           grepl <- base::grepl
[13:21:42.040]                           restarts <- computeRestarts(cond)
[13:21:42.040]                           for (restart in restarts) {
[13:21:42.040]                             name <- restart$name
[13:21:42.040]                             if (is.null(name)) 
[13:21:42.040]                               next
[13:21:42.040]                             if (!grepl(pattern, name)) 
[13:21:42.040]                               next
[13:21:42.040]                             invokeRestart(restart)
[13:21:42.040]                             muffled <- TRUE
[13:21:42.040]                             break
[13:21:42.040]                           }
[13:21:42.040]                         }
[13:21:42.040]                       }
[13:21:42.040]                       invisible(muffled)
[13:21:42.040]                     }
[13:21:42.040]                     muffleCondition(cond, pattern = "^muffle")
[13:21:42.040]                   }
[13:21:42.040]                 }
[13:21:42.040]                 else {
[13:21:42.040]                   if (TRUE) {
[13:21:42.040]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:42.040]                     {
[13:21:42.040]                       inherits <- base::inherits
[13:21:42.040]                       invokeRestart <- base::invokeRestart
[13:21:42.040]                       is.null <- base::is.null
[13:21:42.040]                       muffled <- FALSE
[13:21:42.040]                       if (inherits(cond, "message")) {
[13:21:42.040]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:42.040]                         if (muffled) 
[13:21:42.040]                           invokeRestart("muffleMessage")
[13:21:42.040]                       }
[13:21:42.040]                       else if (inherits(cond, "warning")) {
[13:21:42.040]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:42.040]                         if (muffled) 
[13:21:42.040]                           invokeRestart("muffleWarning")
[13:21:42.040]                       }
[13:21:42.040]                       else if (inherits(cond, "condition")) {
[13:21:42.040]                         if (!is.null(pattern)) {
[13:21:42.040]                           computeRestarts <- base::computeRestarts
[13:21:42.040]                           grepl <- base::grepl
[13:21:42.040]                           restarts <- computeRestarts(cond)
[13:21:42.040]                           for (restart in restarts) {
[13:21:42.040]                             name <- restart$name
[13:21:42.040]                             if (is.null(name)) 
[13:21:42.040]                               next
[13:21:42.040]                             if (!grepl(pattern, name)) 
[13:21:42.040]                               next
[13:21:42.040]                             invokeRestart(restart)
[13:21:42.040]                             muffled <- TRUE
[13:21:42.040]                             break
[13:21:42.040]                           }
[13:21:42.040]                         }
[13:21:42.040]                       }
[13:21:42.040]                       invisible(muffled)
[13:21:42.040]                     }
[13:21:42.040]                     muffleCondition(cond, pattern = "^muffle")
[13:21:42.040]                   }
[13:21:42.040]                 }
[13:21:42.040]             }
[13:21:42.040]         }))
[13:21:42.040]     }, error = function(ex) {
[13:21:42.040]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:42.040]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:42.040]                 ...future.rng), started = ...future.startTime, 
[13:21:42.040]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:42.040]             version = "1.8"), class = "FutureResult")
[13:21:42.040]     }, finally = {
[13:21:42.040]         if (!identical(...future.workdir, getwd())) 
[13:21:42.040]             setwd(...future.workdir)
[13:21:42.040]         {
[13:21:42.040]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:42.040]                 ...future.oldOptions$nwarnings <- NULL
[13:21:42.040]             }
[13:21:42.040]             base::options(...future.oldOptions)
[13:21:42.040]             if (.Platform$OS.type == "windows") {
[13:21:42.040]                 old_names <- names(...future.oldEnvVars)
[13:21:42.040]                 envs <- base::Sys.getenv()
[13:21:42.040]                 names <- names(envs)
[13:21:42.040]                 common <- intersect(names, old_names)
[13:21:42.040]                 added <- setdiff(names, old_names)
[13:21:42.040]                 removed <- setdiff(old_names, names)
[13:21:42.040]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:42.040]                   envs[common]]
[13:21:42.040]                 NAMES <- toupper(changed)
[13:21:42.040]                 args <- list()
[13:21:42.040]                 for (kk in seq_along(NAMES)) {
[13:21:42.040]                   name <- changed[[kk]]
[13:21:42.040]                   NAME <- NAMES[[kk]]
[13:21:42.040]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:42.040]                     next
[13:21:42.040]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:42.040]                 }
[13:21:42.040]                 NAMES <- toupper(added)
[13:21:42.040]                 for (kk in seq_along(NAMES)) {
[13:21:42.040]                   name <- added[[kk]]
[13:21:42.040]                   NAME <- NAMES[[kk]]
[13:21:42.040]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:42.040]                     next
[13:21:42.040]                   args[[name]] <- ""
[13:21:42.040]                 }
[13:21:42.040]                 NAMES <- toupper(removed)
[13:21:42.040]                 for (kk in seq_along(NAMES)) {
[13:21:42.040]                   name <- removed[[kk]]
[13:21:42.040]                   NAME <- NAMES[[kk]]
[13:21:42.040]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:42.040]                     next
[13:21:42.040]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:42.040]                 }
[13:21:42.040]                 if (length(args) > 0) 
[13:21:42.040]                   base::do.call(base::Sys.setenv, args = args)
[13:21:42.040]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:42.040]             }
[13:21:42.040]             else {
[13:21:42.040]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:42.040]             }
[13:21:42.040]             {
[13:21:42.040]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:42.040]                   0L) {
[13:21:42.040]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:42.040]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:42.040]                   base::options(opts)
[13:21:42.040]                 }
[13:21:42.040]                 {
[13:21:42.040]                   {
[13:21:42.040]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:42.040]                     NULL
[13:21:42.040]                   }
[13:21:42.040]                   options(future.plan = NULL)
[13:21:42.040]                   if (is.na(NA_character_)) 
[13:21:42.040]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:42.040]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:42.040]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:21:42.040]                     envir = parent.frame()) 
[13:21:42.040]                   {
[13:21:42.040]                     default_workers <- missing(workers)
[13:21:42.040]                     if (is.function(workers)) 
[13:21:42.040]                       workers <- workers()
[13:21:42.040]                     workers <- structure(as.integer(workers), 
[13:21:42.040]                       class = class(workers))
[13:21:42.040]                     stop_if_not(is.finite(workers), workers >= 
[13:21:42.040]                       1L)
[13:21:42.040]                     if ((workers == 1L && !inherits(workers, 
[13:21:42.040]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:21:42.040]                       if (default_workers) 
[13:21:42.040]                         supportsMulticore(warn = TRUE)
[13:21:42.040]                       return(sequential(..., envir = envir))
[13:21:42.040]                     }
[13:21:42.040]                     oopts <- options(mc.cores = workers)
[13:21:42.040]                     on.exit(options(oopts))
[13:21:42.040]                     future <- MulticoreFuture(..., workers = workers, 
[13:21:42.040]                       envir = envir)
[13:21:42.040]                     if (!future$lazy) 
[13:21:42.040]                       future <- run(future)
[13:21:42.040]                     invisible(future)
[13:21:42.040]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:42.040]                 }
[13:21:42.040]             }
[13:21:42.040]         }
[13:21:42.040]     })
[13:21:42.040]     if (TRUE) {
[13:21:42.040]         base::sink(type = "output", split = FALSE)
[13:21:42.040]         if (TRUE) {
[13:21:42.040]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:42.040]         }
[13:21:42.040]         else {
[13:21:42.040]             ...future.result["stdout"] <- base::list(NULL)
[13:21:42.040]         }
[13:21:42.040]         base::close(...future.stdout)
[13:21:42.040]         ...future.stdout <- NULL
[13:21:42.040]     }
[13:21:42.040]     ...future.result$conditions <- ...future.conditions
[13:21:42.040]     ...future.result$finished <- base::Sys.time()
[13:21:42.040]     ...future.result
[13:21:42.040] }
[13:21:42.044] requestCore(): workers = 2
[13:21:42.044] Poll #1 (0): usedCores() = 2, workers = 2
[13:21:42.058] MulticoreFuture started
[13:21:42.058] - Launch lazy future ... done
[13:21:42.058] run() for ‘MulticoreFuture’ ... done
[13:21:42.059] plan(): Setting new future strategy stack:
[13:21:42.059] List of future strategies:
[13:21:42.059] 1. sequential:
[13:21:42.059]    - args: function (..., envir = parent.frame())
[13:21:42.059]    - tweaked: FALSE
[13:21:42.059]    - call: NULL
[13:21:42.061] plan(): nbrOfWorkers() = 1
[13:21:42.061] resolve() on list environment ...
[13:21:42.061]  recursive: 0
[13:21:42.063] plan(): Setting new future strategy stack:
[13:21:42.064] List of future strategies:
[13:21:42.064] 1. multicore:
[13:21:42.064]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:42.064]    - tweaked: FALSE
[13:21:42.064]    - call: plan(strategy)
[13:21:42.071]  length: 4
[13:21:42.072]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:21:42.073] Future #1
[13:21:42.073]  length: 3 (resolved future 1)
[13:21:42.076] plan(): nbrOfWorkers() = 2
[13:21:42.085] Future #3
[13:21:42.085]  length: 2 (resolved future 3)
[13:21:42.085]  length: 1 (resolved future 4)
[13:21:42.529] plan(): Setting new future strategy stack:
[13:21:42.530] List of future strategies:
[13:21:42.530] 1. multicore:
[13:21:42.530]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:21:42.530]    - tweaked: FALSE
[13:21:42.530]    - call: plan(strategy)
[13:21:42.534] plan(): nbrOfWorkers() = 2
[13:21:42.545] Future #2
[13:21:42.545]  length: 0 (resolved future 2)
[13:21:42.546] resolve() on list environment ... DONE
[13:21:42.546] resolve() on list environment ...
[13:21:42.546]  recursive: 0
[13:21:42.548]  length: 4
[13:21:42.548]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:21:42.549] Future #1
[13:21:42.549]  length: 3 (resolved future 1)
[13:21:42.549] Future #2
[13:21:42.549]  length: 2 (resolved future 2)
[13:21:42.550] Future #3
[13:21:42.550]  length: 1 (resolved future 3)
[13:21:42.550]  length: 0 (resolved future 4)
[13:21:42.550] resolve() on list environment ... DONE
[13:21:42.551] resolve() on list environment ...
[13:21:42.552]  recursive: 0
[13:21:42.553]  length: 4
[13:21:42.553]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:21:42.553] Future #1
[13:21:42.553]  length: 3 (resolved future 1)
[13:21:42.553] Future #2
[13:21:42.553]  length: 2 (resolved future 2)
[13:21:42.554] Future #3
[13:21:42.554]  length: 1 (resolved future 3)
[13:21:42.554]  length: 0 (resolved future 4)
[13:21:42.554] resolve() on list environment ... DONE
[13:21:42.555] resolve() on list environment ...
[13:21:42.555]  recursive: 0
[13:21:42.556]  length: 4
[13:21:42.556]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:21:42.556] Future #1
[13:21:42.556]  length: 3 (resolved future 1)
[13:21:42.557] Future #2
[13:21:42.557]  length: 2 (resolved future 2)
[13:21:42.557] Future #3
[13:21:42.557]  length: 1 (resolved future 3)
[13:21:42.557]  length: 0 (resolved future 4)
[13:21:42.558] resolve() on list environment ... DONE
[13:21:42.558] resolve() on list environment ...
[13:21:42.558]  recursive: 0
[13:21:42.559]  length: 4
[13:21:42.559]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:21:42.560] Future #1
[13:21:42.560]  length: 3 (resolved future 1)
[13:21:42.560] Future #2
[13:21:42.561]  length: 2 (resolved future 2)
[13:21:42.561] Future #3
[13:21:42.562]  length: 1 (resolved future 3)
[13:21:42.563]  length: 0 (resolved future 4)
[13:21:42.563] resolve() on list environment ... DONE
[13:21:42.564] resolve() on list environment ...
[13:21:42.564]  recursive: 99
[13:21:42.565]  length: 4
[13:21:42.565]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:21:42.565] Future #1
[13:21:42.565] A MulticoreFuture was resolved
[13:21:42.565]  length: 3 (resolved future 1)
[13:21:42.566] Future #2
[13:21:42.566] A MulticoreFuture was resolved
[13:21:42.566]  length: 2 (resolved future 2)
[13:21:42.566] Future #3
[13:21:42.566] A MulticoreFuture was resolved
[13:21:42.566]  length: 1 (resolved future 3)
[13:21:42.566]  length: 0 (resolved future 4)
[13:21:42.566] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('multicore') ...
- plan('multisession') ...
[13:21:42.567] plan(): Setting new future strategy stack:
[13:21:42.567] List of future strategies:
[13:21:42.567] 1. multisession:
[13:21:42.567]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:21:42.567]    - tweaked: FALSE
[13:21:42.567]    - call: plan(strategy)
[13:21:42.568] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:21:42.568] multisession:
[13:21:42.568] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:21:42.568] - tweaked: FALSE
[13:21:42.568] - call: plan(strategy)
[13:21:42.575] getGlobalsAndPackages() ...
[13:21:42.575] Not searching for globals
[13:21:42.577] - globals: [0] <none>
[13:21:42.577] getGlobalsAndPackages() ... DONE
[13:21:42.578] [local output] makeClusterPSOCK() ...
[13:21:42.616] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:21:42.622] [local output] Base port: 11418
[13:21:42.622] [local output] Getting setup options for 2 cluster nodes ...
[13:21:42.622] [local output]  - Node 1 of 2 ...
[13:21:42.623] [local output] localMachine=TRUE => revtunnel=FALSE

[13:21:42.623] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpRIPAyw/worker.rank=1.parallelly.parent=91417.165194acacef4.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpRIPAyw/worker.rank=1.parallelly.parent=91417.165194acacef4.pid")'’
[13:21:42.815] - Possible to infer worker's PID: TRUE
[13:21:42.816] [local output] Rscript port: 11418

[13:21:42.816] [local output]  - Node 2 of 2 ...
[13:21:42.817] [local output] localMachine=TRUE => revtunnel=FALSE

[13:21:42.817] [local output] Rscript port: 11418

[13:21:42.818] [local output] Getting setup options for 2 cluster nodes ... done
[13:21:42.818] [local output]  - Parallel setup requested for some PSOCK nodes
[13:21:42.818] [local output] Setting up PSOCK nodes in parallel
[13:21:42.819] List of 36
[13:21:42.819]  $ worker          : chr "localhost"
[13:21:42.819]   ..- attr(*, "localhost")= logi TRUE
[13:21:42.819]  $ master          : chr "localhost"
[13:21:42.819]  $ port            : int 11418
[13:21:42.819]  $ connectTimeout  : num 120
[13:21:42.819]  $ timeout         : num 2592000
[13:21:42.819]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:21:42.819]  $ homogeneous     : logi TRUE
[13:21:42.819]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:21:42.819]  $ rscript_envs    : NULL
[13:21:42.819]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:21:42.819]  $ rscript_startup : NULL
[13:21:42.819]  $ rscript_sh      : chr "sh"
[13:21:42.819]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:21:42.819]  $ methods         : logi TRUE
[13:21:42.819]  $ socketOptions   : chr "no-delay"
[13:21:42.819]  $ useXDR          : logi FALSE
[13:21:42.819]  $ outfile         : chr "/dev/null"
[13:21:42.819]  $ renice          : int NA
[13:21:42.819]  $ rshcmd          : NULL
[13:21:42.819]  $ user            : chr(0) 
[13:21:42.819]  $ revtunnel       : logi FALSE
[13:21:42.819]  $ rshlogfile      : NULL
[13:21:42.819]  $ rshopts         : chr(0) 
[13:21:42.819]  $ rank            : int 1
[13:21:42.819]  $ manual          : logi FALSE
[13:21:42.819]  $ dryrun          : logi FALSE
[13:21:42.819]  $ quiet           : logi FALSE
[13:21:42.819]  $ setup_strategy  : chr "parallel"
[13:21:42.819]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:21:42.819]  $ pidfile         : chr "/tmp/RtmpRIPAyw/worker.rank=1.parallelly.parent=91417.165194acacef4.pid"
[13:21:42.819]  $ rshcmd_label    : NULL
[13:21:42.819]  $ rsh_call        : NULL
[13:21:42.819]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:21:42.819]  $ localMachine    : logi TRUE
[13:21:42.819]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:21:42.819]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:21:42.819]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:21:42.819]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:21:42.819]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:21:42.819]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:21:42.819]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:21:42.819]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:21:42.819]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:21:42.819]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:21:42.819]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:21:42.819]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:21:42.819]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:21:42.819]  $ arguments       :List of 28
[13:21:42.819]   ..$ worker          : chr "localhost"
[13:21:42.819]   ..$ master          : NULL
[13:21:42.819]   ..$ port            : int 11418
[13:21:42.819]   ..$ connectTimeout  : num 120
[13:21:42.819]   ..$ timeout         : num 2592000
[13:21:42.819]   ..$ rscript         : NULL
[13:21:42.819]   ..$ homogeneous     : NULL
[13:21:42.819]   ..$ rscript_args    : NULL
[13:21:42.819]   ..$ rscript_envs    : NULL
[13:21:42.819]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:21:42.819]   ..$ rscript_startup : NULL
[13:21:42.819]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:21:42.819]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:21:42.819]   ..$ methods         : logi TRUE
[13:21:42.819]   ..$ socketOptions   : chr "no-delay"
[13:21:42.819]   ..$ useXDR          : logi FALSE
[13:21:42.819]   ..$ outfile         : chr "/dev/null"
[13:21:42.819]   ..$ renice          : int NA
[13:21:42.819]   ..$ rshcmd          : NULL
[13:21:42.819]   ..$ user            : NULL
[13:21:42.819]   ..$ revtunnel       : logi NA
[13:21:42.819]   ..$ rshlogfile      : NULL
[13:21:42.819]   ..$ rshopts         : NULL
[13:21:42.819]   ..$ rank            : int 1
[13:21:42.819]   ..$ manual          : logi FALSE
[13:21:42.819]   ..$ dryrun          : logi FALSE
[13:21:42.819]   ..$ quiet           : logi FALSE
[13:21:42.819]   ..$ setup_strategy  : chr "parallel"
[13:21:42.819]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:21:42.836] [local output] System call to launch all workers:
[13:21:42.836] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpRIPAyw/worker.rank=1.parallelly.parent=91417.165194acacef4.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11418 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:21:42.836] [local output] Starting PSOCK main server
[13:21:42.838] [local output] Workers launched
[13:21:42.838] [local output] Waiting for workers to connect back
[13:21:42.838]  - [local output] 0 workers out of 2 ready
[13:21:43.074]  - [local output] 0 workers out of 2 ready
[13:21:43.074]  - [local output] 1 workers out of 2 ready
[13:21:43.101]  - [local output] 1 workers out of 2 ready
[13:21:43.102]  - [local output] 2 workers out of 2 ready
[13:21:43.102] [local output] Launching of workers completed
[13:21:43.102] [local output] Collecting session information from workers
[13:21:43.103] [local output]  - Worker #1 of 2
[13:21:43.104] [local output]  - Worker #2 of 2
[13:21:43.104] [local output] makeClusterPSOCK() ... done
[13:21:43.116] Packages needed by the future expression (n = 0): <none>
[13:21:43.116] Packages needed by future strategies (n = 0): <none>
[13:21:43.116] {
[13:21:43.116]     {
[13:21:43.116]         {
[13:21:43.116]             ...future.startTime <- base::Sys.time()
[13:21:43.116]             {
[13:21:43.116]                 {
[13:21:43.116]                   {
[13:21:43.116]                     {
[13:21:43.116]                       base::local({
[13:21:43.116]                         has_future <- base::requireNamespace("future", 
[13:21:43.116]                           quietly = TRUE)
[13:21:43.116]                         if (has_future) {
[13:21:43.116]                           ns <- base::getNamespace("future")
[13:21:43.116]                           version <- ns[[".package"]][["version"]]
[13:21:43.116]                           if (is.null(version)) 
[13:21:43.116]                             version <- utils::packageVersion("future")
[13:21:43.116]                         }
[13:21:43.116]                         else {
[13:21:43.116]                           version <- NULL
[13:21:43.116]                         }
[13:21:43.116]                         if (!has_future || version < "1.8.0") {
[13:21:43.116]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:43.116]                             "", base::R.version$version.string), 
[13:21:43.116]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:43.116]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:43.116]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:43.116]                               "release", "version")], collapse = " "), 
[13:21:43.116]                             hostname = base::Sys.info()[["nodename"]])
[13:21:43.116]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:43.116]                             info)
[13:21:43.116]                           info <- base::paste(info, collapse = "; ")
[13:21:43.116]                           if (!has_future) {
[13:21:43.116]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:43.116]                               info)
[13:21:43.116]                           }
[13:21:43.116]                           else {
[13:21:43.116]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:43.116]                               info, version)
[13:21:43.116]                           }
[13:21:43.116]                           base::stop(msg)
[13:21:43.116]                         }
[13:21:43.116]                       })
[13:21:43.116]                     }
[13:21:43.116]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:43.116]                     base::options(mc.cores = 1L)
[13:21:43.116]                   }
[13:21:43.116]                   options(future.plan = NULL)
[13:21:43.116]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:43.116]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:43.116]                 }
[13:21:43.116]                 ...future.workdir <- getwd()
[13:21:43.116]             }
[13:21:43.116]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:43.116]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:43.116]         }
[13:21:43.116]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:43.116]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:43.116]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:43.116]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:43.116]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:43.116]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:43.116]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:43.116]             base::names(...future.oldOptions))
[13:21:43.116]     }
[13:21:43.116]     if (FALSE) {
[13:21:43.116]     }
[13:21:43.116]     else {
[13:21:43.116]         if (TRUE) {
[13:21:43.116]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:43.116]                 open = "w")
[13:21:43.116]         }
[13:21:43.116]         else {
[13:21:43.116]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:43.116]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:43.116]         }
[13:21:43.116]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:43.116]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:43.116]             base::sink(type = "output", split = FALSE)
[13:21:43.116]             base::close(...future.stdout)
[13:21:43.116]         }, add = TRUE)
[13:21:43.116]     }
[13:21:43.116]     ...future.frame <- base::sys.nframe()
[13:21:43.116]     ...future.conditions <- base::list()
[13:21:43.116]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:43.116]     if (FALSE) {
[13:21:43.116]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:43.116]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:43.116]     }
[13:21:43.116]     ...future.result <- base::tryCatch({
[13:21:43.116]         base::withCallingHandlers({
[13:21:43.116]             ...future.value <- base::withVisible(base::local({
[13:21:43.116]                 ...future.makeSendCondition <- local({
[13:21:43.116]                   sendCondition <- NULL
[13:21:43.116]                   function(frame = 1L) {
[13:21:43.116]                     if (is.function(sendCondition)) 
[13:21:43.116]                       return(sendCondition)
[13:21:43.116]                     ns <- getNamespace("parallel")
[13:21:43.116]                     if (exists("sendData", mode = "function", 
[13:21:43.116]                       envir = ns)) {
[13:21:43.116]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:43.116]                         envir = ns)
[13:21:43.116]                       envir <- sys.frame(frame)
[13:21:43.116]                       master <- NULL
[13:21:43.116]                       while (!identical(envir, .GlobalEnv) && 
[13:21:43.116]                         !identical(envir, emptyenv())) {
[13:21:43.116]                         if (exists("master", mode = "list", envir = envir, 
[13:21:43.116]                           inherits = FALSE)) {
[13:21:43.116]                           master <- get("master", mode = "list", 
[13:21:43.116]                             envir = envir, inherits = FALSE)
[13:21:43.116]                           if (inherits(master, c("SOCKnode", 
[13:21:43.116]                             "SOCK0node"))) {
[13:21:43.116]                             sendCondition <<- function(cond) {
[13:21:43.116]                               data <- list(type = "VALUE", value = cond, 
[13:21:43.116]                                 success = TRUE)
[13:21:43.116]                               parallel_sendData(master, data)
[13:21:43.116]                             }
[13:21:43.116]                             return(sendCondition)
[13:21:43.116]                           }
[13:21:43.116]                         }
[13:21:43.116]                         frame <- frame + 1L
[13:21:43.116]                         envir <- sys.frame(frame)
[13:21:43.116]                       }
[13:21:43.116]                     }
[13:21:43.116]                     sendCondition <<- function(cond) NULL
[13:21:43.116]                   }
[13:21:43.116]                 })
[13:21:43.116]                 withCallingHandlers({
[13:21:43.116]                   NA
[13:21:43.116]                 }, immediateCondition = function(cond) {
[13:21:43.116]                   sendCondition <- ...future.makeSendCondition()
[13:21:43.116]                   sendCondition(cond)
[13:21:43.116]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:43.116]                   {
[13:21:43.116]                     inherits <- base::inherits
[13:21:43.116]                     invokeRestart <- base::invokeRestart
[13:21:43.116]                     is.null <- base::is.null
[13:21:43.116]                     muffled <- FALSE
[13:21:43.116]                     if (inherits(cond, "message")) {
[13:21:43.116]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:43.116]                       if (muffled) 
[13:21:43.116]                         invokeRestart("muffleMessage")
[13:21:43.116]                     }
[13:21:43.116]                     else if (inherits(cond, "warning")) {
[13:21:43.116]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:43.116]                       if (muffled) 
[13:21:43.116]                         invokeRestart("muffleWarning")
[13:21:43.116]                     }
[13:21:43.116]                     else if (inherits(cond, "condition")) {
[13:21:43.116]                       if (!is.null(pattern)) {
[13:21:43.116]                         computeRestarts <- base::computeRestarts
[13:21:43.116]                         grepl <- base::grepl
[13:21:43.116]                         restarts <- computeRestarts(cond)
[13:21:43.116]                         for (restart in restarts) {
[13:21:43.116]                           name <- restart$name
[13:21:43.116]                           if (is.null(name)) 
[13:21:43.116]                             next
[13:21:43.116]                           if (!grepl(pattern, name)) 
[13:21:43.116]                             next
[13:21:43.116]                           invokeRestart(restart)
[13:21:43.116]                           muffled <- TRUE
[13:21:43.116]                           break
[13:21:43.116]                         }
[13:21:43.116]                       }
[13:21:43.116]                     }
[13:21:43.116]                     invisible(muffled)
[13:21:43.116]                   }
[13:21:43.116]                   muffleCondition(cond)
[13:21:43.116]                 })
[13:21:43.116]             }))
[13:21:43.116]             future::FutureResult(value = ...future.value$value, 
[13:21:43.116]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:43.116]                   ...future.rng), globalenv = if (FALSE) 
[13:21:43.116]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:43.116]                     ...future.globalenv.names))
[13:21:43.116]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:43.116]         }, condition = base::local({
[13:21:43.116]             c <- base::c
[13:21:43.116]             inherits <- base::inherits
[13:21:43.116]             invokeRestart <- base::invokeRestart
[13:21:43.116]             length <- base::length
[13:21:43.116]             list <- base::list
[13:21:43.116]             seq.int <- base::seq.int
[13:21:43.116]             signalCondition <- base::signalCondition
[13:21:43.116]             sys.calls <- base::sys.calls
[13:21:43.116]             `[[` <- base::`[[`
[13:21:43.116]             `+` <- base::`+`
[13:21:43.116]             `<<-` <- base::`<<-`
[13:21:43.116]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:43.116]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:43.116]                   3L)]
[13:21:43.116]             }
[13:21:43.116]             function(cond) {
[13:21:43.116]                 is_error <- inherits(cond, "error")
[13:21:43.116]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:43.116]                   NULL)
[13:21:43.116]                 if (is_error) {
[13:21:43.116]                   sessionInformation <- function() {
[13:21:43.116]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:43.116]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:43.116]                       search = base::search(), system = base::Sys.info())
[13:21:43.116]                   }
[13:21:43.116]                   ...future.conditions[[length(...future.conditions) + 
[13:21:43.116]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:43.116]                     cond$call), session = sessionInformation(), 
[13:21:43.116]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:43.116]                   signalCondition(cond)
[13:21:43.116]                 }
[13:21:43.116]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:43.116]                 "immediateCondition"))) {
[13:21:43.116]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:43.116]                   ...future.conditions[[length(...future.conditions) + 
[13:21:43.116]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:43.116]                   if (TRUE && !signal) {
[13:21:43.116]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:43.116]                     {
[13:21:43.116]                       inherits <- base::inherits
[13:21:43.116]                       invokeRestart <- base::invokeRestart
[13:21:43.116]                       is.null <- base::is.null
[13:21:43.116]                       muffled <- FALSE
[13:21:43.116]                       if (inherits(cond, "message")) {
[13:21:43.116]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:43.116]                         if (muffled) 
[13:21:43.116]                           invokeRestart("muffleMessage")
[13:21:43.116]                       }
[13:21:43.116]                       else if (inherits(cond, "warning")) {
[13:21:43.116]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:43.116]                         if (muffled) 
[13:21:43.116]                           invokeRestart("muffleWarning")
[13:21:43.116]                       }
[13:21:43.116]                       else if (inherits(cond, "condition")) {
[13:21:43.116]                         if (!is.null(pattern)) {
[13:21:43.116]                           computeRestarts <- base::computeRestarts
[13:21:43.116]                           grepl <- base::grepl
[13:21:43.116]                           restarts <- computeRestarts(cond)
[13:21:43.116]                           for (restart in restarts) {
[13:21:43.116]                             name <- restart$name
[13:21:43.116]                             if (is.null(name)) 
[13:21:43.116]                               next
[13:21:43.116]                             if (!grepl(pattern, name)) 
[13:21:43.116]                               next
[13:21:43.116]                             invokeRestart(restart)
[13:21:43.116]                             muffled <- TRUE
[13:21:43.116]                             break
[13:21:43.116]                           }
[13:21:43.116]                         }
[13:21:43.116]                       }
[13:21:43.116]                       invisible(muffled)
[13:21:43.116]                     }
[13:21:43.116]                     muffleCondition(cond, pattern = "^muffle")
[13:21:43.116]                   }
[13:21:43.116]                 }
[13:21:43.116]                 else {
[13:21:43.116]                   if (TRUE) {
[13:21:43.116]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:43.116]                     {
[13:21:43.116]                       inherits <- base::inherits
[13:21:43.116]                       invokeRestart <- base::invokeRestart
[13:21:43.116]                       is.null <- base::is.null
[13:21:43.116]                       muffled <- FALSE
[13:21:43.116]                       if (inherits(cond, "message")) {
[13:21:43.116]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:43.116]                         if (muffled) 
[13:21:43.116]                           invokeRestart("muffleMessage")
[13:21:43.116]                       }
[13:21:43.116]                       else if (inherits(cond, "warning")) {
[13:21:43.116]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:43.116]                         if (muffled) 
[13:21:43.116]                           invokeRestart("muffleWarning")
[13:21:43.116]                       }
[13:21:43.116]                       else if (inherits(cond, "condition")) {
[13:21:43.116]                         if (!is.null(pattern)) {
[13:21:43.116]                           computeRestarts <- base::computeRestarts
[13:21:43.116]                           grepl <- base::grepl
[13:21:43.116]                           restarts <- computeRestarts(cond)
[13:21:43.116]                           for (restart in restarts) {
[13:21:43.116]                             name <- restart$name
[13:21:43.116]                             if (is.null(name)) 
[13:21:43.116]                               next
[13:21:43.116]                             if (!grepl(pattern, name)) 
[13:21:43.116]                               next
[13:21:43.116]                             invokeRestart(restart)
[13:21:43.116]                             muffled <- TRUE
[13:21:43.116]                             break
[13:21:43.116]                           }
[13:21:43.116]                         }
[13:21:43.116]                       }
[13:21:43.116]                       invisible(muffled)
[13:21:43.116]                     }
[13:21:43.116]                     muffleCondition(cond, pattern = "^muffle")
[13:21:43.116]                   }
[13:21:43.116]                 }
[13:21:43.116]             }
[13:21:43.116]         }))
[13:21:43.116]     }, error = function(ex) {
[13:21:43.116]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:43.116]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:43.116]                 ...future.rng), started = ...future.startTime, 
[13:21:43.116]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:43.116]             version = "1.8"), class = "FutureResult")
[13:21:43.116]     }, finally = {
[13:21:43.116]         if (!identical(...future.workdir, getwd())) 
[13:21:43.116]             setwd(...future.workdir)
[13:21:43.116]         {
[13:21:43.116]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:43.116]                 ...future.oldOptions$nwarnings <- NULL
[13:21:43.116]             }
[13:21:43.116]             base::options(...future.oldOptions)
[13:21:43.116]             if (.Platform$OS.type == "windows") {
[13:21:43.116]                 old_names <- names(...future.oldEnvVars)
[13:21:43.116]                 envs <- base::Sys.getenv()
[13:21:43.116]                 names <- names(envs)
[13:21:43.116]                 common <- intersect(names, old_names)
[13:21:43.116]                 added <- setdiff(names, old_names)
[13:21:43.116]                 removed <- setdiff(old_names, names)
[13:21:43.116]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:43.116]                   envs[common]]
[13:21:43.116]                 NAMES <- toupper(changed)
[13:21:43.116]                 args <- list()
[13:21:43.116]                 for (kk in seq_along(NAMES)) {
[13:21:43.116]                   name <- changed[[kk]]
[13:21:43.116]                   NAME <- NAMES[[kk]]
[13:21:43.116]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:43.116]                     next
[13:21:43.116]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:43.116]                 }
[13:21:43.116]                 NAMES <- toupper(added)
[13:21:43.116]                 for (kk in seq_along(NAMES)) {
[13:21:43.116]                   name <- added[[kk]]
[13:21:43.116]                   NAME <- NAMES[[kk]]
[13:21:43.116]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:43.116]                     next
[13:21:43.116]                   args[[name]] <- ""
[13:21:43.116]                 }
[13:21:43.116]                 NAMES <- toupper(removed)
[13:21:43.116]                 for (kk in seq_along(NAMES)) {
[13:21:43.116]                   name <- removed[[kk]]
[13:21:43.116]                   NAME <- NAMES[[kk]]
[13:21:43.116]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:43.116]                     next
[13:21:43.116]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:43.116]                 }
[13:21:43.116]                 if (length(args) > 0) 
[13:21:43.116]                   base::do.call(base::Sys.setenv, args = args)
[13:21:43.116]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:43.116]             }
[13:21:43.116]             else {
[13:21:43.116]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:43.116]             }
[13:21:43.116]             {
[13:21:43.116]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:43.116]                   0L) {
[13:21:43.116]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:43.116]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:43.116]                   base::options(opts)
[13:21:43.116]                 }
[13:21:43.116]                 {
[13:21:43.116]                   {
[13:21:43.116]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:43.116]                     NULL
[13:21:43.116]                   }
[13:21:43.116]                   options(future.plan = NULL)
[13:21:43.116]                   if (is.na(NA_character_)) 
[13:21:43.116]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:43.116]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:43.116]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:43.116]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:43.116]                     envir = parent.frame()) 
[13:21:43.116]                   {
[13:21:43.116]                     if (is.function(workers)) 
[13:21:43.116]                       workers <- workers()
[13:21:43.116]                     workers <- structure(as.integer(workers), 
[13:21:43.116]                       class = class(workers))
[13:21:43.116]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:43.116]                       workers >= 1)
[13:21:43.116]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:43.116]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:43.116]                     }
[13:21:43.116]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:43.116]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:43.116]                       envir = envir)
[13:21:43.116]                     if (!future$lazy) 
[13:21:43.116]                       future <- run(future)
[13:21:43.116]                     invisible(future)
[13:21:43.116]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:43.116]                 }
[13:21:43.116]             }
[13:21:43.116]         }
[13:21:43.116]     })
[13:21:43.116]     if (TRUE) {
[13:21:43.116]         base::sink(type = "output", split = FALSE)
[13:21:43.116]         if (TRUE) {
[13:21:43.116]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:43.116]         }
[13:21:43.116]         else {
[13:21:43.116]             ...future.result["stdout"] <- base::list(NULL)
[13:21:43.116]         }
[13:21:43.116]         base::close(...future.stdout)
[13:21:43.116]         ...future.stdout <- NULL
[13:21:43.116]     }
[13:21:43.116]     ...future.result$conditions <- ...future.conditions
[13:21:43.116]     ...future.result$finished <- base::Sys.time()
[13:21:43.116]     ...future.result
[13:21:43.116] }
[13:21:43.189] MultisessionFuture started
[13:21:43.189] result() for ClusterFuture ...
[13:21:43.190] receiveMessageFromWorker() for ClusterFuture ...
[13:21:43.190] - Validating connection of MultisessionFuture
[13:21:43.223] - received message: FutureResult
[13:21:43.223] - Received FutureResult
[13:21:43.223] - Erased future from FutureRegistry
[13:21:43.223] result() for ClusterFuture ...
[13:21:43.223] - result already collected: FutureResult
[13:21:43.224] result() for ClusterFuture ... done
[13:21:43.224] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:43.224] result() for ClusterFuture ... done
[13:21:43.224] result() for ClusterFuture ...
[13:21:43.224] - result already collected: FutureResult
[13:21:43.224] result() for ClusterFuture ... done
[13:21:43.224] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:21:43.228] plan(): nbrOfWorkers() = 2
*** resolve() for Future objects ...
- result = FALSE, recursive = FALSE ...
[13:21:43.232] getGlobalsAndPackages() ...
[13:21:43.232] Searching for globals...
[13:21:43.233] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:21:43.233] Searching for globals ... DONE
[13:21:43.233] Resolving globals: FALSE
[13:21:43.234] 
[13:21:43.234] 
[13:21:43.234] getGlobalsAndPackages() ... DONE
[13:21:43.234] run() for ‘Future’ ...
[13:21:43.235] - state: ‘created’
[13:21:43.235] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:43.250] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:43.250] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:43.250]   - Field: ‘node’
[13:21:43.250]   - Field: ‘label’
[13:21:43.250]   - Field: ‘local’
[13:21:43.251]   - Field: ‘owner’
[13:21:43.251]   - Field: ‘envir’
[13:21:43.251]   - Field: ‘workers’
[13:21:43.251]   - Field: ‘packages’
[13:21:43.251]   - Field: ‘gc’
[13:21:43.251]   - Field: ‘conditions’
[13:21:43.251]   - Field: ‘persistent’
[13:21:43.251]   - Field: ‘expr’
[13:21:43.251]   - Field: ‘uuid’
[13:21:43.251]   - Field: ‘seed’
[13:21:43.252]   - Field: ‘version’
[13:21:43.252]   - Field: ‘result’
[13:21:43.252]   - Field: ‘asynchronous’
[13:21:43.252]   - Field: ‘calls’
[13:21:43.252]   - Field: ‘globals’
[13:21:43.252]   - Field: ‘stdout’
[13:21:43.252]   - Field: ‘earlySignal’
[13:21:43.252]   - Field: ‘lazy’
[13:21:43.253]   - Field: ‘state’
[13:21:43.253] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:43.253] - Launch lazy future ...
[13:21:43.253] Packages needed by the future expression (n = 0): <none>
[13:21:43.253] Packages needed by future strategies (n = 0): <none>
[13:21:43.254] {
[13:21:43.254]     {
[13:21:43.254]         {
[13:21:43.254]             ...future.startTime <- base::Sys.time()
[13:21:43.254]             {
[13:21:43.254]                 {
[13:21:43.254]                   {
[13:21:43.254]                     {
[13:21:43.254]                       base::local({
[13:21:43.254]                         has_future <- base::requireNamespace("future", 
[13:21:43.254]                           quietly = TRUE)
[13:21:43.254]                         if (has_future) {
[13:21:43.254]                           ns <- base::getNamespace("future")
[13:21:43.254]                           version <- ns[[".package"]][["version"]]
[13:21:43.254]                           if (is.null(version)) 
[13:21:43.254]                             version <- utils::packageVersion("future")
[13:21:43.254]                         }
[13:21:43.254]                         else {
[13:21:43.254]                           version <- NULL
[13:21:43.254]                         }
[13:21:43.254]                         if (!has_future || version < "1.8.0") {
[13:21:43.254]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:43.254]                             "", base::R.version$version.string), 
[13:21:43.254]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:43.254]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:43.254]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:43.254]                               "release", "version")], collapse = " "), 
[13:21:43.254]                             hostname = base::Sys.info()[["nodename"]])
[13:21:43.254]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:43.254]                             info)
[13:21:43.254]                           info <- base::paste(info, collapse = "; ")
[13:21:43.254]                           if (!has_future) {
[13:21:43.254]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:43.254]                               info)
[13:21:43.254]                           }
[13:21:43.254]                           else {
[13:21:43.254]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:43.254]                               info, version)
[13:21:43.254]                           }
[13:21:43.254]                           base::stop(msg)
[13:21:43.254]                         }
[13:21:43.254]                       })
[13:21:43.254]                     }
[13:21:43.254]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:43.254]                     base::options(mc.cores = 1L)
[13:21:43.254]                   }
[13:21:43.254]                   options(future.plan = NULL)
[13:21:43.254]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:43.254]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:43.254]                 }
[13:21:43.254]                 ...future.workdir <- getwd()
[13:21:43.254]             }
[13:21:43.254]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:43.254]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:43.254]         }
[13:21:43.254]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:43.254]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:43.254]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:43.254]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:43.254]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:43.254]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:43.254]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:43.254]             base::names(...future.oldOptions))
[13:21:43.254]     }
[13:21:43.254]     if (FALSE) {
[13:21:43.254]     }
[13:21:43.254]     else {
[13:21:43.254]         if (TRUE) {
[13:21:43.254]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:43.254]                 open = "w")
[13:21:43.254]         }
[13:21:43.254]         else {
[13:21:43.254]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:43.254]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:43.254]         }
[13:21:43.254]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:43.254]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:43.254]             base::sink(type = "output", split = FALSE)
[13:21:43.254]             base::close(...future.stdout)
[13:21:43.254]         }, add = TRUE)
[13:21:43.254]     }
[13:21:43.254]     ...future.frame <- base::sys.nframe()
[13:21:43.254]     ...future.conditions <- base::list()
[13:21:43.254]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:43.254]     if (FALSE) {
[13:21:43.254]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:43.254]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:43.254]     }
[13:21:43.254]     ...future.result <- base::tryCatch({
[13:21:43.254]         base::withCallingHandlers({
[13:21:43.254]             ...future.value <- base::withVisible(base::local({
[13:21:43.254]                 ...future.makeSendCondition <- local({
[13:21:43.254]                   sendCondition <- NULL
[13:21:43.254]                   function(frame = 1L) {
[13:21:43.254]                     if (is.function(sendCondition)) 
[13:21:43.254]                       return(sendCondition)
[13:21:43.254]                     ns <- getNamespace("parallel")
[13:21:43.254]                     if (exists("sendData", mode = "function", 
[13:21:43.254]                       envir = ns)) {
[13:21:43.254]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:43.254]                         envir = ns)
[13:21:43.254]                       envir <- sys.frame(frame)
[13:21:43.254]                       master <- NULL
[13:21:43.254]                       while (!identical(envir, .GlobalEnv) && 
[13:21:43.254]                         !identical(envir, emptyenv())) {
[13:21:43.254]                         if (exists("master", mode = "list", envir = envir, 
[13:21:43.254]                           inherits = FALSE)) {
[13:21:43.254]                           master <- get("master", mode = "list", 
[13:21:43.254]                             envir = envir, inherits = FALSE)
[13:21:43.254]                           if (inherits(master, c("SOCKnode", 
[13:21:43.254]                             "SOCK0node"))) {
[13:21:43.254]                             sendCondition <<- function(cond) {
[13:21:43.254]                               data <- list(type = "VALUE", value = cond, 
[13:21:43.254]                                 success = TRUE)
[13:21:43.254]                               parallel_sendData(master, data)
[13:21:43.254]                             }
[13:21:43.254]                             return(sendCondition)
[13:21:43.254]                           }
[13:21:43.254]                         }
[13:21:43.254]                         frame <- frame + 1L
[13:21:43.254]                         envir <- sys.frame(frame)
[13:21:43.254]                       }
[13:21:43.254]                     }
[13:21:43.254]                     sendCondition <<- function(cond) NULL
[13:21:43.254]                   }
[13:21:43.254]                 })
[13:21:43.254]                 withCallingHandlers({
[13:21:43.254]                   {
[13:21:43.254]                     Sys.sleep(0.5)
[13:21:43.254]                     list(a = 1, b = 42L)
[13:21:43.254]                   }
[13:21:43.254]                 }, immediateCondition = function(cond) {
[13:21:43.254]                   sendCondition <- ...future.makeSendCondition()
[13:21:43.254]                   sendCondition(cond)
[13:21:43.254]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:43.254]                   {
[13:21:43.254]                     inherits <- base::inherits
[13:21:43.254]                     invokeRestart <- base::invokeRestart
[13:21:43.254]                     is.null <- base::is.null
[13:21:43.254]                     muffled <- FALSE
[13:21:43.254]                     if (inherits(cond, "message")) {
[13:21:43.254]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:43.254]                       if (muffled) 
[13:21:43.254]                         invokeRestart("muffleMessage")
[13:21:43.254]                     }
[13:21:43.254]                     else if (inherits(cond, "warning")) {
[13:21:43.254]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:43.254]                       if (muffled) 
[13:21:43.254]                         invokeRestart("muffleWarning")
[13:21:43.254]                     }
[13:21:43.254]                     else if (inherits(cond, "condition")) {
[13:21:43.254]                       if (!is.null(pattern)) {
[13:21:43.254]                         computeRestarts <- base::computeRestarts
[13:21:43.254]                         grepl <- base::grepl
[13:21:43.254]                         restarts <- computeRestarts(cond)
[13:21:43.254]                         for (restart in restarts) {
[13:21:43.254]                           name <- restart$name
[13:21:43.254]                           if (is.null(name)) 
[13:21:43.254]                             next
[13:21:43.254]                           if (!grepl(pattern, name)) 
[13:21:43.254]                             next
[13:21:43.254]                           invokeRestart(restart)
[13:21:43.254]                           muffled <- TRUE
[13:21:43.254]                           break
[13:21:43.254]                         }
[13:21:43.254]                       }
[13:21:43.254]                     }
[13:21:43.254]                     invisible(muffled)
[13:21:43.254]                   }
[13:21:43.254]                   muffleCondition(cond)
[13:21:43.254]                 })
[13:21:43.254]             }))
[13:21:43.254]             future::FutureResult(value = ...future.value$value, 
[13:21:43.254]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:43.254]                   ...future.rng), globalenv = if (FALSE) 
[13:21:43.254]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:43.254]                     ...future.globalenv.names))
[13:21:43.254]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:43.254]         }, condition = base::local({
[13:21:43.254]             c <- base::c
[13:21:43.254]             inherits <- base::inherits
[13:21:43.254]             invokeRestart <- base::invokeRestart
[13:21:43.254]             length <- base::length
[13:21:43.254]             list <- base::list
[13:21:43.254]             seq.int <- base::seq.int
[13:21:43.254]             signalCondition <- base::signalCondition
[13:21:43.254]             sys.calls <- base::sys.calls
[13:21:43.254]             `[[` <- base::`[[`
[13:21:43.254]             `+` <- base::`+`
[13:21:43.254]             `<<-` <- base::`<<-`
[13:21:43.254]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:43.254]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:43.254]                   3L)]
[13:21:43.254]             }
[13:21:43.254]             function(cond) {
[13:21:43.254]                 is_error <- inherits(cond, "error")
[13:21:43.254]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:43.254]                   NULL)
[13:21:43.254]                 if (is_error) {
[13:21:43.254]                   sessionInformation <- function() {
[13:21:43.254]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:43.254]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:43.254]                       search = base::search(), system = base::Sys.info())
[13:21:43.254]                   }
[13:21:43.254]                   ...future.conditions[[length(...future.conditions) + 
[13:21:43.254]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:43.254]                     cond$call), session = sessionInformation(), 
[13:21:43.254]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:43.254]                   signalCondition(cond)
[13:21:43.254]                 }
[13:21:43.254]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:43.254]                 "immediateCondition"))) {
[13:21:43.254]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:43.254]                   ...future.conditions[[length(...future.conditions) + 
[13:21:43.254]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:43.254]                   if (TRUE && !signal) {
[13:21:43.254]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:43.254]                     {
[13:21:43.254]                       inherits <- base::inherits
[13:21:43.254]                       invokeRestart <- base::invokeRestart
[13:21:43.254]                       is.null <- base::is.null
[13:21:43.254]                       muffled <- FALSE
[13:21:43.254]                       if (inherits(cond, "message")) {
[13:21:43.254]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:43.254]                         if (muffled) 
[13:21:43.254]                           invokeRestart("muffleMessage")
[13:21:43.254]                       }
[13:21:43.254]                       else if (inherits(cond, "warning")) {
[13:21:43.254]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:43.254]                         if (muffled) 
[13:21:43.254]                           invokeRestart("muffleWarning")
[13:21:43.254]                       }
[13:21:43.254]                       else if (inherits(cond, "condition")) {
[13:21:43.254]                         if (!is.null(pattern)) {
[13:21:43.254]                           computeRestarts <- base::computeRestarts
[13:21:43.254]                           grepl <- base::grepl
[13:21:43.254]                           restarts <- computeRestarts(cond)
[13:21:43.254]                           for (restart in restarts) {
[13:21:43.254]                             name <- restart$name
[13:21:43.254]                             if (is.null(name)) 
[13:21:43.254]                               next
[13:21:43.254]                             if (!grepl(pattern, name)) 
[13:21:43.254]                               next
[13:21:43.254]                             invokeRestart(restart)
[13:21:43.254]                             muffled <- TRUE
[13:21:43.254]                             break
[13:21:43.254]                           }
[13:21:43.254]                         }
[13:21:43.254]                       }
[13:21:43.254]                       invisible(muffled)
[13:21:43.254]                     }
[13:21:43.254]                     muffleCondition(cond, pattern = "^muffle")
[13:21:43.254]                   }
[13:21:43.254]                 }
[13:21:43.254]                 else {
[13:21:43.254]                   if (TRUE) {
[13:21:43.254]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:43.254]                     {
[13:21:43.254]                       inherits <- base::inherits
[13:21:43.254]                       invokeRestart <- base::invokeRestart
[13:21:43.254]                       is.null <- base::is.null
[13:21:43.254]                       muffled <- FALSE
[13:21:43.254]                       if (inherits(cond, "message")) {
[13:21:43.254]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:43.254]                         if (muffled) 
[13:21:43.254]                           invokeRestart("muffleMessage")
[13:21:43.254]                       }
[13:21:43.254]                       else if (inherits(cond, "warning")) {
[13:21:43.254]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:43.254]                         if (muffled) 
[13:21:43.254]                           invokeRestart("muffleWarning")
[13:21:43.254]                       }
[13:21:43.254]                       else if (inherits(cond, "condition")) {
[13:21:43.254]                         if (!is.null(pattern)) {
[13:21:43.254]                           computeRestarts <- base::computeRestarts
[13:21:43.254]                           grepl <- base::grepl
[13:21:43.254]                           restarts <- computeRestarts(cond)
[13:21:43.254]                           for (restart in restarts) {
[13:21:43.254]                             name <- restart$name
[13:21:43.254]                             if (is.null(name)) 
[13:21:43.254]                               next
[13:21:43.254]                             if (!grepl(pattern, name)) 
[13:21:43.254]                               next
[13:21:43.254]                             invokeRestart(restart)
[13:21:43.254]                             muffled <- TRUE
[13:21:43.254]                             break
[13:21:43.254]                           }
[13:21:43.254]                         }
[13:21:43.254]                       }
[13:21:43.254]                       invisible(muffled)
[13:21:43.254]                     }
[13:21:43.254]                     muffleCondition(cond, pattern = "^muffle")
[13:21:43.254]                   }
[13:21:43.254]                 }
[13:21:43.254]             }
[13:21:43.254]         }))
[13:21:43.254]     }, error = function(ex) {
[13:21:43.254]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:43.254]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:43.254]                 ...future.rng), started = ...future.startTime, 
[13:21:43.254]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:43.254]             version = "1.8"), class = "FutureResult")
[13:21:43.254]     }, finally = {
[13:21:43.254]         if (!identical(...future.workdir, getwd())) 
[13:21:43.254]             setwd(...future.workdir)
[13:21:43.254]         {
[13:21:43.254]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:43.254]                 ...future.oldOptions$nwarnings <- NULL
[13:21:43.254]             }
[13:21:43.254]             base::options(...future.oldOptions)
[13:21:43.254]             if (.Platform$OS.type == "windows") {
[13:21:43.254]                 old_names <- names(...future.oldEnvVars)
[13:21:43.254]                 envs <- base::Sys.getenv()
[13:21:43.254]                 names <- names(envs)
[13:21:43.254]                 common <- intersect(names, old_names)
[13:21:43.254]                 added <- setdiff(names, old_names)
[13:21:43.254]                 removed <- setdiff(old_names, names)
[13:21:43.254]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:43.254]                   envs[common]]
[13:21:43.254]                 NAMES <- toupper(changed)
[13:21:43.254]                 args <- list()
[13:21:43.254]                 for (kk in seq_along(NAMES)) {
[13:21:43.254]                   name <- changed[[kk]]
[13:21:43.254]                   NAME <- NAMES[[kk]]
[13:21:43.254]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:43.254]                     next
[13:21:43.254]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:43.254]                 }
[13:21:43.254]                 NAMES <- toupper(added)
[13:21:43.254]                 for (kk in seq_along(NAMES)) {
[13:21:43.254]                   name <- added[[kk]]
[13:21:43.254]                   NAME <- NAMES[[kk]]
[13:21:43.254]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:43.254]                     next
[13:21:43.254]                   args[[name]] <- ""
[13:21:43.254]                 }
[13:21:43.254]                 NAMES <- toupper(removed)
[13:21:43.254]                 for (kk in seq_along(NAMES)) {
[13:21:43.254]                   name <- removed[[kk]]
[13:21:43.254]                   NAME <- NAMES[[kk]]
[13:21:43.254]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:43.254]                     next
[13:21:43.254]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:43.254]                 }
[13:21:43.254]                 if (length(args) > 0) 
[13:21:43.254]                   base::do.call(base::Sys.setenv, args = args)
[13:21:43.254]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:43.254]             }
[13:21:43.254]             else {
[13:21:43.254]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:43.254]             }
[13:21:43.254]             {
[13:21:43.254]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:43.254]                   0L) {
[13:21:43.254]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:43.254]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:43.254]                   base::options(opts)
[13:21:43.254]                 }
[13:21:43.254]                 {
[13:21:43.254]                   {
[13:21:43.254]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:43.254]                     NULL
[13:21:43.254]                   }
[13:21:43.254]                   options(future.plan = NULL)
[13:21:43.254]                   if (is.na(NA_character_)) 
[13:21:43.254]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:43.254]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:43.254]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:43.254]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:43.254]                     envir = parent.frame()) 
[13:21:43.254]                   {
[13:21:43.254]                     if (is.function(workers)) 
[13:21:43.254]                       workers <- workers()
[13:21:43.254]                     workers <- structure(as.integer(workers), 
[13:21:43.254]                       class = class(workers))
[13:21:43.254]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:43.254]                       workers >= 1)
[13:21:43.254]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:43.254]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:43.254]                     }
[13:21:43.254]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:43.254]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:43.254]                       envir = envir)
[13:21:43.254]                     if (!future$lazy) 
[13:21:43.254]                       future <- run(future)
[13:21:43.254]                     invisible(future)
[13:21:43.254]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:43.254]                 }
[13:21:43.254]             }
[13:21:43.254]         }
[13:21:43.254]     })
[13:21:43.254]     if (TRUE) {
[13:21:43.254]         base::sink(type = "output", split = FALSE)
[13:21:43.254]         if (TRUE) {
[13:21:43.254]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:43.254]         }
[13:21:43.254]         else {
[13:21:43.254]             ...future.result["stdout"] <- base::list(NULL)
[13:21:43.254]         }
[13:21:43.254]         base::close(...future.stdout)
[13:21:43.254]         ...future.stdout <- NULL
[13:21:43.254]     }
[13:21:43.254]     ...future.result$conditions <- ...future.conditions
[13:21:43.254]     ...future.result$finished <- base::Sys.time()
[13:21:43.254]     ...future.result
[13:21:43.254] }
[13:21:43.258] MultisessionFuture started
[13:21:43.258] - Launch lazy future ... done
[13:21:43.258] run() for ‘MultisessionFuture’ ... done
[13:21:43.807] receiveMessageFromWorker() for ClusterFuture ...
[13:21:43.807] - Validating connection of MultisessionFuture
[13:21:43.807] - received message: FutureResult
[13:21:43.807] - Received FutureResult
[13:21:43.808] - Erased future from FutureRegistry
[13:21:43.808] result() for ClusterFuture ...
[13:21:43.808] - result already collected: FutureResult
[13:21:43.808] result() for ClusterFuture ... done
[13:21:43.808] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:43.808] A MultisessionFuture was resolved (result was not collected)
[13:21:43.808] getGlobalsAndPackages() ...
[13:21:43.808] Searching for globals...
[13:21:43.810] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:21:43.810] Searching for globals ... DONE
[13:21:43.810] Resolving globals: FALSE
[13:21:43.810] 
[13:21:43.811] 
[13:21:43.811] getGlobalsAndPackages() ... DONE
[13:21:43.811] run() for ‘Future’ ...
[13:21:43.811] - state: ‘created’
[13:21:43.811] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:43.826] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:43.826] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:43.827]   - Field: ‘node’
[13:21:43.827]   - Field: ‘label’
[13:21:43.827]   - Field: ‘local’
[13:21:43.827]   - Field: ‘owner’
[13:21:43.827]   - Field: ‘envir’
[13:21:43.827]   - Field: ‘workers’
[13:21:43.827]   - Field: ‘packages’
[13:21:43.827]   - Field: ‘gc’
[13:21:43.827]   - Field: ‘conditions’
[13:21:43.827]   - Field: ‘persistent’
[13:21:43.828]   - Field: ‘expr’
[13:21:43.828]   - Field: ‘uuid’
[13:21:43.828]   - Field: ‘seed’
[13:21:43.828]   - Field: ‘version’
[13:21:43.828]   - Field: ‘result’
[13:21:43.828]   - Field: ‘asynchronous’
[13:21:43.828]   - Field: ‘calls’
[13:21:43.828]   - Field: ‘globals’
[13:21:43.829]   - Field: ‘stdout’
[13:21:43.829]   - Field: ‘earlySignal’
[13:21:43.829]   - Field: ‘lazy’
[13:21:43.829]   - Field: ‘state’
[13:21:43.829] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:43.829] - Launch lazy future ...
[13:21:43.829] Packages needed by the future expression (n = 0): <none>
[13:21:43.830] Packages needed by future strategies (n = 0): <none>
[13:21:43.830] {
[13:21:43.830]     {
[13:21:43.830]         {
[13:21:43.830]             ...future.startTime <- base::Sys.time()
[13:21:43.830]             {
[13:21:43.830]                 {
[13:21:43.830]                   {
[13:21:43.830]                     {
[13:21:43.830]                       base::local({
[13:21:43.830]                         has_future <- base::requireNamespace("future", 
[13:21:43.830]                           quietly = TRUE)
[13:21:43.830]                         if (has_future) {
[13:21:43.830]                           ns <- base::getNamespace("future")
[13:21:43.830]                           version <- ns[[".package"]][["version"]]
[13:21:43.830]                           if (is.null(version)) 
[13:21:43.830]                             version <- utils::packageVersion("future")
[13:21:43.830]                         }
[13:21:43.830]                         else {
[13:21:43.830]                           version <- NULL
[13:21:43.830]                         }
[13:21:43.830]                         if (!has_future || version < "1.8.0") {
[13:21:43.830]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:43.830]                             "", base::R.version$version.string), 
[13:21:43.830]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:43.830]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:43.830]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:43.830]                               "release", "version")], collapse = " "), 
[13:21:43.830]                             hostname = base::Sys.info()[["nodename"]])
[13:21:43.830]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:43.830]                             info)
[13:21:43.830]                           info <- base::paste(info, collapse = "; ")
[13:21:43.830]                           if (!has_future) {
[13:21:43.830]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:43.830]                               info)
[13:21:43.830]                           }
[13:21:43.830]                           else {
[13:21:43.830]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:43.830]                               info, version)
[13:21:43.830]                           }
[13:21:43.830]                           base::stop(msg)
[13:21:43.830]                         }
[13:21:43.830]                       })
[13:21:43.830]                     }
[13:21:43.830]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:43.830]                     base::options(mc.cores = 1L)
[13:21:43.830]                   }
[13:21:43.830]                   options(future.plan = NULL)
[13:21:43.830]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:43.830]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:43.830]                 }
[13:21:43.830]                 ...future.workdir <- getwd()
[13:21:43.830]             }
[13:21:43.830]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:43.830]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:43.830]         }
[13:21:43.830]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:43.830]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:43.830]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:43.830]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:43.830]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:43.830]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:43.830]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:43.830]             base::names(...future.oldOptions))
[13:21:43.830]     }
[13:21:43.830]     if (FALSE) {
[13:21:43.830]     }
[13:21:43.830]     else {
[13:21:43.830]         if (TRUE) {
[13:21:43.830]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:43.830]                 open = "w")
[13:21:43.830]         }
[13:21:43.830]         else {
[13:21:43.830]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:43.830]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:43.830]         }
[13:21:43.830]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:43.830]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:43.830]             base::sink(type = "output", split = FALSE)
[13:21:43.830]             base::close(...future.stdout)
[13:21:43.830]         }, add = TRUE)
[13:21:43.830]     }
[13:21:43.830]     ...future.frame <- base::sys.nframe()
[13:21:43.830]     ...future.conditions <- base::list()
[13:21:43.830]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:43.830]     if (FALSE) {
[13:21:43.830]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:43.830]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:43.830]     }
[13:21:43.830]     ...future.result <- base::tryCatch({
[13:21:43.830]         base::withCallingHandlers({
[13:21:43.830]             ...future.value <- base::withVisible(base::local({
[13:21:43.830]                 ...future.makeSendCondition <- local({
[13:21:43.830]                   sendCondition <- NULL
[13:21:43.830]                   function(frame = 1L) {
[13:21:43.830]                     if (is.function(sendCondition)) 
[13:21:43.830]                       return(sendCondition)
[13:21:43.830]                     ns <- getNamespace("parallel")
[13:21:43.830]                     if (exists("sendData", mode = "function", 
[13:21:43.830]                       envir = ns)) {
[13:21:43.830]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:43.830]                         envir = ns)
[13:21:43.830]                       envir <- sys.frame(frame)
[13:21:43.830]                       master <- NULL
[13:21:43.830]                       while (!identical(envir, .GlobalEnv) && 
[13:21:43.830]                         !identical(envir, emptyenv())) {
[13:21:43.830]                         if (exists("master", mode = "list", envir = envir, 
[13:21:43.830]                           inherits = FALSE)) {
[13:21:43.830]                           master <- get("master", mode = "list", 
[13:21:43.830]                             envir = envir, inherits = FALSE)
[13:21:43.830]                           if (inherits(master, c("SOCKnode", 
[13:21:43.830]                             "SOCK0node"))) {
[13:21:43.830]                             sendCondition <<- function(cond) {
[13:21:43.830]                               data <- list(type = "VALUE", value = cond, 
[13:21:43.830]                                 success = TRUE)
[13:21:43.830]                               parallel_sendData(master, data)
[13:21:43.830]                             }
[13:21:43.830]                             return(sendCondition)
[13:21:43.830]                           }
[13:21:43.830]                         }
[13:21:43.830]                         frame <- frame + 1L
[13:21:43.830]                         envir <- sys.frame(frame)
[13:21:43.830]                       }
[13:21:43.830]                     }
[13:21:43.830]                     sendCondition <<- function(cond) NULL
[13:21:43.830]                   }
[13:21:43.830]                 })
[13:21:43.830]                 withCallingHandlers({
[13:21:43.830]                   {
[13:21:43.830]                     Sys.sleep(0.5)
[13:21:43.830]                     list(a = 1, b = 42L)
[13:21:43.830]                   }
[13:21:43.830]                 }, immediateCondition = function(cond) {
[13:21:43.830]                   sendCondition <- ...future.makeSendCondition()
[13:21:43.830]                   sendCondition(cond)
[13:21:43.830]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:43.830]                   {
[13:21:43.830]                     inherits <- base::inherits
[13:21:43.830]                     invokeRestart <- base::invokeRestart
[13:21:43.830]                     is.null <- base::is.null
[13:21:43.830]                     muffled <- FALSE
[13:21:43.830]                     if (inherits(cond, "message")) {
[13:21:43.830]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:43.830]                       if (muffled) 
[13:21:43.830]                         invokeRestart("muffleMessage")
[13:21:43.830]                     }
[13:21:43.830]                     else if (inherits(cond, "warning")) {
[13:21:43.830]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:43.830]                       if (muffled) 
[13:21:43.830]                         invokeRestart("muffleWarning")
[13:21:43.830]                     }
[13:21:43.830]                     else if (inherits(cond, "condition")) {
[13:21:43.830]                       if (!is.null(pattern)) {
[13:21:43.830]                         computeRestarts <- base::computeRestarts
[13:21:43.830]                         grepl <- base::grepl
[13:21:43.830]                         restarts <- computeRestarts(cond)
[13:21:43.830]                         for (restart in restarts) {
[13:21:43.830]                           name <- restart$name
[13:21:43.830]                           if (is.null(name)) 
[13:21:43.830]                             next
[13:21:43.830]                           if (!grepl(pattern, name)) 
[13:21:43.830]                             next
[13:21:43.830]                           invokeRestart(restart)
[13:21:43.830]                           muffled <- TRUE
[13:21:43.830]                           break
[13:21:43.830]                         }
[13:21:43.830]                       }
[13:21:43.830]                     }
[13:21:43.830]                     invisible(muffled)
[13:21:43.830]                   }
[13:21:43.830]                   muffleCondition(cond)
[13:21:43.830]                 })
[13:21:43.830]             }))
[13:21:43.830]             future::FutureResult(value = ...future.value$value, 
[13:21:43.830]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:43.830]                   ...future.rng), globalenv = if (FALSE) 
[13:21:43.830]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:43.830]                     ...future.globalenv.names))
[13:21:43.830]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:43.830]         }, condition = base::local({
[13:21:43.830]             c <- base::c
[13:21:43.830]             inherits <- base::inherits
[13:21:43.830]             invokeRestart <- base::invokeRestart
[13:21:43.830]             length <- base::length
[13:21:43.830]             list <- base::list
[13:21:43.830]             seq.int <- base::seq.int
[13:21:43.830]             signalCondition <- base::signalCondition
[13:21:43.830]             sys.calls <- base::sys.calls
[13:21:43.830]             `[[` <- base::`[[`
[13:21:43.830]             `+` <- base::`+`
[13:21:43.830]             `<<-` <- base::`<<-`
[13:21:43.830]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:43.830]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:43.830]                   3L)]
[13:21:43.830]             }
[13:21:43.830]             function(cond) {
[13:21:43.830]                 is_error <- inherits(cond, "error")
[13:21:43.830]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:43.830]                   NULL)
[13:21:43.830]                 if (is_error) {
[13:21:43.830]                   sessionInformation <- function() {
[13:21:43.830]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:43.830]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:43.830]                       search = base::search(), system = base::Sys.info())
[13:21:43.830]                   }
[13:21:43.830]                   ...future.conditions[[length(...future.conditions) + 
[13:21:43.830]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:43.830]                     cond$call), session = sessionInformation(), 
[13:21:43.830]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:43.830]                   signalCondition(cond)
[13:21:43.830]                 }
[13:21:43.830]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:43.830]                 "immediateCondition"))) {
[13:21:43.830]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:43.830]                   ...future.conditions[[length(...future.conditions) + 
[13:21:43.830]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:43.830]                   if (TRUE && !signal) {
[13:21:43.830]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:43.830]                     {
[13:21:43.830]                       inherits <- base::inherits
[13:21:43.830]                       invokeRestart <- base::invokeRestart
[13:21:43.830]                       is.null <- base::is.null
[13:21:43.830]                       muffled <- FALSE
[13:21:43.830]                       if (inherits(cond, "message")) {
[13:21:43.830]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:43.830]                         if (muffled) 
[13:21:43.830]                           invokeRestart("muffleMessage")
[13:21:43.830]                       }
[13:21:43.830]                       else if (inherits(cond, "warning")) {
[13:21:43.830]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:43.830]                         if (muffled) 
[13:21:43.830]                           invokeRestart("muffleWarning")
[13:21:43.830]                       }
[13:21:43.830]                       else if (inherits(cond, "condition")) {
[13:21:43.830]                         if (!is.null(pattern)) {
[13:21:43.830]                           computeRestarts <- base::computeRestarts
[13:21:43.830]                           grepl <- base::grepl
[13:21:43.830]                           restarts <- computeRestarts(cond)
[13:21:43.830]                           for (restart in restarts) {
[13:21:43.830]                             name <- restart$name
[13:21:43.830]                             if (is.null(name)) 
[13:21:43.830]                               next
[13:21:43.830]                             if (!grepl(pattern, name)) 
[13:21:43.830]                               next
[13:21:43.830]                             invokeRestart(restart)
[13:21:43.830]                             muffled <- TRUE
[13:21:43.830]                             break
[13:21:43.830]                           }
[13:21:43.830]                         }
[13:21:43.830]                       }
[13:21:43.830]                       invisible(muffled)
[13:21:43.830]                     }
[13:21:43.830]                     muffleCondition(cond, pattern = "^muffle")
[13:21:43.830]                   }
[13:21:43.830]                 }
[13:21:43.830]                 else {
[13:21:43.830]                   if (TRUE) {
[13:21:43.830]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:43.830]                     {
[13:21:43.830]                       inherits <- base::inherits
[13:21:43.830]                       invokeRestart <- base::invokeRestart
[13:21:43.830]                       is.null <- base::is.null
[13:21:43.830]                       muffled <- FALSE
[13:21:43.830]                       if (inherits(cond, "message")) {
[13:21:43.830]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:43.830]                         if (muffled) 
[13:21:43.830]                           invokeRestart("muffleMessage")
[13:21:43.830]                       }
[13:21:43.830]                       else if (inherits(cond, "warning")) {
[13:21:43.830]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:43.830]                         if (muffled) 
[13:21:43.830]                           invokeRestart("muffleWarning")
[13:21:43.830]                       }
[13:21:43.830]                       else if (inherits(cond, "condition")) {
[13:21:43.830]                         if (!is.null(pattern)) {
[13:21:43.830]                           computeRestarts <- base::computeRestarts
[13:21:43.830]                           grepl <- base::grepl
[13:21:43.830]                           restarts <- computeRestarts(cond)
[13:21:43.830]                           for (restart in restarts) {
[13:21:43.830]                             name <- restart$name
[13:21:43.830]                             if (is.null(name)) 
[13:21:43.830]                               next
[13:21:43.830]                             if (!grepl(pattern, name)) 
[13:21:43.830]                               next
[13:21:43.830]                             invokeRestart(restart)
[13:21:43.830]                             muffled <- TRUE
[13:21:43.830]                             break
[13:21:43.830]                           }
[13:21:43.830]                         }
[13:21:43.830]                       }
[13:21:43.830]                       invisible(muffled)
[13:21:43.830]                     }
[13:21:43.830]                     muffleCondition(cond, pattern = "^muffle")
[13:21:43.830]                   }
[13:21:43.830]                 }
[13:21:43.830]             }
[13:21:43.830]         }))
[13:21:43.830]     }, error = function(ex) {
[13:21:43.830]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:43.830]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:43.830]                 ...future.rng), started = ...future.startTime, 
[13:21:43.830]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:43.830]             version = "1.8"), class = "FutureResult")
[13:21:43.830]     }, finally = {
[13:21:43.830]         if (!identical(...future.workdir, getwd())) 
[13:21:43.830]             setwd(...future.workdir)
[13:21:43.830]         {
[13:21:43.830]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:43.830]                 ...future.oldOptions$nwarnings <- NULL
[13:21:43.830]             }
[13:21:43.830]             base::options(...future.oldOptions)
[13:21:43.830]             if (.Platform$OS.type == "windows") {
[13:21:43.830]                 old_names <- names(...future.oldEnvVars)
[13:21:43.830]                 envs <- base::Sys.getenv()
[13:21:43.830]                 names <- names(envs)
[13:21:43.830]                 common <- intersect(names, old_names)
[13:21:43.830]                 added <- setdiff(names, old_names)
[13:21:43.830]                 removed <- setdiff(old_names, names)
[13:21:43.830]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:43.830]                   envs[common]]
[13:21:43.830]                 NAMES <- toupper(changed)
[13:21:43.830]                 args <- list()
[13:21:43.830]                 for (kk in seq_along(NAMES)) {
[13:21:43.830]                   name <- changed[[kk]]
[13:21:43.830]                   NAME <- NAMES[[kk]]
[13:21:43.830]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:43.830]                     next
[13:21:43.830]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:43.830]                 }
[13:21:43.830]                 NAMES <- toupper(added)
[13:21:43.830]                 for (kk in seq_along(NAMES)) {
[13:21:43.830]                   name <- added[[kk]]
[13:21:43.830]                   NAME <- NAMES[[kk]]
[13:21:43.830]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:43.830]                     next
[13:21:43.830]                   args[[name]] <- ""
[13:21:43.830]                 }
[13:21:43.830]                 NAMES <- toupper(removed)
[13:21:43.830]                 for (kk in seq_along(NAMES)) {
[13:21:43.830]                   name <- removed[[kk]]
[13:21:43.830]                   NAME <- NAMES[[kk]]
[13:21:43.830]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:43.830]                     next
[13:21:43.830]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:43.830]                 }
[13:21:43.830]                 if (length(args) > 0) 
[13:21:43.830]                   base::do.call(base::Sys.setenv, args = args)
[13:21:43.830]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:43.830]             }
[13:21:43.830]             else {
[13:21:43.830]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:43.830]             }
[13:21:43.830]             {
[13:21:43.830]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:43.830]                   0L) {
[13:21:43.830]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:43.830]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:43.830]                   base::options(opts)
[13:21:43.830]                 }
[13:21:43.830]                 {
[13:21:43.830]                   {
[13:21:43.830]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:43.830]                     NULL
[13:21:43.830]                   }
[13:21:43.830]                   options(future.plan = NULL)
[13:21:43.830]                   if (is.na(NA_character_)) 
[13:21:43.830]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:43.830]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:43.830]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:43.830]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:43.830]                     envir = parent.frame()) 
[13:21:43.830]                   {
[13:21:43.830]                     if (is.function(workers)) 
[13:21:43.830]                       workers <- workers()
[13:21:43.830]                     workers <- structure(as.integer(workers), 
[13:21:43.830]                       class = class(workers))
[13:21:43.830]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:43.830]                       workers >= 1)
[13:21:43.830]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:43.830]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:43.830]                     }
[13:21:43.830]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:43.830]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:43.830]                       envir = envir)
[13:21:43.830]                     if (!future$lazy) 
[13:21:43.830]                       future <- run(future)
[13:21:43.830]                     invisible(future)
[13:21:43.830]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:43.830]                 }
[13:21:43.830]             }
[13:21:43.830]         }
[13:21:43.830]     })
[13:21:43.830]     if (TRUE) {
[13:21:43.830]         base::sink(type = "output", split = FALSE)
[13:21:43.830]         if (TRUE) {
[13:21:43.830]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:43.830]         }
[13:21:43.830]         else {
[13:21:43.830]             ...future.result["stdout"] <- base::list(NULL)
[13:21:43.830]         }
[13:21:43.830]         base::close(...future.stdout)
[13:21:43.830]         ...future.stdout <- NULL
[13:21:43.830]     }
[13:21:43.830]     ...future.result$conditions <- ...future.conditions
[13:21:43.830]     ...future.result$finished <- base::Sys.time()
[13:21:43.830]     ...future.result
[13:21:43.830] }
[13:21:43.834] MultisessionFuture started
[13:21:43.834] - Launch lazy future ... done
[13:21:43.834] run() for ‘MultisessionFuture’ ... done
[13:21:44.383] receiveMessageFromWorker() for ClusterFuture ...
[13:21:44.383] - Validating connection of MultisessionFuture
[13:21:44.383] - received message: FutureResult
[13:21:44.384] - Received FutureResult
[13:21:44.384] - Erased future from FutureRegistry
[13:21:44.384] result() for ClusterFuture ...
[13:21:44.384] - result already collected: FutureResult
[13:21:44.384] result() for ClusterFuture ... done
[13:21:44.385] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:44.385] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[13:21:44.386] getGlobalsAndPackages() ...
[13:21:44.386] Searching for globals...
[13:21:44.387] - globals found: [2] ‘list’, ‘stop’
[13:21:44.387] Searching for globals ... DONE
[13:21:44.387] Resolving globals: FALSE
[13:21:44.387] 
[13:21:44.387] 
[13:21:44.387] getGlobalsAndPackages() ... DONE
[13:21:44.388] run() for ‘Future’ ...
[13:21:44.388] - state: ‘created’
[13:21:44.388] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:44.404] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:44.404] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:44.404]   - Field: ‘node’
[13:21:44.405]   - Field: ‘label’
[13:21:44.405]   - Field: ‘local’
[13:21:44.405]   - Field: ‘owner’
[13:21:44.405]   - Field: ‘envir’
[13:21:44.405]   - Field: ‘workers’
[13:21:44.405]   - Field: ‘packages’
[13:21:44.405]   - Field: ‘gc’
[13:21:44.405]   - Field: ‘conditions’
[13:21:44.405]   - Field: ‘persistent’
[13:21:44.405]   - Field: ‘expr’
[13:21:44.406]   - Field: ‘uuid’
[13:21:44.406]   - Field: ‘seed’
[13:21:44.406]   - Field: ‘version’
[13:21:44.406]   - Field: ‘result’
[13:21:44.406]   - Field: ‘asynchronous’
[13:21:44.406]   - Field: ‘calls’
[13:21:44.406]   - Field: ‘globals’
[13:21:44.406]   - Field: ‘stdout’
[13:21:44.406]   - Field: ‘earlySignal’
[13:21:44.406]   - Field: ‘lazy’
[13:21:44.406]   - Field: ‘state’
[13:21:44.406] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:44.407] - Launch lazy future ...
[13:21:44.407] Packages needed by the future expression (n = 0): <none>
[13:21:44.407] Packages needed by future strategies (n = 0): <none>
[13:21:44.407] {
[13:21:44.407]     {
[13:21:44.407]         {
[13:21:44.407]             ...future.startTime <- base::Sys.time()
[13:21:44.407]             {
[13:21:44.407]                 {
[13:21:44.407]                   {
[13:21:44.407]                     {
[13:21:44.407]                       base::local({
[13:21:44.407]                         has_future <- base::requireNamespace("future", 
[13:21:44.407]                           quietly = TRUE)
[13:21:44.407]                         if (has_future) {
[13:21:44.407]                           ns <- base::getNamespace("future")
[13:21:44.407]                           version <- ns[[".package"]][["version"]]
[13:21:44.407]                           if (is.null(version)) 
[13:21:44.407]                             version <- utils::packageVersion("future")
[13:21:44.407]                         }
[13:21:44.407]                         else {
[13:21:44.407]                           version <- NULL
[13:21:44.407]                         }
[13:21:44.407]                         if (!has_future || version < "1.8.0") {
[13:21:44.407]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:44.407]                             "", base::R.version$version.string), 
[13:21:44.407]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:44.407]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:44.407]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:44.407]                               "release", "version")], collapse = " "), 
[13:21:44.407]                             hostname = base::Sys.info()[["nodename"]])
[13:21:44.407]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:44.407]                             info)
[13:21:44.407]                           info <- base::paste(info, collapse = "; ")
[13:21:44.407]                           if (!has_future) {
[13:21:44.407]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:44.407]                               info)
[13:21:44.407]                           }
[13:21:44.407]                           else {
[13:21:44.407]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:44.407]                               info, version)
[13:21:44.407]                           }
[13:21:44.407]                           base::stop(msg)
[13:21:44.407]                         }
[13:21:44.407]                       })
[13:21:44.407]                     }
[13:21:44.407]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:44.407]                     base::options(mc.cores = 1L)
[13:21:44.407]                   }
[13:21:44.407]                   options(future.plan = NULL)
[13:21:44.407]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:44.407]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:44.407]                 }
[13:21:44.407]                 ...future.workdir <- getwd()
[13:21:44.407]             }
[13:21:44.407]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:44.407]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:44.407]         }
[13:21:44.407]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:44.407]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:44.407]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:44.407]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:44.407]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:44.407]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:44.407]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:44.407]             base::names(...future.oldOptions))
[13:21:44.407]     }
[13:21:44.407]     if (FALSE) {
[13:21:44.407]     }
[13:21:44.407]     else {
[13:21:44.407]         if (TRUE) {
[13:21:44.407]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:44.407]                 open = "w")
[13:21:44.407]         }
[13:21:44.407]         else {
[13:21:44.407]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:44.407]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:44.407]         }
[13:21:44.407]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:44.407]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:44.407]             base::sink(type = "output", split = FALSE)
[13:21:44.407]             base::close(...future.stdout)
[13:21:44.407]         }, add = TRUE)
[13:21:44.407]     }
[13:21:44.407]     ...future.frame <- base::sys.nframe()
[13:21:44.407]     ...future.conditions <- base::list()
[13:21:44.407]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:44.407]     if (FALSE) {
[13:21:44.407]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:44.407]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:44.407]     }
[13:21:44.407]     ...future.result <- base::tryCatch({
[13:21:44.407]         base::withCallingHandlers({
[13:21:44.407]             ...future.value <- base::withVisible(base::local({
[13:21:44.407]                 ...future.makeSendCondition <- local({
[13:21:44.407]                   sendCondition <- NULL
[13:21:44.407]                   function(frame = 1L) {
[13:21:44.407]                     if (is.function(sendCondition)) 
[13:21:44.407]                       return(sendCondition)
[13:21:44.407]                     ns <- getNamespace("parallel")
[13:21:44.407]                     if (exists("sendData", mode = "function", 
[13:21:44.407]                       envir = ns)) {
[13:21:44.407]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:44.407]                         envir = ns)
[13:21:44.407]                       envir <- sys.frame(frame)
[13:21:44.407]                       master <- NULL
[13:21:44.407]                       while (!identical(envir, .GlobalEnv) && 
[13:21:44.407]                         !identical(envir, emptyenv())) {
[13:21:44.407]                         if (exists("master", mode = "list", envir = envir, 
[13:21:44.407]                           inherits = FALSE)) {
[13:21:44.407]                           master <- get("master", mode = "list", 
[13:21:44.407]                             envir = envir, inherits = FALSE)
[13:21:44.407]                           if (inherits(master, c("SOCKnode", 
[13:21:44.407]                             "SOCK0node"))) {
[13:21:44.407]                             sendCondition <<- function(cond) {
[13:21:44.407]                               data <- list(type = "VALUE", value = cond, 
[13:21:44.407]                                 success = TRUE)
[13:21:44.407]                               parallel_sendData(master, data)
[13:21:44.407]                             }
[13:21:44.407]                             return(sendCondition)
[13:21:44.407]                           }
[13:21:44.407]                         }
[13:21:44.407]                         frame <- frame + 1L
[13:21:44.407]                         envir <- sys.frame(frame)
[13:21:44.407]                       }
[13:21:44.407]                     }
[13:21:44.407]                     sendCondition <<- function(cond) NULL
[13:21:44.407]                   }
[13:21:44.407]                 })
[13:21:44.407]                 withCallingHandlers({
[13:21:44.407]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:21:44.407]                 }, immediateCondition = function(cond) {
[13:21:44.407]                   sendCondition <- ...future.makeSendCondition()
[13:21:44.407]                   sendCondition(cond)
[13:21:44.407]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:44.407]                   {
[13:21:44.407]                     inherits <- base::inherits
[13:21:44.407]                     invokeRestart <- base::invokeRestart
[13:21:44.407]                     is.null <- base::is.null
[13:21:44.407]                     muffled <- FALSE
[13:21:44.407]                     if (inherits(cond, "message")) {
[13:21:44.407]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:44.407]                       if (muffled) 
[13:21:44.407]                         invokeRestart("muffleMessage")
[13:21:44.407]                     }
[13:21:44.407]                     else if (inherits(cond, "warning")) {
[13:21:44.407]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:44.407]                       if (muffled) 
[13:21:44.407]                         invokeRestart("muffleWarning")
[13:21:44.407]                     }
[13:21:44.407]                     else if (inherits(cond, "condition")) {
[13:21:44.407]                       if (!is.null(pattern)) {
[13:21:44.407]                         computeRestarts <- base::computeRestarts
[13:21:44.407]                         grepl <- base::grepl
[13:21:44.407]                         restarts <- computeRestarts(cond)
[13:21:44.407]                         for (restart in restarts) {
[13:21:44.407]                           name <- restart$name
[13:21:44.407]                           if (is.null(name)) 
[13:21:44.407]                             next
[13:21:44.407]                           if (!grepl(pattern, name)) 
[13:21:44.407]                             next
[13:21:44.407]                           invokeRestart(restart)
[13:21:44.407]                           muffled <- TRUE
[13:21:44.407]                           break
[13:21:44.407]                         }
[13:21:44.407]                       }
[13:21:44.407]                     }
[13:21:44.407]                     invisible(muffled)
[13:21:44.407]                   }
[13:21:44.407]                   muffleCondition(cond)
[13:21:44.407]                 })
[13:21:44.407]             }))
[13:21:44.407]             future::FutureResult(value = ...future.value$value, 
[13:21:44.407]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:44.407]                   ...future.rng), globalenv = if (FALSE) 
[13:21:44.407]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:44.407]                     ...future.globalenv.names))
[13:21:44.407]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:44.407]         }, condition = base::local({
[13:21:44.407]             c <- base::c
[13:21:44.407]             inherits <- base::inherits
[13:21:44.407]             invokeRestart <- base::invokeRestart
[13:21:44.407]             length <- base::length
[13:21:44.407]             list <- base::list
[13:21:44.407]             seq.int <- base::seq.int
[13:21:44.407]             signalCondition <- base::signalCondition
[13:21:44.407]             sys.calls <- base::sys.calls
[13:21:44.407]             `[[` <- base::`[[`
[13:21:44.407]             `+` <- base::`+`
[13:21:44.407]             `<<-` <- base::`<<-`
[13:21:44.407]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:44.407]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:44.407]                   3L)]
[13:21:44.407]             }
[13:21:44.407]             function(cond) {
[13:21:44.407]                 is_error <- inherits(cond, "error")
[13:21:44.407]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:44.407]                   NULL)
[13:21:44.407]                 if (is_error) {
[13:21:44.407]                   sessionInformation <- function() {
[13:21:44.407]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:44.407]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:44.407]                       search = base::search(), system = base::Sys.info())
[13:21:44.407]                   }
[13:21:44.407]                   ...future.conditions[[length(...future.conditions) + 
[13:21:44.407]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:44.407]                     cond$call), session = sessionInformation(), 
[13:21:44.407]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:44.407]                   signalCondition(cond)
[13:21:44.407]                 }
[13:21:44.407]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:44.407]                 "immediateCondition"))) {
[13:21:44.407]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:44.407]                   ...future.conditions[[length(...future.conditions) + 
[13:21:44.407]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:44.407]                   if (TRUE && !signal) {
[13:21:44.407]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:44.407]                     {
[13:21:44.407]                       inherits <- base::inherits
[13:21:44.407]                       invokeRestart <- base::invokeRestart
[13:21:44.407]                       is.null <- base::is.null
[13:21:44.407]                       muffled <- FALSE
[13:21:44.407]                       if (inherits(cond, "message")) {
[13:21:44.407]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:44.407]                         if (muffled) 
[13:21:44.407]                           invokeRestart("muffleMessage")
[13:21:44.407]                       }
[13:21:44.407]                       else if (inherits(cond, "warning")) {
[13:21:44.407]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:44.407]                         if (muffled) 
[13:21:44.407]                           invokeRestart("muffleWarning")
[13:21:44.407]                       }
[13:21:44.407]                       else if (inherits(cond, "condition")) {
[13:21:44.407]                         if (!is.null(pattern)) {
[13:21:44.407]                           computeRestarts <- base::computeRestarts
[13:21:44.407]                           grepl <- base::grepl
[13:21:44.407]                           restarts <- computeRestarts(cond)
[13:21:44.407]                           for (restart in restarts) {
[13:21:44.407]                             name <- restart$name
[13:21:44.407]                             if (is.null(name)) 
[13:21:44.407]                               next
[13:21:44.407]                             if (!grepl(pattern, name)) 
[13:21:44.407]                               next
[13:21:44.407]                             invokeRestart(restart)
[13:21:44.407]                             muffled <- TRUE
[13:21:44.407]                             break
[13:21:44.407]                           }
[13:21:44.407]                         }
[13:21:44.407]                       }
[13:21:44.407]                       invisible(muffled)
[13:21:44.407]                     }
[13:21:44.407]                     muffleCondition(cond, pattern = "^muffle")
[13:21:44.407]                   }
[13:21:44.407]                 }
[13:21:44.407]                 else {
[13:21:44.407]                   if (TRUE) {
[13:21:44.407]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:44.407]                     {
[13:21:44.407]                       inherits <- base::inherits
[13:21:44.407]                       invokeRestart <- base::invokeRestart
[13:21:44.407]                       is.null <- base::is.null
[13:21:44.407]                       muffled <- FALSE
[13:21:44.407]                       if (inherits(cond, "message")) {
[13:21:44.407]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:44.407]                         if (muffled) 
[13:21:44.407]                           invokeRestart("muffleMessage")
[13:21:44.407]                       }
[13:21:44.407]                       else if (inherits(cond, "warning")) {
[13:21:44.407]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:44.407]                         if (muffled) 
[13:21:44.407]                           invokeRestart("muffleWarning")
[13:21:44.407]                       }
[13:21:44.407]                       else if (inherits(cond, "condition")) {
[13:21:44.407]                         if (!is.null(pattern)) {
[13:21:44.407]                           computeRestarts <- base::computeRestarts
[13:21:44.407]                           grepl <- base::grepl
[13:21:44.407]                           restarts <- computeRestarts(cond)
[13:21:44.407]                           for (restart in restarts) {
[13:21:44.407]                             name <- restart$name
[13:21:44.407]                             if (is.null(name)) 
[13:21:44.407]                               next
[13:21:44.407]                             if (!grepl(pattern, name)) 
[13:21:44.407]                               next
[13:21:44.407]                             invokeRestart(restart)
[13:21:44.407]                             muffled <- TRUE
[13:21:44.407]                             break
[13:21:44.407]                           }
[13:21:44.407]                         }
[13:21:44.407]                       }
[13:21:44.407]                       invisible(muffled)
[13:21:44.407]                     }
[13:21:44.407]                     muffleCondition(cond, pattern = "^muffle")
[13:21:44.407]                   }
[13:21:44.407]                 }
[13:21:44.407]             }
[13:21:44.407]         }))
[13:21:44.407]     }, error = function(ex) {
[13:21:44.407]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:44.407]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:44.407]                 ...future.rng), started = ...future.startTime, 
[13:21:44.407]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:44.407]             version = "1.8"), class = "FutureResult")
[13:21:44.407]     }, finally = {
[13:21:44.407]         if (!identical(...future.workdir, getwd())) 
[13:21:44.407]             setwd(...future.workdir)
[13:21:44.407]         {
[13:21:44.407]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:44.407]                 ...future.oldOptions$nwarnings <- NULL
[13:21:44.407]             }
[13:21:44.407]             base::options(...future.oldOptions)
[13:21:44.407]             if (.Platform$OS.type == "windows") {
[13:21:44.407]                 old_names <- names(...future.oldEnvVars)
[13:21:44.407]                 envs <- base::Sys.getenv()
[13:21:44.407]                 names <- names(envs)
[13:21:44.407]                 common <- intersect(names, old_names)
[13:21:44.407]                 added <- setdiff(names, old_names)
[13:21:44.407]                 removed <- setdiff(old_names, names)
[13:21:44.407]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:44.407]                   envs[common]]
[13:21:44.407]                 NAMES <- toupper(changed)
[13:21:44.407]                 args <- list()
[13:21:44.407]                 for (kk in seq_along(NAMES)) {
[13:21:44.407]                   name <- changed[[kk]]
[13:21:44.407]                   NAME <- NAMES[[kk]]
[13:21:44.407]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:44.407]                     next
[13:21:44.407]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:44.407]                 }
[13:21:44.407]                 NAMES <- toupper(added)
[13:21:44.407]                 for (kk in seq_along(NAMES)) {
[13:21:44.407]                   name <- added[[kk]]
[13:21:44.407]                   NAME <- NAMES[[kk]]
[13:21:44.407]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:44.407]                     next
[13:21:44.407]                   args[[name]] <- ""
[13:21:44.407]                 }
[13:21:44.407]                 NAMES <- toupper(removed)
[13:21:44.407]                 for (kk in seq_along(NAMES)) {
[13:21:44.407]                   name <- removed[[kk]]
[13:21:44.407]                   NAME <- NAMES[[kk]]
[13:21:44.407]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:44.407]                     next
[13:21:44.407]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:44.407]                 }
[13:21:44.407]                 if (length(args) > 0) 
[13:21:44.407]                   base::do.call(base::Sys.setenv, args = args)
[13:21:44.407]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:44.407]             }
[13:21:44.407]             else {
[13:21:44.407]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:44.407]             }
[13:21:44.407]             {
[13:21:44.407]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:44.407]                   0L) {
[13:21:44.407]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:44.407]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:44.407]                   base::options(opts)
[13:21:44.407]                 }
[13:21:44.407]                 {
[13:21:44.407]                   {
[13:21:44.407]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:44.407]                     NULL
[13:21:44.407]                   }
[13:21:44.407]                   options(future.plan = NULL)
[13:21:44.407]                   if (is.na(NA_character_)) 
[13:21:44.407]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:44.407]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:44.407]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:44.407]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:44.407]                     envir = parent.frame()) 
[13:21:44.407]                   {
[13:21:44.407]                     if (is.function(workers)) 
[13:21:44.407]                       workers <- workers()
[13:21:44.407]                     workers <- structure(as.integer(workers), 
[13:21:44.407]                       class = class(workers))
[13:21:44.407]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:44.407]                       workers >= 1)
[13:21:44.407]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:44.407]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:44.407]                     }
[13:21:44.407]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:44.407]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:44.407]                       envir = envir)
[13:21:44.407]                     if (!future$lazy) 
[13:21:44.407]                       future <- run(future)
[13:21:44.407]                     invisible(future)
[13:21:44.407]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:44.407]                 }
[13:21:44.407]             }
[13:21:44.407]         }
[13:21:44.407]     })
[13:21:44.407]     if (TRUE) {
[13:21:44.407]         base::sink(type = "output", split = FALSE)
[13:21:44.407]         if (TRUE) {
[13:21:44.407]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:44.407]         }
[13:21:44.407]         else {
[13:21:44.407]             ...future.result["stdout"] <- base::list(NULL)
[13:21:44.407]         }
[13:21:44.407]         base::close(...future.stdout)
[13:21:44.407]         ...future.stdout <- NULL
[13:21:44.407]     }
[13:21:44.407]     ...future.result$conditions <- ...future.conditions
[13:21:44.407]     ...future.result$finished <- base::Sys.time()
[13:21:44.407]     ...future.result
[13:21:44.407] }
[13:21:44.410] MultisessionFuture started
[13:21:44.411] - Launch lazy future ... done
[13:21:44.411] run() for ‘MultisessionFuture’ ... done
[13:21:44.458] receiveMessageFromWorker() for ClusterFuture ...
[13:21:44.458] - Validating connection of MultisessionFuture
[13:21:44.458] - received message: FutureResult
[13:21:44.458] - Received FutureResult
[13:21:44.458] - Erased future from FutureRegistry
[13:21:44.458] result() for ClusterFuture ...
[13:21:44.459] - result already collected: FutureResult
[13:21:44.459] result() for ClusterFuture ... done
[13:21:44.459] signalConditions() ...
[13:21:44.459]  - include = ‘immediateCondition’
[13:21:44.459]  - exclude = 
[13:21:44.459]  - resignal = FALSE
[13:21:44.459]  - Number of conditions: 1
[13:21:44.459] signalConditions() ... done
[13:21:44.459] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:44.459] A MultisessionFuture was resolved (result was not collected)
[13:21:44.459] getGlobalsAndPackages() ...
[13:21:44.460] Searching for globals...
[13:21:44.460] - globals found: [2] ‘list’, ‘stop’
[13:21:44.460] Searching for globals ... DONE
[13:21:44.460] Resolving globals: FALSE
[13:21:44.461] 
[13:21:44.461] 
[13:21:44.461] getGlobalsAndPackages() ... DONE
[13:21:44.461] run() for ‘Future’ ...
[13:21:44.461] - state: ‘created’
[13:21:44.461] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:44.476] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:44.476] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:44.476]   - Field: ‘node’
[13:21:44.476]   - Field: ‘label’
[13:21:44.476]   - Field: ‘local’
[13:21:44.476]   - Field: ‘owner’
[13:21:44.476]   - Field: ‘envir’
[13:21:44.476]   - Field: ‘workers’
[13:21:44.476]   - Field: ‘packages’
[13:21:44.477]   - Field: ‘gc’
[13:21:44.477]   - Field: ‘conditions’
[13:21:44.477]   - Field: ‘persistent’
[13:21:44.477]   - Field: ‘expr’
[13:21:44.477]   - Field: ‘uuid’
[13:21:44.477]   - Field: ‘seed’
[13:21:44.477]   - Field: ‘version’
[13:21:44.477]   - Field: ‘result’
[13:21:44.477]   - Field: ‘asynchronous’
[13:21:44.477]   - Field: ‘calls’
[13:21:44.477]   - Field: ‘globals’
[13:21:44.478]   - Field: ‘stdout’
[13:21:44.478]   - Field: ‘earlySignal’
[13:21:44.478]   - Field: ‘lazy’
[13:21:44.478]   - Field: ‘state’
[13:21:44.478] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:44.478] - Launch lazy future ...
[13:21:44.478] Packages needed by the future expression (n = 0): <none>
[13:21:44.478] Packages needed by future strategies (n = 0): <none>
[13:21:44.479] {
[13:21:44.479]     {
[13:21:44.479]         {
[13:21:44.479]             ...future.startTime <- base::Sys.time()
[13:21:44.479]             {
[13:21:44.479]                 {
[13:21:44.479]                   {
[13:21:44.479]                     {
[13:21:44.479]                       base::local({
[13:21:44.479]                         has_future <- base::requireNamespace("future", 
[13:21:44.479]                           quietly = TRUE)
[13:21:44.479]                         if (has_future) {
[13:21:44.479]                           ns <- base::getNamespace("future")
[13:21:44.479]                           version <- ns[[".package"]][["version"]]
[13:21:44.479]                           if (is.null(version)) 
[13:21:44.479]                             version <- utils::packageVersion("future")
[13:21:44.479]                         }
[13:21:44.479]                         else {
[13:21:44.479]                           version <- NULL
[13:21:44.479]                         }
[13:21:44.479]                         if (!has_future || version < "1.8.0") {
[13:21:44.479]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:44.479]                             "", base::R.version$version.string), 
[13:21:44.479]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:44.479]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:44.479]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:44.479]                               "release", "version")], collapse = " "), 
[13:21:44.479]                             hostname = base::Sys.info()[["nodename"]])
[13:21:44.479]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:44.479]                             info)
[13:21:44.479]                           info <- base::paste(info, collapse = "; ")
[13:21:44.479]                           if (!has_future) {
[13:21:44.479]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:44.479]                               info)
[13:21:44.479]                           }
[13:21:44.479]                           else {
[13:21:44.479]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:44.479]                               info, version)
[13:21:44.479]                           }
[13:21:44.479]                           base::stop(msg)
[13:21:44.479]                         }
[13:21:44.479]                       })
[13:21:44.479]                     }
[13:21:44.479]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:44.479]                     base::options(mc.cores = 1L)
[13:21:44.479]                   }
[13:21:44.479]                   options(future.plan = NULL)
[13:21:44.479]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:44.479]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:44.479]                 }
[13:21:44.479]                 ...future.workdir <- getwd()
[13:21:44.479]             }
[13:21:44.479]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:44.479]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:44.479]         }
[13:21:44.479]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:44.479]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:44.479]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:44.479]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:44.479]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:44.479]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:44.479]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:44.479]             base::names(...future.oldOptions))
[13:21:44.479]     }
[13:21:44.479]     if (FALSE) {
[13:21:44.479]     }
[13:21:44.479]     else {
[13:21:44.479]         if (TRUE) {
[13:21:44.479]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:44.479]                 open = "w")
[13:21:44.479]         }
[13:21:44.479]         else {
[13:21:44.479]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:44.479]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:44.479]         }
[13:21:44.479]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:44.479]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:44.479]             base::sink(type = "output", split = FALSE)
[13:21:44.479]             base::close(...future.stdout)
[13:21:44.479]         }, add = TRUE)
[13:21:44.479]     }
[13:21:44.479]     ...future.frame <- base::sys.nframe()
[13:21:44.479]     ...future.conditions <- base::list()
[13:21:44.479]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:44.479]     if (FALSE) {
[13:21:44.479]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:44.479]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:44.479]     }
[13:21:44.479]     ...future.result <- base::tryCatch({
[13:21:44.479]         base::withCallingHandlers({
[13:21:44.479]             ...future.value <- base::withVisible(base::local({
[13:21:44.479]                 ...future.makeSendCondition <- local({
[13:21:44.479]                   sendCondition <- NULL
[13:21:44.479]                   function(frame = 1L) {
[13:21:44.479]                     if (is.function(sendCondition)) 
[13:21:44.479]                       return(sendCondition)
[13:21:44.479]                     ns <- getNamespace("parallel")
[13:21:44.479]                     if (exists("sendData", mode = "function", 
[13:21:44.479]                       envir = ns)) {
[13:21:44.479]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:44.479]                         envir = ns)
[13:21:44.479]                       envir <- sys.frame(frame)
[13:21:44.479]                       master <- NULL
[13:21:44.479]                       while (!identical(envir, .GlobalEnv) && 
[13:21:44.479]                         !identical(envir, emptyenv())) {
[13:21:44.479]                         if (exists("master", mode = "list", envir = envir, 
[13:21:44.479]                           inherits = FALSE)) {
[13:21:44.479]                           master <- get("master", mode = "list", 
[13:21:44.479]                             envir = envir, inherits = FALSE)
[13:21:44.479]                           if (inherits(master, c("SOCKnode", 
[13:21:44.479]                             "SOCK0node"))) {
[13:21:44.479]                             sendCondition <<- function(cond) {
[13:21:44.479]                               data <- list(type = "VALUE", value = cond, 
[13:21:44.479]                                 success = TRUE)
[13:21:44.479]                               parallel_sendData(master, data)
[13:21:44.479]                             }
[13:21:44.479]                             return(sendCondition)
[13:21:44.479]                           }
[13:21:44.479]                         }
[13:21:44.479]                         frame <- frame + 1L
[13:21:44.479]                         envir <- sys.frame(frame)
[13:21:44.479]                       }
[13:21:44.479]                     }
[13:21:44.479]                     sendCondition <<- function(cond) NULL
[13:21:44.479]                   }
[13:21:44.479]                 })
[13:21:44.479]                 withCallingHandlers({
[13:21:44.479]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:21:44.479]                 }, immediateCondition = function(cond) {
[13:21:44.479]                   sendCondition <- ...future.makeSendCondition()
[13:21:44.479]                   sendCondition(cond)
[13:21:44.479]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:44.479]                   {
[13:21:44.479]                     inherits <- base::inherits
[13:21:44.479]                     invokeRestart <- base::invokeRestart
[13:21:44.479]                     is.null <- base::is.null
[13:21:44.479]                     muffled <- FALSE
[13:21:44.479]                     if (inherits(cond, "message")) {
[13:21:44.479]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:44.479]                       if (muffled) 
[13:21:44.479]                         invokeRestart("muffleMessage")
[13:21:44.479]                     }
[13:21:44.479]                     else if (inherits(cond, "warning")) {
[13:21:44.479]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:44.479]                       if (muffled) 
[13:21:44.479]                         invokeRestart("muffleWarning")
[13:21:44.479]                     }
[13:21:44.479]                     else if (inherits(cond, "condition")) {
[13:21:44.479]                       if (!is.null(pattern)) {
[13:21:44.479]                         computeRestarts <- base::computeRestarts
[13:21:44.479]                         grepl <- base::grepl
[13:21:44.479]                         restarts <- computeRestarts(cond)
[13:21:44.479]                         for (restart in restarts) {
[13:21:44.479]                           name <- restart$name
[13:21:44.479]                           if (is.null(name)) 
[13:21:44.479]                             next
[13:21:44.479]                           if (!grepl(pattern, name)) 
[13:21:44.479]                             next
[13:21:44.479]                           invokeRestart(restart)
[13:21:44.479]                           muffled <- TRUE
[13:21:44.479]                           break
[13:21:44.479]                         }
[13:21:44.479]                       }
[13:21:44.479]                     }
[13:21:44.479]                     invisible(muffled)
[13:21:44.479]                   }
[13:21:44.479]                   muffleCondition(cond)
[13:21:44.479]                 })
[13:21:44.479]             }))
[13:21:44.479]             future::FutureResult(value = ...future.value$value, 
[13:21:44.479]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:44.479]                   ...future.rng), globalenv = if (FALSE) 
[13:21:44.479]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:44.479]                     ...future.globalenv.names))
[13:21:44.479]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:44.479]         }, condition = base::local({
[13:21:44.479]             c <- base::c
[13:21:44.479]             inherits <- base::inherits
[13:21:44.479]             invokeRestart <- base::invokeRestart
[13:21:44.479]             length <- base::length
[13:21:44.479]             list <- base::list
[13:21:44.479]             seq.int <- base::seq.int
[13:21:44.479]             signalCondition <- base::signalCondition
[13:21:44.479]             sys.calls <- base::sys.calls
[13:21:44.479]             `[[` <- base::`[[`
[13:21:44.479]             `+` <- base::`+`
[13:21:44.479]             `<<-` <- base::`<<-`
[13:21:44.479]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:44.479]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:44.479]                   3L)]
[13:21:44.479]             }
[13:21:44.479]             function(cond) {
[13:21:44.479]                 is_error <- inherits(cond, "error")
[13:21:44.479]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:44.479]                   NULL)
[13:21:44.479]                 if (is_error) {
[13:21:44.479]                   sessionInformation <- function() {
[13:21:44.479]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:44.479]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:44.479]                       search = base::search(), system = base::Sys.info())
[13:21:44.479]                   }
[13:21:44.479]                   ...future.conditions[[length(...future.conditions) + 
[13:21:44.479]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:44.479]                     cond$call), session = sessionInformation(), 
[13:21:44.479]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:44.479]                   signalCondition(cond)
[13:21:44.479]                 }
[13:21:44.479]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:44.479]                 "immediateCondition"))) {
[13:21:44.479]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:44.479]                   ...future.conditions[[length(...future.conditions) + 
[13:21:44.479]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:44.479]                   if (TRUE && !signal) {
[13:21:44.479]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:44.479]                     {
[13:21:44.479]                       inherits <- base::inherits
[13:21:44.479]                       invokeRestart <- base::invokeRestart
[13:21:44.479]                       is.null <- base::is.null
[13:21:44.479]                       muffled <- FALSE
[13:21:44.479]                       if (inherits(cond, "message")) {
[13:21:44.479]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:44.479]                         if (muffled) 
[13:21:44.479]                           invokeRestart("muffleMessage")
[13:21:44.479]                       }
[13:21:44.479]                       else if (inherits(cond, "warning")) {
[13:21:44.479]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:44.479]                         if (muffled) 
[13:21:44.479]                           invokeRestart("muffleWarning")
[13:21:44.479]                       }
[13:21:44.479]                       else if (inherits(cond, "condition")) {
[13:21:44.479]                         if (!is.null(pattern)) {
[13:21:44.479]                           computeRestarts <- base::computeRestarts
[13:21:44.479]                           grepl <- base::grepl
[13:21:44.479]                           restarts <- computeRestarts(cond)
[13:21:44.479]                           for (restart in restarts) {
[13:21:44.479]                             name <- restart$name
[13:21:44.479]                             if (is.null(name)) 
[13:21:44.479]                               next
[13:21:44.479]                             if (!grepl(pattern, name)) 
[13:21:44.479]                               next
[13:21:44.479]                             invokeRestart(restart)
[13:21:44.479]                             muffled <- TRUE
[13:21:44.479]                             break
[13:21:44.479]                           }
[13:21:44.479]                         }
[13:21:44.479]                       }
[13:21:44.479]                       invisible(muffled)
[13:21:44.479]                     }
[13:21:44.479]                     muffleCondition(cond, pattern = "^muffle")
[13:21:44.479]                   }
[13:21:44.479]                 }
[13:21:44.479]                 else {
[13:21:44.479]                   if (TRUE) {
[13:21:44.479]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:44.479]                     {
[13:21:44.479]                       inherits <- base::inherits
[13:21:44.479]                       invokeRestart <- base::invokeRestart
[13:21:44.479]                       is.null <- base::is.null
[13:21:44.479]                       muffled <- FALSE
[13:21:44.479]                       if (inherits(cond, "message")) {
[13:21:44.479]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:44.479]                         if (muffled) 
[13:21:44.479]                           invokeRestart("muffleMessage")
[13:21:44.479]                       }
[13:21:44.479]                       else if (inherits(cond, "warning")) {
[13:21:44.479]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:44.479]                         if (muffled) 
[13:21:44.479]                           invokeRestart("muffleWarning")
[13:21:44.479]                       }
[13:21:44.479]                       else if (inherits(cond, "condition")) {
[13:21:44.479]                         if (!is.null(pattern)) {
[13:21:44.479]                           computeRestarts <- base::computeRestarts
[13:21:44.479]                           grepl <- base::grepl
[13:21:44.479]                           restarts <- computeRestarts(cond)
[13:21:44.479]                           for (restart in restarts) {
[13:21:44.479]                             name <- restart$name
[13:21:44.479]                             if (is.null(name)) 
[13:21:44.479]                               next
[13:21:44.479]                             if (!grepl(pattern, name)) 
[13:21:44.479]                               next
[13:21:44.479]                             invokeRestart(restart)
[13:21:44.479]                             muffled <- TRUE
[13:21:44.479]                             break
[13:21:44.479]                           }
[13:21:44.479]                         }
[13:21:44.479]                       }
[13:21:44.479]                       invisible(muffled)
[13:21:44.479]                     }
[13:21:44.479]                     muffleCondition(cond, pattern = "^muffle")
[13:21:44.479]                   }
[13:21:44.479]                 }
[13:21:44.479]             }
[13:21:44.479]         }))
[13:21:44.479]     }, error = function(ex) {
[13:21:44.479]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:44.479]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:44.479]                 ...future.rng), started = ...future.startTime, 
[13:21:44.479]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:44.479]             version = "1.8"), class = "FutureResult")
[13:21:44.479]     }, finally = {
[13:21:44.479]         if (!identical(...future.workdir, getwd())) 
[13:21:44.479]             setwd(...future.workdir)
[13:21:44.479]         {
[13:21:44.479]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:44.479]                 ...future.oldOptions$nwarnings <- NULL
[13:21:44.479]             }
[13:21:44.479]             base::options(...future.oldOptions)
[13:21:44.479]             if (.Platform$OS.type == "windows") {
[13:21:44.479]                 old_names <- names(...future.oldEnvVars)
[13:21:44.479]                 envs <- base::Sys.getenv()
[13:21:44.479]                 names <- names(envs)
[13:21:44.479]                 common <- intersect(names, old_names)
[13:21:44.479]                 added <- setdiff(names, old_names)
[13:21:44.479]                 removed <- setdiff(old_names, names)
[13:21:44.479]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:44.479]                   envs[common]]
[13:21:44.479]                 NAMES <- toupper(changed)
[13:21:44.479]                 args <- list()
[13:21:44.479]                 for (kk in seq_along(NAMES)) {
[13:21:44.479]                   name <- changed[[kk]]
[13:21:44.479]                   NAME <- NAMES[[kk]]
[13:21:44.479]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:44.479]                     next
[13:21:44.479]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:44.479]                 }
[13:21:44.479]                 NAMES <- toupper(added)
[13:21:44.479]                 for (kk in seq_along(NAMES)) {
[13:21:44.479]                   name <- added[[kk]]
[13:21:44.479]                   NAME <- NAMES[[kk]]
[13:21:44.479]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:44.479]                     next
[13:21:44.479]                   args[[name]] <- ""
[13:21:44.479]                 }
[13:21:44.479]                 NAMES <- toupper(removed)
[13:21:44.479]                 for (kk in seq_along(NAMES)) {
[13:21:44.479]                   name <- removed[[kk]]
[13:21:44.479]                   NAME <- NAMES[[kk]]
[13:21:44.479]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:44.479]                     next
[13:21:44.479]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:44.479]                 }
[13:21:44.479]                 if (length(args) > 0) 
[13:21:44.479]                   base::do.call(base::Sys.setenv, args = args)
[13:21:44.479]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:44.479]             }
[13:21:44.479]             else {
[13:21:44.479]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:44.479]             }
[13:21:44.479]             {
[13:21:44.479]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:44.479]                   0L) {
[13:21:44.479]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:44.479]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:44.479]                   base::options(opts)
[13:21:44.479]                 }
[13:21:44.479]                 {
[13:21:44.479]                   {
[13:21:44.479]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:44.479]                     NULL
[13:21:44.479]                   }
[13:21:44.479]                   options(future.plan = NULL)
[13:21:44.479]                   if (is.na(NA_character_)) 
[13:21:44.479]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:44.479]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:44.479]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:44.479]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:44.479]                     envir = parent.frame()) 
[13:21:44.479]                   {
[13:21:44.479]                     if (is.function(workers)) 
[13:21:44.479]                       workers <- workers()
[13:21:44.479]                     workers <- structure(as.integer(workers), 
[13:21:44.479]                       class = class(workers))
[13:21:44.479]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:44.479]                       workers >= 1)
[13:21:44.479]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:44.479]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:44.479]                     }
[13:21:44.479]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:44.479]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:44.479]                       envir = envir)
[13:21:44.479]                     if (!future$lazy) 
[13:21:44.479]                       future <- run(future)
[13:21:44.479]                     invisible(future)
[13:21:44.479]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:44.479]                 }
[13:21:44.479]             }
[13:21:44.479]         }
[13:21:44.479]     })
[13:21:44.479]     if (TRUE) {
[13:21:44.479]         base::sink(type = "output", split = FALSE)
[13:21:44.479]         if (TRUE) {
[13:21:44.479]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:44.479]         }
[13:21:44.479]         else {
[13:21:44.479]             ...future.result["stdout"] <- base::list(NULL)
[13:21:44.479]         }
[13:21:44.479]         base::close(...future.stdout)
[13:21:44.479]         ...future.stdout <- NULL
[13:21:44.479]     }
[13:21:44.479]     ...future.result$conditions <- ...future.conditions
[13:21:44.479]     ...future.result$finished <- base::Sys.time()
[13:21:44.479]     ...future.result
[13:21:44.479] }
[13:21:44.482] MultisessionFuture started
[13:21:44.482] - Launch lazy future ... done
[13:21:44.482] run() for ‘MultisessionFuture’ ... done
[13:21:44.529] receiveMessageFromWorker() for ClusterFuture ...
[13:21:44.529] - Validating connection of MultisessionFuture
[13:21:44.530] - received message: FutureResult
[13:21:44.530] - Received FutureResult
[13:21:44.530] - Erased future from FutureRegistry
[13:21:44.530] result() for ClusterFuture ...
[13:21:44.530] - result already collected: FutureResult
[13:21:44.530] result() for ClusterFuture ... done
[13:21:44.530] signalConditions() ...
[13:21:44.530]  - include = ‘immediateCondition’
[13:21:44.530]  - exclude = 
[13:21:44.531]  - resignal = FALSE
[13:21:44.531]  - Number of conditions: 1
[13:21:44.531] signalConditions() ... done
[13:21:44.531] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:44.531] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = FALSE ... DONE
- result = FALSE, recursive = TRUE ...
[13:21:44.531] getGlobalsAndPackages() ...
[13:21:44.531] Searching for globals...
[13:21:44.532] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:21:44.532] Searching for globals ... DONE
[13:21:44.533] Resolving globals: FALSE
[13:21:44.533] 
[13:21:44.533] 
[13:21:44.533] getGlobalsAndPackages() ... DONE
[13:21:44.533] run() for ‘Future’ ...
[13:21:44.533] - state: ‘created’
[13:21:44.534] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:44.548] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:44.548] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:44.549]   - Field: ‘node’
[13:21:44.549]   - Field: ‘label’
[13:21:44.549]   - Field: ‘local’
[13:21:44.549]   - Field: ‘owner’
[13:21:44.549]   - Field: ‘envir’
[13:21:44.549]   - Field: ‘workers’
[13:21:44.549]   - Field: ‘packages’
[13:21:44.549]   - Field: ‘gc’
[13:21:44.549]   - Field: ‘conditions’
[13:21:44.549]   - Field: ‘persistent’
[13:21:44.549]   - Field: ‘expr’
[13:21:44.550]   - Field: ‘uuid’
[13:21:44.550]   - Field: ‘seed’
[13:21:44.550]   - Field: ‘version’
[13:21:44.550]   - Field: ‘result’
[13:21:44.550]   - Field: ‘asynchronous’
[13:21:44.550]   - Field: ‘calls’
[13:21:44.550]   - Field: ‘globals’
[13:21:44.550]   - Field: ‘stdout’
[13:21:44.550]   - Field: ‘earlySignal’
[13:21:44.550]   - Field: ‘lazy’
[13:21:44.550]   - Field: ‘state’
[13:21:44.551] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:44.551] - Launch lazy future ...
[13:21:44.551] Packages needed by the future expression (n = 0): <none>
[13:21:44.551] Packages needed by future strategies (n = 0): <none>
[13:21:44.551] {
[13:21:44.551]     {
[13:21:44.551]         {
[13:21:44.551]             ...future.startTime <- base::Sys.time()
[13:21:44.551]             {
[13:21:44.551]                 {
[13:21:44.551]                   {
[13:21:44.551]                     {
[13:21:44.551]                       base::local({
[13:21:44.551]                         has_future <- base::requireNamespace("future", 
[13:21:44.551]                           quietly = TRUE)
[13:21:44.551]                         if (has_future) {
[13:21:44.551]                           ns <- base::getNamespace("future")
[13:21:44.551]                           version <- ns[[".package"]][["version"]]
[13:21:44.551]                           if (is.null(version)) 
[13:21:44.551]                             version <- utils::packageVersion("future")
[13:21:44.551]                         }
[13:21:44.551]                         else {
[13:21:44.551]                           version <- NULL
[13:21:44.551]                         }
[13:21:44.551]                         if (!has_future || version < "1.8.0") {
[13:21:44.551]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:44.551]                             "", base::R.version$version.string), 
[13:21:44.551]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:44.551]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:44.551]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:44.551]                               "release", "version")], collapse = " "), 
[13:21:44.551]                             hostname = base::Sys.info()[["nodename"]])
[13:21:44.551]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:44.551]                             info)
[13:21:44.551]                           info <- base::paste(info, collapse = "; ")
[13:21:44.551]                           if (!has_future) {
[13:21:44.551]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:44.551]                               info)
[13:21:44.551]                           }
[13:21:44.551]                           else {
[13:21:44.551]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:44.551]                               info, version)
[13:21:44.551]                           }
[13:21:44.551]                           base::stop(msg)
[13:21:44.551]                         }
[13:21:44.551]                       })
[13:21:44.551]                     }
[13:21:44.551]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:44.551]                     base::options(mc.cores = 1L)
[13:21:44.551]                   }
[13:21:44.551]                   options(future.plan = NULL)
[13:21:44.551]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:44.551]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:44.551]                 }
[13:21:44.551]                 ...future.workdir <- getwd()
[13:21:44.551]             }
[13:21:44.551]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:44.551]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:44.551]         }
[13:21:44.551]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:44.551]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:44.551]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:44.551]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:44.551]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:44.551]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:44.551]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:44.551]             base::names(...future.oldOptions))
[13:21:44.551]     }
[13:21:44.551]     if (FALSE) {
[13:21:44.551]     }
[13:21:44.551]     else {
[13:21:44.551]         if (TRUE) {
[13:21:44.551]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:44.551]                 open = "w")
[13:21:44.551]         }
[13:21:44.551]         else {
[13:21:44.551]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:44.551]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:44.551]         }
[13:21:44.551]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:44.551]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:44.551]             base::sink(type = "output", split = FALSE)
[13:21:44.551]             base::close(...future.stdout)
[13:21:44.551]         }, add = TRUE)
[13:21:44.551]     }
[13:21:44.551]     ...future.frame <- base::sys.nframe()
[13:21:44.551]     ...future.conditions <- base::list()
[13:21:44.551]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:44.551]     if (FALSE) {
[13:21:44.551]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:44.551]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:44.551]     }
[13:21:44.551]     ...future.result <- base::tryCatch({
[13:21:44.551]         base::withCallingHandlers({
[13:21:44.551]             ...future.value <- base::withVisible(base::local({
[13:21:44.551]                 ...future.makeSendCondition <- local({
[13:21:44.551]                   sendCondition <- NULL
[13:21:44.551]                   function(frame = 1L) {
[13:21:44.551]                     if (is.function(sendCondition)) 
[13:21:44.551]                       return(sendCondition)
[13:21:44.551]                     ns <- getNamespace("parallel")
[13:21:44.551]                     if (exists("sendData", mode = "function", 
[13:21:44.551]                       envir = ns)) {
[13:21:44.551]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:44.551]                         envir = ns)
[13:21:44.551]                       envir <- sys.frame(frame)
[13:21:44.551]                       master <- NULL
[13:21:44.551]                       while (!identical(envir, .GlobalEnv) && 
[13:21:44.551]                         !identical(envir, emptyenv())) {
[13:21:44.551]                         if (exists("master", mode = "list", envir = envir, 
[13:21:44.551]                           inherits = FALSE)) {
[13:21:44.551]                           master <- get("master", mode = "list", 
[13:21:44.551]                             envir = envir, inherits = FALSE)
[13:21:44.551]                           if (inherits(master, c("SOCKnode", 
[13:21:44.551]                             "SOCK0node"))) {
[13:21:44.551]                             sendCondition <<- function(cond) {
[13:21:44.551]                               data <- list(type = "VALUE", value = cond, 
[13:21:44.551]                                 success = TRUE)
[13:21:44.551]                               parallel_sendData(master, data)
[13:21:44.551]                             }
[13:21:44.551]                             return(sendCondition)
[13:21:44.551]                           }
[13:21:44.551]                         }
[13:21:44.551]                         frame <- frame + 1L
[13:21:44.551]                         envir <- sys.frame(frame)
[13:21:44.551]                       }
[13:21:44.551]                     }
[13:21:44.551]                     sendCondition <<- function(cond) NULL
[13:21:44.551]                   }
[13:21:44.551]                 })
[13:21:44.551]                 withCallingHandlers({
[13:21:44.551]                   {
[13:21:44.551]                     Sys.sleep(0.5)
[13:21:44.551]                     list(a = 1, b = 42L)
[13:21:44.551]                   }
[13:21:44.551]                 }, immediateCondition = function(cond) {
[13:21:44.551]                   sendCondition <- ...future.makeSendCondition()
[13:21:44.551]                   sendCondition(cond)
[13:21:44.551]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:44.551]                   {
[13:21:44.551]                     inherits <- base::inherits
[13:21:44.551]                     invokeRestart <- base::invokeRestart
[13:21:44.551]                     is.null <- base::is.null
[13:21:44.551]                     muffled <- FALSE
[13:21:44.551]                     if (inherits(cond, "message")) {
[13:21:44.551]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:44.551]                       if (muffled) 
[13:21:44.551]                         invokeRestart("muffleMessage")
[13:21:44.551]                     }
[13:21:44.551]                     else if (inherits(cond, "warning")) {
[13:21:44.551]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:44.551]                       if (muffled) 
[13:21:44.551]                         invokeRestart("muffleWarning")
[13:21:44.551]                     }
[13:21:44.551]                     else if (inherits(cond, "condition")) {
[13:21:44.551]                       if (!is.null(pattern)) {
[13:21:44.551]                         computeRestarts <- base::computeRestarts
[13:21:44.551]                         grepl <- base::grepl
[13:21:44.551]                         restarts <- computeRestarts(cond)
[13:21:44.551]                         for (restart in restarts) {
[13:21:44.551]                           name <- restart$name
[13:21:44.551]                           if (is.null(name)) 
[13:21:44.551]                             next
[13:21:44.551]                           if (!grepl(pattern, name)) 
[13:21:44.551]                             next
[13:21:44.551]                           invokeRestart(restart)
[13:21:44.551]                           muffled <- TRUE
[13:21:44.551]                           break
[13:21:44.551]                         }
[13:21:44.551]                       }
[13:21:44.551]                     }
[13:21:44.551]                     invisible(muffled)
[13:21:44.551]                   }
[13:21:44.551]                   muffleCondition(cond)
[13:21:44.551]                 })
[13:21:44.551]             }))
[13:21:44.551]             future::FutureResult(value = ...future.value$value, 
[13:21:44.551]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:44.551]                   ...future.rng), globalenv = if (FALSE) 
[13:21:44.551]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:44.551]                     ...future.globalenv.names))
[13:21:44.551]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:44.551]         }, condition = base::local({
[13:21:44.551]             c <- base::c
[13:21:44.551]             inherits <- base::inherits
[13:21:44.551]             invokeRestart <- base::invokeRestart
[13:21:44.551]             length <- base::length
[13:21:44.551]             list <- base::list
[13:21:44.551]             seq.int <- base::seq.int
[13:21:44.551]             signalCondition <- base::signalCondition
[13:21:44.551]             sys.calls <- base::sys.calls
[13:21:44.551]             `[[` <- base::`[[`
[13:21:44.551]             `+` <- base::`+`
[13:21:44.551]             `<<-` <- base::`<<-`
[13:21:44.551]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:44.551]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:44.551]                   3L)]
[13:21:44.551]             }
[13:21:44.551]             function(cond) {
[13:21:44.551]                 is_error <- inherits(cond, "error")
[13:21:44.551]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:44.551]                   NULL)
[13:21:44.551]                 if (is_error) {
[13:21:44.551]                   sessionInformation <- function() {
[13:21:44.551]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:44.551]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:44.551]                       search = base::search(), system = base::Sys.info())
[13:21:44.551]                   }
[13:21:44.551]                   ...future.conditions[[length(...future.conditions) + 
[13:21:44.551]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:44.551]                     cond$call), session = sessionInformation(), 
[13:21:44.551]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:44.551]                   signalCondition(cond)
[13:21:44.551]                 }
[13:21:44.551]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:44.551]                 "immediateCondition"))) {
[13:21:44.551]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:44.551]                   ...future.conditions[[length(...future.conditions) + 
[13:21:44.551]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:44.551]                   if (TRUE && !signal) {
[13:21:44.551]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:44.551]                     {
[13:21:44.551]                       inherits <- base::inherits
[13:21:44.551]                       invokeRestart <- base::invokeRestart
[13:21:44.551]                       is.null <- base::is.null
[13:21:44.551]                       muffled <- FALSE
[13:21:44.551]                       if (inherits(cond, "message")) {
[13:21:44.551]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:44.551]                         if (muffled) 
[13:21:44.551]                           invokeRestart("muffleMessage")
[13:21:44.551]                       }
[13:21:44.551]                       else if (inherits(cond, "warning")) {
[13:21:44.551]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:44.551]                         if (muffled) 
[13:21:44.551]                           invokeRestart("muffleWarning")
[13:21:44.551]                       }
[13:21:44.551]                       else if (inherits(cond, "condition")) {
[13:21:44.551]                         if (!is.null(pattern)) {
[13:21:44.551]                           computeRestarts <- base::computeRestarts
[13:21:44.551]                           grepl <- base::grepl
[13:21:44.551]                           restarts <- computeRestarts(cond)
[13:21:44.551]                           for (restart in restarts) {
[13:21:44.551]                             name <- restart$name
[13:21:44.551]                             if (is.null(name)) 
[13:21:44.551]                               next
[13:21:44.551]                             if (!grepl(pattern, name)) 
[13:21:44.551]                               next
[13:21:44.551]                             invokeRestart(restart)
[13:21:44.551]                             muffled <- TRUE
[13:21:44.551]                             break
[13:21:44.551]                           }
[13:21:44.551]                         }
[13:21:44.551]                       }
[13:21:44.551]                       invisible(muffled)
[13:21:44.551]                     }
[13:21:44.551]                     muffleCondition(cond, pattern = "^muffle")
[13:21:44.551]                   }
[13:21:44.551]                 }
[13:21:44.551]                 else {
[13:21:44.551]                   if (TRUE) {
[13:21:44.551]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:44.551]                     {
[13:21:44.551]                       inherits <- base::inherits
[13:21:44.551]                       invokeRestart <- base::invokeRestart
[13:21:44.551]                       is.null <- base::is.null
[13:21:44.551]                       muffled <- FALSE
[13:21:44.551]                       if (inherits(cond, "message")) {
[13:21:44.551]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:44.551]                         if (muffled) 
[13:21:44.551]                           invokeRestart("muffleMessage")
[13:21:44.551]                       }
[13:21:44.551]                       else if (inherits(cond, "warning")) {
[13:21:44.551]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:44.551]                         if (muffled) 
[13:21:44.551]                           invokeRestart("muffleWarning")
[13:21:44.551]                       }
[13:21:44.551]                       else if (inherits(cond, "condition")) {
[13:21:44.551]                         if (!is.null(pattern)) {
[13:21:44.551]                           computeRestarts <- base::computeRestarts
[13:21:44.551]                           grepl <- base::grepl
[13:21:44.551]                           restarts <- computeRestarts(cond)
[13:21:44.551]                           for (restart in restarts) {
[13:21:44.551]                             name <- restart$name
[13:21:44.551]                             if (is.null(name)) 
[13:21:44.551]                               next
[13:21:44.551]                             if (!grepl(pattern, name)) 
[13:21:44.551]                               next
[13:21:44.551]                             invokeRestart(restart)
[13:21:44.551]                             muffled <- TRUE
[13:21:44.551]                             break
[13:21:44.551]                           }
[13:21:44.551]                         }
[13:21:44.551]                       }
[13:21:44.551]                       invisible(muffled)
[13:21:44.551]                     }
[13:21:44.551]                     muffleCondition(cond, pattern = "^muffle")
[13:21:44.551]                   }
[13:21:44.551]                 }
[13:21:44.551]             }
[13:21:44.551]         }))
[13:21:44.551]     }, error = function(ex) {
[13:21:44.551]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:44.551]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:44.551]                 ...future.rng), started = ...future.startTime, 
[13:21:44.551]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:44.551]             version = "1.8"), class = "FutureResult")
[13:21:44.551]     }, finally = {
[13:21:44.551]         if (!identical(...future.workdir, getwd())) 
[13:21:44.551]             setwd(...future.workdir)
[13:21:44.551]         {
[13:21:44.551]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:44.551]                 ...future.oldOptions$nwarnings <- NULL
[13:21:44.551]             }
[13:21:44.551]             base::options(...future.oldOptions)
[13:21:44.551]             if (.Platform$OS.type == "windows") {
[13:21:44.551]                 old_names <- names(...future.oldEnvVars)
[13:21:44.551]                 envs <- base::Sys.getenv()
[13:21:44.551]                 names <- names(envs)
[13:21:44.551]                 common <- intersect(names, old_names)
[13:21:44.551]                 added <- setdiff(names, old_names)
[13:21:44.551]                 removed <- setdiff(old_names, names)
[13:21:44.551]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:44.551]                   envs[common]]
[13:21:44.551]                 NAMES <- toupper(changed)
[13:21:44.551]                 args <- list()
[13:21:44.551]                 for (kk in seq_along(NAMES)) {
[13:21:44.551]                   name <- changed[[kk]]
[13:21:44.551]                   NAME <- NAMES[[kk]]
[13:21:44.551]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:44.551]                     next
[13:21:44.551]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:44.551]                 }
[13:21:44.551]                 NAMES <- toupper(added)
[13:21:44.551]                 for (kk in seq_along(NAMES)) {
[13:21:44.551]                   name <- added[[kk]]
[13:21:44.551]                   NAME <- NAMES[[kk]]
[13:21:44.551]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:44.551]                     next
[13:21:44.551]                   args[[name]] <- ""
[13:21:44.551]                 }
[13:21:44.551]                 NAMES <- toupper(removed)
[13:21:44.551]                 for (kk in seq_along(NAMES)) {
[13:21:44.551]                   name <- removed[[kk]]
[13:21:44.551]                   NAME <- NAMES[[kk]]
[13:21:44.551]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:44.551]                     next
[13:21:44.551]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:44.551]                 }
[13:21:44.551]                 if (length(args) > 0) 
[13:21:44.551]                   base::do.call(base::Sys.setenv, args = args)
[13:21:44.551]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:44.551]             }
[13:21:44.551]             else {
[13:21:44.551]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:44.551]             }
[13:21:44.551]             {
[13:21:44.551]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:44.551]                   0L) {
[13:21:44.551]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:44.551]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:44.551]                   base::options(opts)
[13:21:44.551]                 }
[13:21:44.551]                 {
[13:21:44.551]                   {
[13:21:44.551]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:44.551]                     NULL
[13:21:44.551]                   }
[13:21:44.551]                   options(future.plan = NULL)
[13:21:44.551]                   if (is.na(NA_character_)) 
[13:21:44.551]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:44.551]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:44.551]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:44.551]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:44.551]                     envir = parent.frame()) 
[13:21:44.551]                   {
[13:21:44.551]                     if (is.function(workers)) 
[13:21:44.551]                       workers <- workers()
[13:21:44.551]                     workers <- structure(as.integer(workers), 
[13:21:44.551]                       class = class(workers))
[13:21:44.551]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:44.551]                       workers >= 1)
[13:21:44.551]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:44.551]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:44.551]                     }
[13:21:44.551]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:44.551]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:44.551]                       envir = envir)
[13:21:44.551]                     if (!future$lazy) 
[13:21:44.551]                       future <- run(future)
[13:21:44.551]                     invisible(future)
[13:21:44.551]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:44.551]                 }
[13:21:44.551]             }
[13:21:44.551]         }
[13:21:44.551]     })
[13:21:44.551]     if (TRUE) {
[13:21:44.551]         base::sink(type = "output", split = FALSE)
[13:21:44.551]         if (TRUE) {
[13:21:44.551]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:44.551]         }
[13:21:44.551]         else {
[13:21:44.551]             ...future.result["stdout"] <- base::list(NULL)
[13:21:44.551]         }
[13:21:44.551]         base::close(...future.stdout)
[13:21:44.551]         ...future.stdout <- NULL
[13:21:44.551]     }
[13:21:44.551]     ...future.result$conditions <- ...future.conditions
[13:21:44.551]     ...future.result$finished <- base::Sys.time()
[13:21:44.551]     ...future.result
[13:21:44.551] }
[13:21:44.554] MultisessionFuture started
[13:21:44.554] - Launch lazy future ... done
[13:21:44.555] run() for ‘MultisessionFuture’ ... done
[13:21:45.111] receiveMessageFromWorker() for ClusterFuture ...
[13:21:45.111] - Validating connection of MultisessionFuture
[13:21:45.112] - received message: FutureResult
[13:21:45.112] - Received FutureResult
[13:21:45.112] - Erased future from FutureRegistry
[13:21:45.112] result() for ClusterFuture ...
[13:21:45.112] - result already collected: FutureResult
[13:21:45.112] result() for ClusterFuture ... done
[13:21:45.112] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:45.112] A MultisessionFuture was resolved (result was not collected)
[13:21:45.112] getGlobalsAndPackages() ...
[13:21:45.112] Searching for globals...
[13:21:45.114] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:21:45.114] Searching for globals ... DONE
[13:21:45.114] Resolving globals: FALSE
[13:21:45.114] 
[13:21:45.114] 
[13:21:45.114] getGlobalsAndPackages() ... DONE
[13:21:45.115] run() for ‘Future’ ...
[13:21:45.115] - state: ‘created’
[13:21:45.115] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:45.129] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:45.129] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:45.130]   - Field: ‘node’
[13:21:45.130]   - Field: ‘label’
[13:21:45.130]   - Field: ‘local’
[13:21:45.130]   - Field: ‘owner’
[13:21:45.130]   - Field: ‘envir’
[13:21:45.130]   - Field: ‘workers’
[13:21:45.130]   - Field: ‘packages’
[13:21:45.130]   - Field: ‘gc’
[13:21:45.130]   - Field: ‘conditions’
[13:21:45.130]   - Field: ‘persistent’
[13:21:45.131]   - Field: ‘expr’
[13:21:45.131]   - Field: ‘uuid’
[13:21:45.131]   - Field: ‘seed’
[13:21:45.131]   - Field: ‘version’
[13:21:45.131]   - Field: ‘result’
[13:21:45.131]   - Field: ‘asynchronous’
[13:21:45.131]   - Field: ‘calls’
[13:21:45.131]   - Field: ‘globals’
[13:21:45.131]   - Field: ‘stdout’
[13:21:45.131]   - Field: ‘earlySignal’
[13:21:45.131]   - Field: ‘lazy’
[13:21:45.131]   - Field: ‘state’
[13:21:45.132] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:45.132] - Launch lazy future ...
[13:21:45.132] Packages needed by the future expression (n = 0): <none>
[13:21:45.132] Packages needed by future strategies (n = 0): <none>
[13:21:45.132] {
[13:21:45.132]     {
[13:21:45.132]         {
[13:21:45.132]             ...future.startTime <- base::Sys.time()
[13:21:45.132]             {
[13:21:45.132]                 {
[13:21:45.132]                   {
[13:21:45.132]                     {
[13:21:45.132]                       base::local({
[13:21:45.132]                         has_future <- base::requireNamespace("future", 
[13:21:45.132]                           quietly = TRUE)
[13:21:45.132]                         if (has_future) {
[13:21:45.132]                           ns <- base::getNamespace("future")
[13:21:45.132]                           version <- ns[[".package"]][["version"]]
[13:21:45.132]                           if (is.null(version)) 
[13:21:45.132]                             version <- utils::packageVersion("future")
[13:21:45.132]                         }
[13:21:45.132]                         else {
[13:21:45.132]                           version <- NULL
[13:21:45.132]                         }
[13:21:45.132]                         if (!has_future || version < "1.8.0") {
[13:21:45.132]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:45.132]                             "", base::R.version$version.string), 
[13:21:45.132]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:45.132]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:45.132]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:45.132]                               "release", "version")], collapse = " "), 
[13:21:45.132]                             hostname = base::Sys.info()[["nodename"]])
[13:21:45.132]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:45.132]                             info)
[13:21:45.132]                           info <- base::paste(info, collapse = "; ")
[13:21:45.132]                           if (!has_future) {
[13:21:45.132]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:45.132]                               info)
[13:21:45.132]                           }
[13:21:45.132]                           else {
[13:21:45.132]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:45.132]                               info, version)
[13:21:45.132]                           }
[13:21:45.132]                           base::stop(msg)
[13:21:45.132]                         }
[13:21:45.132]                       })
[13:21:45.132]                     }
[13:21:45.132]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:45.132]                     base::options(mc.cores = 1L)
[13:21:45.132]                   }
[13:21:45.132]                   options(future.plan = NULL)
[13:21:45.132]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:45.132]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:45.132]                 }
[13:21:45.132]                 ...future.workdir <- getwd()
[13:21:45.132]             }
[13:21:45.132]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:45.132]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:45.132]         }
[13:21:45.132]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:45.132]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:45.132]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:45.132]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:45.132]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:45.132]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:45.132]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:45.132]             base::names(...future.oldOptions))
[13:21:45.132]     }
[13:21:45.132]     if (FALSE) {
[13:21:45.132]     }
[13:21:45.132]     else {
[13:21:45.132]         if (TRUE) {
[13:21:45.132]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:45.132]                 open = "w")
[13:21:45.132]         }
[13:21:45.132]         else {
[13:21:45.132]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:45.132]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:45.132]         }
[13:21:45.132]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:45.132]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:45.132]             base::sink(type = "output", split = FALSE)
[13:21:45.132]             base::close(...future.stdout)
[13:21:45.132]         }, add = TRUE)
[13:21:45.132]     }
[13:21:45.132]     ...future.frame <- base::sys.nframe()
[13:21:45.132]     ...future.conditions <- base::list()
[13:21:45.132]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:45.132]     if (FALSE) {
[13:21:45.132]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:45.132]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:45.132]     }
[13:21:45.132]     ...future.result <- base::tryCatch({
[13:21:45.132]         base::withCallingHandlers({
[13:21:45.132]             ...future.value <- base::withVisible(base::local({
[13:21:45.132]                 ...future.makeSendCondition <- local({
[13:21:45.132]                   sendCondition <- NULL
[13:21:45.132]                   function(frame = 1L) {
[13:21:45.132]                     if (is.function(sendCondition)) 
[13:21:45.132]                       return(sendCondition)
[13:21:45.132]                     ns <- getNamespace("parallel")
[13:21:45.132]                     if (exists("sendData", mode = "function", 
[13:21:45.132]                       envir = ns)) {
[13:21:45.132]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:45.132]                         envir = ns)
[13:21:45.132]                       envir <- sys.frame(frame)
[13:21:45.132]                       master <- NULL
[13:21:45.132]                       while (!identical(envir, .GlobalEnv) && 
[13:21:45.132]                         !identical(envir, emptyenv())) {
[13:21:45.132]                         if (exists("master", mode = "list", envir = envir, 
[13:21:45.132]                           inherits = FALSE)) {
[13:21:45.132]                           master <- get("master", mode = "list", 
[13:21:45.132]                             envir = envir, inherits = FALSE)
[13:21:45.132]                           if (inherits(master, c("SOCKnode", 
[13:21:45.132]                             "SOCK0node"))) {
[13:21:45.132]                             sendCondition <<- function(cond) {
[13:21:45.132]                               data <- list(type = "VALUE", value = cond, 
[13:21:45.132]                                 success = TRUE)
[13:21:45.132]                               parallel_sendData(master, data)
[13:21:45.132]                             }
[13:21:45.132]                             return(sendCondition)
[13:21:45.132]                           }
[13:21:45.132]                         }
[13:21:45.132]                         frame <- frame + 1L
[13:21:45.132]                         envir <- sys.frame(frame)
[13:21:45.132]                       }
[13:21:45.132]                     }
[13:21:45.132]                     sendCondition <<- function(cond) NULL
[13:21:45.132]                   }
[13:21:45.132]                 })
[13:21:45.132]                 withCallingHandlers({
[13:21:45.132]                   {
[13:21:45.132]                     Sys.sleep(0.5)
[13:21:45.132]                     list(a = 1, b = 42L)
[13:21:45.132]                   }
[13:21:45.132]                 }, immediateCondition = function(cond) {
[13:21:45.132]                   sendCondition <- ...future.makeSendCondition()
[13:21:45.132]                   sendCondition(cond)
[13:21:45.132]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:45.132]                   {
[13:21:45.132]                     inherits <- base::inherits
[13:21:45.132]                     invokeRestart <- base::invokeRestart
[13:21:45.132]                     is.null <- base::is.null
[13:21:45.132]                     muffled <- FALSE
[13:21:45.132]                     if (inherits(cond, "message")) {
[13:21:45.132]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:45.132]                       if (muffled) 
[13:21:45.132]                         invokeRestart("muffleMessage")
[13:21:45.132]                     }
[13:21:45.132]                     else if (inherits(cond, "warning")) {
[13:21:45.132]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:45.132]                       if (muffled) 
[13:21:45.132]                         invokeRestart("muffleWarning")
[13:21:45.132]                     }
[13:21:45.132]                     else if (inherits(cond, "condition")) {
[13:21:45.132]                       if (!is.null(pattern)) {
[13:21:45.132]                         computeRestarts <- base::computeRestarts
[13:21:45.132]                         grepl <- base::grepl
[13:21:45.132]                         restarts <- computeRestarts(cond)
[13:21:45.132]                         for (restart in restarts) {
[13:21:45.132]                           name <- restart$name
[13:21:45.132]                           if (is.null(name)) 
[13:21:45.132]                             next
[13:21:45.132]                           if (!grepl(pattern, name)) 
[13:21:45.132]                             next
[13:21:45.132]                           invokeRestart(restart)
[13:21:45.132]                           muffled <- TRUE
[13:21:45.132]                           break
[13:21:45.132]                         }
[13:21:45.132]                       }
[13:21:45.132]                     }
[13:21:45.132]                     invisible(muffled)
[13:21:45.132]                   }
[13:21:45.132]                   muffleCondition(cond)
[13:21:45.132]                 })
[13:21:45.132]             }))
[13:21:45.132]             future::FutureResult(value = ...future.value$value, 
[13:21:45.132]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:45.132]                   ...future.rng), globalenv = if (FALSE) 
[13:21:45.132]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:45.132]                     ...future.globalenv.names))
[13:21:45.132]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:45.132]         }, condition = base::local({
[13:21:45.132]             c <- base::c
[13:21:45.132]             inherits <- base::inherits
[13:21:45.132]             invokeRestart <- base::invokeRestart
[13:21:45.132]             length <- base::length
[13:21:45.132]             list <- base::list
[13:21:45.132]             seq.int <- base::seq.int
[13:21:45.132]             signalCondition <- base::signalCondition
[13:21:45.132]             sys.calls <- base::sys.calls
[13:21:45.132]             `[[` <- base::`[[`
[13:21:45.132]             `+` <- base::`+`
[13:21:45.132]             `<<-` <- base::`<<-`
[13:21:45.132]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:45.132]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:45.132]                   3L)]
[13:21:45.132]             }
[13:21:45.132]             function(cond) {
[13:21:45.132]                 is_error <- inherits(cond, "error")
[13:21:45.132]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:45.132]                   NULL)
[13:21:45.132]                 if (is_error) {
[13:21:45.132]                   sessionInformation <- function() {
[13:21:45.132]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:45.132]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:45.132]                       search = base::search(), system = base::Sys.info())
[13:21:45.132]                   }
[13:21:45.132]                   ...future.conditions[[length(...future.conditions) + 
[13:21:45.132]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:45.132]                     cond$call), session = sessionInformation(), 
[13:21:45.132]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:45.132]                   signalCondition(cond)
[13:21:45.132]                 }
[13:21:45.132]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:45.132]                 "immediateCondition"))) {
[13:21:45.132]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:45.132]                   ...future.conditions[[length(...future.conditions) + 
[13:21:45.132]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:45.132]                   if (TRUE && !signal) {
[13:21:45.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:45.132]                     {
[13:21:45.132]                       inherits <- base::inherits
[13:21:45.132]                       invokeRestart <- base::invokeRestart
[13:21:45.132]                       is.null <- base::is.null
[13:21:45.132]                       muffled <- FALSE
[13:21:45.132]                       if (inherits(cond, "message")) {
[13:21:45.132]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:45.132]                         if (muffled) 
[13:21:45.132]                           invokeRestart("muffleMessage")
[13:21:45.132]                       }
[13:21:45.132]                       else if (inherits(cond, "warning")) {
[13:21:45.132]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:45.132]                         if (muffled) 
[13:21:45.132]                           invokeRestart("muffleWarning")
[13:21:45.132]                       }
[13:21:45.132]                       else if (inherits(cond, "condition")) {
[13:21:45.132]                         if (!is.null(pattern)) {
[13:21:45.132]                           computeRestarts <- base::computeRestarts
[13:21:45.132]                           grepl <- base::grepl
[13:21:45.132]                           restarts <- computeRestarts(cond)
[13:21:45.132]                           for (restart in restarts) {
[13:21:45.132]                             name <- restart$name
[13:21:45.132]                             if (is.null(name)) 
[13:21:45.132]                               next
[13:21:45.132]                             if (!grepl(pattern, name)) 
[13:21:45.132]                               next
[13:21:45.132]                             invokeRestart(restart)
[13:21:45.132]                             muffled <- TRUE
[13:21:45.132]                             break
[13:21:45.132]                           }
[13:21:45.132]                         }
[13:21:45.132]                       }
[13:21:45.132]                       invisible(muffled)
[13:21:45.132]                     }
[13:21:45.132]                     muffleCondition(cond, pattern = "^muffle")
[13:21:45.132]                   }
[13:21:45.132]                 }
[13:21:45.132]                 else {
[13:21:45.132]                   if (TRUE) {
[13:21:45.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:45.132]                     {
[13:21:45.132]                       inherits <- base::inherits
[13:21:45.132]                       invokeRestart <- base::invokeRestart
[13:21:45.132]                       is.null <- base::is.null
[13:21:45.132]                       muffled <- FALSE
[13:21:45.132]                       if (inherits(cond, "message")) {
[13:21:45.132]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:45.132]                         if (muffled) 
[13:21:45.132]                           invokeRestart("muffleMessage")
[13:21:45.132]                       }
[13:21:45.132]                       else if (inherits(cond, "warning")) {
[13:21:45.132]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:45.132]                         if (muffled) 
[13:21:45.132]                           invokeRestart("muffleWarning")
[13:21:45.132]                       }
[13:21:45.132]                       else if (inherits(cond, "condition")) {
[13:21:45.132]                         if (!is.null(pattern)) {
[13:21:45.132]                           computeRestarts <- base::computeRestarts
[13:21:45.132]                           grepl <- base::grepl
[13:21:45.132]                           restarts <- computeRestarts(cond)
[13:21:45.132]                           for (restart in restarts) {
[13:21:45.132]                             name <- restart$name
[13:21:45.132]                             if (is.null(name)) 
[13:21:45.132]                               next
[13:21:45.132]                             if (!grepl(pattern, name)) 
[13:21:45.132]                               next
[13:21:45.132]                             invokeRestart(restart)
[13:21:45.132]                             muffled <- TRUE
[13:21:45.132]                             break
[13:21:45.132]                           }
[13:21:45.132]                         }
[13:21:45.132]                       }
[13:21:45.132]                       invisible(muffled)
[13:21:45.132]                     }
[13:21:45.132]                     muffleCondition(cond, pattern = "^muffle")
[13:21:45.132]                   }
[13:21:45.132]                 }
[13:21:45.132]             }
[13:21:45.132]         }))
[13:21:45.132]     }, error = function(ex) {
[13:21:45.132]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:45.132]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:45.132]                 ...future.rng), started = ...future.startTime, 
[13:21:45.132]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:45.132]             version = "1.8"), class = "FutureResult")
[13:21:45.132]     }, finally = {
[13:21:45.132]         if (!identical(...future.workdir, getwd())) 
[13:21:45.132]             setwd(...future.workdir)
[13:21:45.132]         {
[13:21:45.132]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:45.132]                 ...future.oldOptions$nwarnings <- NULL
[13:21:45.132]             }
[13:21:45.132]             base::options(...future.oldOptions)
[13:21:45.132]             if (.Platform$OS.type == "windows") {
[13:21:45.132]                 old_names <- names(...future.oldEnvVars)
[13:21:45.132]                 envs <- base::Sys.getenv()
[13:21:45.132]                 names <- names(envs)
[13:21:45.132]                 common <- intersect(names, old_names)
[13:21:45.132]                 added <- setdiff(names, old_names)
[13:21:45.132]                 removed <- setdiff(old_names, names)
[13:21:45.132]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:45.132]                   envs[common]]
[13:21:45.132]                 NAMES <- toupper(changed)
[13:21:45.132]                 args <- list()
[13:21:45.132]                 for (kk in seq_along(NAMES)) {
[13:21:45.132]                   name <- changed[[kk]]
[13:21:45.132]                   NAME <- NAMES[[kk]]
[13:21:45.132]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:45.132]                     next
[13:21:45.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:45.132]                 }
[13:21:45.132]                 NAMES <- toupper(added)
[13:21:45.132]                 for (kk in seq_along(NAMES)) {
[13:21:45.132]                   name <- added[[kk]]
[13:21:45.132]                   NAME <- NAMES[[kk]]
[13:21:45.132]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:45.132]                     next
[13:21:45.132]                   args[[name]] <- ""
[13:21:45.132]                 }
[13:21:45.132]                 NAMES <- toupper(removed)
[13:21:45.132]                 for (kk in seq_along(NAMES)) {
[13:21:45.132]                   name <- removed[[kk]]
[13:21:45.132]                   NAME <- NAMES[[kk]]
[13:21:45.132]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:45.132]                     next
[13:21:45.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:45.132]                 }
[13:21:45.132]                 if (length(args) > 0) 
[13:21:45.132]                   base::do.call(base::Sys.setenv, args = args)
[13:21:45.132]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:45.132]             }
[13:21:45.132]             else {
[13:21:45.132]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:45.132]             }
[13:21:45.132]             {
[13:21:45.132]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:45.132]                   0L) {
[13:21:45.132]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:45.132]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:45.132]                   base::options(opts)
[13:21:45.132]                 }
[13:21:45.132]                 {
[13:21:45.132]                   {
[13:21:45.132]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:45.132]                     NULL
[13:21:45.132]                   }
[13:21:45.132]                   options(future.plan = NULL)
[13:21:45.132]                   if (is.na(NA_character_)) 
[13:21:45.132]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:45.132]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:45.132]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:45.132]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:45.132]                     envir = parent.frame()) 
[13:21:45.132]                   {
[13:21:45.132]                     if (is.function(workers)) 
[13:21:45.132]                       workers <- workers()
[13:21:45.132]                     workers <- structure(as.integer(workers), 
[13:21:45.132]                       class = class(workers))
[13:21:45.132]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:45.132]                       workers >= 1)
[13:21:45.132]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:45.132]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:45.132]                     }
[13:21:45.132]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:45.132]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:45.132]                       envir = envir)
[13:21:45.132]                     if (!future$lazy) 
[13:21:45.132]                       future <- run(future)
[13:21:45.132]                     invisible(future)
[13:21:45.132]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:45.132]                 }
[13:21:45.132]             }
[13:21:45.132]         }
[13:21:45.132]     })
[13:21:45.132]     if (TRUE) {
[13:21:45.132]         base::sink(type = "output", split = FALSE)
[13:21:45.132]         if (TRUE) {
[13:21:45.132]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:45.132]         }
[13:21:45.132]         else {
[13:21:45.132]             ...future.result["stdout"] <- base::list(NULL)
[13:21:45.132]         }
[13:21:45.132]         base::close(...future.stdout)
[13:21:45.132]         ...future.stdout <- NULL
[13:21:45.132]     }
[13:21:45.132]     ...future.result$conditions <- ...future.conditions
[13:21:45.132]     ...future.result$finished <- base::Sys.time()
[13:21:45.132]     ...future.result
[13:21:45.132] }
[13:21:45.136] MultisessionFuture started
[13:21:45.136] - Launch lazy future ... done
[13:21:45.136] run() for ‘MultisessionFuture’ ... done
[13:21:45.683] receiveMessageFromWorker() for ClusterFuture ...
[13:21:45.683] - Validating connection of MultisessionFuture
[13:21:45.683] - received message: FutureResult
[13:21:45.683] - Received FutureResult
[13:21:45.683] - Erased future from FutureRegistry
[13:21:45.683] result() for ClusterFuture ...
[13:21:45.684] - result already collected: FutureResult
[13:21:45.684] result() for ClusterFuture ... done
[13:21:45.684] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:45.684] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[13:21:45.684] getGlobalsAndPackages() ...
[13:21:45.684] Searching for globals...
[13:21:45.685] - globals found: [2] ‘list’, ‘stop’
[13:21:45.685] Searching for globals ... DONE
[13:21:45.685] Resolving globals: FALSE
[13:21:45.685] 
[13:21:45.685] 
[13:21:45.686] getGlobalsAndPackages() ... DONE
[13:21:45.686] run() for ‘Future’ ...
[13:21:45.686] - state: ‘created’
[13:21:45.686] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:45.700] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:45.701] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:45.701]   - Field: ‘node’
[13:21:45.701]   - Field: ‘label’
[13:21:45.701]   - Field: ‘local’
[13:21:45.701]   - Field: ‘owner’
[13:21:45.701]   - Field: ‘envir’
[13:21:45.701]   - Field: ‘workers’
[13:21:45.701]   - Field: ‘packages’
[13:21:45.701]   - Field: ‘gc’
[13:21:45.702]   - Field: ‘conditions’
[13:21:45.702]   - Field: ‘persistent’
[13:21:45.702]   - Field: ‘expr’
[13:21:45.702]   - Field: ‘uuid’
[13:21:45.702]   - Field: ‘seed’
[13:21:45.702]   - Field: ‘version’
[13:21:45.702]   - Field: ‘result’
[13:21:45.702]   - Field: ‘asynchronous’
[13:21:45.702]   - Field: ‘calls’
[13:21:45.702]   - Field: ‘globals’
[13:21:45.702]   - Field: ‘stdout’
[13:21:45.703]   - Field: ‘earlySignal’
[13:21:45.703]   - Field: ‘lazy’
[13:21:45.703]   - Field: ‘state’
[13:21:45.703] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:45.703] - Launch lazy future ...
[13:21:45.703] Packages needed by the future expression (n = 0): <none>
[13:21:45.703] Packages needed by future strategies (n = 0): <none>
[13:21:45.704] {
[13:21:45.704]     {
[13:21:45.704]         {
[13:21:45.704]             ...future.startTime <- base::Sys.time()
[13:21:45.704]             {
[13:21:45.704]                 {
[13:21:45.704]                   {
[13:21:45.704]                     {
[13:21:45.704]                       base::local({
[13:21:45.704]                         has_future <- base::requireNamespace("future", 
[13:21:45.704]                           quietly = TRUE)
[13:21:45.704]                         if (has_future) {
[13:21:45.704]                           ns <- base::getNamespace("future")
[13:21:45.704]                           version <- ns[[".package"]][["version"]]
[13:21:45.704]                           if (is.null(version)) 
[13:21:45.704]                             version <- utils::packageVersion("future")
[13:21:45.704]                         }
[13:21:45.704]                         else {
[13:21:45.704]                           version <- NULL
[13:21:45.704]                         }
[13:21:45.704]                         if (!has_future || version < "1.8.0") {
[13:21:45.704]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:45.704]                             "", base::R.version$version.string), 
[13:21:45.704]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:45.704]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:45.704]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:45.704]                               "release", "version")], collapse = " "), 
[13:21:45.704]                             hostname = base::Sys.info()[["nodename"]])
[13:21:45.704]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:45.704]                             info)
[13:21:45.704]                           info <- base::paste(info, collapse = "; ")
[13:21:45.704]                           if (!has_future) {
[13:21:45.704]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:45.704]                               info)
[13:21:45.704]                           }
[13:21:45.704]                           else {
[13:21:45.704]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:45.704]                               info, version)
[13:21:45.704]                           }
[13:21:45.704]                           base::stop(msg)
[13:21:45.704]                         }
[13:21:45.704]                       })
[13:21:45.704]                     }
[13:21:45.704]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:45.704]                     base::options(mc.cores = 1L)
[13:21:45.704]                   }
[13:21:45.704]                   options(future.plan = NULL)
[13:21:45.704]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:45.704]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:45.704]                 }
[13:21:45.704]                 ...future.workdir <- getwd()
[13:21:45.704]             }
[13:21:45.704]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:45.704]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:45.704]         }
[13:21:45.704]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:45.704]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:45.704]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:45.704]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:45.704]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:45.704]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:45.704]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:45.704]             base::names(...future.oldOptions))
[13:21:45.704]     }
[13:21:45.704]     if (FALSE) {
[13:21:45.704]     }
[13:21:45.704]     else {
[13:21:45.704]         if (TRUE) {
[13:21:45.704]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:45.704]                 open = "w")
[13:21:45.704]         }
[13:21:45.704]         else {
[13:21:45.704]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:45.704]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:45.704]         }
[13:21:45.704]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:45.704]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:45.704]             base::sink(type = "output", split = FALSE)
[13:21:45.704]             base::close(...future.stdout)
[13:21:45.704]         }, add = TRUE)
[13:21:45.704]     }
[13:21:45.704]     ...future.frame <- base::sys.nframe()
[13:21:45.704]     ...future.conditions <- base::list()
[13:21:45.704]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:45.704]     if (FALSE) {
[13:21:45.704]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:45.704]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:45.704]     }
[13:21:45.704]     ...future.result <- base::tryCatch({
[13:21:45.704]         base::withCallingHandlers({
[13:21:45.704]             ...future.value <- base::withVisible(base::local({
[13:21:45.704]                 ...future.makeSendCondition <- local({
[13:21:45.704]                   sendCondition <- NULL
[13:21:45.704]                   function(frame = 1L) {
[13:21:45.704]                     if (is.function(sendCondition)) 
[13:21:45.704]                       return(sendCondition)
[13:21:45.704]                     ns <- getNamespace("parallel")
[13:21:45.704]                     if (exists("sendData", mode = "function", 
[13:21:45.704]                       envir = ns)) {
[13:21:45.704]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:45.704]                         envir = ns)
[13:21:45.704]                       envir <- sys.frame(frame)
[13:21:45.704]                       master <- NULL
[13:21:45.704]                       while (!identical(envir, .GlobalEnv) && 
[13:21:45.704]                         !identical(envir, emptyenv())) {
[13:21:45.704]                         if (exists("master", mode = "list", envir = envir, 
[13:21:45.704]                           inherits = FALSE)) {
[13:21:45.704]                           master <- get("master", mode = "list", 
[13:21:45.704]                             envir = envir, inherits = FALSE)
[13:21:45.704]                           if (inherits(master, c("SOCKnode", 
[13:21:45.704]                             "SOCK0node"))) {
[13:21:45.704]                             sendCondition <<- function(cond) {
[13:21:45.704]                               data <- list(type = "VALUE", value = cond, 
[13:21:45.704]                                 success = TRUE)
[13:21:45.704]                               parallel_sendData(master, data)
[13:21:45.704]                             }
[13:21:45.704]                             return(sendCondition)
[13:21:45.704]                           }
[13:21:45.704]                         }
[13:21:45.704]                         frame <- frame + 1L
[13:21:45.704]                         envir <- sys.frame(frame)
[13:21:45.704]                       }
[13:21:45.704]                     }
[13:21:45.704]                     sendCondition <<- function(cond) NULL
[13:21:45.704]                   }
[13:21:45.704]                 })
[13:21:45.704]                 withCallingHandlers({
[13:21:45.704]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:21:45.704]                 }, immediateCondition = function(cond) {
[13:21:45.704]                   sendCondition <- ...future.makeSendCondition()
[13:21:45.704]                   sendCondition(cond)
[13:21:45.704]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:45.704]                   {
[13:21:45.704]                     inherits <- base::inherits
[13:21:45.704]                     invokeRestart <- base::invokeRestart
[13:21:45.704]                     is.null <- base::is.null
[13:21:45.704]                     muffled <- FALSE
[13:21:45.704]                     if (inherits(cond, "message")) {
[13:21:45.704]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:45.704]                       if (muffled) 
[13:21:45.704]                         invokeRestart("muffleMessage")
[13:21:45.704]                     }
[13:21:45.704]                     else if (inherits(cond, "warning")) {
[13:21:45.704]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:45.704]                       if (muffled) 
[13:21:45.704]                         invokeRestart("muffleWarning")
[13:21:45.704]                     }
[13:21:45.704]                     else if (inherits(cond, "condition")) {
[13:21:45.704]                       if (!is.null(pattern)) {
[13:21:45.704]                         computeRestarts <- base::computeRestarts
[13:21:45.704]                         grepl <- base::grepl
[13:21:45.704]                         restarts <- computeRestarts(cond)
[13:21:45.704]                         for (restart in restarts) {
[13:21:45.704]                           name <- restart$name
[13:21:45.704]                           if (is.null(name)) 
[13:21:45.704]                             next
[13:21:45.704]                           if (!grepl(pattern, name)) 
[13:21:45.704]                             next
[13:21:45.704]                           invokeRestart(restart)
[13:21:45.704]                           muffled <- TRUE
[13:21:45.704]                           break
[13:21:45.704]                         }
[13:21:45.704]                       }
[13:21:45.704]                     }
[13:21:45.704]                     invisible(muffled)
[13:21:45.704]                   }
[13:21:45.704]                   muffleCondition(cond)
[13:21:45.704]                 })
[13:21:45.704]             }))
[13:21:45.704]             future::FutureResult(value = ...future.value$value, 
[13:21:45.704]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:45.704]                   ...future.rng), globalenv = if (FALSE) 
[13:21:45.704]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:45.704]                     ...future.globalenv.names))
[13:21:45.704]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:45.704]         }, condition = base::local({
[13:21:45.704]             c <- base::c
[13:21:45.704]             inherits <- base::inherits
[13:21:45.704]             invokeRestart <- base::invokeRestart
[13:21:45.704]             length <- base::length
[13:21:45.704]             list <- base::list
[13:21:45.704]             seq.int <- base::seq.int
[13:21:45.704]             signalCondition <- base::signalCondition
[13:21:45.704]             sys.calls <- base::sys.calls
[13:21:45.704]             `[[` <- base::`[[`
[13:21:45.704]             `+` <- base::`+`
[13:21:45.704]             `<<-` <- base::`<<-`
[13:21:45.704]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:45.704]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:45.704]                   3L)]
[13:21:45.704]             }
[13:21:45.704]             function(cond) {
[13:21:45.704]                 is_error <- inherits(cond, "error")
[13:21:45.704]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:45.704]                   NULL)
[13:21:45.704]                 if (is_error) {
[13:21:45.704]                   sessionInformation <- function() {
[13:21:45.704]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:45.704]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:45.704]                       search = base::search(), system = base::Sys.info())
[13:21:45.704]                   }
[13:21:45.704]                   ...future.conditions[[length(...future.conditions) + 
[13:21:45.704]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:45.704]                     cond$call), session = sessionInformation(), 
[13:21:45.704]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:45.704]                   signalCondition(cond)
[13:21:45.704]                 }
[13:21:45.704]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:45.704]                 "immediateCondition"))) {
[13:21:45.704]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:45.704]                   ...future.conditions[[length(...future.conditions) + 
[13:21:45.704]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:45.704]                   if (TRUE && !signal) {
[13:21:45.704]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:45.704]                     {
[13:21:45.704]                       inherits <- base::inherits
[13:21:45.704]                       invokeRestart <- base::invokeRestart
[13:21:45.704]                       is.null <- base::is.null
[13:21:45.704]                       muffled <- FALSE
[13:21:45.704]                       if (inherits(cond, "message")) {
[13:21:45.704]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:45.704]                         if (muffled) 
[13:21:45.704]                           invokeRestart("muffleMessage")
[13:21:45.704]                       }
[13:21:45.704]                       else if (inherits(cond, "warning")) {
[13:21:45.704]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:45.704]                         if (muffled) 
[13:21:45.704]                           invokeRestart("muffleWarning")
[13:21:45.704]                       }
[13:21:45.704]                       else if (inherits(cond, "condition")) {
[13:21:45.704]                         if (!is.null(pattern)) {
[13:21:45.704]                           computeRestarts <- base::computeRestarts
[13:21:45.704]                           grepl <- base::grepl
[13:21:45.704]                           restarts <- computeRestarts(cond)
[13:21:45.704]                           for (restart in restarts) {
[13:21:45.704]                             name <- restart$name
[13:21:45.704]                             if (is.null(name)) 
[13:21:45.704]                               next
[13:21:45.704]                             if (!grepl(pattern, name)) 
[13:21:45.704]                               next
[13:21:45.704]                             invokeRestart(restart)
[13:21:45.704]                             muffled <- TRUE
[13:21:45.704]                             break
[13:21:45.704]                           }
[13:21:45.704]                         }
[13:21:45.704]                       }
[13:21:45.704]                       invisible(muffled)
[13:21:45.704]                     }
[13:21:45.704]                     muffleCondition(cond, pattern = "^muffle")
[13:21:45.704]                   }
[13:21:45.704]                 }
[13:21:45.704]                 else {
[13:21:45.704]                   if (TRUE) {
[13:21:45.704]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:45.704]                     {
[13:21:45.704]                       inherits <- base::inherits
[13:21:45.704]                       invokeRestart <- base::invokeRestart
[13:21:45.704]                       is.null <- base::is.null
[13:21:45.704]                       muffled <- FALSE
[13:21:45.704]                       if (inherits(cond, "message")) {
[13:21:45.704]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:45.704]                         if (muffled) 
[13:21:45.704]                           invokeRestart("muffleMessage")
[13:21:45.704]                       }
[13:21:45.704]                       else if (inherits(cond, "warning")) {
[13:21:45.704]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:45.704]                         if (muffled) 
[13:21:45.704]                           invokeRestart("muffleWarning")
[13:21:45.704]                       }
[13:21:45.704]                       else if (inherits(cond, "condition")) {
[13:21:45.704]                         if (!is.null(pattern)) {
[13:21:45.704]                           computeRestarts <- base::computeRestarts
[13:21:45.704]                           grepl <- base::grepl
[13:21:45.704]                           restarts <- computeRestarts(cond)
[13:21:45.704]                           for (restart in restarts) {
[13:21:45.704]                             name <- restart$name
[13:21:45.704]                             if (is.null(name)) 
[13:21:45.704]                               next
[13:21:45.704]                             if (!grepl(pattern, name)) 
[13:21:45.704]                               next
[13:21:45.704]                             invokeRestart(restart)
[13:21:45.704]                             muffled <- TRUE
[13:21:45.704]                             break
[13:21:45.704]                           }
[13:21:45.704]                         }
[13:21:45.704]                       }
[13:21:45.704]                       invisible(muffled)
[13:21:45.704]                     }
[13:21:45.704]                     muffleCondition(cond, pattern = "^muffle")
[13:21:45.704]                   }
[13:21:45.704]                 }
[13:21:45.704]             }
[13:21:45.704]         }))
[13:21:45.704]     }, error = function(ex) {
[13:21:45.704]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:45.704]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:45.704]                 ...future.rng), started = ...future.startTime, 
[13:21:45.704]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:45.704]             version = "1.8"), class = "FutureResult")
[13:21:45.704]     }, finally = {
[13:21:45.704]         if (!identical(...future.workdir, getwd())) 
[13:21:45.704]             setwd(...future.workdir)
[13:21:45.704]         {
[13:21:45.704]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:45.704]                 ...future.oldOptions$nwarnings <- NULL
[13:21:45.704]             }
[13:21:45.704]             base::options(...future.oldOptions)
[13:21:45.704]             if (.Platform$OS.type == "windows") {
[13:21:45.704]                 old_names <- names(...future.oldEnvVars)
[13:21:45.704]                 envs <- base::Sys.getenv()
[13:21:45.704]                 names <- names(envs)
[13:21:45.704]                 common <- intersect(names, old_names)
[13:21:45.704]                 added <- setdiff(names, old_names)
[13:21:45.704]                 removed <- setdiff(old_names, names)
[13:21:45.704]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:45.704]                   envs[common]]
[13:21:45.704]                 NAMES <- toupper(changed)
[13:21:45.704]                 args <- list()
[13:21:45.704]                 for (kk in seq_along(NAMES)) {
[13:21:45.704]                   name <- changed[[kk]]
[13:21:45.704]                   NAME <- NAMES[[kk]]
[13:21:45.704]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:45.704]                     next
[13:21:45.704]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:45.704]                 }
[13:21:45.704]                 NAMES <- toupper(added)
[13:21:45.704]                 for (kk in seq_along(NAMES)) {
[13:21:45.704]                   name <- added[[kk]]
[13:21:45.704]                   NAME <- NAMES[[kk]]
[13:21:45.704]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:45.704]                     next
[13:21:45.704]                   args[[name]] <- ""
[13:21:45.704]                 }
[13:21:45.704]                 NAMES <- toupper(removed)
[13:21:45.704]                 for (kk in seq_along(NAMES)) {
[13:21:45.704]                   name <- removed[[kk]]
[13:21:45.704]                   NAME <- NAMES[[kk]]
[13:21:45.704]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:45.704]                     next
[13:21:45.704]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:45.704]                 }
[13:21:45.704]                 if (length(args) > 0) 
[13:21:45.704]                   base::do.call(base::Sys.setenv, args = args)
[13:21:45.704]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:45.704]             }
[13:21:45.704]             else {
[13:21:45.704]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:45.704]             }
[13:21:45.704]             {
[13:21:45.704]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:45.704]                   0L) {
[13:21:45.704]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:45.704]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:45.704]                   base::options(opts)
[13:21:45.704]                 }
[13:21:45.704]                 {
[13:21:45.704]                   {
[13:21:45.704]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:45.704]                     NULL
[13:21:45.704]                   }
[13:21:45.704]                   options(future.plan = NULL)
[13:21:45.704]                   if (is.na(NA_character_)) 
[13:21:45.704]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:45.704]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:45.704]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:45.704]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:45.704]                     envir = parent.frame()) 
[13:21:45.704]                   {
[13:21:45.704]                     if (is.function(workers)) 
[13:21:45.704]                       workers <- workers()
[13:21:45.704]                     workers <- structure(as.integer(workers), 
[13:21:45.704]                       class = class(workers))
[13:21:45.704]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:45.704]                       workers >= 1)
[13:21:45.704]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:45.704]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:45.704]                     }
[13:21:45.704]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:45.704]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:45.704]                       envir = envir)
[13:21:45.704]                     if (!future$lazy) 
[13:21:45.704]                       future <- run(future)
[13:21:45.704]                     invisible(future)
[13:21:45.704]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:45.704]                 }
[13:21:45.704]             }
[13:21:45.704]         }
[13:21:45.704]     })
[13:21:45.704]     if (TRUE) {
[13:21:45.704]         base::sink(type = "output", split = FALSE)
[13:21:45.704]         if (TRUE) {
[13:21:45.704]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:45.704]         }
[13:21:45.704]         else {
[13:21:45.704]             ...future.result["stdout"] <- base::list(NULL)
[13:21:45.704]         }
[13:21:45.704]         base::close(...future.stdout)
[13:21:45.704]         ...future.stdout <- NULL
[13:21:45.704]     }
[13:21:45.704]     ...future.result$conditions <- ...future.conditions
[13:21:45.704]     ...future.result$finished <- base::Sys.time()
[13:21:45.704]     ...future.result
[13:21:45.704] }
[13:21:45.707] MultisessionFuture started
[13:21:45.707] - Launch lazy future ... done
[13:21:45.707] run() for ‘MultisessionFuture’ ... done
[13:21:45.754] receiveMessageFromWorker() for ClusterFuture ...
[13:21:45.754] - Validating connection of MultisessionFuture
[13:21:45.754] - received message: FutureResult
[13:21:45.754] - Received FutureResult
[13:21:45.755] - Erased future from FutureRegistry
[13:21:45.755] result() for ClusterFuture ...
[13:21:45.755] - result already collected: FutureResult
[13:21:45.755] result() for ClusterFuture ... done
[13:21:45.755] signalConditions() ...
[13:21:45.755]  - include = ‘immediateCondition’
[13:21:45.755]  - exclude = 
[13:21:45.755]  - resignal = FALSE
[13:21:45.755]  - Number of conditions: 1
[13:21:45.755] signalConditions() ... done
[13:21:45.756] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:45.756] A MultisessionFuture was resolved (result was not collected)
[13:21:45.756] getGlobalsAndPackages() ...
[13:21:45.756] Searching for globals...
[13:21:45.757] - globals found: [2] ‘list’, ‘stop’
[13:21:45.757] Searching for globals ... DONE
[13:21:45.757] Resolving globals: FALSE
[13:21:45.757] 
[13:21:45.757] 
[13:21:45.757] getGlobalsAndPackages() ... DONE
[13:21:45.758] run() for ‘Future’ ...
[13:21:45.758] - state: ‘created’
[13:21:45.758] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:45.773] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:45.773] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:45.775]   - Field: ‘node’
[13:21:45.775]   - Field: ‘label’
[13:21:45.775]   - Field: ‘local’
[13:21:45.775]   - Field: ‘owner’
[13:21:45.776]   - Field: ‘envir’
[13:21:45.776]   - Field: ‘workers’
[13:21:45.776]   - Field: ‘packages’
[13:21:45.776]   - Field: ‘gc’
[13:21:45.776]   - Field: ‘conditions’
[13:21:45.776]   - Field: ‘persistent’
[13:21:45.776]   - Field: ‘expr’
[13:21:45.776]   - Field: ‘uuid’
[13:21:45.776]   - Field: ‘seed’
[13:21:45.776]   - Field: ‘version’
[13:21:45.776]   - Field: ‘result’
[13:21:45.776]   - Field: ‘asynchronous’
[13:21:45.777]   - Field: ‘calls’
[13:21:45.777]   - Field: ‘globals’
[13:21:45.777]   - Field: ‘stdout’
[13:21:45.777]   - Field: ‘earlySignal’
[13:21:45.777]   - Field: ‘lazy’
[13:21:45.777]   - Field: ‘state’
[13:21:45.777] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:45.777] - Launch lazy future ...
[13:21:45.778] Packages needed by the future expression (n = 0): <none>
[13:21:45.778] Packages needed by future strategies (n = 0): <none>
[13:21:45.778] {
[13:21:45.778]     {
[13:21:45.778]         {
[13:21:45.778]             ...future.startTime <- base::Sys.time()
[13:21:45.778]             {
[13:21:45.778]                 {
[13:21:45.778]                   {
[13:21:45.778]                     {
[13:21:45.778]                       base::local({
[13:21:45.778]                         has_future <- base::requireNamespace("future", 
[13:21:45.778]                           quietly = TRUE)
[13:21:45.778]                         if (has_future) {
[13:21:45.778]                           ns <- base::getNamespace("future")
[13:21:45.778]                           version <- ns[[".package"]][["version"]]
[13:21:45.778]                           if (is.null(version)) 
[13:21:45.778]                             version <- utils::packageVersion("future")
[13:21:45.778]                         }
[13:21:45.778]                         else {
[13:21:45.778]                           version <- NULL
[13:21:45.778]                         }
[13:21:45.778]                         if (!has_future || version < "1.8.0") {
[13:21:45.778]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:45.778]                             "", base::R.version$version.string), 
[13:21:45.778]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:45.778]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:45.778]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:45.778]                               "release", "version")], collapse = " "), 
[13:21:45.778]                             hostname = base::Sys.info()[["nodename"]])
[13:21:45.778]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:45.778]                             info)
[13:21:45.778]                           info <- base::paste(info, collapse = "; ")
[13:21:45.778]                           if (!has_future) {
[13:21:45.778]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:45.778]                               info)
[13:21:45.778]                           }
[13:21:45.778]                           else {
[13:21:45.778]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:45.778]                               info, version)
[13:21:45.778]                           }
[13:21:45.778]                           base::stop(msg)
[13:21:45.778]                         }
[13:21:45.778]                       })
[13:21:45.778]                     }
[13:21:45.778]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:45.778]                     base::options(mc.cores = 1L)
[13:21:45.778]                   }
[13:21:45.778]                   options(future.plan = NULL)
[13:21:45.778]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:45.778]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:45.778]                 }
[13:21:45.778]                 ...future.workdir <- getwd()
[13:21:45.778]             }
[13:21:45.778]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:45.778]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:45.778]         }
[13:21:45.778]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:45.778]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:45.778]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:45.778]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:45.778]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:45.778]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:45.778]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:45.778]             base::names(...future.oldOptions))
[13:21:45.778]     }
[13:21:45.778]     if (FALSE) {
[13:21:45.778]     }
[13:21:45.778]     else {
[13:21:45.778]         if (TRUE) {
[13:21:45.778]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:45.778]                 open = "w")
[13:21:45.778]         }
[13:21:45.778]         else {
[13:21:45.778]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:45.778]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:45.778]         }
[13:21:45.778]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:45.778]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:45.778]             base::sink(type = "output", split = FALSE)
[13:21:45.778]             base::close(...future.stdout)
[13:21:45.778]         }, add = TRUE)
[13:21:45.778]     }
[13:21:45.778]     ...future.frame <- base::sys.nframe()
[13:21:45.778]     ...future.conditions <- base::list()
[13:21:45.778]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:45.778]     if (FALSE) {
[13:21:45.778]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:45.778]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:45.778]     }
[13:21:45.778]     ...future.result <- base::tryCatch({
[13:21:45.778]         base::withCallingHandlers({
[13:21:45.778]             ...future.value <- base::withVisible(base::local({
[13:21:45.778]                 ...future.makeSendCondition <- local({
[13:21:45.778]                   sendCondition <- NULL
[13:21:45.778]                   function(frame = 1L) {
[13:21:45.778]                     if (is.function(sendCondition)) 
[13:21:45.778]                       return(sendCondition)
[13:21:45.778]                     ns <- getNamespace("parallel")
[13:21:45.778]                     if (exists("sendData", mode = "function", 
[13:21:45.778]                       envir = ns)) {
[13:21:45.778]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:45.778]                         envir = ns)
[13:21:45.778]                       envir <- sys.frame(frame)
[13:21:45.778]                       master <- NULL
[13:21:45.778]                       while (!identical(envir, .GlobalEnv) && 
[13:21:45.778]                         !identical(envir, emptyenv())) {
[13:21:45.778]                         if (exists("master", mode = "list", envir = envir, 
[13:21:45.778]                           inherits = FALSE)) {
[13:21:45.778]                           master <- get("master", mode = "list", 
[13:21:45.778]                             envir = envir, inherits = FALSE)
[13:21:45.778]                           if (inherits(master, c("SOCKnode", 
[13:21:45.778]                             "SOCK0node"))) {
[13:21:45.778]                             sendCondition <<- function(cond) {
[13:21:45.778]                               data <- list(type = "VALUE", value = cond, 
[13:21:45.778]                                 success = TRUE)
[13:21:45.778]                               parallel_sendData(master, data)
[13:21:45.778]                             }
[13:21:45.778]                             return(sendCondition)
[13:21:45.778]                           }
[13:21:45.778]                         }
[13:21:45.778]                         frame <- frame + 1L
[13:21:45.778]                         envir <- sys.frame(frame)
[13:21:45.778]                       }
[13:21:45.778]                     }
[13:21:45.778]                     sendCondition <<- function(cond) NULL
[13:21:45.778]                   }
[13:21:45.778]                 })
[13:21:45.778]                 withCallingHandlers({
[13:21:45.778]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:21:45.778]                 }, immediateCondition = function(cond) {
[13:21:45.778]                   sendCondition <- ...future.makeSendCondition()
[13:21:45.778]                   sendCondition(cond)
[13:21:45.778]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:45.778]                   {
[13:21:45.778]                     inherits <- base::inherits
[13:21:45.778]                     invokeRestart <- base::invokeRestart
[13:21:45.778]                     is.null <- base::is.null
[13:21:45.778]                     muffled <- FALSE
[13:21:45.778]                     if (inherits(cond, "message")) {
[13:21:45.778]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:45.778]                       if (muffled) 
[13:21:45.778]                         invokeRestart("muffleMessage")
[13:21:45.778]                     }
[13:21:45.778]                     else if (inherits(cond, "warning")) {
[13:21:45.778]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:45.778]                       if (muffled) 
[13:21:45.778]                         invokeRestart("muffleWarning")
[13:21:45.778]                     }
[13:21:45.778]                     else if (inherits(cond, "condition")) {
[13:21:45.778]                       if (!is.null(pattern)) {
[13:21:45.778]                         computeRestarts <- base::computeRestarts
[13:21:45.778]                         grepl <- base::grepl
[13:21:45.778]                         restarts <- computeRestarts(cond)
[13:21:45.778]                         for (restart in restarts) {
[13:21:45.778]                           name <- restart$name
[13:21:45.778]                           if (is.null(name)) 
[13:21:45.778]                             next
[13:21:45.778]                           if (!grepl(pattern, name)) 
[13:21:45.778]                             next
[13:21:45.778]                           invokeRestart(restart)
[13:21:45.778]                           muffled <- TRUE
[13:21:45.778]                           break
[13:21:45.778]                         }
[13:21:45.778]                       }
[13:21:45.778]                     }
[13:21:45.778]                     invisible(muffled)
[13:21:45.778]                   }
[13:21:45.778]                   muffleCondition(cond)
[13:21:45.778]                 })
[13:21:45.778]             }))
[13:21:45.778]             future::FutureResult(value = ...future.value$value, 
[13:21:45.778]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:45.778]                   ...future.rng), globalenv = if (FALSE) 
[13:21:45.778]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:45.778]                     ...future.globalenv.names))
[13:21:45.778]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:45.778]         }, condition = base::local({
[13:21:45.778]             c <- base::c
[13:21:45.778]             inherits <- base::inherits
[13:21:45.778]             invokeRestart <- base::invokeRestart
[13:21:45.778]             length <- base::length
[13:21:45.778]             list <- base::list
[13:21:45.778]             seq.int <- base::seq.int
[13:21:45.778]             signalCondition <- base::signalCondition
[13:21:45.778]             sys.calls <- base::sys.calls
[13:21:45.778]             `[[` <- base::`[[`
[13:21:45.778]             `+` <- base::`+`
[13:21:45.778]             `<<-` <- base::`<<-`
[13:21:45.778]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:45.778]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:45.778]                   3L)]
[13:21:45.778]             }
[13:21:45.778]             function(cond) {
[13:21:45.778]                 is_error <- inherits(cond, "error")
[13:21:45.778]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:45.778]                   NULL)
[13:21:45.778]                 if (is_error) {
[13:21:45.778]                   sessionInformation <- function() {
[13:21:45.778]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:45.778]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:45.778]                       search = base::search(), system = base::Sys.info())
[13:21:45.778]                   }
[13:21:45.778]                   ...future.conditions[[length(...future.conditions) + 
[13:21:45.778]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:45.778]                     cond$call), session = sessionInformation(), 
[13:21:45.778]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:45.778]                   signalCondition(cond)
[13:21:45.778]                 }
[13:21:45.778]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:45.778]                 "immediateCondition"))) {
[13:21:45.778]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:45.778]                   ...future.conditions[[length(...future.conditions) + 
[13:21:45.778]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:45.778]                   if (TRUE && !signal) {
[13:21:45.778]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:45.778]                     {
[13:21:45.778]                       inherits <- base::inherits
[13:21:45.778]                       invokeRestart <- base::invokeRestart
[13:21:45.778]                       is.null <- base::is.null
[13:21:45.778]                       muffled <- FALSE
[13:21:45.778]                       if (inherits(cond, "message")) {
[13:21:45.778]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:45.778]                         if (muffled) 
[13:21:45.778]                           invokeRestart("muffleMessage")
[13:21:45.778]                       }
[13:21:45.778]                       else if (inherits(cond, "warning")) {
[13:21:45.778]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:45.778]                         if (muffled) 
[13:21:45.778]                           invokeRestart("muffleWarning")
[13:21:45.778]                       }
[13:21:45.778]                       else if (inherits(cond, "condition")) {
[13:21:45.778]                         if (!is.null(pattern)) {
[13:21:45.778]                           computeRestarts <- base::computeRestarts
[13:21:45.778]                           grepl <- base::grepl
[13:21:45.778]                           restarts <- computeRestarts(cond)
[13:21:45.778]                           for (restart in restarts) {
[13:21:45.778]                             name <- restart$name
[13:21:45.778]                             if (is.null(name)) 
[13:21:45.778]                               next
[13:21:45.778]                             if (!grepl(pattern, name)) 
[13:21:45.778]                               next
[13:21:45.778]                             invokeRestart(restart)
[13:21:45.778]                             muffled <- TRUE
[13:21:45.778]                             break
[13:21:45.778]                           }
[13:21:45.778]                         }
[13:21:45.778]                       }
[13:21:45.778]                       invisible(muffled)
[13:21:45.778]                     }
[13:21:45.778]                     muffleCondition(cond, pattern = "^muffle")
[13:21:45.778]                   }
[13:21:45.778]                 }
[13:21:45.778]                 else {
[13:21:45.778]                   if (TRUE) {
[13:21:45.778]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:45.778]                     {
[13:21:45.778]                       inherits <- base::inherits
[13:21:45.778]                       invokeRestart <- base::invokeRestart
[13:21:45.778]                       is.null <- base::is.null
[13:21:45.778]                       muffled <- FALSE
[13:21:45.778]                       if (inherits(cond, "message")) {
[13:21:45.778]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:45.778]                         if (muffled) 
[13:21:45.778]                           invokeRestart("muffleMessage")
[13:21:45.778]                       }
[13:21:45.778]                       else if (inherits(cond, "warning")) {
[13:21:45.778]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:45.778]                         if (muffled) 
[13:21:45.778]                           invokeRestart("muffleWarning")
[13:21:45.778]                       }
[13:21:45.778]                       else if (inherits(cond, "condition")) {
[13:21:45.778]                         if (!is.null(pattern)) {
[13:21:45.778]                           computeRestarts <- base::computeRestarts
[13:21:45.778]                           grepl <- base::grepl
[13:21:45.778]                           restarts <- computeRestarts(cond)
[13:21:45.778]                           for (restart in restarts) {
[13:21:45.778]                             name <- restart$name
[13:21:45.778]                             if (is.null(name)) 
[13:21:45.778]                               next
[13:21:45.778]                             if (!grepl(pattern, name)) 
[13:21:45.778]                               next
[13:21:45.778]                             invokeRestart(restart)
[13:21:45.778]                             muffled <- TRUE
[13:21:45.778]                             break
[13:21:45.778]                           }
[13:21:45.778]                         }
[13:21:45.778]                       }
[13:21:45.778]                       invisible(muffled)
[13:21:45.778]                     }
[13:21:45.778]                     muffleCondition(cond, pattern = "^muffle")
[13:21:45.778]                   }
[13:21:45.778]                 }
[13:21:45.778]             }
[13:21:45.778]         }))
[13:21:45.778]     }, error = function(ex) {
[13:21:45.778]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:45.778]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:45.778]                 ...future.rng), started = ...future.startTime, 
[13:21:45.778]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:45.778]             version = "1.8"), class = "FutureResult")
[13:21:45.778]     }, finally = {
[13:21:45.778]         if (!identical(...future.workdir, getwd())) 
[13:21:45.778]             setwd(...future.workdir)
[13:21:45.778]         {
[13:21:45.778]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:45.778]                 ...future.oldOptions$nwarnings <- NULL
[13:21:45.778]             }
[13:21:45.778]             base::options(...future.oldOptions)
[13:21:45.778]             if (.Platform$OS.type == "windows") {
[13:21:45.778]                 old_names <- names(...future.oldEnvVars)
[13:21:45.778]                 envs <- base::Sys.getenv()
[13:21:45.778]                 names <- names(envs)
[13:21:45.778]                 common <- intersect(names, old_names)
[13:21:45.778]                 added <- setdiff(names, old_names)
[13:21:45.778]                 removed <- setdiff(old_names, names)
[13:21:45.778]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:45.778]                   envs[common]]
[13:21:45.778]                 NAMES <- toupper(changed)
[13:21:45.778]                 args <- list()
[13:21:45.778]                 for (kk in seq_along(NAMES)) {
[13:21:45.778]                   name <- changed[[kk]]
[13:21:45.778]                   NAME <- NAMES[[kk]]
[13:21:45.778]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:45.778]                     next
[13:21:45.778]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:45.778]                 }
[13:21:45.778]                 NAMES <- toupper(added)
[13:21:45.778]                 for (kk in seq_along(NAMES)) {
[13:21:45.778]                   name <- added[[kk]]
[13:21:45.778]                   NAME <- NAMES[[kk]]
[13:21:45.778]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:45.778]                     next
[13:21:45.778]                   args[[name]] <- ""
[13:21:45.778]                 }
[13:21:45.778]                 NAMES <- toupper(removed)
[13:21:45.778]                 for (kk in seq_along(NAMES)) {
[13:21:45.778]                   name <- removed[[kk]]
[13:21:45.778]                   NAME <- NAMES[[kk]]
[13:21:45.778]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:45.778]                     next
[13:21:45.778]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:45.778]                 }
[13:21:45.778]                 if (length(args) > 0) 
[13:21:45.778]                   base::do.call(base::Sys.setenv, args = args)
[13:21:45.778]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:45.778]             }
[13:21:45.778]             else {
[13:21:45.778]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:45.778]             }
[13:21:45.778]             {
[13:21:45.778]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:45.778]                   0L) {
[13:21:45.778]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:45.778]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:45.778]                   base::options(opts)
[13:21:45.778]                 }
[13:21:45.778]                 {
[13:21:45.778]                   {
[13:21:45.778]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:45.778]                     NULL
[13:21:45.778]                   }
[13:21:45.778]                   options(future.plan = NULL)
[13:21:45.778]                   if (is.na(NA_character_)) 
[13:21:45.778]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:45.778]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:45.778]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:45.778]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:45.778]                     envir = parent.frame()) 
[13:21:45.778]                   {
[13:21:45.778]                     if (is.function(workers)) 
[13:21:45.778]                       workers <- workers()
[13:21:45.778]                     workers <- structure(as.integer(workers), 
[13:21:45.778]                       class = class(workers))
[13:21:45.778]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:45.778]                       workers >= 1)
[13:21:45.778]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:45.778]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:45.778]                     }
[13:21:45.778]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:45.778]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:45.778]                       envir = envir)
[13:21:45.778]                     if (!future$lazy) 
[13:21:45.778]                       future <- run(future)
[13:21:45.778]                     invisible(future)
[13:21:45.778]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:45.778]                 }
[13:21:45.778]             }
[13:21:45.778]         }
[13:21:45.778]     })
[13:21:45.778]     if (TRUE) {
[13:21:45.778]         base::sink(type = "output", split = FALSE)
[13:21:45.778]         if (TRUE) {
[13:21:45.778]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:45.778]         }
[13:21:45.778]         else {
[13:21:45.778]             ...future.result["stdout"] <- base::list(NULL)
[13:21:45.778]         }
[13:21:45.778]         base::close(...future.stdout)
[13:21:45.778]         ...future.stdout <- NULL
[13:21:45.778]     }
[13:21:45.778]     ...future.result$conditions <- ...future.conditions
[13:21:45.778]     ...future.result$finished <- base::Sys.time()
[13:21:45.778]     ...future.result
[13:21:45.778] }
[13:21:45.781] MultisessionFuture started
[13:21:45.781] - Launch lazy future ... done
[13:21:45.781] run() for ‘MultisessionFuture’ ... done
[13:21:45.830] receiveMessageFromWorker() for ClusterFuture ...
[13:21:45.830] - Validating connection of MultisessionFuture
[13:21:45.830] - received message: FutureResult
[13:21:45.831] - Received FutureResult
[13:21:45.831] - Erased future from FutureRegistry
[13:21:45.831] result() for ClusterFuture ...
[13:21:45.831] - result already collected: FutureResult
[13:21:45.831] result() for ClusterFuture ... done
[13:21:45.831] signalConditions() ...
[13:21:45.831]  - include = ‘immediateCondition’
[13:21:45.831]  - exclude = 
[13:21:45.831]  - resignal = FALSE
[13:21:45.831]  - Number of conditions: 1
[13:21:45.832] signalConditions() ... done
[13:21:45.832] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:45.832] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = TRUE ... DONE
- result = FALSE, recursive = -1 ...
[13:21:45.832] getGlobalsAndPackages() ...
[13:21:45.832] Searching for globals...
[13:21:45.833] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:21:45.833] Searching for globals ... DONE
[13:21:45.833] Resolving globals: FALSE
[13:21:45.834] 
[13:21:45.834] 
[13:21:45.834] getGlobalsAndPackages() ... DONE
[13:21:45.834] run() for ‘Future’ ...
[13:21:45.834] - state: ‘created’
[13:21:45.834] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:45.849] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:45.849] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:45.850]   - Field: ‘node’
[13:21:45.850]   - Field: ‘label’
[13:21:45.850]   - Field: ‘local’
[13:21:45.850]   - Field: ‘owner’
[13:21:45.850]   - Field: ‘envir’
[13:21:45.850]   - Field: ‘workers’
[13:21:45.850]   - Field: ‘packages’
[13:21:45.850]   - Field: ‘gc’
[13:21:45.850]   - Field: ‘conditions’
[13:21:45.850]   - Field: ‘persistent’
[13:21:45.850]   - Field: ‘expr’
[13:21:45.851]   - Field: ‘uuid’
[13:21:45.851]   - Field: ‘seed’
[13:21:45.851]   - Field: ‘version’
[13:21:45.851]   - Field: ‘result’
[13:21:45.851]   - Field: ‘asynchronous’
[13:21:45.851]   - Field: ‘calls’
[13:21:45.851]   - Field: ‘globals’
[13:21:45.851]   - Field: ‘stdout’
[13:21:45.851]   - Field: ‘earlySignal’
[13:21:45.851]   - Field: ‘lazy’
[13:21:45.851]   - Field: ‘state’
[13:21:45.852] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:45.852] - Launch lazy future ...
[13:21:45.852] Packages needed by the future expression (n = 0): <none>
[13:21:45.852] Packages needed by future strategies (n = 0): <none>
[13:21:45.852] {
[13:21:45.852]     {
[13:21:45.852]         {
[13:21:45.852]             ...future.startTime <- base::Sys.time()
[13:21:45.852]             {
[13:21:45.852]                 {
[13:21:45.852]                   {
[13:21:45.852]                     {
[13:21:45.852]                       base::local({
[13:21:45.852]                         has_future <- base::requireNamespace("future", 
[13:21:45.852]                           quietly = TRUE)
[13:21:45.852]                         if (has_future) {
[13:21:45.852]                           ns <- base::getNamespace("future")
[13:21:45.852]                           version <- ns[[".package"]][["version"]]
[13:21:45.852]                           if (is.null(version)) 
[13:21:45.852]                             version <- utils::packageVersion("future")
[13:21:45.852]                         }
[13:21:45.852]                         else {
[13:21:45.852]                           version <- NULL
[13:21:45.852]                         }
[13:21:45.852]                         if (!has_future || version < "1.8.0") {
[13:21:45.852]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:45.852]                             "", base::R.version$version.string), 
[13:21:45.852]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:45.852]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:45.852]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:45.852]                               "release", "version")], collapse = " "), 
[13:21:45.852]                             hostname = base::Sys.info()[["nodename"]])
[13:21:45.852]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:45.852]                             info)
[13:21:45.852]                           info <- base::paste(info, collapse = "; ")
[13:21:45.852]                           if (!has_future) {
[13:21:45.852]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:45.852]                               info)
[13:21:45.852]                           }
[13:21:45.852]                           else {
[13:21:45.852]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:45.852]                               info, version)
[13:21:45.852]                           }
[13:21:45.852]                           base::stop(msg)
[13:21:45.852]                         }
[13:21:45.852]                       })
[13:21:45.852]                     }
[13:21:45.852]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:45.852]                     base::options(mc.cores = 1L)
[13:21:45.852]                   }
[13:21:45.852]                   options(future.plan = NULL)
[13:21:45.852]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:45.852]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:45.852]                 }
[13:21:45.852]                 ...future.workdir <- getwd()
[13:21:45.852]             }
[13:21:45.852]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:45.852]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:45.852]         }
[13:21:45.852]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:45.852]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:45.852]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:45.852]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:45.852]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:45.852]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:45.852]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:45.852]             base::names(...future.oldOptions))
[13:21:45.852]     }
[13:21:45.852]     if (FALSE) {
[13:21:45.852]     }
[13:21:45.852]     else {
[13:21:45.852]         if (TRUE) {
[13:21:45.852]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:45.852]                 open = "w")
[13:21:45.852]         }
[13:21:45.852]         else {
[13:21:45.852]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:45.852]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:45.852]         }
[13:21:45.852]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:45.852]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:45.852]             base::sink(type = "output", split = FALSE)
[13:21:45.852]             base::close(...future.stdout)
[13:21:45.852]         }, add = TRUE)
[13:21:45.852]     }
[13:21:45.852]     ...future.frame <- base::sys.nframe()
[13:21:45.852]     ...future.conditions <- base::list()
[13:21:45.852]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:45.852]     if (FALSE) {
[13:21:45.852]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:45.852]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:45.852]     }
[13:21:45.852]     ...future.result <- base::tryCatch({
[13:21:45.852]         base::withCallingHandlers({
[13:21:45.852]             ...future.value <- base::withVisible(base::local({
[13:21:45.852]                 ...future.makeSendCondition <- local({
[13:21:45.852]                   sendCondition <- NULL
[13:21:45.852]                   function(frame = 1L) {
[13:21:45.852]                     if (is.function(sendCondition)) 
[13:21:45.852]                       return(sendCondition)
[13:21:45.852]                     ns <- getNamespace("parallel")
[13:21:45.852]                     if (exists("sendData", mode = "function", 
[13:21:45.852]                       envir = ns)) {
[13:21:45.852]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:45.852]                         envir = ns)
[13:21:45.852]                       envir <- sys.frame(frame)
[13:21:45.852]                       master <- NULL
[13:21:45.852]                       while (!identical(envir, .GlobalEnv) && 
[13:21:45.852]                         !identical(envir, emptyenv())) {
[13:21:45.852]                         if (exists("master", mode = "list", envir = envir, 
[13:21:45.852]                           inherits = FALSE)) {
[13:21:45.852]                           master <- get("master", mode = "list", 
[13:21:45.852]                             envir = envir, inherits = FALSE)
[13:21:45.852]                           if (inherits(master, c("SOCKnode", 
[13:21:45.852]                             "SOCK0node"))) {
[13:21:45.852]                             sendCondition <<- function(cond) {
[13:21:45.852]                               data <- list(type = "VALUE", value = cond, 
[13:21:45.852]                                 success = TRUE)
[13:21:45.852]                               parallel_sendData(master, data)
[13:21:45.852]                             }
[13:21:45.852]                             return(sendCondition)
[13:21:45.852]                           }
[13:21:45.852]                         }
[13:21:45.852]                         frame <- frame + 1L
[13:21:45.852]                         envir <- sys.frame(frame)
[13:21:45.852]                       }
[13:21:45.852]                     }
[13:21:45.852]                     sendCondition <<- function(cond) NULL
[13:21:45.852]                   }
[13:21:45.852]                 })
[13:21:45.852]                 withCallingHandlers({
[13:21:45.852]                   {
[13:21:45.852]                     Sys.sleep(0.5)
[13:21:45.852]                     list(a = 1, b = 42L)
[13:21:45.852]                   }
[13:21:45.852]                 }, immediateCondition = function(cond) {
[13:21:45.852]                   sendCondition <- ...future.makeSendCondition()
[13:21:45.852]                   sendCondition(cond)
[13:21:45.852]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:45.852]                   {
[13:21:45.852]                     inherits <- base::inherits
[13:21:45.852]                     invokeRestart <- base::invokeRestart
[13:21:45.852]                     is.null <- base::is.null
[13:21:45.852]                     muffled <- FALSE
[13:21:45.852]                     if (inherits(cond, "message")) {
[13:21:45.852]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:45.852]                       if (muffled) 
[13:21:45.852]                         invokeRestart("muffleMessage")
[13:21:45.852]                     }
[13:21:45.852]                     else if (inherits(cond, "warning")) {
[13:21:45.852]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:45.852]                       if (muffled) 
[13:21:45.852]                         invokeRestart("muffleWarning")
[13:21:45.852]                     }
[13:21:45.852]                     else if (inherits(cond, "condition")) {
[13:21:45.852]                       if (!is.null(pattern)) {
[13:21:45.852]                         computeRestarts <- base::computeRestarts
[13:21:45.852]                         grepl <- base::grepl
[13:21:45.852]                         restarts <- computeRestarts(cond)
[13:21:45.852]                         for (restart in restarts) {
[13:21:45.852]                           name <- restart$name
[13:21:45.852]                           if (is.null(name)) 
[13:21:45.852]                             next
[13:21:45.852]                           if (!grepl(pattern, name)) 
[13:21:45.852]                             next
[13:21:45.852]                           invokeRestart(restart)
[13:21:45.852]                           muffled <- TRUE
[13:21:45.852]                           break
[13:21:45.852]                         }
[13:21:45.852]                       }
[13:21:45.852]                     }
[13:21:45.852]                     invisible(muffled)
[13:21:45.852]                   }
[13:21:45.852]                   muffleCondition(cond)
[13:21:45.852]                 })
[13:21:45.852]             }))
[13:21:45.852]             future::FutureResult(value = ...future.value$value, 
[13:21:45.852]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:45.852]                   ...future.rng), globalenv = if (FALSE) 
[13:21:45.852]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:45.852]                     ...future.globalenv.names))
[13:21:45.852]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:45.852]         }, condition = base::local({
[13:21:45.852]             c <- base::c
[13:21:45.852]             inherits <- base::inherits
[13:21:45.852]             invokeRestart <- base::invokeRestart
[13:21:45.852]             length <- base::length
[13:21:45.852]             list <- base::list
[13:21:45.852]             seq.int <- base::seq.int
[13:21:45.852]             signalCondition <- base::signalCondition
[13:21:45.852]             sys.calls <- base::sys.calls
[13:21:45.852]             `[[` <- base::`[[`
[13:21:45.852]             `+` <- base::`+`
[13:21:45.852]             `<<-` <- base::`<<-`
[13:21:45.852]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:45.852]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:45.852]                   3L)]
[13:21:45.852]             }
[13:21:45.852]             function(cond) {
[13:21:45.852]                 is_error <- inherits(cond, "error")
[13:21:45.852]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:45.852]                   NULL)
[13:21:45.852]                 if (is_error) {
[13:21:45.852]                   sessionInformation <- function() {
[13:21:45.852]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:45.852]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:45.852]                       search = base::search(), system = base::Sys.info())
[13:21:45.852]                   }
[13:21:45.852]                   ...future.conditions[[length(...future.conditions) + 
[13:21:45.852]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:45.852]                     cond$call), session = sessionInformation(), 
[13:21:45.852]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:45.852]                   signalCondition(cond)
[13:21:45.852]                 }
[13:21:45.852]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:45.852]                 "immediateCondition"))) {
[13:21:45.852]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:45.852]                   ...future.conditions[[length(...future.conditions) + 
[13:21:45.852]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:45.852]                   if (TRUE && !signal) {
[13:21:45.852]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:45.852]                     {
[13:21:45.852]                       inherits <- base::inherits
[13:21:45.852]                       invokeRestart <- base::invokeRestart
[13:21:45.852]                       is.null <- base::is.null
[13:21:45.852]                       muffled <- FALSE
[13:21:45.852]                       if (inherits(cond, "message")) {
[13:21:45.852]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:45.852]                         if (muffled) 
[13:21:45.852]                           invokeRestart("muffleMessage")
[13:21:45.852]                       }
[13:21:45.852]                       else if (inherits(cond, "warning")) {
[13:21:45.852]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:45.852]                         if (muffled) 
[13:21:45.852]                           invokeRestart("muffleWarning")
[13:21:45.852]                       }
[13:21:45.852]                       else if (inherits(cond, "condition")) {
[13:21:45.852]                         if (!is.null(pattern)) {
[13:21:45.852]                           computeRestarts <- base::computeRestarts
[13:21:45.852]                           grepl <- base::grepl
[13:21:45.852]                           restarts <- computeRestarts(cond)
[13:21:45.852]                           for (restart in restarts) {
[13:21:45.852]                             name <- restart$name
[13:21:45.852]                             if (is.null(name)) 
[13:21:45.852]                               next
[13:21:45.852]                             if (!grepl(pattern, name)) 
[13:21:45.852]                               next
[13:21:45.852]                             invokeRestart(restart)
[13:21:45.852]                             muffled <- TRUE
[13:21:45.852]                             break
[13:21:45.852]                           }
[13:21:45.852]                         }
[13:21:45.852]                       }
[13:21:45.852]                       invisible(muffled)
[13:21:45.852]                     }
[13:21:45.852]                     muffleCondition(cond, pattern = "^muffle")
[13:21:45.852]                   }
[13:21:45.852]                 }
[13:21:45.852]                 else {
[13:21:45.852]                   if (TRUE) {
[13:21:45.852]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:45.852]                     {
[13:21:45.852]                       inherits <- base::inherits
[13:21:45.852]                       invokeRestart <- base::invokeRestart
[13:21:45.852]                       is.null <- base::is.null
[13:21:45.852]                       muffled <- FALSE
[13:21:45.852]                       if (inherits(cond, "message")) {
[13:21:45.852]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:45.852]                         if (muffled) 
[13:21:45.852]                           invokeRestart("muffleMessage")
[13:21:45.852]                       }
[13:21:45.852]                       else if (inherits(cond, "warning")) {
[13:21:45.852]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:45.852]                         if (muffled) 
[13:21:45.852]                           invokeRestart("muffleWarning")
[13:21:45.852]                       }
[13:21:45.852]                       else if (inherits(cond, "condition")) {
[13:21:45.852]                         if (!is.null(pattern)) {
[13:21:45.852]                           computeRestarts <- base::computeRestarts
[13:21:45.852]                           grepl <- base::grepl
[13:21:45.852]                           restarts <- computeRestarts(cond)
[13:21:45.852]                           for (restart in restarts) {
[13:21:45.852]                             name <- restart$name
[13:21:45.852]                             if (is.null(name)) 
[13:21:45.852]                               next
[13:21:45.852]                             if (!grepl(pattern, name)) 
[13:21:45.852]                               next
[13:21:45.852]                             invokeRestart(restart)
[13:21:45.852]                             muffled <- TRUE
[13:21:45.852]                             break
[13:21:45.852]                           }
[13:21:45.852]                         }
[13:21:45.852]                       }
[13:21:45.852]                       invisible(muffled)
[13:21:45.852]                     }
[13:21:45.852]                     muffleCondition(cond, pattern = "^muffle")
[13:21:45.852]                   }
[13:21:45.852]                 }
[13:21:45.852]             }
[13:21:45.852]         }))
[13:21:45.852]     }, error = function(ex) {
[13:21:45.852]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:45.852]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:45.852]                 ...future.rng), started = ...future.startTime, 
[13:21:45.852]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:45.852]             version = "1.8"), class = "FutureResult")
[13:21:45.852]     }, finally = {
[13:21:45.852]         if (!identical(...future.workdir, getwd())) 
[13:21:45.852]             setwd(...future.workdir)
[13:21:45.852]         {
[13:21:45.852]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:45.852]                 ...future.oldOptions$nwarnings <- NULL
[13:21:45.852]             }
[13:21:45.852]             base::options(...future.oldOptions)
[13:21:45.852]             if (.Platform$OS.type == "windows") {
[13:21:45.852]                 old_names <- names(...future.oldEnvVars)
[13:21:45.852]                 envs <- base::Sys.getenv()
[13:21:45.852]                 names <- names(envs)
[13:21:45.852]                 common <- intersect(names, old_names)
[13:21:45.852]                 added <- setdiff(names, old_names)
[13:21:45.852]                 removed <- setdiff(old_names, names)
[13:21:45.852]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:45.852]                   envs[common]]
[13:21:45.852]                 NAMES <- toupper(changed)
[13:21:45.852]                 args <- list()
[13:21:45.852]                 for (kk in seq_along(NAMES)) {
[13:21:45.852]                   name <- changed[[kk]]
[13:21:45.852]                   NAME <- NAMES[[kk]]
[13:21:45.852]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:45.852]                     next
[13:21:45.852]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:45.852]                 }
[13:21:45.852]                 NAMES <- toupper(added)
[13:21:45.852]                 for (kk in seq_along(NAMES)) {
[13:21:45.852]                   name <- added[[kk]]
[13:21:45.852]                   NAME <- NAMES[[kk]]
[13:21:45.852]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:45.852]                     next
[13:21:45.852]                   args[[name]] <- ""
[13:21:45.852]                 }
[13:21:45.852]                 NAMES <- toupper(removed)
[13:21:45.852]                 for (kk in seq_along(NAMES)) {
[13:21:45.852]                   name <- removed[[kk]]
[13:21:45.852]                   NAME <- NAMES[[kk]]
[13:21:45.852]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:45.852]                     next
[13:21:45.852]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:45.852]                 }
[13:21:45.852]                 if (length(args) > 0) 
[13:21:45.852]                   base::do.call(base::Sys.setenv, args = args)
[13:21:45.852]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:45.852]             }
[13:21:45.852]             else {
[13:21:45.852]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:45.852]             }
[13:21:45.852]             {
[13:21:45.852]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:45.852]                   0L) {
[13:21:45.852]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:45.852]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:45.852]                   base::options(opts)
[13:21:45.852]                 }
[13:21:45.852]                 {
[13:21:45.852]                   {
[13:21:45.852]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:45.852]                     NULL
[13:21:45.852]                   }
[13:21:45.852]                   options(future.plan = NULL)
[13:21:45.852]                   if (is.na(NA_character_)) 
[13:21:45.852]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:45.852]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:45.852]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:45.852]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:45.852]                     envir = parent.frame()) 
[13:21:45.852]                   {
[13:21:45.852]                     if (is.function(workers)) 
[13:21:45.852]                       workers <- workers()
[13:21:45.852]                     workers <- structure(as.integer(workers), 
[13:21:45.852]                       class = class(workers))
[13:21:45.852]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:45.852]                       workers >= 1)
[13:21:45.852]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:45.852]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:45.852]                     }
[13:21:45.852]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:45.852]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:45.852]                       envir = envir)
[13:21:45.852]                     if (!future$lazy) 
[13:21:45.852]                       future <- run(future)
[13:21:45.852]                     invisible(future)
[13:21:45.852]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:45.852]                 }
[13:21:45.852]             }
[13:21:45.852]         }
[13:21:45.852]     })
[13:21:45.852]     if (TRUE) {
[13:21:45.852]         base::sink(type = "output", split = FALSE)
[13:21:45.852]         if (TRUE) {
[13:21:45.852]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:45.852]         }
[13:21:45.852]         else {
[13:21:45.852]             ...future.result["stdout"] <- base::list(NULL)
[13:21:45.852]         }
[13:21:45.852]         base::close(...future.stdout)
[13:21:45.852]         ...future.stdout <- NULL
[13:21:45.852]     }
[13:21:45.852]     ...future.result$conditions <- ...future.conditions
[13:21:45.852]     ...future.result$finished <- base::Sys.time()
[13:21:45.852]     ...future.result
[13:21:45.852] }
[13:21:45.856] MultisessionFuture started
[13:21:45.856] - Launch lazy future ... done
[13:21:45.856] run() for ‘MultisessionFuture’ ... done
[13:21:45.856] getGlobalsAndPackages() ...
[13:21:45.856] Searching for globals...
[13:21:45.857] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:21:45.857] Searching for globals ... DONE
[13:21:45.857] Resolving globals: FALSE
[13:21:45.858] 
[13:21:45.858] 
[13:21:45.858] getGlobalsAndPackages() ... DONE
- w/ exception ...
[13:21:45.858] getGlobalsAndPackages() ...
[13:21:45.858] Searching for globals...
[13:21:45.859] - globals found: [2] ‘list’, ‘stop’
[13:21:45.859] Searching for globals ... DONE
[13:21:45.859] Resolving globals: FALSE
[13:21:45.859] 
[13:21:45.859] 
[13:21:45.859] getGlobalsAndPackages() ... DONE
[13:21:45.860] run() for ‘Future’ ...
[13:21:45.860] - state: ‘created’
[13:21:45.860] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:45.876] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:45.876] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:45.876]   - Field: ‘node’
[13:21:45.876]   - Field: ‘label’
[13:21:45.876]   - Field: ‘local’
[13:21:45.876]   - Field: ‘owner’
[13:21:45.877]   - Field: ‘envir’
[13:21:45.877]   - Field: ‘workers’
[13:21:45.877]   - Field: ‘packages’
[13:21:45.877]   - Field: ‘gc’
[13:21:45.877]   - Field: ‘conditions’
[13:21:45.877]   - Field: ‘persistent’
[13:21:45.877]   - Field: ‘expr’
[13:21:45.877]   - Field: ‘uuid’
[13:21:45.877]   - Field: ‘seed’
[13:21:45.877]   - Field: ‘version’
[13:21:45.878]   - Field: ‘result’
[13:21:45.878]   - Field: ‘asynchronous’
[13:21:45.878]   - Field: ‘calls’
[13:21:45.878]   - Field: ‘globals’
[13:21:45.878]   - Field: ‘stdout’
[13:21:45.878]   - Field: ‘earlySignal’
[13:21:45.878]   - Field: ‘lazy’
[13:21:45.878]   - Field: ‘state’
[13:21:45.878] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:45.878] - Launch lazy future ...
[13:21:45.879] Packages needed by the future expression (n = 0): <none>
[13:21:45.879] Packages needed by future strategies (n = 0): <none>
[13:21:45.879] {
[13:21:45.879]     {
[13:21:45.879]         {
[13:21:45.879]             ...future.startTime <- base::Sys.time()
[13:21:45.879]             {
[13:21:45.879]                 {
[13:21:45.879]                   {
[13:21:45.879]                     {
[13:21:45.879]                       base::local({
[13:21:45.879]                         has_future <- base::requireNamespace("future", 
[13:21:45.879]                           quietly = TRUE)
[13:21:45.879]                         if (has_future) {
[13:21:45.879]                           ns <- base::getNamespace("future")
[13:21:45.879]                           version <- ns[[".package"]][["version"]]
[13:21:45.879]                           if (is.null(version)) 
[13:21:45.879]                             version <- utils::packageVersion("future")
[13:21:45.879]                         }
[13:21:45.879]                         else {
[13:21:45.879]                           version <- NULL
[13:21:45.879]                         }
[13:21:45.879]                         if (!has_future || version < "1.8.0") {
[13:21:45.879]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:45.879]                             "", base::R.version$version.string), 
[13:21:45.879]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:45.879]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:45.879]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:45.879]                               "release", "version")], collapse = " "), 
[13:21:45.879]                             hostname = base::Sys.info()[["nodename"]])
[13:21:45.879]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:45.879]                             info)
[13:21:45.879]                           info <- base::paste(info, collapse = "; ")
[13:21:45.879]                           if (!has_future) {
[13:21:45.879]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:45.879]                               info)
[13:21:45.879]                           }
[13:21:45.879]                           else {
[13:21:45.879]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:45.879]                               info, version)
[13:21:45.879]                           }
[13:21:45.879]                           base::stop(msg)
[13:21:45.879]                         }
[13:21:45.879]                       })
[13:21:45.879]                     }
[13:21:45.879]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:45.879]                     base::options(mc.cores = 1L)
[13:21:45.879]                   }
[13:21:45.879]                   options(future.plan = NULL)
[13:21:45.879]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:45.879]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:45.879]                 }
[13:21:45.879]                 ...future.workdir <- getwd()
[13:21:45.879]             }
[13:21:45.879]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:45.879]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:45.879]         }
[13:21:45.879]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:45.879]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:45.879]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:45.879]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:45.879]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:45.879]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:45.879]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:45.879]             base::names(...future.oldOptions))
[13:21:45.879]     }
[13:21:45.879]     if (FALSE) {
[13:21:45.879]     }
[13:21:45.879]     else {
[13:21:45.879]         if (TRUE) {
[13:21:45.879]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:45.879]                 open = "w")
[13:21:45.879]         }
[13:21:45.879]         else {
[13:21:45.879]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:45.879]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:45.879]         }
[13:21:45.879]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:45.879]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:45.879]             base::sink(type = "output", split = FALSE)
[13:21:45.879]             base::close(...future.stdout)
[13:21:45.879]         }, add = TRUE)
[13:21:45.879]     }
[13:21:45.879]     ...future.frame <- base::sys.nframe()
[13:21:45.879]     ...future.conditions <- base::list()
[13:21:45.879]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:45.879]     if (FALSE) {
[13:21:45.879]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:45.879]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:45.879]     }
[13:21:45.879]     ...future.result <- base::tryCatch({
[13:21:45.879]         base::withCallingHandlers({
[13:21:45.879]             ...future.value <- base::withVisible(base::local({
[13:21:45.879]                 ...future.makeSendCondition <- local({
[13:21:45.879]                   sendCondition <- NULL
[13:21:45.879]                   function(frame = 1L) {
[13:21:45.879]                     if (is.function(sendCondition)) 
[13:21:45.879]                       return(sendCondition)
[13:21:45.879]                     ns <- getNamespace("parallel")
[13:21:45.879]                     if (exists("sendData", mode = "function", 
[13:21:45.879]                       envir = ns)) {
[13:21:45.879]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:45.879]                         envir = ns)
[13:21:45.879]                       envir <- sys.frame(frame)
[13:21:45.879]                       master <- NULL
[13:21:45.879]                       while (!identical(envir, .GlobalEnv) && 
[13:21:45.879]                         !identical(envir, emptyenv())) {
[13:21:45.879]                         if (exists("master", mode = "list", envir = envir, 
[13:21:45.879]                           inherits = FALSE)) {
[13:21:45.879]                           master <- get("master", mode = "list", 
[13:21:45.879]                             envir = envir, inherits = FALSE)
[13:21:45.879]                           if (inherits(master, c("SOCKnode", 
[13:21:45.879]                             "SOCK0node"))) {
[13:21:45.879]                             sendCondition <<- function(cond) {
[13:21:45.879]                               data <- list(type = "VALUE", value = cond, 
[13:21:45.879]                                 success = TRUE)
[13:21:45.879]                               parallel_sendData(master, data)
[13:21:45.879]                             }
[13:21:45.879]                             return(sendCondition)
[13:21:45.879]                           }
[13:21:45.879]                         }
[13:21:45.879]                         frame <- frame + 1L
[13:21:45.879]                         envir <- sys.frame(frame)
[13:21:45.879]                       }
[13:21:45.879]                     }
[13:21:45.879]                     sendCondition <<- function(cond) NULL
[13:21:45.879]                   }
[13:21:45.879]                 })
[13:21:45.879]                 withCallingHandlers({
[13:21:45.879]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:21:45.879]                 }, immediateCondition = function(cond) {
[13:21:45.879]                   sendCondition <- ...future.makeSendCondition()
[13:21:45.879]                   sendCondition(cond)
[13:21:45.879]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:45.879]                   {
[13:21:45.879]                     inherits <- base::inherits
[13:21:45.879]                     invokeRestart <- base::invokeRestart
[13:21:45.879]                     is.null <- base::is.null
[13:21:45.879]                     muffled <- FALSE
[13:21:45.879]                     if (inherits(cond, "message")) {
[13:21:45.879]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:45.879]                       if (muffled) 
[13:21:45.879]                         invokeRestart("muffleMessage")
[13:21:45.879]                     }
[13:21:45.879]                     else if (inherits(cond, "warning")) {
[13:21:45.879]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:45.879]                       if (muffled) 
[13:21:45.879]                         invokeRestart("muffleWarning")
[13:21:45.879]                     }
[13:21:45.879]                     else if (inherits(cond, "condition")) {
[13:21:45.879]                       if (!is.null(pattern)) {
[13:21:45.879]                         computeRestarts <- base::computeRestarts
[13:21:45.879]                         grepl <- base::grepl
[13:21:45.879]                         restarts <- computeRestarts(cond)
[13:21:45.879]                         for (restart in restarts) {
[13:21:45.879]                           name <- restart$name
[13:21:45.879]                           if (is.null(name)) 
[13:21:45.879]                             next
[13:21:45.879]                           if (!grepl(pattern, name)) 
[13:21:45.879]                             next
[13:21:45.879]                           invokeRestart(restart)
[13:21:45.879]                           muffled <- TRUE
[13:21:45.879]                           break
[13:21:45.879]                         }
[13:21:45.879]                       }
[13:21:45.879]                     }
[13:21:45.879]                     invisible(muffled)
[13:21:45.879]                   }
[13:21:45.879]                   muffleCondition(cond)
[13:21:45.879]                 })
[13:21:45.879]             }))
[13:21:45.879]             future::FutureResult(value = ...future.value$value, 
[13:21:45.879]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:45.879]                   ...future.rng), globalenv = if (FALSE) 
[13:21:45.879]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:45.879]                     ...future.globalenv.names))
[13:21:45.879]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:45.879]         }, condition = base::local({
[13:21:45.879]             c <- base::c
[13:21:45.879]             inherits <- base::inherits
[13:21:45.879]             invokeRestart <- base::invokeRestart
[13:21:45.879]             length <- base::length
[13:21:45.879]             list <- base::list
[13:21:45.879]             seq.int <- base::seq.int
[13:21:45.879]             signalCondition <- base::signalCondition
[13:21:45.879]             sys.calls <- base::sys.calls
[13:21:45.879]             `[[` <- base::`[[`
[13:21:45.879]             `+` <- base::`+`
[13:21:45.879]             `<<-` <- base::`<<-`
[13:21:45.879]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:45.879]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:45.879]                   3L)]
[13:21:45.879]             }
[13:21:45.879]             function(cond) {
[13:21:45.879]                 is_error <- inherits(cond, "error")
[13:21:45.879]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:45.879]                   NULL)
[13:21:45.879]                 if (is_error) {
[13:21:45.879]                   sessionInformation <- function() {
[13:21:45.879]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:45.879]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:45.879]                       search = base::search(), system = base::Sys.info())
[13:21:45.879]                   }
[13:21:45.879]                   ...future.conditions[[length(...future.conditions) + 
[13:21:45.879]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:45.879]                     cond$call), session = sessionInformation(), 
[13:21:45.879]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:45.879]                   signalCondition(cond)
[13:21:45.879]                 }
[13:21:45.879]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:45.879]                 "immediateCondition"))) {
[13:21:45.879]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:45.879]                   ...future.conditions[[length(...future.conditions) + 
[13:21:45.879]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:45.879]                   if (TRUE && !signal) {
[13:21:45.879]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:45.879]                     {
[13:21:45.879]                       inherits <- base::inherits
[13:21:45.879]                       invokeRestart <- base::invokeRestart
[13:21:45.879]                       is.null <- base::is.null
[13:21:45.879]                       muffled <- FALSE
[13:21:45.879]                       if (inherits(cond, "message")) {
[13:21:45.879]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:45.879]                         if (muffled) 
[13:21:45.879]                           invokeRestart("muffleMessage")
[13:21:45.879]                       }
[13:21:45.879]                       else if (inherits(cond, "warning")) {
[13:21:45.879]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:45.879]                         if (muffled) 
[13:21:45.879]                           invokeRestart("muffleWarning")
[13:21:45.879]                       }
[13:21:45.879]                       else if (inherits(cond, "condition")) {
[13:21:45.879]                         if (!is.null(pattern)) {
[13:21:45.879]                           computeRestarts <- base::computeRestarts
[13:21:45.879]                           grepl <- base::grepl
[13:21:45.879]                           restarts <- computeRestarts(cond)
[13:21:45.879]                           for (restart in restarts) {
[13:21:45.879]                             name <- restart$name
[13:21:45.879]                             if (is.null(name)) 
[13:21:45.879]                               next
[13:21:45.879]                             if (!grepl(pattern, name)) 
[13:21:45.879]                               next
[13:21:45.879]                             invokeRestart(restart)
[13:21:45.879]                             muffled <- TRUE
[13:21:45.879]                             break
[13:21:45.879]                           }
[13:21:45.879]                         }
[13:21:45.879]                       }
[13:21:45.879]                       invisible(muffled)
[13:21:45.879]                     }
[13:21:45.879]                     muffleCondition(cond, pattern = "^muffle")
[13:21:45.879]                   }
[13:21:45.879]                 }
[13:21:45.879]                 else {
[13:21:45.879]                   if (TRUE) {
[13:21:45.879]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:45.879]                     {
[13:21:45.879]                       inherits <- base::inherits
[13:21:45.879]                       invokeRestart <- base::invokeRestart
[13:21:45.879]                       is.null <- base::is.null
[13:21:45.879]                       muffled <- FALSE
[13:21:45.879]                       if (inherits(cond, "message")) {
[13:21:45.879]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:45.879]                         if (muffled) 
[13:21:45.879]                           invokeRestart("muffleMessage")
[13:21:45.879]                       }
[13:21:45.879]                       else if (inherits(cond, "warning")) {
[13:21:45.879]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:45.879]                         if (muffled) 
[13:21:45.879]                           invokeRestart("muffleWarning")
[13:21:45.879]                       }
[13:21:45.879]                       else if (inherits(cond, "condition")) {
[13:21:45.879]                         if (!is.null(pattern)) {
[13:21:45.879]                           computeRestarts <- base::computeRestarts
[13:21:45.879]                           grepl <- base::grepl
[13:21:45.879]                           restarts <- computeRestarts(cond)
[13:21:45.879]                           for (restart in restarts) {
[13:21:45.879]                             name <- restart$name
[13:21:45.879]                             if (is.null(name)) 
[13:21:45.879]                               next
[13:21:45.879]                             if (!grepl(pattern, name)) 
[13:21:45.879]                               next
[13:21:45.879]                             invokeRestart(restart)
[13:21:45.879]                             muffled <- TRUE
[13:21:45.879]                             break
[13:21:45.879]                           }
[13:21:45.879]                         }
[13:21:45.879]                       }
[13:21:45.879]                       invisible(muffled)
[13:21:45.879]                     }
[13:21:45.879]                     muffleCondition(cond, pattern = "^muffle")
[13:21:45.879]                   }
[13:21:45.879]                 }
[13:21:45.879]             }
[13:21:45.879]         }))
[13:21:45.879]     }, error = function(ex) {
[13:21:45.879]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:45.879]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:45.879]                 ...future.rng), started = ...future.startTime, 
[13:21:45.879]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:45.879]             version = "1.8"), class = "FutureResult")
[13:21:45.879]     }, finally = {
[13:21:45.879]         if (!identical(...future.workdir, getwd())) 
[13:21:45.879]             setwd(...future.workdir)
[13:21:45.879]         {
[13:21:45.879]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:45.879]                 ...future.oldOptions$nwarnings <- NULL
[13:21:45.879]             }
[13:21:45.879]             base::options(...future.oldOptions)
[13:21:45.879]             if (.Platform$OS.type == "windows") {
[13:21:45.879]                 old_names <- names(...future.oldEnvVars)
[13:21:45.879]                 envs <- base::Sys.getenv()
[13:21:45.879]                 names <- names(envs)
[13:21:45.879]                 common <- intersect(names, old_names)
[13:21:45.879]                 added <- setdiff(names, old_names)
[13:21:45.879]                 removed <- setdiff(old_names, names)
[13:21:45.879]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:45.879]                   envs[common]]
[13:21:45.879]                 NAMES <- toupper(changed)
[13:21:45.879]                 args <- list()
[13:21:45.879]                 for (kk in seq_along(NAMES)) {
[13:21:45.879]                   name <- changed[[kk]]
[13:21:45.879]                   NAME <- NAMES[[kk]]
[13:21:45.879]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:45.879]                     next
[13:21:45.879]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:45.879]                 }
[13:21:45.879]                 NAMES <- toupper(added)
[13:21:45.879]                 for (kk in seq_along(NAMES)) {
[13:21:45.879]                   name <- added[[kk]]
[13:21:45.879]                   NAME <- NAMES[[kk]]
[13:21:45.879]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:45.879]                     next
[13:21:45.879]                   args[[name]] <- ""
[13:21:45.879]                 }
[13:21:45.879]                 NAMES <- toupper(removed)
[13:21:45.879]                 for (kk in seq_along(NAMES)) {
[13:21:45.879]                   name <- removed[[kk]]
[13:21:45.879]                   NAME <- NAMES[[kk]]
[13:21:45.879]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:45.879]                     next
[13:21:45.879]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:45.879]                 }
[13:21:45.879]                 if (length(args) > 0) 
[13:21:45.879]                   base::do.call(base::Sys.setenv, args = args)
[13:21:45.879]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:45.879]             }
[13:21:45.879]             else {
[13:21:45.879]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:45.879]             }
[13:21:45.879]             {
[13:21:45.879]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:45.879]                   0L) {
[13:21:45.879]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:45.879]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:45.879]                   base::options(opts)
[13:21:45.879]                 }
[13:21:45.879]                 {
[13:21:45.879]                   {
[13:21:45.879]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:45.879]                     NULL
[13:21:45.879]                   }
[13:21:45.879]                   options(future.plan = NULL)
[13:21:45.879]                   if (is.na(NA_character_)) 
[13:21:45.879]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:45.879]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:45.879]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:45.879]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:45.879]                     envir = parent.frame()) 
[13:21:45.879]                   {
[13:21:45.879]                     if (is.function(workers)) 
[13:21:45.879]                       workers <- workers()
[13:21:45.879]                     workers <- structure(as.integer(workers), 
[13:21:45.879]                       class = class(workers))
[13:21:45.879]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:45.879]                       workers >= 1)
[13:21:45.879]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:45.879]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:45.879]                     }
[13:21:45.879]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:45.879]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:45.879]                       envir = envir)
[13:21:45.879]                     if (!future$lazy) 
[13:21:45.879]                       future <- run(future)
[13:21:45.879]                     invisible(future)
[13:21:45.879]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:45.879]                 }
[13:21:45.879]             }
[13:21:45.879]         }
[13:21:45.879]     })
[13:21:45.879]     if (TRUE) {
[13:21:45.879]         base::sink(type = "output", split = FALSE)
[13:21:45.879]         if (TRUE) {
[13:21:45.879]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:45.879]         }
[13:21:45.879]         else {
[13:21:45.879]             ...future.result["stdout"] <- base::list(NULL)
[13:21:45.879]         }
[13:21:45.879]         base::close(...future.stdout)
[13:21:45.879]         ...future.stdout <- NULL
[13:21:45.879]     }
[13:21:45.879]     ...future.result$conditions <- ...future.conditions
[13:21:45.879]     ...future.result$finished <- base::Sys.time()
[13:21:45.879]     ...future.result
[13:21:45.879] }
[13:21:45.953] MultisessionFuture started
[13:21:45.953] - Launch lazy future ... done
[13:21:45.953] run() for ‘MultisessionFuture’ ... done
[13:21:45.954] getGlobalsAndPackages() ...
[13:21:45.954] Searching for globals...
[13:21:45.955] - globals found: [2] ‘list’, ‘stop’
[13:21:45.955] Searching for globals ... DONE
[13:21:45.955] Resolving globals: FALSE
[13:21:45.956] 
[13:21:45.956] 
[13:21:45.956] getGlobalsAndPackages() ... DONE
- result = FALSE, recursive = -1 ... DONE
- result = FALSE, recursive = 0 ...
[13:21:45.957] getGlobalsAndPackages() ...
[13:21:45.957] Searching for globals...
[13:21:45.959] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:21:45.959] Searching for globals ... DONE
[13:21:45.959] Resolving globals: FALSE
[13:21:45.959] 
[13:21:45.960] 
[13:21:45.960] getGlobalsAndPackages() ... DONE
[13:21:45.960] run() for ‘Future’ ...
[13:21:45.960] - state: ‘created’
[13:21:45.961] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:45.979] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:45.979] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:45.979]   - Field: ‘node’
[13:21:45.979]   - Field: ‘label’
[13:21:45.979]   - Field: ‘local’
[13:21:45.979]   - Field: ‘owner’
[13:21:45.980]   - Field: ‘envir’
[13:21:45.980]   - Field: ‘workers’
[13:21:45.980]   - Field: ‘packages’
[13:21:45.980]   - Field: ‘gc’
[13:21:45.980]   - Field: ‘conditions’
[13:21:45.980]   - Field: ‘persistent’
[13:21:45.980]   - Field: ‘expr’
[13:21:45.981]   - Field: ‘uuid’
[13:21:45.981]   - Field: ‘seed’
[13:21:45.981]   - Field: ‘version’
[13:21:45.981]   - Field: ‘result’
[13:21:45.981]   - Field: ‘asynchronous’
[13:21:45.981]   - Field: ‘calls’
[13:21:45.982]   - Field: ‘globals’
[13:21:45.982]   - Field: ‘stdout’
[13:21:45.982]   - Field: ‘earlySignal’
[13:21:45.982]   - Field: ‘lazy’
[13:21:45.982]   - Field: ‘state’
[13:21:45.982] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:45.983] - Launch lazy future ...
[13:21:45.983] Packages needed by the future expression (n = 0): <none>
[13:21:45.983] Packages needed by future strategies (n = 0): <none>
[13:21:45.984] {
[13:21:45.984]     {
[13:21:45.984]         {
[13:21:45.984]             ...future.startTime <- base::Sys.time()
[13:21:45.984]             {
[13:21:45.984]                 {
[13:21:45.984]                   {
[13:21:45.984]                     {
[13:21:45.984]                       base::local({
[13:21:45.984]                         has_future <- base::requireNamespace("future", 
[13:21:45.984]                           quietly = TRUE)
[13:21:45.984]                         if (has_future) {
[13:21:45.984]                           ns <- base::getNamespace("future")
[13:21:45.984]                           version <- ns[[".package"]][["version"]]
[13:21:45.984]                           if (is.null(version)) 
[13:21:45.984]                             version <- utils::packageVersion("future")
[13:21:45.984]                         }
[13:21:45.984]                         else {
[13:21:45.984]                           version <- NULL
[13:21:45.984]                         }
[13:21:45.984]                         if (!has_future || version < "1.8.0") {
[13:21:45.984]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:45.984]                             "", base::R.version$version.string), 
[13:21:45.984]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:45.984]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:45.984]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:45.984]                               "release", "version")], collapse = " "), 
[13:21:45.984]                             hostname = base::Sys.info()[["nodename"]])
[13:21:45.984]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:45.984]                             info)
[13:21:45.984]                           info <- base::paste(info, collapse = "; ")
[13:21:45.984]                           if (!has_future) {
[13:21:45.984]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:45.984]                               info)
[13:21:45.984]                           }
[13:21:45.984]                           else {
[13:21:45.984]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:45.984]                               info, version)
[13:21:45.984]                           }
[13:21:45.984]                           base::stop(msg)
[13:21:45.984]                         }
[13:21:45.984]                       })
[13:21:45.984]                     }
[13:21:45.984]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:45.984]                     base::options(mc.cores = 1L)
[13:21:45.984]                   }
[13:21:45.984]                   options(future.plan = NULL)
[13:21:45.984]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:45.984]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:45.984]                 }
[13:21:45.984]                 ...future.workdir <- getwd()
[13:21:45.984]             }
[13:21:45.984]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:45.984]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:45.984]         }
[13:21:45.984]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:45.984]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:45.984]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:45.984]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:45.984]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:45.984]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:45.984]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:45.984]             base::names(...future.oldOptions))
[13:21:45.984]     }
[13:21:45.984]     if (FALSE) {
[13:21:45.984]     }
[13:21:45.984]     else {
[13:21:45.984]         if (TRUE) {
[13:21:45.984]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:45.984]                 open = "w")
[13:21:45.984]         }
[13:21:45.984]         else {
[13:21:45.984]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:45.984]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:45.984]         }
[13:21:45.984]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:45.984]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:45.984]             base::sink(type = "output", split = FALSE)
[13:21:45.984]             base::close(...future.stdout)
[13:21:45.984]         }, add = TRUE)
[13:21:45.984]     }
[13:21:45.984]     ...future.frame <- base::sys.nframe()
[13:21:45.984]     ...future.conditions <- base::list()
[13:21:45.984]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:45.984]     if (FALSE) {
[13:21:45.984]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:45.984]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:45.984]     }
[13:21:45.984]     ...future.result <- base::tryCatch({
[13:21:45.984]         base::withCallingHandlers({
[13:21:45.984]             ...future.value <- base::withVisible(base::local({
[13:21:45.984]                 ...future.makeSendCondition <- local({
[13:21:45.984]                   sendCondition <- NULL
[13:21:45.984]                   function(frame = 1L) {
[13:21:45.984]                     if (is.function(sendCondition)) 
[13:21:45.984]                       return(sendCondition)
[13:21:45.984]                     ns <- getNamespace("parallel")
[13:21:45.984]                     if (exists("sendData", mode = "function", 
[13:21:45.984]                       envir = ns)) {
[13:21:45.984]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:45.984]                         envir = ns)
[13:21:45.984]                       envir <- sys.frame(frame)
[13:21:45.984]                       master <- NULL
[13:21:45.984]                       while (!identical(envir, .GlobalEnv) && 
[13:21:45.984]                         !identical(envir, emptyenv())) {
[13:21:45.984]                         if (exists("master", mode = "list", envir = envir, 
[13:21:45.984]                           inherits = FALSE)) {
[13:21:45.984]                           master <- get("master", mode = "list", 
[13:21:45.984]                             envir = envir, inherits = FALSE)
[13:21:45.984]                           if (inherits(master, c("SOCKnode", 
[13:21:45.984]                             "SOCK0node"))) {
[13:21:45.984]                             sendCondition <<- function(cond) {
[13:21:45.984]                               data <- list(type = "VALUE", value = cond, 
[13:21:45.984]                                 success = TRUE)
[13:21:45.984]                               parallel_sendData(master, data)
[13:21:45.984]                             }
[13:21:45.984]                             return(sendCondition)
[13:21:45.984]                           }
[13:21:45.984]                         }
[13:21:45.984]                         frame <- frame + 1L
[13:21:45.984]                         envir <- sys.frame(frame)
[13:21:45.984]                       }
[13:21:45.984]                     }
[13:21:45.984]                     sendCondition <<- function(cond) NULL
[13:21:45.984]                   }
[13:21:45.984]                 })
[13:21:45.984]                 withCallingHandlers({
[13:21:45.984]                   {
[13:21:45.984]                     Sys.sleep(0.5)
[13:21:45.984]                     list(a = 1, b = 42L)
[13:21:45.984]                   }
[13:21:45.984]                 }, immediateCondition = function(cond) {
[13:21:45.984]                   sendCondition <- ...future.makeSendCondition()
[13:21:45.984]                   sendCondition(cond)
[13:21:45.984]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:45.984]                   {
[13:21:45.984]                     inherits <- base::inherits
[13:21:45.984]                     invokeRestart <- base::invokeRestart
[13:21:45.984]                     is.null <- base::is.null
[13:21:45.984]                     muffled <- FALSE
[13:21:45.984]                     if (inherits(cond, "message")) {
[13:21:45.984]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:45.984]                       if (muffled) 
[13:21:45.984]                         invokeRestart("muffleMessage")
[13:21:45.984]                     }
[13:21:45.984]                     else if (inherits(cond, "warning")) {
[13:21:45.984]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:45.984]                       if (muffled) 
[13:21:45.984]                         invokeRestart("muffleWarning")
[13:21:45.984]                     }
[13:21:45.984]                     else if (inherits(cond, "condition")) {
[13:21:45.984]                       if (!is.null(pattern)) {
[13:21:45.984]                         computeRestarts <- base::computeRestarts
[13:21:45.984]                         grepl <- base::grepl
[13:21:45.984]                         restarts <- computeRestarts(cond)
[13:21:45.984]                         for (restart in restarts) {
[13:21:45.984]                           name <- restart$name
[13:21:45.984]                           if (is.null(name)) 
[13:21:45.984]                             next
[13:21:45.984]                           if (!grepl(pattern, name)) 
[13:21:45.984]                             next
[13:21:45.984]                           invokeRestart(restart)
[13:21:45.984]                           muffled <- TRUE
[13:21:45.984]                           break
[13:21:45.984]                         }
[13:21:45.984]                       }
[13:21:45.984]                     }
[13:21:45.984]                     invisible(muffled)
[13:21:45.984]                   }
[13:21:45.984]                   muffleCondition(cond)
[13:21:45.984]                 })
[13:21:45.984]             }))
[13:21:45.984]             future::FutureResult(value = ...future.value$value, 
[13:21:45.984]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:45.984]                   ...future.rng), globalenv = if (FALSE) 
[13:21:45.984]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:45.984]                     ...future.globalenv.names))
[13:21:45.984]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:45.984]         }, condition = base::local({
[13:21:45.984]             c <- base::c
[13:21:45.984]             inherits <- base::inherits
[13:21:45.984]             invokeRestart <- base::invokeRestart
[13:21:45.984]             length <- base::length
[13:21:45.984]             list <- base::list
[13:21:45.984]             seq.int <- base::seq.int
[13:21:45.984]             signalCondition <- base::signalCondition
[13:21:45.984]             sys.calls <- base::sys.calls
[13:21:45.984]             `[[` <- base::`[[`
[13:21:45.984]             `+` <- base::`+`
[13:21:45.984]             `<<-` <- base::`<<-`
[13:21:45.984]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:45.984]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:45.984]                   3L)]
[13:21:45.984]             }
[13:21:45.984]             function(cond) {
[13:21:45.984]                 is_error <- inherits(cond, "error")
[13:21:45.984]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:45.984]                   NULL)
[13:21:45.984]                 if (is_error) {
[13:21:45.984]                   sessionInformation <- function() {
[13:21:45.984]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:45.984]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:45.984]                       search = base::search(), system = base::Sys.info())
[13:21:45.984]                   }
[13:21:45.984]                   ...future.conditions[[length(...future.conditions) + 
[13:21:45.984]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:45.984]                     cond$call), session = sessionInformation(), 
[13:21:45.984]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:45.984]                   signalCondition(cond)
[13:21:45.984]                 }
[13:21:45.984]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:45.984]                 "immediateCondition"))) {
[13:21:45.984]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:45.984]                   ...future.conditions[[length(...future.conditions) + 
[13:21:45.984]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:45.984]                   if (TRUE && !signal) {
[13:21:45.984]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:45.984]                     {
[13:21:45.984]                       inherits <- base::inherits
[13:21:45.984]                       invokeRestart <- base::invokeRestart
[13:21:45.984]                       is.null <- base::is.null
[13:21:45.984]                       muffled <- FALSE
[13:21:45.984]                       if (inherits(cond, "message")) {
[13:21:45.984]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:45.984]                         if (muffled) 
[13:21:45.984]                           invokeRestart("muffleMessage")
[13:21:45.984]                       }
[13:21:45.984]                       else if (inherits(cond, "warning")) {
[13:21:45.984]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:45.984]                         if (muffled) 
[13:21:45.984]                           invokeRestart("muffleWarning")
[13:21:45.984]                       }
[13:21:45.984]                       else if (inherits(cond, "condition")) {
[13:21:45.984]                         if (!is.null(pattern)) {
[13:21:45.984]                           computeRestarts <- base::computeRestarts
[13:21:45.984]                           grepl <- base::grepl
[13:21:45.984]                           restarts <- computeRestarts(cond)
[13:21:45.984]                           for (restart in restarts) {
[13:21:45.984]                             name <- restart$name
[13:21:45.984]                             if (is.null(name)) 
[13:21:45.984]                               next
[13:21:45.984]                             if (!grepl(pattern, name)) 
[13:21:45.984]                               next
[13:21:45.984]                             invokeRestart(restart)
[13:21:45.984]                             muffled <- TRUE
[13:21:45.984]                             break
[13:21:45.984]                           }
[13:21:45.984]                         }
[13:21:45.984]                       }
[13:21:45.984]                       invisible(muffled)
[13:21:45.984]                     }
[13:21:45.984]                     muffleCondition(cond, pattern = "^muffle")
[13:21:45.984]                   }
[13:21:45.984]                 }
[13:21:45.984]                 else {
[13:21:45.984]                   if (TRUE) {
[13:21:45.984]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:45.984]                     {
[13:21:45.984]                       inherits <- base::inherits
[13:21:45.984]                       invokeRestart <- base::invokeRestart
[13:21:45.984]                       is.null <- base::is.null
[13:21:45.984]                       muffled <- FALSE
[13:21:45.984]                       if (inherits(cond, "message")) {
[13:21:45.984]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:45.984]                         if (muffled) 
[13:21:45.984]                           invokeRestart("muffleMessage")
[13:21:45.984]                       }
[13:21:45.984]                       else if (inherits(cond, "warning")) {
[13:21:45.984]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:45.984]                         if (muffled) 
[13:21:45.984]                           invokeRestart("muffleWarning")
[13:21:45.984]                       }
[13:21:45.984]                       else if (inherits(cond, "condition")) {
[13:21:45.984]                         if (!is.null(pattern)) {
[13:21:45.984]                           computeRestarts <- base::computeRestarts
[13:21:45.984]                           grepl <- base::grepl
[13:21:45.984]                           restarts <- computeRestarts(cond)
[13:21:45.984]                           for (restart in restarts) {
[13:21:45.984]                             name <- restart$name
[13:21:45.984]                             if (is.null(name)) 
[13:21:45.984]                               next
[13:21:45.984]                             if (!grepl(pattern, name)) 
[13:21:45.984]                               next
[13:21:45.984]                             invokeRestart(restart)
[13:21:45.984]                             muffled <- TRUE
[13:21:45.984]                             break
[13:21:45.984]                           }
[13:21:45.984]                         }
[13:21:45.984]                       }
[13:21:45.984]                       invisible(muffled)
[13:21:45.984]                     }
[13:21:45.984]                     muffleCondition(cond, pattern = "^muffle")
[13:21:45.984]                   }
[13:21:45.984]                 }
[13:21:45.984]             }
[13:21:45.984]         }))
[13:21:45.984]     }, error = function(ex) {
[13:21:45.984]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:45.984]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:45.984]                 ...future.rng), started = ...future.startTime, 
[13:21:45.984]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:45.984]             version = "1.8"), class = "FutureResult")
[13:21:45.984]     }, finally = {
[13:21:45.984]         if (!identical(...future.workdir, getwd())) 
[13:21:45.984]             setwd(...future.workdir)
[13:21:45.984]         {
[13:21:45.984]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:45.984]                 ...future.oldOptions$nwarnings <- NULL
[13:21:45.984]             }
[13:21:45.984]             base::options(...future.oldOptions)
[13:21:45.984]             if (.Platform$OS.type == "windows") {
[13:21:45.984]                 old_names <- names(...future.oldEnvVars)
[13:21:45.984]                 envs <- base::Sys.getenv()
[13:21:45.984]                 names <- names(envs)
[13:21:45.984]                 common <- intersect(names, old_names)
[13:21:45.984]                 added <- setdiff(names, old_names)
[13:21:45.984]                 removed <- setdiff(old_names, names)
[13:21:45.984]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:45.984]                   envs[common]]
[13:21:45.984]                 NAMES <- toupper(changed)
[13:21:45.984]                 args <- list()
[13:21:45.984]                 for (kk in seq_along(NAMES)) {
[13:21:45.984]                   name <- changed[[kk]]
[13:21:45.984]                   NAME <- NAMES[[kk]]
[13:21:45.984]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:45.984]                     next
[13:21:45.984]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:45.984]                 }
[13:21:45.984]                 NAMES <- toupper(added)
[13:21:45.984]                 for (kk in seq_along(NAMES)) {
[13:21:45.984]                   name <- added[[kk]]
[13:21:45.984]                   NAME <- NAMES[[kk]]
[13:21:45.984]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:45.984]                     next
[13:21:45.984]                   args[[name]] <- ""
[13:21:45.984]                 }
[13:21:45.984]                 NAMES <- toupper(removed)
[13:21:45.984]                 for (kk in seq_along(NAMES)) {
[13:21:45.984]                   name <- removed[[kk]]
[13:21:45.984]                   NAME <- NAMES[[kk]]
[13:21:45.984]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:45.984]                     next
[13:21:45.984]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:45.984]                 }
[13:21:45.984]                 if (length(args) > 0) 
[13:21:45.984]                   base::do.call(base::Sys.setenv, args = args)
[13:21:45.984]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:45.984]             }
[13:21:45.984]             else {
[13:21:45.984]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:45.984]             }
[13:21:45.984]             {
[13:21:45.984]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:45.984]                   0L) {
[13:21:45.984]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:45.984]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:45.984]                   base::options(opts)
[13:21:45.984]                 }
[13:21:45.984]                 {
[13:21:45.984]                   {
[13:21:45.984]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:45.984]                     NULL
[13:21:45.984]                   }
[13:21:45.984]                   options(future.plan = NULL)
[13:21:45.984]                   if (is.na(NA_character_)) 
[13:21:45.984]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:45.984]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:45.984]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:45.984]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:45.984]                     envir = parent.frame()) 
[13:21:45.984]                   {
[13:21:45.984]                     if (is.function(workers)) 
[13:21:45.984]                       workers <- workers()
[13:21:45.984]                     workers <- structure(as.integer(workers), 
[13:21:45.984]                       class = class(workers))
[13:21:45.984]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:45.984]                       workers >= 1)
[13:21:45.984]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:45.984]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:45.984]                     }
[13:21:45.984]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:45.984]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:45.984]                       envir = envir)
[13:21:45.984]                     if (!future$lazy) 
[13:21:45.984]                       future <- run(future)
[13:21:45.984]                     invisible(future)
[13:21:45.984]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:45.984]                 }
[13:21:45.984]             }
[13:21:45.984]         }
[13:21:45.984]     })
[13:21:45.984]     if (TRUE) {
[13:21:45.984]         base::sink(type = "output", split = FALSE)
[13:21:45.984]         if (TRUE) {
[13:21:45.984]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:45.984]         }
[13:21:45.984]         else {
[13:21:45.984]             ...future.result["stdout"] <- base::list(NULL)
[13:21:45.984]         }
[13:21:45.984]         base::close(...future.stdout)
[13:21:45.984]         ...future.stdout <- NULL
[13:21:45.984]     }
[13:21:45.984]     ...future.result$conditions <- ...future.conditions
[13:21:45.984]     ...future.result$finished <- base::Sys.time()
[13:21:45.984]     ...future.result
[13:21:45.984] }
[13:21:45.988] Poll #1 (0): usedNodes() = 2, workers = 2
[13:21:46.009] receiveMessageFromWorker() for ClusterFuture ...
[13:21:46.009] - Validating connection of MultisessionFuture
[13:21:46.010] - received message: FutureResult
[13:21:46.010] - Received FutureResult
[13:21:46.010] - Erased future from FutureRegistry
[13:21:46.010] result() for ClusterFuture ...
[13:21:46.010] - result already collected: FutureResult
[13:21:46.010] result() for ClusterFuture ... done
[13:21:46.010] signalConditions() ...
[13:21:46.010]  - include = ‘immediateCondition’
[13:21:46.011]  - exclude = 
[13:21:46.011]  - resignal = FALSE
[13:21:46.011]  - Number of conditions: 1
[13:21:46.011] signalConditions() ... done
[13:21:46.011] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:46.011] result() for ClusterFuture ...
[13:21:46.011] - result already collected: FutureResult
[13:21:46.011] result() for ClusterFuture ... done
[13:21:46.011] result() for ClusterFuture ...
[13:21:46.011] - result already collected: FutureResult
[13:21:46.011] result() for ClusterFuture ... done
[13:21:46.012] signalConditions() ...
[13:21:46.012]  - include = ‘immediateCondition’
[13:21:46.012]  - exclude = 
[13:21:46.012]  - resignal = FALSE
[13:21:46.012]  - Number of conditions: 1
[13:21:46.012] signalConditions() ... done
[13:21:46.013] MultisessionFuture started
[13:21:46.013] - Launch lazy future ... done
[13:21:46.013] run() for ‘MultisessionFuture’ ... done
[13:21:46.570] receiveMessageFromWorker() for ClusterFuture ...
[13:21:46.570] - Validating connection of MultisessionFuture
[13:21:46.571] - received message: FutureResult
[13:21:46.571] - Received FutureResult
[13:21:46.571] - Erased future from FutureRegistry
[13:21:46.571] result() for ClusterFuture ...
[13:21:46.571] - result already collected: FutureResult
[13:21:46.571] result() for ClusterFuture ... done
[13:21:46.571] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:46.571] A MultisessionFuture was resolved (result was not collected)
[13:21:46.571] getGlobalsAndPackages() ...
[13:21:46.572] Searching for globals...
[13:21:46.573] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:21:46.573] Searching for globals ... DONE
[13:21:46.573] Resolving globals: FALSE
[13:21:46.573] 
[13:21:46.573] 
[13:21:46.573] getGlobalsAndPackages() ... DONE
[13:21:46.574] run() for ‘Future’ ...
[13:21:46.574] - state: ‘created’
[13:21:46.574] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:46.588] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:46.588] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:46.588]   - Field: ‘node’
[13:21:46.588]   - Field: ‘label’
[13:21:46.589]   - Field: ‘local’
[13:21:46.589]   - Field: ‘owner’
[13:21:46.589]   - Field: ‘envir’
[13:21:46.589]   - Field: ‘workers’
[13:21:46.589]   - Field: ‘packages’
[13:21:46.589]   - Field: ‘gc’
[13:21:46.589]   - Field: ‘conditions’
[13:21:46.589]   - Field: ‘persistent’
[13:21:46.589]   - Field: ‘expr’
[13:21:46.589]   - Field: ‘uuid’
[13:21:46.590]   - Field: ‘seed’
[13:21:46.590]   - Field: ‘version’
[13:21:46.590]   - Field: ‘result’
[13:21:46.590]   - Field: ‘asynchronous’
[13:21:46.590]   - Field: ‘calls’
[13:21:46.590]   - Field: ‘globals’
[13:21:46.590]   - Field: ‘stdout’
[13:21:46.590]   - Field: ‘earlySignal’
[13:21:46.590]   - Field: ‘lazy’
[13:21:46.590]   - Field: ‘state’
[13:21:46.590] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:46.591] - Launch lazy future ...
[13:21:46.591] Packages needed by the future expression (n = 0): <none>
[13:21:46.591] Packages needed by future strategies (n = 0): <none>
[13:21:46.591] {
[13:21:46.591]     {
[13:21:46.591]         {
[13:21:46.591]             ...future.startTime <- base::Sys.time()
[13:21:46.591]             {
[13:21:46.591]                 {
[13:21:46.591]                   {
[13:21:46.591]                     {
[13:21:46.591]                       base::local({
[13:21:46.591]                         has_future <- base::requireNamespace("future", 
[13:21:46.591]                           quietly = TRUE)
[13:21:46.591]                         if (has_future) {
[13:21:46.591]                           ns <- base::getNamespace("future")
[13:21:46.591]                           version <- ns[[".package"]][["version"]]
[13:21:46.591]                           if (is.null(version)) 
[13:21:46.591]                             version <- utils::packageVersion("future")
[13:21:46.591]                         }
[13:21:46.591]                         else {
[13:21:46.591]                           version <- NULL
[13:21:46.591]                         }
[13:21:46.591]                         if (!has_future || version < "1.8.0") {
[13:21:46.591]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:46.591]                             "", base::R.version$version.string), 
[13:21:46.591]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:46.591]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:46.591]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:46.591]                               "release", "version")], collapse = " "), 
[13:21:46.591]                             hostname = base::Sys.info()[["nodename"]])
[13:21:46.591]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:46.591]                             info)
[13:21:46.591]                           info <- base::paste(info, collapse = "; ")
[13:21:46.591]                           if (!has_future) {
[13:21:46.591]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:46.591]                               info)
[13:21:46.591]                           }
[13:21:46.591]                           else {
[13:21:46.591]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:46.591]                               info, version)
[13:21:46.591]                           }
[13:21:46.591]                           base::stop(msg)
[13:21:46.591]                         }
[13:21:46.591]                       })
[13:21:46.591]                     }
[13:21:46.591]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:46.591]                     base::options(mc.cores = 1L)
[13:21:46.591]                   }
[13:21:46.591]                   options(future.plan = NULL)
[13:21:46.591]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:46.591]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:46.591]                 }
[13:21:46.591]                 ...future.workdir <- getwd()
[13:21:46.591]             }
[13:21:46.591]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:46.591]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:46.591]         }
[13:21:46.591]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:46.591]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:46.591]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:46.591]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:46.591]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:46.591]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:46.591]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:46.591]             base::names(...future.oldOptions))
[13:21:46.591]     }
[13:21:46.591]     if (FALSE) {
[13:21:46.591]     }
[13:21:46.591]     else {
[13:21:46.591]         if (TRUE) {
[13:21:46.591]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:46.591]                 open = "w")
[13:21:46.591]         }
[13:21:46.591]         else {
[13:21:46.591]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:46.591]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:46.591]         }
[13:21:46.591]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:46.591]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:46.591]             base::sink(type = "output", split = FALSE)
[13:21:46.591]             base::close(...future.stdout)
[13:21:46.591]         }, add = TRUE)
[13:21:46.591]     }
[13:21:46.591]     ...future.frame <- base::sys.nframe()
[13:21:46.591]     ...future.conditions <- base::list()
[13:21:46.591]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:46.591]     if (FALSE) {
[13:21:46.591]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:46.591]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:46.591]     }
[13:21:46.591]     ...future.result <- base::tryCatch({
[13:21:46.591]         base::withCallingHandlers({
[13:21:46.591]             ...future.value <- base::withVisible(base::local({
[13:21:46.591]                 ...future.makeSendCondition <- local({
[13:21:46.591]                   sendCondition <- NULL
[13:21:46.591]                   function(frame = 1L) {
[13:21:46.591]                     if (is.function(sendCondition)) 
[13:21:46.591]                       return(sendCondition)
[13:21:46.591]                     ns <- getNamespace("parallel")
[13:21:46.591]                     if (exists("sendData", mode = "function", 
[13:21:46.591]                       envir = ns)) {
[13:21:46.591]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:46.591]                         envir = ns)
[13:21:46.591]                       envir <- sys.frame(frame)
[13:21:46.591]                       master <- NULL
[13:21:46.591]                       while (!identical(envir, .GlobalEnv) && 
[13:21:46.591]                         !identical(envir, emptyenv())) {
[13:21:46.591]                         if (exists("master", mode = "list", envir = envir, 
[13:21:46.591]                           inherits = FALSE)) {
[13:21:46.591]                           master <- get("master", mode = "list", 
[13:21:46.591]                             envir = envir, inherits = FALSE)
[13:21:46.591]                           if (inherits(master, c("SOCKnode", 
[13:21:46.591]                             "SOCK0node"))) {
[13:21:46.591]                             sendCondition <<- function(cond) {
[13:21:46.591]                               data <- list(type = "VALUE", value = cond, 
[13:21:46.591]                                 success = TRUE)
[13:21:46.591]                               parallel_sendData(master, data)
[13:21:46.591]                             }
[13:21:46.591]                             return(sendCondition)
[13:21:46.591]                           }
[13:21:46.591]                         }
[13:21:46.591]                         frame <- frame + 1L
[13:21:46.591]                         envir <- sys.frame(frame)
[13:21:46.591]                       }
[13:21:46.591]                     }
[13:21:46.591]                     sendCondition <<- function(cond) NULL
[13:21:46.591]                   }
[13:21:46.591]                 })
[13:21:46.591]                 withCallingHandlers({
[13:21:46.591]                   {
[13:21:46.591]                     Sys.sleep(0.5)
[13:21:46.591]                     list(a = 1, b = 42L)
[13:21:46.591]                   }
[13:21:46.591]                 }, immediateCondition = function(cond) {
[13:21:46.591]                   sendCondition <- ...future.makeSendCondition()
[13:21:46.591]                   sendCondition(cond)
[13:21:46.591]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:46.591]                   {
[13:21:46.591]                     inherits <- base::inherits
[13:21:46.591]                     invokeRestart <- base::invokeRestart
[13:21:46.591]                     is.null <- base::is.null
[13:21:46.591]                     muffled <- FALSE
[13:21:46.591]                     if (inherits(cond, "message")) {
[13:21:46.591]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:46.591]                       if (muffled) 
[13:21:46.591]                         invokeRestart("muffleMessage")
[13:21:46.591]                     }
[13:21:46.591]                     else if (inherits(cond, "warning")) {
[13:21:46.591]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:46.591]                       if (muffled) 
[13:21:46.591]                         invokeRestart("muffleWarning")
[13:21:46.591]                     }
[13:21:46.591]                     else if (inherits(cond, "condition")) {
[13:21:46.591]                       if (!is.null(pattern)) {
[13:21:46.591]                         computeRestarts <- base::computeRestarts
[13:21:46.591]                         grepl <- base::grepl
[13:21:46.591]                         restarts <- computeRestarts(cond)
[13:21:46.591]                         for (restart in restarts) {
[13:21:46.591]                           name <- restart$name
[13:21:46.591]                           if (is.null(name)) 
[13:21:46.591]                             next
[13:21:46.591]                           if (!grepl(pattern, name)) 
[13:21:46.591]                             next
[13:21:46.591]                           invokeRestart(restart)
[13:21:46.591]                           muffled <- TRUE
[13:21:46.591]                           break
[13:21:46.591]                         }
[13:21:46.591]                       }
[13:21:46.591]                     }
[13:21:46.591]                     invisible(muffled)
[13:21:46.591]                   }
[13:21:46.591]                   muffleCondition(cond)
[13:21:46.591]                 })
[13:21:46.591]             }))
[13:21:46.591]             future::FutureResult(value = ...future.value$value, 
[13:21:46.591]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:46.591]                   ...future.rng), globalenv = if (FALSE) 
[13:21:46.591]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:46.591]                     ...future.globalenv.names))
[13:21:46.591]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:46.591]         }, condition = base::local({
[13:21:46.591]             c <- base::c
[13:21:46.591]             inherits <- base::inherits
[13:21:46.591]             invokeRestart <- base::invokeRestart
[13:21:46.591]             length <- base::length
[13:21:46.591]             list <- base::list
[13:21:46.591]             seq.int <- base::seq.int
[13:21:46.591]             signalCondition <- base::signalCondition
[13:21:46.591]             sys.calls <- base::sys.calls
[13:21:46.591]             `[[` <- base::`[[`
[13:21:46.591]             `+` <- base::`+`
[13:21:46.591]             `<<-` <- base::`<<-`
[13:21:46.591]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:46.591]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:46.591]                   3L)]
[13:21:46.591]             }
[13:21:46.591]             function(cond) {
[13:21:46.591]                 is_error <- inherits(cond, "error")
[13:21:46.591]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:46.591]                   NULL)
[13:21:46.591]                 if (is_error) {
[13:21:46.591]                   sessionInformation <- function() {
[13:21:46.591]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:46.591]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:46.591]                       search = base::search(), system = base::Sys.info())
[13:21:46.591]                   }
[13:21:46.591]                   ...future.conditions[[length(...future.conditions) + 
[13:21:46.591]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:46.591]                     cond$call), session = sessionInformation(), 
[13:21:46.591]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:46.591]                   signalCondition(cond)
[13:21:46.591]                 }
[13:21:46.591]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:46.591]                 "immediateCondition"))) {
[13:21:46.591]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:46.591]                   ...future.conditions[[length(...future.conditions) + 
[13:21:46.591]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:46.591]                   if (TRUE && !signal) {
[13:21:46.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:46.591]                     {
[13:21:46.591]                       inherits <- base::inherits
[13:21:46.591]                       invokeRestart <- base::invokeRestart
[13:21:46.591]                       is.null <- base::is.null
[13:21:46.591]                       muffled <- FALSE
[13:21:46.591]                       if (inherits(cond, "message")) {
[13:21:46.591]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:46.591]                         if (muffled) 
[13:21:46.591]                           invokeRestart("muffleMessage")
[13:21:46.591]                       }
[13:21:46.591]                       else if (inherits(cond, "warning")) {
[13:21:46.591]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:46.591]                         if (muffled) 
[13:21:46.591]                           invokeRestart("muffleWarning")
[13:21:46.591]                       }
[13:21:46.591]                       else if (inherits(cond, "condition")) {
[13:21:46.591]                         if (!is.null(pattern)) {
[13:21:46.591]                           computeRestarts <- base::computeRestarts
[13:21:46.591]                           grepl <- base::grepl
[13:21:46.591]                           restarts <- computeRestarts(cond)
[13:21:46.591]                           for (restart in restarts) {
[13:21:46.591]                             name <- restart$name
[13:21:46.591]                             if (is.null(name)) 
[13:21:46.591]                               next
[13:21:46.591]                             if (!grepl(pattern, name)) 
[13:21:46.591]                               next
[13:21:46.591]                             invokeRestart(restart)
[13:21:46.591]                             muffled <- TRUE
[13:21:46.591]                             break
[13:21:46.591]                           }
[13:21:46.591]                         }
[13:21:46.591]                       }
[13:21:46.591]                       invisible(muffled)
[13:21:46.591]                     }
[13:21:46.591]                     muffleCondition(cond, pattern = "^muffle")
[13:21:46.591]                   }
[13:21:46.591]                 }
[13:21:46.591]                 else {
[13:21:46.591]                   if (TRUE) {
[13:21:46.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:46.591]                     {
[13:21:46.591]                       inherits <- base::inherits
[13:21:46.591]                       invokeRestart <- base::invokeRestart
[13:21:46.591]                       is.null <- base::is.null
[13:21:46.591]                       muffled <- FALSE
[13:21:46.591]                       if (inherits(cond, "message")) {
[13:21:46.591]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:46.591]                         if (muffled) 
[13:21:46.591]                           invokeRestart("muffleMessage")
[13:21:46.591]                       }
[13:21:46.591]                       else if (inherits(cond, "warning")) {
[13:21:46.591]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:46.591]                         if (muffled) 
[13:21:46.591]                           invokeRestart("muffleWarning")
[13:21:46.591]                       }
[13:21:46.591]                       else if (inherits(cond, "condition")) {
[13:21:46.591]                         if (!is.null(pattern)) {
[13:21:46.591]                           computeRestarts <- base::computeRestarts
[13:21:46.591]                           grepl <- base::grepl
[13:21:46.591]                           restarts <- computeRestarts(cond)
[13:21:46.591]                           for (restart in restarts) {
[13:21:46.591]                             name <- restart$name
[13:21:46.591]                             if (is.null(name)) 
[13:21:46.591]                               next
[13:21:46.591]                             if (!grepl(pattern, name)) 
[13:21:46.591]                               next
[13:21:46.591]                             invokeRestart(restart)
[13:21:46.591]                             muffled <- TRUE
[13:21:46.591]                             break
[13:21:46.591]                           }
[13:21:46.591]                         }
[13:21:46.591]                       }
[13:21:46.591]                       invisible(muffled)
[13:21:46.591]                     }
[13:21:46.591]                     muffleCondition(cond, pattern = "^muffle")
[13:21:46.591]                   }
[13:21:46.591]                 }
[13:21:46.591]             }
[13:21:46.591]         }))
[13:21:46.591]     }, error = function(ex) {
[13:21:46.591]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:46.591]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:46.591]                 ...future.rng), started = ...future.startTime, 
[13:21:46.591]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:46.591]             version = "1.8"), class = "FutureResult")
[13:21:46.591]     }, finally = {
[13:21:46.591]         if (!identical(...future.workdir, getwd())) 
[13:21:46.591]             setwd(...future.workdir)
[13:21:46.591]         {
[13:21:46.591]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:46.591]                 ...future.oldOptions$nwarnings <- NULL
[13:21:46.591]             }
[13:21:46.591]             base::options(...future.oldOptions)
[13:21:46.591]             if (.Platform$OS.type == "windows") {
[13:21:46.591]                 old_names <- names(...future.oldEnvVars)
[13:21:46.591]                 envs <- base::Sys.getenv()
[13:21:46.591]                 names <- names(envs)
[13:21:46.591]                 common <- intersect(names, old_names)
[13:21:46.591]                 added <- setdiff(names, old_names)
[13:21:46.591]                 removed <- setdiff(old_names, names)
[13:21:46.591]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:46.591]                   envs[common]]
[13:21:46.591]                 NAMES <- toupper(changed)
[13:21:46.591]                 args <- list()
[13:21:46.591]                 for (kk in seq_along(NAMES)) {
[13:21:46.591]                   name <- changed[[kk]]
[13:21:46.591]                   NAME <- NAMES[[kk]]
[13:21:46.591]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:46.591]                     next
[13:21:46.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:46.591]                 }
[13:21:46.591]                 NAMES <- toupper(added)
[13:21:46.591]                 for (kk in seq_along(NAMES)) {
[13:21:46.591]                   name <- added[[kk]]
[13:21:46.591]                   NAME <- NAMES[[kk]]
[13:21:46.591]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:46.591]                     next
[13:21:46.591]                   args[[name]] <- ""
[13:21:46.591]                 }
[13:21:46.591]                 NAMES <- toupper(removed)
[13:21:46.591]                 for (kk in seq_along(NAMES)) {
[13:21:46.591]                   name <- removed[[kk]]
[13:21:46.591]                   NAME <- NAMES[[kk]]
[13:21:46.591]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:46.591]                     next
[13:21:46.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:46.591]                 }
[13:21:46.591]                 if (length(args) > 0) 
[13:21:46.591]                   base::do.call(base::Sys.setenv, args = args)
[13:21:46.591]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:46.591]             }
[13:21:46.591]             else {
[13:21:46.591]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:46.591]             }
[13:21:46.591]             {
[13:21:46.591]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:46.591]                   0L) {
[13:21:46.591]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:46.591]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:46.591]                   base::options(opts)
[13:21:46.591]                 }
[13:21:46.591]                 {
[13:21:46.591]                   {
[13:21:46.591]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:46.591]                     NULL
[13:21:46.591]                   }
[13:21:46.591]                   options(future.plan = NULL)
[13:21:46.591]                   if (is.na(NA_character_)) 
[13:21:46.591]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:46.591]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:46.591]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:46.591]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:46.591]                     envir = parent.frame()) 
[13:21:46.591]                   {
[13:21:46.591]                     if (is.function(workers)) 
[13:21:46.591]                       workers <- workers()
[13:21:46.591]                     workers <- structure(as.integer(workers), 
[13:21:46.591]                       class = class(workers))
[13:21:46.591]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:46.591]                       workers >= 1)
[13:21:46.591]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:46.591]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:46.591]                     }
[13:21:46.591]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:46.591]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:46.591]                       envir = envir)
[13:21:46.591]                     if (!future$lazy) 
[13:21:46.591]                       future <- run(future)
[13:21:46.591]                     invisible(future)
[13:21:46.591]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:46.591]                 }
[13:21:46.591]             }
[13:21:46.591]         }
[13:21:46.591]     })
[13:21:46.591]     if (TRUE) {
[13:21:46.591]         base::sink(type = "output", split = FALSE)
[13:21:46.591]         if (TRUE) {
[13:21:46.591]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:46.591]         }
[13:21:46.591]         else {
[13:21:46.591]             ...future.result["stdout"] <- base::list(NULL)
[13:21:46.591]         }
[13:21:46.591]         base::close(...future.stdout)
[13:21:46.591]         ...future.stdout <- NULL
[13:21:46.591]     }
[13:21:46.591]     ...future.result$conditions <- ...future.conditions
[13:21:46.591]     ...future.result$finished <- base::Sys.time()
[13:21:46.591]     ...future.result
[13:21:46.591] }
[13:21:46.594] MultisessionFuture started
[13:21:46.594] - Launch lazy future ... done
[13:21:46.595] run() for ‘MultisessionFuture’ ... done
[13:21:47.143] receiveMessageFromWorker() for ClusterFuture ...
[13:21:47.143] - Validating connection of MultisessionFuture
[13:21:47.143] - received message: FutureResult
[13:21:47.143] - Received FutureResult
[13:21:47.143] - Erased future from FutureRegistry
[13:21:47.143] result() for ClusterFuture ...
[13:21:47.143] - result already collected: FutureResult
[13:21:47.144] result() for ClusterFuture ... done
[13:21:47.144] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:47.144] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[13:21:47.144] getGlobalsAndPackages() ...
[13:21:47.144] Searching for globals...
[13:21:47.145] - globals found: [2] ‘list’, ‘stop’
[13:21:47.145] Searching for globals ... DONE
[13:21:47.145] Resolving globals: FALSE
[13:21:47.145] 
[13:21:47.145] 
[13:21:47.145] getGlobalsAndPackages() ... DONE
[13:21:47.146] run() for ‘Future’ ...
[13:21:47.146] - state: ‘created’
[13:21:47.146] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:47.162] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:47.162] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:47.163]   - Field: ‘node’
[13:21:47.163]   - Field: ‘label’
[13:21:47.163]   - Field: ‘local’
[13:21:47.163]   - Field: ‘owner’
[13:21:47.163]   - Field: ‘envir’
[13:21:47.163]   - Field: ‘workers’
[13:21:47.163]   - Field: ‘packages’
[13:21:47.163]   - Field: ‘gc’
[13:21:47.163]   - Field: ‘conditions’
[13:21:47.163]   - Field: ‘persistent’
[13:21:47.163]   - Field: ‘expr’
[13:21:47.163]   - Field: ‘uuid’
[13:21:47.164]   - Field: ‘seed’
[13:21:47.164]   - Field: ‘version’
[13:21:47.164]   - Field: ‘result’
[13:21:47.164]   - Field: ‘asynchronous’
[13:21:47.164]   - Field: ‘calls’
[13:21:47.164]   - Field: ‘globals’
[13:21:47.164]   - Field: ‘stdout’
[13:21:47.164]   - Field: ‘earlySignal’
[13:21:47.164]   - Field: ‘lazy’
[13:21:47.164]   - Field: ‘state’
[13:21:47.164] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:47.165] - Launch lazy future ...
[13:21:47.165] Packages needed by the future expression (n = 0): <none>
[13:21:47.165] Packages needed by future strategies (n = 0): <none>
[13:21:47.165] {
[13:21:47.165]     {
[13:21:47.165]         {
[13:21:47.165]             ...future.startTime <- base::Sys.time()
[13:21:47.165]             {
[13:21:47.165]                 {
[13:21:47.165]                   {
[13:21:47.165]                     {
[13:21:47.165]                       base::local({
[13:21:47.165]                         has_future <- base::requireNamespace("future", 
[13:21:47.165]                           quietly = TRUE)
[13:21:47.165]                         if (has_future) {
[13:21:47.165]                           ns <- base::getNamespace("future")
[13:21:47.165]                           version <- ns[[".package"]][["version"]]
[13:21:47.165]                           if (is.null(version)) 
[13:21:47.165]                             version <- utils::packageVersion("future")
[13:21:47.165]                         }
[13:21:47.165]                         else {
[13:21:47.165]                           version <- NULL
[13:21:47.165]                         }
[13:21:47.165]                         if (!has_future || version < "1.8.0") {
[13:21:47.165]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:47.165]                             "", base::R.version$version.string), 
[13:21:47.165]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:47.165]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:47.165]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:47.165]                               "release", "version")], collapse = " "), 
[13:21:47.165]                             hostname = base::Sys.info()[["nodename"]])
[13:21:47.165]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:47.165]                             info)
[13:21:47.165]                           info <- base::paste(info, collapse = "; ")
[13:21:47.165]                           if (!has_future) {
[13:21:47.165]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:47.165]                               info)
[13:21:47.165]                           }
[13:21:47.165]                           else {
[13:21:47.165]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:47.165]                               info, version)
[13:21:47.165]                           }
[13:21:47.165]                           base::stop(msg)
[13:21:47.165]                         }
[13:21:47.165]                       })
[13:21:47.165]                     }
[13:21:47.165]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:47.165]                     base::options(mc.cores = 1L)
[13:21:47.165]                   }
[13:21:47.165]                   options(future.plan = NULL)
[13:21:47.165]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:47.165]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:47.165]                 }
[13:21:47.165]                 ...future.workdir <- getwd()
[13:21:47.165]             }
[13:21:47.165]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:47.165]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:47.165]         }
[13:21:47.165]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:47.165]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:47.165]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:47.165]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:47.165]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:47.165]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:47.165]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:47.165]             base::names(...future.oldOptions))
[13:21:47.165]     }
[13:21:47.165]     if (FALSE) {
[13:21:47.165]     }
[13:21:47.165]     else {
[13:21:47.165]         if (TRUE) {
[13:21:47.165]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:47.165]                 open = "w")
[13:21:47.165]         }
[13:21:47.165]         else {
[13:21:47.165]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:47.165]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:47.165]         }
[13:21:47.165]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:47.165]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:47.165]             base::sink(type = "output", split = FALSE)
[13:21:47.165]             base::close(...future.stdout)
[13:21:47.165]         }, add = TRUE)
[13:21:47.165]     }
[13:21:47.165]     ...future.frame <- base::sys.nframe()
[13:21:47.165]     ...future.conditions <- base::list()
[13:21:47.165]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:47.165]     if (FALSE) {
[13:21:47.165]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:47.165]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:47.165]     }
[13:21:47.165]     ...future.result <- base::tryCatch({
[13:21:47.165]         base::withCallingHandlers({
[13:21:47.165]             ...future.value <- base::withVisible(base::local({
[13:21:47.165]                 ...future.makeSendCondition <- local({
[13:21:47.165]                   sendCondition <- NULL
[13:21:47.165]                   function(frame = 1L) {
[13:21:47.165]                     if (is.function(sendCondition)) 
[13:21:47.165]                       return(sendCondition)
[13:21:47.165]                     ns <- getNamespace("parallel")
[13:21:47.165]                     if (exists("sendData", mode = "function", 
[13:21:47.165]                       envir = ns)) {
[13:21:47.165]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:47.165]                         envir = ns)
[13:21:47.165]                       envir <- sys.frame(frame)
[13:21:47.165]                       master <- NULL
[13:21:47.165]                       while (!identical(envir, .GlobalEnv) && 
[13:21:47.165]                         !identical(envir, emptyenv())) {
[13:21:47.165]                         if (exists("master", mode = "list", envir = envir, 
[13:21:47.165]                           inherits = FALSE)) {
[13:21:47.165]                           master <- get("master", mode = "list", 
[13:21:47.165]                             envir = envir, inherits = FALSE)
[13:21:47.165]                           if (inherits(master, c("SOCKnode", 
[13:21:47.165]                             "SOCK0node"))) {
[13:21:47.165]                             sendCondition <<- function(cond) {
[13:21:47.165]                               data <- list(type = "VALUE", value = cond, 
[13:21:47.165]                                 success = TRUE)
[13:21:47.165]                               parallel_sendData(master, data)
[13:21:47.165]                             }
[13:21:47.165]                             return(sendCondition)
[13:21:47.165]                           }
[13:21:47.165]                         }
[13:21:47.165]                         frame <- frame + 1L
[13:21:47.165]                         envir <- sys.frame(frame)
[13:21:47.165]                       }
[13:21:47.165]                     }
[13:21:47.165]                     sendCondition <<- function(cond) NULL
[13:21:47.165]                   }
[13:21:47.165]                 })
[13:21:47.165]                 withCallingHandlers({
[13:21:47.165]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:21:47.165]                 }, immediateCondition = function(cond) {
[13:21:47.165]                   sendCondition <- ...future.makeSendCondition()
[13:21:47.165]                   sendCondition(cond)
[13:21:47.165]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:47.165]                   {
[13:21:47.165]                     inherits <- base::inherits
[13:21:47.165]                     invokeRestart <- base::invokeRestart
[13:21:47.165]                     is.null <- base::is.null
[13:21:47.165]                     muffled <- FALSE
[13:21:47.165]                     if (inherits(cond, "message")) {
[13:21:47.165]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:47.165]                       if (muffled) 
[13:21:47.165]                         invokeRestart("muffleMessage")
[13:21:47.165]                     }
[13:21:47.165]                     else if (inherits(cond, "warning")) {
[13:21:47.165]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:47.165]                       if (muffled) 
[13:21:47.165]                         invokeRestart("muffleWarning")
[13:21:47.165]                     }
[13:21:47.165]                     else if (inherits(cond, "condition")) {
[13:21:47.165]                       if (!is.null(pattern)) {
[13:21:47.165]                         computeRestarts <- base::computeRestarts
[13:21:47.165]                         grepl <- base::grepl
[13:21:47.165]                         restarts <- computeRestarts(cond)
[13:21:47.165]                         for (restart in restarts) {
[13:21:47.165]                           name <- restart$name
[13:21:47.165]                           if (is.null(name)) 
[13:21:47.165]                             next
[13:21:47.165]                           if (!grepl(pattern, name)) 
[13:21:47.165]                             next
[13:21:47.165]                           invokeRestart(restart)
[13:21:47.165]                           muffled <- TRUE
[13:21:47.165]                           break
[13:21:47.165]                         }
[13:21:47.165]                       }
[13:21:47.165]                     }
[13:21:47.165]                     invisible(muffled)
[13:21:47.165]                   }
[13:21:47.165]                   muffleCondition(cond)
[13:21:47.165]                 })
[13:21:47.165]             }))
[13:21:47.165]             future::FutureResult(value = ...future.value$value, 
[13:21:47.165]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:47.165]                   ...future.rng), globalenv = if (FALSE) 
[13:21:47.165]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:47.165]                     ...future.globalenv.names))
[13:21:47.165]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:47.165]         }, condition = base::local({
[13:21:47.165]             c <- base::c
[13:21:47.165]             inherits <- base::inherits
[13:21:47.165]             invokeRestart <- base::invokeRestart
[13:21:47.165]             length <- base::length
[13:21:47.165]             list <- base::list
[13:21:47.165]             seq.int <- base::seq.int
[13:21:47.165]             signalCondition <- base::signalCondition
[13:21:47.165]             sys.calls <- base::sys.calls
[13:21:47.165]             `[[` <- base::`[[`
[13:21:47.165]             `+` <- base::`+`
[13:21:47.165]             `<<-` <- base::`<<-`
[13:21:47.165]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:47.165]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:47.165]                   3L)]
[13:21:47.165]             }
[13:21:47.165]             function(cond) {
[13:21:47.165]                 is_error <- inherits(cond, "error")
[13:21:47.165]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:47.165]                   NULL)
[13:21:47.165]                 if (is_error) {
[13:21:47.165]                   sessionInformation <- function() {
[13:21:47.165]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:47.165]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:47.165]                       search = base::search(), system = base::Sys.info())
[13:21:47.165]                   }
[13:21:47.165]                   ...future.conditions[[length(...future.conditions) + 
[13:21:47.165]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:47.165]                     cond$call), session = sessionInformation(), 
[13:21:47.165]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:47.165]                   signalCondition(cond)
[13:21:47.165]                 }
[13:21:47.165]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:47.165]                 "immediateCondition"))) {
[13:21:47.165]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:47.165]                   ...future.conditions[[length(...future.conditions) + 
[13:21:47.165]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:47.165]                   if (TRUE && !signal) {
[13:21:47.165]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:47.165]                     {
[13:21:47.165]                       inherits <- base::inherits
[13:21:47.165]                       invokeRestart <- base::invokeRestart
[13:21:47.165]                       is.null <- base::is.null
[13:21:47.165]                       muffled <- FALSE
[13:21:47.165]                       if (inherits(cond, "message")) {
[13:21:47.165]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:47.165]                         if (muffled) 
[13:21:47.165]                           invokeRestart("muffleMessage")
[13:21:47.165]                       }
[13:21:47.165]                       else if (inherits(cond, "warning")) {
[13:21:47.165]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:47.165]                         if (muffled) 
[13:21:47.165]                           invokeRestart("muffleWarning")
[13:21:47.165]                       }
[13:21:47.165]                       else if (inherits(cond, "condition")) {
[13:21:47.165]                         if (!is.null(pattern)) {
[13:21:47.165]                           computeRestarts <- base::computeRestarts
[13:21:47.165]                           grepl <- base::grepl
[13:21:47.165]                           restarts <- computeRestarts(cond)
[13:21:47.165]                           for (restart in restarts) {
[13:21:47.165]                             name <- restart$name
[13:21:47.165]                             if (is.null(name)) 
[13:21:47.165]                               next
[13:21:47.165]                             if (!grepl(pattern, name)) 
[13:21:47.165]                               next
[13:21:47.165]                             invokeRestart(restart)
[13:21:47.165]                             muffled <- TRUE
[13:21:47.165]                             break
[13:21:47.165]                           }
[13:21:47.165]                         }
[13:21:47.165]                       }
[13:21:47.165]                       invisible(muffled)
[13:21:47.165]                     }
[13:21:47.165]                     muffleCondition(cond, pattern = "^muffle")
[13:21:47.165]                   }
[13:21:47.165]                 }
[13:21:47.165]                 else {
[13:21:47.165]                   if (TRUE) {
[13:21:47.165]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:47.165]                     {
[13:21:47.165]                       inherits <- base::inherits
[13:21:47.165]                       invokeRestart <- base::invokeRestart
[13:21:47.165]                       is.null <- base::is.null
[13:21:47.165]                       muffled <- FALSE
[13:21:47.165]                       if (inherits(cond, "message")) {
[13:21:47.165]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:47.165]                         if (muffled) 
[13:21:47.165]                           invokeRestart("muffleMessage")
[13:21:47.165]                       }
[13:21:47.165]                       else if (inherits(cond, "warning")) {
[13:21:47.165]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:47.165]                         if (muffled) 
[13:21:47.165]                           invokeRestart("muffleWarning")
[13:21:47.165]                       }
[13:21:47.165]                       else if (inherits(cond, "condition")) {
[13:21:47.165]                         if (!is.null(pattern)) {
[13:21:47.165]                           computeRestarts <- base::computeRestarts
[13:21:47.165]                           grepl <- base::grepl
[13:21:47.165]                           restarts <- computeRestarts(cond)
[13:21:47.165]                           for (restart in restarts) {
[13:21:47.165]                             name <- restart$name
[13:21:47.165]                             if (is.null(name)) 
[13:21:47.165]                               next
[13:21:47.165]                             if (!grepl(pattern, name)) 
[13:21:47.165]                               next
[13:21:47.165]                             invokeRestart(restart)
[13:21:47.165]                             muffled <- TRUE
[13:21:47.165]                             break
[13:21:47.165]                           }
[13:21:47.165]                         }
[13:21:47.165]                       }
[13:21:47.165]                       invisible(muffled)
[13:21:47.165]                     }
[13:21:47.165]                     muffleCondition(cond, pattern = "^muffle")
[13:21:47.165]                   }
[13:21:47.165]                 }
[13:21:47.165]             }
[13:21:47.165]         }))
[13:21:47.165]     }, error = function(ex) {
[13:21:47.165]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:47.165]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:47.165]                 ...future.rng), started = ...future.startTime, 
[13:21:47.165]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:47.165]             version = "1.8"), class = "FutureResult")
[13:21:47.165]     }, finally = {
[13:21:47.165]         if (!identical(...future.workdir, getwd())) 
[13:21:47.165]             setwd(...future.workdir)
[13:21:47.165]         {
[13:21:47.165]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:47.165]                 ...future.oldOptions$nwarnings <- NULL
[13:21:47.165]             }
[13:21:47.165]             base::options(...future.oldOptions)
[13:21:47.165]             if (.Platform$OS.type == "windows") {
[13:21:47.165]                 old_names <- names(...future.oldEnvVars)
[13:21:47.165]                 envs <- base::Sys.getenv()
[13:21:47.165]                 names <- names(envs)
[13:21:47.165]                 common <- intersect(names, old_names)
[13:21:47.165]                 added <- setdiff(names, old_names)
[13:21:47.165]                 removed <- setdiff(old_names, names)
[13:21:47.165]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:47.165]                   envs[common]]
[13:21:47.165]                 NAMES <- toupper(changed)
[13:21:47.165]                 args <- list()
[13:21:47.165]                 for (kk in seq_along(NAMES)) {
[13:21:47.165]                   name <- changed[[kk]]
[13:21:47.165]                   NAME <- NAMES[[kk]]
[13:21:47.165]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:47.165]                     next
[13:21:47.165]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:47.165]                 }
[13:21:47.165]                 NAMES <- toupper(added)
[13:21:47.165]                 for (kk in seq_along(NAMES)) {
[13:21:47.165]                   name <- added[[kk]]
[13:21:47.165]                   NAME <- NAMES[[kk]]
[13:21:47.165]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:47.165]                     next
[13:21:47.165]                   args[[name]] <- ""
[13:21:47.165]                 }
[13:21:47.165]                 NAMES <- toupper(removed)
[13:21:47.165]                 for (kk in seq_along(NAMES)) {
[13:21:47.165]                   name <- removed[[kk]]
[13:21:47.165]                   NAME <- NAMES[[kk]]
[13:21:47.165]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:47.165]                     next
[13:21:47.165]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:47.165]                 }
[13:21:47.165]                 if (length(args) > 0) 
[13:21:47.165]                   base::do.call(base::Sys.setenv, args = args)
[13:21:47.165]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:47.165]             }
[13:21:47.165]             else {
[13:21:47.165]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:47.165]             }
[13:21:47.165]             {
[13:21:47.165]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:47.165]                   0L) {
[13:21:47.165]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:47.165]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:47.165]                   base::options(opts)
[13:21:47.165]                 }
[13:21:47.165]                 {
[13:21:47.165]                   {
[13:21:47.165]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:47.165]                     NULL
[13:21:47.165]                   }
[13:21:47.165]                   options(future.plan = NULL)
[13:21:47.165]                   if (is.na(NA_character_)) 
[13:21:47.165]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:47.165]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:47.165]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:47.165]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:47.165]                     envir = parent.frame()) 
[13:21:47.165]                   {
[13:21:47.165]                     if (is.function(workers)) 
[13:21:47.165]                       workers <- workers()
[13:21:47.165]                     workers <- structure(as.integer(workers), 
[13:21:47.165]                       class = class(workers))
[13:21:47.165]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:47.165]                       workers >= 1)
[13:21:47.165]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:47.165]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:47.165]                     }
[13:21:47.165]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:47.165]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:47.165]                       envir = envir)
[13:21:47.165]                     if (!future$lazy) 
[13:21:47.165]                       future <- run(future)
[13:21:47.165]                     invisible(future)
[13:21:47.165]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:47.165]                 }
[13:21:47.165]             }
[13:21:47.165]         }
[13:21:47.165]     })
[13:21:47.165]     if (TRUE) {
[13:21:47.165]         base::sink(type = "output", split = FALSE)
[13:21:47.165]         if (TRUE) {
[13:21:47.165]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:47.165]         }
[13:21:47.165]         else {
[13:21:47.165]             ...future.result["stdout"] <- base::list(NULL)
[13:21:47.165]         }
[13:21:47.165]         base::close(...future.stdout)
[13:21:47.165]         ...future.stdout <- NULL
[13:21:47.165]     }
[13:21:47.165]     ...future.result$conditions <- ...future.conditions
[13:21:47.165]     ...future.result$finished <- base::Sys.time()
[13:21:47.165]     ...future.result
[13:21:47.165] }
[13:21:47.169] MultisessionFuture started
[13:21:47.169] - Launch lazy future ... done
[13:21:47.169] run() for ‘MultisessionFuture’ ... done
[13:21:47.218] receiveMessageFromWorker() for ClusterFuture ...
[13:21:47.218] - Validating connection of MultisessionFuture
[13:21:47.218] - received message: FutureResult
[13:21:47.218] - Received FutureResult
[13:21:47.219] - Erased future from FutureRegistry
[13:21:47.219] result() for ClusterFuture ...
[13:21:47.219] - result already collected: FutureResult
[13:21:47.219] result() for ClusterFuture ... done
[13:21:47.219] signalConditions() ...
[13:21:47.219]  - include = ‘immediateCondition’
[13:21:47.219]  - exclude = 
[13:21:47.219]  - resignal = FALSE
[13:21:47.219]  - Number of conditions: 1
[13:21:47.219] signalConditions() ... done
[13:21:47.219] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:47.220] A MultisessionFuture was resolved (result was not collected)
[13:21:47.220] getGlobalsAndPackages() ...
[13:21:47.220] Searching for globals...
[13:21:47.220] - globals found: [2] ‘list’, ‘stop’
[13:21:47.221] Searching for globals ... DONE
[13:21:47.221] Resolving globals: FALSE
[13:21:47.221] 
[13:21:47.221] 
[13:21:47.221] getGlobalsAndPackages() ... DONE
[13:21:47.221] run() for ‘Future’ ...
[13:21:47.222] - state: ‘created’
[13:21:47.222] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:47.236] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:47.236] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:47.237]   - Field: ‘node’
[13:21:47.237]   - Field: ‘label’
[13:21:47.237]   - Field: ‘local’
[13:21:47.237]   - Field: ‘owner’
[13:21:47.237]   - Field: ‘envir’
[13:21:47.237]   - Field: ‘workers’
[13:21:47.237]   - Field: ‘packages’
[13:21:47.237]   - Field: ‘gc’
[13:21:47.237]   - Field: ‘conditions’
[13:21:47.237]   - Field: ‘persistent’
[13:21:47.238]   - Field: ‘expr’
[13:21:47.238]   - Field: ‘uuid’
[13:21:47.238]   - Field: ‘seed’
[13:21:47.238]   - Field: ‘version’
[13:21:47.238]   - Field: ‘result’
[13:21:47.238]   - Field: ‘asynchronous’
[13:21:47.238]   - Field: ‘calls’
[13:21:47.238]   - Field: ‘globals’
[13:21:47.238]   - Field: ‘stdout’
[13:21:47.238]   - Field: ‘earlySignal’
[13:21:47.238]   - Field: ‘lazy’
[13:21:47.239]   - Field: ‘state’
[13:21:47.239] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:47.239] - Launch lazy future ...
[13:21:47.239] Packages needed by the future expression (n = 0): <none>
[13:21:47.239] Packages needed by future strategies (n = 0): <none>
[13:21:47.240] {
[13:21:47.240]     {
[13:21:47.240]         {
[13:21:47.240]             ...future.startTime <- base::Sys.time()
[13:21:47.240]             {
[13:21:47.240]                 {
[13:21:47.240]                   {
[13:21:47.240]                     {
[13:21:47.240]                       base::local({
[13:21:47.240]                         has_future <- base::requireNamespace("future", 
[13:21:47.240]                           quietly = TRUE)
[13:21:47.240]                         if (has_future) {
[13:21:47.240]                           ns <- base::getNamespace("future")
[13:21:47.240]                           version <- ns[[".package"]][["version"]]
[13:21:47.240]                           if (is.null(version)) 
[13:21:47.240]                             version <- utils::packageVersion("future")
[13:21:47.240]                         }
[13:21:47.240]                         else {
[13:21:47.240]                           version <- NULL
[13:21:47.240]                         }
[13:21:47.240]                         if (!has_future || version < "1.8.0") {
[13:21:47.240]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:47.240]                             "", base::R.version$version.string), 
[13:21:47.240]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:47.240]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:47.240]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:47.240]                               "release", "version")], collapse = " "), 
[13:21:47.240]                             hostname = base::Sys.info()[["nodename"]])
[13:21:47.240]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:47.240]                             info)
[13:21:47.240]                           info <- base::paste(info, collapse = "; ")
[13:21:47.240]                           if (!has_future) {
[13:21:47.240]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:47.240]                               info)
[13:21:47.240]                           }
[13:21:47.240]                           else {
[13:21:47.240]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:47.240]                               info, version)
[13:21:47.240]                           }
[13:21:47.240]                           base::stop(msg)
[13:21:47.240]                         }
[13:21:47.240]                       })
[13:21:47.240]                     }
[13:21:47.240]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:47.240]                     base::options(mc.cores = 1L)
[13:21:47.240]                   }
[13:21:47.240]                   options(future.plan = NULL)
[13:21:47.240]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:47.240]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:47.240]                 }
[13:21:47.240]                 ...future.workdir <- getwd()
[13:21:47.240]             }
[13:21:47.240]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:47.240]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:47.240]         }
[13:21:47.240]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:47.240]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:47.240]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:47.240]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:47.240]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:47.240]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:47.240]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:47.240]             base::names(...future.oldOptions))
[13:21:47.240]     }
[13:21:47.240]     if (FALSE) {
[13:21:47.240]     }
[13:21:47.240]     else {
[13:21:47.240]         if (TRUE) {
[13:21:47.240]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:47.240]                 open = "w")
[13:21:47.240]         }
[13:21:47.240]         else {
[13:21:47.240]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:47.240]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:47.240]         }
[13:21:47.240]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:47.240]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:47.240]             base::sink(type = "output", split = FALSE)
[13:21:47.240]             base::close(...future.stdout)
[13:21:47.240]         }, add = TRUE)
[13:21:47.240]     }
[13:21:47.240]     ...future.frame <- base::sys.nframe()
[13:21:47.240]     ...future.conditions <- base::list()
[13:21:47.240]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:47.240]     if (FALSE) {
[13:21:47.240]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:47.240]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:47.240]     }
[13:21:47.240]     ...future.result <- base::tryCatch({
[13:21:47.240]         base::withCallingHandlers({
[13:21:47.240]             ...future.value <- base::withVisible(base::local({
[13:21:47.240]                 ...future.makeSendCondition <- local({
[13:21:47.240]                   sendCondition <- NULL
[13:21:47.240]                   function(frame = 1L) {
[13:21:47.240]                     if (is.function(sendCondition)) 
[13:21:47.240]                       return(sendCondition)
[13:21:47.240]                     ns <- getNamespace("parallel")
[13:21:47.240]                     if (exists("sendData", mode = "function", 
[13:21:47.240]                       envir = ns)) {
[13:21:47.240]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:47.240]                         envir = ns)
[13:21:47.240]                       envir <- sys.frame(frame)
[13:21:47.240]                       master <- NULL
[13:21:47.240]                       while (!identical(envir, .GlobalEnv) && 
[13:21:47.240]                         !identical(envir, emptyenv())) {
[13:21:47.240]                         if (exists("master", mode = "list", envir = envir, 
[13:21:47.240]                           inherits = FALSE)) {
[13:21:47.240]                           master <- get("master", mode = "list", 
[13:21:47.240]                             envir = envir, inherits = FALSE)
[13:21:47.240]                           if (inherits(master, c("SOCKnode", 
[13:21:47.240]                             "SOCK0node"))) {
[13:21:47.240]                             sendCondition <<- function(cond) {
[13:21:47.240]                               data <- list(type = "VALUE", value = cond, 
[13:21:47.240]                                 success = TRUE)
[13:21:47.240]                               parallel_sendData(master, data)
[13:21:47.240]                             }
[13:21:47.240]                             return(sendCondition)
[13:21:47.240]                           }
[13:21:47.240]                         }
[13:21:47.240]                         frame <- frame + 1L
[13:21:47.240]                         envir <- sys.frame(frame)
[13:21:47.240]                       }
[13:21:47.240]                     }
[13:21:47.240]                     sendCondition <<- function(cond) NULL
[13:21:47.240]                   }
[13:21:47.240]                 })
[13:21:47.240]                 withCallingHandlers({
[13:21:47.240]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:21:47.240]                 }, immediateCondition = function(cond) {
[13:21:47.240]                   sendCondition <- ...future.makeSendCondition()
[13:21:47.240]                   sendCondition(cond)
[13:21:47.240]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:47.240]                   {
[13:21:47.240]                     inherits <- base::inherits
[13:21:47.240]                     invokeRestart <- base::invokeRestart
[13:21:47.240]                     is.null <- base::is.null
[13:21:47.240]                     muffled <- FALSE
[13:21:47.240]                     if (inherits(cond, "message")) {
[13:21:47.240]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:47.240]                       if (muffled) 
[13:21:47.240]                         invokeRestart("muffleMessage")
[13:21:47.240]                     }
[13:21:47.240]                     else if (inherits(cond, "warning")) {
[13:21:47.240]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:47.240]                       if (muffled) 
[13:21:47.240]                         invokeRestart("muffleWarning")
[13:21:47.240]                     }
[13:21:47.240]                     else if (inherits(cond, "condition")) {
[13:21:47.240]                       if (!is.null(pattern)) {
[13:21:47.240]                         computeRestarts <- base::computeRestarts
[13:21:47.240]                         grepl <- base::grepl
[13:21:47.240]                         restarts <- computeRestarts(cond)
[13:21:47.240]                         for (restart in restarts) {
[13:21:47.240]                           name <- restart$name
[13:21:47.240]                           if (is.null(name)) 
[13:21:47.240]                             next
[13:21:47.240]                           if (!grepl(pattern, name)) 
[13:21:47.240]                             next
[13:21:47.240]                           invokeRestart(restart)
[13:21:47.240]                           muffled <- TRUE
[13:21:47.240]                           break
[13:21:47.240]                         }
[13:21:47.240]                       }
[13:21:47.240]                     }
[13:21:47.240]                     invisible(muffled)
[13:21:47.240]                   }
[13:21:47.240]                   muffleCondition(cond)
[13:21:47.240]                 })
[13:21:47.240]             }))
[13:21:47.240]             future::FutureResult(value = ...future.value$value, 
[13:21:47.240]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:47.240]                   ...future.rng), globalenv = if (FALSE) 
[13:21:47.240]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:47.240]                     ...future.globalenv.names))
[13:21:47.240]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:47.240]         }, condition = base::local({
[13:21:47.240]             c <- base::c
[13:21:47.240]             inherits <- base::inherits
[13:21:47.240]             invokeRestart <- base::invokeRestart
[13:21:47.240]             length <- base::length
[13:21:47.240]             list <- base::list
[13:21:47.240]             seq.int <- base::seq.int
[13:21:47.240]             signalCondition <- base::signalCondition
[13:21:47.240]             sys.calls <- base::sys.calls
[13:21:47.240]             `[[` <- base::`[[`
[13:21:47.240]             `+` <- base::`+`
[13:21:47.240]             `<<-` <- base::`<<-`
[13:21:47.240]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:47.240]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:47.240]                   3L)]
[13:21:47.240]             }
[13:21:47.240]             function(cond) {
[13:21:47.240]                 is_error <- inherits(cond, "error")
[13:21:47.240]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:47.240]                   NULL)
[13:21:47.240]                 if (is_error) {
[13:21:47.240]                   sessionInformation <- function() {
[13:21:47.240]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:47.240]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:47.240]                       search = base::search(), system = base::Sys.info())
[13:21:47.240]                   }
[13:21:47.240]                   ...future.conditions[[length(...future.conditions) + 
[13:21:47.240]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:47.240]                     cond$call), session = sessionInformation(), 
[13:21:47.240]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:47.240]                   signalCondition(cond)
[13:21:47.240]                 }
[13:21:47.240]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:47.240]                 "immediateCondition"))) {
[13:21:47.240]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:47.240]                   ...future.conditions[[length(...future.conditions) + 
[13:21:47.240]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:47.240]                   if (TRUE && !signal) {
[13:21:47.240]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:47.240]                     {
[13:21:47.240]                       inherits <- base::inherits
[13:21:47.240]                       invokeRestart <- base::invokeRestart
[13:21:47.240]                       is.null <- base::is.null
[13:21:47.240]                       muffled <- FALSE
[13:21:47.240]                       if (inherits(cond, "message")) {
[13:21:47.240]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:47.240]                         if (muffled) 
[13:21:47.240]                           invokeRestart("muffleMessage")
[13:21:47.240]                       }
[13:21:47.240]                       else if (inherits(cond, "warning")) {
[13:21:47.240]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:47.240]                         if (muffled) 
[13:21:47.240]                           invokeRestart("muffleWarning")
[13:21:47.240]                       }
[13:21:47.240]                       else if (inherits(cond, "condition")) {
[13:21:47.240]                         if (!is.null(pattern)) {
[13:21:47.240]                           computeRestarts <- base::computeRestarts
[13:21:47.240]                           grepl <- base::grepl
[13:21:47.240]                           restarts <- computeRestarts(cond)
[13:21:47.240]                           for (restart in restarts) {
[13:21:47.240]                             name <- restart$name
[13:21:47.240]                             if (is.null(name)) 
[13:21:47.240]                               next
[13:21:47.240]                             if (!grepl(pattern, name)) 
[13:21:47.240]                               next
[13:21:47.240]                             invokeRestart(restart)
[13:21:47.240]                             muffled <- TRUE
[13:21:47.240]                             break
[13:21:47.240]                           }
[13:21:47.240]                         }
[13:21:47.240]                       }
[13:21:47.240]                       invisible(muffled)
[13:21:47.240]                     }
[13:21:47.240]                     muffleCondition(cond, pattern = "^muffle")
[13:21:47.240]                   }
[13:21:47.240]                 }
[13:21:47.240]                 else {
[13:21:47.240]                   if (TRUE) {
[13:21:47.240]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:47.240]                     {
[13:21:47.240]                       inherits <- base::inherits
[13:21:47.240]                       invokeRestart <- base::invokeRestart
[13:21:47.240]                       is.null <- base::is.null
[13:21:47.240]                       muffled <- FALSE
[13:21:47.240]                       if (inherits(cond, "message")) {
[13:21:47.240]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:47.240]                         if (muffled) 
[13:21:47.240]                           invokeRestart("muffleMessage")
[13:21:47.240]                       }
[13:21:47.240]                       else if (inherits(cond, "warning")) {
[13:21:47.240]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:47.240]                         if (muffled) 
[13:21:47.240]                           invokeRestart("muffleWarning")
[13:21:47.240]                       }
[13:21:47.240]                       else if (inherits(cond, "condition")) {
[13:21:47.240]                         if (!is.null(pattern)) {
[13:21:47.240]                           computeRestarts <- base::computeRestarts
[13:21:47.240]                           grepl <- base::grepl
[13:21:47.240]                           restarts <- computeRestarts(cond)
[13:21:47.240]                           for (restart in restarts) {
[13:21:47.240]                             name <- restart$name
[13:21:47.240]                             if (is.null(name)) 
[13:21:47.240]                               next
[13:21:47.240]                             if (!grepl(pattern, name)) 
[13:21:47.240]                               next
[13:21:47.240]                             invokeRestart(restart)
[13:21:47.240]                             muffled <- TRUE
[13:21:47.240]                             break
[13:21:47.240]                           }
[13:21:47.240]                         }
[13:21:47.240]                       }
[13:21:47.240]                       invisible(muffled)
[13:21:47.240]                     }
[13:21:47.240]                     muffleCondition(cond, pattern = "^muffle")
[13:21:47.240]                   }
[13:21:47.240]                 }
[13:21:47.240]             }
[13:21:47.240]         }))
[13:21:47.240]     }, error = function(ex) {
[13:21:47.240]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:47.240]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:47.240]                 ...future.rng), started = ...future.startTime, 
[13:21:47.240]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:47.240]             version = "1.8"), class = "FutureResult")
[13:21:47.240]     }, finally = {
[13:21:47.240]         if (!identical(...future.workdir, getwd())) 
[13:21:47.240]             setwd(...future.workdir)
[13:21:47.240]         {
[13:21:47.240]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:47.240]                 ...future.oldOptions$nwarnings <- NULL
[13:21:47.240]             }
[13:21:47.240]             base::options(...future.oldOptions)
[13:21:47.240]             if (.Platform$OS.type == "windows") {
[13:21:47.240]                 old_names <- names(...future.oldEnvVars)
[13:21:47.240]                 envs <- base::Sys.getenv()
[13:21:47.240]                 names <- names(envs)
[13:21:47.240]                 common <- intersect(names, old_names)
[13:21:47.240]                 added <- setdiff(names, old_names)
[13:21:47.240]                 removed <- setdiff(old_names, names)
[13:21:47.240]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:47.240]                   envs[common]]
[13:21:47.240]                 NAMES <- toupper(changed)
[13:21:47.240]                 args <- list()
[13:21:47.240]                 for (kk in seq_along(NAMES)) {
[13:21:47.240]                   name <- changed[[kk]]
[13:21:47.240]                   NAME <- NAMES[[kk]]
[13:21:47.240]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:47.240]                     next
[13:21:47.240]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:47.240]                 }
[13:21:47.240]                 NAMES <- toupper(added)
[13:21:47.240]                 for (kk in seq_along(NAMES)) {
[13:21:47.240]                   name <- added[[kk]]
[13:21:47.240]                   NAME <- NAMES[[kk]]
[13:21:47.240]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:47.240]                     next
[13:21:47.240]                   args[[name]] <- ""
[13:21:47.240]                 }
[13:21:47.240]                 NAMES <- toupper(removed)
[13:21:47.240]                 for (kk in seq_along(NAMES)) {
[13:21:47.240]                   name <- removed[[kk]]
[13:21:47.240]                   NAME <- NAMES[[kk]]
[13:21:47.240]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:47.240]                     next
[13:21:47.240]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:47.240]                 }
[13:21:47.240]                 if (length(args) > 0) 
[13:21:47.240]                   base::do.call(base::Sys.setenv, args = args)
[13:21:47.240]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:47.240]             }
[13:21:47.240]             else {
[13:21:47.240]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:47.240]             }
[13:21:47.240]             {
[13:21:47.240]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:47.240]                   0L) {
[13:21:47.240]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:47.240]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:47.240]                   base::options(opts)
[13:21:47.240]                 }
[13:21:47.240]                 {
[13:21:47.240]                   {
[13:21:47.240]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:47.240]                     NULL
[13:21:47.240]                   }
[13:21:47.240]                   options(future.plan = NULL)
[13:21:47.240]                   if (is.na(NA_character_)) 
[13:21:47.240]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:47.240]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:47.240]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:47.240]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:47.240]                     envir = parent.frame()) 
[13:21:47.240]                   {
[13:21:47.240]                     if (is.function(workers)) 
[13:21:47.240]                       workers <- workers()
[13:21:47.240]                     workers <- structure(as.integer(workers), 
[13:21:47.240]                       class = class(workers))
[13:21:47.240]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:47.240]                       workers >= 1)
[13:21:47.240]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:47.240]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:47.240]                     }
[13:21:47.240]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:47.240]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:47.240]                       envir = envir)
[13:21:47.240]                     if (!future$lazy) 
[13:21:47.240]                       future <- run(future)
[13:21:47.240]                     invisible(future)
[13:21:47.240]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:47.240]                 }
[13:21:47.240]             }
[13:21:47.240]         }
[13:21:47.240]     })
[13:21:47.240]     if (TRUE) {
[13:21:47.240]         base::sink(type = "output", split = FALSE)
[13:21:47.240]         if (TRUE) {
[13:21:47.240]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:47.240]         }
[13:21:47.240]         else {
[13:21:47.240]             ...future.result["stdout"] <- base::list(NULL)
[13:21:47.240]         }
[13:21:47.240]         base::close(...future.stdout)
[13:21:47.240]         ...future.stdout <- NULL
[13:21:47.240]     }
[13:21:47.240]     ...future.result$conditions <- ...future.conditions
[13:21:47.240]     ...future.result$finished <- base::Sys.time()
[13:21:47.240]     ...future.result
[13:21:47.240] }
[13:21:47.243] MultisessionFuture started
[13:21:47.243] - Launch lazy future ... done
[13:21:47.243] run() for ‘MultisessionFuture’ ... done
[13:21:47.290] receiveMessageFromWorker() for ClusterFuture ...
[13:21:47.290] - Validating connection of MultisessionFuture
[13:21:47.290] - received message: FutureResult
[13:21:47.291] - Received FutureResult
[13:21:47.291] - Erased future from FutureRegistry
[13:21:47.291] result() for ClusterFuture ...
[13:21:47.291] - result already collected: FutureResult
[13:21:47.291] result() for ClusterFuture ... done
[13:21:47.291] signalConditions() ...
[13:21:47.291]  - include = ‘immediateCondition’
[13:21:47.291]  - exclude = 
[13:21:47.291]  - resignal = FALSE
[13:21:47.291]  - Number of conditions: 1
[13:21:47.292] signalConditions() ... done
[13:21:47.292] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:47.292] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 0 ... DONE
- result = FALSE, recursive = 1 ...
[13:21:47.292] getGlobalsAndPackages() ...
[13:21:47.292] Searching for globals...
[13:21:47.293] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:21:47.293] Searching for globals ... DONE
[13:21:47.294] Resolving globals: FALSE
[13:21:47.294] 
[13:21:47.294] 
[13:21:47.294] getGlobalsAndPackages() ... DONE
[13:21:47.294] run() for ‘Future’ ...
[13:21:47.294] - state: ‘created’
[13:21:47.295] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:47.311] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:47.311] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:47.311]   - Field: ‘node’
[13:21:47.311]   - Field: ‘label’
[13:21:47.311]   - Field: ‘local’
[13:21:47.312]   - Field: ‘owner’
[13:21:47.312]   - Field: ‘envir’
[13:21:47.312]   - Field: ‘workers’
[13:21:47.312]   - Field: ‘packages’
[13:21:47.312]   - Field: ‘gc’
[13:21:47.312]   - Field: ‘conditions’
[13:21:47.312]   - Field: ‘persistent’
[13:21:47.312]   - Field: ‘expr’
[13:21:47.312]   - Field: ‘uuid’
[13:21:47.312]   - Field: ‘seed’
[13:21:47.312]   - Field: ‘version’
[13:21:47.313]   - Field: ‘result’
[13:21:47.313]   - Field: ‘asynchronous’
[13:21:47.313]   - Field: ‘calls’
[13:21:47.313]   - Field: ‘globals’
[13:21:47.313]   - Field: ‘stdout’
[13:21:47.313]   - Field: ‘earlySignal’
[13:21:47.313]   - Field: ‘lazy’
[13:21:47.313]   - Field: ‘state’
[13:21:47.313] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:47.313] - Launch lazy future ...
[13:21:47.314] Packages needed by the future expression (n = 0): <none>
[13:21:47.314] Packages needed by future strategies (n = 0): <none>
[13:21:47.314] {
[13:21:47.314]     {
[13:21:47.314]         {
[13:21:47.314]             ...future.startTime <- base::Sys.time()
[13:21:47.314]             {
[13:21:47.314]                 {
[13:21:47.314]                   {
[13:21:47.314]                     {
[13:21:47.314]                       base::local({
[13:21:47.314]                         has_future <- base::requireNamespace("future", 
[13:21:47.314]                           quietly = TRUE)
[13:21:47.314]                         if (has_future) {
[13:21:47.314]                           ns <- base::getNamespace("future")
[13:21:47.314]                           version <- ns[[".package"]][["version"]]
[13:21:47.314]                           if (is.null(version)) 
[13:21:47.314]                             version <- utils::packageVersion("future")
[13:21:47.314]                         }
[13:21:47.314]                         else {
[13:21:47.314]                           version <- NULL
[13:21:47.314]                         }
[13:21:47.314]                         if (!has_future || version < "1.8.0") {
[13:21:47.314]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:47.314]                             "", base::R.version$version.string), 
[13:21:47.314]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:47.314]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:47.314]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:47.314]                               "release", "version")], collapse = " "), 
[13:21:47.314]                             hostname = base::Sys.info()[["nodename"]])
[13:21:47.314]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:47.314]                             info)
[13:21:47.314]                           info <- base::paste(info, collapse = "; ")
[13:21:47.314]                           if (!has_future) {
[13:21:47.314]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:47.314]                               info)
[13:21:47.314]                           }
[13:21:47.314]                           else {
[13:21:47.314]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:47.314]                               info, version)
[13:21:47.314]                           }
[13:21:47.314]                           base::stop(msg)
[13:21:47.314]                         }
[13:21:47.314]                       })
[13:21:47.314]                     }
[13:21:47.314]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:47.314]                     base::options(mc.cores = 1L)
[13:21:47.314]                   }
[13:21:47.314]                   options(future.plan = NULL)
[13:21:47.314]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:47.314]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:47.314]                 }
[13:21:47.314]                 ...future.workdir <- getwd()
[13:21:47.314]             }
[13:21:47.314]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:47.314]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:47.314]         }
[13:21:47.314]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:47.314]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:47.314]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:47.314]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:47.314]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:47.314]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:47.314]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:47.314]             base::names(...future.oldOptions))
[13:21:47.314]     }
[13:21:47.314]     if (FALSE) {
[13:21:47.314]     }
[13:21:47.314]     else {
[13:21:47.314]         if (TRUE) {
[13:21:47.314]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:47.314]                 open = "w")
[13:21:47.314]         }
[13:21:47.314]         else {
[13:21:47.314]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:47.314]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:47.314]         }
[13:21:47.314]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:47.314]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:47.314]             base::sink(type = "output", split = FALSE)
[13:21:47.314]             base::close(...future.stdout)
[13:21:47.314]         }, add = TRUE)
[13:21:47.314]     }
[13:21:47.314]     ...future.frame <- base::sys.nframe()
[13:21:47.314]     ...future.conditions <- base::list()
[13:21:47.314]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:47.314]     if (FALSE) {
[13:21:47.314]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:47.314]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:47.314]     }
[13:21:47.314]     ...future.result <- base::tryCatch({
[13:21:47.314]         base::withCallingHandlers({
[13:21:47.314]             ...future.value <- base::withVisible(base::local({
[13:21:47.314]                 ...future.makeSendCondition <- local({
[13:21:47.314]                   sendCondition <- NULL
[13:21:47.314]                   function(frame = 1L) {
[13:21:47.314]                     if (is.function(sendCondition)) 
[13:21:47.314]                       return(sendCondition)
[13:21:47.314]                     ns <- getNamespace("parallel")
[13:21:47.314]                     if (exists("sendData", mode = "function", 
[13:21:47.314]                       envir = ns)) {
[13:21:47.314]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:47.314]                         envir = ns)
[13:21:47.314]                       envir <- sys.frame(frame)
[13:21:47.314]                       master <- NULL
[13:21:47.314]                       while (!identical(envir, .GlobalEnv) && 
[13:21:47.314]                         !identical(envir, emptyenv())) {
[13:21:47.314]                         if (exists("master", mode = "list", envir = envir, 
[13:21:47.314]                           inherits = FALSE)) {
[13:21:47.314]                           master <- get("master", mode = "list", 
[13:21:47.314]                             envir = envir, inherits = FALSE)
[13:21:47.314]                           if (inherits(master, c("SOCKnode", 
[13:21:47.314]                             "SOCK0node"))) {
[13:21:47.314]                             sendCondition <<- function(cond) {
[13:21:47.314]                               data <- list(type = "VALUE", value = cond, 
[13:21:47.314]                                 success = TRUE)
[13:21:47.314]                               parallel_sendData(master, data)
[13:21:47.314]                             }
[13:21:47.314]                             return(sendCondition)
[13:21:47.314]                           }
[13:21:47.314]                         }
[13:21:47.314]                         frame <- frame + 1L
[13:21:47.314]                         envir <- sys.frame(frame)
[13:21:47.314]                       }
[13:21:47.314]                     }
[13:21:47.314]                     sendCondition <<- function(cond) NULL
[13:21:47.314]                   }
[13:21:47.314]                 })
[13:21:47.314]                 withCallingHandlers({
[13:21:47.314]                   {
[13:21:47.314]                     Sys.sleep(0.5)
[13:21:47.314]                     list(a = 1, b = 42L)
[13:21:47.314]                   }
[13:21:47.314]                 }, immediateCondition = function(cond) {
[13:21:47.314]                   sendCondition <- ...future.makeSendCondition()
[13:21:47.314]                   sendCondition(cond)
[13:21:47.314]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:47.314]                   {
[13:21:47.314]                     inherits <- base::inherits
[13:21:47.314]                     invokeRestart <- base::invokeRestart
[13:21:47.314]                     is.null <- base::is.null
[13:21:47.314]                     muffled <- FALSE
[13:21:47.314]                     if (inherits(cond, "message")) {
[13:21:47.314]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:47.314]                       if (muffled) 
[13:21:47.314]                         invokeRestart("muffleMessage")
[13:21:47.314]                     }
[13:21:47.314]                     else if (inherits(cond, "warning")) {
[13:21:47.314]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:47.314]                       if (muffled) 
[13:21:47.314]                         invokeRestart("muffleWarning")
[13:21:47.314]                     }
[13:21:47.314]                     else if (inherits(cond, "condition")) {
[13:21:47.314]                       if (!is.null(pattern)) {
[13:21:47.314]                         computeRestarts <- base::computeRestarts
[13:21:47.314]                         grepl <- base::grepl
[13:21:47.314]                         restarts <- computeRestarts(cond)
[13:21:47.314]                         for (restart in restarts) {
[13:21:47.314]                           name <- restart$name
[13:21:47.314]                           if (is.null(name)) 
[13:21:47.314]                             next
[13:21:47.314]                           if (!grepl(pattern, name)) 
[13:21:47.314]                             next
[13:21:47.314]                           invokeRestart(restart)
[13:21:47.314]                           muffled <- TRUE
[13:21:47.314]                           break
[13:21:47.314]                         }
[13:21:47.314]                       }
[13:21:47.314]                     }
[13:21:47.314]                     invisible(muffled)
[13:21:47.314]                   }
[13:21:47.314]                   muffleCondition(cond)
[13:21:47.314]                 })
[13:21:47.314]             }))
[13:21:47.314]             future::FutureResult(value = ...future.value$value, 
[13:21:47.314]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:47.314]                   ...future.rng), globalenv = if (FALSE) 
[13:21:47.314]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:47.314]                     ...future.globalenv.names))
[13:21:47.314]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:47.314]         }, condition = base::local({
[13:21:47.314]             c <- base::c
[13:21:47.314]             inherits <- base::inherits
[13:21:47.314]             invokeRestart <- base::invokeRestart
[13:21:47.314]             length <- base::length
[13:21:47.314]             list <- base::list
[13:21:47.314]             seq.int <- base::seq.int
[13:21:47.314]             signalCondition <- base::signalCondition
[13:21:47.314]             sys.calls <- base::sys.calls
[13:21:47.314]             `[[` <- base::`[[`
[13:21:47.314]             `+` <- base::`+`
[13:21:47.314]             `<<-` <- base::`<<-`
[13:21:47.314]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:47.314]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:47.314]                   3L)]
[13:21:47.314]             }
[13:21:47.314]             function(cond) {
[13:21:47.314]                 is_error <- inherits(cond, "error")
[13:21:47.314]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:47.314]                   NULL)
[13:21:47.314]                 if (is_error) {
[13:21:47.314]                   sessionInformation <- function() {
[13:21:47.314]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:47.314]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:47.314]                       search = base::search(), system = base::Sys.info())
[13:21:47.314]                   }
[13:21:47.314]                   ...future.conditions[[length(...future.conditions) + 
[13:21:47.314]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:47.314]                     cond$call), session = sessionInformation(), 
[13:21:47.314]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:47.314]                   signalCondition(cond)
[13:21:47.314]                 }
[13:21:47.314]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:47.314]                 "immediateCondition"))) {
[13:21:47.314]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:47.314]                   ...future.conditions[[length(...future.conditions) + 
[13:21:47.314]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:47.314]                   if (TRUE && !signal) {
[13:21:47.314]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:47.314]                     {
[13:21:47.314]                       inherits <- base::inherits
[13:21:47.314]                       invokeRestart <- base::invokeRestart
[13:21:47.314]                       is.null <- base::is.null
[13:21:47.314]                       muffled <- FALSE
[13:21:47.314]                       if (inherits(cond, "message")) {
[13:21:47.314]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:47.314]                         if (muffled) 
[13:21:47.314]                           invokeRestart("muffleMessage")
[13:21:47.314]                       }
[13:21:47.314]                       else if (inherits(cond, "warning")) {
[13:21:47.314]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:47.314]                         if (muffled) 
[13:21:47.314]                           invokeRestart("muffleWarning")
[13:21:47.314]                       }
[13:21:47.314]                       else if (inherits(cond, "condition")) {
[13:21:47.314]                         if (!is.null(pattern)) {
[13:21:47.314]                           computeRestarts <- base::computeRestarts
[13:21:47.314]                           grepl <- base::grepl
[13:21:47.314]                           restarts <- computeRestarts(cond)
[13:21:47.314]                           for (restart in restarts) {
[13:21:47.314]                             name <- restart$name
[13:21:47.314]                             if (is.null(name)) 
[13:21:47.314]                               next
[13:21:47.314]                             if (!grepl(pattern, name)) 
[13:21:47.314]                               next
[13:21:47.314]                             invokeRestart(restart)
[13:21:47.314]                             muffled <- TRUE
[13:21:47.314]                             break
[13:21:47.314]                           }
[13:21:47.314]                         }
[13:21:47.314]                       }
[13:21:47.314]                       invisible(muffled)
[13:21:47.314]                     }
[13:21:47.314]                     muffleCondition(cond, pattern = "^muffle")
[13:21:47.314]                   }
[13:21:47.314]                 }
[13:21:47.314]                 else {
[13:21:47.314]                   if (TRUE) {
[13:21:47.314]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:47.314]                     {
[13:21:47.314]                       inherits <- base::inherits
[13:21:47.314]                       invokeRestart <- base::invokeRestart
[13:21:47.314]                       is.null <- base::is.null
[13:21:47.314]                       muffled <- FALSE
[13:21:47.314]                       if (inherits(cond, "message")) {
[13:21:47.314]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:47.314]                         if (muffled) 
[13:21:47.314]                           invokeRestart("muffleMessage")
[13:21:47.314]                       }
[13:21:47.314]                       else if (inherits(cond, "warning")) {
[13:21:47.314]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:47.314]                         if (muffled) 
[13:21:47.314]                           invokeRestart("muffleWarning")
[13:21:47.314]                       }
[13:21:47.314]                       else if (inherits(cond, "condition")) {
[13:21:47.314]                         if (!is.null(pattern)) {
[13:21:47.314]                           computeRestarts <- base::computeRestarts
[13:21:47.314]                           grepl <- base::grepl
[13:21:47.314]                           restarts <- computeRestarts(cond)
[13:21:47.314]                           for (restart in restarts) {
[13:21:47.314]                             name <- restart$name
[13:21:47.314]                             if (is.null(name)) 
[13:21:47.314]                               next
[13:21:47.314]                             if (!grepl(pattern, name)) 
[13:21:47.314]                               next
[13:21:47.314]                             invokeRestart(restart)
[13:21:47.314]                             muffled <- TRUE
[13:21:47.314]                             break
[13:21:47.314]                           }
[13:21:47.314]                         }
[13:21:47.314]                       }
[13:21:47.314]                       invisible(muffled)
[13:21:47.314]                     }
[13:21:47.314]                     muffleCondition(cond, pattern = "^muffle")
[13:21:47.314]                   }
[13:21:47.314]                 }
[13:21:47.314]             }
[13:21:47.314]         }))
[13:21:47.314]     }, error = function(ex) {
[13:21:47.314]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:47.314]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:47.314]                 ...future.rng), started = ...future.startTime, 
[13:21:47.314]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:47.314]             version = "1.8"), class = "FutureResult")
[13:21:47.314]     }, finally = {
[13:21:47.314]         if (!identical(...future.workdir, getwd())) 
[13:21:47.314]             setwd(...future.workdir)
[13:21:47.314]         {
[13:21:47.314]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:47.314]                 ...future.oldOptions$nwarnings <- NULL
[13:21:47.314]             }
[13:21:47.314]             base::options(...future.oldOptions)
[13:21:47.314]             if (.Platform$OS.type == "windows") {
[13:21:47.314]                 old_names <- names(...future.oldEnvVars)
[13:21:47.314]                 envs <- base::Sys.getenv()
[13:21:47.314]                 names <- names(envs)
[13:21:47.314]                 common <- intersect(names, old_names)
[13:21:47.314]                 added <- setdiff(names, old_names)
[13:21:47.314]                 removed <- setdiff(old_names, names)
[13:21:47.314]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:47.314]                   envs[common]]
[13:21:47.314]                 NAMES <- toupper(changed)
[13:21:47.314]                 args <- list()
[13:21:47.314]                 for (kk in seq_along(NAMES)) {
[13:21:47.314]                   name <- changed[[kk]]
[13:21:47.314]                   NAME <- NAMES[[kk]]
[13:21:47.314]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:47.314]                     next
[13:21:47.314]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:47.314]                 }
[13:21:47.314]                 NAMES <- toupper(added)
[13:21:47.314]                 for (kk in seq_along(NAMES)) {
[13:21:47.314]                   name <- added[[kk]]
[13:21:47.314]                   NAME <- NAMES[[kk]]
[13:21:47.314]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:47.314]                     next
[13:21:47.314]                   args[[name]] <- ""
[13:21:47.314]                 }
[13:21:47.314]                 NAMES <- toupper(removed)
[13:21:47.314]                 for (kk in seq_along(NAMES)) {
[13:21:47.314]                   name <- removed[[kk]]
[13:21:47.314]                   NAME <- NAMES[[kk]]
[13:21:47.314]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:47.314]                     next
[13:21:47.314]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:47.314]                 }
[13:21:47.314]                 if (length(args) > 0) 
[13:21:47.314]                   base::do.call(base::Sys.setenv, args = args)
[13:21:47.314]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:47.314]             }
[13:21:47.314]             else {
[13:21:47.314]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:47.314]             }
[13:21:47.314]             {
[13:21:47.314]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:47.314]                   0L) {
[13:21:47.314]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:47.314]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:47.314]                   base::options(opts)
[13:21:47.314]                 }
[13:21:47.314]                 {
[13:21:47.314]                   {
[13:21:47.314]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:47.314]                     NULL
[13:21:47.314]                   }
[13:21:47.314]                   options(future.plan = NULL)
[13:21:47.314]                   if (is.na(NA_character_)) 
[13:21:47.314]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:47.314]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:47.314]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:47.314]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:47.314]                     envir = parent.frame()) 
[13:21:47.314]                   {
[13:21:47.314]                     if (is.function(workers)) 
[13:21:47.314]                       workers <- workers()
[13:21:47.314]                     workers <- structure(as.integer(workers), 
[13:21:47.314]                       class = class(workers))
[13:21:47.314]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:47.314]                       workers >= 1)
[13:21:47.314]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:47.314]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:47.314]                     }
[13:21:47.314]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:47.314]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:47.314]                       envir = envir)
[13:21:47.314]                     if (!future$lazy) 
[13:21:47.314]                       future <- run(future)
[13:21:47.314]                     invisible(future)
[13:21:47.314]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:47.314]                 }
[13:21:47.314]             }
[13:21:47.314]         }
[13:21:47.314]     })
[13:21:47.314]     if (TRUE) {
[13:21:47.314]         base::sink(type = "output", split = FALSE)
[13:21:47.314]         if (TRUE) {
[13:21:47.314]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:47.314]         }
[13:21:47.314]         else {
[13:21:47.314]             ...future.result["stdout"] <- base::list(NULL)
[13:21:47.314]         }
[13:21:47.314]         base::close(...future.stdout)
[13:21:47.314]         ...future.stdout <- NULL
[13:21:47.314]     }
[13:21:47.314]     ...future.result$conditions <- ...future.conditions
[13:21:47.314]     ...future.result$finished <- base::Sys.time()
[13:21:47.314]     ...future.result
[13:21:47.314] }
[13:21:47.317] MultisessionFuture started
[13:21:47.317] - Launch lazy future ... done
[13:21:47.318] run() for ‘MultisessionFuture’ ... done
[13:21:47.875] receiveMessageFromWorker() for ClusterFuture ...
[13:21:47.875] - Validating connection of MultisessionFuture
[13:21:47.876] - received message: FutureResult
[13:21:47.876] - Received FutureResult
[13:21:47.876] - Erased future from FutureRegistry
[13:21:47.876] result() for ClusterFuture ...
[13:21:47.876] - result already collected: FutureResult
[13:21:47.876] result() for ClusterFuture ... done
[13:21:47.877] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:47.877] A MultisessionFuture was resolved (result was not collected)
[13:21:47.877] getGlobalsAndPackages() ...
[13:21:47.877] Searching for globals...
[13:21:47.878] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:21:47.878] Searching for globals ... DONE
[13:21:47.878] Resolving globals: FALSE
[13:21:47.879] 
[13:21:47.879] 
[13:21:47.879] getGlobalsAndPackages() ... DONE
[13:21:47.879] run() for ‘Future’ ...
[13:21:47.879] - state: ‘created’
[13:21:47.879] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:47.893] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:47.894] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:47.894]   - Field: ‘node’
[13:21:47.894]   - Field: ‘label’
[13:21:47.894]   - Field: ‘local’
[13:21:47.894]   - Field: ‘owner’
[13:21:47.894]   - Field: ‘envir’
[13:21:47.894]   - Field: ‘workers’
[13:21:47.894]   - Field: ‘packages’
[13:21:47.894]   - Field: ‘gc’
[13:21:47.894]   - Field: ‘conditions’
[13:21:47.894]   - Field: ‘persistent’
[13:21:47.895]   - Field: ‘expr’
[13:21:47.895]   - Field: ‘uuid’
[13:21:47.895]   - Field: ‘seed’
[13:21:47.895]   - Field: ‘version’
[13:21:47.895]   - Field: ‘result’
[13:21:47.895]   - Field: ‘asynchronous’
[13:21:47.895]   - Field: ‘calls’
[13:21:47.895]   - Field: ‘globals’
[13:21:47.895]   - Field: ‘stdout’
[13:21:47.895]   - Field: ‘earlySignal’
[13:21:47.895]   - Field: ‘lazy’
[13:21:47.896]   - Field: ‘state’
[13:21:47.896] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:47.896] - Launch lazy future ...
[13:21:47.896] Packages needed by the future expression (n = 0): <none>
[13:21:47.896] Packages needed by future strategies (n = 0): <none>
[13:21:47.897] {
[13:21:47.897]     {
[13:21:47.897]         {
[13:21:47.897]             ...future.startTime <- base::Sys.time()
[13:21:47.897]             {
[13:21:47.897]                 {
[13:21:47.897]                   {
[13:21:47.897]                     {
[13:21:47.897]                       base::local({
[13:21:47.897]                         has_future <- base::requireNamespace("future", 
[13:21:47.897]                           quietly = TRUE)
[13:21:47.897]                         if (has_future) {
[13:21:47.897]                           ns <- base::getNamespace("future")
[13:21:47.897]                           version <- ns[[".package"]][["version"]]
[13:21:47.897]                           if (is.null(version)) 
[13:21:47.897]                             version <- utils::packageVersion("future")
[13:21:47.897]                         }
[13:21:47.897]                         else {
[13:21:47.897]                           version <- NULL
[13:21:47.897]                         }
[13:21:47.897]                         if (!has_future || version < "1.8.0") {
[13:21:47.897]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:47.897]                             "", base::R.version$version.string), 
[13:21:47.897]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:47.897]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:47.897]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:47.897]                               "release", "version")], collapse = " "), 
[13:21:47.897]                             hostname = base::Sys.info()[["nodename"]])
[13:21:47.897]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:47.897]                             info)
[13:21:47.897]                           info <- base::paste(info, collapse = "; ")
[13:21:47.897]                           if (!has_future) {
[13:21:47.897]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:47.897]                               info)
[13:21:47.897]                           }
[13:21:47.897]                           else {
[13:21:47.897]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:47.897]                               info, version)
[13:21:47.897]                           }
[13:21:47.897]                           base::stop(msg)
[13:21:47.897]                         }
[13:21:47.897]                       })
[13:21:47.897]                     }
[13:21:47.897]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:47.897]                     base::options(mc.cores = 1L)
[13:21:47.897]                   }
[13:21:47.897]                   options(future.plan = NULL)
[13:21:47.897]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:47.897]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:47.897]                 }
[13:21:47.897]                 ...future.workdir <- getwd()
[13:21:47.897]             }
[13:21:47.897]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:47.897]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:47.897]         }
[13:21:47.897]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:47.897]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:47.897]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:47.897]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:47.897]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:47.897]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:47.897]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:47.897]             base::names(...future.oldOptions))
[13:21:47.897]     }
[13:21:47.897]     if (FALSE) {
[13:21:47.897]     }
[13:21:47.897]     else {
[13:21:47.897]         if (TRUE) {
[13:21:47.897]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:47.897]                 open = "w")
[13:21:47.897]         }
[13:21:47.897]         else {
[13:21:47.897]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:47.897]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:47.897]         }
[13:21:47.897]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:47.897]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:47.897]             base::sink(type = "output", split = FALSE)
[13:21:47.897]             base::close(...future.stdout)
[13:21:47.897]         }, add = TRUE)
[13:21:47.897]     }
[13:21:47.897]     ...future.frame <- base::sys.nframe()
[13:21:47.897]     ...future.conditions <- base::list()
[13:21:47.897]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:47.897]     if (FALSE) {
[13:21:47.897]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:47.897]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:47.897]     }
[13:21:47.897]     ...future.result <- base::tryCatch({
[13:21:47.897]         base::withCallingHandlers({
[13:21:47.897]             ...future.value <- base::withVisible(base::local({
[13:21:47.897]                 ...future.makeSendCondition <- local({
[13:21:47.897]                   sendCondition <- NULL
[13:21:47.897]                   function(frame = 1L) {
[13:21:47.897]                     if (is.function(sendCondition)) 
[13:21:47.897]                       return(sendCondition)
[13:21:47.897]                     ns <- getNamespace("parallel")
[13:21:47.897]                     if (exists("sendData", mode = "function", 
[13:21:47.897]                       envir = ns)) {
[13:21:47.897]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:47.897]                         envir = ns)
[13:21:47.897]                       envir <- sys.frame(frame)
[13:21:47.897]                       master <- NULL
[13:21:47.897]                       while (!identical(envir, .GlobalEnv) && 
[13:21:47.897]                         !identical(envir, emptyenv())) {
[13:21:47.897]                         if (exists("master", mode = "list", envir = envir, 
[13:21:47.897]                           inherits = FALSE)) {
[13:21:47.897]                           master <- get("master", mode = "list", 
[13:21:47.897]                             envir = envir, inherits = FALSE)
[13:21:47.897]                           if (inherits(master, c("SOCKnode", 
[13:21:47.897]                             "SOCK0node"))) {
[13:21:47.897]                             sendCondition <<- function(cond) {
[13:21:47.897]                               data <- list(type = "VALUE", value = cond, 
[13:21:47.897]                                 success = TRUE)
[13:21:47.897]                               parallel_sendData(master, data)
[13:21:47.897]                             }
[13:21:47.897]                             return(sendCondition)
[13:21:47.897]                           }
[13:21:47.897]                         }
[13:21:47.897]                         frame <- frame + 1L
[13:21:47.897]                         envir <- sys.frame(frame)
[13:21:47.897]                       }
[13:21:47.897]                     }
[13:21:47.897]                     sendCondition <<- function(cond) NULL
[13:21:47.897]                   }
[13:21:47.897]                 })
[13:21:47.897]                 withCallingHandlers({
[13:21:47.897]                   {
[13:21:47.897]                     Sys.sleep(0.5)
[13:21:47.897]                     list(a = 1, b = 42L)
[13:21:47.897]                   }
[13:21:47.897]                 }, immediateCondition = function(cond) {
[13:21:47.897]                   sendCondition <- ...future.makeSendCondition()
[13:21:47.897]                   sendCondition(cond)
[13:21:47.897]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:47.897]                   {
[13:21:47.897]                     inherits <- base::inherits
[13:21:47.897]                     invokeRestart <- base::invokeRestart
[13:21:47.897]                     is.null <- base::is.null
[13:21:47.897]                     muffled <- FALSE
[13:21:47.897]                     if (inherits(cond, "message")) {
[13:21:47.897]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:47.897]                       if (muffled) 
[13:21:47.897]                         invokeRestart("muffleMessage")
[13:21:47.897]                     }
[13:21:47.897]                     else if (inherits(cond, "warning")) {
[13:21:47.897]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:47.897]                       if (muffled) 
[13:21:47.897]                         invokeRestart("muffleWarning")
[13:21:47.897]                     }
[13:21:47.897]                     else if (inherits(cond, "condition")) {
[13:21:47.897]                       if (!is.null(pattern)) {
[13:21:47.897]                         computeRestarts <- base::computeRestarts
[13:21:47.897]                         grepl <- base::grepl
[13:21:47.897]                         restarts <- computeRestarts(cond)
[13:21:47.897]                         for (restart in restarts) {
[13:21:47.897]                           name <- restart$name
[13:21:47.897]                           if (is.null(name)) 
[13:21:47.897]                             next
[13:21:47.897]                           if (!grepl(pattern, name)) 
[13:21:47.897]                             next
[13:21:47.897]                           invokeRestart(restart)
[13:21:47.897]                           muffled <- TRUE
[13:21:47.897]                           break
[13:21:47.897]                         }
[13:21:47.897]                       }
[13:21:47.897]                     }
[13:21:47.897]                     invisible(muffled)
[13:21:47.897]                   }
[13:21:47.897]                   muffleCondition(cond)
[13:21:47.897]                 })
[13:21:47.897]             }))
[13:21:47.897]             future::FutureResult(value = ...future.value$value, 
[13:21:47.897]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:47.897]                   ...future.rng), globalenv = if (FALSE) 
[13:21:47.897]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:47.897]                     ...future.globalenv.names))
[13:21:47.897]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:47.897]         }, condition = base::local({
[13:21:47.897]             c <- base::c
[13:21:47.897]             inherits <- base::inherits
[13:21:47.897]             invokeRestart <- base::invokeRestart
[13:21:47.897]             length <- base::length
[13:21:47.897]             list <- base::list
[13:21:47.897]             seq.int <- base::seq.int
[13:21:47.897]             signalCondition <- base::signalCondition
[13:21:47.897]             sys.calls <- base::sys.calls
[13:21:47.897]             `[[` <- base::`[[`
[13:21:47.897]             `+` <- base::`+`
[13:21:47.897]             `<<-` <- base::`<<-`
[13:21:47.897]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:47.897]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:47.897]                   3L)]
[13:21:47.897]             }
[13:21:47.897]             function(cond) {
[13:21:47.897]                 is_error <- inherits(cond, "error")
[13:21:47.897]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:47.897]                   NULL)
[13:21:47.897]                 if (is_error) {
[13:21:47.897]                   sessionInformation <- function() {
[13:21:47.897]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:47.897]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:47.897]                       search = base::search(), system = base::Sys.info())
[13:21:47.897]                   }
[13:21:47.897]                   ...future.conditions[[length(...future.conditions) + 
[13:21:47.897]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:47.897]                     cond$call), session = sessionInformation(), 
[13:21:47.897]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:47.897]                   signalCondition(cond)
[13:21:47.897]                 }
[13:21:47.897]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:47.897]                 "immediateCondition"))) {
[13:21:47.897]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:47.897]                   ...future.conditions[[length(...future.conditions) + 
[13:21:47.897]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:47.897]                   if (TRUE && !signal) {
[13:21:47.897]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:47.897]                     {
[13:21:47.897]                       inherits <- base::inherits
[13:21:47.897]                       invokeRestart <- base::invokeRestart
[13:21:47.897]                       is.null <- base::is.null
[13:21:47.897]                       muffled <- FALSE
[13:21:47.897]                       if (inherits(cond, "message")) {
[13:21:47.897]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:47.897]                         if (muffled) 
[13:21:47.897]                           invokeRestart("muffleMessage")
[13:21:47.897]                       }
[13:21:47.897]                       else if (inherits(cond, "warning")) {
[13:21:47.897]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:47.897]                         if (muffled) 
[13:21:47.897]                           invokeRestart("muffleWarning")
[13:21:47.897]                       }
[13:21:47.897]                       else if (inherits(cond, "condition")) {
[13:21:47.897]                         if (!is.null(pattern)) {
[13:21:47.897]                           computeRestarts <- base::computeRestarts
[13:21:47.897]                           grepl <- base::grepl
[13:21:47.897]                           restarts <- computeRestarts(cond)
[13:21:47.897]                           for (restart in restarts) {
[13:21:47.897]                             name <- restart$name
[13:21:47.897]                             if (is.null(name)) 
[13:21:47.897]                               next
[13:21:47.897]                             if (!grepl(pattern, name)) 
[13:21:47.897]                               next
[13:21:47.897]                             invokeRestart(restart)
[13:21:47.897]                             muffled <- TRUE
[13:21:47.897]                             break
[13:21:47.897]                           }
[13:21:47.897]                         }
[13:21:47.897]                       }
[13:21:47.897]                       invisible(muffled)
[13:21:47.897]                     }
[13:21:47.897]                     muffleCondition(cond, pattern = "^muffle")
[13:21:47.897]                   }
[13:21:47.897]                 }
[13:21:47.897]                 else {
[13:21:47.897]                   if (TRUE) {
[13:21:47.897]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:47.897]                     {
[13:21:47.897]                       inherits <- base::inherits
[13:21:47.897]                       invokeRestart <- base::invokeRestart
[13:21:47.897]                       is.null <- base::is.null
[13:21:47.897]                       muffled <- FALSE
[13:21:47.897]                       if (inherits(cond, "message")) {
[13:21:47.897]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:47.897]                         if (muffled) 
[13:21:47.897]                           invokeRestart("muffleMessage")
[13:21:47.897]                       }
[13:21:47.897]                       else if (inherits(cond, "warning")) {
[13:21:47.897]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:47.897]                         if (muffled) 
[13:21:47.897]                           invokeRestart("muffleWarning")
[13:21:47.897]                       }
[13:21:47.897]                       else if (inherits(cond, "condition")) {
[13:21:47.897]                         if (!is.null(pattern)) {
[13:21:47.897]                           computeRestarts <- base::computeRestarts
[13:21:47.897]                           grepl <- base::grepl
[13:21:47.897]                           restarts <- computeRestarts(cond)
[13:21:47.897]                           for (restart in restarts) {
[13:21:47.897]                             name <- restart$name
[13:21:47.897]                             if (is.null(name)) 
[13:21:47.897]                               next
[13:21:47.897]                             if (!grepl(pattern, name)) 
[13:21:47.897]                               next
[13:21:47.897]                             invokeRestart(restart)
[13:21:47.897]                             muffled <- TRUE
[13:21:47.897]                             break
[13:21:47.897]                           }
[13:21:47.897]                         }
[13:21:47.897]                       }
[13:21:47.897]                       invisible(muffled)
[13:21:47.897]                     }
[13:21:47.897]                     muffleCondition(cond, pattern = "^muffle")
[13:21:47.897]                   }
[13:21:47.897]                 }
[13:21:47.897]             }
[13:21:47.897]         }))
[13:21:47.897]     }, error = function(ex) {
[13:21:47.897]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:47.897]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:47.897]                 ...future.rng), started = ...future.startTime, 
[13:21:47.897]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:47.897]             version = "1.8"), class = "FutureResult")
[13:21:47.897]     }, finally = {
[13:21:47.897]         if (!identical(...future.workdir, getwd())) 
[13:21:47.897]             setwd(...future.workdir)
[13:21:47.897]         {
[13:21:47.897]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:47.897]                 ...future.oldOptions$nwarnings <- NULL
[13:21:47.897]             }
[13:21:47.897]             base::options(...future.oldOptions)
[13:21:47.897]             if (.Platform$OS.type == "windows") {
[13:21:47.897]                 old_names <- names(...future.oldEnvVars)
[13:21:47.897]                 envs <- base::Sys.getenv()
[13:21:47.897]                 names <- names(envs)
[13:21:47.897]                 common <- intersect(names, old_names)
[13:21:47.897]                 added <- setdiff(names, old_names)
[13:21:47.897]                 removed <- setdiff(old_names, names)
[13:21:47.897]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:47.897]                   envs[common]]
[13:21:47.897]                 NAMES <- toupper(changed)
[13:21:47.897]                 args <- list()
[13:21:47.897]                 for (kk in seq_along(NAMES)) {
[13:21:47.897]                   name <- changed[[kk]]
[13:21:47.897]                   NAME <- NAMES[[kk]]
[13:21:47.897]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:47.897]                     next
[13:21:47.897]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:47.897]                 }
[13:21:47.897]                 NAMES <- toupper(added)
[13:21:47.897]                 for (kk in seq_along(NAMES)) {
[13:21:47.897]                   name <- added[[kk]]
[13:21:47.897]                   NAME <- NAMES[[kk]]
[13:21:47.897]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:47.897]                     next
[13:21:47.897]                   args[[name]] <- ""
[13:21:47.897]                 }
[13:21:47.897]                 NAMES <- toupper(removed)
[13:21:47.897]                 for (kk in seq_along(NAMES)) {
[13:21:47.897]                   name <- removed[[kk]]
[13:21:47.897]                   NAME <- NAMES[[kk]]
[13:21:47.897]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:47.897]                     next
[13:21:47.897]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:47.897]                 }
[13:21:47.897]                 if (length(args) > 0) 
[13:21:47.897]                   base::do.call(base::Sys.setenv, args = args)
[13:21:47.897]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:47.897]             }
[13:21:47.897]             else {
[13:21:47.897]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:47.897]             }
[13:21:47.897]             {
[13:21:47.897]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:47.897]                   0L) {
[13:21:47.897]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:47.897]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:47.897]                   base::options(opts)
[13:21:47.897]                 }
[13:21:47.897]                 {
[13:21:47.897]                   {
[13:21:47.897]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:47.897]                     NULL
[13:21:47.897]                   }
[13:21:47.897]                   options(future.plan = NULL)
[13:21:47.897]                   if (is.na(NA_character_)) 
[13:21:47.897]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:47.897]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:47.897]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:47.897]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:47.897]                     envir = parent.frame()) 
[13:21:47.897]                   {
[13:21:47.897]                     if (is.function(workers)) 
[13:21:47.897]                       workers <- workers()
[13:21:47.897]                     workers <- structure(as.integer(workers), 
[13:21:47.897]                       class = class(workers))
[13:21:47.897]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:47.897]                       workers >= 1)
[13:21:47.897]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:47.897]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:47.897]                     }
[13:21:47.897]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:47.897]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:47.897]                       envir = envir)
[13:21:47.897]                     if (!future$lazy) 
[13:21:47.897]                       future <- run(future)
[13:21:47.897]                     invisible(future)
[13:21:47.897]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:47.897]                 }
[13:21:47.897]             }
[13:21:47.897]         }
[13:21:47.897]     })
[13:21:47.897]     if (TRUE) {
[13:21:47.897]         base::sink(type = "output", split = FALSE)
[13:21:47.897]         if (TRUE) {
[13:21:47.897]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:47.897]         }
[13:21:47.897]         else {
[13:21:47.897]             ...future.result["stdout"] <- base::list(NULL)
[13:21:47.897]         }
[13:21:47.897]         base::close(...future.stdout)
[13:21:47.897]         ...future.stdout <- NULL
[13:21:47.897]     }
[13:21:47.897]     ...future.result$conditions <- ...future.conditions
[13:21:47.897]     ...future.result$finished <- base::Sys.time()
[13:21:47.897]     ...future.result
[13:21:47.897] }
[13:21:47.900] MultisessionFuture started
[13:21:47.900] - Launch lazy future ... done
[13:21:47.900] run() for ‘MultisessionFuture’ ... done
[13:21:48.447] receiveMessageFromWorker() for ClusterFuture ...
[13:21:48.447] - Validating connection of MultisessionFuture
[13:21:48.447] - received message: FutureResult
[13:21:48.447] - Received FutureResult
[13:21:48.447] - Erased future from FutureRegistry
[13:21:48.447] result() for ClusterFuture ...
[13:21:48.448] - result already collected: FutureResult
[13:21:48.448] result() for ClusterFuture ... done
[13:21:48.448] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:48.448] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[13:21:48.448] getGlobalsAndPackages() ...
[13:21:48.448] Searching for globals...
[13:21:48.449] - globals found: [2] ‘list’, ‘stop’
[13:21:48.449] Searching for globals ... DONE
[13:21:48.449] Resolving globals: FALSE
[13:21:48.449] 
[13:21:48.449] 
[13:21:48.449] getGlobalsAndPackages() ... DONE
[13:21:48.450] run() for ‘Future’ ...
[13:21:48.450] - state: ‘created’
[13:21:48.450] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:48.464] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:48.464] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:48.465]   - Field: ‘node’
[13:21:48.465]   - Field: ‘label’
[13:21:48.465]   - Field: ‘local’
[13:21:48.465]   - Field: ‘owner’
[13:21:48.465]   - Field: ‘envir’
[13:21:48.465]   - Field: ‘workers’
[13:21:48.465]   - Field: ‘packages’
[13:21:48.465]   - Field: ‘gc’
[13:21:48.465]   - Field: ‘conditions’
[13:21:48.465]   - Field: ‘persistent’
[13:21:48.466]   - Field: ‘expr’
[13:21:48.466]   - Field: ‘uuid’
[13:21:48.466]   - Field: ‘seed’
[13:21:48.466]   - Field: ‘version’
[13:21:48.466]   - Field: ‘result’
[13:21:48.466]   - Field: ‘asynchronous’
[13:21:48.466]   - Field: ‘calls’
[13:21:48.466]   - Field: ‘globals’
[13:21:48.466]   - Field: ‘stdout’
[13:21:48.466]   - Field: ‘earlySignal’
[13:21:48.466]   - Field: ‘lazy’
[13:21:48.467]   - Field: ‘state’
[13:21:48.467] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:48.467] - Launch lazy future ...
[13:21:48.467] Packages needed by the future expression (n = 0): <none>
[13:21:48.467] Packages needed by future strategies (n = 0): <none>
[13:21:48.468] {
[13:21:48.468]     {
[13:21:48.468]         {
[13:21:48.468]             ...future.startTime <- base::Sys.time()
[13:21:48.468]             {
[13:21:48.468]                 {
[13:21:48.468]                   {
[13:21:48.468]                     {
[13:21:48.468]                       base::local({
[13:21:48.468]                         has_future <- base::requireNamespace("future", 
[13:21:48.468]                           quietly = TRUE)
[13:21:48.468]                         if (has_future) {
[13:21:48.468]                           ns <- base::getNamespace("future")
[13:21:48.468]                           version <- ns[[".package"]][["version"]]
[13:21:48.468]                           if (is.null(version)) 
[13:21:48.468]                             version <- utils::packageVersion("future")
[13:21:48.468]                         }
[13:21:48.468]                         else {
[13:21:48.468]                           version <- NULL
[13:21:48.468]                         }
[13:21:48.468]                         if (!has_future || version < "1.8.0") {
[13:21:48.468]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:48.468]                             "", base::R.version$version.string), 
[13:21:48.468]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:48.468]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:48.468]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:48.468]                               "release", "version")], collapse = " "), 
[13:21:48.468]                             hostname = base::Sys.info()[["nodename"]])
[13:21:48.468]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:48.468]                             info)
[13:21:48.468]                           info <- base::paste(info, collapse = "; ")
[13:21:48.468]                           if (!has_future) {
[13:21:48.468]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:48.468]                               info)
[13:21:48.468]                           }
[13:21:48.468]                           else {
[13:21:48.468]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:48.468]                               info, version)
[13:21:48.468]                           }
[13:21:48.468]                           base::stop(msg)
[13:21:48.468]                         }
[13:21:48.468]                       })
[13:21:48.468]                     }
[13:21:48.468]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:48.468]                     base::options(mc.cores = 1L)
[13:21:48.468]                   }
[13:21:48.468]                   options(future.plan = NULL)
[13:21:48.468]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:48.468]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:48.468]                 }
[13:21:48.468]                 ...future.workdir <- getwd()
[13:21:48.468]             }
[13:21:48.468]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:48.468]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:48.468]         }
[13:21:48.468]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:48.468]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:48.468]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:48.468]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:48.468]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:48.468]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:48.468]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:48.468]             base::names(...future.oldOptions))
[13:21:48.468]     }
[13:21:48.468]     if (FALSE) {
[13:21:48.468]     }
[13:21:48.468]     else {
[13:21:48.468]         if (TRUE) {
[13:21:48.468]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:48.468]                 open = "w")
[13:21:48.468]         }
[13:21:48.468]         else {
[13:21:48.468]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:48.468]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:48.468]         }
[13:21:48.468]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:48.468]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:48.468]             base::sink(type = "output", split = FALSE)
[13:21:48.468]             base::close(...future.stdout)
[13:21:48.468]         }, add = TRUE)
[13:21:48.468]     }
[13:21:48.468]     ...future.frame <- base::sys.nframe()
[13:21:48.468]     ...future.conditions <- base::list()
[13:21:48.468]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:48.468]     if (FALSE) {
[13:21:48.468]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:48.468]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:48.468]     }
[13:21:48.468]     ...future.result <- base::tryCatch({
[13:21:48.468]         base::withCallingHandlers({
[13:21:48.468]             ...future.value <- base::withVisible(base::local({
[13:21:48.468]                 ...future.makeSendCondition <- local({
[13:21:48.468]                   sendCondition <- NULL
[13:21:48.468]                   function(frame = 1L) {
[13:21:48.468]                     if (is.function(sendCondition)) 
[13:21:48.468]                       return(sendCondition)
[13:21:48.468]                     ns <- getNamespace("parallel")
[13:21:48.468]                     if (exists("sendData", mode = "function", 
[13:21:48.468]                       envir = ns)) {
[13:21:48.468]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:48.468]                         envir = ns)
[13:21:48.468]                       envir <- sys.frame(frame)
[13:21:48.468]                       master <- NULL
[13:21:48.468]                       while (!identical(envir, .GlobalEnv) && 
[13:21:48.468]                         !identical(envir, emptyenv())) {
[13:21:48.468]                         if (exists("master", mode = "list", envir = envir, 
[13:21:48.468]                           inherits = FALSE)) {
[13:21:48.468]                           master <- get("master", mode = "list", 
[13:21:48.468]                             envir = envir, inherits = FALSE)
[13:21:48.468]                           if (inherits(master, c("SOCKnode", 
[13:21:48.468]                             "SOCK0node"))) {
[13:21:48.468]                             sendCondition <<- function(cond) {
[13:21:48.468]                               data <- list(type = "VALUE", value = cond, 
[13:21:48.468]                                 success = TRUE)
[13:21:48.468]                               parallel_sendData(master, data)
[13:21:48.468]                             }
[13:21:48.468]                             return(sendCondition)
[13:21:48.468]                           }
[13:21:48.468]                         }
[13:21:48.468]                         frame <- frame + 1L
[13:21:48.468]                         envir <- sys.frame(frame)
[13:21:48.468]                       }
[13:21:48.468]                     }
[13:21:48.468]                     sendCondition <<- function(cond) NULL
[13:21:48.468]                   }
[13:21:48.468]                 })
[13:21:48.468]                 withCallingHandlers({
[13:21:48.468]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:21:48.468]                 }, immediateCondition = function(cond) {
[13:21:48.468]                   sendCondition <- ...future.makeSendCondition()
[13:21:48.468]                   sendCondition(cond)
[13:21:48.468]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:48.468]                   {
[13:21:48.468]                     inherits <- base::inherits
[13:21:48.468]                     invokeRestart <- base::invokeRestart
[13:21:48.468]                     is.null <- base::is.null
[13:21:48.468]                     muffled <- FALSE
[13:21:48.468]                     if (inherits(cond, "message")) {
[13:21:48.468]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:48.468]                       if (muffled) 
[13:21:48.468]                         invokeRestart("muffleMessage")
[13:21:48.468]                     }
[13:21:48.468]                     else if (inherits(cond, "warning")) {
[13:21:48.468]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:48.468]                       if (muffled) 
[13:21:48.468]                         invokeRestart("muffleWarning")
[13:21:48.468]                     }
[13:21:48.468]                     else if (inherits(cond, "condition")) {
[13:21:48.468]                       if (!is.null(pattern)) {
[13:21:48.468]                         computeRestarts <- base::computeRestarts
[13:21:48.468]                         grepl <- base::grepl
[13:21:48.468]                         restarts <- computeRestarts(cond)
[13:21:48.468]                         for (restart in restarts) {
[13:21:48.468]                           name <- restart$name
[13:21:48.468]                           if (is.null(name)) 
[13:21:48.468]                             next
[13:21:48.468]                           if (!grepl(pattern, name)) 
[13:21:48.468]                             next
[13:21:48.468]                           invokeRestart(restart)
[13:21:48.468]                           muffled <- TRUE
[13:21:48.468]                           break
[13:21:48.468]                         }
[13:21:48.468]                       }
[13:21:48.468]                     }
[13:21:48.468]                     invisible(muffled)
[13:21:48.468]                   }
[13:21:48.468]                   muffleCondition(cond)
[13:21:48.468]                 })
[13:21:48.468]             }))
[13:21:48.468]             future::FutureResult(value = ...future.value$value, 
[13:21:48.468]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:48.468]                   ...future.rng), globalenv = if (FALSE) 
[13:21:48.468]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:48.468]                     ...future.globalenv.names))
[13:21:48.468]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:48.468]         }, condition = base::local({
[13:21:48.468]             c <- base::c
[13:21:48.468]             inherits <- base::inherits
[13:21:48.468]             invokeRestart <- base::invokeRestart
[13:21:48.468]             length <- base::length
[13:21:48.468]             list <- base::list
[13:21:48.468]             seq.int <- base::seq.int
[13:21:48.468]             signalCondition <- base::signalCondition
[13:21:48.468]             sys.calls <- base::sys.calls
[13:21:48.468]             `[[` <- base::`[[`
[13:21:48.468]             `+` <- base::`+`
[13:21:48.468]             `<<-` <- base::`<<-`
[13:21:48.468]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:48.468]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:48.468]                   3L)]
[13:21:48.468]             }
[13:21:48.468]             function(cond) {
[13:21:48.468]                 is_error <- inherits(cond, "error")
[13:21:48.468]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:48.468]                   NULL)
[13:21:48.468]                 if (is_error) {
[13:21:48.468]                   sessionInformation <- function() {
[13:21:48.468]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:48.468]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:48.468]                       search = base::search(), system = base::Sys.info())
[13:21:48.468]                   }
[13:21:48.468]                   ...future.conditions[[length(...future.conditions) + 
[13:21:48.468]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:48.468]                     cond$call), session = sessionInformation(), 
[13:21:48.468]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:48.468]                   signalCondition(cond)
[13:21:48.468]                 }
[13:21:48.468]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:48.468]                 "immediateCondition"))) {
[13:21:48.468]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:48.468]                   ...future.conditions[[length(...future.conditions) + 
[13:21:48.468]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:48.468]                   if (TRUE && !signal) {
[13:21:48.468]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:48.468]                     {
[13:21:48.468]                       inherits <- base::inherits
[13:21:48.468]                       invokeRestart <- base::invokeRestart
[13:21:48.468]                       is.null <- base::is.null
[13:21:48.468]                       muffled <- FALSE
[13:21:48.468]                       if (inherits(cond, "message")) {
[13:21:48.468]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:48.468]                         if (muffled) 
[13:21:48.468]                           invokeRestart("muffleMessage")
[13:21:48.468]                       }
[13:21:48.468]                       else if (inherits(cond, "warning")) {
[13:21:48.468]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:48.468]                         if (muffled) 
[13:21:48.468]                           invokeRestart("muffleWarning")
[13:21:48.468]                       }
[13:21:48.468]                       else if (inherits(cond, "condition")) {
[13:21:48.468]                         if (!is.null(pattern)) {
[13:21:48.468]                           computeRestarts <- base::computeRestarts
[13:21:48.468]                           grepl <- base::grepl
[13:21:48.468]                           restarts <- computeRestarts(cond)
[13:21:48.468]                           for (restart in restarts) {
[13:21:48.468]                             name <- restart$name
[13:21:48.468]                             if (is.null(name)) 
[13:21:48.468]                               next
[13:21:48.468]                             if (!grepl(pattern, name)) 
[13:21:48.468]                               next
[13:21:48.468]                             invokeRestart(restart)
[13:21:48.468]                             muffled <- TRUE
[13:21:48.468]                             break
[13:21:48.468]                           }
[13:21:48.468]                         }
[13:21:48.468]                       }
[13:21:48.468]                       invisible(muffled)
[13:21:48.468]                     }
[13:21:48.468]                     muffleCondition(cond, pattern = "^muffle")
[13:21:48.468]                   }
[13:21:48.468]                 }
[13:21:48.468]                 else {
[13:21:48.468]                   if (TRUE) {
[13:21:48.468]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:48.468]                     {
[13:21:48.468]                       inherits <- base::inherits
[13:21:48.468]                       invokeRestart <- base::invokeRestart
[13:21:48.468]                       is.null <- base::is.null
[13:21:48.468]                       muffled <- FALSE
[13:21:48.468]                       if (inherits(cond, "message")) {
[13:21:48.468]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:48.468]                         if (muffled) 
[13:21:48.468]                           invokeRestart("muffleMessage")
[13:21:48.468]                       }
[13:21:48.468]                       else if (inherits(cond, "warning")) {
[13:21:48.468]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:48.468]                         if (muffled) 
[13:21:48.468]                           invokeRestart("muffleWarning")
[13:21:48.468]                       }
[13:21:48.468]                       else if (inherits(cond, "condition")) {
[13:21:48.468]                         if (!is.null(pattern)) {
[13:21:48.468]                           computeRestarts <- base::computeRestarts
[13:21:48.468]                           grepl <- base::grepl
[13:21:48.468]                           restarts <- computeRestarts(cond)
[13:21:48.468]                           for (restart in restarts) {
[13:21:48.468]                             name <- restart$name
[13:21:48.468]                             if (is.null(name)) 
[13:21:48.468]                               next
[13:21:48.468]                             if (!grepl(pattern, name)) 
[13:21:48.468]                               next
[13:21:48.468]                             invokeRestart(restart)
[13:21:48.468]                             muffled <- TRUE
[13:21:48.468]                             break
[13:21:48.468]                           }
[13:21:48.468]                         }
[13:21:48.468]                       }
[13:21:48.468]                       invisible(muffled)
[13:21:48.468]                     }
[13:21:48.468]                     muffleCondition(cond, pattern = "^muffle")
[13:21:48.468]                   }
[13:21:48.468]                 }
[13:21:48.468]             }
[13:21:48.468]         }))
[13:21:48.468]     }, error = function(ex) {
[13:21:48.468]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:48.468]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:48.468]                 ...future.rng), started = ...future.startTime, 
[13:21:48.468]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:48.468]             version = "1.8"), class = "FutureResult")
[13:21:48.468]     }, finally = {
[13:21:48.468]         if (!identical(...future.workdir, getwd())) 
[13:21:48.468]             setwd(...future.workdir)
[13:21:48.468]         {
[13:21:48.468]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:48.468]                 ...future.oldOptions$nwarnings <- NULL
[13:21:48.468]             }
[13:21:48.468]             base::options(...future.oldOptions)
[13:21:48.468]             if (.Platform$OS.type == "windows") {
[13:21:48.468]                 old_names <- names(...future.oldEnvVars)
[13:21:48.468]                 envs <- base::Sys.getenv()
[13:21:48.468]                 names <- names(envs)
[13:21:48.468]                 common <- intersect(names, old_names)
[13:21:48.468]                 added <- setdiff(names, old_names)
[13:21:48.468]                 removed <- setdiff(old_names, names)
[13:21:48.468]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:48.468]                   envs[common]]
[13:21:48.468]                 NAMES <- toupper(changed)
[13:21:48.468]                 args <- list()
[13:21:48.468]                 for (kk in seq_along(NAMES)) {
[13:21:48.468]                   name <- changed[[kk]]
[13:21:48.468]                   NAME <- NAMES[[kk]]
[13:21:48.468]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:48.468]                     next
[13:21:48.468]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:48.468]                 }
[13:21:48.468]                 NAMES <- toupper(added)
[13:21:48.468]                 for (kk in seq_along(NAMES)) {
[13:21:48.468]                   name <- added[[kk]]
[13:21:48.468]                   NAME <- NAMES[[kk]]
[13:21:48.468]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:48.468]                     next
[13:21:48.468]                   args[[name]] <- ""
[13:21:48.468]                 }
[13:21:48.468]                 NAMES <- toupper(removed)
[13:21:48.468]                 for (kk in seq_along(NAMES)) {
[13:21:48.468]                   name <- removed[[kk]]
[13:21:48.468]                   NAME <- NAMES[[kk]]
[13:21:48.468]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:48.468]                     next
[13:21:48.468]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:48.468]                 }
[13:21:48.468]                 if (length(args) > 0) 
[13:21:48.468]                   base::do.call(base::Sys.setenv, args = args)
[13:21:48.468]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:48.468]             }
[13:21:48.468]             else {
[13:21:48.468]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:48.468]             }
[13:21:48.468]             {
[13:21:48.468]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:48.468]                   0L) {
[13:21:48.468]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:48.468]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:48.468]                   base::options(opts)
[13:21:48.468]                 }
[13:21:48.468]                 {
[13:21:48.468]                   {
[13:21:48.468]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:48.468]                     NULL
[13:21:48.468]                   }
[13:21:48.468]                   options(future.plan = NULL)
[13:21:48.468]                   if (is.na(NA_character_)) 
[13:21:48.468]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:48.468]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:48.468]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:48.468]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:48.468]                     envir = parent.frame()) 
[13:21:48.468]                   {
[13:21:48.468]                     if (is.function(workers)) 
[13:21:48.468]                       workers <- workers()
[13:21:48.468]                     workers <- structure(as.integer(workers), 
[13:21:48.468]                       class = class(workers))
[13:21:48.468]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:48.468]                       workers >= 1)
[13:21:48.468]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:48.468]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:48.468]                     }
[13:21:48.468]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:48.468]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:48.468]                       envir = envir)
[13:21:48.468]                     if (!future$lazy) 
[13:21:48.468]                       future <- run(future)
[13:21:48.468]                     invisible(future)
[13:21:48.468]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:48.468]                 }
[13:21:48.468]             }
[13:21:48.468]         }
[13:21:48.468]     })
[13:21:48.468]     if (TRUE) {
[13:21:48.468]         base::sink(type = "output", split = FALSE)
[13:21:48.468]         if (TRUE) {
[13:21:48.468]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:48.468]         }
[13:21:48.468]         else {
[13:21:48.468]             ...future.result["stdout"] <- base::list(NULL)
[13:21:48.468]         }
[13:21:48.468]         base::close(...future.stdout)
[13:21:48.468]         ...future.stdout <- NULL
[13:21:48.468]     }
[13:21:48.468]     ...future.result$conditions <- ...future.conditions
[13:21:48.468]     ...future.result$finished <- base::Sys.time()
[13:21:48.468]     ...future.result
[13:21:48.468] }
[13:21:48.471] MultisessionFuture started
[13:21:48.471] - Launch lazy future ... done
[13:21:48.471] run() for ‘MultisessionFuture’ ... done
[13:21:48.518] receiveMessageFromWorker() for ClusterFuture ...
[13:21:48.518] - Validating connection of MultisessionFuture
[13:21:48.519] - received message: FutureResult
[13:21:48.519] - Received FutureResult
[13:21:48.519] - Erased future from FutureRegistry
[13:21:48.519] result() for ClusterFuture ...
[13:21:48.519] - result already collected: FutureResult
[13:21:48.519] result() for ClusterFuture ... done
[13:21:48.519] signalConditions() ...
[13:21:48.519]  - include = ‘immediateCondition’
[13:21:48.520]  - exclude = 
[13:21:48.520]  - resignal = FALSE
[13:21:48.520]  - Number of conditions: 1
[13:21:48.520] signalConditions() ... done
[13:21:48.520] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:48.520] A MultisessionFuture was resolved (result was not collected)
[13:21:48.520] getGlobalsAndPackages() ...
[13:21:48.520] Searching for globals...
[13:21:48.521] - globals found: [2] ‘list’, ‘stop’
[13:21:48.521] Searching for globals ... DONE
[13:21:48.521] Resolving globals: FALSE
[13:21:48.521] 
[13:21:48.522] 
[13:21:48.522] getGlobalsAndPackages() ... DONE
[13:21:48.522] run() for ‘Future’ ...
[13:21:48.522] - state: ‘created’
[13:21:48.522] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:48.539] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:48.539] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:48.539]   - Field: ‘node’
[13:21:48.539]   - Field: ‘label’
[13:21:48.539]   - Field: ‘local’
[13:21:48.539]   - Field: ‘owner’
[13:21:48.539]   - Field: ‘envir’
[13:21:48.539]   - Field: ‘workers’
[13:21:48.539]   - Field: ‘packages’
[13:21:48.540]   - Field: ‘gc’
[13:21:48.540]   - Field: ‘conditions’
[13:21:48.540]   - Field: ‘persistent’
[13:21:48.540]   - Field: ‘expr’
[13:21:48.540]   - Field: ‘uuid’
[13:21:48.540]   - Field: ‘seed’
[13:21:48.540]   - Field: ‘version’
[13:21:48.540]   - Field: ‘result’
[13:21:48.540]   - Field: ‘asynchronous’
[13:21:48.540]   - Field: ‘calls’
[13:21:48.540]   - Field: ‘globals’
[13:21:48.541]   - Field: ‘stdout’
[13:21:48.541]   - Field: ‘earlySignal’
[13:21:48.541]   - Field: ‘lazy’
[13:21:48.541]   - Field: ‘state’
[13:21:48.541] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:48.541] - Launch lazy future ...
[13:21:48.541] Packages needed by the future expression (n = 0): <none>
[13:21:48.541] Packages needed by future strategies (n = 0): <none>
[13:21:48.542] {
[13:21:48.542]     {
[13:21:48.542]         {
[13:21:48.542]             ...future.startTime <- base::Sys.time()
[13:21:48.542]             {
[13:21:48.542]                 {
[13:21:48.542]                   {
[13:21:48.542]                     {
[13:21:48.542]                       base::local({
[13:21:48.542]                         has_future <- base::requireNamespace("future", 
[13:21:48.542]                           quietly = TRUE)
[13:21:48.542]                         if (has_future) {
[13:21:48.542]                           ns <- base::getNamespace("future")
[13:21:48.542]                           version <- ns[[".package"]][["version"]]
[13:21:48.542]                           if (is.null(version)) 
[13:21:48.542]                             version <- utils::packageVersion("future")
[13:21:48.542]                         }
[13:21:48.542]                         else {
[13:21:48.542]                           version <- NULL
[13:21:48.542]                         }
[13:21:48.542]                         if (!has_future || version < "1.8.0") {
[13:21:48.542]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:48.542]                             "", base::R.version$version.string), 
[13:21:48.542]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:48.542]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:48.542]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:48.542]                               "release", "version")], collapse = " "), 
[13:21:48.542]                             hostname = base::Sys.info()[["nodename"]])
[13:21:48.542]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:48.542]                             info)
[13:21:48.542]                           info <- base::paste(info, collapse = "; ")
[13:21:48.542]                           if (!has_future) {
[13:21:48.542]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:48.542]                               info)
[13:21:48.542]                           }
[13:21:48.542]                           else {
[13:21:48.542]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:48.542]                               info, version)
[13:21:48.542]                           }
[13:21:48.542]                           base::stop(msg)
[13:21:48.542]                         }
[13:21:48.542]                       })
[13:21:48.542]                     }
[13:21:48.542]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:48.542]                     base::options(mc.cores = 1L)
[13:21:48.542]                   }
[13:21:48.542]                   options(future.plan = NULL)
[13:21:48.542]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:48.542]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:48.542]                 }
[13:21:48.542]                 ...future.workdir <- getwd()
[13:21:48.542]             }
[13:21:48.542]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:48.542]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:48.542]         }
[13:21:48.542]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:48.542]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:48.542]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:48.542]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:48.542]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:48.542]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:48.542]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:48.542]             base::names(...future.oldOptions))
[13:21:48.542]     }
[13:21:48.542]     if (FALSE) {
[13:21:48.542]     }
[13:21:48.542]     else {
[13:21:48.542]         if (TRUE) {
[13:21:48.542]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:48.542]                 open = "w")
[13:21:48.542]         }
[13:21:48.542]         else {
[13:21:48.542]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:48.542]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:48.542]         }
[13:21:48.542]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:48.542]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:48.542]             base::sink(type = "output", split = FALSE)
[13:21:48.542]             base::close(...future.stdout)
[13:21:48.542]         }, add = TRUE)
[13:21:48.542]     }
[13:21:48.542]     ...future.frame <- base::sys.nframe()
[13:21:48.542]     ...future.conditions <- base::list()
[13:21:48.542]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:48.542]     if (FALSE) {
[13:21:48.542]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:48.542]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:48.542]     }
[13:21:48.542]     ...future.result <- base::tryCatch({
[13:21:48.542]         base::withCallingHandlers({
[13:21:48.542]             ...future.value <- base::withVisible(base::local({
[13:21:48.542]                 ...future.makeSendCondition <- local({
[13:21:48.542]                   sendCondition <- NULL
[13:21:48.542]                   function(frame = 1L) {
[13:21:48.542]                     if (is.function(sendCondition)) 
[13:21:48.542]                       return(sendCondition)
[13:21:48.542]                     ns <- getNamespace("parallel")
[13:21:48.542]                     if (exists("sendData", mode = "function", 
[13:21:48.542]                       envir = ns)) {
[13:21:48.542]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:48.542]                         envir = ns)
[13:21:48.542]                       envir <- sys.frame(frame)
[13:21:48.542]                       master <- NULL
[13:21:48.542]                       while (!identical(envir, .GlobalEnv) && 
[13:21:48.542]                         !identical(envir, emptyenv())) {
[13:21:48.542]                         if (exists("master", mode = "list", envir = envir, 
[13:21:48.542]                           inherits = FALSE)) {
[13:21:48.542]                           master <- get("master", mode = "list", 
[13:21:48.542]                             envir = envir, inherits = FALSE)
[13:21:48.542]                           if (inherits(master, c("SOCKnode", 
[13:21:48.542]                             "SOCK0node"))) {
[13:21:48.542]                             sendCondition <<- function(cond) {
[13:21:48.542]                               data <- list(type = "VALUE", value = cond, 
[13:21:48.542]                                 success = TRUE)
[13:21:48.542]                               parallel_sendData(master, data)
[13:21:48.542]                             }
[13:21:48.542]                             return(sendCondition)
[13:21:48.542]                           }
[13:21:48.542]                         }
[13:21:48.542]                         frame <- frame + 1L
[13:21:48.542]                         envir <- sys.frame(frame)
[13:21:48.542]                       }
[13:21:48.542]                     }
[13:21:48.542]                     sendCondition <<- function(cond) NULL
[13:21:48.542]                   }
[13:21:48.542]                 })
[13:21:48.542]                 withCallingHandlers({
[13:21:48.542]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:21:48.542]                 }, immediateCondition = function(cond) {
[13:21:48.542]                   sendCondition <- ...future.makeSendCondition()
[13:21:48.542]                   sendCondition(cond)
[13:21:48.542]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:48.542]                   {
[13:21:48.542]                     inherits <- base::inherits
[13:21:48.542]                     invokeRestart <- base::invokeRestart
[13:21:48.542]                     is.null <- base::is.null
[13:21:48.542]                     muffled <- FALSE
[13:21:48.542]                     if (inherits(cond, "message")) {
[13:21:48.542]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:48.542]                       if (muffled) 
[13:21:48.542]                         invokeRestart("muffleMessage")
[13:21:48.542]                     }
[13:21:48.542]                     else if (inherits(cond, "warning")) {
[13:21:48.542]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:48.542]                       if (muffled) 
[13:21:48.542]                         invokeRestart("muffleWarning")
[13:21:48.542]                     }
[13:21:48.542]                     else if (inherits(cond, "condition")) {
[13:21:48.542]                       if (!is.null(pattern)) {
[13:21:48.542]                         computeRestarts <- base::computeRestarts
[13:21:48.542]                         grepl <- base::grepl
[13:21:48.542]                         restarts <- computeRestarts(cond)
[13:21:48.542]                         for (restart in restarts) {
[13:21:48.542]                           name <- restart$name
[13:21:48.542]                           if (is.null(name)) 
[13:21:48.542]                             next
[13:21:48.542]                           if (!grepl(pattern, name)) 
[13:21:48.542]                             next
[13:21:48.542]                           invokeRestart(restart)
[13:21:48.542]                           muffled <- TRUE
[13:21:48.542]                           break
[13:21:48.542]                         }
[13:21:48.542]                       }
[13:21:48.542]                     }
[13:21:48.542]                     invisible(muffled)
[13:21:48.542]                   }
[13:21:48.542]                   muffleCondition(cond)
[13:21:48.542]                 })
[13:21:48.542]             }))
[13:21:48.542]             future::FutureResult(value = ...future.value$value, 
[13:21:48.542]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:48.542]                   ...future.rng), globalenv = if (FALSE) 
[13:21:48.542]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:48.542]                     ...future.globalenv.names))
[13:21:48.542]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:48.542]         }, condition = base::local({
[13:21:48.542]             c <- base::c
[13:21:48.542]             inherits <- base::inherits
[13:21:48.542]             invokeRestart <- base::invokeRestart
[13:21:48.542]             length <- base::length
[13:21:48.542]             list <- base::list
[13:21:48.542]             seq.int <- base::seq.int
[13:21:48.542]             signalCondition <- base::signalCondition
[13:21:48.542]             sys.calls <- base::sys.calls
[13:21:48.542]             `[[` <- base::`[[`
[13:21:48.542]             `+` <- base::`+`
[13:21:48.542]             `<<-` <- base::`<<-`
[13:21:48.542]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:48.542]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:48.542]                   3L)]
[13:21:48.542]             }
[13:21:48.542]             function(cond) {
[13:21:48.542]                 is_error <- inherits(cond, "error")
[13:21:48.542]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:48.542]                   NULL)
[13:21:48.542]                 if (is_error) {
[13:21:48.542]                   sessionInformation <- function() {
[13:21:48.542]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:48.542]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:48.542]                       search = base::search(), system = base::Sys.info())
[13:21:48.542]                   }
[13:21:48.542]                   ...future.conditions[[length(...future.conditions) + 
[13:21:48.542]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:48.542]                     cond$call), session = sessionInformation(), 
[13:21:48.542]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:48.542]                   signalCondition(cond)
[13:21:48.542]                 }
[13:21:48.542]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:48.542]                 "immediateCondition"))) {
[13:21:48.542]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:48.542]                   ...future.conditions[[length(...future.conditions) + 
[13:21:48.542]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:48.542]                   if (TRUE && !signal) {
[13:21:48.542]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:48.542]                     {
[13:21:48.542]                       inherits <- base::inherits
[13:21:48.542]                       invokeRestart <- base::invokeRestart
[13:21:48.542]                       is.null <- base::is.null
[13:21:48.542]                       muffled <- FALSE
[13:21:48.542]                       if (inherits(cond, "message")) {
[13:21:48.542]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:48.542]                         if (muffled) 
[13:21:48.542]                           invokeRestart("muffleMessage")
[13:21:48.542]                       }
[13:21:48.542]                       else if (inherits(cond, "warning")) {
[13:21:48.542]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:48.542]                         if (muffled) 
[13:21:48.542]                           invokeRestart("muffleWarning")
[13:21:48.542]                       }
[13:21:48.542]                       else if (inherits(cond, "condition")) {
[13:21:48.542]                         if (!is.null(pattern)) {
[13:21:48.542]                           computeRestarts <- base::computeRestarts
[13:21:48.542]                           grepl <- base::grepl
[13:21:48.542]                           restarts <- computeRestarts(cond)
[13:21:48.542]                           for (restart in restarts) {
[13:21:48.542]                             name <- restart$name
[13:21:48.542]                             if (is.null(name)) 
[13:21:48.542]                               next
[13:21:48.542]                             if (!grepl(pattern, name)) 
[13:21:48.542]                               next
[13:21:48.542]                             invokeRestart(restart)
[13:21:48.542]                             muffled <- TRUE
[13:21:48.542]                             break
[13:21:48.542]                           }
[13:21:48.542]                         }
[13:21:48.542]                       }
[13:21:48.542]                       invisible(muffled)
[13:21:48.542]                     }
[13:21:48.542]                     muffleCondition(cond, pattern = "^muffle")
[13:21:48.542]                   }
[13:21:48.542]                 }
[13:21:48.542]                 else {
[13:21:48.542]                   if (TRUE) {
[13:21:48.542]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:48.542]                     {
[13:21:48.542]                       inherits <- base::inherits
[13:21:48.542]                       invokeRestart <- base::invokeRestart
[13:21:48.542]                       is.null <- base::is.null
[13:21:48.542]                       muffled <- FALSE
[13:21:48.542]                       if (inherits(cond, "message")) {
[13:21:48.542]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:48.542]                         if (muffled) 
[13:21:48.542]                           invokeRestart("muffleMessage")
[13:21:48.542]                       }
[13:21:48.542]                       else if (inherits(cond, "warning")) {
[13:21:48.542]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:48.542]                         if (muffled) 
[13:21:48.542]                           invokeRestart("muffleWarning")
[13:21:48.542]                       }
[13:21:48.542]                       else if (inherits(cond, "condition")) {
[13:21:48.542]                         if (!is.null(pattern)) {
[13:21:48.542]                           computeRestarts <- base::computeRestarts
[13:21:48.542]                           grepl <- base::grepl
[13:21:48.542]                           restarts <- computeRestarts(cond)
[13:21:48.542]                           for (restart in restarts) {
[13:21:48.542]                             name <- restart$name
[13:21:48.542]                             if (is.null(name)) 
[13:21:48.542]                               next
[13:21:48.542]                             if (!grepl(pattern, name)) 
[13:21:48.542]                               next
[13:21:48.542]                             invokeRestart(restart)
[13:21:48.542]                             muffled <- TRUE
[13:21:48.542]                             break
[13:21:48.542]                           }
[13:21:48.542]                         }
[13:21:48.542]                       }
[13:21:48.542]                       invisible(muffled)
[13:21:48.542]                     }
[13:21:48.542]                     muffleCondition(cond, pattern = "^muffle")
[13:21:48.542]                   }
[13:21:48.542]                 }
[13:21:48.542]             }
[13:21:48.542]         }))
[13:21:48.542]     }, error = function(ex) {
[13:21:48.542]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:48.542]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:48.542]                 ...future.rng), started = ...future.startTime, 
[13:21:48.542]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:48.542]             version = "1.8"), class = "FutureResult")
[13:21:48.542]     }, finally = {
[13:21:48.542]         if (!identical(...future.workdir, getwd())) 
[13:21:48.542]             setwd(...future.workdir)
[13:21:48.542]         {
[13:21:48.542]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:48.542]                 ...future.oldOptions$nwarnings <- NULL
[13:21:48.542]             }
[13:21:48.542]             base::options(...future.oldOptions)
[13:21:48.542]             if (.Platform$OS.type == "windows") {
[13:21:48.542]                 old_names <- names(...future.oldEnvVars)
[13:21:48.542]                 envs <- base::Sys.getenv()
[13:21:48.542]                 names <- names(envs)
[13:21:48.542]                 common <- intersect(names, old_names)
[13:21:48.542]                 added <- setdiff(names, old_names)
[13:21:48.542]                 removed <- setdiff(old_names, names)
[13:21:48.542]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:48.542]                   envs[common]]
[13:21:48.542]                 NAMES <- toupper(changed)
[13:21:48.542]                 args <- list()
[13:21:48.542]                 for (kk in seq_along(NAMES)) {
[13:21:48.542]                   name <- changed[[kk]]
[13:21:48.542]                   NAME <- NAMES[[kk]]
[13:21:48.542]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:48.542]                     next
[13:21:48.542]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:48.542]                 }
[13:21:48.542]                 NAMES <- toupper(added)
[13:21:48.542]                 for (kk in seq_along(NAMES)) {
[13:21:48.542]                   name <- added[[kk]]
[13:21:48.542]                   NAME <- NAMES[[kk]]
[13:21:48.542]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:48.542]                     next
[13:21:48.542]                   args[[name]] <- ""
[13:21:48.542]                 }
[13:21:48.542]                 NAMES <- toupper(removed)
[13:21:48.542]                 for (kk in seq_along(NAMES)) {
[13:21:48.542]                   name <- removed[[kk]]
[13:21:48.542]                   NAME <- NAMES[[kk]]
[13:21:48.542]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:48.542]                     next
[13:21:48.542]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:48.542]                 }
[13:21:48.542]                 if (length(args) > 0) 
[13:21:48.542]                   base::do.call(base::Sys.setenv, args = args)
[13:21:48.542]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:48.542]             }
[13:21:48.542]             else {
[13:21:48.542]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:48.542]             }
[13:21:48.542]             {
[13:21:48.542]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:48.542]                   0L) {
[13:21:48.542]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:48.542]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:48.542]                   base::options(opts)
[13:21:48.542]                 }
[13:21:48.542]                 {
[13:21:48.542]                   {
[13:21:48.542]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:48.542]                     NULL
[13:21:48.542]                   }
[13:21:48.542]                   options(future.plan = NULL)
[13:21:48.542]                   if (is.na(NA_character_)) 
[13:21:48.542]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:48.542]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:48.542]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:48.542]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:48.542]                     envir = parent.frame()) 
[13:21:48.542]                   {
[13:21:48.542]                     if (is.function(workers)) 
[13:21:48.542]                       workers <- workers()
[13:21:48.542]                     workers <- structure(as.integer(workers), 
[13:21:48.542]                       class = class(workers))
[13:21:48.542]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:48.542]                       workers >= 1)
[13:21:48.542]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:48.542]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:48.542]                     }
[13:21:48.542]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:48.542]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:48.542]                       envir = envir)
[13:21:48.542]                     if (!future$lazy) 
[13:21:48.542]                       future <- run(future)
[13:21:48.542]                     invisible(future)
[13:21:48.542]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:48.542]                 }
[13:21:48.542]             }
[13:21:48.542]         }
[13:21:48.542]     })
[13:21:48.542]     if (TRUE) {
[13:21:48.542]         base::sink(type = "output", split = FALSE)
[13:21:48.542]         if (TRUE) {
[13:21:48.542]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:48.542]         }
[13:21:48.542]         else {
[13:21:48.542]             ...future.result["stdout"] <- base::list(NULL)
[13:21:48.542]         }
[13:21:48.542]         base::close(...future.stdout)
[13:21:48.542]         ...future.stdout <- NULL
[13:21:48.542]     }
[13:21:48.542]     ...future.result$conditions <- ...future.conditions
[13:21:48.542]     ...future.result$finished <- base::Sys.time()
[13:21:48.542]     ...future.result
[13:21:48.542] }
[13:21:48.545] MultisessionFuture started
[13:21:48.545] - Launch lazy future ... done
[13:21:48.545] run() for ‘MultisessionFuture’ ... done
[13:21:48.594] receiveMessageFromWorker() for ClusterFuture ...
[13:21:48.594] - Validating connection of MultisessionFuture
[13:21:48.594] - received message: FutureResult
[13:21:48.594] - Received FutureResult
[13:21:48.595] - Erased future from FutureRegistry
[13:21:48.595] result() for ClusterFuture ...
[13:21:48.595] - result already collected: FutureResult
[13:21:48.595] result() for ClusterFuture ... done
[13:21:48.595] signalConditions() ...
[13:21:48.595]  - include = ‘immediateCondition’
[13:21:48.595]  - exclude = 
[13:21:48.595]  - resignal = FALSE
[13:21:48.595]  - Number of conditions: 1
[13:21:48.595] signalConditions() ... done
[13:21:48.595] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:48.596] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 1 ... DONE
- result = FALSE, recursive = 2 ...
[13:21:48.596] getGlobalsAndPackages() ...
[13:21:48.596] Searching for globals...
[13:21:48.597] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:21:48.597] Searching for globals ... DONE
[13:21:48.597] Resolving globals: FALSE
[13:21:48.598] 
[13:21:48.598] 
[13:21:48.598] getGlobalsAndPackages() ... DONE
[13:21:48.598] run() for ‘Future’ ...
[13:21:48.598] - state: ‘created’
[13:21:48.598] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:48.613] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:48.613] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:48.613]   - Field: ‘node’
[13:21:48.613]   - Field: ‘label’
[13:21:48.613]   - Field: ‘local’
[13:21:48.613]   - Field: ‘owner’
[13:21:48.613]   - Field: ‘envir’
[13:21:48.614]   - Field: ‘workers’
[13:21:48.614]   - Field: ‘packages’
[13:21:48.614]   - Field: ‘gc’
[13:21:48.614]   - Field: ‘conditions’
[13:21:48.614]   - Field: ‘persistent’
[13:21:48.614]   - Field: ‘expr’
[13:21:48.614]   - Field: ‘uuid’
[13:21:48.614]   - Field: ‘seed’
[13:21:48.615]   - Field: ‘version’
[13:21:48.615]   - Field: ‘result’
[13:21:48.615]   - Field: ‘asynchronous’
[13:21:48.615]   - Field: ‘calls’
[13:21:48.615]   - Field: ‘globals’
[13:21:48.615]   - Field: ‘stdout’
[13:21:48.615]   - Field: ‘earlySignal’
[13:21:48.615]   - Field: ‘lazy’
[13:21:48.616]   - Field: ‘state’
[13:21:48.616] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:48.616] - Launch lazy future ...
[13:21:48.616] Packages needed by the future expression (n = 0): <none>
[13:21:48.616] Packages needed by future strategies (n = 0): <none>
[13:21:48.617] {
[13:21:48.617]     {
[13:21:48.617]         {
[13:21:48.617]             ...future.startTime <- base::Sys.time()
[13:21:48.617]             {
[13:21:48.617]                 {
[13:21:48.617]                   {
[13:21:48.617]                     {
[13:21:48.617]                       base::local({
[13:21:48.617]                         has_future <- base::requireNamespace("future", 
[13:21:48.617]                           quietly = TRUE)
[13:21:48.617]                         if (has_future) {
[13:21:48.617]                           ns <- base::getNamespace("future")
[13:21:48.617]                           version <- ns[[".package"]][["version"]]
[13:21:48.617]                           if (is.null(version)) 
[13:21:48.617]                             version <- utils::packageVersion("future")
[13:21:48.617]                         }
[13:21:48.617]                         else {
[13:21:48.617]                           version <- NULL
[13:21:48.617]                         }
[13:21:48.617]                         if (!has_future || version < "1.8.0") {
[13:21:48.617]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:48.617]                             "", base::R.version$version.string), 
[13:21:48.617]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:48.617]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:48.617]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:48.617]                               "release", "version")], collapse = " "), 
[13:21:48.617]                             hostname = base::Sys.info()[["nodename"]])
[13:21:48.617]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:48.617]                             info)
[13:21:48.617]                           info <- base::paste(info, collapse = "; ")
[13:21:48.617]                           if (!has_future) {
[13:21:48.617]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:48.617]                               info)
[13:21:48.617]                           }
[13:21:48.617]                           else {
[13:21:48.617]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:48.617]                               info, version)
[13:21:48.617]                           }
[13:21:48.617]                           base::stop(msg)
[13:21:48.617]                         }
[13:21:48.617]                       })
[13:21:48.617]                     }
[13:21:48.617]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:48.617]                     base::options(mc.cores = 1L)
[13:21:48.617]                   }
[13:21:48.617]                   options(future.plan = NULL)
[13:21:48.617]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:48.617]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:48.617]                 }
[13:21:48.617]                 ...future.workdir <- getwd()
[13:21:48.617]             }
[13:21:48.617]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:48.617]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:48.617]         }
[13:21:48.617]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:48.617]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:48.617]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:48.617]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:48.617]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:48.617]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:48.617]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:48.617]             base::names(...future.oldOptions))
[13:21:48.617]     }
[13:21:48.617]     if (FALSE) {
[13:21:48.617]     }
[13:21:48.617]     else {
[13:21:48.617]         if (TRUE) {
[13:21:48.617]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:48.617]                 open = "w")
[13:21:48.617]         }
[13:21:48.617]         else {
[13:21:48.617]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:48.617]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:48.617]         }
[13:21:48.617]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:48.617]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:48.617]             base::sink(type = "output", split = FALSE)
[13:21:48.617]             base::close(...future.stdout)
[13:21:48.617]         }, add = TRUE)
[13:21:48.617]     }
[13:21:48.617]     ...future.frame <- base::sys.nframe()
[13:21:48.617]     ...future.conditions <- base::list()
[13:21:48.617]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:48.617]     if (FALSE) {
[13:21:48.617]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:48.617]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:48.617]     }
[13:21:48.617]     ...future.result <- base::tryCatch({
[13:21:48.617]         base::withCallingHandlers({
[13:21:48.617]             ...future.value <- base::withVisible(base::local({
[13:21:48.617]                 ...future.makeSendCondition <- local({
[13:21:48.617]                   sendCondition <- NULL
[13:21:48.617]                   function(frame = 1L) {
[13:21:48.617]                     if (is.function(sendCondition)) 
[13:21:48.617]                       return(sendCondition)
[13:21:48.617]                     ns <- getNamespace("parallel")
[13:21:48.617]                     if (exists("sendData", mode = "function", 
[13:21:48.617]                       envir = ns)) {
[13:21:48.617]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:48.617]                         envir = ns)
[13:21:48.617]                       envir <- sys.frame(frame)
[13:21:48.617]                       master <- NULL
[13:21:48.617]                       while (!identical(envir, .GlobalEnv) && 
[13:21:48.617]                         !identical(envir, emptyenv())) {
[13:21:48.617]                         if (exists("master", mode = "list", envir = envir, 
[13:21:48.617]                           inherits = FALSE)) {
[13:21:48.617]                           master <- get("master", mode = "list", 
[13:21:48.617]                             envir = envir, inherits = FALSE)
[13:21:48.617]                           if (inherits(master, c("SOCKnode", 
[13:21:48.617]                             "SOCK0node"))) {
[13:21:48.617]                             sendCondition <<- function(cond) {
[13:21:48.617]                               data <- list(type = "VALUE", value = cond, 
[13:21:48.617]                                 success = TRUE)
[13:21:48.617]                               parallel_sendData(master, data)
[13:21:48.617]                             }
[13:21:48.617]                             return(sendCondition)
[13:21:48.617]                           }
[13:21:48.617]                         }
[13:21:48.617]                         frame <- frame + 1L
[13:21:48.617]                         envir <- sys.frame(frame)
[13:21:48.617]                       }
[13:21:48.617]                     }
[13:21:48.617]                     sendCondition <<- function(cond) NULL
[13:21:48.617]                   }
[13:21:48.617]                 })
[13:21:48.617]                 withCallingHandlers({
[13:21:48.617]                   {
[13:21:48.617]                     Sys.sleep(0.5)
[13:21:48.617]                     list(a = 1, b = 42L)
[13:21:48.617]                   }
[13:21:48.617]                 }, immediateCondition = function(cond) {
[13:21:48.617]                   sendCondition <- ...future.makeSendCondition()
[13:21:48.617]                   sendCondition(cond)
[13:21:48.617]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:48.617]                   {
[13:21:48.617]                     inherits <- base::inherits
[13:21:48.617]                     invokeRestart <- base::invokeRestart
[13:21:48.617]                     is.null <- base::is.null
[13:21:48.617]                     muffled <- FALSE
[13:21:48.617]                     if (inherits(cond, "message")) {
[13:21:48.617]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:48.617]                       if (muffled) 
[13:21:48.617]                         invokeRestart("muffleMessage")
[13:21:48.617]                     }
[13:21:48.617]                     else if (inherits(cond, "warning")) {
[13:21:48.617]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:48.617]                       if (muffled) 
[13:21:48.617]                         invokeRestart("muffleWarning")
[13:21:48.617]                     }
[13:21:48.617]                     else if (inherits(cond, "condition")) {
[13:21:48.617]                       if (!is.null(pattern)) {
[13:21:48.617]                         computeRestarts <- base::computeRestarts
[13:21:48.617]                         grepl <- base::grepl
[13:21:48.617]                         restarts <- computeRestarts(cond)
[13:21:48.617]                         for (restart in restarts) {
[13:21:48.617]                           name <- restart$name
[13:21:48.617]                           if (is.null(name)) 
[13:21:48.617]                             next
[13:21:48.617]                           if (!grepl(pattern, name)) 
[13:21:48.617]                             next
[13:21:48.617]                           invokeRestart(restart)
[13:21:48.617]                           muffled <- TRUE
[13:21:48.617]                           break
[13:21:48.617]                         }
[13:21:48.617]                       }
[13:21:48.617]                     }
[13:21:48.617]                     invisible(muffled)
[13:21:48.617]                   }
[13:21:48.617]                   muffleCondition(cond)
[13:21:48.617]                 })
[13:21:48.617]             }))
[13:21:48.617]             future::FutureResult(value = ...future.value$value, 
[13:21:48.617]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:48.617]                   ...future.rng), globalenv = if (FALSE) 
[13:21:48.617]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:48.617]                     ...future.globalenv.names))
[13:21:48.617]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:48.617]         }, condition = base::local({
[13:21:48.617]             c <- base::c
[13:21:48.617]             inherits <- base::inherits
[13:21:48.617]             invokeRestart <- base::invokeRestart
[13:21:48.617]             length <- base::length
[13:21:48.617]             list <- base::list
[13:21:48.617]             seq.int <- base::seq.int
[13:21:48.617]             signalCondition <- base::signalCondition
[13:21:48.617]             sys.calls <- base::sys.calls
[13:21:48.617]             `[[` <- base::`[[`
[13:21:48.617]             `+` <- base::`+`
[13:21:48.617]             `<<-` <- base::`<<-`
[13:21:48.617]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:48.617]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:48.617]                   3L)]
[13:21:48.617]             }
[13:21:48.617]             function(cond) {
[13:21:48.617]                 is_error <- inherits(cond, "error")
[13:21:48.617]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:48.617]                   NULL)
[13:21:48.617]                 if (is_error) {
[13:21:48.617]                   sessionInformation <- function() {
[13:21:48.617]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:48.617]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:48.617]                       search = base::search(), system = base::Sys.info())
[13:21:48.617]                   }
[13:21:48.617]                   ...future.conditions[[length(...future.conditions) + 
[13:21:48.617]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:48.617]                     cond$call), session = sessionInformation(), 
[13:21:48.617]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:48.617]                   signalCondition(cond)
[13:21:48.617]                 }
[13:21:48.617]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:48.617]                 "immediateCondition"))) {
[13:21:48.617]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:48.617]                   ...future.conditions[[length(...future.conditions) + 
[13:21:48.617]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:48.617]                   if (TRUE && !signal) {
[13:21:48.617]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:48.617]                     {
[13:21:48.617]                       inherits <- base::inherits
[13:21:48.617]                       invokeRestart <- base::invokeRestart
[13:21:48.617]                       is.null <- base::is.null
[13:21:48.617]                       muffled <- FALSE
[13:21:48.617]                       if (inherits(cond, "message")) {
[13:21:48.617]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:48.617]                         if (muffled) 
[13:21:48.617]                           invokeRestart("muffleMessage")
[13:21:48.617]                       }
[13:21:48.617]                       else if (inherits(cond, "warning")) {
[13:21:48.617]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:48.617]                         if (muffled) 
[13:21:48.617]                           invokeRestart("muffleWarning")
[13:21:48.617]                       }
[13:21:48.617]                       else if (inherits(cond, "condition")) {
[13:21:48.617]                         if (!is.null(pattern)) {
[13:21:48.617]                           computeRestarts <- base::computeRestarts
[13:21:48.617]                           grepl <- base::grepl
[13:21:48.617]                           restarts <- computeRestarts(cond)
[13:21:48.617]                           for (restart in restarts) {
[13:21:48.617]                             name <- restart$name
[13:21:48.617]                             if (is.null(name)) 
[13:21:48.617]                               next
[13:21:48.617]                             if (!grepl(pattern, name)) 
[13:21:48.617]                               next
[13:21:48.617]                             invokeRestart(restart)
[13:21:48.617]                             muffled <- TRUE
[13:21:48.617]                             break
[13:21:48.617]                           }
[13:21:48.617]                         }
[13:21:48.617]                       }
[13:21:48.617]                       invisible(muffled)
[13:21:48.617]                     }
[13:21:48.617]                     muffleCondition(cond, pattern = "^muffle")
[13:21:48.617]                   }
[13:21:48.617]                 }
[13:21:48.617]                 else {
[13:21:48.617]                   if (TRUE) {
[13:21:48.617]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:48.617]                     {
[13:21:48.617]                       inherits <- base::inherits
[13:21:48.617]                       invokeRestart <- base::invokeRestart
[13:21:48.617]                       is.null <- base::is.null
[13:21:48.617]                       muffled <- FALSE
[13:21:48.617]                       if (inherits(cond, "message")) {
[13:21:48.617]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:48.617]                         if (muffled) 
[13:21:48.617]                           invokeRestart("muffleMessage")
[13:21:48.617]                       }
[13:21:48.617]                       else if (inherits(cond, "warning")) {
[13:21:48.617]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:48.617]                         if (muffled) 
[13:21:48.617]                           invokeRestart("muffleWarning")
[13:21:48.617]                       }
[13:21:48.617]                       else if (inherits(cond, "condition")) {
[13:21:48.617]                         if (!is.null(pattern)) {
[13:21:48.617]                           computeRestarts <- base::computeRestarts
[13:21:48.617]                           grepl <- base::grepl
[13:21:48.617]                           restarts <- computeRestarts(cond)
[13:21:48.617]                           for (restart in restarts) {
[13:21:48.617]                             name <- restart$name
[13:21:48.617]                             if (is.null(name)) 
[13:21:48.617]                               next
[13:21:48.617]                             if (!grepl(pattern, name)) 
[13:21:48.617]                               next
[13:21:48.617]                             invokeRestart(restart)
[13:21:48.617]                             muffled <- TRUE
[13:21:48.617]                             break
[13:21:48.617]                           }
[13:21:48.617]                         }
[13:21:48.617]                       }
[13:21:48.617]                       invisible(muffled)
[13:21:48.617]                     }
[13:21:48.617]                     muffleCondition(cond, pattern = "^muffle")
[13:21:48.617]                   }
[13:21:48.617]                 }
[13:21:48.617]             }
[13:21:48.617]         }))
[13:21:48.617]     }, error = function(ex) {
[13:21:48.617]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:48.617]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:48.617]                 ...future.rng), started = ...future.startTime, 
[13:21:48.617]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:48.617]             version = "1.8"), class = "FutureResult")
[13:21:48.617]     }, finally = {
[13:21:48.617]         if (!identical(...future.workdir, getwd())) 
[13:21:48.617]             setwd(...future.workdir)
[13:21:48.617]         {
[13:21:48.617]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:48.617]                 ...future.oldOptions$nwarnings <- NULL
[13:21:48.617]             }
[13:21:48.617]             base::options(...future.oldOptions)
[13:21:48.617]             if (.Platform$OS.type == "windows") {
[13:21:48.617]                 old_names <- names(...future.oldEnvVars)
[13:21:48.617]                 envs <- base::Sys.getenv()
[13:21:48.617]                 names <- names(envs)
[13:21:48.617]                 common <- intersect(names, old_names)
[13:21:48.617]                 added <- setdiff(names, old_names)
[13:21:48.617]                 removed <- setdiff(old_names, names)
[13:21:48.617]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:48.617]                   envs[common]]
[13:21:48.617]                 NAMES <- toupper(changed)
[13:21:48.617]                 args <- list()
[13:21:48.617]                 for (kk in seq_along(NAMES)) {
[13:21:48.617]                   name <- changed[[kk]]
[13:21:48.617]                   NAME <- NAMES[[kk]]
[13:21:48.617]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:48.617]                     next
[13:21:48.617]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:48.617]                 }
[13:21:48.617]                 NAMES <- toupper(added)
[13:21:48.617]                 for (kk in seq_along(NAMES)) {
[13:21:48.617]                   name <- added[[kk]]
[13:21:48.617]                   NAME <- NAMES[[kk]]
[13:21:48.617]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:48.617]                     next
[13:21:48.617]                   args[[name]] <- ""
[13:21:48.617]                 }
[13:21:48.617]                 NAMES <- toupper(removed)
[13:21:48.617]                 for (kk in seq_along(NAMES)) {
[13:21:48.617]                   name <- removed[[kk]]
[13:21:48.617]                   NAME <- NAMES[[kk]]
[13:21:48.617]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:48.617]                     next
[13:21:48.617]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:48.617]                 }
[13:21:48.617]                 if (length(args) > 0) 
[13:21:48.617]                   base::do.call(base::Sys.setenv, args = args)
[13:21:48.617]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:48.617]             }
[13:21:48.617]             else {
[13:21:48.617]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:48.617]             }
[13:21:48.617]             {
[13:21:48.617]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:48.617]                   0L) {
[13:21:48.617]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:48.617]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:48.617]                   base::options(opts)
[13:21:48.617]                 }
[13:21:48.617]                 {
[13:21:48.617]                   {
[13:21:48.617]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:48.617]                     NULL
[13:21:48.617]                   }
[13:21:48.617]                   options(future.plan = NULL)
[13:21:48.617]                   if (is.na(NA_character_)) 
[13:21:48.617]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:48.617]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:48.617]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:48.617]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:48.617]                     envir = parent.frame()) 
[13:21:48.617]                   {
[13:21:48.617]                     if (is.function(workers)) 
[13:21:48.617]                       workers <- workers()
[13:21:48.617]                     workers <- structure(as.integer(workers), 
[13:21:48.617]                       class = class(workers))
[13:21:48.617]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:48.617]                       workers >= 1)
[13:21:48.617]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:48.617]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:48.617]                     }
[13:21:48.617]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:48.617]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:48.617]                       envir = envir)
[13:21:48.617]                     if (!future$lazy) 
[13:21:48.617]                       future <- run(future)
[13:21:48.617]                     invisible(future)
[13:21:48.617]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:48.617]                 }
[13:21:48.617]             }
[13:21:48.617]         }
[13:21:48.617]     })
[13:21:48.617]     if (TRUE) {
[13:21:48.617]         base::sink(type = "output", split = FALSE)
[13:21:48.617]         if (TRUE) {
[13:21:48.617]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:48.617]         }
[13:21:48.617]         else {
[13:21:48.617]             ...future.result["stdout"] <- base::list(NULL)
[13:21:48.617]         }
[13:21:48.617]         base::close(...future.stdout)
[13:21:48.617]         ...future.stdout <- NULL
[13:21:48.617]     }
[13:21:48.617]     ...future.result$conditions <- ...future.conditions
[13:21:48.617]     ...future.result$finished <- base::Sys.time()
[13:21:48.617]     ...future.result
[13:21:48.617] }
[13:21:48.621] MultisessionFuture started
[13:21:48.621] - Launch lazy future ... done
[13:21:48.621] run() for ‘MultisessionFuture’ ... done
[13:21:49.179] receiveMessageFromWorker() for ClusterFuture ...
[13:21:49.179] - Validating connection of MultisessionFuture
[13:21:49.180] - received message: FutureResult
[13:21:49.180] - Received FutureResult
[13:21:49.180] - Erased future from FutureRegistry
[13:21:49.180] result() for ClusterFuture ...
[13:21:49.180] - result already collected: FutureResult
[13:21:49.180] result() for ClusterFuture ... done
[13:21:49.180] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:49.180] A MultisessionFuture was resolved (result was not collected)
[13:21:49.180] getGlobalsAndPackages() ...
[13:21:49.181] Searching for globals...
[13:21:49.182] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:21:49.182] Searching for globals ... DONE
[13:21:49.182] Resolving globals: FALSE
[13:21:49.182] 
[13:21:49.182] 
[13:21:49.182] getGlobalsAndPackages() ... DONE
[13:21:49.183] run() for ‘Future’ ...
[13:21:49.183] - state: ‘created’
[13:21:49.183] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:49.197] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:49.197] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:49.198]   - Field: ‘node’
[13:21:49.198]   - Field: ‘label’
[13:21:49.198]   - Field: ‘local’
[13:21:49.198]   - Field: ‘owner’
[13:21:49.198]   - Field: ‘envir’
[13:21:49.198]   - Field: ‘workers’
[13:21:49.198]   - Field: ‘packages’
[13:21:49.198]   - Field: ‘gc’
[13:21:49.198]   - Field: ‘conditions’
[13:21:49.198]   - Field: ‘persistent’
[13:21:49.198]   - Field: ‘expr’
[13:21:49.199]   - Field: ‘uuid’
[13:21:49.199]   - Field: ‘seed’
[13:21:49.199]   - Field: ‘version’
[13:21:49.199]   - Field: ‘result’
[13:21:49.199]   - Field: ‘asynchronous’
[13:21:49.199]   - Field: ‘calls’
[13:21:49.199]   - Field: ‘globals’
[13:21:49.199]   - Field: ‘stdout’
[13:21:49.199]   - Field: ‘earlySignal’
[13:21:49.199]   - Field: ‘lazy’
[13:21:49.199]   - Field: ‘state’
[13:21:49.200] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:49.200] - Launch lazy future ...
[13:21:49.200] Packages needed by the future expression (n = 0): <none>
[13:21:49.200] Packages needed by future strategies (n = 0): <none>
[13:21:49.201] {
[13:21:49.201]     {
[13:21:49.201]         {
[13:21:49.201]             ...future.startTime <- base::Sys.time()
[13:21:49.201]             {
[13:21:49.201]                 {
[13:21:49.201]                   {
[13:21:49.201]                     {
[13:21:49.201]                       base::local({
[13:21:49.201]                         has_future <- base::requireNamespace("future", 
[13:21:49.201]                           quietly = TRUE)
[13:21:49.201]                         if (has_future) {
[13:21:49.201]                           ns <- base::getNamespace("future")
[13:21:49.201]                           version <- ns[[".package"]][["version"]]
[13:21:49.201]                           if (is.null(version)) 
[13:21:49.201]                             version <- utils::packageVersion("future")
[13:21:49.201]                         }
[13:21:49.201]                         else {
[13:21:49.201]                           version <- NULL
[13:21:49.201]                         }
[13:21:49.201]                         if (!has_future || version < "1.8.0") {
[13:21:49.201]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:49.201]                             "", base::R.version$version.string), 
[13:21:49.201]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:49.201]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:49.201]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:49.201]                               "release", "version")], collapse = " "), 
[13:21:49.201]                             hostname = base::Sys.info()[["nodename"]])
[13:21:49.201]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:49.201]                             info)
[13:21:49.201]                           info <- base::paste(info, collapse = "; ")
[13:21:49.201]                           if (!has_future) {
[13:21:49.201]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:49.201]                               info)
[13:21:49.201]                           }
[13:21:49.201]                           else {
[13:21:49.201]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:49.201]                               info, version)
[13:21:49.201]                           }
[13:21:49.201]                           base::stop(msg)
[13:21:49.201]                         }
[13:21:49.201]                       })
[13:21:49.201]                     }
[13:21:49.201]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:49.201]                     base::options(mc.cores = 1L)
[13:21:49.201]                   }
[13:21:49.201]                   options(future.plan = NULL)
[13:21:49.201]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:49.201]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:49.201]                 }
[13:21:49.201]                 ...future.workdir <- getwd()
[13:21:49.201]             }
[13:21:49.201]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:49.201]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:49.201]         }
[13:21:49.201]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:49.201]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:49.201]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:49.201]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:49.201]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:49.201]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:49.201]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:49.201]             base::names(...future.oldOptions))
[13:21:49.201]     }
[13:21:49.201]     if (FALSE) {
[13:21:49.201]     }
[13:21:49.201]     else {
[13:21:49.201]         if (TRUE) {
[13:21:49.201]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:49.201]                 open = "w")
[13:21:49.201]         }
[13:21:49.201]         else {
[13:21:49.201]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:49.201]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:49.201]         }
[13:21:49.201]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:49.201]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:49.201]             base::sink(type = "output", split = FALSE)
[13:21:49.201]             base::close(...future.stdout)
[13:21:49.201]         }, add = TRUE)
[13:21:49.201]     }
[13:21:49.201]     ...future.frame <- base::sys.nframe()
[13:21:49.201]     ...future.conditions <- base::list()
[13:21:49.201]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:49.201]     if (FALSE) {
[13:21:49.201]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:49.201]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:49.201]     }
[13:21:49.201]     ...future.result <- base::tryCatch({
[13:21:49.201]         base::withCallingHandlers({
[13:21:49.201]             ...future.value <- base::withVisible(base::local({
[13:21:49.201]                 ...future.makeSendCondition <- local({
[13:21:49.201]                   sendCondition <- NULL
[13:21:49.201]                   function(frame = 1L) {
[13:21:49.201]                     if (is.function(sendCondition)) 
[13:21:49.201]                       return(sendCondition)
[13:21:49.201]                     ns <- getNamespace("parallel")
[13:21:49.201]                     if (exists("sendData", mode = "function", 
[13:21:49.201]                       envir = ns)) {
[13:21:49.201]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:49.201]                         envir = ns)
[13:21:49.201]                       envir <- sys.frame(frame)
[13:21:49.201]                       master <- NULL
[13:21:49.201]                       while (!identical(envir, .GlobalEnv) && 
[13:21:49.201]                         !identical(envir, emptyenv())) {
[13:21:49.201]                         if (exists("master", mode = "list", envir = envir, 
[13:21:49.201]                           inherits = FALSE)) {
[13:21:49.201]                           master <- get("master", mode = "list", 
[13:21:49.201]                             envir = envir, inherits = FALSE)
[13:21:49.201]                           if (inherits(master, c("SOCKnode", 
[13:21:49.201]                             "SOCK0node"))) {
[13:21:49.201]                             sendCondition <<- function(cond) {
[13:21:49.201]                               data <- list(type = "VALUE", value = cond, 
[13:21:49.201]                                 success = TRUE)
[13:21:49.201]                               parallel_sendData(master, data)
[13:21:49.201]                             }
[13:21:49.201]                             return(sendCondition)
[13:21:49.201]                           }
[13:21:49.201]                         }
[13:21:49.201]                         frame <- frame + 1L
[13:21:49.201]                         envir <- sys.frame(frame)
[13:21:49.201]                       }
[13:21:49.201]                     }
[13:21:49.201]                     sendCondition <<- function(cond) NULL
[13:21:49.201]                   }
[13:21:49.201]                 })
[13:21:49.201]                 withCallingHandlers({
[13:21:49.201]                   {
[13:21:49.201]                     Sys.sleep(0.5)
[13:21:49.201]                     list(a = 1, b = 42L)
[13:21:49.201]                   }
[13:21:49.201]                 }, immediateCondition = function(cond) {
[13:21:49.201]                   sendCondition <- ...future.makeSendCondition()
[13:21:49.201]                   sendCondition(cond)
[13:21:49.201]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:49.201]                   {
[13:21:49.201]                     inherits <- base::inherits
[13:21:49.201]                     invokeRestart <- base::invokeRestart
[13:21:49.201]                     is.null <- base::is.null
[13:21:49.201]                     muffled <- FALSE
[13:21:49.201]                     if (inherits(cond, "message")) {
[13:21:49.201]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:49.201]                       if (muffled) 
[13:21:49.201]                         invokeRestart("muffleMessage")
[13:21:49.201]                     }
[13:21:49.201]                     else if (inherits(cond, "warning")) {
[13:21:49.201]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:49.201]                       if (muffled) 
[13:21:49.201]                         invokeRestart("muffleWarning")
[13:21:49.201]                     }
[13:21:49.201]                     else if (inherits(cond, "condition")) {
[13:21:49.201]                       if (!is.null(pattern)) {
[13:21:49.201]                         computeRestarts <- base::computeRestarts
[13:21:49.201]                         grepl <- base::grepl
[13:21:49.201]                         restarts <- computeRestarts(cond)
[13:21:49.201]                         for (restart in restarts) {
[13:21:49.201]                           name <- restart$name
[13:21:49.201]                           if (is.null(name)) 
[13:21:49.201]                             next
[13:21:49.201]                           if (!grepl(pattern, name)) 
[13:21:49.201]                             next
[13:21:49.201]                           invokeRestart(restart)
[13:21:49.201]                           muffled <- TRUE
[13:21:49.201]                           break
[13:21:49.201]                         }
[13:21:49.201]                       }
[13:21:49.201]                     }
[13:21:49.201]                     invisible(muffled)
[13:21:49.201]                   }
[13:21:49.201]                   muffleCondition(cond)
[13:21:49.201]                 })
[13:21:49.201]             }))
[13:21:49.201]             future::FutureResult(value = ...future.value$value, 
[13:21:49.201]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:49.201]                   ...future.rng), globalenv = if (FALSE) 
[13:21:49.201]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:49.201]                     ...future.globalenv.names))
[13:21:49.201]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:49.201]         }, condition = base::local({
[13:21:49.201]             c <- base::c
[13:21:49.201]             inherits <- base::inherits
[13:21:49.201]             invokeRestart <- base::invokeRestart
[13:21:49.201]             length <- base::length
[13:21:49.201]             list <- base::list
[13:21:49.201]             seq.int <- base::seq.int
[13:21:49.201]             signalCondition <- base::signalCondition
[13:21:49.201]             sys.calls <- base::sys.calls
[13:21:49.201]             `[[` <- base::`[[`
[13:21:49.201]             `+` <- base::`+`
[13:21:49.201]             `<<-` <- base::`<<-`
[13:21:49.201]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:49.201]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:49.201]                   3L)]
[13:21:49.201]             }
[13:21:49.201]             function(cond) {
[13:21:49.201]                 is_error <- inherits(cond, "error")
[13:21:49.201]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:49.201]                   NULL)
[13:21:49.201]                 if (is_error) {
[13:21:49.201]                   sessionInformation <- function() {
[13:21:49.201]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:49.201]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:49.201]                       search = base::search(), system = base::Sys.info())
[13:21:49.201]                   }
[13:21:49.201]                   ...future.conditions[[length(...future.conditions) + 
[13:21:49.201]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:49.201]                     cond$call), session = sessionInformation(), 
[13:21:49.201]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:49.201]                   signalCondition(cond)
[13:21:49.201]                 }
[13:21:49.201]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:49.201]                 "immediateCondition"))) {
[13:21:49.201]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:49.201]                   ...future.conditions[[length(...future.conditions) + 
[13:21:49.201]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:49.201]                   if (TRUE && !signal) {
[13:21:49.201]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:49.201]                     {
[13:21:49.201]                       inherits <- base::inherits
[13:21:49.201]                       invokeRestart <- base::invokeRestart
[13:21:49.201]                       is.null <- base::is.null
[13:21:49.201]                       muffled <- FALSE
[13:21:49.201]                       if (inherits(cond, "message")) {
[13:21:49.201]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:49.201]                         if (muffled) 
[13:21:49.201]                           invokeRestart("muffleMessage")
[13:21:49.201]                       }
[13:21:49.201]                       else if (inherits(cond, "warning")) {
[13:21:49.201]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:49.201]                         if (muffled) 
[13:21:49.201]                           invokeRestart("muffleWarning")
[13:21:49.201]                       }
[13:21:49.201]                       else if (inherits(cond, "condition")) {
[13:21:49.201]                         if (!is.null(pattern)) {
[13:21:49.201]                           computeRestarts <- base::computeRestarts
[13:21:49.201]                           grepl <- base::grepl
[13:21:49.201]                           restarts <- computeRestarts(cond)
[13:21:49.201]                           for (restart in restarts) {
[13:21:49.201]                             name <- restart$name
[13:21:49.201]                             if (is.null(name)) 
[13:21:49.201]                               next
[13:21:49.201]                             if (!grepl(pattern, name)) 
[13:21:49.201]                               next
[13:21:49.201]                             invokeRestart(restart)
[13:21:49.201]                             muffled <- TRUE
[13:21:49.201]                             break
[13:21:49.201]                           }
[13:21:49.201]                         }
[13:21:49.201]                       }
[13:21:49.201]                       invisible(muffled)
[13:21:49.201]                     }
[13:21:49.201]                     muffleCondition(cond, pattern = "^muffle")
[13:21:49.201]                   }
[13:21:49.201]                 }
[13:21:49.201]                 else {
[13:21:49.201]                   if (TRUE) {
[13:21:49.201]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:49.201]                     {
[13:21:49.201]                       inherits <- base::inherits
[13:21:49.201]                       invokeRestart <- base::invokeRestart
[13:21:49.201]                       is.null <- base::is.null
[13:21:49.201]                       muffled <- FALSE
[13:21:49.201]                       if (inherits(cond, "message")) {
[13:21:49.201]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:49.201]                         if (muffled) 
[13:21:49.201]                           invokeRestart("muffleMessage")
[13:21:49.201]                       }
[13:21:49.201]                       else if (inherits(cond, "warning")) {
[13:21:49.201]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:49.201]                         if (muffled) 
[13:21:49.201]                           invokeRestart("muffleWarning")
[13:21:49.201]                       }
[13:21:49.201]                       else if (inherits(cond, "condition")) {
[13:21:49.201]                         if (!is.null(pattern)) {
[13:21:49.201]                           computeRestarts <- base::computeRestarts
[13:21:49.201]                           grepl <- base::grepl
[13:21:49.201]                           restarts <- computeRestarts(cond)
[13:21:49.201]                           for (restart in restarts) {
[13:21:49.201]                             name <- restart$name
[13:21:49.201]                             if (is.null(name)) 
[13:21:49.201]                               next
[13:21:49.201]                             if (!grepl(pattern, name)) 
[13:21:49.201]                               next
[13:21:49.201]                             invokeRestart(restart)
[13:21:49.201]                             muffled <- TRUE
[13:21:49.201]                             break
[13:21:49.201]                           }
[13:21:49.201]                         }
[13:21:49.201]                       }
[13:21:49.201]                       invisible(muffled)
[13:21:49.201]                     }
[13:21:49.201]                     muffleCondition(cond, pattern = "^muffle")
[13:21:49.201]                   }
[13:21:49.201]                 }
[13:21:49.201]             }
[13:21:49.201]         }))
[13:21:49.201]     }, error = function(ex) {
[13:21:49.201]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:49.201]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:49.201]                 ...future.rng), started = ...future.startTime, 
[13:21:49.201]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:49.201]             version = "1.8"), class = "FutureResult")
[13:21:49.201]     }, finally = {
[13:21:49.201]         if (!identical(...future.workdir, getwd())) 
[13:21:49.201]             setwd(...future.workdir)
[13:21:49.201]         {
[13:21:49.201]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:49.201]                 ...future.oldOptions$nwarnings <- NULL
[13:21:49.201]             }
[13:21:49.201]             base::options(...future.oldOptions)
[13:21:49.201]             if (.Platform$OS.type == "windows") {
[13:21:49.201]                 old_names <- names(...future.oldEnvVars)
[13:21:49.201]                 envs <- base::Sys.getenv()
[13:21:49.201]                 names <- names(envs)
[13:21:49.201]                 common <- intersect(names, old_names)
[13:21:49.201]                 added <- setdiff(names, old_names)
[13:21:49.201]                 removed <- setdiff(old_names, names)
[13:21:49.201]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:49.201]                   envs[common]]
[13:21:49.201]                 NAMES <- toupper(changed)
[13:21:49.201]                 args <- list()
[13:21:49.201]                 for (kk in seq_along(NAMES)) {
[13:21:49.201]                   name <- changed[[kk]]
[13:21:49.201]                   NAME <- NAMES[[kk]]
[13:21:49.201]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:49.201]                     next
[13:21:49.201]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:49.201]                 }
[13:21:49.201]                 NAMES <- toupper(added)
[13:21:49.201]                 for (kk in seq_along(NAMES)) {
[13:21:49.201]                   name <- added[[kk]]
[13:21:49.201]                   NAME <- NAMES[[kk]]
[13:21:49.201]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:49.201]                     next
[13:21:49.201]                   args[[name]] <- ""
[13:21:49.201]                 }
[13:21:49.201]                 NAMES <- toupper(removed)
[13:21:49.201]                 for (kk in seq_along(NAMES)) {
[13:21:49.201]                   name <- removed[[kk]]
[13:21:49.201]                   NAME <- NAMES[[kk]]
[13:21:49.201]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:49.201]                     next
[13:21:49.201]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:49.201]                 }
[13:21:49.201]                 if (length(args) > 0) 
[13:21:49.201]                   base::do.call(base::Sys.setenv, args = args)
[13:21:49.201]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:49.201]             }
[13:21:49.201]             else {
[13:21:49.201]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:49.201]             }
[13:21:49.201]             {
[13:21:49.201]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:49.201]                   0L) {
[13:21:49.201]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:49.201]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:49.201]                   base::options(opts)
[13:21:49.201]                 }
[13:21:49.201]                 {
[13:21:49.201]                   {
[13:21:49.201]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:49.201]                     NULL
[13:21:49.201]                   }
[13:21:49.201]                   options(future.plan = NULL)
[13:21:49.201]                   if (is.na(NA_character_)) 
[13:21:49.201]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:49.201]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:49.201]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:49.201]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:49.201]                     envir = parent.frame()) 
[13:21:49.201]                   {
[13:21:49.201]                     if (is.function(workers)) 
[13:21:49.201]                       workers <- workers()
[13:21:49.201]                     workers <- structure(as.integer(workers), 
[13:21:49.201]                       class = class(workers))
[13:21:49.201]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:49.201]                       workers >= 1)
[13:21:49.201]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:49.201]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:49.201]                     }
[13:21:49.201]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:49.201]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:49.201]                       envir = envir)
[13:21:49.201]                     if (!future$lazy) 
[13:21:49.201]                       future <- run(future)
[13:21:49.201]                     invisible(future)
[13:21:49.201]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:49.201]                 }
[13:21:49.201]             }
[13:21:49.201]         }
[13:21:49.201]     })
[13:21:49.201]     if (TRUE) {
[13:21:49.201]         base::sink(type = "output", split = FALSE)
[13:21:49.201]         if (TRUE) {
[13:21:49.201]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:49.201]         }
[13:21:49.201]         else {
[13:21:49.201]             ...future.result["stdout"] <- base::list(NULL)
[13:21:49.201]         }
[13:21:49.201]         base::close(...future.stdout)
[13:21:49.201]         ...future.stdout <- NULL
[13:21:49.201]     }
[13:21:49.201]     ...future.result$conditions <- ...future.conditions
[13:21:49.201]     ...future.result$finished <- base::Sys.time()
[13:21:49.201]     ...future.result
[13:21:49.201] }
[13:21:49.204] MultisessionFuture started
[13:21:49.204] - Launch lazy future ... done
[13:21:49.204] run() for ‘MultisessionFuture’ ... done
[13:21:49.750] receiveMessageFromWorker() for ClusterFuture ...
[13:21:49.751] - Validating connection of MultisessionFuture
[13:21:49.751] - received message: FutureResult
[13:21:49.751] - Received FutureResult
[13:21:49.751] - Erased future from FutureRegistry
[13:21:49.751] result() for ClusterFuture ...
[13:21:49.751] - result already collected: FutureResult
[13:21:49.751] result() for ClusterFuture ... done
[13:21:49.751] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:49.752] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[13:21:49.752] getGlobalsAndPackages() ...
[13:21:49.752] Searching for globals...
[13:21:49.752] - globals found: [2] ‘list’, ‘stop’
[13:21:49.753] Searching for globals ... DONE
[13:21:49.753] Resolving globals: FALSE
[13:21:49.753] 
[13:21:49.753] 
[13:21:49.753] getGlobalsAndPackages() ... DONE
[13:21:49.753] run() for ‘Future’ ...
[13:21:49.754] - state: ‘created’
[13:21:49.754] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:49.768] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:49.768] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:49.768]   - Field: ‘node’
[13:21:49.768]   - Field: ‘label’
[13:21:49.768]   - Field: ‘local’
[13:21:49.768]   - Field: ‘owner’
[13:21:49.768]   - Field: ‘envir’
[13:21:49.769]   - Field: ‘workers’
[13:21:49.769]   - Field: ‘packages’
[13:21:49.769]   - Field: ‘gc’
[13:21:49.769]   - Field: ‘conditions’
[13:21:49.769]   - Field: ‘persistent’
[13:21:49.769]   - Field: ‘expr’
[13:21:49.769]   - Field: ‘uuid’
[13:21:49.769]   - Field: ‘seed’
[13:21:49.769]   - Field: ‘version’
[13:21:49.769]   - Field: ‘result’
[13:21:49.770]   - Field: ‘asynchronous’
[13:21:49.770]   - Field: ‘calls’
[13:21:49.770]   - Field: ‘globals’
[13:21:49.770]   - Field: ‘stdout’
[13:21:49.770]   - Field: ‘earlySignal’
[13:21:49.770]   - Field: ‘lazy’
[13:21:49.770]   - Field: ‘state’
[13:21:49.770] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:49.770] - Launch lazy future ...
[13:21:49.770] Packages needed by the future expression (n = 0): <none>
[13:21:49.771] Packages needed by future strategies (n = 0): <none>
[13:21:49.771] {
[13:21:49.771]     {
[13:21:49.771]         {
[13:21:49.771]             ...future.startTime <- base::Sys.time()
[13:21:49.771]             {
[13:21:49.771]                 {
[13:21:49.771]                   {
[13:21:49.771]                     {
[13:21:49.771]                       base::local({
[13:21:49.771]                         has_future <- base::requireNamespace("future", 
[13:21:49.771]                           quietly = TRUE)
[13:21:49.771]                         if (has_future) {
[13:21:49.771]                           ns <- base::getNamespace("future")
[13:21:49.771]                           version <- ns[[".package"]][["version"]]
[13:21:49.771]                           if (is.null(version)) 
[13:21:49.771]                             version <- utils::packageVersion("future")
[13:21:49.771]                         }
[13:21:49.771]                         else {
[13:21:49.771]                           version <- NULL
[13:21:49.771]                         }
[13:21:49.771]                         if (!has_future || version < "1.8.0") {
[13:21:49.771]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:49.771]                             "", base::R.version$version.string), 
[13:21:49.771]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:49.771]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:49.771]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:49.771]                               "release", "version")], collapse = " "), 
[13:21:49.771]                             hostname = base::Sys.info()[["nodename"]])
[13:21:49.771]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:49.771]                             info)
[13:21:49.771]                           info <- base::paste(info, collapse = "; ")
[13:21:49.771]                           if (!has_future) {
[13:21:49.771]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:49.771]                               info)
[13:21:49.771]                           }
[13:21:49.771]                           else {
[13:21:49.771]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:49.771]                               info, version)
[13:21:49.771]                           }
[13:21:49.771]                           base::stop(msg)
[13:21:49.771]                         }
[13:21:49.771]                       })
[13:21:49.771]                     }
[13:21:49.771]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:49.771]                     base::options(mc.cores = 1L)
[13:21:49.771]                   }
[13:21:49.771]                   options(future.plan = NULL)
[13:21:49.771]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:49.771]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:49.771]                 }
[13:21:49.771]                 ...future.workdir <- getwd()
[13:21:49.771]             }
[13:21:49.771]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:49.771]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:49.771]         }
[13:21:49.771]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:49.771]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:49.771]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:49.771]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:49.771]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:49.771]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:49.771]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:49.771]             base::names(...future.oldOptions))
[13:21:49.771]     }
[13:21:49.771]     if (FALSE) {
[13:21:49.771]     }
[13:21:49.771]     else {
[13:21:49.771]         if (TRUE) {
[13:21:49.771]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:49.771]                 open = "w")
[13:21:49.771]         }
[13:21:49.771]         else {
[13:21:49.771]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:49.771]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:49.771]         }
[13:21:49.771]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:49.771]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:49.771]             base::sink(type = "output", split = FALSE)
[13:21:49.771]             base::close(...future.stdout)
[13:21:49.771]         }, add = TRUE)
[13:21:49.771]     }
[13:21:49.771]     ...future.frame <- base::sys.nframe()
[13:21:49.771]     ...future.conditions <- base::list()
[13:21:49.771]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:49.771]     if (FALSE) {
[13:21:49.771]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:49.771]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:49.771]     }
[13:21:49.771]     ...future.result <- base::tryCatch({
[13:21:49.771]         base::withCallingHandlers({
[13:21:49.771]             ...future.value <- base::withVisible(base::local({
[13:21:49.771]                 ...future.makeSendCondition <- local({
[13:21:49.771]                   sendCondition <- NULL
[13:21:49.771]                   function(frame = 1L) {
[13:21:49.771]                     if (is.function(sendCondition)) 
[13:21:49.771]                       return(sendCondition)
[13:21:49.771]                     ns <- getNamespace("parallel")
[13:21:49.771]                     if (exists("sendData", mode = "function", 
[13:21:49.771]                       envir = ns)) {
[13:21:49.771]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:49.771]                         envir = ns)
[13:21:49.771]                       envir <- sys.frame(frame)
[13:21:49.771]                       master <- NULL
[13:21:49.771]                       while (!identical(envir, .GlobalEnv) && 
[13:21:49.771]                         !identical(envir, emptyenv())) {
[13:21:49.771]                         if (exists("master", mode = "list", envir = envir, 
[13:21:49.771]                           inherits = FALSE)) {
[13:21:49.771]                           master <- get("master", mode = "list", 
[13:21:49.771]                             envir = envir, inherits = FALSE)
[13:21:49.771]                           if (inherits(master, c("SOCKnode", 
[13:21:49.771]                             "SOCK0node"))) {
[13:21:49.771]                             sendCondition <<- function(cond) {
[13:21:49.771]                               data <- list(type = "VALUE", value = cond, 
[13:21:49.771]                                 success = TRUE)
[13:21:49.771]                               parallel_sendData(master, data)
[13:21:49.771]                             }
[13:21:49.771]                             return(sendCondition)
[13:21:49.771]                           }
[13:21:49.771]                         }
[13:21:49.771]                         frame <- frame + 1L
[13:21:49.771]                         envir <- sys.frame(frame)
[13:21:49.771]                       }
[13:21:49.771]                     }
[13:21:49.771]                     sendCondition <<- function(cond) NULL
[13:21:49.771]                   }
[13:21:49.771]                 })
[13:21:49.771]                 withCallingHandlers({
[13:21:49.771]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:21:49.771]                 }, immediateCondition = function(cond) {
[13:21:49.771]                   sendCondition <- ...future.makeSendCondition()
[13:21:49.771]                   sendCondition(cond)
[13:21:49.771]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:49.771]                   {
[13:21:49.771]                     inherits <- base::inherits
[13:21:49.771]                     invokeRestart <- base::invokeRestart
[13:21:49.771]                     is.null <- base::is.null
[13:21:49.771]                     muffled <- FALSE
[13:21:49.771]                     if (inherits(cond, "message")) {
[13:21:49.771]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:49.771]                       if (muffled) 
[13:21:49.771]                         invokeRestart("muffleMessage")
[13:21:49.771]                     }
[13:21:49.771]                     else if (inherits(cond, "warning")) {
[13:21:49.771]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:49.771]                       if (muffled) 
[13:21:49.771]                         invokeRestart("muffleWarning")
[13:21:49.771]                     }
[13:21:49.771]                     else if (inherits(cond, "condition")) {
[13:21:49.771]                       if (!is.null(pattern)) {
[13:21:49.771]                         computeRestarts <- base::computeRestarts
[13:21:49.771]                         grepl <- base::grepl
[13:21:49.771]                         restarts <- computeRestarts(cond)
[13:21:49.771]                         for (restart in restarts) {
[13:21:49.771]                           name <- restart$name
[13:21:49.771]                           if (is.null(name)) 
[13:21:49.771]                             next
[13:21:49.771]                           if (!grepl(pattern, name)) 
[13:21:49.771]                             next
[13:21:49.771]                           invokeRestart(restart)
[13:21:49.771]                           muffled <- TRUE
[13:21:49.771]                           break
[13:21:49.771]                         }
[13:21:49.771]                       }
[13:21:49.771]                     }
[13:21:49.771]                     invisible(muffled)
[13:21:49.771]                   }
[13:21:49.771]                   muffleCondition(cond)
[13:21:49.771]                 })
[13:21:49.771]             }))
[13:21:49.771]             future::FutureResult(value = ...future.value$value, 
[13:21:49.771]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:49.771]                   ...future.rng), globalenv = if (FALSE) 
[13:21:49.771]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:49.771]                     ...future.globalenv.names))
[13:21:49.771]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:49.771]         }, condition = base::local({
[13:21:49.771]             c <- base::c
[13:21:49.771]             inherits <- base::inherits
[13:21:49.771]             invokeRestart <- base::invokeRestart
[13:21:49.771]             length <- base::length
[13:21:49.771]             list <- base::list
[13:21:49.771]             seq.int <- base::seq.int
[13:21:49.771]             signalCondition <- base::signalCondition
[13:21:49.771]             sys.calls <- base::sys.calls
[13:21:49.771]             `[[` <- base::`[[`
[13:21:49.771]             `+` <- base::`+`
[13:21:49.771]             `<<-` <- base::`<<-`
[13:21:49.771]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:49.771]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:49.771]                   3L)]
[13:21:49.771]             }
[13:21:49.771]             function(cond) {
[13:21:49.771]                 is_error <- inherits(cond, "error")
[13:21:49.771]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:49.771]                   NULL)
[13:21:49.771]                 if (is_error) {
[13:21:49.771]                   sessionInformation <- function() {
[13:21:49.771]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:49.771]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:49.771]                       search = base::search(), system = base::Sys.info())
[13:21:49.771]                   }
[13:21:49.771]                   ...future.conditions[[length(...future.conditions) + 
[13:21:49.771]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:49.771]                     cond$call), session = sessionInformation(), 
[13:21:49.771]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:49.771]                   signalCondition(cond)
[13:21:49.771]                 }
[13:21:49.771]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:49.771]                 "immediateCondition"))) {
[13:21:49.771]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:49.771]                   ...future.conditions[[length(...future.conditions) + 
[13:21:49.771]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:49.771]                   if (TRUE && !signal) {
[13:21:49.771]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:49.771]                     {
[13:21:49.771]                       inherits <- base::inherits
[13:21:49.771]                       invokeRestart <- base::invokeRestart
[13:21:49.771]                       is.null <- base::is.null
[13:21:49.771]                       muffled <- FALSE
[13:21:49.771]                       if (inherits(cond, "message")) {
[13:21:49.771]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:49.771]                         if (muffled) 
[13:21:49.771]                           invokeRestart("muffleMessage")
[13:21:49.771]                       }
[13:21:49.771]                       else if (inherits(cond, "warning")) {
[13:21:49.771]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:49.771]                         if (muffled) 
[13:21:49.771]                           invokeRestart("muffleWarning")
[13:21:49.771]                       }
[13:21:49.771]                       else if (inherits(cond, "condition")) {
[13:21:49.771]                         if (!is.null(pattern)) {
[13:21:49.771]                           computeRestarts <- base::computeRestarts
[13:21:49.771]                           grepl <- base::grepl
[13:21:49.771]                           restarts <- computeRestarts(cond)
[13:21:49.771]                           for (restart in restarts) {
[13:21:49.771]                             name <- restart$name
[13:21:49.771]                             if (is.null(name)) 
[13:21:49.771]                               next
[13:21:49.771]                             if (!grepl(pattern, name)) 
[13:21:49.771]                               next
[13:21:49.771]                             invokeRestart(restart)
[13:21:49.771]                             muffled <- TRUE
[13:21:49.771]                             break
[13:21:49.771]                           }
[13:21:49.771]                         }
[13:21:49.771]                       }
[13:21:49.771]                       invisible(muffled)
[13:21:49.771]                     }
[13:21:49.771]                     muffleCondition(cond, pattern = "^muffle")
[13:21:49.771]                   }
[13:21:49.771]                 }
[13:21:49.771]                 else {
[13:21:49.771]                   if (TRUE) {
[13:21:49.771]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:49.771]                     {
[13:21:49.771]                       inherits <- base::inherits
[13:21:49.771]                       invokeRestart <- base::invokeRestart
[13:21:49.771]                       is.null <- base::is.null
[13:21:49.771]                       muffled <- FALSE
[13:21:49.771]                       if (inherits(cond, "message")) {
[13:21:49.771]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:49.771]                         if (muffled) 
[13:21:49.771]                           invokeRestart("muffleMessage")
[13:21:49.771]                       }
[13:21:49.771]                       else if (inherits(cond, "warning")) {
[13:21:49.771]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:49.771]                         if (muffled) 
[13:21:49.771]                           invokeRestart("muffleWarning")
[13:21:49.771]                       }
[13:21:49.771]                       else if (inherits(cond, "condition")) {
[13:21:49.771]                         if (!is.null(pattern)) {
[13:21:49.771]                           computeRestarts <- base::computeRestarts
[13:21:49.771]                           grepl <- base::grepl
[13:21:49.771]                           restarts <- computeRestarts(cond)
[13:21:49.771]                           for (restart in restarts) {
[13:21:49.771]                             name <- restart$name
[13:21:49.771]                             if (is.null(name)) 
[13:21:49.771]                               next
[13:21:49.771]                             if (!grepl(pattern, name)) 
[13:21:49.771]                               next
[13:21:49.771]                             invokeRestart(restart)
[13:21:49.771]                             muffled <- TRUE
[13:21:49.771]                             break
[13:21:49.771]                           }
[13:21:49.771]                         }
[13:21:49.771]                       }
[13:21:49.771]                       invisible(muffled)
[13:21:49.771]                     }
[13:21:49.771]                     muffleCondition(cond, pattern = "^muffle")
[13:21:49.771]                   }
[13:21:49.771]                 }
[13:21:49.771]             }
[13:21:49.771]         }))
[13:21:49.771]     }, error = function(ex) {
[13:21:49.771]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:49.771]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:49.771]                 ...future.rng), started = ...future.startTime, 
[13:21:49.771]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:49.771]             version = "1.8"), class = "FutureResult")
[13:21:49.771]     }, finally = {
[13:21:49.771]         if (!identical(...future.workdir, getwd())) 
[13:21:49.771]             setwd(...future.workdir)
[13:21:49.771]         {
[13:21:49.771]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:49.771]                 ...future.oldOptions$nwarnings <- NULL
[13:21:49.771]             }
[13:21:49.771]             base::options(...future.oldOptions)
[13:21:49.771]             if (.Platform$OS.type == "windows") {
[13:21:49.771]                 old_names <- names(...future.oldEnvVars)
[13:21:49.771]                 envs <- base::Sys.getenv()
[13:21:49.771]                 names <- names(envs)
[13:21:49.771]                 common <- intersect(names, old_names)
[13:21:49.771]                 added <- setdiff(names, old_names)
[13:21:49.771]                 removed <- setdiff(old_names, names)
[13:21:49.771]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:49.771]                   envs[common]]
[13:21:49.771]                 NAMES <- toupper(changed)
[13:21:49.771]                 args <- list()
[13:21:49.771]                 for (kk in seq_along(NAMES)) {
[13:21:49.771]                   name <- changed[[kk]]
[13:21:49.771]                   NAME <- NAMES[[kk]]
[13:21:49.771]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:49.771]                     next
[13:21:49.771]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:49.771]                 }
[13:21:49.771]                 NAMES <- toupper(added)
[13:21:49.771]                 for (kk in seq_along(NAMES)) {
[13:21:49.771]                   name <- added[[kk]]
[13:21:49.771]                   NAME <- NAMES[[kk]]
[13:21:49.771]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:49.771]                     next
[13:21:49.771]                   args[[name]] <- ""
[13:21:49.771]                 }
[13:21:49.771]                 NAMES <- toupper(removed)
[13:21:49.771]                 for (kk in seq_along(NAMES)) {
[13:21:49.771]                   name <- removed[[kk]]
[13:21:49.771]                   NAME <- NAMES[[kk]]
[13:21:49.771]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:49.771]                     next
[13:21:49.771]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:49.771]                 }
[13:21:49.771]                 if (length(args) > 0) 
[13:21:49.771]                   base::do.call(base::Sys.setenv, args = args)
[13:21:49.771]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:49.771]             }
[13:21:49.771]             else {
[13:21:49.771]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:49.771]             }
[13:21:49.771]             {
[13:21:49.771]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:49.771]                   0L) {
[13:21:49.771]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:49.771]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:49.771]                   base::options(opts)
[13:21:49.771]                 }
[13:21:49.771]                 {
[13:21:49.771]                   {
[13:21:49.771]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:49.771]                     NULL
[13:21:49.771]                   }
[13:21:49.771]                   options(future.plan = NULL)
[13:21:49.771]                   if (is.na(NA_character_)) 
[13:21:49.771]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:49.771]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:49.771]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:49.771]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:49.771]                     envir = parent.frame()) 
[13:21:49.771]                   {
[13:21:49.771]                     if (is.function(workers)) 
[13:21:49.771]                       workers <- workers()
[13:21:49.771]                     workers <- structure(as.integer(workers), 
[13:21:49.771]                       class = class(workers))
[13:21:49.771]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:49.771]                       workers >= 1)
[13:21:49.771]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:49.771]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:49.771]                     }
[13:21:49.771]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:49.771]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:49.771]                       envir = envir)
[13:21:49.771]                     if (!future$lazy) 
[13:21:49.771]                       future <- run(future)
[13:21:49.771]                     invisible(future)
[13:21:49.771]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:49.771]                 }
[13:21:49.771]             }
[13:21:49.771]         }
[13:21:49.771]     })
[13:21:49.771]     if (TRUE) {
[13:21:49.771]         base::sink(type = "output", split = FALSE)
[13:21:49.771]         if (TRUE) {
[13:21:49.771]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:49.771]         }
[13:21:49.771]         else {
[13:21:49.771]             ...future.result["stdout"] <- base::list(NULL)
[13:21:49.771]         }
[13:21:49.771]         base::close(...future.stdout)
[13:21:49.771]         ...future.stdout <- NULL
[13:21:49.771]     }
[13:21:49.771]     ...future.result$conditions <- ...future.conditions
[13:21:49.771]     ...future.result$finished <- base::Sys.time()
[13:21:49.771]     ...future.result
[13:21:49.771] }
[13:21:49.774] MultisessionFuture started
[13:21:49.774] - Launch lazy future ... done
[13:21:49.774] run() for ‘MultisessionFuture’ ... done
[13:21:49.823] receiveMessageFromWorker() for ClusterFuture ...
[13:21:49.823] - Validating connection of MultisessionFuture
[13:21:49.824] - received message: FutureResult
[13:21:49.824] - Received FutureResult
[13:21:49.824] - Erased future from FutureRegistry
[13:21:49.824] result() for ClusterFuture ...
[13:21:49.824] - result already collected: FutureResult
[13:21:49.824] result() for ClusterFuture ... done
[13:21:49.824] signalConditions() ...
[13:21:49.824]  - include = ‘immediateCondition’
[13:21:49.825]  - exclude = 
[13:21:49.825]  - resignal = FALSE
[13:21:49.825]  - Number of conditions: 1
[13:21:49.825] signalConditions() ... done
[13:21:49.825] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:49.825] A MultisessionFuture was resolved (result was not collected)
[13:21:49.825] getGlobalsAndPackages() ...
[13:21:49.825] Searching for globals...
[13:21:49.826] - globals found: [2] ‘list’, ‘stop’
[13:21:49.826] Searching for globals ... DONE
[13:21:49.826] Resolving globals: FALSE
[13:21:49.826] 
[13:21:49.826] 
[13:21:49.827] getGlobalsAndPackages() ... DONE
[13:21:49.827] run() for ‘Future’ ...
[13:21:49.827] - state: ‘created’
[13:21:49.827] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:49.841] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:49.841] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:49.842]   - Field: ‘node’
[13:21:49.842]   - Field: ‘label’
[13:21:49.842]   - Field: ‘local’
[13:21:49.842]   - Field: ‘owner’
[13:21:49.842]   - Field: ‘envir’
[13:21:49.842]   - Field: ‘workers’
[13:21:49.842]   - Field: ‘packages’
[13:21:49.842]   - Field: ‘gc’
[13:21:49.842]   - Field: ‘conditions’
[13:21:49.842]   - Field: ‘persistent’
[13:21:49.842]   - Field: ‘expr’
[13:21:49.843]   - Field: ‘uuid’
[13:21:49.843]   - Field: ‘seed’
[13:21:49.843]   - Field: ‘version’
[13:21:49.843]   - Field: ‘result’
[13:21:49.843]   - Field: ‘asynchronous’
[13:21:49.843]   - Field: ‘calls’
[13:21:49.843]   - Field: ‘globals’
[13:21:49.843]   - Field: ‘stdout’
[13:21:49.843]   - Field: ‘earlySignal’
[13:21:49.843]   - Field: ‘lazy’
[13:21:49.843]   - Field: ‘state’
[13:21:49.844] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:49.844] - Launch lazy future ...
[13:21:49.844] Packages needed by the future expression (n = 0): <none>
[13:21:49.844] Packages needed by future strategies (n = 0): <none>
[13:21:49.844] {
[13:21:49.844]     {
[13:21:49.844]         {
[13:21:49.844]             ...future.startTime <- base::Sys.time()
[13:21:49.844]             {
[13:21:49.844]                 {
[13:21:49.844]                   {
[13:21:49.844]                     {
[13:21:49.844]                       base::local({
[13:21:49.844]                         has_future <- base::requireNamespace("future", 
[13:21:49.844]                           quietly = TRUE)
[13:21:49.844]                         if (has_future) {
[13:21:49.844]                           ns <- base::getNamespace("future")
[13:21:49.844]                           version <- ns[[".package"]][["version"]]
[13:21:49.844]                           if (is.null(version)) 
[13:21:49.844]                             version <- utils::packageVersion("future")
[13:21:49.844]                         }
[13:21:49.844]                         else {
[13:21:49.844]                           version <- NULL
[13:21:49.844]                         }
[13:21:49.844]                         if (!has_future || version < "1.8.0") {
[13:21:49.844]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:49.844]                             "", base::R.version$version.string), 
[13:21:49.844]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:49.844]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:49.844]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:49.844]                               "release", "version")], collapse = " "), 
[13:21:49.844]                             hostname = base::Sys.info()[["nodename"]])
[13:21:49.844]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:49.844]                             info)
[13:21:49.844]                           info <- base::paste(info, collapse = "; ")
[13:21:49.844]                           if (!has_future) {
[13:21:49.844]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:49.844]                               info)
[13:21:49.844]                           }
[13:21:49.844]                           else {
[13:21:49.844]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:49.844]                               info, version)
[13:21:49.844]                           }
[13:21:49.844]                           base::stop(msg)
[13:21:49.844]                         }
[13:21:49.844]                       })
[13:21:49.844]                     }
[13:21:49.844]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:49.844]                     base::options(mc.cores = 1L)
[13:21:49.844]                   }
[13:21:49.844]                   options(future.plan = NULL)
[13:21:49.844]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:49.844]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:49.844]                 }
[13:21:49.844]                 ...future.workdir <- getwd()
[13:21:49.844]             }
[13:21:49.844]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:49.844]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:49.844]         }
[13:21:49.844]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:49.844]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:49.844]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:49.844]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:49.844]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:49.844]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:49.844]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:49.844]             base::names(...future.oldOptions))
[13:21:49.844]     }
[13:21:49.844]     if (FALSE) {
[13:21:49.844]     }
[13:21:49.844]     else {
[13:21:49.844]         if (TRUE) {
[13:21:49.844]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:49.844]                 open = "w")
[13:21:49.844]         }
[13:21:49.844]         else {
[13:21:49.844]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:49.844]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:49.844]         }
[13:21:49.844]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:49.844]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:49.844]             base::sink(type = "output", split = FALSE)
[13:21:49.844]             base::close(...future.stdout)
[13:21:49.844]         }, add = TRUE)
[13:21:49.844]     }
[13:21:49.844]     ...future.frame <- base::sys.nframe()
[13:21:49.844]     ...future.conditions <- base::list()
[13:21:49.844]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:49.844]     if (FALSE) {
[13:21:49.844]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:49.844]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:49.844]     }
[13:21:49.844]     ...future.result <- base::tryCatch({
[13:21:49.844]         base::withCallingHandlers({
[13:21:49.844]             ...future.value <- base::withVisible(base::local({
[13:21:49.844]                 ...future.makeSendCondition <- local({
[13:21:49.844]                   sendCondition <- NULL
[13:21:49.844]                   function(frame = 1L) {
[13:21:49.844]                     if (is.function(sendCondition)) 
[13:21:49.844]                       return(sendCondition)
[13:21:49.844]                     ns <- getNamespace("parallel")
[13:21:49.844]                     if (exists("sendData", mode = "function", 
[13:21:49.844]                       envir = ns)) {
[13:21:49.844]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:49.844]                         envir = ns)
[13:21:49.844]                       envir <- sys.frame(frame)
[13:21:49.844]                       master <- NULL
[13:21:49.844]                       while (!identical(envir, .GlobalEnv) && 
[13:21:49.844]                         !identical(envir, emptyenv())) {
[13:21:49.844]                         if (exists("master", mode = "list", envir = envir, 
[13:21:49.844]                           inherits = FALSE)) {
[13:21:49.844]                           master <- get("master", mode = "list", 
[13:21:49.844]                             envir = envir, inherits = FALSE)
[13:21:49.844]                           if (inherits(master, c("SOCKnode", 
[13:21:49.844]                             "SOCK0node"))) {
[13:21:49.844]                             sendCondition <<- function(cond) {
[13:21:49.844]                               data <- list(type = "VALUE", value = cond, 
[13:21:49.844]                                 success = TRUE)
[13:21:49.844]                               parallel_sendData(master, data)
[13:21:49.844]                             }
[13:21:49.844]                             return(sendCondition)
[13:21:49.844]                           }
[13:21:49.844]                         }
[13:21:49.844]                         frame <- frame + 1L
[13:21:49.844]                         envir <- sys.frame(frame)
[13:21:49.844]                       }
[13:21:49.844]                     }
[13:21:49.844]                     sendCondition <<- function(cond) NULL
[13:21:49.844]                   }
[13:21:49.844]                 })
[13:21:49.844]                 withCallingHandlers({
[13:21:49.844]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:21:49.844]                 }, immediateCondition = function(cond) {
[13:21:49.844]                   sendCondition <- ...future.makeSendCondition()
[13:21:49.844]                   sendCondition(cond)
[13:21:49.844]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:49.844]                   {
[13:21:49.844]                     inherits <- base::inherits
[13:21:49.844]                     invokeRestart <- base::invokeRestart
[13:21:49.844]                     is.null <- base::is.null
[13:21:49.844]                     muffled <- FALSE
[13:21:49.844]                     if (inherits(cond, "message")) {
[13:21:49.844]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:49.844]                       if (muffled) 
[13:21:49.844]                         invokeRestart("muffleMessage")
[13:21:49.844]                     }
[13:21:49.844]                     else if (inherits(cond, "warning")) {
[13:21:49.844]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:49.844]                       if (muffled) 
[13:21:49.844]                         invokeRestart("muffleWarning")
[13:21:49.844]                     }
[13:21:49.844]                     else if (inherits(cond, "condition")) {
[13:21:49.844]                       if (!is.null(pattern)) {
[13:21:49.844]                         computeRestarts <- base::computeRestarts
[13:21:49.844]                         grepl <- base::grepl
[13:21:49.844]                         restarts <- computeRestarts(cond)
[13:21:49.844]                         for (restart in restarts) {
[13:21:49.844]                           name <- restart$name
[13:21:49.844]                           if (is.null(name)) 
[13:21:49.844]                             next
[13:21:49.844]                           if (!grepl(pattern, name)) 
[13:21:49.844]                             next
[13:21:49.844]                           invokeRestart(restart)
[13:21:49.844]                           muffled <- TRUE
[13:21:49.844]                           break
[13:21:49.844]                         }
[13:21:49.844]                       }
[13:21:49.844]                     }
[13:21:49.844]                     invisible(muffled)
[13:21:49.844]                   }
[13:21:49.844]                   muffleCondition(cond)
[13:21:49.844]                 })
[13:21:49.844]             }))
[13:21:49.844]             future::FutureResult(value = ...future.value$value, 
[13:21:49.844]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:49.844]                   ...future.rng), globalenv = if (FALSE) 
[13:21:49.844]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:49.844]                     ...future.globalenv.names))
[13:21:49.844]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:49.844]         }, condition = base::local({
[13:21:49.844]             c <- base::c
[13:21:49.844]             inherits <- base::inherits
[13:21:49.844]             invokeRestart <- base::invokeRestart
[13:21:49.844]             length <- base::length
[13:21:49.844]             list <- base::list
[13:21:49.844]             seq.int <- base::seq.int
[13:21:49.844]             signalCondition <- base::signalCondition
[13:21:49.844]             sys.calls <- base::sys.calls
[13:21:49.844]             `[[` <- base::`[[`
[13:21:49.844]             `+` <- base::`+`
[13:21:49.844]             `<<-` <- base::`<<-`
[13:21:49.844]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:49.844]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:49.844]                   3L)]
[13:21:49.844]             }
[13:21:49.844]             function(cond) {
[13:21:49.844]                 is_error <- inherits(cond, "error")
[13:21:49.844]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:49.844]                   NULL)
[13:21:49.844]                 if (is_error) {
[13:21:49.844]                   sessionInformation <- function() {
[13:21:49.844]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:49.844]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:49.844]                       search = base::search(), system = base::Sys.info())
[13:21:49.844]                   }
[13:21:49.844]                   ...future.conditions[[length(...future.conditions) + 
[13:21:49.844]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:49.844]                     cond$call), session = sessionInformation(), 
[13:21:49.844]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:49.844]                   signalCondition(cond)
[13:21:49.844]                 }
[13:21:49.844]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:49.844]                 "immediateCondition"))) {
[13:21:49.844]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:49.844]                   ...future.conditions[[length(...future.conditions) + 
[13:21:49.844]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:49.844]                   if (TRUE && !signal) {
[13:21:49.844]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:49.844]                     {
[13:21:49.844]                       inherits <- base::inherits
[13:21:49.844]                       invokeRestart <- base::invokeRestart
[13:21:49.844]                       is.null <- base::is.null
[13:21:49.844]                       muffled <- FALSE
[13:21:49.844]                       if (inherits(cond, "message")) {
[13:21:49.844]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:49.844]                         if (muffled) 
[13:21:49.844]                           invokeRestart("muffleMessage")
[13:21:49.844]                       }
[13:21:49.844]                       else if (inherits(cond, "warning")) {
[13:21:49.844]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:49.844]                         if (muffled) 
[13:21:49.844]                           invokeRestart("muffleWarning")
[13:21:49.844]                       }
[13:21:49.844]                       else if (inherits(cond, "condition")) {
[13:21:49.844]                         if (!is.null(pattern)) {
[13:21:49.844]                           computeRestarts <- base::computeRestarts
[13:21:49.844]                           grepl <- base::grepl
[13:21:49.844]                           restarts <- computeRestarts(cond)
[13:21:49.844]                           for (restart in restarts) {
[13:21:49.844]                             name <- restart$name
[13:21:49.844]                             if (is.null(name)) 
[13:21:49.844]                               next
[13:21:49.844]                             if (!grepl(pattern, name)) 
[13:21:49.844]                               next
[13:21:49.844]                             invokeRestart(restart)
[13:21:49.844]                             muffled <- TRUE
[13:21:49.844]                             break
[13:21:49.844]                           }
[13:21:49.844]                         }
[13:21:49.844]                       }
[13:21:49.844]                       invisible(muffled)
[13:21:49.844]                     }
[13:21:49.844]                     muffleCondition(cond, pattern = "^muffle")
[13:21:49.844]                   }
[13:21:49.844]                 }
[13:21:49.844]                 else {
[13:21:49.844]                   if (TRUE) {
[13:21:49.844]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:49.844]                     {
[13:21:49.844]                       inherits <- base::inherits
[13:21:49.844]                       invokeRestart <- base::invokeRestart
[13:21:49.844]                       is.null <- base::is.null
[13:21:49.844]                       muffled <- FALSE
[13:21:49.844]                       if (inherits(cond, "message")) {
[13:21:49.844]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:49.844]                         if (muffled) 
[13:21:49.844]                           invokeRestart("muffleMessage")
[13:21:49.844]                       }
[13:21:49.844]                       else if (inherits(cond, "warning")) {
[13:21:49.844]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:49.844]                         if (muffled) 
[13:21:49.844]                           invokeRestart("muffleWarning")
[13:21:49.844]                       }
[13:21:49.844]                       else if (inherits(cond, "condition")) {
[13:21:49.844]                         if (!is.null(pattern)) {
[13:21:49.844]                           computeRestarts <- base::computeRestarts
[13:21:49.844]                           grepl <- base::grepl
[13:21:49.844]                           restarts <- computeRestarts(cond)
[13:21:49.844]                           for (restart in restarts) {
[13:21:49.844]                             name <- restart$name
[13:21:49.844]                             if (is.null(name)) 
[13:21:49.844]                               next
[13:21:49.844]                             if (!grepl(pattern, name)) 
[13:21:49.844]                               next
[13:21:49.844]                             invokeRestart(restart)
[13:21:49.844]                             muffled <- TRUE
[13:21:49.844]                             break
[13:21:49.844]                           }
[13:21:49.844]                         }
[13:21:49.844]                       }
[13:21:49.844]                       invisible(muffled)
[13:21:49.844]                     }
[13:21:49.844]                     muffleCondition(cond, pattern = "^muffle")
[13:21:49.844]                   }
[13:21:49.844]                 }
[13:21:49.844]             }
[13:21:49.844]         }))
[13:21:49.844]     }, error = function(ex) {
[13:21:49.844]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:49.844]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:49.844]                 ...future.rng), started = ...future.startTime, 
[13:21:49.844]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:49.844]             version = "1.8"), class = "FutureResult")
[13:21:49.844]     }, finally = {
[13:21:49.844]         if (!identical(...future.workdir, getwd())) 
[13:21:49.844]             setwd(...future.workdir)
[13:21:49.844]         {
[13:21:49.844]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:49.844]                 ...future.oldOptions$nwarnings <- NULL
[13:21:49.844]             }
[13:21:49.844]             base::options(...future.oldOptions)
[13:21:49.844]             if (.Platform$OS.type == "windows") {
[13:21:49.844]                 old_names <- names(...future.oldEnvVars)
[13:21:49.844]                 envs <- base::Sys.getenv()
[13:21:49.844]                 names <- names(envs)
[13:21:49.844]                 common <- intersect(names, old_names)
[13:21:49.844]                 added <- setdiff(names, old_names)
[13:21:49.844]                 removed <- setdiff(old_names, names)
[13:21:49.844]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:49.844]                   envs[common]]
[13:21:49.844]                 NAMES <- toupper(changed)
[13:21:49.844]                 args <- list()
[13:21:49.844]                 for (kk in seq_along(NAMES)) {
[13:21:49.844]                   name <- changed[[kk]]
[13:21:49.844]                   NAME <- NAMES[[kk]]
[13:21:49.844]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:49.844]                     next
[13:21:49.844]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:49.844]                 }
[13:21:49.844]                 NAMES <- toupper(added)
[13:21:49.844]                 for (kk in seq_along(NAMES)) {
[13:21:49.844]                   name <- added[[kk]]
[13:21:49.844]                   NAME <- NAMES[[kk]]
[13:21:49.844]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:49.844]                     next
[13:21:49.844]                   args[[name]] <- ""
[13:21:49.844]                 }
[13:21:49.844]                 NAMES <- toupper(removed)
[13:21:49.844]                 for (kk in seq_along(NAMES)) {
[13:21:49.844]                   name <- removed[[kk]]
[13:21:49.844]                   NAME <- NAMES[[kk]]
[13:21:49.844]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:49.844]                     next
[13:21:49.844]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:49.844]                 }
[13:21:49.844]                 if (length(args) > 0) 
[13:21:49.844]                   base::do.call(base::Sys.setenv, args = args)
[13:21:49.844]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:49.844]             }
[13:21:49.844]             else {
[13:21:49.844]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:49.844]             }
[13:21:49.844]             {
[13:21:49.844]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:49.844]                   0L) {
[13:21:49.844]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:49.844]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:49.844]                   base::options(opts)
[13:21:49.844]                 }
[13:21:49.844]                 {
[13:21:49.844]                   {
[13:21:49.844]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:49.844]                     NULL
[13:21:49.844]                   }
[13:21:49.844]                   options(future.plan = NULL)
[13:21:49.844]                   if (is.na(NA_character_)) 
[13:21:49.844]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:49.844]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:49.844]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:49.844]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:49.844]                     envir = parent.frame()) 
[13:21:49.844]                   {
[13:21:49.844]                     if (is.function(workers)) 
[13:21:49.844]                       workers <- workers()
[13:21:49.844]                     workers <- structure(as.integer(workers), 
[13:21:49.844]                       class = class(workers))
[13:21:49.844]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:49.844]                       workers >= 1)
[13:21:49.844]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:49.844]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:49.844]                     }
[13:21:49.844]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:49.844]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:49.844]                       envir = envir)
[13:21:49.844]                     if (!future$lazy) 
[13:21:49.844]                       future <- run(future)
[13:21:49.844]                     invisible(future)
[13:21:49.844]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:49.844]                 }
[13:21:49.844]             }
[13:21:49.844]         }
[13:21:49.844]     })
[13:21:49.844]     if (TRUE) {
[13:21:49.844]         base::sink(type = "output", split = FALSE)
[13:21:49.844]         if (TRUE) {
[13:21:49.844]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:49.844]         }
[13:21:49.844]         else {
[13:21:49.844]             ...future.result["stdout"] <- base::list(NULL)
[13:21:49.844]         }
[13:21:49.844]         base::close(...future.stdout)
[13:21:49.844]         ...future.stdout <- NULL
[13:21:49.844]     }
[13:21:49.844]     ...future.result$conditions <- ...future.conditions
[13:21:49.844]     ...future.result$finished <- base::Sys.time()
[13:21:49.844]     ...future.result
[13:21:49.844] }
[13:21:49.847] MultisessionFuture started
[13:21:49.848] - Launch lazy future ... done
[13:21:49.848] run() for ‘MultisessionFuture’ ... done
[13:21:49.893] receiveMessageFromWorker() for ClusterFuture ...
[13:21:49.893] - Validating connection of MultisessionFuture
[13:21:49.894] - received message: FutureResult
[13:21:49.894] - Received FutureResult
[13:21:49.894] - Erased future from FutureRegistry
[13:21:49.894] result() for ClusterFuture ...
[13:21:49.894] - result already collected: FutureResult
[13:21:49.894] result() for ClusterFuture ... done
[13:21:49.895] signalConditions() ...
[13:21:49.895]  - include = ‘immediateCondition’
[13:21:49.895]  - exclude = 
[13:21:49.895]  - resignal = FALSE
[13:21:49.895]  - Number of conditions: 1
[13:21:49.895] signalConditions() ... done
[13:21:49.895] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:49.895] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 2 ... DONE
- result = FALSE, recursive = Inf ...
[13:21:49.895] getGlobalsAndPackages() ...
[13:21:49.896] Searching for globals...
[13:21:49.897] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:21:49.897] Searching for globals ... DONE
[13:21:49.897] Resolving globals: FALSE
[13:21:49.897] 
[13:21:49.897] 
[13:21:49.897] getGlobalsAndPackages() ... DONE
[13:21:49.898] run() for ‘Future’ ...
[13:21:49.898] - state: ‘created’
[13:21:49.898] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:49.914] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:49.914] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:49.915]   - Field: ‘node’
[13:21:49.915]   - Field: ‘label’
[13:21:49.915]   - Field: ‘local’
[13:21:49.915]   - Field: ‘owner’
[13:21:49.915]   - Field: ‘envir’
[13:21:49.915]   - Field: ‘workers’
[13:21:49.915]   - Field: ‘packages’
[13:21:49.915]   - Field: ‘gc’
[13:21:49.915]   - Field: ‘conditions’
[13:21:49.915]   - Field: ‘persistent’
[13:21:49.915]   - Field: ‘expr’
[13:21:49.916]   - Field: ‘uuid’
[13:21:49.916]   - Field: ‘seed’
[13:21:49.916]   - Field: ‘version’
[13:21:49.916]   - Field: ‘result’
[13:21:49.916]   - Field: ‘asynchronous’
[13:21:49.916]   - Field: ‘calls’
[13:21:49.916]   - Field: ‘globals’
[13:21:49.916]   - Field: ‘stdout’
[13:21:49.916]   - Field: ‘earlySignal’
[13:21:49.916]   - Field: ‘lazy’
[13:21:49.916]   - Field: ‘state’
[13:21:49.917] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:49.917] - Launch lazy future ...
[13:21:49.917] Packages needed by the future expression (n = 0): <none>
[13:21:49.917] Packages needed by future strategies (n = 0): <none>
[13:21:49.917] {
[13:21:49.917]     {
[13:21:49.917]         {
[13:21:49.917]             ...future.startTime <- base::Sys.time()
[13:21:49.917]             {
[13:21:49.917]                 {
[13:21:49.917]                   {
[13:21:49.917]                     {
[13:21:49.917]                       base::local({
[13:21:49.917]                         has_future <- base::requireNamespace("future", 
[13:21:49.917]                           quietly = TRUE)
[13:21:49.917]                         if (has_future) {
[13:21:49.917]                           ns <- base::getNamespace("future")
[13:21:49.917]                           version <- ns[[".package"]][["version"]]
[13:21:49.917]                           if (is.null(version)) 
[13:21:49.917]                             version <- utils::packageVersion("future")
[13:21:49.917]                         }
[13:21:49.917]                         else {
[13:21:49.917]                           version <- NULL
[13:21:49.917]                         }
[13:21:49.917]                         if (!has_future || version < "1.8.0") {
[13:21:49.917]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:49.917]                             "", base::R.version$version.string), 
[13:21:49.917]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:49.917]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:49.917]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:49.917]                               "release", "version")], collapse = " "), 
[13:21:49.917]                             hostname = base::Sys.info()[["nodename"]])
[13:21:49.917]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:49.917]                             info)
[13:21:49.917]                           info <- base::paste(info, collapse = "; ")
[13:21:49.917]                           if (!has_future) {
[13:21:49.917]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:49.917]                               info)
[13:21:49.917]                           }
[13:21:49.917]                           else {
[13:21:49.917]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:49.917]                               info, version)
[13:21:49.917]                           }
[13:21:49.917]                           base::stop(msg)
[13:21:49.917]                         }
[13:21:49.917]                       })
[13:21:49.917]                     }
[13:21:49.917]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:49.917]                     base::options(mc.cores = 1L)
[13:21:49.917]                   }
[13:21:49.917]                   options(future.plan = NULL)
[13:21:49.917]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:49.917]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:49.917]                 }
[13:21:49.917]                 ...future.workdir <- getwd()
[13:21:49.917]             }
[13:21:49.917]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:49.917]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:49.917]         }
[13:21:49.917]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:49.917]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:49.917]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:49.917]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:49.917]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:49.917]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:49.917]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:49.917]             base::names(...future.oldOptions))
[13:21:49.917]     }
[13:21:49.917]     if (FALSE) {
[13:21:49.917]     }
[13:21:49.917]     else {
[13:21:49.917]         if (TRUE) {
[13:21:49.917]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:49.917]                 open = "w")
[13:21:49.917]         }
[13:21:49.917]         else {
[13:21:49.917]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:49.917]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:49.917]         }
[13:21:49.917]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:49.917]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:49.917]             base::sink(type = "output", split = FALSE)
[13:21:49.917]             base::close(...future.stdout)
[13:21:49.917]         }, add = TRUE)
[13:21:49.917]     }
[13:21:49.917]     ...future.frame <- base::sys.nframe()
[13:21:49.917]     ...future.conditions <- base::list()
[13:21:49.917]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:49.917]     if (FALSE) {
[13:21:49.917]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:49.917]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:49.917]     }
[13:21:49.917]     ...future.result <- base::tryCatch({
[13:21:49.917]         base::withCallingHandlers({
[13:21:49.917]             ...future.value <- base::withVisible(base::local({
[13:21:49.917]                 ...future.makeSendCondition <- local({
[13:21:49.917]                   sendCondition <- NULL
[13:21:49.917]                   function(frame = 1L) {
[13:21:49.917]                     if (is.function(sendCondition)) 
[13:21:49.917]                       return(sendCondition)
[13:21:49.917]                     ns <- getNamespace("parallel")
[13:21:49.917]                     if (exists("sendData", mode = "function", 
[13:21:49.917]                       envir = ns)) {
[13:21:49.917]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:49.917]                         envir = ns)
[13:21:49.917]                       envir <- sys.frame(frame)
[13:21:49.917]                       master <- NULL
[13:21:49.917]                       while (!identical(envir, .GlobalEnv) && 
[13:21:49.917]                         !identical(envir, emptyenv())) {
[13:21:49.917]                         if (exists("master", mode = "list", envir = envir, 
[13:21:49.917]                           inherits = FALSE)) {
[13:21:49.917]                           master <- get("master", mode = "list", 
[13:21:49.917]                             envir = envir, inherits = FALSE)
[13:21:49.917]                           if (inherits(master, c("SOCKnode", 
[13:21:49.917]                             "SOCK0node"))) {
[13:21:49.917]                             sendCondition <<- function(cond) {
[13:21:49.917]                               data <- list(type = "VALUE", value = cond, 
[13:21:49.917]                                 success = TRUE)
[13:21:49.917]                               parallel_sendData(master, data)
[13:21:49.917]                             }
[13:21:49.917]                             return(sendCondition)
[13:21:49.917]                           }
[13:21:49.917]                         }
[13:21:49.917]                         frame <- frame + 1L
[13:21:49.917]                         envir <- sys.frame(frame)
[13:21:49.917]                       }
[13:21:49.917]                     }
[13:21:49.917]                     sendCondition <<- function(cond) NULL
[13:21:49.917]                   }
[13:21:49.917]                 })
[13:21:49.917]                 withCallingHandlers({
[13:21:49.917]                   {
[13:21:49.917]                     Sys.sleep(0.5)
[13:21:49.917]                     list(a = 1, b = 42L)
[13:21:49.917]                   }
[13:21:49.917]                 }, immediateCondition = function(cond) {
[13:21:49.917]                   sendCondition <- ...future.makeSendCondition()
[13:21:49.917]                   sendCondition(cond)
[13:21:49.917]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:49.917]                   {
[13:21:49.917]                     inherits <- base::inherits
[13:21:49.917]                     invokeRestart <- base::invokeRestart
[13:21:49.917]                     is.null <- base::is.null
[13:21:49.917]                     muffled <- FALSE
[13:21:49.917]                     if (inherits(cond, "message")) {
[13:21:49.917]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:49.917]                       if (muffled) 
[13:21:49.917]                         invokeRestart("muffleMessage")
[13:21:49.917]                     }
[13:21:49.917]                     else if (inherits(cond, "warning")) {
[13:21:49.917]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:49.917]                       if (muffled) 
[13:21:49.917]                         invokeRestart("muffleWarning")
[13:21:49.917]                     }
[13:21:49.917]                     else if (inherits(cond, "condition")) {
[13:21:49.917]                       if (!is.null(pattern)) {
[13:21:49.917]                         computeRestarts <- base::computeRestarts
[13:21:49.917]                         grepl <- base::grepl
[13:21:49.917]                         restarts <- computeRestarts(cond)
[13:21:49.917]                         for (restart in restarts) {
[13:21:49.917]                           name <- restart$name
[13:21:49.917]                           if (is.null(name)) 
[13:21:49.917]                             next
[13:21:49.917]                           if (!grepl(pattern, name)) 
[13:21:49.917]                             next
[13:21:49.917]                           invokeRestart(restart)
[13:21:49.917]                           muffled <- TRUE
[13:21:49.917]                           break
[13:21:49.917]                         }
[13:21:49.917]                       }
[13:21:49.917]                     }
[13:21:49.917]                     invisible(muffled)
[13:21:49.917]                   }
[13:21:49.917]                   muffleCondition(cond)
[13:21:49.917]                 })
[13:21:49.917]             }))
[13:21:49.917]             future::FutureResult(value = ...future.value$value, 
[13:21:49.917]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:49.917]                   ...future.rng), globalenv = if (FALSE) 
[13:21:49.917]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:49.917]                     ...future.globalenv.names))
[13:21:49.917]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:49.917]         }, condition = base::local({
[13:21:49.917]             c <- base::c
[13:21:49.917]             inherits <- base::inherits
[13:21:49.917]             invokeRestart <- base::invokeRestart
[13:21:49.917]             length <- base::length
[13:21:49.917]             list <- base::list
[13:21:49.917]             seq.int <- base::seq.int
[13:21:49.917]             signalCondition <- base::signalCondition
[13:21:49.917]             sys.calls <- base::sys.calls
[13:21:49.917]             `[[` <- base::`[[`
[13:21:49.917]             `+` <- base::`+`
[13:21:49.917]             `<<-` <- base::`<<-`
[13:21:49.917]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:49.917]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:49.917]                   3L)]
[13:21:49.917]             }
[13:21:49.917]             function(cond) {
[13:21:49.917]                 is_error <- inherits(cond, "error")
[13:21:49.917]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:49.917]                   NULL)
[13:21:49.917]                 if (is_error) {
[13:21:49.917]                   sessionInformation <- function() {
[13:21:49.917]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:49.917]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:49.917]                       search = base::search(), system = base::Sys.info())
[13:21:49.917]                   }
[13:21:49.917]                   ...future.conditions[[length(...future.conditions) + 
[13:21:49.917]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:49.917]                     cond$call), session = sessionInformation(), 
[13:21:49.917]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:49.917]                   signalCondition(cond)
[13:21:49.917]                 }
[13:21:49.917]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:49.917]                 "immediateCondition"))) {
[13:21:49.917]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:49.917]                   ...future.conditions[[length(...future.conditions) + 
[13:21:49.917]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:49.917]                   if (TRUE && !signal) {
[13:21:49.917]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:49.917]                     {
[13:21:49.917]                       inherits <- base::inherits
[13:21:49.917]                       invokeRestart <- base::invokeRestart
[13:21:49.917]                       is.null <- base::is.null
[13:21:49.917]                       muffled <- FALSE
[13:21:49.917]                       if (inherits(cond, "message")) {
[13:21:49.917]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:49.917]                         if (muffled) 
[13:21:49.917]                           invokeRestart("muffleMessage")
[13:21:49.917]                       }
[13:21:49.917]                       else if (inherits(cond, "warning")) {
[13:21:49.917]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:49.917]                         if (muffled) 
[13:21:49.917]                           invokeRestart("muffleWarning")
[13:21:49.917]                       }
[13:21:49.917]                       else if (inherits(cond, "condition")) {
[13:21:49.917]                         if (!is.null(pattern)) {
[13:21:49.917]                           computeRestarts <- base::computeRestarts
[13:21:49.917]                           grepl <- base::grepl
[13:21:49.917]                           restarts <- computeRestarts(cond)
[13:21:49.917]                           for (restart in restarts) {
[13:21:49.917]                             name <- restart$name
[13:21:49.917]                             if (is.null(name)) 
[13:21:49.917]                               next
[13:21:49.917]                             if (!grepl(pattern, name)) 
[13:21:49.917]                               next
[13:21:49.917]                             invokeRestart(restart)
[13:21:49.917]                             muffled <- TRUE
[13:21:49.917]                             break
[13:21:49.917]                           }
[13:21:49.917]                         }
[13:21:49.917]                       }
[13:21:49.917]                       invisible(muffled)
[13:21:49.917]                     }
[13:21:49.917]                     muffleCondition(cond, pattern = "^muffle")
[13:21:49.917]                   }
[13:21:49.917]                 }
[13:21:49.917]                 else {
[13:21:49.917]                   if (TRUE) {
[13:21:49.917]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:49.917]                     {
[13:21:49.917]                       inherits <- base::inherits
[13:21:49.917]                       invokeRestart <- base::invokeRestart
[13:21:49.917]                       is.null <- base::is.null
[13:21:49.917]                       muffled <- FALSE
[13:21:49.917]                       if (inherits(cond, "message")) {
[13:21:49.917]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:49.917]                         if (muffled) 
[13:21:49.917]                           invokeRestart("muffleMessage")
[13:21:49.917]                       }
[13:21:49.917]                       else if (inherits(cond, "warning")) {
[13:21:49.917]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:49.917]                         if (muffled) 
[13:21:49.917]                           invokeRestart("muffleWarning")
[13:21:49.917]                       }
[13:21:49.917]                       else if (inherits(cond, "condition")) {
[13:21:49.917]                         if (!is.null(pattern)) {
[13:21:49.917]                           computeRestarts <- base::computeRestarts
[13:21:49.917]                           grepl <- base::grepl
[13:21:49.917]                           restarts <- computeRestarts(cond)
[13:21:49.917]                           for (restart in restarts) {
[13:21:49.917]                             name <- restart$name
[13:21:49.917]                             if (is.null(name)) 
[13:21:49.917]                               next
[13:21:49.917]                             if (!grepl(pattern, name)) 
[13:21:49.917]                               next
[13:21:49.917]                             invokeRestart(restart)
[13:21:49.917]                             muffled <- TRUE
[13:21:49.917]                             break
[13:21:49.917]                           }
[13:21:49.917]                         }
[13:21:49.917]                       }
[13:21:49.917]                       invisible(muffled)
[13:21:49.917]                     }
[13:21:49.917]                     muffleCondition(cond, pattern = "^muffle")
[13:21:49.917]                   }
[13:21:49.917]                 }
[13:21:49.917]             }
[13:21:49.917]         }))
[13:21:49.917]     }, error = function(ex) {
[13:21:49.917]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:49.917]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:49.917]                 ...future.rng), started = ...future.startTime, 
[13:21:49.917]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:49.917]             version = "1.8"), class = "FutureResult")
[13:21:49.917]     }, finally = {
[13:21:49.917]         if (!identical(...future.workdir, getwd())) 
[13:21:49.917]             setwd(...future.workdir)
[13:21:49.917]         {
[13:21:49.917]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:49.917]                 ...future.oldOptions$nwarnings <- NULL
[13:21:49.917]             }
[13:21:49.917]             base::options(...future.oldOptions)
[13:21:49.917]             if (.Platform$OS.type == "windows") {
[13:21:49.917]                 old_names <- names(...future.oldEnvVars)
[13:21:49.917]                 envs <- base::Sys.getenv()
[13:21:49.917]                 names <- names(envs)
[13:21:49.917]                 common <- intersect(names, old_names)
[13:21:49.917]                 added <- setdiff(names, old_names)
[13:21:49.917]                 removed <- setdiff(old_names, names)
[13:21:49.917]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:49.917]                   envs[common]]
[13:21:49.917]                 NAMES <- toupper(changed)
[13:21:49.917]                 args <- list()
[13:21:49.917]                 for (kk in seq_along(NAMES)) {
[13:21:49.917]                   name <- changed[[kk]]
[13:21:49.917]                   NAME <- NAMES[[kk]]
[13:21:49.917]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:49.917]                     next
[13:21:49.917]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:49.917]                 }
[13:21:49.917]                 NAMES <- toupper(added)
[13:21:49.917]                 for (kk in seq_along(NAMES)) {
[13:21:49.917]                   name <- added[[kk]]
[13:21:49.917]                   NAME <- NAMES[[kk]]
[13:21:49.917]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:49.917]                     next
[13:21:49.917]                   args[[name]] <- ""
[13:21:49.917]                 }
[13:21:49.917]                 NAMES <- toupper(removed)
[13:21:49.917]                 for (kk in seq_along(NAMES)) {
[13:21:49.917]                   name <- removed[[kk]]
[13:21:49.917]                   NAME <- NAMES[[kk]]
[13:21:49.917]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:49.917]                     next
[13:21:49.917]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:49.917]                 }
[13:21:49.917]                 if (length(args) > 0) 
[13:21:49.917]                   base::do.call(base::Sys.setenv, args = args)
[13:21:49.917]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:49.917]             }
[13:21:49.917]             else {
[13:21:49.917]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:49.917]             }
[13:21:49.917]             {
[13:21:49.917]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:49.917]                   0L) {
[13:21:49.917]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:49.917]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:49.917]                   base::options(opts)
[13:21:49.917]                 }
[13:21:49.917]                 {
[13:21:49.917]                   {
[13:21:49.917]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:49.917]                     NULL
[13:21:49.917]                   }
[13:21:49.917]                   options(future.plan = NULL)
[13:21:49.917]                   if (is.na(NA_character_)) 
[13:21:49.917]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:49.917]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:49.917]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:49.917]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:49.917]                     envir = parent.frame()) 
[13:21:49.917]                   {
[13:21:49.917]                     if (is.function(workers)) 
[13:21:49.917]                       workers <- workers()
[13:21:49.917]                     workers <- structure(as.integer(workers), 
[13:21:49.917]                       class = class(workers))
[13:21:49.917]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:49.917]                       workers >= 1)
[13:21:49.917]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:49.917]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:49.917]                     }
[13:21:49.917]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:49.917]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:49.917]                       envir = envir)
[13:21:49.917]                     if (!future$lazy) 
[13:21:49.917]                       future <- run(future)
[13:21:49.917]                     invisible(future)
[13:21:49.917]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:49.917]                 }
[13:21:49.917]             }
[13:21:49.917]         }
[13:21:49.917]     })
[13:21:49.917]     if (TRUE) {
[13:21:49.917]         base::sink(type = "output", split = FALSE)
[13:21:49.917]         if (TRUE) {
[13:21:49.917]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:49.917]         }
[13:21:49.917]         else {
[13:21:49.917]             ...future.result["stdout"] <- base::list(NULL)
[13:21:49.917]         }
[13:21:49.917]         base::close(...future.stdout)
[13:21:49.917]         ...future.stdout <- NULL
[13:21:49.917]     }
[13:21:49.917]     ...future.result$conditions <- ...future.conditions
[13:21:49.917]     ...future.result$finished <- base::Sys.time()
[13:21:49.917]     ...future.result
[13:21:49.917] }
[13:21:49.920] MultisessionFuture started
[13:21:49.921] - Launch lazy future ... done
[13:21:49.921] run() for ‘MultisessionFuture’ ... done
[13:21:50.467] receiveMessageFromWorker() for ClusterFuture ...
[13:21:50.467] - Validating connection of MultisessionFuture
[13:21:50.467] - received message: FutureResult
[13:21:50.467] - Received FutureResult
[13:21:50.467] - Erased future from FutureRegistry
[13:21:50.467] result() for ClusterFuture ...
[13:21:50.467] - result already collected: FutureResult
[13:21:50.467] result() for ClusterFuture ... done
[13:21:50.468] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:50.468] A MultisessionFuture was resolved (result was not collected)
[13:21:50.468] getGlobalsAndPackages() ...
[13:21:50.468] Searching for globals...
[13:21:50.469] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:21:50.469] Searching for globals ... DONE
[13:21:50.469] Resolving globals: FALSE
[13:21:50.470] 
[13:21:50.470] 
[13:21:50.470] getGlobalsAndPackages() ... DONE
[13:21:50.470] run() for ‘Future’ ...
[13:21:50.470] - state: ‘created’
[13:21:50.470] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:50.485] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:50.485] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:50.485]   - Field: ‘node’
[13:21:50.485]   - Field: ‘label’
[13:21:50.485]   - Field: ‘local’
[13:21:50.485]   - Field: ‘owner’
[13:21:50.485]   - Field: ‘envir’
[13:21:50.486]   - Field: ‘workers’
[13:21:50.486]   - Field: ‘packages’
[13:21:50.486]   - Field: ‘gc’
[13:21:50.486]   - Field: ‘conditions’
[13:21:50.486]   - Field: ‘persistent’
[13:21:50.486]   - Field: ‘expr’
[13:21:50.486]   - Field: ‘uuid’
[13:21:50.486]   - Field: ‘seed’
[13:21:50.486]   - Field: ‘version’
[13:21:50.486]   - Field: ‘result’
[13:21:50.486]   - Field: ‘asynchronous’
[13:21:50.487]   - Field: ‘calls’
[13:21:50.487]   - Field: ‘globals’
[13:21:50.487]   - Field: ‘stdout’
[13:21:50.487]   - Field: ‘earlySignal’
[13:21:50.487]   - Field: ‘lazy’
[13:21:50.487]   - Field: ‘state’
[13:21:50.487] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:50.487] - Launch lazy future ...
[13:21:50.487] Packages needed by the future expression (n = 0): <none>
[13:21:50.488] Packages needed by future strategies (n = 0): <none>
[13:21:50.488] {
[13:21:50.488]     {
[13:21:50.488]         {
[13:21:50.488]             ...future.startTime <- base::Sys.time()
[13:21:50.488]             {
[13:21:50.488]                 {
[13:21:50.488]                   {
[13:21:50.488]                     {
[13:21:50.488]                       base::local({
[13:21:50.488]                         has_future <- base::requireNamespace("future", 
[13:21:50.488]                           quietly = TRUE)
[13:21:50.488]                         if (has_future) {
[13:21:50.488]                           ns <- base::getNamespace("future")
[13:21:50.488]                           version <- ns[[".package"]][["version"]]
[13:21:50.488]                           if (is.null(version)) 
[13:21:50.488]                             version <- utils::packageVersion("future")
[13:21:50.488]                         }
[13:21:50.488]                         else {
[13:21:50.488]                           version <- NULL
[13:21:50.488]                         }
[13:21:50.488]                         if (!has_future || version < "1.8.0") {
[13:21:50.488]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:50.488]                             "", base::R.version$version.string), 
[13:21:50.488]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:50.488]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:50.488]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:50.488]                               "release", "version")], collapse = " "), 
[13:21:50.488]                             hostname = base::Sys.info()[["nodename"]])
[13:21:50.488]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:50.488]                             info)
[13:21:50.488]                           info <- base::paste(info, collapse = "; ")
[13:21:50.488]                           if (!has_future) {
[13:21:50.488]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:50.488]                               info)
[13:21:50.488]                           }
[13:21:50.488]                           else {
[13:21:50.488]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:50.488]                               info, version)
[13:21:50.488]                           }
[13:21:50.488]                           base::stop(msg)
[13:21:50.488]                         }
[13:21:50.488]                       })
[13:21:50.488]                     }
[13:21:50.488]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:50.488]                     base::options(mc.cores = 1L)
[13:21:50.488]                   }
[13:21:50.488]                   options(future.plan = NULL)
[13:21:50.488]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:50.488]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:50.488]                 }
[13:21:50.488]                 ...future.workdir <- getwd()
[13:21:50.488]             }
[13:21:50.488]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:50.488]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:50.488]         }
[13:21:50.488]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:50.488]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:50.488]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:50.488]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:50.488]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:50.488]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:50.488]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:50.488]             base::names(...future.oldOptions))
[13:21:50.488]     }
[13:21:50.488]     if (FALSE) {
[13:21:50.488]     }
[13:21:50.488]     else {
[13:21:50.488]         if (TRUE) {
[13:21:50.488]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:50.488]                 open = "w")
[13:21:50.488]         }
[13:21:50.488]         else {
[13:21:50.488]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:50.488]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:50.488]         }
[13:21:50.488]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:50.488]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:50.488]             base::sink(type = "output", split = FALSE)
[13:21:50.488]             base::close(...future.stdout)
[13:21:50.488]         }, add = TRUE)
[13:21:50.488]     }
[13:21:50.488]     ...future.frame <- base::sys.nframe()
[13:21:50.488]     ...future.conditions <- base::list()
[13:21:50.488]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:50.488]     if (FALSE) {
[13:21:50.488]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:50.488]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:50.488]     }
[13:21:50.488]     ...future.result <- base::tryCatch({
[13:21:50.488]         base::withCallingHandlers({
[13:21:50.488]             ...future.value <- base::withVisible(base::local({
[13:21:50.488]                 ...future.makeSendCondition <- local({
[13:21:50.488]                   sendCondition <- NULL
[13:21:50.488]                   function(frame = 1L) {
[13:21:50.488]                     if (is.function(sendCondition)) 
[13:21:50.488]                       return(sendCondition)
[13:21:50.488]                     ns <- getNamespace("parallel")
[13:21:50.488]                     if (exists("sendData", mode = "function", 
[13:21:50.488]                       envir = ns)) {
[13:21:50.488]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:50.488]                         envir = ns)
[13:21:50.488]                       envir <- sys.frame(frame)
[13:21:50.488]                       master <- NULL
[13:21:50.488]                       while (!identical(envir, .GlobalEnv) && 
[13:21:50.488]                         !identical(envir, emptyenv())) {
[13:21:50.488]                         if (exists("master", mode = "list", envir = envir, 
[13:21:50.488]                           inherits = FALSE)) {
[13:21:50.488]                           master <- get("master", mode = "list", 
[13:21:50.488]                             envir = envir, inherits = FALSE)
[13:21:50.488]                           if (inherits(master, c("SOCKnode", 
[13:21:50.488]                             "SOCK0node"))) {
[13:21:50.488]                             sendCondition <<- function(cond) {
[13:21:50.488]                               data <- list(type = "VALUE", value = cond, 
[13:21:50.488]                                 success = TRUE)
[13:21:50.488]                               parallel_sendData(master, data)
[13:21:50.488]                             }
[13:21:50.488]                             return(sendCondition)
[13:21:50.488]                           }
[13:21:50.488]                         }
[13:21:50.488]                         frame <- frame + 1L
[13:21:50.488]                         envir <- sys.frame(frame)
[13:21:50.488]                       }
[13:21:50.488]                     }
[13:21:50.488]                     sendCondition <<- function(cond) NULL
[13:21:50.488]                   }
[13:21:50.488]                 })
[13:21:50.488]                 withCallingHandlers({
[13:21:50.488]                   {
[13:21:50.488]                     Sys.sleep(0.5)
[13:21:50.488]                     list(a = 1, b = 42L)
[13:21:50.488]                   }
[13:21:50.488]                 }, immediateCondition = function(cond) {
[13:21:50.488]                   sendCondition <- ...future.makeSendCondition()
[13:21:50.488]                   sendCondition(cond)
[13:21:50.488]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:50.488]                   {
[13:21:50.488]                     inherits <- base::inherits
[13:21:50.488]                     invokeRestart <- base::invokeRestart
[13:21:50.488]                     is.null <- base::is.null
[13:21:50.488]                     muffled <- FALSE
[13:21:50.488]                     if (inherits(cond, "message")) {
[13:21:50.488]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:50.488]                       if (muffled) 
[13:21:50.488]                         invokeRestart("muffleMessage")
[13:21:50.488]                     }
[13:21:50.488]                     else if (inherits(cond, "warning")) {
[13:21:50.488]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:50.488]                       if (muffled) 
[13:21:50.488]                         invokeRestart("muffleWarning")
[13:21:50.488]                     }
[13:21:50.488]                     else if (inherits(cond, "condition")) {
[13:21:50.488]                       if (!is.null(pattern)) {
[13:21:50.488]                         computeRestarts <- base::computeRestarts
[13:21:50.488]                         grepl <- base::grepl
[13:21:50.488]                         restarts <- computeRestarts(cond)
[13:21:50.488]                         for (restart in restarts) {
[13:21:50.488]                           name <- restart$name
[13:21:50.488]                           if (is.null(name)) 
[13:21:50.488]                             next
[13:21:50.488]                           if (!grepl(pattern, name)) 
[13:21:50.488]                             next
[13:21:50.488]                           invokeRestart(restart)
[13:21:50.488]                           muffled <- TRUE
[13:21:50.488]                           break
[13:21:50.488]                         }
[13:21:50.488]                       }
[13:21:50.488]                     }
[13:21:50.488]                     invisible(muffled)
[13:21:50.488]                   }
[13:21:50.488]                   muffleCondition(cond)
[13:21:50.488]                 })
[13:21:50.488]             }))
[13:21:50.488]             future::FutureResult(value = ...future.value$value, 
[13:21:50.488]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:50.488]                   ...future.rng), globalenv = if (FALSE) 
[13:21:50.488]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:50.488]                     ...future.globalenv.names))
[13:21:50.488]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:50.488]         }, condition = base::local({
[13:21:50.488]             c <- base::c
[13:21:50.488]             inherits <- base::inherits
[13:21:50.488]             invokeRestart <- base::invokeRestart
[13:21:50.488]             length <- base::length
[13:21:50.488]             list <- base::list
[13:21:50.488]             seq.int <- base::seq.int
[13:21:50.488]             signalCondition <- base::signalCondition
[13:21:50.488]             sys.calls <- base::sys.calls
[13:21:50.488]             `[[` <- base::`[[`
[13:21:50.488]             `+` <- base::`+`
[13:21:50.488]             `<<-` <- base::`<<-`
[13:21:50.488]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:50.488]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:50.488]                   3L)]
[13:21:50.488]             }
[13:21:50.488]             function(cond) {
[13:21:50.488]                 is_error <- inherits(cond, "error")
[13:21:50.488]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:50.488]                   NULL)
[13:21:50.488]                 if (is_error) {
[13:21:50.488]                   sessionInformation <- function() {
[13:21:50.488]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:50.488]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:50.488]                       search = base::search(), system = base::Sys.info())
[13:21:50.488]                   }
[13:21:50.488]                   ...future.conditions[[length(...future.conditions) + 
[13:21:50.488]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:50.488]                     cond$call), session = sessionInformation(), 
[13:21:50.488]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:50.488]                   signalCondition(cond)
[13:21:50.488]                 }
[13:21:50.488]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:50.488]                 "immediateCondition"))) {
[13:21:50.488]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:50.488]                   ...future.conditions[[length(...future.conditions) + 
[13:21:50.488]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:50.488]                   if (TRUE && !signal) {
[13:21:50.488]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:50.488]                     {
[13:21:50.488]                       inherits <- base::inherits
[13:21:50.488]                       invokeRestart <- base::invokeRestart
[13:21:50.488]                       is.null <- base::is.null
[13:21:50.488]                       muffled <- FALSE
[13:21:50.488]                       if (inherits(cond, "message")) {
[13:21:50.488]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:50.488]                         if (muffled) 
[13:21:50.488]                           invokeRestart("muffleMessage")
[13:21:50.488]                       }
[13:21:50.488]                       else if (inherits(cond, "warning")) {
[13:21:50.488]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:50.488]                         if (muffled) 
[13:21:50.488]                           invokeRestart("muffleWarning")
[13:21:50.488]                       }
[13:21:50.488]                       else if (inherits(cond, "condition")) {
[13:21:50.488]                         if (!is.null(pattern)) {
[13:21:50.488]                           computeRestarts <- base::computeRestarts
[13:21:50.488]                           grepl <- base::grepl
[13:21:50.488]                           restarts <- computeRestarts(cond)
[13:21:50.488]                           for (restart in restarts) {
[13:21:50.488]                             name <- restart$name
[13:21:50.488]                             if (is.null(name)) 
[13:21:50.488]                               next
[13:21:50.488]                             if (!grepl(pattern, name)) 
[13:21:50.488]                               next
[13:21:50.488]                             invokeRestart(restart)
[13:21:50.488]                             muffled <- TRUE
[13:21:50.488]                             break
[13:21:50.488]                           }
[13:21:50.488]                         }
[13:21:50.488]                       }
[13:21:50.488]                       invisible(muffled)
[13:21:50.488]                     }
[13:21:50.488]                     muffleCondition(cond, pattern = "^muffle")
[13:21:50.488]                   }
[13:21:50.488]                 }
[13:21:50.488]                 else {
[13:21:50.488]                   if (TRUE) {
[13:21:50.488]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:50.488]                     {
[13:21:50.488]                       inherits <- base::inherits
[13:21:50.488]                       invokeRestart <- base::invokeRestart
[13:21:50.488]                       is.null <- base::is.null
[13:21:50.488]                       muffled <- FALSE
[13:21:50.488]                       if (inherits(cond, "message")) {
[13:21:50.488]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:50.488]                         if (muffled) 
[13:21:50.488]                           invokeRestart("muffleMessage")
[13:21:50.488]                       }
[13:21:50.488]                       else if (inherits(cond, "warning")) {
[13:21:50.488]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:50.488]                         if (muffled) 
[13:21:50.488]                           invokeRestart("muffleWarning")
[13:21:50.488]                       }
[13:21:50.488]                       else if (inherits(cond, "condition")) {
[13:21:50.488]                         if (!is.null(pattern)) {
[13:21:50.488]                           computeRestarts <- base::computeRestarts
[13:21:50.488]                           grepl <- base::grepl
[13:21:50.488]                           restarts <- computeRestarts(cond)
[13:21:50.488]                           for (restart in restarts) {
[13:21:50.488]                             name <- restart$name
[13:21:50.488]                             if (is.null(name)) 
[13:21:50.488]                               next
[13:21:50.488]                             if (!grepl(pattern, name)) 
[13:21:50.488]                               next
[13:21:50.488]                             invokeRestart(restart)
[13:21:50.488]                             muffled <- TRUE
[13:21:50.488]                             break
[13:21:50.488]                           }
[13:21:50.488]                         }
[13:21:50.488]                       }
[13:21:50.488]                       invisible(muffled)
[13:21:50.488]                     }
[13:21:50.488]                     muffleCondition(cond, pattern = "^muffle")
[13:21:50.488]                   }
[13:21:50.488]                 }
[13:21:50.488]             }
[13:21:50.488]         }))
[13:21:50.488]     }, error = function(ex) {
[13:21:50.488]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:50.488]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:50.488]                 ...future.rng), started = ...future.startTime, 
[13:21:50.488]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:50.488]             version = "1.8"), class = "FutureResult")
[13:21:50.488]     }, finally = {
[13:21:50.488]         if (!identical(...future.workdir, getwd())) 
[13:21:50.488]             setwd(...future.workdir)
[13:21:50.488]         {
[13:21:50.488]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:50.488]                 ...future.oldOptions$nwarnings <- NULL
[13:21:50.488]             }
[13:21:50.488]             base::options(...future.oldOptions)
[13:21:50.488]             if (.Platform$OS.type == "windows") {
[13:21:50.488]                 old_names <- names(...future.oldEnvVars)
[13:21:50.488]                 envs <- base::Sys.getenv()
[13:21:50.488]                 names <- names(envs)
[13:21:50.488]                 common <- intersect(names, old_names)
[13:21:50.488]                 added <- setdiff(names, old_names)
[13:21:50.488]                 removed <- setdiff(old_names, names)
[13:21:50.488]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:50.488]                   envs[common]]
[13:21:50.488]                 NAMES <- toupper(changed)
[13:21:50.488]                 args <- list()
[13:21:50.488]                 for (kk in seq_along(NAMES)) {
[13:21:50.488]                   name <- changed[[kk]]
[13:21:50.488]                   NAME <- NAMES[[kk]]
[13:21:50.488]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:50.488]                     next
[13:21:50.488]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:50.488]                 }
[13:21:50.488]                 NAMES <- toupper(added)
[13:21:50.488]                 for (kk in seq_along(NAMES)) {
[13:21:50.488]                   name <- added[[kk]]
[13:21:50.488]                   NAME <- NAMES[[kk]]
[13:21:50.488]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:50.488]                     next
[13:21:50.488]                   args[[name]] <- ""
[13:21:50.488]                 }
[13:21:50.488]                 NAMES <- toupper(removed)
[13:21:50.488]                 for (kk in seq_along(NAMES)) {
[13:21:50.488]                   name <- removed[[kk]]
[13:21:50.488]                   NAME <- NAMES[[kk]]
[13:21:50.488]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:50.488]                     next
[13:21:50.488]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:50.488]                 }
[13:21:50.488]                 if (length(args) > 0) 
[13:21:50.488]                   base::do.call(base::Sys.setenv, args = args)
[13:21:50.488]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:50.488]             }
[13:21:50.488]             else {
[13:21:50.488]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:50.488]             }
[13:21:50.488]             {
[13:21:50.488]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:50.488]                   0L) {
[13:21:50.488]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:50.488]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:50.488]                   base::options(opts)
[13:21:50.488]                 }
[13:21:50.488]                 {
[13:21:50.488]                   {
[13:21:50.488]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:50.488]                     NULL
[13:21:50.488]                   }
[13:21:50.488]                   options(future.plan = NULL)
[13:21:50.488]                   if (is.na(NA_character_)) 
[13:21:50.488]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:50.488]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:50.488]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:50.488]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:50.488]                     envir = parent.frame()) 
[13:21:50.488]                   {
[13:21:50.488]                     if (is.function(workers)) 
[13:21:50.488]                       workers <- workers()
[13:21:50.488]                     workers <- structure(as.integer(workers), 
[13:21:50.488]                       class = class(workers))
[13:21:50.488]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:50.488]                       workers >= 1)
[13:21:50.488]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:50.488]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:50.488]                     }
[13:21:50.488]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:50.488]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:50.488]                       envir = envir)
[13:21:50.488]                     if (!future$lazy) 
[13:21:50.488]                       future <- run(future)
[13:21:50.488]                     invisible(future)
[13:21:50.488]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:50.488]                 }
[13:21:50.488]             }
[13:21:50.488]         }
[13:21:50.488]     })
[13:21:50.488]     if (TRUE) {
[13:21:50.488]         base::sink(type = "output", split = FALSE)
[13:21:50.488]         if (TRUE) {
[13:21:50.488]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:50.488]         }
[13:21:50.488]         else {
[13:21:50.488]             ...future.result["stdout"] <- base::list(NULL)
[13:21:50.488]         }
[13:21:50.488]         base::close(...future.stdout)
[13:21:50.488]         ...future.stdout <- NULL
[13:21:50.488]     }
[13:21:50.488]     ...future.result$conditions <- ...future.conditions
[13:21:50.488]     ...future.result$finished <- base::Sys.time()
[13:21:50.488]     ...future.result
[13:21:50.488] }
[13:21:50.491] MultisessionFuture started
[13:21:50.491] - Launch lazy future ... done
[13:21:50.491] run() for ‘MultisessionFuture’ ... done
[13:21:51.049] receiveMessageFromWorker() for ClusterFuture ...
[13:21:51.049] - Validating connection of MultisessionFuture
[13:21:51.049] - received message: FutureResult
[13:21:51.049] - Received FutureResult
[13:21:51.050] - Erased future from FutureRegistry
[13:21:51.050] result() for ClusterFuture ...
[13:21:51.050] - result already collected: FutureResult
[13:21:51.050] result() for ClusterFuture ... done
[13:21:51.050] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:51.050] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[13:21:51.050] getGlobalsAndPackages() ...
[13:21:51.050] Searching for globals...
[13:21:51.051] - globals found: [2] ‘list’, ‘stop’
[13:21:51.051] Searching for globals ... DONE
[13:21:51.051] Resolving globals: FALSE
[13:21:51.052] 
[13:21:51.052] 
[13:21:51.052] getGlobalsAndPackages() ... DONE
[13:21:51.052] run() for ‘Future’ ...
[13:21:51.052] - state: ‘created’
[13:21:51.052] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:51.067] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:51.067] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:51.067]   - Field: ‘node’
[13:21:51.067]   - Field: ‘label’
[13:21:51.067]   - Field: ‘local’
[13:21:51.067]   - Field: ‘owner’
[13:21:51.068]   - Field: ‘envir’
[13:21:51.068]   - Field: ‘workers’
[13:21:51.068]   - Field: ‘packages’
[13:21:51.068]   - Field: ‘gc’
[13:21:51.068]   - Field: ‘conditions’
[13:21:51.068]   - Field: ‘persistent’
[13:21:51.068]   - Field: ‘expr’
[13:21:51.068]   - Field: ‘uuid’
[13:21:51.068]   - Field: ‘seed’
[13:21:51.068]   - Field: ‘version’
[13:21:51.068]   - Field: ‘result’
[13:21:51.069]   - Field: ‘asynchronous’
[13:21:51.069]   - Field: ‘calls’
[13:21:51.069]   - Field: ‘globals’
[13:21:51.069]   - Field: ‘stdout’
[13:21:51.069]   - Field: ‘earlySignal’
[13:21:51.069]   - Field: ‘lazy’
[13:21:51.069]   - Field: ‘state’
[13:21:51.069] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:51.069] - Launch lazy future ...
[13:21:51.070] Packages needed by the future expression (n = 0): <none>
[13:21:51.070] Packages needed by future strategies (n = 0): <none>
[13:21:51.070] {
[13:21:51.070]     {
[13:21:51.070]         {
[13:21:51.070]             ...future.startTime <- base::Sys.time()
[13:21:51.070]             {
[13:21:51.070]                 {
[13:21:51.070]                   {
[13:21:51.070]                     {
[13:21:51.070]                       base::local({
[13:21:51.070]                         has_future <- base::requireNamespace("future", 
[13:21:51.070]                           quietly = TRUE)
[13:21:51.070]                         if (has_future) {
[13:21:51.070]                           ns <- base::getNamespace("future")
[13:21:51.070]                           version <- ns[[".package"]][["version"]]
[13:21:51.070]                           if (is.null(version)) 
[13:21:51.070]                             version <- utils::packageVersion("future")
[13:21:51.070]                         }
[13:21:51.070]                         else {
[13:21:51.070]                           version <- NULL
[13:21:51.070]                         }
[13:21:51.070]                         if (!has_future || version < "1.8.0") {
[13:21:51.070]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:51.070]                             "", base::R.version$version.string), 
[13:21:51.070]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:51.070]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:51.070]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:51.070]                               "release", "version")], collapse = " "), 
[13:21:51.070]                             hostname = base::Sys.info()[["nodename"]])
[13:21:51.070]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:51.070]                             info)
[13:21:51.070]                           info <- base::paste(info, collapse = "; ")
[13:21:51.070]                           if (!has_future) {
[13:21:51.070]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:51.070]                               info)
[13:21:51.070]                           }
[13:21:51.070]                           else {
[13:21:51.070]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:51.070]                               info, version)
[13:21:51.070]                           }
[13:21:51.070]                           base::stop(msg)
[13:21:51.070]                         }
[13:21:51.070]                       })
[13:21:51.070]                     }
[13:21:51.070]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:51.070]                     base::options(mc.cores = 1L)
[13:21:51.070]                   }
[13:21:51.070]                   options(future.plan = NULL)
[13:21:51.070]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:51.070]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:51.070]                 }
[13:21:51.070]                 ...future.workdir <- getwd()
[13:21:51.070]             }
[13:21:51.070]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:51.070]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:51.070]         }
[13:21:51.070]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:51.070]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:51.070]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:51.070]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:51.070]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:51.070]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:51.070]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:51.070]             base::names(...future.oldOptions))
[13:21:51.070]     }
[13:21:51.070]     if (FALSE) {
[13:21:51.070]     }
[13:21:51.070]     else {
[13:21:51.070]         if (TRUE) {
[13:21:51.070]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:51.070]                 open = "w")
[13:21:51.070]         }
[13:21:51.070]         else {
[13:21:51.070]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:51.070]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:51.070]         }
[13:21:51.070]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:51.070]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:51.070]             base::sink(type = "output", split = FALSE)
[13:21:51.070]             base::close(...future.stdout)
[13:21:51.070]         }, add = TRUE)
[13:21:51.070]     }
[13:21:51.070]     ...future.frame <- base::sys.nframe()
[13:21:51.070]     ...future.conditions <- base::list()
[13:21:51.070]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:51.070]     if (FALSE) {
[13:21:51.070]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:51.070]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:51.070]     }
[13:21:51.070]     ...future.result <- base::tryCatch({
[13:21:51.070]         base::withCallingHandlers({
[13:21:51.070]             ...future.value <- base::withVisible(base::local({
[13:21:51.070]                 ...future.makeSendCondition <- local({
[13:21:51.070]                   sendCondition <- NULL
[13:21:51.070]                   function(frame = 1L) {
[13:21:51.070]                     if (is.function(sendCondition)) 
[13:21:51.070]                       return(sendCondition)
[13:21:51.070]                     ns <- getNamespace("parallel")
[13:21:51.070]                     if (exists("sendData", mode = "function", 
[13:21:51.070]                       envir = ns)) {
[13:21:51.070]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:51.070]                         envir = ns)
[13:21:51.070]                       envir <- sys.frame(frame)
[13:21:51.070]                       master <- NULL
[13:21:51.070]                       while (!identical(envir, .GlobalEnv) && 
[13:21:51.070]                         !identical(envir, emptyenv())) {
[13:21:51.070]                         if (exists("master", mode = "list", envir = envir, 
[13:21:51.070]                           inherits = FALSE)) {
[13:21:51.070]                           master <- get("master", mode = "list", 
[13:21:51.070]                             envir = envir, inherits = FALSE)
[13:21:51.070]                           if (inherits(master, c("SOCKnode", 
[13:21:51.070]                             "SOCK0node"))) {
[13:21:51.070]                             sendCondition <<- function(cond) {
[13:21:51.070]                               data <- list(type = "VALUE", value = cond, 
[13:21:51.070]                                 success = TRUE)
[13:21:51.070]                               parallel_sendData(master, data)
[13:21:51.070]                             }
[13:21:51.070]                             return(sendCondition)
[13:21:51.070]                           }
[13:21:51.070]                         }
[13:21:51.070]                         frame <- frame + 1L
[13:21:51.070]                         envir <- sys.frame(frame)
[13:21:51.070]                       }
[13:21:51.070]                     }
[13:21:51.070]                     sendCondition <<- function(cond) NULL
[13:21:51.070]                   }
[13:21:51.070]                 })
[13:21:51.070]                 withCallingHandlers({
[13:21:51.070]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:21:51.070]                 }, immediateCondition = function(cond) {
[13:21:51.070]                   sendCondition <- ...future.makeSendCondition()
[13:21:51.070]                   sendCondition(cond)
[13:21:51.070]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:51.070]                   {
[13:21:51.070]                     inherits <- base::inherits
[13:21:51.070]                     invokeRestart <- base::invokeRestart
[13:21:51.070]                     is.null <- base::is.null
[13:21:51.070]                     muffled <- FALSE
[13:21:51.070]                     if (inherits(cond, "message")) {
[13:21:51.070]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:51.070]                       if (muffled) 
[13:21:51.070]                         invokeRestart("muffleMessage")
[13:21:51.070]                     }
[13:21:51.070]                     else if (inherits(cond, "warning")) {
[13:21:51.070]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:51.070]                       if (muffled) 
[13:21:51.070]                         invokeRestart("muffleWarning")
[13:21:51.070]                     }
[13:21:51.070]                     else if (inherits(cond, "condition")) {
[13:21:51.070]                       if (!is.null(pattern)) {
[13:21:51.070]                         computeRestarts <- base::computeRestarts
[13:21:51.070]                         grepl <- base::grepl
[13:21:51.070]                         restarts <- computeRestarts(cond)
[13:21:51.070]                         for (restart in restarts) {
[13:21:51.070]                           name <- restart$name
[13:21:51.070]                           if (is.null(name)) 
[13:21:51.070]                             next
[13:21:51.070]                           if (!grepl(pattern, name)) 
[13:21:51.070]                             next
[13:21:51.070]                           invokeRestart(restart)
[13:21:51.070]                           muffled <- TRUE
[13:21:51.070]                           break
[13:21:51.070]                         }
[13:21:51.070]                       }
[13:21:51.070]                     }
[13:21:51.070]                     invisible(muffled)
[13:21:51.070]                   }
[13:21:51.070]                   muffleCondition(cond)
[13:21:51.070]                 })
[13:21:51.070]             }))
[13:21:51.070]             future::FutureResult(value = ...future.value$value, 
[13:21:51.070]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:51.070]                   ...future.rng), globalenv = if (FALSE) 
[13:21:51.070]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:51.070]                     ...future.globalenv.names))
[13:21:51.070]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:51.070]         }, condition = base::local({
[13:21:51.070]             c <- base::c
[13:21:51.070]             inherits <- base::inherits
[13:21:51.070]             invokeRestart <- base::invokeRestart
[13:21:51.070]             length <- base::length
[13:21:51.070]             list <- base::list
[13:21:51.070]             seq.int <- base::seq.int
[13:21:51.070]             signalCondition <- base::signalCondition
[13:21:51.070]             sys.calls <- base::sys.calls
[13:21:51.070]             `[[` <- base::`[[`
[13:21:51.070]             `+` <- base::`+`
[13:21:51.070]             `<<-` <- base::`<<-`
[13:21:51.070]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:51.070]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:51.070]                   3L)]
[13:21:51.070]             }
[13:21:51.070]             function(cond) {
[13:21:51.070]                 is_error <- inherits(cond, "error")
[13:21:51.070]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:51.070]                   NULL)
[13:21:51.070]                 if (is_error) {
[13:21:51.070]                   sessionInformation <- function() {
[13:21:51.070]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:51.070]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:51.070]                       search = base::search(), system = base::Sys.info())
[13:21:51.070]                   }
[13:21:51.070]                   ...future.conditions[[length(...future.conditions) + 
[13:21:51.070]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:51.070]                     cond$call), session = sessionInformation(), 
[13:21:51.070]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:51.070]                   signalCondition(cond)
[13:21:51.070]                 }
[13:21:51.070]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:51.070]                 "immediateCondition"))) {
[13:21:51.070]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:51.070]                   ...future.conditions[[length(...future.conditions) + 
[13:21:51.070]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:51.070]                   if (TRUE && !signal) {
[13:21:51.070]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:51.070]                     {
[13:21:51.070]                       inherits <- base::inherits
[13:21:51.070]                       invokeRestart <- base::invokeRestart
[13:21:51.070]                       is.null <- base::is.null
[13:21:51.070]                       muffled <- FALSE
[13:21:51.070]                       if (inherits(cond, "message")) {
[13:21:51.070]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:51.070]                         if (muffled) 
[13:21:51.070]                           invokeRestart("muffleMessage")
[13:21:51.070]                       }
[13:21:51.070]                       else if (inherits(cond, "warning")) {
[13:21:51.070]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:51.070]                         if (muffled) 
[13:21:51.070]                           invokeRestart("muffleWarning")
[13:21:51.070]                       }
[13:21:51.070]                       else if (inherits(cond, "condition")) {
[13:21:51.070]                         if (!is.null(pattern)) {
[13:21:51.070]                           computeRestarts <- base::computeRestarts
[13:21:51.070]                           grepl <- base::grepl
[13:21:51.070]                           restarts <- computeRestarts(cond)
[13:21:51.070]                           for (restart in restarts) {
[13:21:51.070]                             name <- restart$name
[13:21:51.070]                             if (is.null(name)) 
[13:21:51.070]                               next
[13:21:51.070]                             if (!grepl(pattern, name)) 
[13:21:51.070]                               next
[13:21:51.070]                             invokeRestart(restart)
[13:21:51.070]                             muffled <- TRUE
[13:21:51.070]                             break
[13:21:51.070]                           }
[13:21:51.070]                         }
[13:21:51.070]                       }
[13:21:51.070]                       invisible(muffled)
[13:21:51.070]                     }
[13:21:51.070]                     muffleCondition(cond, pattern = "^muffle")
[13:21:51.070]                   }
[13:21:51.070]                 }
[13:21:51.070]                 else {
[13:21:51.070]                   if (TRUE) {
[13:21:51.070]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:51.070]                     {
[13:21:51.070]                       inherits <- base::inherits
[13:21:51.070]                       invokeRestart <- base::invokeRestart
[13:21:51.070]                       is.null <- base::is.null
[13:21:51.070]                       muffled <- FALSE
[13:21:51.070]                       if (inherits(cond, "message")) {
[13:21:51.070]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:51.070]                         if (muffled) 
[13:21:51.070]                           invokeRestart("muffleMessage")
[13:21:51.070]                       }
[13:21:51.070]                       else if (inherits(cond, "warning")) {
[13:21:51.070]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:51.070]                         if (muffled) 
[13:21:51.070]                           invokeRestart("muffleWarning")
[13:21:51.070]                       }
[13:21:51.070]                       else if (inherits(cond, "condition")) {
[13:21:51.070]                         if (!is.null(pattern)) {
[13:21:51.070]                           computeRestarts <- base::computeRestarts
[13:21:51.070]                           grepl <- base::grepl
[13:21:51.070]                           restarts <- computeRestarts(cond)
[13:21:51.070]                           for (restart in restarts) {
[13:21:51.070]                             name <- restart$name
[13:21:51.070]                             if (is.null(name)) 
[13:21:51.070]                               next
[13:21:51.070]                             if (!grepl(pattern, name)) 
[13:21:51.070]                               next
[13:21:51.070]                             invokeRestart(restart)
[13:21:51.070]                             muffled <- TRUE
[13:21:51.070]                             break
[13:21:51.070]                           }
[13:21:51.070]                         }
[13:21:51.070]                       }
[13:21:51.070]                       invisible(muffled)
[13:21:51.070]                     }
[13:21:51.070]                     muffleCondition(cond, pattern = "^muffle")
[13:21:51.070]                   }
[13:21:51.070]                 }
[13:21:51.070]             }
[13:21:51.070]         }))
[13:21:51.070]     }, error = function(ex) {
[13:21:51.070]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:51.070]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:51.070]                 ...future.rng), started = ...future.startTime, 
[13:21:51.070]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:51.070]             version = "1.8"), class = "FutureResult")
[13:21:51.070]     }, finally = {
[13:21:51.070]         if (!identical(...future.workdir, getwd())) 
[13:21:51.070]             setwd(...future.workdir)
[13:21:51.070]         {
[13:21:51.070]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:51.070]                 ...future.oldOptions$nwarnings <- NULL
[13:21:51.070]             }
[13:21:51.070]             base::options(...future.oldOptions)
[13:21:51.070]             if (.Platform$OS.type == "windows") {
[13:21:51.070]                 old_names <- names(...future.oldEnvVars)
[13:21:51.070]                 envs <- base::Sys.getenv()
[13:21:51.070]                 names <- names(envs)
[13:21:51.070]                 common <- intersect(names, old_names)
[13:21:51.070]                 added <- setdiff(names, old_names)
[13:21:51.070]                 removed <- setdiff(old_names, names)
[13:21:51.070]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:51.070]                   envs[common]]
[13:21:51.070]                 NAMES <- toupper(changed)
[13:21:51.070]                 args <- list()
[13:21:51.070]                 for (kk in seq_along(NAMES)) {
[13:21:51.070]                   name <- changed[[kk]]
[13:21:51.070]                   NAME <- NAMES[[kk]]
[13:21:51.070]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:51.070]                     next
[13:21:51.070]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:51.070]                 }
[13:21:51.070]                 NAMES <- toupper(added)
[13:21:51.070]                 for (kk in seq_along(NAMES)) {
[13:21:51.070]                   name <- added[[kk]]
[13:21:51.070]                   NAME <- NAMES[[kk]]
[13:21:51.070]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:51.070]                     next
[13:21:51.070]                   args[[name]] <- ""
[13:21:51.070]                 }
[13:21:51.070]                 NAMES <- toupper(removed)
[13:21:51.070]                 for (kk in seq_along(NAMES)) {
[13:21:51.070]                   name <- removed[[kk]]
[13:21:51.070]                   NAME <- NAMES[[kk]]
[13:21:51.070]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:51.070]                     next
[13:21:51.070]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:51.070]                 }
[13:21:51.070]                 if (length(args) > 0) 
[13:21:51.070]                   base::do.call(base::Sys.setenv, args = args)
[13:21:51.070]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:51.070]             }
[13:21:51.070]             else {
[13:21:51.070]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:51.070]             }
[13:21:51.070]             {
[13:21:51.070]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:51.070]                   0L) {
[13:21:51.070]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:51.070]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:51.070]                   base::options(opts)
[13:21:51.070]                 }
[13:21:51.070]                 {
[13:21:51.070]                   {
[13:21:51.070]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:51.070]                     NULL
[13:21:51.070]                   }
[13:21:51.070]                   options(future.plan = NULL)
[13:21:51.070]                   if (is.na(NA_character_)) 
[13:21:51.070]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:51.070]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:51.070]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:51.070]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:51.070]                     envir = parent.frame()) 
[13:21:51.070]                   {
[13:21:51.070]                     if (is.function(workers)) 
[13:21:51.070]                       workers <- workers()
[13:21:51.070]                     workers <- structure(as.integer(workers), 
[13:21:51.070]                       class = class(workers))
[13:21:51.070]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:51.070]                       workers >= 1)
[13:21:51.070]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:51.070]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:51.070]                     }
[13:21:51.070]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:51.070]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:51.070]                       envir = envir)
[13:21:51.070]                     if (!future$lazy) 
[13:21:51.070]                       future <- run(future)
[13:21:51.070]                     invisible(future)
[13:21:51.070]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:51.070]                 }
[13:21:51.070]             }
[13:21:51.070]         }
[13:21:51.070]     })
[13:21:51.070]     if (TRUE) {
[13:21:51.070]         base::sink(type = "output", split = FALSE)
[13:21:51.070]         if (TRUE) {
[13:21:51.070]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:51.070]         }
[13:21:51.070]         else {
[13:21:51.070]             ...future.result["stdout"] <- base::list(NULL)
[13:21:51.070]         }
[13:21:51.070]         base::close(...future.stdout)
[13:21:51.070]         ...future.stdout <- NULL
[13:21:51.070]     }
[13:21:51.070]     ...future.result$conditions <- ...future.conditions
[13:21:51.070]     ...future.result$finished <- base::Sys.time()
[13:21:51.070]     ...future.result
[13:21:51.070] }
[13:21:51.074] MultisessionFuture started
[13:21:51.074] - Launch lazy future ... done
[13:21:51.074] run() for ‘MultisessionFuture’ ... done
[13:21:51.122] receiveMessageFromWorker() for ClusterFuture ...
[13:21:51.122] - Validating connection of MultisessionFuture
[13:21:51.123] - received message: FutureResult
[13:21:51.123] - Received FutureResult
[13:21:51.123] - Erased future from FutureRegistry
[13:21:51.123] result() for ClusterFuture ...
[13:21:51.123] - result already collected: FutureResult
[13:21:51.123] result() for ClusterFuture ... done
[13:21:51.123] signalConditions() ...
[13:21:51.123]  - include = ‘immediateCondition’
[13:21:51.124]  - exclude = 
[13:21:51.124]  - resignal = FALSE
[13:21:51.124]  - Number of conditions: 1
[13:21:51.124] signalConditions() ... done
[13:21:51.124] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:51.124] A MultisessionFuture was resolved (result was not collected)
[13:21:51.124] getGlobalsAndPackages() ...
[13:21:51.124] Searching for globals...
[13:21:51.125] - globals found: [2] ‘list’, ‘stop’
[13:21:51.125] Searching for globals ... DONE
[13:21:51.125] Resolving globals: FALSE
[13:21:51.125] 
[13:21:51.125] 
[13:21:51.126] getGlobalsAndPackages() ... DONE
[13:21:51.126] run() for ‘Future’ ...
[13:21:51.126] - state: ‘created’
[13:21:51.126] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:51.140] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:51.140] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:51.141]   - Field: ‘node’
[13:21:51.141]   - Field: ‘label’
[13:21:51.141]   - Field: ‘local’
[13:21:51.141]   - Field: ‘owner’
[13:21:51.141]   - Field: ‘envir’
[13:21:51.141]   - Field: ‘workers’
[13:21:51.141]   - Field: ‘packages’
[13:21:51.141]   - Field: ‘gc’
[13:21:51.141]   - Field: ‘conditions’
[13:21:51.141]   - Field: ‘persistent’
[13:21:51.141]   - Field: ‘expr’
[13:21:51.142]   - Field: ‘uuid’
[13:21:51.142]   - Field: ‘seed’
[13:21:51.142]   - Field: ‘version’
[13:21:51.142]   - Field: ‘result’
[13:21:51.142]   - Field: ‘asynchronous’
[13:21:51.142]   - Field: ‘calls’
[13:21:51.142]   - Field: ‘globals’
[13:21:51.142]   - Field: ‘stdout’
[13:21:51.142]   - Field: ‘earlySignal’
[13:21:51.142]   - Field: ‘lazy’
[13:21:51.142]   - Field: ‘state’
[13:21:51.143] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:51.143] - Launch lazy future ...
[13:21:51.143] Packages needed by the future expression (n = 0): <none>
[13:21:51.143] Packages needed by future strategies (n = 0): <none>
[13:21:51.143] {
[13:21:51.143]     {
[13:21:51.143]         {
[13:21:51.143]             ...future.startTime <- base::Sys.time()
[13:21:51.143]             {
[13:21:51.143]                 {
[13:21:51.143]                   {
[13:21:51.143]                     {
[13:21:51.143]                       base::local({
[13:21:51.143]                         has_future <- base::requireNamespace("future", 
[13:21:51.143]                           quietly = TRUE)
[13:21:51.143]                         if (has_future) {
[13:21:51.143]                           ns <- base::getNamespace("future")
[13:21:51.143]                           version <- ns[[".package"]][["version"]]
[13:21:51.143]                           if (is.null(version)) 
[13:21:51.143]                             version <- utils::packageVersion("future")
[13:21:51.143]                         }
[13:21:51.143]                         else {
[13:21:51.143]                           version <- NULL
[13:21:51.143]                         }
[13:21:51.143]                         if (!has_future || version < "1.8.0") {
[13:21:51.143]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:51.143]                             "", base::R.version$version.string), 
[13:21:51.143]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:51.143]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:51.143]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:51.143]                               "release", "version")], collapse = " "), 
[13:21:51.143]                             hostname = base::Sys.info()[["nodename"]])
[13:21:51.143]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:51.143]                             info)
[13:21:51.143]                           info <- base::paste(info, collapse = "; ")
[13:21:51.143]                           if (!has_future) {
[13:21:51.143]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:51.143]                               info)
[13:21:51.143]                           }
[13:21:51.143]                           else {
[13:21:51.143]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:51.143]                               info, version)
[13:21:51.143]                           }
[13:21:51.143]                           base::stop(msg)
[13:21:51.143]                         }
[13:21:51.143]                       })
[13:21:51.143]                     }
[13:21:51.143]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:51.143]                     base::options(mc.cores = 1L)
[13:21:51.143]                   }
[13:21:51.143]                   options(future.plan = NULL)
[13:21:51.143]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:51.143]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:51.143]                 }
[13:21:51.143]                 ...future.workdir <- getwd()
[13:21:51.143]             }
[13:21:51.143]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:51.143]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:51.143]         }
[13:21:51.143]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:51.143]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:51.143]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:51.143]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:51.143]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:51.143]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:51.143]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:51.143]             base::names(...future.oldOptions))
[13:21:51.143]     }
[13:21:51.143]     if (FALSE) {
[13:21:51.143]     }
[13:21:51.143]     else {
[13:21:51.143]         if (TRUE) {
[13:21:51.143]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:51.143]                 open = "w")
[13:21:51.143]         }
[13:21:51.143]         else {
[13:21:51.143]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:51.143]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:51.143]         }
[13:21:51.143]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:51.143]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:51.143]             base::sink(type = "output", split = FALSE)
[13:21:51.143]             base::close(...future.stdout)
[13:21:51.143]         }, add = TRUE)
[13:21:51.143]     }
[13:21:51.143]     ...future.frame <- base::sys.nframe()
[13:21:51.143]     ...future.conditions <- base::list()
[13:21:51.143]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:51.143]     if (FALSE) {
[13:21:51.143]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:51.143]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:51.143]     }
[13:21:51.143]     ...future.result <- base::tryCatch({
[13:21:51.143]         base::withCallingHandlers({
[13:21:51.143]             ...future.value <- base::withVisible(base::local({
[13:21:51.143]                 ...future.makeSendCondition <- local({
[13:21:51.143]                   sendCondition <- NULL
[13:21:51.143]                   function(frame = 1L) {
[13:21:51.143]                     if (is.function(sendCondition)) 
[13:21:51.143]                       return(sendCondition)
[13:21:51.143]                     ns <- getNamespace("parallel")
[13:21:51.143]                     if (exists("sendData", mode = "function", 
[13:21:51.143]                       envir = ns)) {
[13:21:51.143]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:51.143]                         envir = ns)
[13:21:51.143]                       envir <- sys.frame(frame)
[13:21:51.143]                       master <- NULL
[13:21:51.143]                       while (!identical(envir, .GlobalEnv) && 
[13:21:51.143]                         !identical(envir, emptyenv())) {
[13:21:51.143]                         if (exists("master", mode = "list", envir = envir, 
[13:21:51.143]                           inherits = FALSE)) {
[13:21:51.143]                           master <- get("master", mode = "list", 
[13:21:51.143]                             envir = envir, inherits = FALSE)
[13:21:51.143]                           if (inherits(master, c("SOCKnode", 
[13:21:51.143]                             "SOCK0node"))) {
[13:21:51.143]                             sendCondition <<- function(cond) {
[13:21:51.143]                               data <- list(type = "VALUE", value = cond, 
[13:21:51.143]                                 success = TRUE)
[13:21:51.143]                               parallel_sendData(master, data)
[13:21:51.143]                             }
[13:21:51.143]                             return(sendCondition)
[13:21:51.143]                           }
[13:21:51.143]                         }
[13:21:51.143]                         frame <- frame + 1L
[13:21:51.143]                         envir <- sys.frame(frame)
[13:21:51.143]                       }
[13:21:51.143]                     }
[13:21:51.143]                     sendCondition <<- function(cond) NULL
[13:21:51.143]                   }
[13:21:51.143]                 })
[13:21:51.143]                 withCallingHandlers({
[13:21:51.143]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:21:51.143]                 }, immediateCondition = function(cond) {
[13:21:51.143]                   sendCondition <- ...future.makeSendCondition()
[13:21:51.143]                   sendCondition(cond)
[13:21:51.143]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:51.143]                   {
[13:21:51.143]                     inherits <- base::inherits
[13:21:51.143]                     invokeRestart <- base::invokeRestart
[13:21:51.143]                     is.null <- base::is.null
[13:21:51.143]                     muffled <- FALSE
[13:21:51.143]                     if (inherits(cond, "message")) {
[13:21:51.143]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:51.143]                       if (muffled) 
[13:21:51.143]                         invokeRestart("muffleMessage")
[13:21:51.143]                     }
[13:21:51.143]                     else if (inherits(cond, "warning")) {
[13:21:51.143]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:51.143]                       if (muffled) 
[13:21:51.143]                         invokeRestart("muffleWarning")
[13:21:51.143]                     }
[13:21:51.143]                     else if (inherits(cond, "condition")) {
[13:21:51.143]                       if (!is.null(pattern)) {
[13:21:51.143]                         computeRestarts <- base::computeRestarts
[13:21:51.143]                         grepl <- base::grepl
[13:21:51.143]                         restarts <- computeRestarts(cond)
[13:21:51.143]                         for (restart in restarts) {
[13:21:51.143]                           name <- restart$name
[13:21:51.143]                           if (is.null(name)) 
[13:21:51.143]                             next
[13:21:51.143]                           if (!grepl(pattern, name)) 
[13:21:51.143]                             next
[13:21:51.143]                           invokeRestart(restart)
[13:21:51.143]                           muffled <- TRUE
[13:21:51.143]                           break
[13:21:51.143]                         }
[13:21:51.143]                       }
[13:21:51.143]                     }
[13:21:51.143]                     invisible(muffled)
[13:21:51.143]                   }
[13:21:51.143]                   muffleCondition(cond)
[13:21:51.143]                 })
[13:21:51.143]             }))
[13:21:51.143]             future::FutureResult(value = ...future.value$value, 
[13:21:51.143]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:51.143]                   ...future.rng), globalenv = if (FALSE) 
[13:21:51.143]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:51.143]                     ...future.globalenv.names))
[13:21:51.143]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:51.143]         }, condition = base::local({
[13:21:51.143]             c <- base::c
[13:21:51.143]             inherits <- base::inherits
[13:21:51.143]             invokeRestart <- base::invokeRestart
[13:21:51.143]             length <- base::length
[13:21:51.143]             list <- base::list
[13:21:51.143]             seq.int <- base::seq.int
[13:21:51.143]             signalCondition <- base::signalCondition
[13:21:51.143]             sys.calls <- base::sys.calls
[13:21:51.143]             `[[` <- base::`[[`
[13:21:51.143]             `+` <- base::`+`
[13:21:51.143]             `<<-` <- base::`<<-`
[13:21:51.143]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:51.143]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:51.143]                   3L)]
[13:21:51.143]             }
[13:21:51.143]             function(cond) {
[13:21:51.143]                 is_error <- inherits(cond, "error")
[13:21:51.143]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:51.143]                   NULL)
[13:21:51.143]                 if (is_error) {
[13:21:51.143]                   sessionInformation <- function() {
[13:21:51.143]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:51.143]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:51.143]                       search = base::search(), system = base::Sys.info())
[13:21:51.143]                   }
[13:21:51.143]                   ...future.conditions[[length(...future.conditions) + 
[13:21:51.143]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:51.143]                     cond$call), session = sessionInformation(), 
[13:21:51.143]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:51.143]                   signalCondition(cond)
[13:21:51.143]                 }
[13:21:51.143]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:51.143]                 "immediateCondition"))) {
[13:21:51.143]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:51.143]                   ...future.conditions[[length(...future.conditions) + 
[13:21:51.143]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:51.143]                   if (TRUE && !signal) {
[13:21:51.143]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:51.143]                     {
[13:21:51.143]                       inherits <- base::inherits
[13:21:51.143]                       invokeRestart <- base::invokeRestart
[13:21:51.143]                       is.null <- base::is.null
[13:21:51.143]                       muffled <- FALSE
[13:21:51.143]                       if (inherits(cond, "message")) {
[13:21:51.143]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:51.143]                         if (muffled) 
[13:21:51.143]                           invokeRestart("muffleMessage")
[13:21:51.143]                       }
[13:21:51.143]                       else if (inherits(cond, "warning")) {
[13:21:51.143]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:51.143]                         if (muffled) 
[13:21:51.143]                           invokeRestart("muffleWarning")
[13:21:51.143]                       }
[13:21:51.143]                       else if (inherits(cond, "condition")) {
[13:21:51.143]                         if (!is.null(pattern)) {
[13:21:51.143]                           computeRestarts <- base::computeRestarts
[13:21:51.143]                           grepl <- base::grepl
[13:21:51.143]                           restarts <- computeRestarts(cond)
[13:21:51.143]                           for (restart in restarts) {
[13:21:51.143]                             name <- restart$name
[13:21:51.143]                             if (is.null(name)) 
[13:21:51.143]                               next
[13:21:51.143]                             if (!grepl(pattern, name)) 
[13:21:51.143]                               next
[13:21:51.143]                             invokeRestart(restart)
[13:21:51.143]                             muffled <- TRUE
[13:21:51.143]                             break
[13:21:51.143]                           }
[13:21:51.143]                         }
[13:21:51.143]                       }
[13:21:51.143]                       invisible(muffled)
[13:21:51.143]                     }
[13:21:51.143]                     muffleCondition(cond, pattern = "^muffle")
[13:21:51.143]                   }
[13:21:51.143]                 }
[13:21:51.143]                 else {
[13:21:51.143]                   if (TRUE) {
[13:21:51.143]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:51.143]                     {
[13:21:51.143]                       inherits <- base::inherits
[13:21:51.143]                       invokeRestart <- base::invokeRestart
[13:21:51.143]                       is.null <- base::is.null
[13:21:51.143]                       muffled <- FALSE
[13:21:51.143]                       if (inherits(cond, "message")) {
[13:21:51.143]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:51.143]                         if (muffled) 
[13:21:51.143]                           invokeRestart("muffleMessage")
[13:21:51.143]                       }
[13:21:51.143]                       else if (inherits(cond, "warning")) {
[13:21:51.143]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:51.143]                         if (muffled) 
[13:21:51.143]                           invokeRestart("muffleWarning")
[13:21:51.143]                       }
[13:21:51.143]                       else if (inherits(cond, "condition")) {
[13:21:51.143]                         if (!is.null(pattern)) {
[13:21:51.143]                           computeRestarts <- base::computeRestarts
[13:21:51.143]                           grepl <- base::grepl
[13:21:51.143]                           restarts <- computeRestarts(cond)
[13:21:51.143]                           for (restart in restarts) {
[13:21:51.143]                             name <- restart$name
[13:21:51.143]                             if (is.null(name)) 
[13:21:51.143]                               next
[13:21:51.143]                             if (!grepl(pattern, name)) 
[13:21:51.143]                               next
[13:21:51.143]                             invokeRestart(restart)
[13:21:51.143]                             muffled <- TRUE
[13:21:51.143]                             break
[13:21:51.143]                           }
[13:21:51.143]                         }
[13:21:51.143]                       }
[13:21:51.143]                       invisible(muffled)
[13:21:51.143]                     }
[13:21:51.143]                     muffleCondition(cond, pattern = "^muffle")
[13:21:51.143]                   }
[13:21:51.143]                 }
[13:21:51.143]             }
[13:21:51.143]         }))
[13:21:51.143]     }, error = function(ex) {
[13:21:51.143]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:51.143]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:51.143]                 ...future.rng), started = ...future.startTime, 
[13:21:51.143]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:51.143]             version = "1.8"), class = "FutureResult")
[13:21:51.143]     }, finally = {
[13:21:51.143]         if (!identical(...future.workdir, getwd())) 
[13:21:51.143]             setwd(...future.workdir)
[13:21:51.143]         {
[13:21:51.143]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:51.143]                 ...future.oldOptions$nwarnings <- NULL
[13:21:51.143]             }
[13:21:51.143]             base::options(...future.oldOptions)
[13:21:51.143]             if (.Platform$OS.type == "windows") {
[13:21:51.143]                 old_names <- names(...future.oldEnvVars)
[13:21:51.143]                 envs <- base::Sys.getenv()
[13:21:51.143]                 names <- names(envs)
[13:21:51.143]                 common <- intersect(names, old_names)
[13:21:51.143]                 added <- setdiff(names, old_names)
[13:21:51.143]                 removed <- setdiff(old_names, names)
[13:21:51.143]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:51.143]                   envs[common]]
[13:21:51.143]                 NAMES <- toupper(changed)
[13:21:51.143]                 args <- list()
[13:21:51.143]                 for (kk in seq_along(NAMES)) {
[13:21:51.143]                   name <- changed[[kk]]
[13:21:51.143]                   NAME <- NAMES[[kk]]
[13:21:51.143]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:51.143]                     next
[13:21:51.143]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:51.143]                 }
[13:21:51.143]                 NAMES <- toupper(added)
[13:21:51.143]                 for (kk in seq_along(NAMES)) {
[13:21:51.143]                   name <- added[[kk]]
[13:21:51.143]                   NAME <- NAMES[[kk]]
[13:21:51.143]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:51.143]                     next
[13:21:51.143]                   args[[name]] <- ""
[13:21:51.143]                 }
[13:21:51.143]                 NAMES <- toupper(removed)
[13:21:51.143]                 for (kk in seq_along(NAMES)) {
[13:21:51.143]                   name <- removed[[kk]]
[13:21:51.143]                   NAME <- NAMES[[kk]]
[13:21:51.143]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:51.143]                     next
[13:21:51.143]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:51.143]                 }
[13:21:51.143]                 if (length(args) > 0) 
[13:21:51.143]                   base::do.call(base::Sys.setenv, args = args)
[13:21:51.143]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:51.143]             }
[13:21:51.143]             else {
[13:21:51.143]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:51.143]             }
[13:21:51.143]             {
[13:21:51.143]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:51.143]                   0L) {
[13:21:51.143]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:51.143]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:51.143]                   base::options(opts)
[13:21:51.143]                 }
[13:21:51.143]                 {
[13:21:51.143]                   {
[13:21:51.143]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:51.143]                     NULL
[13:21:51.143]                   }
[13:21:51.143]                   options(future.plan = NULL)
[13:21:51.143]                   if (is.na(NA_character_)) 
[13:21:51.143]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:51.143]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:51.143]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:51.143]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:51.143]                     envir = parent.frame()) 
[13:21:51.143]                   {
[13:21:51.143]                     if (is.function(workers)) 
[13:21:51.143]                       workers <- workers()
[13:21:51.143]                     workers <- structure(as.integer(workers), 
[13:21:51.143]                       class = class(workers))
[13:21:51.143]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:51.143]                       workers >= 1)
[13:21:51.143]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:51.143]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:51.143]                     }
[13:21:51.143]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:51.143]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:51.143]                       envir = envir)
[13:21:51.143]                     if (!future$lazy) 
[13:21:51.143]                       future <- run(future)
[13:21:51.143]                     invisible(future)
[13:21:51.143]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:51.143]                 }
[13:21:51.143]             }
[13:21:51.143]         }
[13:21:51.143]     })
[13:21:51.143]     if (TRUE) {
[13:21:51.143]         base::sink(type = "output", split = FALSE)
[13:21:51.143]         if (TRUE) {
[13:21:51.143]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:51.143]         }
[13:21:51.143]         else {
[13:21:51.143]             ...future.result["stdout"] <- base::list(NULL)
[13:21:51.143]         }
[13:21:51.143]         base::close(...future.stdout)
[13:21:51.143]         ...future.stdout <- NULL
[13:21:51.143]     }
[13:21:51.143]     ...future.result$conditions <- ...future.conditions
[13:21:51.143]     ...future.result$finished <- base::Sys.time()
[13:21:51.143]     ...future.result
[13:21:51.143] }
[13:21:51.146] MultisessionFuture started
[13:21:51.147] - Launch lazy future ... done
[13:21:51.147] run() for ‘MultisessionFuture’ ... done
[13:21:51.193] receiveMessageFromWorker() for ClusterFuture ...
[13:21:51.194] - Validating connection of MultisessionFuture
[13:21:51.194] - received message: FutureResult
[13:21:51.194] - Received FutureResult
[13:21:51.194] - Erased future from FutureRegistry
[13:21:51.194] result() for ClusterFuture ...
[13:21:51.195] - result already collected: FutureResult
[13:21:51.195] result() for ClusterFuture ... done
[13:21:51.195] signalConditions() ...
[13:21:51.195]  - include = ‘immediateCondition’
[13:21:51.195]  - exclude = 
[13:21:51.195]  - resignal = FALSE
[13:21:51.195]  - Number of conditions: 1
[13:21:51.195] signalConditions() ... done
[13:21:51.195] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:51.195] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = Inf ... DONE
- result = TRUE, recursive = FALSE ...
[13:21:51.196] getGlobalsAndPackages() ...
[13:21:51.196] Searching for globals...
[13:21:51.197] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:21:51.197] Searching for globals ... DONE
[13:21:51.197] Resolving globals: FALSE
[13:21:51.197] 
[13:21:51.198] 
[13:21:51.198] getGlobalsAndPackages() ... DONE
[13:21:51.198] run() for ‘Future’ ...
[13:21:51.198] - state: ‘created’
[13:21:51.198] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:51.212] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:51.212] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:51.212]   - Field: ‘node’
[13:21:51.213]   - Field: ‘label’
[13:21:51.213]   - Field: ‘local’
[13:21:51.213]   - Field: ‘owner’
[13:21:51.213]   - Field: ‘envir’
[13:21:51.213]   - Field: ‘workers’
[13:21:51.213]   - Field: ‘packages’
[13:21:51.213]   - Field: ‘gc’
[13:21:51.213]   - Field: ‘conditions’
[13:21:51.213]   - Field: ‘persistent’
[13:21:51.213]   - Field: ‘expr’
[13:21:51.214]   - Field: ‘uuid’
[13:21:51.214]   - Field: ‘seed’
[13:21:51.214]   - Field: ‘version’
[13:21:51.214]   - Field: ‘result’
[13:21:51.214]   - Field: ‘asynchronous’
[13:21:51.214]   - Field: ‘calls’
[13:21:51.214]   - Field: ‘globals’
[13:21:51.214]   - Field: ‘stdout’
[13:21:51.214]   - Field: ‘earlySignal’
[13:21:51.214]   - Field: ‘lazy’
[13:21:51.214]   - Field: ‘state’
[13:21:51.215] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:51.215] - Launch lazy future ...
[13:21:51.215] Packages needed by the future expression (n = 0): <none>
[13:21:51.215] Packages needed by future strategies (n = 0): <none>
[13:21:51.215] {
[13:21:51.215]     {
[13:21:51.215]         {
[13:21:51.215]             ...future.startTime <- base::Sys.time()
[13:21:51.215]             {
[13:21:51.215]                 {
[13:21:51.215]                   {
[13:21:51.215]                     {
[13:21:51.215]                       base::local({
[13:21:51.215]                         has_future <- base::requireNamespace("future", 
[13:21:51.215]                           quietly = TRUE)
[13:21:51.215]                         if (has_future) {
[13:21:51.215]                           ns <- base::getNamespace("future")
[13:21:51.215]                           version <- ns[[".package"]][["version"]]
[13:21:51.215]                           if (is.null(version)) 
[13:21:51.215]                             version <- utils::packageVersion("future")
[13:21:51.215]                         }
[13:21:51.215]                         else {
[13:21:51.215]                           version <- NULL
[13:21:51.215]                         }
[13:21:51.215]                         if (!has_future || version < "1.8.0") {
[13:21:51.215]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:51.215]                             "", base::R.version$version.string), 
[13:21:51.215]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:51.215]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:51.215]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:51.215]                               "release", "version")], collapse = " "), 
[13:21:51.215]                             hostname = base::Sys.info()[["nodename"]])
[13:21:51.215]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:51.215]                             info)
[13:21:51.215]                           info <- base::paste(info, collapse = "; ")
[13:21:51.215]                           if (!has_future) {
[13:21:51.215]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:51.215]                               info)
[13:21:51.215]                           }
[13:21:51.215]                           else {
[13:21:51.215]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:51.215]                               info, version)
[13:21:51.215]                           }
[13:21:51.215]                           base::stop(msg)
[13:21:51.215]                         }
[13:21:51.215]                       })
[13:21:51.215]                     }
[13:21:51.215]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:51.215]                     base::options(mc.cores = 1L)
[13:21:51.215]                   }
[13:21:51.215]                   options(future.plan = NULL)
[13:21:51.215]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:51.215]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:51.215]                 }
[13:21:51.215]                 ...future.workdir <- getwd()
[13:21:51.215]             }
[13:21:51.215]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:51.215]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:51.215]         }
[13:21:51.215]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:51.215]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:51.215]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:51.215]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:51.215]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:51.215]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:51.215]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:51.215]             base::names(...future.oldOptions))
[13:21:51.215]     }
[13:21:51.215]     if (FALSE) {
[13:21:51.215]     }
[13:21:51.215]     else {
[13:21:51.215]         if (TRUE) {
[13:21:51.215]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:51.215]                 open = "w")
[13:21:51.215]         }
[13:21:51.215]         else {
[13:21:51.215]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:51.215]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:51.215]         }
[13:21:51.215]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:51.215]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:51.215]             base::sink(type = "output", split = FALSE)
[13:21:51.215]             base::close(...future.stdout)
[13:21:51.215]         }, add = TRUE)
[13:21:51.215]     }
[13:21:51.215]     ...future.frame <- base::sys.nframe()
[13:21:51.215]     ...future.conditions <- base::list()
[13:21:51.215]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:51.215]     if (FALSE) {
[13:21:51.215]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:51.215]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:51.215]     }
[13:21:51.215]     ...future.result <- base::tryCatch({
[13:21:51.215]         base::withCallingHandlers({
[13:21:51.215]             ...future.value <- base::withVisible(base::local({
[13:21:51.215]                 ...future.makeSendCondition <- local({
[13:21:51.215]                   sendCondition <- NULL
[13:21:51.215]                   function(frame = 1L) {
[13:21:51.215]                     if (is.function(sendCondition)) 
[13:21:51.215]                       return(sendCondition)
[13:21:51.215]                     ns <- getNamespace("parallel")
[13:21:51.215]                     if (exists("sendData", mode = "function", 
[13:21:51.215]                       envir = ns)) {
[13:21:51.215]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:51.215]                         envir = ns)
[13:21:51.215]                       envir <- sys.frame(frame)
[13:21:51.215]                       master <- NULL
[13:21:51.215]                       while (!identical(envir, .GlobalEnv) && 
[13:21:51.215]                         !identical(envir, emptyenv())) {
[13:21:51.215]                         if (exists("master", mode = "list", envir = envir, 
[13:21:51.215]                           inherits = FALSE)) {
[13:21:51.215]                           master <- get("master", mode = "list", 
[13:21:51.215]                             envir = envir, inherits = FALSE)
[13:21:51.215]                           if (inherits(master, c("SOCKnode", 
[13:21:51.215]                             "SOCK0node"))) {
[13:21:51.215]                             sendCondition <<- function(cond) {
[13:21:51.215]                               data <- list(type = "VALUE", value = cond, 
[13:21:51.215]                                 success = TRUE)
[13:21:51.215]                               parallel_sendData(master, data)
[13:21:51.215]                             }
[13:21:51.215]                             return(sendCondition)
[13:21:51.215]                           }
[13:21:51.215]                         }
[13:21:51.215]                         frame <- frame + 1L
[13:21:51.215]                         envir <- sys.frame(frame)
[13:21:51.215]                       }
[13:21:51.215]                     }
[13:21:51.215]                     sendCondition <<- function(cond) NULL
[13:21:51.215]                   }
[13:21:51.215]                 })
[13:21:51.215]                 withCallingHandlers({
[13:21:51.215]                   {
[13:21:51.215]                     Sys.sleep(0.5)
[13:21:51.215]                     list(a = 1, b = 42L)
[13:21:51.215]                   }
[13:21:51.215]                 }, immediateCondition = function(cond) {
[13:21:51.215]                   sendCondition <- ...future.makeSendCondition()
[13:21:51.215]                   sendCondition(cond)
[13:21:51.215]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:51.215]                   {
[13:21:51.215]                     inherits <- base::inherits
[13:21:51.215]                     invokeRestart <- base::invokeRestart
[13:21:51.215]                     is.null <- base::is.null
[13:21:51.215]                     muffled <- FALSE
[13:21:51.215]                     if (inherits(cond, "message")) {
[13:21:51.215]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:51.215]                       if (muffled) 
[13:21:51.215]                         invokeRestart("muffleMessage")
[13:21:51.215]                     }
[13:21:51.215]                     else if (inherits(cond, "warning")) {
[13:21:51.215]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:51.215]                       if (muffled) 
[13:21:51.215]                         invokeRestart("muffleWarning")
[13:21:51.215]                     }
[13:21:51.215]                     else if (inherits(cond, "condition")) {
[13:21:51.215]                       if (!is.null(pattern)) {
[13:21:51.215]                         computeRestarts <- base::computeRestarts
[13:21:51.215]                         grepl <- base::grepl
[13:21:51.215]                         restarts <- computeRestarts(cond)
[13:21:51.215]                         for (restart in restarts) {
[13:21:51.215]                           name <- restart$name
[13:21:51.215]                           if (is.null(name)) 
[13:21:51.215]                             next
[13:21:51.215]                           if (!grepl(pattern, name)) 
[13:21:51.215]                             next
[13:21:51.215]                           invokeRestart(restart)
[13:21:51.215]                           muffled <- TRUE
[13:21:51.215]                           break
[13:21:51.215]                         }
[13:21:51.215]                       }
[13:21:51.215]                     }
[13:21:51.215]                     invisible(muffled)
[13:21:51.215]                   }
[13:21:51.215]                   muffleCondition(cond)
[13:21:51.215]                 })
[13:21:51.215]             }))
[13:21:51.215]             future::FutureResult(value = ...future.value$value, 
[13:21:51.215]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:51.215]                   ...future.rng), globalenv = if (FALSE) 
[13:21:51.215]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:51.215]                     ...future.globalenv.names))
[13:21:51.215]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:51.215]         }, condition = base::local({
[13:21:51.215]             c <- base::c
[13:21:51.215]             inherits <- base::inherits
[13:21:51.215]             invokeRestart <- base::invokeRestart
[13:21:51.215]             length <- base::length
[13:21:51.215]             list <- base::list
[13:21:51.215]             seq.int <- base::seq.int
[13:21:51.215]             signalCondition <- base::signalCondition
[13:21:51.215]             sys.calls <- base::sys.calls
[13:21:51.215]             `[[` <- base::`[[`
[13:21:51.215]             `+` <- base::`+`
[13:21:51.215]             `<<-` <- base::`<<-`
[13:21:51.215]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:51.215]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:51.215]                   3L)]
[13:21:51.215]             }
[13:21:51.215]             function(cond) {
[13:21:51.215]                 is_error <- inherits(cond, "error")
[13:21:51.215]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:51.215]                   NULL)
[13:21:51.215]                 if (is_error) {
[13:21:51.215]                   sessionInformation <- function() {
[13:21:51.215]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:51.215]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:51.215]                       search = base::search(), system = base::Sys.info())
[13:21:51.215]                   }
[13:21:51.215]                   ...future.conditions[[length(...future.conditions) + 
[13:21:51.215]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:51.215]                     cond$call), session = sessionInformation(), 
[13:21:51.215]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:51.215]                   signalCondition(cond)
[13:21:51.215]                 }
[13:21:51.215]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:51.215]                 "immediateCondition"))) {
[13:21:51.215]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:51.215]                   ...future.conditions[[length(...future.conditions) + 
[13:21:51.215]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:51.215]                   if (TRUE && !signal) {
[13:21:51.215]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:51.215]                     {
[13:21:51.215]                       inherits <- base::inherits
[13:21:51.215]                       invokeRestart <- base::invokeRestart
[13:21:51.215]                       is.null <- base::is.null
[13:21:51.215]                       muffled <- FALSE
[13:21:51.215]                       if (inherits(cond, "message")) {
[13:21:51.215]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:51.215]                         if (muffled) 
[13:21:51.215]                           invokeRestart("muffleMessage")
[13:21:51.215]                       }
[13:21:51.215]                       else if (inherits(cond, "warning")) {
[13:21:51.215]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:51.215]                         if (muffled) 
[13:21:51.215]                           invokeRestart("muffleWarning")
[13:21:51.215]                       }
[13:21:51.215]                       else if (inherits(cond, "condition")) {
[13:21:51.215]                         if (!is.null(pattern)) {
[13:21:51.215]                           computeRestarts <- base::computeRestarts
[13:21:51.215]                           grepl <- base::grepl
[13:21:51.215]                           restarts <- computeRestarts(cond)
[13:21:51.215]                           for (restart in restarts) {
[13:21:51.215]                             name <- restart$name
[13:21:51.215]                             if (is.null(name)) 
[13:21:51.215]                               next
[13:21:51.215]                             if (!grepl(pattern, name)) 
[13:21:51.215]                               next
[13:21:51.215]                             invokeRestart(restart)
[13:21:51.215]                             muffled <- TRUE
[13:21:51.215]                             break
[13:21:51.215]                           }
[13:21:51.215]                         }
[13:21:51.215]                       }
[13:21:51.215]                       invisible(muffled)
[13:21:51.215]                     }
[13:21:51.215]                     muffleCondition(cond, pattern = "^muffle")
[13:21:51.215]                   }
[13:21:51.215]                 }
[13:21:51.215]                 else {
[13:21:51.215]                   if (TRUE) {
[13:21:51.215]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:51.215]                     {
[13:21:51.215]                       inherits <- base::inherits
[13:21:51.215]                       invokeRestart <- base::invokeRestart
[13:21:51.215]                       is.null <- base::is.null
[13:21:51.215]                       muffled <- FALSE
[13:21:51.215]                       if (inherits(cond, "message")) {
[13:21:51.215]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:51.215]                         if (muffled) 
[13:21:51.215]                           invokeRestart("muffleMessage")
[13:21:51.215]                       }
[13:21:51.215]                       else if (inherits(cond, "warning")) {
[13:21:51.215]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:51.215]                         if (muffled) 
[13:21:51.215]                           invokeRestart("muffleWarning")
[13:21:51.215]                       }
[13:21:51.215]                       else if (inherits(cond, "condition")) {
[13:21:51.215]                         if (!is.null(pattern)) {
[13:21:51.215]                           computeRestarts <- base::computeRestarts
[13:21:51.215]                           grepl <- base::grepl
[13:21:51.215]                           restarts <- computeRestarts(cond)
[13:21:51.215]                           for (restart in restarts) {
[13:21:51.215]                             name <- restart$name
[13:21:51.215]                             if (is.null(name)) 
[13:21:51.215]                               next
[13:21:51.215]                             if (!grepl(pattern, name)) 
[13:21:51.215]                               next
[13:21:51.215]                             invokeRestart(restart)
[13:21:51.215]                             muffled <- TRUE
[13:21:51.215]                             break
[13:21:51.215]                           }
[13:21:51.215]                         }
[13:21:51.215]                       }
[13:21:51.215]                       invisible(muffled)
[13:21:51.215]                     }
[13:21:51.215]                     muffleCondition(cond, pattern = "^muffle")
[13:21:51.215]                   }
[13:21:51.215]                 }
[13:21:51.215]             }
[13:21:51.215]         }))
[13:21:51.215]     }, error = function(ex) {
[13:21:51.215]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:51.215]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:51.215]                 ...future.rng), started = ...future.startTime, 
[13:21:51.215]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:51.215]             version = "1.8"), class = "FutureResult")
[13:21:51.215]     }, finally = {
[13:21:51.215]         if (!identical(...future.workdir, getwd())) 
[13:21:51.215]             setwd(...future.workdir)
[13:21:51.215]         {
[13:21:51.215]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:51.215]                 ...future.oldOptions$nwarnings <- NULL
[13:21:51.215]             }
[13:21:51.215]             base::options(...future.oldOptions)
[13:21:51.215]             if (.Platform$OS.type == "windows") {
[13:21:51.215]                 old_names <- names(...future.oldEnvVars)
[13:21:51.215]                 envs <- base::Sys.getenv()
[13:21:51.215]                 names <- names(envs)
[13:21:51.215]                 common <- intersect(names, old_names)
[13:21:51.215]                 added <- setdiff(names, old_names)
[13:21:51.215]                 removed <- setdiff(old_names, names)
[13:21:51.215]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:51.215]                   envs[common]]
[13:21:51.215]                 NAMES <- toupper(changed)
[13:21:51.215]                 args <- list()
[13:21:51.215]                 for (kk in seq_along(NAMES)) {
[13:21:51.215]                   name <- changed[[kk]]
[13:21:51.215]                   NAME <- NAMES[[kk]]
[13:21:51.215]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:51.215]                     next
[13:21:51.215]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:51.215]                 }
[13:21:51.215]                 NAMES <- toupper(added)
[13:21:51.215]                 for (kk in seq_along(NAMES)) {
[13:21:51.215]                   name <- added[[kk]]
[13:21:51.215]                   NAME <- NAMES[[kk]]
[13:21:51.215]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:51.215]                     next
[13:21:51.215]                   args[[name]] <- ""
[13:21:51.215]                 }
[13:21:51.215]                 NAMES <- toupper(removed)
[13:21:51.215]                 for (kk in seq_along(NAMES)) {
[13:21:51.215]                   name <- removed[[kk]]
[13:21:51.215]                   NAME <- NAMES[[kk]]
[13:21:51.215]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:51.215]                     next
[13:21:51.215]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:51.215]                 }
[13:21:51.215]                 if (length(args) > 0) 
[13:21:51.215]                   base::do.call(base::Sys.setenv, args = args)
[13:21:51.215]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:51.215]             }
[13:21:51.215]             else {
[13:21:51.215]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:51.215]             }
[13:21:51.215]             {
[13:21:51.215]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:51.215]                   0L) {
[13:21:51.215]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:51.215]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:51.215]                   base::options(opts)
[13:21:51.215]                 }
[13:21:51.215]                 {
[13:21:51.215]                   {
[13:21:51.215]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:51.215]                     NULL
[13:21:51.215]                   }
[13:21:51.215]                   options(future.plan = NULL)
[13:21:51.215]                   if (is.na(NA_character_)) 
[13:21:51.215]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:51.215]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:51.215]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:51.215]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:51.215]                     envir = parent.frame()) 
[13:21:51.215]                   {
[13:21:51.215]                     if (is.function(workers)) 
[13:21:51.215]                       workers <- workers()
[13:21:51.215]                     workers <- structure(as.integer(workers), 
[13:21:51.215]                       class = class(workers))
[13:21:51.215]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:51.215]                       workers >= 1)
[13:21:51.215]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:51.215]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:51.215]                     }
[13:21:51.215]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:51.215]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:51.215]                       envir = envir)
[13:21:51.215]                     if (!future$lazy) 
[13:21:51.215]                       future <- run(future)
[13:21:51.215]                     invisible(future)
[13:21:51.215]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:51.215]                 }
[13:21:51.215]             }
[13:21:51.215]         }
[13:21:51.215]     })
[13:21:51.215]     if (TRUE) {
[13:21:51.215]         base::sink(type = "output", split = FALSE)
[13:21:51.215]         if (TRUE) {
[13:21:51.215]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:51.215]         }
[13:21:51.215]         else {
[13:21:51.215]             ...future.result["stdout"] <- base::list(NULL)
[13:21:51.215]         }
[13:21:51.215]         base::close(...future.stdout)
[13:21:51.215]         ...future.stdout <- NULL
[13:21:51.215]     }
[13:21:51.215]     ...future.result$conditions <- ...future.conditions
[13:21:51.215]     ...future.result$finished <- base::Sys.time()
[13:21:51.215]     ...future.result
[13:21:51.215] }
[13:21:51.218] MultisessionFuture started
[13:21:51.219] - Launch lazy future ... done
[13:21:51.219] run() for ‘MultisessionFuture’ ... done
[13:21:51.766] receiveMessageFromWorker() for ClusterFuture ...
[13:21:51.767] - Validating connection of MultisessionFuture
[13:21:51.767] - received message: FutureResult
[13:21:51.767] - Received FutureResult
[13:21:51.767] - Erased future from FutureRegistry
[13:21:51.767] result() for ClusterFuture ...
[13:21:51.767] - result already collected: FutureResult
[13:21:51.767] result() for ClusterFuture ... done
[13:21:51.767] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:51.768] A MultisessionFuture was resolved
[13:21:51.768] getGlobalsAndPackages() ...
[13:21:51.768] Searching for globals...
[13:21:51.769] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:21:51.769] Searching for globals ... DONE
[13:21:51.769] Resolving globals: FALSE
[13:21:51.769] 
[13:21:51.770] 
[13:21:51.770] getGlobalsAndPackages() ... DONE
[13:21:51.770] run() for ‘Future’ ...
[13:21:51.770] - state: ‘created’
[13:21:51.770] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:51.784] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:51.785] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:51.785]   - Field: ‘node’
[13:21:51.785]   - Field: ‘label’
[13:21:51.785]   - Field: ‘local’
[13:21:51.785]   - Field: ‘owner’
[13:21:51.785]   - Field: ‘envir’
[13:21:51.785]   - Field: ‘workers’
[13:21:51.785]   - Field: ‘packages’
[13:21:51.785]   - Field: ‘gc’
[13:21:51.785]   - Field: ‘conditions’
[13:21:51.785]   - Field: ‘persistent’
[13:21:51.786]   - Field: ‘expr’
[13:21:51.786]   - Field: ‘uuid’
[13:21:51.786]   - Field: ‘seed’
[13:21:51.786]   - Field: ‘version’
[13:21:51.786]   - Field: ‘result’
[13:21:51.786]   - Field: ‘asynchronous’
[13:21:51.786]   - Field: ‘calls’
[13:21:51.786]   - Field: ‘globals’
[13:21:51.786]   - Field: ‘stdout’
[13:21:51.786]   - Field: ‘earlySignal’
[13:21:51.786]   - Field: ‘lazy’
[13:21:51.787]   - Field: ‘state’
[13:21:51.787] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:51.787] - Launch lazy future ...
[13:21:51.787] Packages needed by the future expression (n = 0): <none>
[13:21:51.787] Packages needed by future strategies (n = 0): <none>
[13:21:51.788] {
[13:21:51.788]     {
[13:21:51.788]         {
[13:21:51.788]             ...future.startTime <- base::Sys.time()
[13:21:51.788]             {
[13:21:51.788]                 {
[13:21:51.788]                   {
[13:21:51.788]                     {
[13:21:51.788]                       base::local({
[13:21:51.788]                         has_future <- base::requireNamespace("future", 
[13:21:51.788]                           quietly = TRUE)
[13:21:51.788]                         if (has_future) {
[13:21:51.788]                           ns <- base::getNamespace("future")
[13:21:51.788]                           version <- ns[[".package"]][["version"]]
[13:21:51.788]                           if (is.null(version)) 
[13:21:51.788]                             version <- utils::packageVersion("future")
[13:21:51.788]                         }
[13:21:51.788]                         else {
[13:21:51.788]                           version <- NULL
[13:21:51.788]                         }
[13:21:51.788]                         if (!has_future || version < "1.8.0") {
[13:21:51.788]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:51.788]                             "", base::R.version$version.string), 
[13:21:51.788]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:51.788]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:51.788]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:51.788]                               "release", "version")], collapse = " "), 
[13:21:51.788]                             hostname = base::Sys.info()[["nodename"]])
[13:21:51.788]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:51.788]                             info)
[13:21:51.788]                           info <- base::paste(info, collapse = "; ")
[13:21:51.788]                           if (!has_future) {
[13:21:51.788]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:51.788]                               info)
[13:21:51.788]                           }
[13:21:51.788]                           else {
[13:21:51.788]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:51.788]                               info, version)
[13:21:51.788]                           }
[13:21:51.788]                           base::stop(msg)
[13:21:51.788]                         }
[13:21:51.788]                       })
[13:21:51.788]                     }
[13:21:51.788]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:51.788]                     base::options(mc.cores = 1L)
[13:21:51.788]                   }
[13:21:51.788]                   options(future.plan = NULL)
[13:21:51.788]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:51.788]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:51.788]                 }
[13:21:51.788]                 ...future.workdir <- getwd()
[13:21:51.788]             }
[13:21:51.788]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:51.788]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:51.788]         }
[13:21:51.788]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:51.788]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:51.788]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:51.788]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:51.788]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:51.788]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:51.788]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:51.788]             base::names(...future.oldOptions))
[13:21:51.788]     }
[13:21:51.788]     if (FALSE) {
[13:21:51.788]     }
[13:21:51.788]     else {
[13:21:51.788]         if (TRUE) {
[13:21:51.788]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:51.788]                 open = "w")
[13:21:51.788]         }
[13:21:51.788]         else {
[13:21:51.788]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:51.788]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:51.788]         }
[13:21:51.788]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:51.788]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:51.788]             base::sink(type = "output", split = FALSE)
[13:21:51.788]             base::close(...future.stdout)
[13:21:51.788]         }, add = TRUE)
[13:21:51.788]     }
[13:21:51.788]     ...future.frame <- base::sys.nframe()
[13:21:51.788]     ...future.conditions <- base::list()
[13:21:51.788]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:51.788]     if (FALSE) {
[13:21:51.788]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:51.788]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:51.788]     }
[13:21:51.788]     ...future.result <- base::tryCatch({
[13:21:51.788]         base::withCallingHandlers({
[13:21:51.788]             ...future.value <- base::withVisible(base::local({
[13:21:51.788]                 ...future.makeSendCondition <- local({
[13:21:51.788]                   sendCondition <- NULL
[13:21:51.788]                   function(frame = 1L) {
[13:21:51.788]                     if (is.function(sendCondition)) 
[13:21:51.788]                       return(sendCondition)
[13:21:51.788]                     ns <- getNamespace("parallel")
[13:21:51.788]                     if (exists("sendData", mode = "function", 
[13:21:51.788]                       envir = ns)) {
[13:21:51.788]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:51.788]                         envir = ns)
[13:21:51.788]                       envir <- sys.frame(frame)
[13:21:51.788]                       master <- NULL
[13:21:51.788]                       while (!identical(envir, .GlobalEnv) && 
[13:21:51.788]                         !identical(envir, emptyenv())) {
[13:21:51.788]                         if (exists("master", mode = "list", envir = envir, 
[13:21:51.788]                           inherits = FALSE)) {
[13:21:51.788]                           master <- get("master", mode = "list", 
[13:21:51.788]                             envir = envir, inherits = FALSE)
[13:21:51.788]                           if (inherits(master, c("SOCKnode", 
[13:21:51.788]                             "SOCK0node"))) {
[13:21:51.788]                             sendCondition <<- function(cond) {
[13:21:51.788]                               data <- list(type = "VALUE", value = cond, 
[13:21:51.788]                                 success = TRUE)
[13:21:51.788]                               parallel_sendData(master, data)
[13:21:51.788]                             }
[13:21:51.788]                             return(sendCondition)
[13:21:51.788]                           }
[13:21:51.788]                         }
[13:21:51.788]                         frame <- frame + 1L
[13:21:51.788]                         envir <- sys.frame(frame)
[13:21:51.788]                       }
[13:21:51.788]                     }
[13:21:51.788]                     sendCondition <<- function(cond) NULL
[13:21:51.788]                   }
[13:21:51.788]                 })
[13:21:51.788]                 withCallingHandlers({
[13:21:51.788]                   {
[13:21:51.788]                     Sys.sleep(0.5)
[13:21:51.788]                     list(a = 1, b = 42L)
[13:21:51.788]                   }
[13:21:51.788]                 }, immediateCondition = function(cond) {
[13:21:51.788]                   sendCondition <- ...future.makeSendCondition()
[13:21:51.788]                   sendCondition(cond)
[13:21:51.788]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:51.788]                   {
[13:21:51.788]                     inherits <- base::inherits
[13:21:51.788]                     invokeRestart <- base::invokeRestart
[13:21:51.788]                     is.null <- base::is.null
[13:21:51.788]                     muffled <- FALSE
[13:21:51.788]                     if (inherits(cond, "message")) {
[13:21:51.788]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:51.788]                       if (muffled) 
[13:21:51.788]                         invokeRestart("muffleMessage")
[13:21:51.788]                     }
[13:21:51.788]                     else if (inherits(cond, "warning")) {
[13:21:51.788]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:51.788]                       if (muffled) 
[13:21:51.788]                         invokeRestart("muffleWarning")
[13:21:51.788]                     }
[13:21:51.788]                     else if (inherits(cond, "condition")) {
[13:21:51.788]                       if (!is.null(pattern)) {
[13:21:51.788]                         computeRestarts <- base::computeRestarts
[13:21:51.788]                         grepl <- base::grepl
[13:21:51.788]                         restarts <- computeRestarts(cond)
[13:21:51.788]                         for (restart in restarts) {
[13:21:51.788]                           name <- restart$name
[13:21:51.788]                           if (is.null(name)) 
[13:21:51.788]                             next
[13:21:51.788]                           if (!grepl(pattern, name)) 
[13:21:51.788]                             next
[13:21:51.788]                           invokeRestart(restart)
[13:21:51.788]                           muffled <- TRUE
[13:21:51.788]                           break
[13:21:51.788]                         }
[13:21:51.788]                       }
[13:21:51.788]                     }
[13:21:51.788]                     invisible(muffled)
[13:21:51.788]                   }
[13:21:51.788]                   muffleCondition(cond)
[13:21:51.788]                 })
[13:21:51.788]             }))
[13:21:51.788]             future::FutureResult(value = ...future.value$value, 
[13:21:51.788]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:51.788]                   ...future.rng), globalenv = if (FALSE) 
[13:21:51.788]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:51.788]                     ...future.globalenv.names))
[13:21:51.788]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:51.788]         }, condition = base::local({
[13:21:51.788]             c <- base::c
[13:21:51.788]             inherits <- base::inherits
[13:21:51.788]             invokeRestart <- base::invokeRestart
[13:21:51.788]             length <- base::length
[13:21:51.788]             list <- base::list
[13:21:51.788]             seq.int <- base::seq.int
[13:21:51.788]             signalCondition <- base::signalCondition
[13:21:51.788]             sys.calls <- base::sys.calls
[13:21:51.788]             `[[` <- base::`[[`
[13:21:51.788]             `+` <- base::`+`
[13:21:51.788]             `<<-` <- base::`<<-`
[13:21:51.788]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:51.788]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:51.788]                   3L)]
[13:21:51.788]             }
[13:21:51.788]             function(cond) {
[13:21:51.788]                 is_error <- inherits(cond, "error")
[13:21:51.788]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:51.788]                   NULL)
[13:21:51.788]                 if (is_error) {
[13:21:51.788]                   sessionInformation <- function() {
[13:21:51.788]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:51.788]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:51.788]                       search = base::search(), system = base::Sys.info())
[13:21:51.788]                   }
[13:21:51.788]                   ...future.conditions[[length(...future.conditions) + 
[13:21:51.788]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:51.788]                     cond$call), session = sessionInformation(), 
[13:21:51.788]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:51.788]                   signalCondition(cond)
[13:21:51.788]                 }
[13:21:51.788]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:51.788]                 "immediateCondition"))) {
[13:21:51.788]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:51.788]                   ...future.conditions[[length(...future.conditions) + 
[13:21:51.788]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:51.788]                   if (TRUE && !signal) {
[13:21:51.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:51.788]                     {
[13:21:51.788]                       inherits <- base::inherits
[13:21:51.788]                       invokeRestart <- base::invokeRestart
[13:21:51.788]                       is.null <- base::is.null
[13:21:51.788]                       muffled <- FALSE
[13:21:51.788]                       if (inherits(cond, "message")) {
[13:21:51.788]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:51.788]                         if (muffled) 
[13:21:51.788]                           invokeRestart("muffleMessage")
[13:21:51.788]                       }
[13:21:51.788]                       else if (inherits(cond, "warning")) {
[13:21:51.788]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:51.788]                         if (muffled) 
[13:21:51.788]                           invokeRestart("muffleWarning")
[13:21:51.788]                       }
[13:21:51.788]                       else if (inherits(cond, "condition")) {
[13:21:51.788]                         if (!is.null(pattern)) {
[13:21:51.788]                           computeRestarts <- base::computeRestarts
[13:21:51.788]                           grepl <- base::grepl
[13:21:51.788]                           restarts <- computeRestarts(cond)
[13:21:51.788]                           for (restart in restarts) {
[13:21:51.788]                             name <- restart$name
[13:21:51.788]                             if (is.null(name)) 
[13:21:51.788]                               next
[13:21:51.788]                             if (!grepl(pattern, name)) 
[13:21:51.788]                               next
[13:21:51.788]                             invokeRestart(restart)
[13:21:51.788]                             muffled <- TRUE
[13:21:51.788]                             break
[13:21:51.788]                           }
[13:21:51.788]                         }
[13:21:51.788]                       }
[13:21:51.788]                       invisible(muffled)
[13:21:51.788]                     }
[13:21:51.788]                     muffleCondition(cond, pattern = "^muffle")
[13:21:51.788]                   }
[13:21:51.788]                 }
[13:21:51.788]                 else {
[13:21:51.788]                   if (TRUE) {
[13:21:51.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:51.788]                     {
[13:21:51.788]                       inherits <- base::inherits
[13:21:51.788]                       invokeRestart <- base::invokeRestart
[13:21:51.788]                       is.null <- base::is.null
[13:21:51.788]                       muffled <- FALSE
[13:21:51.788]                       if (inherits(cond, "message")) {
[13:21:51.788]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:51.788]                         if (muffled) 
[13:21:51.788]                           invokeRestart("muffleMessage")
[13:21:51.788]                       }
[13:21:51.788]                       else if (inherits(cond, "warning")) {
[13:21:51.788]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:51.788]                         if (muffled) 
[13:21:51.788]                           invokeRestart("muffleWarning")
[13:21:51.788]                       }
[13:21:51.788]                       else if (inherits(cond, "condition")) {
[13:21:51.788]                         if (!is.null(pattern)) {
[13:21:51.788]                           computeRestarts <- base::computeRestarts
[13:21:51.788]                           grepl <- base::grepl
[13:21:51.788]                           restarts <- computeRestarts(cond)
[13:21:51.788]                           for (restart in restarts) {
[13:21:51.788]                             name <- restart$name
[13:21:51.788]                             if (is.null(name)) 
[13:21:51.788]                               next
[13:21:51.788]                             if (!grepl(pattern, name)) 
[13:21:51.788]                               next
[13:21:51.788]                             invokeRestart(restart)
[13:21:51.788]                             muffled <- TRUE
[13:21:51.788]                             break
[13:21:51.788]                           }
[13:21:51.788]                         }
[13:21:51.788]                       }
[13:21:51.788]                       invisible(muffled)
[13:21:51.788]                     }
[13:21:51.788]                     muffleCondition(cond, pattern = "^muffle")
[13:21:51.788]                   }
[13:21:51.788]                 }
[13:21:51.788]             }
[13:21:51.788]         }))
[13:21:51.788]     }, error = function(ex) {
[13:21:51.788]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:51.788]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:51.788]                 ...future.rng), started = ...future.startTime, 
[13:21:51.788]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:51.788]             version = "1.8"), class = "FutureResult")
[13:21:51.788]     }, finally = {
[13:21:51.788]         if (!identical(...future.workdir, getwd())) 
[13:21:51.788]             setwd(...future.workdir)
[13:21:51.788]         {
[13:21:51.788]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:51.788]                 ...future.oldOptions$nwarnings <- NULL
[13:21:51.788]             }
[13:21:51.788]             base::options(...future.oldOptions)
[13:21:51.788]             if (.Platform$OS.type == "windows") {
[13:21:51.788]                 old_names <- names(...future.oldEnvVars)
[13:21:51.788]                 envs <- base::Sys.getenv()
[13:21:51.788]                 names <- names(envs)
[13:21:51.788]                 common <- intersect(names, old_names)
[13:21:51.788]                 added <- setdiff(names, old_names)
[13:21:51.788]                 removed <- setdiff(old_names, names)
[13:21:51.788]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:51.788]                   envs[common]]
[13:21:51.788]                 NAMES <- toupper(changed)
[13:21:51.788]                 args <- list()
[13:21:51.788]                 for (kk in seq_along(NAMES)) {
[13:21:51.788]                   name <- changed[[kk]]
[13:21:51.788]                   NAME <- NAMES[[kk]]
[13:21:51.788]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:51.788]                     next
[13:21:51.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:51.788]                 }
[13:21:51.788]                 NAMES <- toupper(added)
[13:21:51.788]                 for (kk in seq_along(NAMES)) {
[13:21:51.788]                   name <- added[[kk]]
[13:21:51.788]                   NAME <- NAMES[[kk]]
[13:21:51.788]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:51.788]                     next
[13:21:51.788]                   args[[name]] <- ""
[13:21:51.788]                 }
[13:21:51.788]                 NAMES <- toupper(removed)
[13:21:51.788]                 for (kk in seq_along(NAMES)) {
[13:21:51.788]                   name <- removed[[kk]]
[13:21:51.788]                   NAME <- NAMES[[kk]]
[13:21:51.788]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:51.788]                     next
[13:21:51.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:51.788]                 }
[13:21:51.788]                 if (length(args) > 0) 
[13:21:51.788]                   base::do.call(base::Sys.setenv, args = args)
[13:21:51.788]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:51.788]             }
[13:21:51.788]             else {
[13:21:51.788]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:51.788]             }
[13:21:51.788]             {
[13:21:51.788]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:51.788]                   0L) {
[13:21:51.788]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:51.788]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:51.788]                   base::options(opts)
[13:21:51.788]                 }
[13:21:51.788]                 {
[13:21:51.788]                   {
[13:21:51.788]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:51.788]                     NULL
[13:21:51.788]                   }
[13:21:51.788]                   options(future.plan = NULL)
[13:21:51.788]                   if (is.na(NA_character_)) 
[13:21:51.788]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:51.788]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:51.788]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:51.788]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:51.788]                     envir = parent.frame()) 
[13:21:51.788]                   {
[13:21:51.788]                     if (is.function(workers)) 
[13:21:51.788]                       workers <- workers()
[13:21:51.788]                     workers <- structure(as.integer(workers), 
[13:21:51.788]                       class = class(workers))
[13:21:51.788]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:51.788]                       workers >= 1)
[13:21:51.788]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:51.788]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:51.788]                     }
[13:21:51.788]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:51.788]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:51.788]                       envir = envir)
[13:21:51.788]                     if (!future$lazy) 
[13:21:51.788]                       future <- run(future)
[13:21:51.788]                     invisible(future)
[13:21:51.788]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:51.788]                 }
[13:21:51.788]             }
[13:21:51.788]         }
[13:21:51.788]     })
[13:21:51.788]     if (TRUE) {
[13:21:51.788]         base::sink(type = "output", split = FALSE)
[13:21:51.788]         if (TRUE) {
[13:21:51.788]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:51.788]         }
[13:21:51.788]         else {
[13:21:51.788]             ...future.result["stdout"] <- base::list(NULL)
[13:21:51.788]         }
[13:21:51.788]         base::close(...future.stdout)
[13:21:51.788]         ...future.stdout <- NULL
[13:21:51.788]     }
[13:21:51.788]     ...future.result$conditions <- ...future.conditions
[13:21:51.788]     ...future.result$finished <- base::Sys.time()
[13:21:51.788]     ...future.result
[13:21:51.788] }
[13:21:51.791] MultisessionFuture started
[13:21:51.791] - Launch lazy future ... done
[13:21:51.791] run() for ‘MultisessionFuture’ ... done
[13:21:52.348] receiveMessageFromWorker() for ClusterFuture ...
[13:21:52.348] - Validating connection of MultisessionFuture
[13:21:52.348] - received message: FutureResult
[13:21:52.348] - Received FutureResult
[13:21:52.349] - Erased future from FutureRegistry
[13:21:52.349] result() for ClusterFuture ...
[13:21:52.349] - result already collected: FutureResult
[13:21:52.349] result() for ClusterFuture ... done
[13:21:52.349] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:52.349] A MultisessionFuture was resolved
- w/ exception ...
[13:21:52.349] getGlobalsAndPackages() ...
[13:21:52.349] Searching for globals...
[13:21:52.350] - globals found: [2] ‘list’, ‘stop’
[13:21:52.350] Searching for globals ... DONE
[13:21:52.350] Resolving globals: FALSE
[13:21:52.351] 
[13:21:52.351] 
[13:21:52.351] getGlobalsAndPackages() ... DONE
[13:21:52.351] run() for ‘Future’ ...
[13:21:52.351] - state: ‘created’
[13:21:52.351] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:52.366] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:52.366] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:52.366]   - Field: ‘node’
[13:21:52.366]   - Field: ‘label’
[13:21:52.366]   - Field: ‘local’
[13:21:52.366]   - Field: ‘owner’
[13:21:52.366]   - Field: ‘envir’
[13:21:52.366]   - Field: ‘workers’
[13:21:52.367]   - Field: ‘packages’
[13:21:52.367]   - Field: ‘gc’
[13:21:52.367]   - Field: ‘conditions’
[13:21:52.367]   - Field: ‘persistent’
[13:21:52.367]   - Field: ‘expr’
[13:21:52.367]   - Field: ‘uuid’
[13:21:52.367]   - Field: ‘seed’
[13:21:52.367]   - Field: ‘version’
[13:21:52.367]   - Field: ‘result’
[13:21:52.367]   - Field: ‘asynchronous’
[13:21:52.367]   - Field: ‘calls’
[13:21:52.368]   - Field: ‘globals’
[13:21:52.368]   - Field: ‘stdout’
[13:21:52.368]   - Field: ‘earlySignal’
[13:21:52.368]   - Field: ‘lazy’
[13:21:52.368]   - Field: ‘state’
[13:21:52.368] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:52.368] - Launch lazy future ...
[13:21:52.368] Packages needed by the future expression (n = 0): <none>
[13:21:52.368] Packages needed by future strategies (n = 0): <none>
[13:21:52.369] {
[13:21:52.369]     {
[13:21:52.369]         {
[13:21:52.369]             ...future.startTime <- base::Sys.time()
[13:21:52.369]             {
[13:21:52.369]                 {
[13:21:52.369]                   {
[13:21:52.369]                     {
[13:21:52.369]                       base::local({
[13:21:52.369]                         has_future <- base::requireNamespace("future", 
[13:21:52.369]                           quietly = TRUE)
[13:21:52.369]                         if (has_future) {
[13:21:52.369]                           ns <- base::getNamespace("future")
[13:21:52.369]                           version <- ns[[".package"]][["version"]]
[13:21:52.369]                           if (is.null(version)) 
[13:21:52.369]                             version <- utils::packageVersion("future")
[13:21:52.369]                         }
[13:21:52.369]                         else {
[13:21:52.369]                           version <- NULL
[13:21:52.369]                         }
[13:21:52.369]                         if (!has_future || version < "1.8.0") {
[13:21:52.369]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:52.369]                             "", base::R.version$version.string), 
[13:21:52.369]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:52.369]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:52.369]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:52.369]                               "release", "version")], collapse = " "), 
[13:21:52.369]                             hostname = base::Sys.info()[["nodename"]])
[13:21:52.369]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:52.369]                             info)
[13:21:52.369]                           info <- base::paste(info, collapse = "; ")
[13:21:52.369]                           if (!has_future) {
[13:21:52.369]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:52.369]                               info)
[13:21:52.369]                           }
[13:21:52.369]                           else {
[13:21:52.369]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:52.369]                               info, version)
[13:21:52.369]                           }
[13:21:52.369]                           base::stop(msg)
[13:21:52.369]                         }
[13:21:52.369]                       })
[13:21:52.369]                     }
[13:21:52.369]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:52.369]                     base::options(mc.cores = 1L)
[13:21:52.369]                   }
[13:21:52.369]                   options(future.plan = NULL)
[13:21:52.369]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:52.369]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:52.369]                 }
[13:21:52.369]                 ...future.workdir <- getwd()
[13:21:52.369]             }
[13:21:52.369]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:52.369]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:52.369]         }
[13:21:52.369]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:52.369]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:52.369]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:52.369]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:52.369]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:52.369]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:52.369]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:52.369]             base::names(...future.oldOptions))
[13:21:52.369]     }
[13:21:52.369]     if (FALSE) {
[13:21:52.369]     }
[13:21:52.369]     else {
[13:21:52.369]         if (TRUE) {
[13:21:52.369]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:52.369]                 open = "w")
[13:21:52.369]         }
[13:21:52.369]         else {
[13:21:52.369]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:52.369]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:52.369]         }
[13:21:52.369]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:52.369]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:52.369]             base::sink(type = "output", split = FALSE)
[13:21:52.369]             base::close(...future.stdout)
[13:21:52.369]         }, add = TRUE)
[13:21:52.369]     }
[13:21:52.369]     ...future.frame <- base::sys.nframe()
[13:21:52.369]     ...future.conditions <- base::list()
[13:21:52.369]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:52.369]     if (FALSE) {
[13:21:52.369]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:52.369]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:52.369]     }
[13:21:52.369]     ...future.result <- base::tryCatch({
[13:21:52.369]         base::withCallingHandlers({
[13:21:52.369]             ...future.value <- base::withVisible(base::local({
[13:21:52.369]                 ...future.makeSendCondition <- local({
[13:21:52.369]                   sendCondition <- NULL
[13:21:52.369]                   function(frame = 1L) {
[13:21:52.369]                     if (is.function(sendCondition)) 
[13:21:52.369]                       return(sendCondition)
[13:21:52.369]                     ns <- getNamespace("parallel")
[13:21:52.369]                     if (exists("sendData", mode = "function", 
[13:21:52.369]                       envir = ns)) {
[13:21:52.369]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:52.369]                         envir = ns)
[13:21:52.369]                       envir <- sys.frame(frame)
[13:21:52.369]                       master <- NULL
[13:21:52.369]                       while (!identical(envir, .GlobalEnv) && 
[13:21:52.369]                         !identical(envir, emptyenv())) {
[13:21:52.369]                         if (exists("master", mode = "list", envir = envir, 
[13:21:52.369]                           inherits = FALSE)) {
[13:21:52.369]                           master <- get("master", mode = "list", 
[13:21:52.369]                             envir = envir, inherits = FALSE)
[13:21:52.369]                           if (inherits(master, c("SOCKnode", 
[13:21:52.369]                             "SOCK0node"))) {
[13:21:52.369]                             sendCondition <<- function(cond) {
[13:21:52.369]                               data <- list(type = "VALUE", value = cond, 
[13:21:52.369]                                 success = TRUE)
[13:21:52.369]                               parallel_sendData(master, data)
[13:21:52.369]                             }
[13:21:52.369]                             return(sendCondition)
[13:21:52.369]                           }
[13:21:52.369]                         }
[13:21:52.369]                         frame <- frame + 1L
[13:21:52.369]                         envir <- sys.frame(frame)
[13:21:52.369]                       }
[13:21:52.369]                     }
[13:21:52.369]                     sendCondition <<- function(cond) NULL
[13:21:52.369]                   }
[13:21:52.369]                 })
[13:21:52.369]                 withCallingHandlers({
[13:21:52.369]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:21:52.369]                 }, immediateCondition = function(cond) {
[13:21:52.369]                   sendCondition <- ...future.makeSendCondition()
[13:21:52.369]                   sendCondition(cond)
[13:21:52.369]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:52.369]                   {
[13:21:52.369]                     inherits <- base::inherits
[13:21:52.369]                     invokeRestart <- base::invokeRestart
[13:21:52.369]                     is.null <- base::is.null
[13:21:52.369]                     muffled <- FALSE
[13:21:52.369]                     if (inherits(cond, "message")) {
[13:21:52.369]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:52.369]                       if (muffled) 
[13:21:52.369]                         invokeRestart("muffleMessage")
[13:21:52.369]                     }
[13:21:52.369]                     else if (inherits(cond, "warning")) {
[13:21:52.369]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:52.369]                       if (muffled) 
[13:21:52.369]                         invokeRestart("muffleWarning")
[13:21:52.369]                     }
[13:21:52.369]                     else if (inherits(cond, "condition")) {
[13:21:52.369]                       if (!is.null(pattern)) {
[13:21:52.369]                         computeRestarts <- base::computeRestarts
[13:21:52.369]                         grepl <- base::grepl
[13:21:52.369]                         restarts <- computeRestarts(cond)
[13:21:52.369]                         for (restart in restarts) {
[13:21:52.369]                           name <- restart$name
[13:21:52.369]                           if (is.null(name)) 
[13:21:52.369]                             next
[13:21:52.369]                           if (!grepl(pattern, name)) 
[13:21:52.369]                             next
[13:21:52.369]                           invokeRestart(restart)
[13:21:52.369]                           muffled <- TRUE
[13:21:52.369]                           break
[13:21:52.369]                         }
[13:21:52.369]                       }
[13:21:52.369]                     }
[13:21:52.369]                     invisible(muffled)
[13:21:52.369]                   }
[13:21:52.369]                   muffleCondition(cond)
[13:21:52.369]                 })
[13:21:52.369]             }))
[13:21:52.369]             future::FutureResult(value = ...future.value$value, 
[13:21:52.369]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:52.369]                   ...future.rng), globalenv = if (FALSE) 
[13:21:52.369]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:52.369]                     ...future.globalenv.names))
[13:21:52.369]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:52.369]         }, condition = base::local({
[13:21:52.369]             c <- base::c
[13:21:52.369]             inherits <- base::inherits
[13:21:52.369]             invokeRestart <- base::invokeRestart
[13:21:52.369]             length <- base::length
[13:21:52.369]             list <- base::list
[13:21:52.369]             seq.int <- base::seq.int
[13:21:52.369]             signalCondition <- base::signalCondition
[13:21:52.369]             sys.calls <- base::sys.calls
[13:21:52.369]             `[[` <- base::`[[`
[13:21:52.369]             `+` <- base::`+`
[13:21:52.369]             `<<-` <- base::`<<-`
[13:21:52.369]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:52.369]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:52.369]                   3L)]
[13:21:52.369]             }
[13:21:52.369]             function(cond) {
[13:21:52.369]                 is_error <- inherits(cond, "error")
[13:21:52.369]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:52.369]                   NULL)
[13:21:52.369]                 if (is_error) {
[13:21:52.369]                   sessionInformation <- function() {
[13:21:52.369]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:52.369]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:52.369]                       search = base::search(), system = base::Sys.info())
[13:21:52.369]                   }
[13:21:52.369]                   ...future.conditions[[length(...future.conditions) + 
[13:21:52.369]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:52.369]                     cond$call), session = sessionInformation(), 
[13:21:52.369]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:52.369]                   signalCondition(cond)
[13:21:52.369]                 }
[13:21:52.369]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:52.369]                 "immediateCondition"))) {
[13:21:52.369]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:52.369]                   ...future.conditions[[length(...future.conditions) + 
[13:21:52.369]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:52.369]                   if (TRUE && !signal) {
[13:21:52.369]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:52.369]                     {
[13:21:52.369]                       inherits <- base::inherits
[13:21:52.369]                       invokeRestart <- base::invokeRestart
[13:21:52.369]                       is.null <- base::is.null
[13:21:52.369]                       muffled <- FALSE
[13:21:52.369]                       if (inherits(cond, "message")) {
[13:21:52.369]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:52.369]                         if (muffled) 
[13:21:52.369]                           invokeRestart("muffleMessage")
[13:21:52.369]                       }
[13:21:52.369]                       else if (inherits(cond, "warning")) {
[13:21:52.369]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:52.369]                         if (muffled) 
[13:21:52.369]                           invokeRestart("muffleWarning")
[13:21:52.369]                       }
[13:21:52.369]                       else if (inherits(cond, "condition")) {
[13:21:52.369]                         if (!is.null(pattern)) {
[13:21:52.369]                           computeRestarts <- base::computeRestarts
[13:21:52.369]                           grepl <- base::grepl
[13:21:52.369]                           restarts <- computeRestarts(cond)
[13:21:52.369]                           for (restart in restarts) {
[13:21:52.369]                             name <- restart$name
[13:21:52.369]                             if (is.null(name)) 
[13:21:52.369]                               next
[13:21:52.369]                             if (!grepl(pattern, name)) 
[13:21:52.369]                               next
[13:21:52.369]                             invokeRestart(restart)
[13:21:52.369]                             muffled <- TRUE
[13:21:52.369]                             break
[13:21:52.369]                           }
[13:21:52.369]                         }
[13:21:52.369]                       }
[13:21:52.369]                       invisible(muffled)
[13:21:52.369]                     }
[13:21:52.369]                     muffleCondition(cond, pattern = "^muffle")
[13:21:52.369]                   }
[13:21:52.369]                 }
[13:21:52.369]                 else {
[13:21:52.369]                   if (TRUE) {
[13:21:52.369]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:52.369]                     {
[13:21:52.369]                       inherits <- base::inherits
[13:21:52.369]                       invokeRestart <- base::invokeRestart
[13:21:52.369]                       is.null <- base::is.null
[13:21:52.369]                       muffled <- FALSE
[13:21:52.369]                       if (inherits(cond, "message")) {
[13:21:52.369]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:52.369]                         if (muffled) 
[13:21:52.369]                           invokeRestart("muffleMessage")
[13:21:52.369]                       }
[13:21:52.369]                       else if (inherits(cond, "warning")) {
[13:21:52.369]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:52.369]                         if (muffled) 
[13:21:52.369]                           invokeRestart("muffleWarning")
[13:21:52.369]                       }
[13:21:52.369]                       else if (inherits(cond, "condition")) {
[13:21:52.369]                         if (!is.null(pattern)) {
[13:21:52.369]                           computeRestarts <- base::computeRestarts
[13:21:52.369]                           grepl <- base::grepl
[13:21:52.369]                           restarts <- computeRestarts(cond)
[13:21:52.369]                           for (restart in restarts) {
[13:21:52.369]                             name <- restart$name
[13:21:52.369]                             if (is.null(name)) 
[13:21:52.369]                               next
[13:21:52.369]                             if (!grepl(pattern, name)) 
[13:21:52.369]                               next
[13:21:52.369]                             invokeRestart(restart)
[13:21:52.369]                             muffled <- TRUE
[13:21:52.369]                             break
[13:21:52.369]                           }
[13:21:52.369]                         }
[13:21:52.369]                       }
[13:21:52.369]                       invisible(muffled)
[13:21:52.369]                     }
[13:21:52.369]                     muffleCondition(cond, pattern = "^muffle")
[13:21:52.369]                   }
[13:21:52.369]                 }
[13:21:52.369]             }
[13:21:52.369]         }))
[13:21:52.369]     }, error = function(ex) {
[13:21:52.369]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:52.369]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:52.369]                 ...future.rng), started = ...future.startTime, 
[13:21:52.369]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:52.369]             version = "1.8"), class = "FutureResult")
[13:21:52.369]     }, finally = {
[13:21:52.369]         if (!identical(...future.workdir, getwd())) 
[13:21:52.369]             setwd(...future.workdir)
[13:21:52.369]         {
[13:21:52.369]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:52.369]                 ...future.oldOptions$nwarnings <- NULL
[13:21:52.369]             }
[13:21:52.369]             base::options(...future.oldOptions)
[13:21:52.369]             if (.Platform$OS.type == "windows") {
[13:21:52.369]                 old_names <- names(...future.oldEnvVars)
[13:21:52.369]                 envs <- base::Sys.getenv()
[13:21:52.369]                 names <- names(envs)
[13:21:52.369]                 common <- intersect(names, old_names)
[13:21:52.369]                 added <- setdiff(names, old_names)
[13:21:52.369]                 removed <- setdiff(old_names, names)
[13:21:52.369]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:52.369]                   envs[common]]
[13:21:52.369]                 NAMES <- toupper(changed)
[13:21:52.369]                 args <- list()
[13:21:52.369]                 for (kk in seq_along(NAMES)) {
[13:21:52.369]                   name <- changed[[kk]]
[13:21:52.369]                   NAME <- NAMES[[kk]]
[13:21:52.369]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:52.369]                     next
[13:21:52.369]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:52.369]                 }
[13:21:52.369]                 NAMES <- toupper(added)
[13:21:52.369]                 for (kk in seq_along(NAMES)) {
[13:21:52.369]                   name <- added[[kk]]
[13:21:52.369]                   NAME <- NAMES[[kk]]
[13:21:52.369]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:52.369]                     next
[13:21:52.369]                   args[[name]] <- ""
[13:21:52.369]                 }
[13:21:52.369]                 NAMES <- toupper(removed)
[13:21:52.369]                 for (kk in seq_along(NAMES)) {
[13:21:52.369]                   name <- removed[[kk]]
[13:21:52.369]                   NAME <- NAMES[[kk]]
[13:21:52.369]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:52.369]                     next
[13:21:52.369]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:52.369]                 }
[13:21:52.369]                 if (length(args) > 0) 
[13:21:52.369]                   base::do.call(base::Sys.setenv, args = args)
[13:21:52.369]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:52.369]             }
[13:21:52.369]             else {
[13:21:52.369]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:52.369]             }
[13:21:52.369]             {
[13:21:52.369]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:52.369]                   0L) {
[13:21:52.369]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:52.369]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:52.369]                   base::options(opts)
[13:21:52.369]                 }
[13:21:52.369]                 {
[13:21:52.369]                   {
[13:21:52.369]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:52.369]                     NULL
[13:21:52.369]                   }
[13:21:52.369]                   options(future.plan = NULL)
[13:21:52.369]                   if (is.na(NA_character_)) 
[13:21:52.369]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:52.369]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:52.369]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:52.369]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:52.369]                     envir = parent.frame()) 
[13:21:52.369]                   {
[13:21:52.369]                     if (is.function(workers)) 
[13:21:52.369]                       workers <- workers()
[13:21:52.369]                     workers <- structure(as.integer(workers), 
[13:21:52.369]                       class = class(workers))
[13:21:52.369]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:52.369]                       workers >= 1)
[13:21:52.369]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:52.369]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:52.369]                     }
[13:21:52.369]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:52.369]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:52.369]                       envir = envir)
[13:21:52.369]                     if (!future$lazy) 
[13:21:52.369]                       future <- run(future)
[13:21:52.369]                     invisible(future)
[13:21:52.369]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:52.369]                 }
[13:21:52.369]             }
[13:21:52.369]         }
[13:21:52.369]     })
[13:21:52.369]     if (TRUE) {
[13:21:52.369]         base::sink(type = "output", split = FALSE)
[13:21:52.369]         if (TRUE) {
[13:21:52.369]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:52.369]         }
[13:21:52.369]         else {
[13:21:52.369]             ...future.result["stdout"] <- base::list(NULL)
[13:21:52.369]         }
[13:21:52.369]         base::close(...future.stdout)
[13:21:52.369]         ...future.stdout <- NULL
[13:21:52.369]     }
[13:21:52.369]     ...future.result$conditions <- ...future.conditions
[13:21:52.369]     ...future.result$finished <- base::Sys.time()
[13:21:52.369]     ...future.result
[13:21:52.369] }
[13:21:52.372] MultisessionFuture started
[13:21:52.372] - Launch lazy future ... done
[13:21:52.372] run() for ‘MultisessionFuture’ ... done
[13:21:52.418] receiveMessageFromWorker() for ClusterFuture ...
[13:21:52.418] - Validating connection of MultisessionFuture
[13:21:52.418] - received message: FutureResult
[13:21:52.418] - Received FutureResult
[13:21:52.418] - Erased future from FutureRegistry
[13:21:52.419] result() for ClusterFuture ...
[13:21:52.419] - result already collected: FutureResult
[13:21:52.419] result() for ClusterFuture ... done
[13:21:52.419] signalConditions() ...
[13:21:52.419]  - include = ‘immediateCondition’
[13:21:52.419]  - exclude = 
[13:21:52.419]  - resignal = FALSE
[13:21:52.419]  - Number of conditions: 1
[13:21:52.419] signalConditions() ... done
[13:21:52.419] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:52.420] A MultisessionFuture was resolved
[13:21:52.420] getGlobalsAndPackages() ...
[13:21:52.420] Searching for globals...
[13:21:52.420] - globals found: [2] ‘list’, ‘stop’
[13:21:52.421] Searching for globals ... DONE
[13:21:52.421] Resolving globals: FALSE
[13:21:52.421] 
[13:21:52.421] 
[13:21:52.421] getGlobalsAndPackages() ... DONE
[13:21:52.421] run() for ‘Future’ ...
[13:21:52.422] - state: ‘created’
[13:21:52.422] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:52.436] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:52.437] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:52.437]   - Field: ‘node’
[13:21:52.437]   - Field: ‘label’
[13:21:52.437]   - Field: ‘local’
[13:21:52.437]   - Field: ‘owner’
[13:21:52.438]   - Field: ‘envir’
[13:21:52.438]   - Field: ‘workers’
[13:21:52.438]   - Field: ‘packages’
[13:21:52.438]   - Field: ‘gc’
[13:21:52.438]   - Field: ‘conditions’
[13:21:52.438]   - Field: ‘persistent’
[13:21:52.439]   - Field: ‘expr’
[13:21:52.439]   - Field: ‘uuid’
[13:21:52.439]   - Field: ‘seed’
[13:21:52.439]   - Field: ‘version’
[13:21:52.439]   - Field: ‘result’
[13:21:52.439]   - Field: ‘asynchronous’
[13:21:52.440]   - Field: ‘calls’
[13:21:52.440]   - Field: ‘globals’
[13:21:52.440]   - Field: ‘stdout’
[13:21:52.440]   - Field: ‘earlySignal’
[13:21:52.440]   - Field: ‘lazy’
[13:21:52.440]   - Field: ‘state’
[13:21:52.440] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:52.440] - Launch lazy future ...
[13:21:52.441] Packages needed by the future expression (n = 0): <none>
[13:21:52.441] Packages needed by future strategies (n = 0): <none>
[13:21:52.442] {
[13:21:52.442]     {
[13:21:52.442]         {
[13:21:52.442]             ...future.startTime <- base::Sys.time()
[13:21:52.442]             {
[13:21:52.442]                 {
[13:21:52.442]                   {
[13:21:52.442]                     {
[13:21:52.442]                       base::local({
[13:21:52.442]                         has_future <- base::requireNamespace("future", 
[13:21:52.442]                           quietly = TRUE)
[13:21:52.442]                         if (has_future) {
[13:21:52.442]                           ns <- base::getNamespace("future")
[13:21:52.442]                           version <- ns[[".package"]][["version"]]
[13:21:52.442]                           if (is.null(version)) 
[13:21:52.442]                             version <- utils::packageVersion("future")
[13:21:52.442]                         }
[13:21:52.442]                         else {
[13:21:52.442]                           version <- NULL
[13:21:52.442]                         }
[13:21:52.442]                         if (!has_future || version < "1.8.0") {
[13:21:52.442]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:52.442]                             "", base::R.version$version.string), 
[13:21:52.442]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:52.442]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:52.442]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:52.442]                               "release", "version")], collapse = " "), 
[13:21:52.442]                             hostname = base::Sys.info()[["nodename"]])
[13:21:52.442]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:52.442]                             info)
[13:21:52.442]                           info <- base::paste(info, collapse = "; ")
[13:21:52.442]                           if (!has_future) {
[13:21:52.442]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:52.442]                               info)
[13:21:52.442]                           }
[13:21:52.442]                           else {
[13:21:52.442]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:52.442]                               info, version)
[13:21:52.442]                           }
[13:21:52.442]                           base::stop(msg)
[13:21:52.442]                         }
[13:21:52.442]                       })
[13:21:52.442]                     }
[13:21:52.442]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:52.442]                     base::options(mc.cores = 1L)
[13:21:52.442]                   }
[13:21:52.442]                   options(future.plan = NULL)
[13:21:52.442]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:52.442]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:52.442]                 }
[13:21:52.442]                 ...future.workdir <- getwd()
[13:21:52.442]             }
[13:21:52.442]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:52.442]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:52.442]         }
[13:21:52.442]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:52.442]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:52.442]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:52.442]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:52.442]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:52.442]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:52.442]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:52.442]             base::names(...future.oldOptions))
[13:21:52.442]     }
[13:21:52.442]     if (FALSE) {
[13:21:52.442]     }
[13:21:52.442]     else {
[13:21:52.442]         if (TRUE) {
[13:21:52.442]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:52.442]                 open = "w")
[13:21:52.442]         }
[13:21:52.442]         else {
[13:21:52.442]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:52.442]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:52.442]         }
[13:21:52.442]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:52.442]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:52.442]             base::sink(type = "output", split = FALSE)
[13:21:52.442]             base::close(...future.stdout)
[13:21:52.442]         }, add = TRUE)
[13:21:52.442]     }
[13:21:52.442]     ...future.frame <- base::sys.nframe()
[13:21:52.442]     ...future.conditions <- base::list()
[13:21:52.442]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:52.442]     if (FALSE) {
[13:21:52.442]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:52.442]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:52.442]     }
[13:21:52.442]     ...future.result <- base::tryCatch({
[13:21:52.442]         base::withCallingHandlers({
[13:21:52.442]             ...future.value <- base::withVisible(base::local({
[13:21:52.442]                 ...future.makeSendCondition <- local({
[13:21:52.442]                   sendCondition <- NULL
[13:21:52.442]                   function(frame = 1L) {
[13:21:52.442]                     if (is.function(sendCondition)) 
[13:21:52.442]                       return(sendCondition)
[13:21:52.442]                     ns <- getNamespace("parallel")
[13:21:52.442]                     if (exists("sendData", mode = "function", 
[13:21:52.442]                       envir = ns)) {
[13:21:52.442]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:52.442]                         envir = ns)
[13:21:52.442]                       envir <- sys.frame(frame)
[13:21:52.442]                       master <- NULL
[13:21:52.442]                       while (!identical(envir, .GlobalEnv) && 
[13:21:52.442]                         !identical(envir, emptyenv())) {
[13:21:52.442]                         if (exists("master", mode = "list", envir = envir, 
[13:21:52.442]                           inherits = FALSE)) {
[13:21:52.442]                           master <- get("master", mode = "list", 
[13:21:52.442]                             envir = envir, inherits = FALSE)
[13:21:52.442]                           if (inherits(master, c("SOCKnode", 
[13:21:52.442]                             "SOCK0node"))) {
[13:21:52.442]                             sendCondition <<- function(cond) {
[13:21:52.442]                               data <- list(type = "VALUE", value = cond, 
[13:21:52.442]                                 success = TRUE)
[13:21:52.442]                               parallel_sendData(master, data)
[13:21:52.442]                             }
[13:21:52.442]                             return(sendCondition)
[13:21:52.442]                           }
[13:21:52.442]                         }
[13:21:52.442]                         frame <- frame + 1L
[13:21:52.442]                         envir <- sys.frame(frame)
[13:21:52.442]                       }
[13:21:52.442]                     }
[13:21:52.442]                     sendCondition <<- function(cond) NULL
[13:21:52.442]                   }
[13:21:52.442]                 })
[13:21:52.442]                 withCallingHandlers({
[13:21:52.442]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:21:52.442]                 }, immediateCondition = function(cond) {
[13:21:52.442]                   sendCondition <- ...future.makeSendCondition()
[13:21:52.442]                   sendCondition(cond)
[13:21:52.442]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:52.442]                   {
[13:21:52.442]                     inherits <- base::inherits
[13:21:52.442]                     invokeRestart <- base::invokeRestart
[13:21:52.442]                     is.null <- base::is.null
[13:21:52.442]                     muffled <- FALSE
[13:21:52.442]                     if (inherits(cond, "message")) {
[13:21:52.442]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:52.442]                       if (muffled) 
[13:21:52.442]                         invokeRestart("muffleMessage")
[13:21:52.442]                     }
[13:21:52.442]                     else if (inherits(cond, "warning")) {
[13:21:52.442]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:52.442]                       if (muffled) 
[13:21:52.442]                         invokeRestart("muffleWarning")
[13:21:52.442]                     }
[13:21:52.442]                     else if (inherits(cond, "condition")) {
[13:21:52.442]                       if (!is.null(pattern)) {
[13:21:52.442]                         computeRestarts <- base::computeRestarts
[13:21:52.442]                         grepl <- base::grepl
[13:21:52.442]                         restarts <- computeRestarts(cond)
[13:21:52.442]                         for (restart in restarts) {
[13:21:52.442]                           name <- restart$name
[13:21:52.442]                           if (is.null(name)) 
[13:21:52.442]                             next
[13:21:52.442]                           if (!grepl(pattern, name)) 
[13:21:52.442]                             next
[13:21:52.442]                           invokeRestart(restart)
[13:21:52.442]                           muffled <- TRUE
[13:21:52.442]                           break
[13:21:52.442]                         }
[13:21:52.442]                       }
[13:21:52.442]                     }
[13:21:52.442]                     invisible(muffled)
[13:21:52.442]                   }
[13:21:52.442]                   muffleCondition(cond)
[13:21:52.442]                 })
[13:21:52.442]             }))
[13:21:52.442]             future::FutureResult(value = ...future.value$value, 
[13:21:52.442]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:52.442]                   ...future.rng), globalenv = if (FALSE) 
[13:21:52.442]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:52.442]                     ...future.globalenv.names))
[13:21:52.442]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:52.442]         }, condition = base::local({
[13:21:52.442]             c <- base::c
[13:21:52.442]             inherits <- base::inherits
[13:21:52.442]             invokeRestart <- base::invokeRestart
[13:21:52.442]             length <- base::length
[13:21:52.442]             list <- base::list
[13:21:52.442]             seq.int <- base::seq.int
[13:21:52.442]             signalCondition <- base::signalCondition
[13:21:52.442]             sys.calls <- base::sys.calls
[13:21:52.442]             `[[` <- base::`[[`
[13:21:52.442]             `+` <- base::`+`
[13:21:52.442]             `<<-` <- base::`<<-`
[13:21:52.442]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:52.442]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:52.442]                   3L)]
[13:21:52.442]             }
[13:21:52.442]             function(cond) {
[13:21:52.442]                 is_error <- inherits(cond, "error")
[13:21:52.442]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:52.442]                   NULL)
[13:21:52.442]                 if (is_error) {
[13:21:52.442]                   sessionInformation <- function() {
[13:21:52.442]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:52.442]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:52.442]                       search = base::search(), system = base::Sys.info())
[13:21:52.442]                   }
[13:21:52.442]                   ...future.conditions[[length(...future.conditions) + 
[13:21:52.442]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:52.442]                     cond$call), session = sessionInformation(), 
[13:21:52.442]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:52.442]                   signalCondition(cond)
[13:21:52.442]                 }
[13:21:52.442]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:52.442]                 "immediateCondition"))) {
[13:21:52.442]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:52.442]                   ...future.conditions[[length(...future.conditions) + 
[13:21:52.442]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:52.442]                   if (TRUE && !signal) {
[13:21:52.442]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:52.442]                     {
[13:21:52.442]                       inherits <- base::inherits
[13:21:52.442]                       invokeRestart <- base::invokeRestart
[13:21:52.442]                       is.null <- base::is.null
[13:21:52.442]                       muffled <- FALSE
[13:21:52.442]                       if (inherits(cond, "message")) {
[13:21:52.442]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:52.442]                         if (muffled) 
[13:21:52.442]                           invokeRestart("muffleMessage")
[13:21:52.442]                       }
[13:21:52.442]                       else if (inherits(cond, "warning")) {
[13:21:52.442]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:52.442]                         if (muffled) 
[13:21:52.442]                           invokeRestart("muffleWarning")
[13:21:52.442]                       }
[13:21:52.442]                       else if (inherits(cond, "condition")) {
[13:21:52.442]                         if (!is.null(pattern)) {
[13:21:52.442]                           computeRestarts <- base::computeRestarts
[13:21:52.442]                           grepl <- base::grepl
[13:21:52.442]                           restarts <- computeRestarts(cond)
[13:21:52.442]                           for (restart in restarts) {
[13:21:52.442]                             name <- restart$name
[13:21:52.442]                             if (is.null(name)) 
[13:21:52.442]                               next
[13:21:52.442]                             if (!grepl(pattern, name)) 
[13:21:52.442]                               next
[13:21:52.442]                             invokeRestart(restart)
[13:21:52.442]                             muffled <- TRUE
[13:21:52.442]                             break
[13:21:52.442]                           }
[13:21:52.442]                         }
[13:21:52.442]                       }
[13:21:52.442]                       invisible(muffled)
[13:21:52.442]                     }
[13:21:52.442]                     muffleCondition(cond, pattern = "^muffle")
[13:21:52.442]                   }
[13:21:52.442]                 }
[13:21:52.442]                 else {
[13:21:52.442]                   if (TRUE) {
[13:21:52.442]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:52.442]                     {
[13:21:52.442]                       inherits <- base::inherits
[13:21:52.442]                       invokeRestart <- base::invokeRestart
[13:21:52.442]                       is.null <- base::is.null
[13:21:52.442]                       muffled <- FALSE
[13:21:52.442]                       if (inherits(cond, "message")) {
[13:21:52.442]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:52.442]                         if (muffled) 
[13:21:52.442]                           invokeRestart("muffleMessage")
[13:21:52.442]                       }
[13:21:52.442]                       else if (inherits(cond, "warning")) {
[13:21:52.442]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:52.442]                         if (muffled) 
[13:21:52.442]                           invokeRestart("muffleWarning")
[13:21:52.442]                       }
[13:21:52.442]                       else if (inherits(cond, "condition")) {
[13:21:52.442]                         if (!is.null(pattern)) {
[13:21:52.442]                           computeRestarts <- base::computeRestarts
[13:21:52.442]                           grepl <- base::grepl
[13:21:52.442]                           restarts <- computeRestarts(cond)
[13:21:52.442]                           for (restart in restarts) {
[13:21:52.442]                             name <- restart$name
[13:21:52.442]                             if (is.null(name)) 
[13:21:52.442]                               next
[13:21:52.442]                             if (!grepl(pattern, name)) 
[13:21:52.442]                               next
[13:21:52.442]                             invokeRestart(restart)
[13:21:52.442]                             muffled <- TRUE
[13:21:52.442]                             break
[13:21:52.442]                           }
[13:21:52.442]                         }
[13:21:52.442]                       }
[13:21:52.442]                       invisible(muffled)
[13:21:52.442]                     }
[13:21:52.442]                     muffleCondition(cond, pattern = "^muffle")
[13:21:52.442]                   }
[13:21:52.442]                 }
[13:21:52.442]             }
[13:21:52.442]         }))
[13:21:52.442]     }, error = function(ex) {
[13:21:52.442]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:52.442]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:52.442]                 ...future.rng), started = ...future.startTime, 
[13:21:52.442]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:52.442]             version = "1.8"), class = "FutureResult")
[13:21:52.442]     }, finally = {
[13:21:52.442]         if (!identical(...future.workdir, getwd())) 
[13:21:52.442]             setwd(...future.workdir)
[13:21:52.442]         {
[13:21:52.442]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:52.442]                 ...future.oldOptions$nwarnings <- NULL
[13:21:52.442]             }
[13:21:52.442]             base::options(...future.oldOptions)
[13:21:52.442]             if (.Platform$OS.type == "windows") {
[13:21:52.442]                 old_names <- names(...future.oldEnvVars)
[13:21:52.442]                 envs <- base::Sys.getenv()
[13:21:52.442]                 names <- names(envs)
[13:21:52.442]                 common <- intersect(names, old_names)
[13:21:52.442]                 added <- setdiff(names, old_names)
[13:21:52.442]                 removed <- setdiff(old_names, names)
[13:21:52.442]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:52.442]                   envs[common]]
[13:21:52.442]                 NAMES <- toupper(changed)
[13:21:52.442]                 args <- list()
[13:21:52.442]                 for (kk in seq_along(NAMES)) {
[13:21:52.442]                   name <- changed[[kk]]
[13:21:52.442]                   NAME <- NAMES[[kk]]
[13:21:52.442]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:52.442]                     next
[13:21:52.442]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:52.442]                 }
[13:21:52.442]                 NAMES <- toupper(added)
[13:21:52.442]                 for (kk in seq_along(NAMES)) {
[13:21:52.442]                   name <- added[[kk]]
[13:21:52.442]                   NAME <- NAMES[[kk]]
[13:21:52.442]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:52.442]                     next
[13:21:52.442]                   args[[name]] <- ""
[13:21:52.442]                 }
[13:21:52.442]                 NAMES <- toupper(removed)
[13:21:52.442]                 for (kk in seq_along(NAMES)) {
[13:21:52.442]                   name <- removed[[kk]]
[13:21:52.442]                   NAME <- NAMES[[kk]]
[13:21:52.442]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:52.442]                     next
[13:21:52.442]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:52.442]                 }
[13:21:52.442]                 if (length(args) > 0) 
[13:21:52.442]                   base::do.call(base::Sys.setenv, args = args)
[13:21:52.442]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:52.442]             }
[13:21:52.442]             else {
[13:21:52.442]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:52.442]             }
[13:21:52.442]             {
[13:21:52.442]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:52.442]                   0L) {
[13:21:52.442]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:52.442]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:52.442]                   base::options(opts)
[13:21:52.442]                 }
[13:21:52.442]                 {
[13:21:52.442]                   {
[13:21:52.442]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:52.442]                     NULL
[13:21:52.442]                   }
[13:21:52.442]                   options(future.plan = NULL)
[13:21:52.442]                   if (is.na(NA_character_)) 
[13:21:52.442]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:52.442]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:52.442]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:52.442]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:52.442]                     envir = parent.frame()) 
[13:21:52.442]                   {
[13:21:52.442]                     if (is.function(workers)) 
[13:21:52.442]                       workers <- workers()
[13:21:52.442]                     workers <- structure(as.integer(workers), 
[13:21:52.442]                       class = class(workers))
[13:21:52.442]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:52.442]                       workers >= 1)
[13:21:52.442]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:52.442]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:52.442]                     }
[13:21:52.442]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:52.442]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:52.442]                       envir = envir)
[13:21:52.442]                     if (!future$lazy) 
[13:21:52.442]                       future <- run(future)
[13:21:52.442]                     invisible(future)
[13:21:52.442]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:52.442]                 }
[13:21:52.442]             }
[13:21:52.442]         }
[13:21:52.442]     })
[13:21:52.442]     if (TRUE) {
[13:21:52.442]         base::sink(type = "output", split = FALSE)
[13:21:52.442]         if (TRUE) {
[13:21:52.442]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:52.442]         }
[13:21:52.442]         else {
[13:21:52.442]             ...future.result["stdout"] <- base::list(NULL)
[13:21:52.442]         }
[13:21:52.442]         base::close(...future.stdout)
[13:21:52.442]         ...future.stdout <- NULL
[13:21:52.442]     }
[13:21:52.442]     ...future.result$conditions <- ...future.conditions
[13:21:52.442]     ...future.result$finished <- base::Sys.time()
[13:21:52.442]     ...future.result
[13:21:52.442] }
[13:21:52.445] MultisessionFuture started
[13:21:52.445] - Launch lazy future ... done
[13:21:52.445] run() for ‘MultisessionFuture’ ... done
[13:21:52.494] receiveMessageFromWorker() for ClusterFuture ...
[13:21:52.494] - Validating connection of MultisessionFuture
[13:21:52.494] - received message: FutureResult
[13:21:52.494] - Received FutureResult
[13:21:52.495] - Erased future from FutureRegistry
[13:21:52.495] result() for ClusterFuture ...
[13:21:52.495] - result already collected: FutureResult
[13:21:52.495] result() for ClusterFuture ... done
[13:21:52.495] signalConditions() ...
[13:21:52.495]  - include = ‘immediateCondition’
[13:21:52.495]  - exclude = 
[13:21:52.495]  - resignal = FALSE
[13:21:52.495]  - Number of conditions: 1
[13:21:52.495] signalConditions() ... done
[13:21:52.496] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:52.496] A MultisessionFuture was resolved
- result = TRUE, recursive = FALSE ... DONE
- result = TRUE, recursive = TRUE ...
[13:21:52.496] getGlobalsAndPackages() ...
[13:21:52.496] Searching for globals...
[13:21:52.497] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:21:52.497] Searching for globals ... DONE
[13:21:52.497] Resolving globals: FALSE
[13:21:52.498] 
[13:21:52.498] 
[13:21:52.498] getGlobalsAndPackages() ... DONE
[13:21:52.498] run() for ‘Future’ ...
[13:21:52.498] - state: ‘created’
[13:21:52.498] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:52.512] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:52.513] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:52.513]   - Field: ‘node’
[13:21:52.513]   - Field: ‘label’
[13:21:52.513]   - Field: ‘local’
[13:21:52.513]   - Field: ‘owner’
[13:21:52.513]   - Field: ‘envir’
[13:21:52.513]   - Field: ‘workers’
[13:21:52.513]   - Field: ‘packages’
[13:21:52.513]   - Field: ‘gc’
[13:21:52.514]   - Field: ‘conditions’
[13:21:52.514]   - Field: ‘persistent’
[13:21:52.514]   - Field: ‘expr’
[13:21:52.514]   - Field: ‘uuid’
[13:21:52.514]   - Field: ‘seed’
[13:21:52.514]   - Field: ‘version’
[13:21:52.514]   - Field: ‘result’
[13:21:52.514]   - Field: ‘asynchronous’
[13:21:52.514]   - Field: ‘calls’
[13:21:52.514]   - Field: ‘globals’
[13:21:52.514]   - Field: ‘stdout’
[13:21:52.514]   - Field: ‘earlySignal’
[13:21:52.515]   - Field: ‘lazy’
[13:21:52.515]   - Field: ‘state’
[13:21:52.515] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:52.515] - Launch lazy future ...
[13:21:52.515] Packages needed by the future expression (n = 0): <none>
[13:21:52.515] Packages needed by future strategies (n = 0): <none>
[13:21:52.516] {
[13:21:52.516]     {
[13:21:52.516]         {
[13:21:52.516]             ...future.startTime <- base::Sys.time()
[13:21:52.516]             {
[13:21:52.516]                 {
[13:21:52.516]                   {
[13:21:52.516]                     {
[13:21:52.516]                       base::local({
[13:21:52.516]                         has_future <- base::requireNamespace("future", 
[13:21:52.516]                           quietly = TRUE)
[13:21:52.516]                         if (has_future) {
[13:21:52.516]                           ns <- base::getNamespace("future")
[13:21:52.516]                           version <- ns[[".package"]][["version"]]
[13:21:52.516]                           if (is.null(version)) 
[13:21:52.516]                             version <- utils::packageVersion("future")
[13:21:52.516]                         }
[13:21:52.516]                         else {
[13:21:52.516]                           version <- NULL
[13:21:52.516]                         }
[13:21:52.516]                         if (!has_future || version < "1.8.0") {
[13:21:52.516]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:52.516]                             "", base::R.version$version.string), 
[13:21:52.516]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:52.516]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:52.516]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:52.516]                               "release", "version")], collapse = " "), 
[13:21:52.516]                             hostname = base::Sys.info()[["nodename"]])
[13:21:52.516]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:52.516]                             info)
[13:21:52.516]                           info <- base::paste(info, collapse = "; ")
[13:21:52.516]                           if (!has_future) {
[13:21:52.516]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:52.516]                               info)
[13:21:52.516]                           }
[13:21:52.516]                           else {
[13:21:52.516]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:52.516]                               info, version)
[13:21:52.516]                           }
[13:21:52.516]                           base::stop(msg)
[13:21:52.516]                         }
[13:21:52.516]                       })
[13:21:52.516]                     }
[13:21:52.516]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:52.516]                     base::options(mc.cores = 1L)
[13:21:52.516]                   }
[13:21:52.516]                   options(future.plan = NULL)
[13:21:52.516]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:52.516]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:52.516]                 }
[13:21:52.516]                 ...future.workdir <- getwd()
[13:21:52.516]             }
[13:21:52.516]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:52.516]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:52.516]         }
[13:21:52.516]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:52.516]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:52.516]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:52.516]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:52.516]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:52.516]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:52.516]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:52.516]             base::names(...future.oldOptions))
[13:21:52.516]     }
[13:21:52.516]     if (FALSE) {
[13:21:52.516]     }
[13:21:52.516]     else {
[13:21:52.516]         if (TRUE) {
[13:21:52.516]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:52.516]                 open = "w")
[13:21:52.516]         }
[13:21:52.516]         else {
[13:21:52.516]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:52.516]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:52.516]         }
[13:21:52.516]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:52.516]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:52.516]             base::sink(type = "output", split = FALSE)
[13:21:52.516]             base::close(...future.stdout)
[13:21:52.516]         }, add = TRUE)
[13:21:52.516]     }
[13:21:52.516]     ...future.frame <- base::sys.nframe()
[13:21:52.516]     ...future.conditions <- base::list()
[13:21:52.516]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:52.516]     if (FALSE) {
[13:21:52.516]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:52.516]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:52.516]     }
[13:21:52.516]     ...future.result <- base::tryCatch({
[13:21:52.516]         base::withCallingHandlers({
[13:21:52.516]             ...future.value <- base::withVisible(base::local({
[13:21:52.516]                 ...future.makeSendCondition <- local({
[13:21:52.516]                   sendCondition <- NULL
[13:21:52.516]                   function(frame = 1L) {
[13:21:52.516]                     if (is.function(sendCondition)) 
[13:21:52.516]                       return(sendCondition)
[13:21:52.516]                     ns <- getNamespace("parallel")
[13:21:52.516]                     if (exists("sendData", mode = "function", 
[13:21:52.516]                       envir = ns)) {
[13:21:52.516]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:52.516]                         envir = ns)
[13:21:52.516]                       envir <- sys.frame(frame)
[13:21:52.516]                       master <- NULL
[13:21:52.516]                       while (!identical(envir, .GlobalEnv) && 
[13:21:52.516]                         !identical(envir, emptyenv())) {
[13:21:52.516]                         if (exists("master", mode = "list", envir = envir, 
[13:21:52.516]                           inherits = FALSE)) {
[13:21:52.516]                           master <- get("master", mode = "list", 
[13:21:52.516]                             envir = envir, inherits = FALSE)
[13:21:52.516]                           if (inherits(master, c("SOCKnode", 
[13:21:52.516]                             "SOCK0node"))) {
[13:21:52.516]                             sendCondition <<- function(cond) {
[13:21:52.516]                               data <- list(type = "VALUE", value = cond, 
[13:21:52.516]                                 success = TRUE)
[13:21:52.516]                               parallel_sendData(master, data)
[13:21:52.516]                             }
[13:21:52.516]                             return(sendCondition)
[13:21:52.516]                           }
[13:21:52.516]                         }
[13:21:52.516]                         frame <- frame + 1L
[13:21:52.516]                         envir <- sys.frame(frame)
[13:21:52.516]                       }
[13:21:52.516]                     }
[13:21:52.516]                     sendCondition <<- function(cond) NULL
[13:21:52.516]                   }
[13:21:52.516]                 })
[13:21:52.516]                 withCallingHandlers({
[13:21:52.516]                   {
[13:21:52.516]                     Sys.sleep(0.5)
[13:21:52.516]                     list(a = 1, b = 42L)
[13:21:52.516]                   }
[13:21:52.516]                 }, immediateCondition = function(cond) {
[13:21:52.516]                   sendCondition <- ...future.makeSendCondition()
[13:21:52.516]                   sendCondition(cond)
[13:21:52.516]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:52.516]                   {
[13:21:52.516]                     inherits <- base::inherits
[13:21:52.516]                     invokeRestart <- base::invokeRestart
[13:21:52.516]                     is.null <- base::is.null
[13:21:52.516]                     muffled <- FALSE
[13:21:52.516]                     if (inherits(cond, "message")) {
[13:21:52.516]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:52.516]                       if (muffled) 
[13:21:52.516]                         invokeRestart("muffleMessage")
[13:21:52.516]                     }
[13:21:52.516]                     else if (inherits(cond, "warning")) {
[13:21:52.516]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:52.516]                       if (muffled) 
[13:21:52.516]                         invokeRestart("muffleWarning")
[13:21:52.516]                     }
[13:21:52.516]                     else if (inherits(cond, "condition")) {
[13:21:52.516]                       if (!is.null(pattern)) {
[13:21:52.516]                         computeRestarts <- base::computeRestarts
[13:21:52.516]                         grepl <- base::grepl
[13:21:52.516]                         restarts <- computeRestarts(cond)
[13:21:52.516]                         for (restart in restarts) {
[13:21:52.516]                           name <- restart$name
[13:21:52.516]                           if (is.null(name)) 
[13:21:52.516]                             next
[13:21:52.516]                           if (!grepl(pattern, name)) 
[13:21:52.516]                             next
[13:21:52.516]                           invokeRestart(restart)
[13:21:52.516]                           muffled <- TRUE
[13:21:52.516]                           break
[13:21:52.516]                         }
[13:21:52.516]                       }
[13:21:52.516]                     }
[13:21:52.516]                     invisible(muffled)
[13:21:52.516]                   }
[13:21:52.516]                   muffleCondition(cond)
[13:21:52.516]                 })
[13:21:52.516]             }))
[13:21:52.516]             future::FutureResult(value = ...future.value$value, 
[13:21:52.516]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:52.516]                   ...future.rng), globalenv = if (FALSE) 
[13:21:52.516]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:52.516]                     ...future.globalenv.names))
[13:21:52.516]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:52.516]         }, condition = base::local({
[13:21:52.516]             c <- base::c
[13:21:52.516]             inherits <- base::inherits
[13:21:52.516]             invokeRestart <- base::invokeRestart
[13:21:52.516]             length <- base::length
[13:21:52.516]             list <- base::list
[13:21:52.516]             seq.int <- base::seq.int
[13:21:52.516]             signalCondition <- base::signalCondition
[13:21:52.516]             sys.calls <- base::sys.calls
[13:21:52.516]             `[[` <- base::`[[`
[13:21:52.516]             `+` <- base::`+`
[13:21:52.516]             `<<-` <- base::`<<-`
[13:21:52.516]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:52.516]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:52.516]                   3L)]
[13:21:52.516]             }
[13:21:52.516]             function(cond) {
[13:21:52.516]                 is_error <- inherits(cond, "error")
[13:21:52.516]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:52.516]                   NULL)
[13:21:52.516]                 if (is_error) {
[13:21:52.516]                   sessionInformation <- function() {
[13:21:52.516]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:52.516]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:52.516]                       search = base::search(), system = base::Sys.info())
[13:21:52.516]                   }
[13:21:52.516]                   ...future.conditions[[length(...future.conditions) + 
[13:21:52.516]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:52.516]                     cond$call), session = sessionInformation(), 
[13:21:52.516]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:52.516]                   signalCondition(cond)
[13:21:52.516]                 }
[13:21:52.516]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:52.516]                 "immediateCondition"))) {
[13:21:52.516]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:52.516]                   ...future.conditions[[length(...future.conditions) + 
[13:21:52.516]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:52.516]                   if (TRUE && !signal) {
[13:21:52.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:52.516]                     {
[13:21:52.516]                       inherits <- base::inherits
[13:21:52.516]                       invokeRestart <- base::invokeRestart
[13:21:52.516]                       is.null <- base::is.null
[13:21:52.516]                       muffled <- FALSE
[13:21:52.516]                       if (inherits(cond, "message")) {
[13:21:52.516]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:52.516]                         if (muffled) 
[13:21:52.516]                           invokeRestart("muffleMessage")
[13:21:52.516]                       }
[13:21:52.516]                       else if (inherits(cond, "warning")) {
[13:21:52.516]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:52.516]                         if (muffled) 
[13:21:52.516]                           invokeRestart("muffleWarning")
[13:21:52.516]                       }
[13:21:52.516]                       else if (inherits(cond, "condition")) {
[13:21:52.516]                         if (!is.null(pattern)) {
[13:21:52.516]                           computeRestarts <- base::computeRestarts
[13:21:52.516]                           grepl <- base::grepl
[13:21:52.516]                           restarts <- computeRestarts(cond)
[13:21:52.516]                           for (restart in restarts) {
[13:21:52.516]                             name <- restart$name
[13:21:52.516]                             if (is.null(name)) 
[13:21:52.516]                               next
[13:21:52.516]                             if (!grepl(pattern, name)) 
[13:21:52.516]                               next
[13:21:52.516]                             invokeRestart(restart)
[13:21:52.516]                             muffled <- TRUE
[13:21:52.516]                             break
[13:21:52.516]                           }
[13:21:52.516]                         }
[13:21:52.516]                       }
[13:21:52.516]                       invisible(muffled)
[13:21:52.516]                     }
[13:21:52.516]                     muffleCondition(cond, pattern = "^muffle")
[13:21:52.516]                   }
[13:21:52.516]                 }
[13:21:52.516]                 else {
[13:21:52.516]                   if (TRUE) {
[13:21:52.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:52.516]                     {
[13:21:52.516]                       inherits <- base::inherits
[13:21:52.516]                       invokeRestart <- base::invokeRestart
[13:21:52.516]                       is.null <- base::is.null
[13:21:52.516]                       muffled <- FALSE
[13:21:52.516]                       if (inherits(cond, "message")) {
[13:21:52.516]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:52.516]                         if (muffled) 
[13:21:52.516]                           invokeRestart("muffleMessage")
[13:21:52.516]                       }
[13:21:52.516]                       else if (inherits(cond, "warning")) {
[13:21:52.516]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:52.516]                         if (muffled) 
[13:21:52.516]                           invokeRestart("muffleWarning")
[13:21:52.516]                       }
[13:21:52.516]                       else if (inherits(cond, "condition")) {
[13:21:52.516]                         if (!is.null(pattern)) {
[13:21:52.516]                           computeRestarts <- base::computeRestarts
[13:21:52.516]                           grepl <- base::grepl
[13:21:52.516]                           restarts <- computeRestarts(cond)
[13:21:52.516]                           for (restart in restarts) {
[13:21:52.516]                             name <- restart$name
[13:21:52.516]                             if (is.null(name)) 
[13:21:52.516]                               next
[13:21:52.516]                             if (!grepl(pattern, name)) 
[13:21:52.516]                               next
[13:21:52.516]                             invokeRestart(restart)
[13:21:52.516]                             muffled <- TRUE
[13:21:52.516]                             break
[13:21:52.516]                           }
[13:21:52.516]                         }
[13:21:52.516]                       }
[13:21:52.516]                       invisible(muffled)
[13:21:52.516]                     }
[13:21:52.516]                     muffleCondition(cond, pattern = "^muffle")
[13:21:52.516]                   }
[13:21:52.516]                 }
[13:21:52.516]             }
[13:21:52.516]         }))
[13:21:52.516]     }, error = function(ex) {
[13:21:52.516]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:52.516]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:52.516]                 ...future.rng), started = ...future.startTime, 
[13:21:52.516]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:52.516]             version = "1.8"), class = "FutureResult")
[13:21:52.516]     }, finally = {
[13:21:52.516]         if (!identical(...future.workdir, getwd())) 
[13:21:52.516]             setwd(...future.workdir)
[13:21:52.516]         {
[13:21:52.516]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:52.516]                 ...future.oldOptions$nwarnings <- NULL
[13:21:52.516]             }
[13:21:52.516]             base::options(...future.oldOptions)
[13:21:52.516]             if (.Platform$OS.type == "windows") {
[13:21:52.516]                 old_names <- names(...future.oldEnvVars)
[13:21:52.516]                 envs <- base::Sys.getenv()
[13:21:52.516]                 names <- names(envs)
[13:21:52.516]                 common <- intersect(names, old_names)
[13:21:52.516]                 added <- setdiff(names, old_names)
[13:21:52.516]                 removed <- setdiff(old_names, names)
[13:21:52.516]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:52.516]                   envs[common]]
[13:21:52.516]                 NAMES <- toupper(changed)
[13:21:52.516]                 args <- list()
[13:21:52.516]                 for (kk in seq_along(NAMES)) {
[13:21:52.516]                   name <- changed[[kk]]
[13:21:52.516]                   NAME <- NAMES[[kk]]
[13:21:52.516]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:52.516]                     next
[13:21:52.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:52.516]                 }
[13:21:52.516]                 NAMES <- toupper(added)
[13:21:52.516]                 for (kk in seq_along(NAMES)) {
[13:21:52.516]                   name <- added[[kk]]
[13:21:52.516]                   NAME <- NAMES[[kk]]
[13:21:52.516]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:52.516]                     next
[13:21:52.516]                   args[[name]] <- ""
[13:21:52.516]                 }
[13:21:52.516]                 NAMES <- toupper(removed)
[13:21:52.516]                 for (kk in seq_along(NAMES)) {
[13:21:52.516]                   name <- removed[[kk]]
[13:21:52.516]                   NAME <- NAMES[[kk]]
[13:21:52.516]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:52.516]                     next
[13:21:52.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:52.516]                 }
[13:21:52.516]                 if (length(args) > 0) 
[13:21:52.516]                   base::do.call(base::Sys.setenv, args = args)
[13:21:52.516]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:52.516]             }
[13:21:52.516]             else {
[13:21:52.516]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:52.516]             }
[13:21:52.516]             {
[13:21:52.516]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:52.516]                   0L) {
[13:21:52.516]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:52.516]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:52.516]                   base::options(opts)
[13:21:52.516]                 }
[13:21:52.516]                 {
[13:21:52.516]                   {
[13:21:52.516]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:52.516]                     NULL
[13:21:52.516]                   }
[13:21:52.516]                   options(future.plan = NULL)
[13:21:52.516]                   if (is.na(NA_character_)) 
[13:21:52.516]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:52.516]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:52.516]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:52.516]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:52.516]                     envir = parent.frame()) 
[13:21:52.516]                   {
[13:21:52.516]                     if (is.function(workers)) 
[13:21:52.516]                       workers <- workers()
[13:21:52.516]                     workers <- structure(as.integer(workers), 
[13:21:52.516]                       class = class(workers))
[13:21:52.516]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:52.516]                       workers >= 1)
[13:21:52.516]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:52.516]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:52.516]                     }
[13:21:52.516]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:52.516]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:52.516]                       envir = envir)
[13:21:52.516]                     if (!future$lazy) 
[13:21:52.516]                       future <- run(future)
[13:21:52.516]                     invisible(future)
[13:21:52.516]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:52.516]                 }
[13:21:52.516]             }
[13:21:52.516]         }
[13:21:52.516]     })
[13:21:52.516]     if (TRUE) {
[13:21:52.516]         base::sink(type = "output", split = FALSE)
[13:21:52.516]         if (TRUE) {
[13:21:52.516]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:52.516]         }
[13:21:52.516]         else {
[13:21:52.516]             ...future.result["stdout"] <- base::list(NULL)
[13:21:52.516]         }
[13:21:52.516]         base::close(...future.stdout)
[13:21:52.516]         ...future.stdout <- NULL
[13:21:52.516]     }
[13:21:52.516]     ...future.result$conditions <- ...future.conditions
[13:21:52.516]     ...future.result$finished <- base::Sys.time()
[13:21:52.516]     ...future.result
[13:21:52.516] }
[13:21:52.519] MultisessionFuture started
[13:21:52.519] - Launch lazy future ... done
[13:21:52.519] run() for ‘MultisessionFuture’ ... done
[13:21:53.076] receiveMessageFromWorker() for ClusterFuture ...
[13:21:53.076] - Validating connection of MultisessionFuture
[13:21:53.076] - received message: FutureResult
[13:21:53.077] - Received FutureResult
[13:21:53.077] - Erased future from FutureRegistry
[13:21:53.077] result() for ClusterFuture ...
[13:21:53.077] - result already collected: FutureResult
[13:21:53.077] result() for ClusterFuture ... done
[13:21:53.077] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:53.077] resolve() on list ...
[13:21:53.077]  recursive: 98
[13:21:53.077]  length: 2
[13:21:53.078]  elements: ‘a’, ‘b’
[13:21:53.078]  length: 1 (resolved future 1)
[13:21:53.078]  length: 0 (resolved future 2)
[13:21:53.078] resolve() on list ... DONE
[13:21:53.078] A MultisessionFuture was resolved (and resolved itself)
[13:21:53.078] getGlobalsAndPackages() ...
[13:21:53.078] Searching for globals...
[13:21:53.079] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:21:53.079] Searching for globals ... DONE
[13:21:53.080] Resolving globals: FALSE
[13:21:53.080] 
[13:21:53.080] 
[13:21:53.080] getGlobalsAndPackages() ... DONE
[13:21:53.080] run() for ‘Future’ ...
[13:21:53.080] - state: ‘created’
[13:21:53.081] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:53.095] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:53.095] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:53.100]   - Field: ‘node’
[13:21:53.100]   - Field: ‘label’
[13:21:53.100]   - Field: ‘local’
[13:21:53.100]   - Field: ‘owner’
[13:21:53.100]   - Field: ‘envir’
[13:21:53.101]   - Field: ‘workers’
[13:21:53.101]   - Field: ‘packages’
[13:21:53.101]   - Field: ‘gc’
[13:21:53.101]   - Field: ‘conditions’
[13:21:53.101]   - Field: ‘persistent’
[13:21:53.101]   - Field: ‘expr’
[13:21:53.101]   - Field: ‘uuid’
[13:21:53.101]   - Field: ‘seed’
[13:21:53.101]   - Field: ‘version’
[13:21:53.101]   - Field: ‘result’
[13:21:53.102]   - Field: ‘asynchronous’
[13:21:53.102]   - Field: ‘calls’
[13:21:53.102]   - Field: ‘globals’
[13:21:53.102]   - Field: ‘stdout’
[13:21:53.102]   - Field: ‘earlySignal’
[13:21:53.102]   - Field: ‘lazy’
[13:21:53.102]   - Field: ‘state’
[13:21:53.102] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:53.102] - Launch lazy future ...
[13:21:53.102] Packages needed by the future expression (n = 0): <none>
[13:21:53.103] Packages needed by future strategies (n = 0): <none>
[13:21:53.103] {
[13:21:53.103]     {
[13:21:53.103]         {
[13:21:53.103]             ...future.startTime <- base::Sys.time()
[13:21:53.103]             {
[13:21:53.103]                 {
[13:21:53.103]                   {
[13:21:53.103]                     {
[13:21:53.103]                       base::local({
[13:21:53.103]                         has_future <- base::requireNamespace("future", 
[13:21:53.103]                           quietly = TRUE)
[13:21:53.103]                         if (has_future) {
[13:21:53.103]                           ns <- base::getNamespace("future")
[13:21:53.103]                           version <- ns[[".package"]][["version"]]
[13:21:53.103]                           if (is.null(version)) 
[13:21:53.103]                             version <- utils::packageVersion("future")
[13:21:53.103]                         }
[13:21:53.103]                         else {
[13:21:53.103]                           version <- NULL
[13:21:53.103]                         }
[13:21:53.103]                         if (!has_future || version < "1.8.0") {
[13:21:53.103]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:53.103]                             "", base::R.version$version.string), 
[13:21:53.103]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:53.103]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:53.103]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:53.103]                               "release", "version")], collapse = " "), 
[13:21:53.103]                             hostname = base::Sys.info()[["nodename"]])
[13:21:53.103]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:53.103]                             info)
[13:21:53.103]                           info <- base::paste(info, collapse = "; ")
[13:21:53.103]                           if (!has_future) {
[13:21:53.103]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:53.103]                               info)
[13:21:53.103]                           }
[13:21:53.103]                           else {
[13:21:53.103]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:53.103]                               info, version)
[13:21:53.103]                           }
[13:21:53.103]                           base::stop(msg)
[13:21:53.103]                         }
[13:21:53.103]                       })
[13:21:53.103]                     }
[13:21:53.103]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:53.103]                     base::options(mc.cores = 1L)
[13:21:53.103]                   }
[13:21:53.103]                   options(future.plan = NULL)
[13:21:53.103]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:53.103]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:53.103]                 }
[13:21:53.103]                 ...future.workdir <- getwd()
[13:21:53.103]             }
[13:21:53.103]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:53.103]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:53.103]         }
[13:21:53.103]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:53.103]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:53.103]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:53.103]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:53.103]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:53.103]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:53.103]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:53.103]             base::names(...future.oldOptions))
[13:21:53.103]     }
[13:21:53.103]     if (FALSE) {
[13:21:53.103]     }
[13:21:53.103]     else {
[13:21:53.103]         if (TRUE) {
[13:21:53.103]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:53.103]                 open = "w")
[13:21:53.103]         }
[13:21:53.103]         else {
[13:21:53.103]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:53.103]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:53.103]         }
[13:21:53.103]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:53.103]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:53.103]             base::sink(type = "output", split = FALSE)
[13:21:53.103]             base::close(...future.stdout)
[13:21:53.103]         }, add = TRUE)
[13:21:53.103]     }
[13:21:53.103]     ...future.frame <- base::sys.nframe()
[13:21:53.103]     ...future.conditions <- base::list()
[13:21:53.103]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:53.103]     if (FALSE) {
[13:21:53.103]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:53.103]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:53.103]     }
[13:21:53.103]     ...future.result <- base::tryCatch({
[13:21:53.103]         base::withCallingHandlers({
[13:21:53.103]             ...future.value <- base::withVisible(base::local({
[13:21:53.103]                 ...future.makeSendCondition <- local({
[13:21:53.103]                   sendCondition <- NULL
[13:21:53.103]                   function(frame = 1L) {
[13:21:53.103]                     if (is.function(sendCondition)) 
[13:21:53.103]                       return(sendCondition)
[13:21:53.103]                     ns <- getNamespace("parallel")
[13:21:53.103]                     if (exists("sendData", mode = "function", 
[13:21:53.103]                       envir = ns)) {
[13:21:53.103]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:53.103]                         envir = ns)
[13:21:53.103]                       envir <- sys.frame(frame)
[13:21:53.103]                       master <- NULL
[13:21:53.103]                       while (!identical(envir, .GlobalEnv) && 
[13:21:53.103]                         !identical(envir, emptyenv())) {
[13:21:53.103]                         if (exists("master", mode = "list", envir = envir, 
[13:21:53.103]                           inherits = FALSE)) {
[13:21:53.103]                           master <- get("master", mode = "list", 
[13:21:53.103]                             envir = envir, inherits = FALSE)
[13:21:53.103]                           if (inherits(master, c("SOCKnode", 
[13:21:53.103]                             "SOCK0node"))) {
[13:21:53.103]                             sendCondition <<- function(cond) {
[13:21:53.103]                               data <- list(type = "VALUE", value = cond, 
[13:21:53.103]                                 success = TRUE)
[13:21:53.103]                               parallel_sendData(master, data)
[13:21:53.103]                             }
[13:21:53.103]                             return(sendCondition)
[13:21:53.103]                           }
[13:21:53.103]                         }
[13:21:53.103]                         frame <- frame + 1L
[13:21:53.103]                         envir <- sys.frame(frame)
[13:21:53.103]                       }
[13:21:53.103]                     }
[13:21:53.103]                     sendCondition <<- function(cond) NULL
[13:21:53.103]                   }
[13:21:53.103]                 })
[13:21:53.103]                 withCallingHandlers({
[13:21:53.103]                   {
[13:21:53.103]                     Sys.sleep(0.5)
[13:21:53.103]                     list(a = 1, b = 42L)
[13:21:53.103]                   }
[13:21:53.103]                 }, immediateCondition = function(cond) {
[13:21:53.103]                   sendCondition <- ...future.makeSendCondition()
[13:21:53.103]                   sendCondition(cond)
[13:21:53.103]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:53.103]                   {
[13:21:53.103]                     inherits <- base::inherits
[13:21:53.103]                     invokeRestart <- base::invokeRestart
[13:21:53.103]                     is.null <- base::is.null
[13:21:53.103]                     muffled <- FALSE
[13:21:53.103]                     if (inherits(cond, "message")) {
[13:21:53.103]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:53.103]                       if (muffled) 
[13:21:53.103]                         invokeRestart("muffleMessage")
[13:21:53.103]                     }
[13:21:53.103]                     else if (inherits(cond, "warning")) {
[13:21:53.103]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:53.103]                       if (muffled) 
[13:21:53.103]                         invokeRestart("muffleWarning")
[13:21:53.103]                     }
[13:21:53.103]                     else if (inherits(cond, "condition")) {
[13:21:53.103]                       if (!is.null(pattern)) {
[13:21:53.103]                         computeRestarts <- base::computeRestarts
[13:21:53.103]                         grepl <- base::grepl
[13:21:53.103]                         restarts <- computeRestarts(cond)
[13:21:53.103]                         for (restart in restarts) {
[13:21:53.103]                           name <- restart$name
[13:21:53.103]                           if (is.null(name)) 
[13:21:53.103]                             next
[13:21:53.103]                           if (!grepl(pattern, name)) 
[13:21:53.103]                             next
[13:21:53.103]                           invokeRestart(restart)
[13:21:53.103]                           muffled <- TRUE
[13:21:53.103]                           break
[13:21:53.103]                         }
[13:21:53.103]                       }
[13:21:53.103]                     }
[13:21:53.103]                     invisible(muffled)
[13:21:53.103]                   }
[13:21:53.103]                   muffleCondition(cond)
[13:21:53.103]                 })
[13:21:53.103]             }))
[13:21:53.103]             future::FutureResult(value = ...future.value$value, 
[13:21:53.103]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:53.103]                   ...future.rng), globalenv = if (FALSE) 
[13:21:53.103]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:53.103]                     ...future.globalenv.names))
[13:21:53.103]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:53.103]         }, condition = base::local({
[13:21:53.103]             c <- base::c
[13:21:53.103]             inherits <- base::inherits
[13:21:53.103]             invokeRestart <- base::invokeRestart
[13:21:53.103]             length <- base::length
[13:21:53.103]             list <- base::list
[13:21:53.103]             seq.int <- base::seq.int
[13:21:53.103]             signalCondition <- base::signalCondition
[13:21:53.103]             sys.calls <- base::sys.calls
[13:21:53.103]             `[[` <- base::`[[`
[13:21:53.103]             `+` <- base::`+`
[13:21:53.103]             `<<-` <- base::`<<-`
[13:21:53.103]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:53.103]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:53.103]                   3L)]
[13:21:53.103]             }
[13:21:53.103]             function(cond) {
[13:21:53.103]                 is_error <- inherits(cond, "error")
[13:21:53.103]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:53.103]                   NULL)
[13:21:53.103]                 if (is_error) {
[13:21:53.103]                   sessionInformation <- function() {
[13:21:53.103]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:53.103]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:53.103]                       search = base::search(), system = base::Sys.info())
[13:21:53.103]                   }
[13:21:53.103]                   ...future.conditions[[length(...future.conditions) + 
[13:21:53.103]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:53.103]                     cond$call), session = sessionInformation(), 
[13:21:53.103]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:53.103]                   signalCondition(cond)
[13:21:53.103]                 }
[13:21:53.103]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:53.103]                 "immediateCondition"))) {
[13:21:53.103]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:53.103]                   ...future.conditions[[length(...future.conditions) + 
[13:21:53.103]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:53.103]                   if (TRUE && !signal) {
[13:21:53.103]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:53.103]                     {
[13:21:53.103]                       inherits <- base::inherits
[13:21:53.103]                       invokeRestart <- base::invokeRestart
[13:21:53.103]                       is.null <- base::is.null
[13:21:53.103]                       muffled <- FALSE
[13:21:53.103]                       if (inherits(cond, "message")) {
[13:21:53.103]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:53.103]                         if (muffled) 
[13:21:53.103]                           invokeRestart("muffleMessage")
[13:21:53.103]                       }
[13:21:53.103]                       else if (inherits(cond, "warning")) {
[13:21:53.103]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:53.103]                         if (muffled) 
[13:21:53.103]                           invokeRestart("muffleWarning")
[13:21:53.103]                       }
[13:21:53.103]                       else if (inherits(cond, "condition")) {
[13:21:53.103]                         if (!is.null(pattern)) {
[13:21:53.103]                           computeRestarts <- base::computeRestarts
[13:21:53.103]                           grepl <- base::grepl
[13:21:53.103]                           restarts <- computeRestarts(cond)
[13:21:53.103]                           for (restart in restarts) {
[13:21:53.103]                             name <- restart$name
[13:21:53.103]                             if (is.null(name)) 
[13:21:53.103]                               next
[13:21:53.103]                             if (!grepl(pattern, name)) 
[13:21:53.103]                               next
[13:21:53.103]                             invokeRestart(restart)
[13:21:53.103]                             muffled <- TRUE
[13:21:53.103]                             break
[13:21:53.103]                           }
[13:21:53.103]                         }
[13:21:53.103]                       }
[13:21:53.103]                       invisible(muffled)
[13:21:53.103]                     }
[13:21:53.103]                     muffleCondition(cond, pattern = "^muffle")
[13:21:53.103]                   }
[13:21:53.103]                 }
[13:21:53.103]                 else {
[13:21:53.103]                   if (TRUE) {
[13:21:53.103]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:53.103]                     {
[13:21:53.103]                       inherits <- base::inherits
[13:21:53.103]                       invokeRestart <- base::invokeRestart
[13:21:53.103]                       is.null <- base::is.null
[13:21:53.103]                       muffled <- FALSE
[13:21:53.103]                       if (inherits(cond, "message")) {
[13:21:53.103]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:53.103]                         if (muffled) 
[13:21:53.103]                           invokeRestart("muffleMessage")
[13:21:53.103]                       }
[13:21:53.103]                       else if (inherits(cond, "warning")) {
[13:21:53.103]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:53.103]                         if (muffled) 
[13:21:53.103]                           invokeRestart("muffleWarning")
[13:21:53.103]                       }
[13:21:53.103]                       else if (inherits(cond, "condition")) {
[13:21:53.103]                         if (!is.null(pattern)) {
[13:21:53.103]                           computeRestarts <- base::computeRestarts
[13:21:53.103]                           grepl <- base::grepl
[13:21:53.103]                           restarts <- computeRestarts(cond)
[13:21:53.103]                           for (restart in restarts) {
[13:21:53.103]                             name <- restart$name
[13:21:53.103]                             if (is.null(name)) 
[13:21:53.103]                               next
[13:21:53.103]                             if (!grepl(pattern, name)) 
[13:21:53.103]                               next
[13:21:53.103]                             invokeRestart(restart)
[13:21:53.103]                             muffled <- TRUE
[13:21:53.103]                             break
[13:21:53.103]                           }
[13:21:53.103]                         }
[13:21:53.103]                       }
[13:21:53.103]                       invisible(muffled)
[13:21:53.103]                     }
[13:21:53.103]                     muffleCondition(cond, pattern = "^muffle")
[13:21:53.103]                   }
[13:21:53.103]                 }
[13:21:53.103]             }
[13:21:53.103]         }))
[13:21:53.103]     }, error = function(ex) {
[13:21:53.103]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:53.103]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:53.103]                 ...future.rng), started = ...future.startTime, 
[13:21:53.103]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:53.103]             version = "1.8"), class = "FutureResult")
[13:21:53.103]     }, finally = {
[13:21:53.103]         if (!identical(...future.workdir, getwd())) 
[13:21:53.103]             setwd(...future.workdir)
[13:21:53.103]         {
[13:21:53.103]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:53.103]                 ...future.oldOptions$nwarnings <- NULL
[13:21:53.103]             }
[13:21:53.103]             base::options(...future.oldOptions)
[13:21:53.103]             if (.Platform$OS.type == "windows") {
[13:21:53.103]                 old_names <- names(...future.oldEnvVars)
[13:21:53.103]                 envs <- base::Sys.getenv()
[13:21:53.103]                 names <- names(envs)
[13:21:53.103]                 common <- intersect(names, old_names)
[13:21:53.103]                 added <- setdiff(names, old_names)
[13:21:53.103]                 removed <- setdiff(old_names, names)
[13:21:53.103]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:53.103]                   envs[common]]
[13:21:53.103]                 NAMES <- toupper(changed)
[13:21:53.103]                 args <- list()
[13:21:53.103]                 for (kk in seq_along(NAMES)) {
[13:21:53.103]                   name <- changed[[kk]]
[13:21:53.103]                   NAME <- NAMES[[kk]]
[13:21:53.103]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:53.103]                     next
[13:21:53.103]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:53.103]                 }
[13:21:53.103]                 NAMES <- toupper(added)
[13:21:53.103]                 for (kk in seq_along(NAMES)) {
[13:21:53.103]                   name <- added[[kk]]
[13:21:53.103]                   NAME <- NAMES[[kk]]
[13:21:53.103]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:53.103]                     next
[13:21:53.103]                   args[[name]] <- ""
[13:21:53.103]                 }
[13:21:53.103]                 NAMES <- toupper(removed)
[13:21:53.103]                 for (kk in seq_along(NAMES)) {
[13:21:53.103]                   name <- removed[[kk]]
[13:21:53.103]                   NAME <- NAMES[[kk]]
[13:21:53.103]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:53.103]                     next
[13:21:53.103]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:53.103]                 }
[13:21:53.103]                 if (length(args) > 0) 
[13:21:53.103]                   base::do.call(base::Sys.setenv, args = args)
[13:21:53.103]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:53.103]             }
[13:21:53.103]             else {
[13:21:53.103]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:53.103]             }
[13:21:53.103]             {
[13:21:53.103]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:53.103]                   0L) {
[13:21:53.103]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:53.103]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:53.103]                   base::options(opts)
[13:21:53.103]                 }
[13:21:53.103]                 {
[13:21:53.103]                   {
[13:21:53.103]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:53.103]                     NULL
[13:21:53.103]                   }
[13:21:53.103]                   options(future.plan = NULL)
[13:21:53.103]                   if (is.na(NA_character_)) 
[13:21:53.103]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:53.103]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:53.103]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:53.103]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:53.103]                     envir = parent.frame()) 
[13:21:53.103]                   {
[13:21:53.103]                     if (is.function(workers)) 
[13:21:53.103]                       workers <- workers()
[13:21:53.103]                     workers <- structure(as.integer(workers), 
[13:21:53.103]                       class = class(workers))
[13:21:53.103]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:53.103]                       workers >= 1)
[13:21:53.103]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:53.103]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:53.103]                     }
[13:21:53.103]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:53.103]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:53.103]                       envir = envir)
[13:21:53.103]                     if (!future$lazy) 
[13:21:53.103]                       future <- run(future)
[13:21:53.103]                     invisible(future)
[13:21:53.103]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:53.103]                 }
[13:21:53.103]             }
[13:21:53.103]         }
[13:21:53.103]     })
[13:21:53.103]     if (TRUE) {
[13:21:53.103]         base::sink(type = "output", split = FALSE)
[13:21:53.103]         if (TRUE) {
[13:21:53.103]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:53.103]         }
[13:21:53.103]         else {
[13:21:53.103]             ...future.result["stdout"] <- base::list(NULL)
[13:21:53.103]         }
[13:21:53.103]         base::close(...future.stdout)
[13:21:53.103]         ...future.stdout <- NULL
[13:21:53.103]     }
[13:21:53.103]     ...future.result$conditions <- ...future.conditions
[13:21:53.103]     ...future.result$finished <- base::Sys.time()
[13:21:53.103]     ...future.result
[13:21:53.103] }
[13:21:53.106] MultisessionFuture started
[13:21:53.106] - Launch lazy future ... done
[13:21:53.106] run() for ‘MultisessionFuture’ ... done
[13:21:53.665] receiveMessageFromWorker() for ClusterFuture ...
[13:21:53.665] - Validating connection of MultisessionFuture
[13:21:53.665] - received message: FutureResult
[13:21:53.665] - Received FutureResult
[13:21:53.666] - Erased future from FutureRegistry
[13:21:53.666] result() for ClusterFuture ...
[13:21:53.666] - result already collected: FutureResult
[13:21:53.666] result() for ClusterFuture ... done
[13:21:53.666] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:53.666] resolve() on list ...
[13:21:53.666]  recursive: 98
[13:21:53.666]  length: 2
[13:21:53.666]  elements: ‘a’, ‘b’
[13:21:53.666]  length: 1 (resolved future 1)
[13:21:53.667]  length: 0 (resolved future 2)
[13:21:53.667] resolve() on list ... DONE
[13:21:53.667] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[13:21:53.667] getGlobalsAndPackages() ...
[13:21:53.667] Searching for globals...
[13:21:53.668] - globals found: [2] ‘list’, ‘stop’
[13:21:53.668] Searching for globals ... DONE
[13:21:53.668] Resolving globals: FALSE
[13:21:53.668] 
[13:21:53.668] 
[13:21:53.668] getGlobalsAndPackages() ... DONE
[13:21:53.669] run() for ‘Future’ ...
[13:21:53.669] - state: ‘created’
[13:21:53.669] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:53.683] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:53.684] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:53.684]   - Field: ‘node’
[13:21:53.684]   - Field: ‘label’
[13:21:53.684]   - Field: ‘local’
[13:21:53.684]   - Field: ‘owner’
[13:21:53.684]   - Field: ‘envir’
[13:21:53.684]   - Field: ‘workers’
[13:21:53.684]   - Field: ‘packages’
[13:21:53.684]   - Field: ‘gc’
[13:21:53.684]   - Field: ‘conditions’
[13:21:53.684]   - Field: ‘persistent’
[13:21:53.685]   - Field: ‘expr’
[13:21:53.685]   - Field: ‘uuid’
[13:21:53.685]   - Field: ‘seed’
[13:21:53.685]   - Field: ‘version’
[13:21:53.685]   - Field: ‘result’
[13:21:53.685]   - Field: ‘asynchronous’
[13:21:53.685]   - Field: ‘calls’
[13:21:53.685]   - Field: ‘globals’
[13:21:53.685]   - Field: ‘stdout’
[13:21:53.685]   - Field: ‘earlySignal’
[13:21:53.686]   - Field: ‘lazy’
[13:21:53.686]   - Field: ‘state’
[13:21:53.686] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:53.686] - Launch lazy future ...
[13:21:53.686] Packages needed by the future expression (n = 0): <none>
[13:21:53.686] Packages needed by future strategies (n = 0): <none>
[13:21:53.687] {
[13:21:53.687]     {
[13:21:53.687]         {
[13:21:53.687]             ...future.startTime <- base::Sys.time()
[13:21:53.687]             {
[13:21:53.687]                 {
[13:21:53.687]                   {
[13:21:53.687]                     {
[13:21:53.687]                       base::local({
[13:21:53.687]                         has_future <- base::requireNamespace("future", 
[13:21:53.687]                           quietly = TRUE)
[13:21:53.687]                         if (has_future) {
[13:21:53.687]                           ns <- base::getNamespace("future")
[13:21:53.687]                           version <- ns[[".package"]][["version"]]
[13:21:53.687]                           if (is.null(version)) 
[13:21:53.687]                             version <- utils::packageVersion("future")
[13:21:53.687]                         }
[13:21:53.687]                         else {
[13:21:53.687]                           version <- NULL
[13:21:53.687]                         }
[13:21:53.687]                         if (!has_future || version < "1.8.0") {
[13:21:53.687]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:53.687]                             "", base::R.version$version.string), 
[13:21:53.687]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:53.687]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:53.687]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:53.687]                               "release", "version")], collapse = " "), 
[13:21:53.687]                             hostname = base::Sys.info()[["nodename"]])
[13:21:53.687]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:53.687]                             info)
[13:21:53.687]                           info <- base::paste(info, collapse = "; ")
[13:21:53.687]                           if (!has_future) {
[13:21:53.687]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:53.687]                               info)
[13:21:53.687]                           }
[13:21:53.687]                           else {
[13:21:53.687]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:53.687]                               info, version)
[13:21:53.687]                           }
[13:21:53.687]                           base::stop(msg)
[13:21:53.687]                         }
[13:21:53.687]                       })
[13:21:53.687]                     }
[13:21:53.687]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:53.687]                     base::options(mc.cores = 1L)
[13:21:53.687]                   }
[13:21:53.687]                   options(future.plan = NULL)
[13:21:53.687]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:53.687]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:53.687]                 }
[13:21:53.687]                 ...future.workdir <- getwd()
[13:21:53.687]             }
[13:21:53.687]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:53.687]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:53.687]         }
[13:21:53.687]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:53.687]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:53.687]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:53.687]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:53.687]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:53.687]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:53.687]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:53.687]             base::names(...future.oldOptions))
[13:21:53.687]     }
[13:21:53.687]     if (FALSE) {
[13:21:53.687]     }
[13:21:53.687]     else {
[13:21:53.687]         if (TRUE) {
[13:21:53.687]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:53.687]                 open = "w")
[13:21:53.687]         }
[13:21:53.687]         else {
[13:21:53.687]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:53.687]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:53.687]         }
[13:21:53.687]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:53.687]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:53.687]             base::sink(type = "output", split = FALSE)
[13:21:53.687]             base::close(...future.stdout)
[13:21:53.687]         }, add = TRUE)
[13:21:53.687]     }
[13:21:53.687]     ...future.frame <- base::sys.nframe()
[13:21:53.687]     ...future.conditions <- base::list()
[13:21:53.687]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:53.687]     if (FALSE) {
[13:21:53.687]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:53.687]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:53.687]     }
[13:21:53.687]     ...future.result <- base::tryCatch({
[13:21:53.687]         base::withCallingHandlers({
[13:21:53.687]             ...future.value <- base::withVisible(base::local({
[13:21:53.687]                 ...future.makeSendCondition <- local({
[13:21:53.687]                   sendCondition <- NULL
[13:21:53.687]                   function(frame = 1L) {
[13:21:53.687]                     if (is.function(sendCondition)) 
[13:21:53.687]                       return(sendCondition)
[13:21:53.687]                     ns <- getNamespace("parallel")
[13:21:53.687]                     if (exists("sendData", mode = "function", 
[13:21:53.687]                       envir = ns)) {
[13:21:53.687]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:53.687]                         envir = ns)
[13:21:53.687]                       envir <- sys.frame(frame)
[13:21:53.687]                       master <- NULL
[13:21:53.687]                       while (!identical(envir, .GlobalEnv) && 
[13:21:53.687]                         !identical(envir, emptyenv())) {
[13:21:53.687]                         if (exists("master", mode = "list", envir = envir, 
[13:21:53.687]                           inherits = FALSE)) {
[13:21:53.687]                           master <- get("master", mode = "list", 
[13:21:53.687]                             envir = envir, inherits = FALSE)
[13:21:53.687]                           if (inherits(master, c("SOCKnode", 
[13:21:53.687]                             "SOCK0node"))) {
[13:21:53.687]                             sendCondition <<- function(cond) {
[13:21:53.687]                               data <- list(type = "VALUE", value = cond, 
[13:21:53.687]                                 success = TRUE)
[13:21:53.687]                               parallel_sendData(master, data)
[13:21:53.687]                             }
[13:21:53.687]                             return(sendCondition)
[13:21:53.687]                           }
[13:21:53.687]                         }
[13:21:53.687]                         frame <- frame + 1L
[13:21:53.687]                         envir <- sys.frame(frame)
[13:21:53.687]                       }
[13:21:53.687]                     }
[13:21:53.687]                     sendCondition <<- function(cond) NULL
[13:21:53.687]                   }
[13:21:53.687]                 })
[13:21:53.687]                 withCallingHandlers({
[13:21:53.687]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:21:53.687]                 }, immediateCondition = function(cond) {
[13:21:53.687]                   sendCondition <- ...future.makeSendCondition()
[13:21:53.687]                   sendCondition(cond)
[13:21:53.687]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:53.687]                   {
[13:21:53.687]                     inherits <- base::inherits
[13:21:53.687]                     invokeRestart <- base::invokeRestart
[13:21:53.687]                     is.null <- base::is.null
[13:21:53.687]                     muffled <- FALSE
[13:21:53.687]                     if (inherits(cond, "message")) {
[13:21:53.687]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:53.687]                       if (muffled) 
[13:21:53.687]                         invokeRestart("muffleMessage")
[13:21:53.687]                     }
[13:21:53.687]                     else if (inherits(cond, "warning")) {
[13:21:53.687]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:53.687]                       if (muffled) 
[13:21:53.687]                         invokeRestart("muffleWarning")
[13:21:53.687]                     }
[13:21:53.687]                     else if (inherits(cond, "condition")) {
[13:21:53.687]                       if (!is.null(pattern)) {
[13:21:53.687]                         computeRestarts <- base::computeRestarts
[13:21:53.687]                         grepl <- base::grepl
[13:21:53.687]                         restarts <- computeRestarts(cond)
[13:21:53.687]                         for (restart in restarts) {
[13:21:53.687]                           name <- restart$name
[13:21:53.687]                           if (is.null(name)) 
[13:21:53.687]                             next
[13:21:53.687]                           if (!grepl(pattern, name)) 
[13:21:53.687]                             next
[13:21:53.687]                           invokeRestart(restart)
[13:21:53.687]                           muffled <- TRUE
[13:21:53.687]                           break
[13:21:53.687]                         }
[13:21:53.687]                       }
[13:21:53.687]                     }
[13:21:53.687]                     invisible(muffled)
[13:21:53.687]                   }
[13:21:53.687]                   muffleCondition(cond)
[13:21:53.687]                 })
[13:21:53.687]             }))
[13:21:53.687]             future::FutureResult(value = ...future.value$value, 
[13:21:53.687]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:53.687]                   ...future.rng), globalenv = if (FALSE) 
[13:21:53.687]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:53.687]                     ...future.globalenv.names))
[13:21:53.687]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:53.687]         }, condition = base::local({
[13:21:53.687]             c <- base::c
[13:21:53.687]             inherits <- base::inherits
[13:21:53.687]             invokeRestart <- base::invokeRestart
[13:21:53.687]             length <- base::length
[13:21:53.687]             list <- base::list
[13:21:53.687]             seq.int <- base::seq.int
[13:21:53.687]             signalCondition <- base::signalCondition
[13:21:53.687]             sys.calls <- base::sys.calls
[13:21:53.687]             `[[` <- base::`[[`
[13:21:53.687]             `+` <- base::`+`
[13:21:53.687]             `<<-` <- base::`<<-`
[13:21:53.687]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:53.687]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:53.687]                   3L)]
[13:21:53.687]             }
[13:21:53.687]             function(cond) {
[13:21:53.687]                 is_error <- inherits(cond, "error")
[13:21:53.687]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:53.687]                   NULL)
[13:21:53.687]                 if (is_error) {
[13:21:53.687]                   sessionInformation <- function() {
[13:21:53.687]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:53.687]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:53.687]                       search = base::search(), system = base::Sys.info())
[13:21:53.687]                   }
[13:21:53.687]                   ...future.conditions[[length(...future.conditions) + 
[13:21:53.687]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:53.687]                     cond$call), session = sessionInformation(), 
[13:21:53.687]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:53.687]                   signalCondition(cond)
[13:21:53.687]                 }
[13:21:53.687]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:53.687]                 "immediateCondition"))) {
[13:21:53.687]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:53.687]                   ...future.conditions[[length(...future.conditions) + 
[13:21:53.687]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:53.687]                   if (TRUE && !signal) {
[13:21:53.687]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:53.687]                     {
[13:21:53.687]                       inherits <- base::inherits
[13:21:53.687]                       invokeRestart <- base::invokeRestart
[13:21:53.687]                       is.null <- base::is.null
[13:21:53.687]                       muffled <- FALSE
[13:21:53.687]                       if (inherits(cond, "message")) {
[13:21:53.687]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:53.687]                         if (muffled) 
[13:21:53.687]                           invokeRestart("muffleMessage")
[13:21:53.687]                       }
[13:21:53.687]                       else if (inherits(cond, "warning")) {
[13:21:53.687]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:53.687]                         if (muffled) 
[13:21:53.687]                           invokeRestart("muffleWarning")
[13:21:53.687]                       }
[13:21:53.687]                       else if (inherits(cond, "condition")) {
[13:21:53.687]                         if (!is.null(pattern)) {
[13:21:53.687]                           computeRestarts <- base::computeRestarts
[13:21:53.687]                           grepl <- base::grepl
[13:21:53.687]                           restarts <- computeRestarts(cond)
[13:21:53.687]                           for (restart in restarts) {
[13:21:53.687]                             name <- restart$name
[13:21:53.687]                             if (is.null(name)) 
[13:21:53.687]                               next
[13:21:53.687]                             if (!grepl(pattern, name)) 
[13:21:53.687]                               next
[13:21:53.687]                             invokeRestart(restart)
[13:21:53.687]                             muffled <- TRUE
[13:21:53.687]                             break
[13:21:53.687]                           }
[13:21:53.687]                         }
[13:21:53.687]                       }
[13:21:53.687]                       invisible(muffled)
[13:21:53.687]                     }
[13:21:53.687]                     muffleCondition(cond, pattern = "^muffle")
[13:21:53.687]                   }
[13:21:53.687]                 }
[13:21:53.687]                 else {
[13:21:53.687]                   if (TRUE) {
[13:21:53.687]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:53.687]                     {
[13:21:53.687]                       inherits <- base::inherits
[13:21:53.687]                       invokeRestart <- base::invokeRestart
[13:21:53.687]                       is.null <- base::is.null
[13:21:53.687]                       muffled <- FALSE
[13:21:53.687]                       if (inherits(cond, "message")) {
[13:21:53.687]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:53.687]                         if (muffled) 
[13:21:53.687]                           invokeRestart("muffleMessage")
[13:21:53.687]                       }
[13:21:53.687]                       else if (inherits(cond, "warning")) {
[13:21:53.687]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:53.687]                         if (muffled) 
[13:21:53.687]                           invokeRestart("muffleWarning")
[13:21:53.687]                       }
[13:21:53.687]                       else if (inherits(cond, "condition")) {
[13:21:53.687]                         if (!is.null(pattern)) {
[13:21:53.687]                           computeRestarts <- base::computeRestarts
[13:21:53.687]                           grepl <- base::grepl
[13:21:53.687]                           restarts <- computeRestarts(cond)
[13:21:53.687]                           for (restart in restarts) {
[13:21:53.687]                             name <- restart$name
[13:21:53.687]                             if (is.null(name)) 
[13:21:53.687]                               next
[13:21:53.687]                             if (!grepl(pattern, name)) 
[13:21:53.687]                               next
[13:21:53.687]                             invokeRestart(restart)
[13:21:53.687]                             muffled <- TRUE
[13:21:53.687]                             break
[13:21:53.687]                           }
[13:21:53.687]                         }
[13:21:53.687]                       }
[13:21:53.687]                       invisible(muffled)
[13:21:53.687]                     }
[13:21:53.687]                     muffleCondition(cond, pattern = "^muffle")
[13:21:53.687]                   }
[13:21:53.687]                 }
[13:21:53.687]             }
[13:21:53.687]         }))
[13:21:53.687]     }, error = function(ex) {
[13:21:53.687]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:53.687]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:53.687]                 ...future.rng), started = ...future.startTime, 
[13:21:53.687]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:53.687]             version = "1.8"), class = "FutureResult")
[13:21:53.687]     }, finally = {
[13:21:53.687]         if (!identical(...future.workdir, getwd())) 
[13:21:53.687]             setwd(...future.workdir)
[13:21:53.687]         {
[13:21:53.687]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:53.687]                 ...future.oldOptions$nwarnings <- NULL
[13:21:53.687]             }
[13:21:53.687]             base::options(...future.oldOptions)
[13:21:53.687]             if (.Platform$OS.type == "windows") {
[13:21:53.687]                 old_names <- names(...future.oldEnvVars)
[13:21:53.687]                 envs <- base::Sys.getenv()
[13:21:53.687]                 names <- names(envs)
[13:21:53.687]                 common <- intersect(names, old_names)
[13:21:53.687]                 added <- setdiff(names, old_names)
[13:21:53.687]                 removed <- setdiff(old_names, names)
[13:21:53.687]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:53.687]                   envs[common]]
[13:21:53.687]                 NAMES <- toupper(changed)
[13:21:53.687]                 args <- list()
[13:21:53.687]                 for (kk in seq_along(NAMES)) {
[13:21:53.687]                   name <- changed[[kk]]
[13:21:53.687]                   NAME <- NAMES[[kk]]
[13:21:53.687]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:53.687]                     next
[13:21:53.687]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:53.687]                 }
[13:21:53.687]                 NAMES <- toupper(added)
[13:21:53.687]                 for (kk in seq_along(NAMES)) {
[13:21:53.687]                   name <- added[[kk]]
[13:21:53.687]                   NAME <- NAMES[[kk]]
[13:21:53.687]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:53.687]                     next
[13:21:53.687]                   args[[name]] <- ""
[13:21:53.687]                 }
[13:21:53.687]                 NAMES <- toupper(removed)
[13:21:53.687]                 for (kk in seq_along(NAMES)) {
[13:21:53.687]                   name <- removed[[kk]]
[13:21:53.687]                   NAME <- NAMES[[kk]]
[13:21:53.687]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:53.687]                     next
[13:21:53.687]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:53.687]                 }
[13:21:53.687]                 if (length(args) > 0) 
[13:21:53.687]                   base::do.call(base::Sys.setenv, args = args)
[13:21:53.687]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:53.687]             }
[13:21:53.687]             else {
[13:21:53.687]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:53.687]             }
[13:21:53.687]             {
[13:21:53.687]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:53.687]                   0L) {
[13:21:53.687]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:53.687]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:53.687]                   base::options(opts)
[13:21:53.687]                 }
[13:21:53.687]                 {
[13:21:53.687]                   {
[13:21:53.687]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:53.687]                     NULL
[13:21:53.687]                   }
[13:21:53.687]                   options(future.plan = NULL)
[13:21:53.687]                   if (is.na(NA_character_)) 
[13:21:53.687]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:53.687]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:53.687]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:53.687]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:53.687]                     envir = parent.frame()) 
[13:21:53.687]                   {
[13:21:53.687]                     if (is.function(workers)) 
[13:21:53.687]                       workers <- workers()
[13:21:53.687]                     workers <- structure(as.integer(workers), 
[13:21:53.687]                       class = class(workers))
[13:21:53.687]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:53.687]                       workers >= 1)
[13:21:53.687]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:53.687]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:53.687]                     }
[13:21:53.687]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:53.687]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:53.687]                       envir = envir)
[13:21:53.687]                     if (!future$lazy) 
[13:21:53.687]                       future <- run(future)
[13:21:53.687]                     invisible(future)
[13:21:53.687]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:53.687]                 }
[13:21:53.687]             }
[13:21:53.687]         }
[13:21:53.687]     })
[13:21:53.687]     if (TRUE) {
[13:21:53.687]         base::sink(type = "output", split = FALSE)
[13:21:53.687]         if (TRUE) {
[13:21:53.687]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:53.687]         }
[13:21:53.687]         else {
[13:21:53.687]             ...future.result["stdout"] <- base::list(NULL)
[13:21:53.687]         }
[13:21:53.687]         base::close(...future.stdout)
[13:21:53.687]         ...future.stdout <- NULL
[13:21:53.687]     }
[13:21:53.687]     ...future.result$conditions <- ...future.conditions
[13:21:53.687]     ...future.result$finished <- base::Sys.time()
[13:21:53.687]     ...future.result
[13:21:53.687] }
[13:21:53.690] MultisessionFuture started
[13:21:53.690] - Launch lazy future ... done
[13:21:53.690] run() for ‘MultisessionFuture’ ... done
[13:21:53.738] receiveMessageFromWorker() for ClusterFuture ...
[13:21:53.738] - Validating connection of MultisessionFuture
[13:21:53.739] - received message: FutureResult
[13:21:53.739] - Received FutureResult
[13:21:53.739] - Erased future from FutureRegistry
[13:21:53.739] result() for ClusterFuture ...
[13:21:53.739] - result already collected: FutureResult
[13:21:53.739] result() for ClusterFuture ... done
[13:21:53.739] signalConditions() ...
[13:21:53.739]  - include = ‘immediateCondition’
[13:21:53.740]  - exclude = 
[13:21:53.740]  - resignal = FALSE
[13:21:53.740]  - Number of conditions: 1
[13:21:53.740] signalConditions() ... done
[13:21:53.740] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:53.740] A MultisessionFuture was resolved
[13:21:53.740] getGlobalsAndPackages() ...
[13:21:53.740] Searching for globals...
[13:21:53.741] - globals found: [2] ‘list’, ‘stop’
[13:21:53.741] Searching for globals ... DONE
[13:21:53.741] Resolving globals: FALSE
[13:21:53.741] 
[13:21:53.742] 
[13:21:53.742] getGlobalsAndPackages() ... DONE
[13:21:53.742] run() for ‘Future’ ...
[13:21:53.742] - state: ‘created’
[13:21:53.742] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:53.756] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:53.757] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:53.757]   - Field: ‘node’
[13:21:53.757]   - Field: ‘label’
[13:21:53.757]   - Field: ‘local’
[13:21:53.757]   - Field: ‘owner’
[13:21:53.757]   - Field: ‘envir’
[13:21:53.757]   - Field: ‘workers’
[13:21:53.757]   - Field: ‘packages’
[13:21:53.757]   - Field: ‘gc’
[13:21:53.757]   - Field: ‘conditions’
[13:21:53.758]   - Field: ‘persistent’
[13:21:53.758]   - Field: ‘expr’
[13:21:53.758]   - Field: ‘uuid’
[13:21:53.758]   - Field: ‘seed’
[13:21:53.758]   - Field: ‘version’
[13:21:53.758]   - Field: ‘result’
[13:21:53.758]   - Field: ‘asynchronous’
[13:21:53.758]   - Field: ‘calls’
[13:21:53.758]   - Field: ‘globals’
[13:21:53.758]   - Field: ‘stdout’
[13:21:53.758]   - Field: ‘earlySignal’
[13:21:53.759]   - Field: ‘lazy’
[13:21:53.759]   - Field: ‘state’
[13:21:53.759] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:53.759] - Launch lazy future ...
[13:21:53.759] Packages needed by the future expression (n = 0): <none>
[13:21:53.759] Packages needed by future strategies (n = 0): <none>
[13:21:53.760] {
[13:21:53.760]     {
[13:21:53.760]         {
[13:21:53.760]             ...future.startTime <- base::Sys.time()
[13:21:53.760]             {
[13:21:53.760]                 {
[13:21:53.760]                   {
[13:21:53.760]                     {
[13:21:53.760]                       base::local({
[13:21:53.760]                         has_future <- base::requireNamespace("future", 
[13:21:53.760]                           quietly = TRUE)
[13:21:53.760]                         if (has_future) {
[13:21:53.760]                           ns <- base::getNamespace("future")
[13:21:53.760]                           version <- ns[[".package"]][["version"]]
[13:21:53.760]                           if (is.null(version)) 
[13:21:53.760]                             version <- utils::packageVersion("future")
[13:21:53.760]                         }
[13:21:53.760]                         else {
[13:21:53.760]                           version <- NULL
[13:21:53.760]                         }
[13:21:53.760]                         if (!has_future || version < "1.8.0") {
[13:21:53.760]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:53.760]                             "", base::R.version$version.string), 
[13:21:53.760]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:53.760]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:53.760]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:53.760]                               "release", "version")], collapse = " "), 
[13:21:53.760]                             hostname = base::Sys.info()[["nodename"]])
[13:21:53.760]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:53.760]                             info)
[13:21:53.760]                           info <- base::paste(info, collapse = "; ")
[13:21:53.760]                           if (!has_future) {
[13:21:53.760]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:53.760]                               info)
[13:21:53.760]                           }
[13:21:53.760]                           else {
[13:21:53.760]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:53.760]                               info, version)
[13:21:53.760]                           }
[13:21:53.760]                           base::stop(msg)
[13:21:53.760]                         }
[13:21:53.760]                       })
[13:21:53.760]                     }
[13:21:53.760]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:53.760]                     base::options(mc.cores = 1L)
[13:21:53.760]                   }
[13:21:53.760]                   options(future.plan = NULL)
[13:21:53.760]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:53.760]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:53.760]                 }
[13:21:53.760]                 ...future.workdir <- getwd()
[13:21:53.760]             }
[13:21:53.760]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:53.760]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:53.760]         }
[13:21:53.760]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:53.760]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:53.760]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:53.760]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:53.760]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:53.760]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:53.760]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:53.760]             base::names(...future.oldOptions))
[13:21:53.760]     }
[13:21:53.760]     if (FALSE) {
[13:21:53.760]     }
[13:21:53.760]     else {
[13:21:53.760]         if (TRUE) {
[13:21:53.760]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:53.760]                 open = "w")
[13:21:53.760]         }
[13:21:53.760]         else {
[13:21:53.760]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:53.760]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:53.760]         }
[13:21:53.760]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:53.760]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:53.760]             base::sink(type = "output", split = FALSE)
[13:21:53.760]             base::close(...future.stdout)
[13:21:53.760]         }, add = TRUE)
[13:21:53.760]     }
[13:21:53.760]     ...future.frame <- base::sys.nframe()
[13:21:53.760]     ...future.conditions <- base::list()
[13:21:53.760]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:53.760]     if (FALSE) {
[13:21:53.760]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:53.760]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:53.760]     }
[13:21:53.760]     ...future.result <- base::tryCatch({
[13:21:53.760]         base::withCallingHandlers({
[13:21:53.760]             ...future.value <- base::withVisible(base::local({
[13:21:53.760]                 ...future.makeSendCondition <- local({
[13:21:53.760]                   sendCondition <- NULL
[13:21:53.760]                   function(frame = 1L) {
[13:21:53.760]                     if (is.function(sendCondition)) 
[13:21:53.760]                       return(sendCondition)
[13:21:53.760]                     ns <- getNamespace("parallel")
[13:21:53.760]                     if (exists("sendData", mode = "function", 
[13:21:53.760]                       envir = ns)) {
[13:21:53.760]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:53.760]                         envir = ns)
[13:21:53.760]                       envir <- sys.frame(frame)
[13:21:53.760]                       master <- NULL
[13:21:53.760]                       while (!identical(envir, .GlobalEnv) && 
[13:21:53.760]                         !identical(envir, emptyenv())) {
[13:21:53.760]                         if (exists("master", mode = "list", envir = envir, 
[13:21:53.760]                           inherits = FALSE)) {
[13:21:53.760]                           master <- get("master", mode = "list", 
[13:21:53.760]                             envir = envir, inherits = FALSE)
[13:21:53.760]                           if (inherits(master, c("SOCKnode", 
[13:21:53.760]                             "SOCK0node"))) {
[13:21:53.760]                             sendCondition <<- function(cond) {
[13:21:53.760]                               data <- list(type = "VALUE", value = cond, 
[13:21:53.760]                                 success = TRUE)
[13:21:53.760]                               parallel_sendData(master, data)
[13:21:53.760]                             }
[13:21:53.760]                             return(sendCondition)
[13:21:53.760]                           }
[13:21:53.760]                         }
[13:21:53.760]                         frame <- frame + 1L
[13:21:53.760]                         envir <- sys.frame(frame)
[13:21:53.760]                       }
[13:21:53.760]                     }
[13:21:53.760]                     sendCondition <<- function(cond) NULL
[13:21:53.760]                   }
[13:21:53.760]                 })
[13:21:53.760]                 withCallingHandlers({
[13:21:53.760]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:21:53.760]                 }, immediateCondition = function(cond) {
[13:21:53.760]                   sendCondition <- ...future.makeSendCondition()
[13:21:53.760]                   sendCondition(cond)
[13:21:53.760]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:53.760]                   {
[13:21:53.760]                     inherits <- base::inherits
[13:21:53.760]                     invokeRestart <- base::invokeRestart
[13:21:53.760]                     is.null <- base::is.null
[13:21:53.760]                     muffled <- FALSE
[13:21:53.760]                     if (inherits(cond, "message")) {
[13:21:53.760]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:53.760]                       if (muffled) 
[13:21:53.760]                         invokeRestart("muffleMessage")
[13:21:53.760]                     }
[13:21:53.760]                     else if (inherits(cond, "warning")) {
[13:21:53.760]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:53.760]                       if (muffled) 
[13:21:53.760]                         invokeRestart("muffleWarning")
[13:21:53.760]                     }
[13:21:53.760]                     else if (inherits(cond, "condition")) {
[13:21:53.760]                       if (!is.null(pattern)) {
[13:21:53.760]                         computeRestarts <- base::computeRestarts
[13:21:53.760]                         grepl <- base::grepl
[13:21:53.760]                         restarts <- computeRestarts(cond)
[13:21:53.760]                         for (restart in restarts) {
[13:21:53.760]                           name <- restart$name
[13:21:53.760]                           if (is.null(name)) 
[13:21:53.760]                             next
[13:21:53.760]                           if (!grepl(pattern, name)) 
[13:21:53.760]                             next
[13:21:53.760]                           invokeRestart(restart)
[13:21:53.760]                           muffled <- TRUE
[13:21:53.760]                           break
[13:21:53.760]                         }
[13:21:53.760]                       }
[13:21:53.760]                     }
[13:21:53.760]                     invisible(muffled)
[13:21:53.760]                   }
[13:21:53.760]                   muffleCondition(cond)
[13:21:53.760]                 })
[13:21:53.760]             }))
[13:21:53.760]             future::FutureResult(value = ...future.value$value, 
[13:21:53.760]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:53.760]                   ...future.rng), globalenv = if (FALSE) 
[13:21:53.760]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:53.760]                     ...future.globalenv.names))
[13:21:53.760]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:53.760]         }, condition = base::local({
[13:21:53.760]             c <- base::c
[13:21:53.760]             inherits <- base::inherits
[13:21:53.760]             invokeRestart <- base::invokeRestart
[13:21:53.760]             length <- base::length
[13:21:53.760]             list <- base::list
[13:21:53.760]             seq.int <- base::seq.int
[13:21:53.760]             signalCondition <- base::signalCondition
[13:21:53.760]             sys.calls <- base::sys.calls
[13:21:53.760]             `[[` <- base::`[[`
[13:21:53.760]             `+` <- base::`+`
[13:21:53.760]             `<<-` <- base::`<<-`
[13:21:53.760]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:53.760]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:53.760]                   3L)]
[13:21:53.760]             }
[13:21:53.760]             function(cond) {
[13:21:53.760]                 is_error <- inherits(cond, "error")
[13:21:53.760]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:53.760]                   NULL)
[13:21:53.760]                 if (is_error) {
[13:21:53.760]                   sessionInformation <- function() {
[13:21:53.760]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:53.760]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:53.760]                       search = base::search(), system = base::Sys.info())
[13:21:53.760]                   }
[13:21:53.760]                   ...future.conditions[[length(...future.conditions) + 
[13:21:53.760]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:53.760]                     cond$call), session = sessionInformation(), 
[13:21:53.760]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:53.760]                   signalCondition(cond)
[13:21:53.760]                 }
[13:21:53.760]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:53.760]                 "immediateCondition"))) {
[13:21:53.760]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:53.760]                   ...future.conditions[[length(...future.conditions) + 
[13:21:53.760]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:53.760]                   if (TRUE && !signal) {
[13:21:53.760]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:53.760]                     {
[13:21:53.760]                       inherits <- base::inherits
[13:21:53.760]                       invokeRestart <- base::invokeRestart
[13:21:53.760]                       is.null <- base::is.null
[13:21:53.760]                       muffled <- FALSE
[13:21:53.760]                       if (inherits(cond, "message")) {
[13:21:53.760]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:53.760]                         if (muffled) 
[13:21:53.760]                           invokeRestart("muffleMessage")
[13:21:53.760]                       }
[13:21:53.760]                       else if (inherits(cond, "warning")) {
[13:21:53.760]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:53.760]                         if (muffled) 
[13:21:53.760]                           invokeRestart("muffleWarning")
[13:21:53.760]                       }
[13:21:53.760]                       else if (inherits(cond, "condition")) {
[13:21:53.760]                         if (!is.null(pattern)) {
[13:21:53.760]                           computeRestarts <- base::computeRestarts
[13:21:53.760]                           grepl <- base::grepl
[13:21:53.760]                           restarts <- computeRestarts(cond)
[13:21:53.760]                           for (restart in restarts) {
[13:21:53.760]                             name <- restart$name
[13:21:53.760]                             if (is.null(name)) 
[13:21:53.760]                               next
[13:21:53.760]                             if (!grepl(pattern, name)) 
[13:21:53.760]                               next
[13:21:53.760]                             invokeRestart(restart)
[13:21:53.760]                             muffled <- TRUE
[13:21:53.760]                             break
[13:21:53.760]                           }
[13:21:53.760]                         }
[13:21:53.760]                       }
[13:21:53.760]                       invisible(muffled)
[13:21:53.760]                     }
[13:21:53.760]                     muffleCondition(cond, pattern = "^muffle")
[13:21:53.760]                   }
[13:21:53.760]                 }
[13:21:53.760]                 else {
[13:21:53.760]                   if (TRUE) {
[13:21:53.760]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:53.760]                     {
[13:21:53.760]                       inherits <- base::inherits
[13:21:53.760]                       invokeRestart <- base::invokeRestart
[13:21:53.760]                       is.null <- base::is.null
[13:21:53.760]                       muffled <- FALSE
[13:21:53.760]                       if (inherits(cond, "message")) {
[13:21:53.760]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:53.760]                         if (muffled) 
[13:21:53.760]                           invokeRestart("muffleMessage")
[13:21:53.760]                       }
[13:21:53.760]                       else if (inherits(cond, "warning")) {
[13:21:53.760]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:53.760]                         if (muffled) 
[13:21:53.760]                           invokeRestart("muffleWarning")
[13:21:53.760]                       }
[13:21:53.760]                       else if (inherits(cond, "condition")) {
[13:21:53.760]                         if (!is.null(pattern)) {
[13:21:53.760]                           computeRestarts <- base::computeRestarts
[13:21:53.760]                           grepl <- base::grepl
[13:21:53.760]                           restarts <- computeRestarts(cond)
[13:21:53.760]                           for (restart in restarts) {
[13:21:53.760]                             name <- restart$name
[13:21:53.760]                             if (is.null(name)) 
[13:21:53.760]                               next
[13:21:53.760]                             if (!grepl(pattern, name)) 
[13:21:53.760]                               next
[13:21:53.760]                             invokeRestart(restart)
[13:21:53.760]                             muffled <- TRUE
[13:21:53.760]                             break
[13:21:53.760]                           }
[13:21:53.760]                         }
[13:21:53.760]                       }
[13:21:53.760]                       invisible(muffled)
[13:21:53.760]                     }
[13:21:53.760]                     muffleCondition(cond, pattern = "^muffle")
[13:21:53.760]                   }
[13:21:53.760]                 }
[13:21:53.760]             }
[13:21:53.760]         }))
[13:21:53.760]     }, error = function(ex) {
[13:21:53.760]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:53.760]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:53.760]                 ...future.rng), started = ...future.startTime, 
[13:21:53.760]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:53.760]             version = "1.8"), class = "FutureResult")
[13:21:53.760]     }, finally = {
[13:21:53.760]         if (!identical(...future.workdir, getwd())) 
[13:21:53.760]             setwd(...future.workdir)
[13:21:53.760]         {
[13:21:53.760]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:53.760]                 ...future.oldOptions$nwarnings <- NULL
[13:21:53.760]             }
[13:21:53.760]             base::options(...future.oldOptions)
[13:21:53.760]             if (.Platform$OS.type == "windows") {
[13:21:53.760]                 old_names <- names(...future.oldEnvVars)
[13:21:53.760]                 envs <- base::Sys.getenv()
[13:21:53.760]                 names <- names(envs)
[13:21:53.760]                 common <- intersect(names, old_names)
[13:21:53.760]                 added <- setdiff(names, old_names)
[13:21:53.760]                 removed <- setdiff(old_names, names)
[13:21:53.760]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:53.760]                   envs[common]]
[13:21:53.760]                 NAMES <- toupper(changed)
[13:21:53.760]                 args <- list()
[13:21:53.760]                 for (kk in seq_along(NAMES)) {
[13:21:53.760]                   name <- changed[[kk]]
[13:21:53.760]                   NAME <- NAMES[[kk]]
[13:21:53.760]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:53.760]                     next
[13:21:53.760]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:53.760]                 }
[13:21:53.760]                 NAMES <- toupper(added)
[13:21:53.760]                 for (kk in seq_along(NAMES)) {
[13:21:53.760]                   name <- added[[kk]]
[13:21:53.760]                   NAME <- NAMES[[kk]]
[13:21:53.760]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:53.760]                     next
[13:21:53.760]                   args[[name]] <- ""
[13:21:53.760]                 }
[13:21:53.760]                 NAMES <- toupper(removed)
[13:21:53.760]                 for (kk in seq_along(NAMES)) {
[13:21:53.760]                   name <- removed[[kk]]
[13:21:53.760]                   NAME <- NAMES[[kk]]
[13:21:53.760]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:53.760]                     next
[13:21:53.760]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:53.760]                 }
[13:21:53.760]                 if (length(args) > 0) 
[13:21:53.760]                   base::do.call(base::Sys.setenv, args = args)
[13:21:53.760]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:53.760]             }
[13:21:53.760]             else {
[13:21:53.760]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:53.760]             }
[13:21:53.760]             {
[13:21:53.760]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:53.760]                   0L) {
[13:21:53.760]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:53.760]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:53.760]                   base::options(opts)
[13:21:53.760]                 }
[13:21:53.760]                 {
[13:21:53.760]                   {
[13:21:53.760]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:53.760]                     NULL
[13:21:53.760]                   }
[13:21:53.760]                   options(future.plan = NULL)
[13:21:53.760]                   if (is.na(NA_character_)) 
[13:21:53.760]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:53.760]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:53.760]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:53.760]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:53.760]                     envir = parent.frame()) 
[13:21:53.760]                   {
[13:21:53.760]                     if (is.function(workers)) 
[13:21:53.760]                       workers <- workers()
[13:21:53.760]                     workers <- structure(as.integer(workers), 
[13:21:53.760]                       class = class(workers))
[13:21:53.760]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:53.760]                       workers >= 1)
[13:21:53.760]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:53.760]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:53.760]                     }
[13:21:53.760]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:53.760]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:53.760]                       envir = envir)
[13:21:53.760]                     if (!future$lazy) 
[13:21:53.760]                       future <- run(future)
[13:21:53.760]                     invisible(future)
[13:21:53.760]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:53.760]                 }
[13:21:53.760]             }
[13:21:53.760]         }
[13:21:53.760]     })
[13:21:53.760]     if (TRUE) {
[13:21:53.760]         base::sink(type = "output", split = FALSE)
[13:21:53.760]         if (TRUE) {
[13:21:53.760]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:53.760]         }
[13:21:53.760]         else {
[13:21:53.760]             ...future.result["stdout"] <- base::list(NULL)
[13:21:53.760]         }
[13:21:53.760]         base::close(...future.stdout)
[13:21:53.760]         ...future.stdout <- NULL
[13:21:53.760]     }
[13:21:53.760]     ...future.result$conditions <- ...future.conditions
[13:21:53.760]     ...future.result$finished <- base::Sys.time()
[13:21:53.760]     ...future.result
[13:21:53.760] }
[13:21:53.763] MultisessionFuture started
[13:21:53.763] - Launch lazy future ... done
[13:21:53.763] run() for ‘MultisessionFuture’ ... done
[13:21:53.810] receiveMessageFromWorker() for ClusterFuture ...
[13:21:53.810] - Validating connection of MultisessionFuture
[13:21:53.810] - received message: FutureResult
[13:21:53.811] - Received FutureResult
[13:21:53.811] - Erased future from FutureRegistry
[13:21:53.811] result() for ClusterFuture ...
[13:21:53.811] - result already collected: FutureResult
[13:21:53.811] result() for ClusterFuture ... done
[13:21:53.811] signalConditions() ...
[13:21:53.811]  - include = ‘immediateCondition’
[13:21:53.811]  - exclude = 
[13:21:53.811]  - resignal = FALSE
[13:21:53.811]  - Number of conditions: 1
[13:21:53.812] signalConditions() ... done
[13:21:53.812] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:53.812] A MultisessionFuture was resolved
- result = TRUE, recursive = TRUE ... DONE
- result = TRUE, recursive = -1 ...
[13:21:53.812] getGlobalsAndPackages() ...
[13:21:53.812] Searching for globals...
[13:21:53.813] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:21:53.813] Searching for globals ... DONE
[13:21:53.813] Resolving globals: FALSE
[13:21:53.814] 
[13:21:53.814] 
[13:21:53.814] getGlobalsAndPackages() ... DONE
[13:21:53.814] run() for ‘Future’ ...
[13:21:53.814] - state: ‘created’
[13:21:53.814] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:53.829] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:53.829] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:53.829]   - Field: ‘node’
[13:21:53.829]   - Field: ‘label’
[13:21:53.829]   - Field: ‘local’
[13:21:53.829]   - Field: ‘owner’
[13:21:53.829]   - Field: ‘envir’
[13:21:53.829]   - Field: ‘workers’
[13:21:53.829]   - Field: ‘packages’
[13:21:53.830]   - Field: ‘gc’
[13:21:53.830]   - Field: ‘conditions’
[13:21:53.830]   - Field: ‘persistent’
[13:21:53.830]   - Field: ‘expr’
[13:21:53.830]   - Field: ‘uuid’
[13:21:53.830]   - Field: ‘seed’
[13:21:53.830]   - Field: ‘version’
[13:21:53.830]   - Field: ‘result’
[13:21:53.830]   - Field: ‘asynchronous’
[13:21:53.830]   - Field: ‘calls’
[13:21:53.830]   - Field: ‘globals’
[13:21:53.830]   - Field: ‘stdout’
[13:21:53.831]   - Field: ‘earlySignal’
[13:21:53.831]   - Field: ‘lazy’
[13:21:53.831]   - Field: ‘state’
[13:21:53.831] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:53.831] - Launch lazy future ...
[13:21:53.831] Packages needed by the future expression (n = 0): <none>
[13:21:53.831] Packages needed by future strategies (n = 0): <none>
[13:21:53.832] {
[13:21:53.832]     {
[13:21:53.832]         {
[13:21:53.832]             ...future.startTime <- base::Sys.time()
[13:21:53.832]             {
[13:21:53.832]                 {
[13:21:53.832]                   {
[13:21:53.832]                     {
[13:21:53.832]                       base::local({
[13:21:53.832]                         has_future <- base::requireNamespace("future", 
[13:21:53.832]                           quietly = TRUE)
[13:21:53.832]                         if (has_future) {
[13:21:53.832]                           ns <- base::getNamespace("future")
[13:21:53.832]                           version <- ns[[".package"]][["version"]]
[13:21:53.832]                           if (is.null(version)) 
[13:21:53.832]                             version <- utils::packageVersion("future")
[13:21:53.832]                         }
[13:21:53.832]                         else {
[13:21:53.832]                           version <- NULL
[13:21:53.832]                         }
[13:21:53.832]                         if (!has_future || version < "1.8.0") {
[13:21:53.832]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:53.832]                             "", base::R.version$version.string), 
[13:21:53.832]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:53.832]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:53.832]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:53.832]                               "release", "version")], collapse = " "), 
[13:21:53.832]                             hostname = base::Sys.info()[["nodename"]])
[13:21:53.832]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:53.832]                             info)
[13:21:53.832]                           info <- base::paste(info, collapse = "; ")
[13:21:53.832]                           if (!has_future) {
[13:21:53.832]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:53.832]                               info)
[13:21:53.832]                           }
[13:21:53.832]                           else {
[13:21:53.832]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:53.832]                               info, version)
[13:21:53.832]                           }
[13:21:53.832]                           base::stop(msg)
[13:21:53.832]                         }
[13:21:53.832]                       })
[13:21:53.832]                     }
[13:21:53.832]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:53.832]                     base::options(mc.cores = 1L)
[13:21:53.832]                   }
[13:21:53.832]                   options(future.plan = NULL)
[13:21:53.832]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:53.832]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:53.832]                 }
[13:21:53.832]                 ...future.workdir <- getwd()
[13:21:53.832]             }
[13:21:53.832]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:53.832]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:53.832]         }
[13:21:53.832]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:53.832]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:53.832]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:53.832]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:53.832]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:53.832]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:53.832]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:53.832]             base::names(...future.oldOptions))
[13:21:53.832]     }
[13:21:53.832]     if (FALSE) {
[13:21:53.832]     }
[13:21:53.832]     else {
[13:21:53.832]         if (TRUE) {
[13:21:53.832]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:53.832]                 open = "w")
[13:21:53.832]         }
[13:21:53.832]         else {
[13:21:53.832]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:53.832]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:53.832]         }
[13:21:53.832]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:53.832]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:53.832]             base::sink(type = "output", split = FALSE)
[13:21:53.832]             base::close(...future.stdout)
[13:21:53.832]         }, add = TRUE)
[13:21:53.832]     }
[13:21:53.832]     ...future.frame <- base::sys.nframe()
[13:21:53.832]     ...future.conditions <- base::list()
[13:21:53.832]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:53.832]     if (FALSE) {
[13:21:53.832]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:53.832]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:53.832]     }
[13:21:53.832]     ...future.result <- base::tryCatch({
[13:21:53.832]         base::withCallingHandlers({
[13:21:53.832]             ...future.value <- base::withVisible(base::local({
[13:21:53.832]                 ...future.makeSendCondition <- local({
[13:21:53.832]                   sendCondition <- NULL
[13:21:53.832]                   function(frame = 1L) {
[13:21:53.832]                     if (is.function(sendCondition)) 
[13:21:53.832]                       return(sendCondition)
[13:21:53.832]                     ns <- getNamespace("parallel")
[13:21:53.832]                     if (exists("sendData", mode = "function", 
[13:21:53.832]                       envir = ns)) {
[13:21:53.832]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:53.832]                         envir = ns)
[13:21:53.832]                       envir <- sys.frame(frame)
[13:21:53.832]                       master <- NULL
[13:21:53.832]                       while (!identical(envir, .GlobalEnv) && 
[13:21:53.832]                         !identical(envir, emptyenv())) {
[13:21:53.832]                         if (exists("master", mode = "list", envir = envir, 
[13:21:53.832]                           inherits = FALSE)) {
[13:21:53.832]                           master <- get("master", mode = "list", 
[13:21:53.832]                             envir = envir, inherits = FALSE)
[13:21:53.832]                           if (inherits(master, c("SOCKnode", 
[13:21:53.832]                             "SOCK0node"))) {
[13:21:53.832]                             sendCondition <<- function(cond) {
[13:21:53.832]                               data <- list(type = "VALUE", value = cond, 
[13:21:53.832]                                 success = TRUE)
[13:21:53.832]                               parallel_sendData(master, data)
[13:21:53.832]                             }
[13:21:53.832]                             return(sendCondition)
[13:21:53.832]                           }
[13:21:53.832]                         }
[13:21:53.832]                         frame <- frame + 1L
[13:21:53.832]                         envir <- sys.frame(frame)
[13:21:53.832]                       }
[13:21:53.832]                     }
[13:21:53.832]                     sendCondition <<- function(cond) NULL
[13:21:53.832]                   }
[13:21:53.832]                 })
[13:21:53.832]                 withCallingHandlers({
[13:21:53.832]                   {
[13:21:53.832]                     Sys.sleep(0.5)
[13:21:53.832]                     list(a = 1, b = 42L)
[13:21:53.832]                   }
[13:21:53.832]                 }, immediateCondition = function(cond) {
[13:21:53.832]                   sendCondition <- ...future.makeSendCondition()
[13:21:53.832]                   sendCondition(cond)
[13:21:53.832]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:53.832]                   {
[13:21:53.832]                     inherits <- base::inherits
[13:21:53.832]                     invokeRestart <- base::invokeRestart
[13:21:53.832]                     is.null <- base::is.null
[13:21:53.832]                     muffled <- FALSE
[13:21:53.832]                     if (inherits(cond, "message")) {
[13:21:53.832]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:53.832]                       if (muffled) 
[13:21:53.832]                         invokeRestart("muffleMessage")
[13:21:53.832]                     }
[13:21:53.832]                     else if (inherits(cond, "warning")) {
[13:21:53.832]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:53.832]                       if (muffled) 
[13:21:53.832]                         invokeRestart("muffleWarning")
[13:21:53.832]                     }
[13:21:53.832]                     else if (inherits(cond, "condition")) {
[13:21:53.832]                       if (!is.null(pattern)) {
[13:21:53.832]                         computeRestarts <- base::computeRestarts
[13:21:53.832]                         grepl <- base::grepl
[13:21:53.832]                         restarts <- computeRestarts(cond)
[13:21:53.832]                         for (restart in restarts) {
[13:21:53.832]                           name <- restart$name
[13:21:53.832]                           if (is.null(name)) 
[13:21:53.832]                             next
[13:21:53.832]                           if (!grepl(pattern, name)) 
[13:21:53.832]                             next
[13:21:53.832]                           invokeRestart(restart)
[13:21:53.832]                           muffled <- TRUE
[13:21:53.832]                           break
[13:21:53.832]                         }
[13:21:53.832]                       }
[13:21:53.832]                     }
[13:21:53.832]                     invisible(muffled)
[13:21:53.832]                   }
[13:21:53.832]                   muffleCondition(cond)
[13:21:53.832]                 })
[13:21:53.832]             }))
[13:21:53.832]             future::FutureResult(value = ...future.value$value, 
[13:21:53.832]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:53.832]                   ...future.rng), globalenv = if (FALSE) 
[13:21:53.832]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:53.832]                     ...future.globalenv.names))
[13:21:53.832]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:53.832]         }, condition = base::local({
[13:21:53.832]             c <- base::c
[13:21:53.832]             inherits <- base::inherits
[13:21:53.832]             invokeRestart <- base::invokeRestart
[13:21:53.832]             length <- base::length
[13:21:53.832]             list <- base::list
[13:21:53.832]             seq.int <- base::seq.int
[13:21:53.832]             signalCondition <- base::signalCondition
[13:21:53.832]             sys.calls <- base::sys.calls
[13:21:53.832]             `[[` <- base::`[[`
[13:21:53.832]             `+` <- base::`+`
[13:21:53.832]             `<<-` <- base::`<<-`
[13:21:53.832]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:53.832]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:53.832]                   3L)]
[13:21:53.832]             }
[13:21:53.832]             function(cond) {
[13:21:53.832]                 is_error <- inherits(cond, "error")
[13:21:53.832]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:53.832]                   NULL)
[13:21:53.832]                 if (is_error) {
[13:21:53.832]                   sessionInformation <- function() {
[13:21:53.832]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:53.832]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:53.832]                       search = base::search(), system = base::Sys.info())
[13:21:53.832]                   }
[13:21:53.832]                   ...future.conditions[[length(...future.conditions) + 
[13:21:53.832]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:53.832]                     cond$call), session = sessionInformation(), 
[13:21:53.832]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:53.832]                   signalCondition(cond)
[13:21:53.832]                 }
[13:21:53.832]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:53.832]                 "immediateCondition"))) {
[13:21:53.832]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:53.832]                   ...future.conditions[[length(...future.conditions) + 
[13:21:53.832]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:53.832]                   if (TRUE && !signal) {
[13:21:53.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:53.832]                     {
[13:21:53.832]                       inherits <- base::inherits
[13:21:53.832]                       invokeRestart <- base::invokeRestart
[13:21:53.832]                       is.null <- base::is.null
[13:21:53.832]                       muffled <- FALSE
[13:21:53.832]                       if (inherits(cond, "message")) {
[13:21:53.832]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:53.832]                         if (muffled) 
[13:21:53.832]                           invokeRestart("muffleMessage")
[13:21:53.832]                       }
[13:21:53.832]                       else if (inherits(cond, "warning")) {
[13:21:53.832]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:53.832]                         if (muffled) 
[13:21:53.832]                           invokeRestart("muffleWarning")
[13:21:53.832]                       }
[13:21:53.832]                       else if (inherits(cond, "condition")) {
[13:21:53.832]                         if (!is.null(pattern)) {
[13:21:53.832]                           computeRestarts <- base::computeRestarts
[13:21:53.832]                           grepl <- base::grepl
[13:21:53.832]                           restarts <- computeRestarts(cond)
[13:21:53.832]                           for (restart in restarts) {
[13:21:53.832]                             name <- restart$name
[13:21:53.832]                             if (is.null(name)) 
[13:21:53.832]                               next
[13:21:53.832]                             if (!grepl(pattern, name)) 
[13:21:53.832]                               next
[13:21:53.832]                             invokeRestart(restart)
[13:21:53.832]                             muffled <- TRUE
[13:21:53.832]                             break
[13:21:53.832]                           }
[13:21:53.832]                         }
[13:21:53.832]                       }
[13:21:53.832]                       invisible(muffled)
[13:21:53.832]                     }
[13:21:53.832]                     muffleCondition(cond, pattern = "^muffle")
[13:21:53.832]                   }
[13:21:53.832]                 }
[13:21:53.832]                 else {
[13:21:53.832]                   if (TRUE) {
[13:21:53.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:53.832]                     {
[13:21:53.832]                       inherits <- base::inherits
[13:21:53.832]                       invokeRestart <- base::invokeRestart
[13:21:53.832]                       is.null <- base::is.null
[13:21:53.832]                       muffled <- FALSE
[13:21:53.832]                       if (inherits(cond, "message")) {
[13:21:53.832]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:53.832]                         if (muffled) 
[13:21:53.832]                           invokeRestart("muffleMessage")
[13:21:53.832]                       }
[13:21:53.832]                       else if (inherits(cond, "warning")) {
[13:21:53.832]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:53.832]                         if (muffled) 
[13:21:53.832]                           invokeRestart("muffleWarning")
[13:21:53.832]                       }
[13:21:53.832]                       else if (inherits(cond, "condition")) {
[13:21:53.832]                         if (!is.null(pattern)) {
[13:21:53.832]                           computeRestarts <- base::computeRestarts
[13:21:53.832]                           grepl <- base::grepl
[13:21:53.832]                           restarts <- computeRestarts(cond)
[13:21:53.832]                           for (restart in restarts) {
[13:21:53.832]                             name <- restart$name
[13:21:53.832]                             if (is.null(name)) 
[13:21:53.832]                               next
[13:21:53.832]                             if (!grepl(pattern, name)) 
[13:21:53.832]                               next
[13:21:53.832]                             invokeRestart(restart)
[13:21:53.832]                             muffled <- TRUE
[13:21:53.832]                             break
[13:21:53.832]                           }
[13:21:53.832]                         }
[13:21:53.832]                       }
[13:21:53.832]                       invisible(muffled)
[13:21:53.832]                     }
[13:21:53.832]                     muffleCondition(cond, pattern = "^muffle")
[13:21:53.832]                   }
[13:21:53.832]                 }
[13:21:53.832]             }
[13:21:53.832]         }))
[13:21:53.832]     }, error = function(ex) {
[13:21:53.832]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:53.832]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:53.832]                 ...future.rng), started = ...future.startTime, 
[13:21:53.832]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:53.832]             version = "1.8"), class = "FutureResult")
[13:21:53.832]     }, finally = {
[13:21:53.832]         if (!identical(...future.workdir, getwd())) 
[13:21:53.832]             setwd(...future.workdir)
[13:21:53.832]         {
[13:21:53.832]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:53.832]                 ...future.oldOptions$nwarnings <- NULL
[13:21:53.832]             }
[13:21:53.832]             base::options(...future.oldOptions)
[13:21:53.832]             if (.Platform$OS.type == "windows") {
[13:21:53.832]                 old_names <- names(...future.oldEnvVars)
[13:21:53.832]                 envs <- base::Sys.getenv()
[13:21:53.832]                 names <- names(envs)
[13:21:53.832]                 common <- intersect(names, old_names)
[13:21:53.832]                 added <- setdiff(names, old_names)
[13:21:53.832]                 removed <- setdiff(old_names, names)
[13:21:53.832]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:53.832]                   envs[common]]
[13:21:53.832]                 NAMES <- toupper(changed)
[13:21:53.832]                 args <- list()
[13:21:53.832]                 for (kk in seq_along(NAMES)) {
[13:21:53.832]                   name <- changed[[kk]]
[13:21:53.832]                   NAME <- NAMES[[kk]]
[13:21:53.832]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:53.832]                     next
[13:21:53.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:53.832]                 }
[13:21:53.832]                 NAMES <- toupper(added)
[13:21:53.832]                 for (kk in seq_along(NAMES)) {
[13:21:53.832]                   name <- added[[kk]]
[13:21:53.832]                   NAME <- NAMES[[kk]]
[13:21:53.832]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:53.832]                     next
[13:21:53.832]                   args[[name]] <- ""
[13:21:53.832]                 }
[13:21:53.832]                 NAMES <- toupper(removed)
[13:21:53.832]                 for (kk in seq_along(NAMES)) {
[13:21:53.832]                   name <- removed[[kk]]
[13:21:53.832]                   NAME <- NAMES[[kk]]
[13:21:53.832]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:53.832]                     next
[13:21:53.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:53.832]                 }
[13:21:53.832]                 if (length(args) > 0) 
[13:21:53.832]                   base::do.call(base::Sys.setenv, args = args)
[13:21:53.832]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:53.832]             }
[13:21:53.832]             else {
[13:21:53.832]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:53.832]             }
[13:21:53.832]             {
[13:21:53.832]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:53.832]                   0L) {
[13:21:53.832]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:53.832]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:53.832]                   base::options(opts)
[13:21:53.832]                 }
[13:21:53.832]                 {
[13:21:53.832]                   {
[13:21:53.832]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:53.832]                     NULL
[13:21:53.832]                   }
[13:21:53.832]                   options(future.plan = NULL)
[13:21:53.832]                   if (is.na(NA_character_)) 
[13:21:53.832]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:53.832]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:53.832]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:53.832]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:53.832]                     envir = parent.frame()) 
[13:21:53.832]                   {
[13:21:53.832]                     if (is.function(workers)) 
[13:21:53.832]                       workers <- workers()
[13:21:53.832]                     workers <- structure(as.integer(workers), 
[13:21:53.832]                       class = class(workers))
[13:21:53.832]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:53.832]                       workers >= 1)
[13:21:53.832]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:53.832]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:53.832]                     }
[13:21:53.832]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:53.832]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:53.832]                       envir = envir)
[13:21:53.832]                     if (!future$lazy) 
[13:21:53.832]                       future <- run(future)
[13:21:53.832]                     invisible(future)
[13:21:53.832]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:53.832]                 }
[13:21:53.832]             }
[13:21:53.832]         }
[13:21:53.832]     })
[13:21:53.832]     if (TRUE) {
[13:21:53.832]         base::sink(type = "output", split = FALSE)
[13:21:53.832]         if (TRUE) {
[13:21:53.832]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:53.832]         }
[13:21:53.832]         else {
[13:21:53.832]             ...future.result["stdout"] <- base::list(NULL)
[13:21:53.832]         }
[13:21:53.832]         base::close(...future.stdout)
[13:21:53.832]         ...future.stdout <- NULL
[13:21:53.832]     }
[13:21:53.832]     ...future.result$conditions <- ...future.conditions
[13:21:53.832]     ...future.result$finished <- base::Sys.time()
[13:21:53.832]     ...future.result
[13:21:53.832] }
[13:21:53.835] MultisessionFuture started
[13:21:53.835] - Launch lazy future ... done
[13:21:53.835] run() for ‘MultisessionFuture’ ... done
[13:21:53.835] getGlobalsAndPackages() ...
[13:21:53.835] Searching for globals...
[13:21:53.836] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:21:53.836] Searching for globals ... DONE
[13:21:53.837] Resolving globals: FALSE
[13:21:53.837] 
[13:21:53.837] 
[13:21:53.837] getGlobalsAndPackages() ... DONE
- w/ exception ...
[13:21:53.837] getGlobalsAndPackages() ...
[13:21:53.837] Searching for globals...
[13:21:53.838] - globals found: [2] ‘list’, ‘stop’
[13:21:53.838] Searching for globals ... DONE
[13:21:53.838] Resolving globals: FALSE
[13:21:53.839] 
[13:21:53.839] 
[13:21:53.839] getGlobalsAndPackages() ... DONE
[13:21:53.839] run() for ‘Future’ ...
[13:21:53.839] - state: ‘created’
[13:21:53.839] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:53.853] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:53.853] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:53.854]   - Field: ‘node’
[13:21:53.854]   - Field: ‘label’
[13:21:53.854]   - Field: ‘local’
[13:21:53.854]   - Field: ‘owner’
[13:21:53.854]   - Field: ‘envir’
[13:21:53.854]   - Field: ‘workers’
[13:21:53.854]   - Field: ‘packages’
[13:21:53.854]   - Field: ‘gc’
[13:21:53.854]   - Field: ‘conditions’
[13:21:53.854]   - Field: ‘persistent’
[13:21:53.854]   - Field: ‘expr’
[13:21:53.855]   - Field: ‘uuid’
[13:21:53.855]   - Field: ‘seed’
[13:21:53.855]   - Field: ‘version’
[13:21:53.855]   - Field: ‘result’
[13:21:53.855]   - Field: ‘asynchronous’
[13:21:53.855]   - Field: ‘calls’
[13:21:53.855]   - Field: ‘globals’
[13:21:53.855]   - Field: ‘stdout’
[13:21:53.855]   - Field: ‘earlySignal’
[13:21:53.855]   - Field: ‘lazy’
[13:21:53.855]   - Field: ‘state’
[13:21:53.856] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:53.856] - Launch lazy future ...
[13:21:53.856] Packages needed by the future expression (n = 0): <none>
[13:21:53.856] Packages needed by future strategies (n = 0): <none>
[13:21:53.856] {
[13:21:53.856]     {
[13:21:53.856]         {
[13:21:53.856]             ...future.startTime <- base::Sys.time()
[13:21:53.856]             {
[13:21:53.856]                 {
[13:21:53.856]                   {
[13:21:53.856]                     {
[13:21:53.856]                       base::local({
[13:21:53.856]                         has_future <- base::requireNamespace("future", 
[13:21:53.856]                           quietly = TRUE)
[13:21:53.856]                         if (has_future) {
[13:21:53.856]                           ns <- base::getNamespace("future")
[13:21:53.856]                           version <- ns[[".package"]][["version"]]
[13:21:53.856]                           if (is.null(version)) 
[13:21:53.856]                             version <- utils::packageVersion("future")
[13:21:53.856]                         }
[13:21:53.856]                         else {
[13:21:53.856]                           version <- NULL
[13:21:53.856]                         }
[13:21:53.856]                         if (!has_future || version < "1.8.0") {
[13:21:53.856]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:53.856]                             "", base::R.version$version.string), 
[13:21:53.856]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:53.856]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:53.856]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:53.856]                               "release", "version")], collapse = " "), 
[13:21:53.856]                             hostname = base::Sys.info()[["nodename"]])
[13:21:53.856]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:53.856]                             info)
[13:21:53.856]                           info <- base::paste(info, collapse = "; ")
[13:21:53.856]                           if (!has_future) {
[13:21:53.856]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:53.856]                               info)
[13:21:53.856]                           }
[13:21:53.856]                           else {
[13:21:53.856]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:53.856]                               info, version)
[13:21:53.856]                           }
[13:21:53.856]                           base::stop(msg)
[13:21:53.856]                         }
[13:21:53.856]                       })
[13:21:53.856]                     }
[13:21:53.856]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:53.856]                     base::options(mc.cores = 1L)
[13:21:53.856]                   }
[13:21:53.856]                   options(future.plan = NULL)
[13:21:53.856]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:53.856]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:53.856]                 }
[13:21:53.856]                 ...future.workdir <- getwd()
[13:21:53.856]             }
[13:21:53.856]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:53.856]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:53.856]         }
[13:21:53.856]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:53.856]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:53.856]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:53.856]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:53.856]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:53.856]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:53.856]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:53.856]             base::names(...future.oldOptions))
[13:21:53.856]     }
[13:21:53.856]     if (FALSE) {
[13:21:53.856]     }
[13:21:53.856]     else {
[13:21:53.856]         if (TRUE) {
[13:21:53.856]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:53.856]                 open = "w")
[13:21:53.856]         }
[13:21:53.856]         else {
[13:21:53.856]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:53.856]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:53.856]         }
[13:21:53.856]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:53.856]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:53.856]             base::sink(type = "output", split = FALSE)
[13:21:53.856]             base::close(...future.stdout)
[13:21:53.856]         }, add = TRUE)
[13:21:53.856]     }
[13:21:53.856]     ...future.frame <- base::sys.nframe()
[13:21:53.856]     ...future.conditions <- base::list()
[13:21:53.856]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:53.856]     if (FALSE) {
[13:21:53.856]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:53.856]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:53.856]     }
[13:21:53.856]     ...future.result <- base::tryCatch({
[13:21:53.856]         base::withCallingHandlers({
[13:21:53.856]             ...future.value <- base::withVisible(base::local({
[13:21:53.856]                 ...future.makeSendCondition <- local({
[13:21:53.856]                   sendCondition <- NULL
[13:21:53.856]                   function(frame = 1L) {
[13:21:53.856]                     if (is.function(sendCondition)) 
[13:21:53.856]                       return(sendCondition)
[13:21:53.856]                     ns <- getNamespace("parallel")
[13:21:53.856]                     if (exists("sendData", mode = "function", 
[13:21:53.856]                       envir = ns)) {
[13:21:53.856]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:53.856]                         envir = ns)
[13:21:53.856]                       envir <- sys.frame(frame)
[13:21:53.856]                       master <- NULL
[13:21:53.856]                       while (!identical(envir, .GlobalEnv) && 
[13:21:53.856]                         !identical(envir, emptyenv())) {
[13:21:53.856]                         if (exists("master", mode = "list", envir = envir, 
[13:21:53.856]                           inherits = FALSE)) {
[13:21:53.856]                           master <- get("master", mode = "list", 
[13:21:53.856]                             envir = envir, inherits = FALSE)
[13:21:53.856]                           if (inherits(master, c("SOCKnode", 
[13:21:53.856]                             "SOCK0node"))) {
[13:21:53.856]                             sendCondition <<- function(cond) {
[13:21:53.856]                               data <- list(type = "VALUE", value = cond, 
[13:21:53.856]                                 success = TRUE)
[13:21:53.856]                               parallel_sendData(master, data)
[13:21:53.856]                             }
[13:21:53.856]                             return(sendCondition)
[13:21:53.856]                           }
[13:21:53.856]                         }
[13:21:53.856]                         frame <- frame + 1L
[13:21:53.856]                         envir <- sys.frame(frame)
[13:21:53.856]                       }
[13:21:53.856]                     }
[13:21:53.856]                     sendCondition <<- function(cond) NULL
[13:21:53.856]                   }
[13:21:53.856]                 })
[13:21:53.856]                 withCallingHandlers({
[13:21:53.856]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:21:53.856]                 }, immediateCondition = function(cond) {
[13:21:53.856]                   sendCondition <- ...future.makeSendCondition()
[13:21:53.856]                   sendCondition(cond)
[13:21:53.856]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:53.856]                   {
[13:21:53.856]                     inherits <- base::inherits
[13:21:53.856]                     invokeRestart <- base::invokeRestart
[13:21:53.856]                     is.null <- base::is.null
[13:21:53.856]                     muffled <- FALSE
[13:21:53.856]                     if (inherits(cond, "message")) {
[13:21:53.856]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:53.856]                       if (muffled) 
[13:21:53.856]                         invokeRestart("muffleMessage")
[13:21:53.856]                     }
[13:21:53.856]                     else if (inherits(cond, "warning")) {
[13:21:53.856]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:53.856]                       if (muffled) 
[13:21:53.856]                         invokeRestart("muffleWarning")
[13:21:53.856]                     }
[13:21:53.856]                     else if (inherits(cond, "condition")) {
[13:21:53.856]                       if (!is.null(pattern)) {
[13:21:53.856]                         computeRestarts <- base::computeRestarts
[13:21:53.856]                         grepl <- base::grepl
[13:21:53.856]                         restarts <- computeRestarts(cond)
[13:21:53.856]                         for (restart in restarts) {
[13:21:53.856]                           name <- restart$name
[13:21:53.856]                           if (is.null(name)) 
[13:21:53.856]                             next
[13:21:53.856]                           if (!grepl(pattern, name)) 
[13:21:53.856]                             next
[13:21:53.856]                           invokeRestart(restart)
[13:21:53.856]                           muffled <- TRUE
[13:21:53.856]                           break
[13:21:53.856]                         }
[13:21:53.856]                       }
[13:21:53.856]                     }
[13:21:53.856]                     invisible(muffled)
[13:21:53.856]                   }
[13:21:53.856]                   muffleCondition(cond)
[13:21:53.856]                 })
[13:21:53.856]             }))
[13:21:53.856]             future::FutureResult(value = ...future.value$value, 
[13:21:53.856]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:53.856]                   ...future.rng), globalenv = if (FALSE) 
[13:21:53.856]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:53.856]                     ...future.globalenv.names))
[13:21:53.856]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:53.856]         }, condition = base::local({
[13:21:53.856]             c <- base::c
[13:21:53.856]             inherits <- base::inherits
[13:21:53.856]             invokeRestart <- base::invokeRestart
[13:21:53.856]             length <- base::length
[13:21:53.856]             list <- base::list
[13:21:53.856]             seq.int <- base::seq.int
[13:21:53.856]             signalCondition <- base::signalCondition
[13:21:53.856]             sys.calls <- base::sys.calls
[13:21:53.856]             `[[` <- base::`[[`
[13:21:53.856]             `+` <- base::`+`
[13:21:53.856]             `<<-` <- base::`<<-`
[13:21:53.856]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:53.856]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:53.856]                   3L)]
[13:21:53.856]             }
[13:21:53.856]             function(cond) {
[13:21:53.856]                 is_error <- inherits(cond, "error")
[13:21:53.856]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:53.856]                   NULL)
[13:21:53.856]                 if (is_error) {
[13:21:53.856]                   sessionInformation <- function() {
[13:21:53.856]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:53.856]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:53.856]                       search = base::search(), system = base::Sys.info())
[13:21:53.856]                   }
[13:21:53.856]                   ...future.conditions[[length(...future.conditions) + 
[13:21:53.856]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:53.856]                     cond$call), session = sessionInformation(), 
[13:21:53.856]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:53.856]                   signalCondition(cond)
[13:21:53.856]                 }
[13:21:53.856]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:53.856]                 "immediateCondition"))) {
[13:21:53.856]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:53.856]                   ...future.conditions[[length(...future.conditions) + 
[13:21:53.856]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:53.856]                   if (TRUE && !signal) {
[13:21:53.856]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:53.856]                     {
[13:21:53.856]                       inherits <- base::inherits
[13:21:53.856]                       invokeRestart <- base::invokeRestart
[13:21:53.856]                       is.null <- base::is.null
[13:21:53.856]                       muffled <- FALSE
[13:21:53.856]                       if (inherits(cond, "message")) {
[13:21:53.856]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:53.856]                         if (muffled) 
[13:21:53.856]                           invokeRestart("muffleMessage")
[13:21:53.856]                       }
[13:21:53.856]                       else if (inherits(cond, "warning")) {
[13:21:53.856]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:53.856]                         if (muffled) 
[13:21:53.856]                           invokeRestart("muffleWarning")
[13:21:53.856]                       }
[13:21:53.856]                       else if (inherits(cond, "condition")) {
[13:21:53.856]                         if (!is.null(pattern)) {
[13:21:53.856]                           computeRestarts <- base::computeRestarts
[13:21:53.856]                           grepl <- base::grepl
[13:21:53.856]                           restarts <- computeRestarts(cond)
[13:21:53.856]                           for (restart in restarts) {
[13:21:53.856]                             name <- restart$name
[13:21:53.856]                             if (is.null(name)) 
[13:21:53.856]                               next
[13:21:53.856]                             if (!grepl(pattern, name)) 
[13:21:53.856]                               next
[13:21:53.856]                             invokeRestart(restart)
[13:21:53.856]                             muffled <- TRUE
[13:21:53.856]                             break
[13:21:53.856]                           }
[13:21:53.856]                         }
[13:21:53.856]                       }
[13:21:53.856]                       invisible(muffled)
[13:21:53.856]                     }
[13:21:53.856]                     muffleCondition(cond, pattern = "^muffle")
[13:21:53.856]                   }
[13:21:53.856]                 }
[13:21:53.856]                 else {
[13:21:53.856]                   if (TRUE) {
[13:21:53.856]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:53.856]                     {
[13:21:53.856]                       inherits <- base::inherits
[13:21:53.856]                       invokeRestart <- base::invokeRestart
[13:21:53.856]                       is.null <- base::is.null
[13:21:53.856]                       muffled <- FALSE
[13:21:53.856]                       if (inherits(cond, "message")) {
[13:21:53.856]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:53.856]                         if (muffled) 
[13:21:53.856]                           invokeRestart("muffleMessage")
[13:21:53.856]                       }
[13:21:53.856]                       else if (inherits(cond, "warning")) {
[13:21:53.856]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:53.856]                         if (muffled) 
[13:21:53.856]                           invokeRestart("muffleWarning")
[13:21:53.856]                       }
[13:21:53.856]                       else if (inherits(cond, "condition")) {
[13:21:53.856]                         if (!is.null(pattern)) {
[13:21:53.856]                           computeRestarts <- base::computeRestarts
[13:21:53.856]                           grepl <- base::grepl
[13:21:53.856]                           restarts <- computeRestarts(cond)
[13:21:53.856]                           for (restart in restarts) {
[13:21:53.856]                             name <- restart$name
[13:21:53.856]                             if (is.null(name)) 
[13:21:53.856]                               next
[13:21:53.856]                             if (!grepl(pattern, name)) 
[13:21:53.856]                               next
[13:21:53.856]                             invokeRestart(restart)
[13:21:53.856]                             muffled <- TRUE
[13:21:53.856]                             break
[13:21:53.856]                           }
[13:21:53.856]                         }
[13:21:53.856]                       }
[13:21:53.856]                       invisible(muffled)
[13:21:53.856]                     }
[13:21:53.856]                     muffleCondition(cond, pattern = "^muffle")
[13:21:53.856]                   }
[13:21:53.856]                 }
[13:21:53.856]             }
[13:21:53.856]         }))
[13:21:53.856]     }, error = function(ex) {
[13:21:53.856]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:53.856]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:53.856]                 ...future.rng), started = ...future.startTime, 
[13:21:53.856]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:53.856]             version = "1.8"), class = "FutureResult")
[13:21:53.856]     }, finally = {
[13:21:53.856]         if (!identical(...future.workdir, getwd())) 
[13:21:53.856]             setwd(...future.workdir)
[13:21:53.856]         {
[13:21:53.856]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:53.856]                 ...future.oldOptions$nwarnings <- NULL
[13:21:53.856]             }
[13:21:53.856]             base::options(...future.oldOptions)
[13:21:53.856]             if (.Platform$OS.type == "windows") {
[13:21:53.856]                 old_names <- names(...future.oldEnvVars)
[13:21:53.856]                 envs <- base::Sys.getenv()
[13:21:53.856]                 names <- names(envs)
[13:21:53.856]                 common <- intersect(names, old_names)
[13:21:53.856]                 added <- setdiff(names, old_names)
[13:21:53.856]                 removed <- setdiff(old_names, names)
[13:21:53.856]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:53.856]                   envs[common]]
[13:21:53.856]                 NAMES <- toupper(changed)
[13:21:53.856]                 args <- list()
[13:21:53.856]                 for (kk in seq_along(NAMES)) {
[13:21:53.856]                   name <- changed[[kk]]
[13:21:53.856]                   NAME <- NAMES[[kk]]
[13:21:53.856]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:53.856]                     next
[13:21:53.856]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:53.856]                 }
[13:21:53.856]                 NAMES <- toupper(added)
[13:21:53.856]                 for (kk in seq_along(NAMES)) {
[13:21:53.856]                   name <- added[[kk]]
[13:21:53.856]                   NAME <- NAMES[[kk]]
[13:21:53.856]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:53.856]                     next
[13:21:53.856]                   args[[name]] <- ""
[13:21:53.856]                 }
[13:21:53.856]                 NAMES <- toupper(removed)
[13:21:53.856]                 for (kk in seq_along(NAMES)) {
[13:21:53.856]                   name <- removed[[kk]]
[13:21:53.856]                   NAME <- NAMES[[kk]]
[13:21:53.856]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:53.856]                     next
[13:21:53.856]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:53.856]                 }
[13:21:53.856]                 if (length(args) > 0) 
[13:21:53.856]                   base::do.call(base::Sys.setenv, args = args)
[13:21:53.856]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:53.856]             }
[13:21:53.856]             else {
[13:21:53.856]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:53.856]             }
[13:21:53.856]             {
[13:21:53.856]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:53.856]                   0L) {
[13:21:53.856]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:53.856]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:53.856]                   base::options(opts)
[13:21:53.856]                 }
[13:21:53.856]                 {
[13:21:53.856]                   {
[13:21:53.856]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:53.856]                     NULL
[13:21:53.856]                   }
[13:21:53.856]                   options(future.plan = NULL)
[13:21:53.856]                   if (is.na(NA_character_)) 
[13:21:53.856]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:53.856]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:53.856]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:53.856]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:53.856]                     envir = parent.frame()) 
[13:21:53.856]                   {
[13:21:53.856]                     if (is.function(workers)) 
[13:21:53.856]                       workers <- workers()
[13:21:53.856]                     workers <- structure(as.integer(workers), 
[13:21:53.856]                       class = class(workers))
[13:21:53.856]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:53.856]                       workers >= 1)
[13:21:53.856]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:53.856]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:53.856]                     }
[13:21:53.856]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:53.856]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:53.856]                       envir = envir)
[13:21:53.856]                     if (!future$lazy) 
[13:21:53.856]                       future <- run(future)
[13:21:53.856]                     invisible(future)
[13:21:53.856]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:53.856]                 }
[13:21:53.856]             }
[13:21:53.856]         }
[13:21:53.856]     })
[13:21:53.856]     if (TRUE) {
[13:21:53.856]         base::sink(type = "output", split = FALSE)
[13:21:53.856]         if (TRUE) {
[13:21:53.856]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:53.856]         }
[13:21:53.856]         else {
[13:21:53.856]             ...future.result["stdout"] <- base::list(NULL)
[13:21:53.856]         }
[13:21:53.856]         base::close(...future.stdout)
[13:21:53.856]         ...future.stdout <- NULL
[13:21:53.856]     }
[13:21:53.856]     ...future.result$conditions <- ...future.conditions
[13:21:53.856]     ...future.result$finished <- base::Sys.time()
[13:21:53.856]     ...future.result
[13:21:53.856] }
[13:21:53.859] Poll #1 (0): usedNodes() = 2, workers = 2
[13:21:53.869] receiveMessageFromWorker() for ClusterFuture ...
[13:21:53.870] - Validating connection of MultisessionFuture
[13:21:53.870] - received message: FutureResult
[13:21:53.870] - Received FutureResult
[13:21:53.870] - Erased future from FutureRegistry
[13:21:53.870] result() for ClusterFuture ...
[13:21:53.870] - result already collected: FutureResult
[13:21:53.870] result() for ClusterFuture ... done
[13:21:53.870] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:53.870] result() for ClusterFuture ...
[13:21:53.871] - result already collected: FutureResult
[13:21:53.871] result() for ClusterFuture ... done
[13:21:53.871] result() for ClusterFuture ...
[13:21:53.871] - result already collected: FutureResult
[13:21:53.871] result() for ClusterFuture ... done
[13:21:53.872] MultisessionFuture started
[13:21:53.872] - Launch lazy future ... done
[13:21:53.872] run() for ‘MultisessionFuture’ ... done
[13:21:53.872] getGlobalsAndPackages() ...
[13:21:53.872] Searching for globals...
[13:21:53.873] - globals found: [2] ‘list’, ‘stop’
[13:21:53.873] Searching for globals ... DONE
[13:21:53.873] Resolving globals: FALSE
[13:21:53.873] 
[13:21:53.874] 
[13:21:53.874] getGlobalsAndPackages() ... DONE
- result = TRUE, recursive = -1 ... DONE
- result = TRUE, recursive = 0 ...
[13:21:53.874] getGlobalsAndPackages() ...
[13:21:53.874] Searching for globals...
[13:21:53.875] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:21:53.875] Searching for globals ... DONE
[13:21:53.875] Resolving globals: FALSE
[13:21:53.876] 
[13:21:53.876] 
[13:21:53.876] getGlobalsAndPackages() ... DONE
[13:21:53.876] run() for ‘Future’ ...
[13:21:53.876] - state: ‘created’
[13:21:53.876] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:53.891] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:53.891] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:53.891]   - Field: ‘node’
[13:21:53.891]   - Field: ‘label’
[13:21:53.891]   - Field: ‘local’
[13:21:53.891]   - Field: ‘owner’
[13:21:53.891]   - Field: ‘envir’
[13:21:53.891]   - Field: ‘workers’
[13:21:53.891]   - Field: ‘packages’
[13:21:53.892]   - Field: ‘gc’
[13:21:53.892]   - Field: ‘conditions’
[13:21:53.892]   - Field: ‘persistent’
[13:21:53.892]   - Field: ‘expr’
[13:21:53.892]   - Field: ‘uuid’
[13:21:53.892]   - Field: ‘seed’
[13:21:53.892]   - Field: ‘version’
[13:21:53.892]   - Field: ‘result’
[13:21:53.892]   - Field: ‘asynchronous’
[13:21:53.892]   - Field: ‘calls’
[13:21:53.892]   - Field: ‘globals’
[13:21:53.893]   - Field: ‘stdout’
[13:21:53.893]   - Field: ‘earlySignal’
[13:21:53.893]   - Field: ‘lazy’
[13:21:53.893]   - Field: ‘state’
[13:21:53.893] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:53.893] - Launch lazy future ...
[13:21:53.893] Packages needed by the future expression (n = 0): <none>
[13:21:53.893] Packages needed by future strategies (n = 0): <none>
[13:21:53.894] {
[13:21:53.894]     {
[13:21:53.894]         {
[13:21:53.894]             ...future.startTime <- base::Sys.time()
[13:21:53.894]             {
[13:21:53.894]                 {
[13:21:53.894]                   {
[13:21:53.894]                     {
[13:21:53.894]                       base::local({
[13:21:53.894]                         has_future <- base::requireNamespace("future", 
[13:21:53.894]                           quietly = TRUE)
[13:21:53.894]                         if (has_future) {
[13:21:53.894]                           ns <- base::getNamespace("future")
[13:21:53.894]                           version <- ns[[".package"]][["version"]]
[13:21:53.894]                           if (is.null(version)) 
[13:21:53.894]                             version <- utils::packageVersion("future")
[13:21:53.894]                         }
[13:21:53.894]                         else {
[13:21:53.894]                           version <- NULL
[13:21:53.894]                         }
[13:21:53.894]                         if (!has_future || version < "1.8.0") {
[13:21:53.894]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:53.894]                             "", base::R.version$version.string), 
[13:21:53.894]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:53.894]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:53.894]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:53.894]                               "release", "version")], collapse = " "), 
[13:21:53.894]                             hostname = base::Sys.info()[["nodename"]])
[13:21:53.894]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:53.894]                             info)
[13:21:53.894]                           info <- base::paste(info, collapse = "; ")
[13:21:53.894]                           if (!has_future) {
[13:21:53.894]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:53.894]                               info)
[13:21:53.894]                           }
[13:21:53.894]                           else {
[13:21:53.894]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:53.894]                               info, version)
[13:21:53.894]                           }
[13:21:53.894]                           base::stop(msg)
[13:21:53.894]                         }
[13:21:53.894]                       })
[13:21:53.894]                     }
[13:21:53.894]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:53.894]                     base::options(mc.cores = 1L)
[13:21:53.894]                   }
[13:21:53.894]                   options(future.plan = NULL)
[13:21:53.894]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:53.894]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:53.894]                 }
[13:21:53.894]                 ...future.workdir <- getwd()
[13:21:53.894]             }
[13:21:53.894]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:53.894]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:53.894]         }
[13:21:53.894]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:53.894]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:53.894]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:53.894]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:53.894]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:53.894]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:53.894]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:53.894]             base::names(...future.oldOptions))
[13:21:53.894]     }
[13:21:53.894]     if (FALSE) {
[13:21:53.894]     }
[13:21:53.894]     else {
[13:21:53.894]         if (TRUE) {
[13:21:53.894]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:53.894]                 open = "w")
[13:21:53.894]         }
[13:21:53.894]         else {
[13:21:53.894]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:53.894]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:53.894]         }
[13:21:53.894]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:53.894]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:53.894]             base::sink(type = "output", split = FALSE)
[13:21:53.894]             base::close(...future.stdout)
[13:21:53.894]         }, add = TRUE)
[13:21:53.894]     }
[13:21:53.894]     ...future.frame <- base::sys.nframe()
[13:21:53.894]     ...future.conditions <- base::list()
[13:21:53.894]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:53.894]     if (FALSE) {
[13:21:53.894]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:53.894]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:53.894]     }
[13:21:53.894]     ...future.result <- base::tryCatch({
[13:21:53.894]         base::withCallingHandlers({
[13:21:53.894]             ...future.value <- base::withVisible(base::local({
[13:21:53.894]                 ...future.makeSendCondition <- local({
[13:21:53.894]                   sendCondition <- NULL
[13:21:53.894]                   function(frame = 1L) {
[13:21:53.894]                     if (is.function(sendCondition)) 
[13:21:53.894]                       return(sendCondition)
[13:21:53.894]                     ns <- getNamespace("parallel")
[13:21:53.894]                     if (exists("sendData", mode = "function", 
[13:21:53.894]                       envir = ns)) {
[13:21:53.894]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:53.894]                         envir = ns)
[13:21:53.894]                       envir <- sys.frame(frame)
[13:21:53.894]                       master <- NULL
[13:21:53.894]                       while (!identical(envir, .GlobalEnv) && 
[13:21:53.894]                         !identical(envir, emptyenv())) {
[13:21:53.894]                         if (exists("master", mode = "list", envir = envir, 
[13:21:53.894]                           inherits = FALSE)) {
[13:21:53.894]                           master <- get("master", mode = "list", 
[13:21:53.894]                             envir = envir, inherits = FALSE)
[13:21:53.894]                           if (inherits(master, c("SOCKnode", 
[13:21:53.894]                             "SOCK0node"))) {
[13:21:53.894]                             sendCondition <<- function(cond) {
[13:21:53.894]                               data <- list(type = "VALUE", value = cond, 
[13:21:53.894]                                 success = TRUE)
[13:21:53.894]                               parallel_sendData(master, data)
[13:21:53.894]                             }
[13:21:53.894]                             return(sendCondition)
[13:21:53.894]                           }
[13:21:53.894]                         }
[13:21:53.894]                         frame <- frame + 1L
[13:21:53.894]                         envir <- sys.frame(frame)
[13:21:53.894]                       }
[13:21:53.894]                     }
[13:21:53.894]                     sendCondition <<- function(cond) NULL
[13:21:53.894]                   }
[13:21:53.894]                 })
[13:21:53.894]                 withCallingHandlers({
[13:21:53.894]                   {
[13:21:53.894]                     Sys.sleep(0.5)
[13:21:53.894]                     list(a = 1, b = 42L)
[13:21:53.894]                   }
[13:21:53.894]                 }, immediateCondition = function(cond) {
[13:21:53.894]                   sendCondition <- ...future.makeSendCondition()
[13:21:53.894]                   sendCondition(cond)
[13:21:53.894]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:53.894]                   {
[13:21:53.894]                     inherits <- base::inherits
[13:21:53.894]                     invokeRestart <- base::invokeRestart
[13:21:53.894]                     is.null <- base::is.null
[13:21:53.894]                     muffled <- FALSE
[13:21:53.894]                     if (inherits(cond, "message")) {
[13:21:53.894]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:53.894]                       if (muffled) 
[13:21:53.894]                         invokeRestart("muffleMessage")
[13:21:53.894]                     }
[13:21:53.894]                     else if (inherits(cond, "warning")) {
[13:21:53.894]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:53.894]                       if (muffled) 
[13:21:53.894]                         invokeRestart("muffleWarning")
[13:21:53.894]                     }
[13:21:53.894]                     else if (inherits(cond, "condition")) {
[13:21:53.894]                       if (!is.null(pattern)) {
[13:21:53.894]                         computeRestarts <- base::computeRestarts
[13:21:53.894]                         grepl <- base::grepl
[13:21:53.894]                         restarts <- computeRestarts(cond)
[13:21:53.894]                         for (restart in restarts) {
[13:21:53.894]                           name <- restart$name
[13:21:53.894]                           if (is.null(name)) 
[13:21:53.894]                             next
[13:21:53.894]                           if (!grepl(pattern, name)) 
[13:21:53.894]                             next
[13:21:53.894]                           invokeRestart(restart)
[13:21:53.894]                           muffled <- TRUE
[13:21:53.894]                           break
[13:21:53.894]                         }
[13:21:53.894]                       }
[13:21:53.894]                     }
[13:21:53.894]                     invisible(muffled)
[13:21:53.894]                   }
[13:21:53.894]                   muffleCondition(cond)
[13:21:53.894]                 })
[13:21:53.894]             }))
[13:21:53.894]             future::FutureResult(value = ...future.value$value, 
[13:21:53.894]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:53.894]                   ...future.rng), globalenv = if (FALSE) 
[13:21:53.894]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:53.894]                     ...future.globalenv.names))
[13:21:53.894]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:53.894]         }, condition = base::local({
[13:21:53.894]             c <- base::c
[13:21:53.894]             inherits <- base::inherits
[13:21:53.894]             invokeRestart <- base::invokeRestart
[13:21:53.894]             length <- base::length
[13:21:53.894]             list <- base::list
[13:21:53.894]             seq.int <- base::seq.int
[13:21:53.894]             signalCondition <- base::signalCondition
[13:21:53.894]             sys.calls <- base::sys.calls
[13:21:53.894]             `[[` <- base::`[[`
[13:21:53.894]             `+` <- base::`+`
[13:21:53.894]             `<<-` <- base::`<<-`
[13:21:53.894]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:53.894]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:53.894]                   3L)]
[13:21:53.894]             }
[13:21:53.894]             function(cond) {
[13:21:53.894]                 is_error <- inherits(cond, "error")
[13:21:53.894]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:53.894]                   NULL)
[13:21:53.894]                 if (is_error) {
[13:21:53.894]                   sessionInformation <- function() {
[13:21:53.894]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:53.894]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:53.894]                       search = base::search(), system = base::Sys.info())
[13:21:53.894]                   }
[13:21:53.894]                   ...future.conditions[[length(...future.conditions) + 
[13:21:53.894]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:53.894]                     cond$call), session = sessionInformation(), 
[13:21:53.894]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:53.894]                   signalCondition(cond)
[13:21:53.894]                 }
[13:21:53.894]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:53.894]                 "immediateCondition"))) {
[13:21:53.894]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:53.894]                   ...future.conditions[[length(...future.conditions) + 
[13:21:53.894]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:53.894]                   if (TRUE && !signal) {
[13:21:53.894]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:53.894]                     {
[13:21:53.894]                       inherits <- base::inherits
[13:21:53.894]                       invokeRestart <- base::invokeRestart
[13:21:53.894]                       is.null <- base::is.null
[13:21:53.894]                       muffled <- FALSE
[13:21:53.894]                       if (inherits(cond, "message")) {
[13:21:53.894]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:53.894]                         if (muffled) 
[13:21:53.894]                           invokeRestart("muffleMessage")
[13:21:53.894]                       }
[13:21:53.894]                       else if (inherits(cond, "warning")) {
[13:21:53.894]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:53.894]                         if (muffled) 
[13:21:53.894]                           invokeRestart("muffleWarning")
[13:21:53.894]                       }
[13:21:53.894]                       else if (inherits(cond, "condition")) {
[13:21:53.894]                         if (!is.null(pattern)) {
[13:21:53.894]                           computeRestarts <- base::computeRestarts
[13:21:53.894]                           grepl <- base::grepl
[13:21:53.894]                           restarts <- computeRestarts(cond)
[13:21:53.894]                           for (restart in restarts) {
[13:21:53.894]                             name <- restart$name
[13:21:53.894]                             if (is.null(name)) 
[13:21:53.894]                               next
[13:21:53.894]                             if (!grepl(pattern, name)) 
[13:21:53.894]                               next
[13:21:53.894]                             invokeRestart(restart)
[13:21:53.894]                             muffled <- TRUE
[13:21:53.894]                             break
[13:21:53.894]                           }
[13:21:53.894]                         }
[13:21:53.894]                       }
[13:21:53.894]                       invisible(muffled)
[13:21:53.894]                     }
[13:21:53.894]                     muffleCondition(cond, pattern = "^muffle")
[13:21:53.894]                   }
[13:21:53.894]                 }
[13:21:53.894]                 else {
[13:21:53.894]                   if (TRUE) {
[13:21:53.894]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:53.894]                     {
[13:21:53.894]                       inherits <- base::inherits
[13:21:53.894]                       invokeRestart <- base::invokeRestart
[13:21:53.894]                       is.null <- base::is.null
[13:21:53.894]                       muffled <- FALSE
[13:21:53.894]                       if (inherits(cond, "message")) {
[13:21:53.894]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:53.894]                         if (muffled) 
[13:21:53.894]                           invokeRestart("muffleMessage")
[13:21:53.894]                       }
[13:21:53.894]                       else if (inherits(cond, "warning")) {
[13:21:53.894]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:53.894]                         if (muffled) 
[13:21:53.894]                           invokeRestart("muffleWarning")
[13:21:53.894]                       }
[13:21:53.894]                       else if (inherits(cond, "condition")) {
[13:21:53.894]                         if (!is.null(pattern)) {
[13:21:53.894]                           computeRestarts <- base::computeRestarts
[13:21:53.894]                           grepl <- base::grepl
[13:21:53.894]                           restarts <- computeRestarts(cond)
[13:21:53.894]                           for (restart in restarts) {
[13:21:53.894]                             name <- restart$name
[13:21:53.894]                             if (is.null(name)) 
[13:21:53.894]                               next
[13:21:53.894]                             if (!grepl(pattern, name)) 
[13:21:53.894]                               next
[13:21:53.894]                             invokeRestart(restart)
[13:21:53.894]                             muffled <- TRUE
[13:21:53.894]                             break
[13:21:53.894]                           }
[13:21:53.894]                         }
[13:21:53.894]                       }
[13:21:53.894]                       invisible(muffled)
[13:21:53.894]                     }
[13:21:53.894]                     muffleCondition(cond, pattern = "^muffle")
[13:21:53.894]                   }
[13:21:53.894]                 }
[13:21:53.894]             }
[13:21:53.894]         }))
[13:21:53.894]     }, error = function(ex) {
[13:21:53.894]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:53.894]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:53.894]                 ...future.rng), started = ...future.startTime, 
[13:21:53.894]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:53.894]             version = "1.8"), class = "FutureResult")
[13:21:53.894]     }, finally = {
[13:21:53.894]         if (!identical(...future.workdir, getwd())) 
[13:21:53.894]             setwd(...future.workdir)
[13:21:53.894]         {
[13:21:53.894]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:53.894]                 ...future.oldOptions$nwarnings <- NULL
[13:21:53.894]             }
[13:21:53.894]             base::options(...future.oldOptions)
[13:21:53.894]             if (.Platform$OS.type == "windows") {
[13:21:53.894]                 old_names <- names(...future.oldEnvVars)
[13:21:53.894]                 envs <- base::Sys.getenv()
[13:21:53.894]                 names <- names(envs)
[13:21:53.894]                 common <- intersect(names, old_names)
[13:21:53.894]                 added <- setdiff(names, old_names)
[13:21:53.894]                 removed <- setdiff(old_names, names)
[13:21:53.894]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:53.894]                   envs[common]]
[13:21:53.894]                 NAMES <- toupper(changed)
[13:21:53.894]                 args <- list()
[13:21:53.894]                 for (kk in seq_along(NAMES)) {
[13:21:53.894]                   name <- changed[[kk]]
[13:21:53.894]                   NAME <- NAMES[[kk]]
[13:21:53.894]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:53.894]                     next
[13:21:53.894]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:53.894]                 }
[13:21:53.894]                 NAMES <- toupper(added)
[13:21:53.894]                 for (kk in seq_along(NAMES)) {
[13:21:53.894]                   name <- added[[kk]]
[13:21:53.894]                   NAME <- NAMES[[kk]]
[13:21:53.894]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:53.894]                     next
[13:21:53.894]                   args[[name]] <- ""
[13:21:53.894]                 }
[13:21:53.894]                 NAMES <- toupper(removed)
[13:21:53.894]                 for (kk in seq_along(NAMES)) {
[13:21:53.894]                   name <- removed[[kk]]
[13:21:53.894]                   NAME <- NAMES[[kk]]
[13:21:53.894]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:53.894]                     next
[13:21:53.894]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:53.894]                 }
[13:21:53.894]                 if (length(args) > 0) 
[13:21:53.894]                   base::do.call(base::Sys.setenv, args = args)
[13:21:53.894]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:53.894]             }
[13:21:53.894]             else {
[13:21:53.894]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:53.894]             }
[13:21:53.894]             {
[13:21:53.894]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:53.894]                   0L) {
[13:21:53.894]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:53.894]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:53.894]                   base::options(opts)
[13:21:53.894]                 }
[13:21:53.894]                 {
[13:21:53.894]                   {
[13:21:53.894]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:53.894]                     NULL
[13:21:53.894]                   }
[13:21:53.894]                   options(future.plan = NULL)
[13:21:53.894]                   if (is.na(NA_character_)) 
[13:21:53.894]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:53.894]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:53.894]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:53.894]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:53.894]                     envir = parent.frame()) 
[13:21:53.894]                   {
[13:21:53.894]                     if (is.function(workers)) 
[13:21:53.894]                       workers <- workers()
[13:21:53.894]                     workers <- structure(as.integer(workers), 
[13:21:53.894]                       class = class(workers))
[13:21:53.894]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:53.894]                       workers >= 1)
[13:21:53.894]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:53.894]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:53.894]                     }
[13:21:53.894]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:53.894]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:53.894]                       envir = envir)
[13:21:53.894]                     if (!future$lazy) 
[13:21:53.894]                       future <- run(future)
[13:21:53.894]                     invisible(future)
[13:21:53.894]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:53.894]                 }
[13:21:53.894]             }
[13:21:53.894]         }
[13:21:53.894]     })
[13:21:53.894]     if (TRUE) {
[13:21:53.894]         base::sink(type = "output", split = FALSE)
[13:21:53.894]         if (TRUE) {
[13:21:53.894]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:53.894]         }
[13:21:53.894]         else {
[13:21:53.894]             ...future.result["stdout"] <- base::list(NULL)
[13:21:53.894]         }
[13:21:53.894]         base::close(...future.stdout)
[13:21:53.894]         ...future.stdout <- NULL
[13:21:53.894]     }
[13:21:53.894]     ...future.result$conditions <- ...future.conditions
[13:21:53.894]     ...future.result$finished <- base::Sys.time()
[13:21:53.894]     ...future.result
[13:21:53.894] }
[13:21:53.896] Poll #1 (0): usedNodes() = 2, workers = 2
[13:21:53.920] receiveMessageFromWorker() for ClusterFuture ...
[13:21:53.920] - Validating connection of MultisessionFuture
[13:21:53.921] - received message: FutureResult
[13:21:53.921] - Received FutureResult
[13:21:53.921] - Erased future from FutureRegistry
[13:21:53.921] result() for ClusterFuture ...
[13:21:53.921] - result already collected: FutureResult
[13:21:53.921] result() for ClusterFuture ... done
[13:21:53.921] signalConditions() ...
[13:21:53.922]  - include = ‘immediateCondition’
[13:21:53.922]  - exclude = 
[13:21:53.922]  - resignal = FALSE
[13:21:53.922]  - Number of conditions: 1
[13:21:53.922] signalConditions() ... done
[13:21:53.922] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:53.922] result() for ClusterFuture ...
[13:21:53.922] - result already collected: FutureResult
[13:21:53.922] result() for ClusterFuture ... done
[13:21:53.922] result() for ClusterFuture ...
[13:21:53.923] - result already collected: FutureResult
[13:21:53.923] result() for ClusterFuture ... done
[13:21:53.923] signalConditions() ...
[13:21:53.923]  - include = ‘immediateCondition’
[13:21:53.923]  - exclude = 
[13:21:53.923]  - resignal = FALSE
[13:21:53.923]  - Number of conditions: 1
[13:21:53.923] signalConditions() ... done
[13:21:53.924] MultisessionFuture started
[13:21:53.924] - Launch lazy future ... done
[13:21:53.924] run() for ‘MultisessionFuture’ ... done
[13:21:54.482] receiveMessageFromWorker() for ClusterFuture ...
[13:21:54.482] - Validating connection of MultisessionFuture
[13:21:54.483] - received message: FutureResult
[13:21:54.483] - Received FutureResult
[13:21:54.483] - Erased future from FutureRegistry
[13:21:54.483] result() for ClusterFuture ...
[13:21:54.483] - result already collected: FutureResult
[13:21:54.483] result() for ClusterFuture ... done
[13:21:54.483] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:54.483] A MultisessionFuture was resolved
[13:21:54.483] getGlobalsAndPackages() ...
[13:21:54.484] Searching for globals...
[13:21:54.485] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:21:54.485] Searching for globals ... DONE
[13:21:54.485] Resolving globals: FALSE
[13:21:54.485] 
[13:21:54.485] 
[13:21:54.485] getGlobalsAndPackages() ... DONE
[13:21:54.486] run() for ‘Future’ ...
[13:21:54.486] - state: ‘created’
[13:21:54.486] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:54.501] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:54.501] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:54.501]   - Field: ‘node’
[13:21:54.501]   - Field: ‘label’
[13:21:54.501]   - Field: ‘local’
[13:21:54.501]   - Field: ‘owner’
[13:21:54.501]   - Field: ‘envir’
[13:21:54.501]   - Field: ‘workers’
[13:21:54.501]   - Field: ‘packages’
[13:21:54.502]   - Field: ‘gc’
[13:21:54.502]   - Field: ‘conditions’
[13:21:54.502]   - Field: ‘persistent’
[13:21:54.502]   - Field: ‘expr’
[13:21:54.502]   - Field: ‘uuid’
[13:21:54.502]   - Field: ‘seed’
[13:21:54.502]   - Field: ‘version’
[13:21:54.502]   - Field: ‘result’
[13:21:54.502]   - Field: ‘asynchronous’
[13:21:54.502]   - Field: ‘calls’
[13:21:54.502]   - Field: ‘globals’
[13:21:54.503]   - Field: ‘stdout’
[13:21:54.503]   - Field: ‘earlySignal’
[13:21:54.503]   - Field: ‘lazy’
[13:21:54.503]   - Field: ‘state’
[13:21:54.503] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:54.503] - Launch lazy future ...
[13:21:54.503] Packages needed by the future expression (n = 0): <none>
[13:21:54.503] Packages needed by future strategies (n = 0): <none>
[13:21:54.504] {
[13:21:54.504]     {
[13:21:54.504]         {
[13:21:54.504]             ...future.startTime <- base::Sys.time()
[13:21:54.504]             {
[13:21:54.504]                 {
[13:21:54.504]                   {
[13:21:54.504]                     {
[13:21:54.504]                       base::local({
[13:21:54.504]                         has_future <- base::requireNamespace("future", 
[13:21:54.504]                           quietly = TRUE)
[13:21:54.504]                         if (has_future) {
[13:21:54.504]                           ns <- base::getNamespace("future")
[13:21:54.504]                           version <- ns[[".package"]][["version"]]
[13:21:54.504]                           if (is.null(version)) 
[13:21:54.504]                             version <- utils::packageVersion("future")
[13:21:54.504]                         }
[13:21:54.504]                         else {
[13:21:54.504]                           version <- NULL
[13:21:54.504]                         }
[13:21:54.504]                         if (!has_future || version < "1.8.0") {
[13:21:54.504]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:54.504]                             "", base::R.version$version.string), 
[13:21:54.504]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:54.504]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:54.504]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:54.504]                               "release", "version")], collapse = " "), 
[13:21:54.504]                             hostname = base::Sys.info()[["nodename"]])
[13:21:54.504]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:54.504]                             info)
[13:21:54.504]                           info <- base::paste(info, collapse = "; ")
[13:21:54.504]                           if (!has_future) {
[13:21:54.504]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:54.504]                               info)
[13:21:54.504]                           }
[13:21:54.504]                           else {
[13:21:54.504]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:54.504]                               info, version)
[13:21:54.504]                           }
[13:21:54.504]                           base::stop(msg)
[13:21:54.504]                         }
[13:21:54.504]                       })
[13:21:54.504]                     }
[13:21:54.504]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:54.504]                     base::options(mc.cores = 1L)
[13:21:54.504]                   }
[13:21:54.504]                   options(future.plan = NULL)
[13:21:54.504]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:54.504]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:54.504]                 }
[13:21:54.504]                 ...future.workdir <- getwd()
[13:21:54.504]             }
[13:21:54.504]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:54.504]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:54.504]         }
[13:21:54.504]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:54.504]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:54.504]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:54.504]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:54.504]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:54.504]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:54.504]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:54.504]             base::names(...future.oldOptions))
[13:21:54.504]     }
[13:21:54.504]     if (FALSE) {
[13:21:54.504]     }
[13:21:54.504]     else {
[13:21:54.504]         if (TRUE) {
[13:21:54.504]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:54.504]                 open = "w")
[13:21:54.504]         }
[13:21:54.504]         else {
[13:21:54.504]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:54.504]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:54.504]         }
[13:21:54.504]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:54.504]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:54.504]             base::sink(type = "output", split = FALSE)
[13:21:54.504]             base::close(...future.stdout)
[13:21:54.504]         }, add = TRUE)
[13:21:54.504]     }
[13:21:54.504]     ...future.frame <- base::sys.nframe()
[13:21:54.504]     ...future.conditions <- base::list()
[13:21:54.504]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:54.504]     if (FALSE) {
[13:21:54.504]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:54.504]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:54.504]     }
[13:21:54.504]     ...future.result <- base::tryCatch({
[13:21:54.504]         base::withCallingHandlers({
[13:21:54.504]             ...future.value <- base::withVisible(base::local({
[13:21:54.504]                 ...future.makeSendCondition <- local({
[13:21:54.504]                   sendCondition <- NULL
[13:21:54.504]                   function(frame = 1L) {
[13:21:54.504]                     if (is.function(sendCondition)) 
[13:21:54.504]                       return(sendCondition)
[13:21:54.504]                     ns <- getNamespace("parallel")
[13:21:54.504]                     if (exists("sendData", mode = "function", 
[13:21:54.504]                       envir = ns)) {
[13:21:54.504]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:54.504]                         envir = ns)
[13:21:54.504]                       envir <- sys.frame(frame)
[13:21:54.504]                       master <- NULL
[13:21:54.504]                       while (!identical(envir, .GlobalEnv) && 
[13:21:54.504]                         !identical(envir, emptyenv())) {
[13:21:54.504]                         if (exists("master", mode = "list", envir = envir, 
[13:21:54.504]                           inherits = FALSE)) {
[13:21:54.504]                           master <- get("master", mode = "list", 
[13:21:54.504]                             envir = envir, inherits = FALSE)
[13:21:54.504]                           if (inherits(master, c("SOCKnode", 
[13:21:54.504]                             "SOCK0node"))) {
[13:21:54.504]                             sendCondition <<- function(cond) {
[13:21:54.504]                               data <- list(type = "VALUE", value = cond, 
[13:21:54.504]                                 success = TRUE)
[13:21:54.504]                               parallel_sendData(master, data)
[13:21:54.504]                             }
[13:21:54.504]                             return(sendCondition)
[13:21:54.504]                           }
[13:21:54.504]                         }
[13:21:54.504]                         frame <- frame + 1L
[13:21:54.504]                         envir <- sys.frame(frame)
[13:21:54.504]                       }
[13:21:54.504]                     }
[13:21:54.504]                     sendCondition <<- function(cond) NULL
[13:21:54.504]                   }
[13:21:54.504]                 })
[13:21:54.504]                 withCallingHandlers({
[13:21:54.504]                   {
[13:21:54.504]                     Sys.sleep(0.5)
[13:21:54.504]                     list(a = 1, b = 42L)
[13:21:54.504]                   }
[13:21:54.504]                 }, immediateCondition = function(cond) {
[13:21:54.504]                   sendCondition <- ...future.makeSendCondition()
[13:21:54.504]                   sendCondition(cond)
[13:21:54.504]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:54.504]                   {
[13:21:54.504]                     inherits <- base::inherits
[13:21:54.504]                     invokeRestart <- base::invokeRestart
[13:21:54.504]                     is.null <- base::is.null
[13:21:54.504]                     muffled <- FALSE
[13:21:54.504]                     if (inherits(cond, "message")) {
[13:21:54.504]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:54.504]                       if (muffled) 
[13:21:54.504]                         invokeRestart("muffleMessage")
[13:21:54.504]                     }
[13:21:54.504]                     else if (inherits(cond, "warning")) {
[13:21:54.504]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:54.504]                       if (muffled) 
[13:21:54.504]                         invokeRestart("muffleWarning")
[13:21:54.504]                     }
[13:21:54.504]                     else if (inherits(cond, "condition")) {
[13:21:54.504]                       if (!is.null(pattern)) {
[13:21:54.504]                         computeRestarts <- base::computeRestarts
[13:21:54.504]                         grepl <- base::grepl
[13:21:54.504]                         restarts <- computeRestarts(cond)
[13:21:54.504]                         for (restart in restarts) {
[13:21:54.504]                           name <- restart$name
[13:21:54.504]                           if (is.null(name)) 
[13:21:54.504]                             next
[13:21:54.504]                           if (!grepl(pattern, name)) 
[13:21:54.504]                             next
[13:21:54.504]                           invokeRestart(restart)
[13:21:54.504]                           muffled <- TRUE
[13:21:54.504]                           break
[13:21:54.504]                         }
[13:21:54.504]                       }
[13:21:54.504]                     }
[13:21:54.504]                     invisible(muffled)
[13:21:54.504]                   }
[13:21:54.504]                   muffleCondition(cond)
[13:21:54.504]                 })
[13:21:54.504]             }))
[13:21:54.504]             future::FutureResult(value = ...future.value$value, 
[13:21:54.504]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:54.504]                   ...future.rng), globalenv = if (FALSE) 
[13:21:54.504]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:54.504]                     ...future.globalenv.names))
[13:21:54.504]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:54.504]         }, condition = base::local({
[13:21:54.504]             c <- base::c
[13:21:54.504]             inherits <- base::inherits
[13:21:54.504]             invokeRestart <- base::invokeRestart
[13:21:54.504]             length <- base::length
[13:21:54.504]             list <- base::list
[13:21:54.504]             seq.int <- base::seq.int
[13:21:54.504]             signalCondition <- base::signalCondition
[13:21:54.504]             sys.calls <- base::sys.calls
[13:21:54.504]             `[[` <- base::`[[`
[13:21:54.504]             `+` <- base::`+`
[13:21:54.504]             `<<-` <- base::`<<-`
[13:21:54.504]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:54.504]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:54.504]                   3L)]
[13:21:54.504]             }
[13:21:54.504]             function(cond) {
[13:21:54.504]                 is_error <- inherits(cond, "error")
[13:21:54.504]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:54.504]                   NULL)
[13:21:54.504]                 if (is_error) {
[13:21:54.504]                   sessionInformation <- function() {
[13:21:54.504]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:54.504]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:54.504]                       search = base::search(), system = base::Sys.info())
[13:21:54.504]                   }
[13:21:54.504]                   ...future.conditions[[length(...future.conditions) + 
[13:21:54.504]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:54.504]                     cond$call), session = sessionInformation(), 
[13:21:54.504]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:54.504]                   signalCondition(cond)
[13:21:54.504]                 }
[13:21:54.504]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:54.504]                 "immediateCondition"))) {
[13:21:54.504]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:54.504]                   ...future.conditions[[length(...future.conditions) + 
[13:21:54.504]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:54.504]                   if (TRUE && !signal) {
[13:21:54.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:54.504]                     {
[13:21:54.504]                       inherits <- base::inherits
[13:21:54.504]                       invokeRestart <- base::invokeRestart
[13:21:54.504]                       is.null <- base::is.null
[13:21:54.504]                       muffled <- FALSE
[13:21:54.504]                       if (inherits(cond, "message")) {
[13:21:54.504]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:54.504]                         if (muffled) 
[13:21:54.504]                           invokeRestart("muffleMessage")
[13:21:54.504]                       }
[13:21:54.504]                       else if (inherits(cond, "warning")) {
[13:21:54.504]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:54.504]                         if (muffled) 
[13:21:54.504]                           invokeRestart("muffleWarning")
[13:21:54.504]                       }
[13:21:54.504]                       else if (inherits(cond, "condition")) {
[13:21:54.504]                         if (!is.null(pattern)) {
[13:21:54.504]                           computeRestarts <- base::computeRestarts
[13:21:54.504]                           grepl <- base::grepl
[13:21:54.504]                           restarts <- computeRestarts(cond)
[13:21:54.504]                           for (restart in restarts) {
[13:21:54.504]                             name <- restart$name
[13:21:54.504]                             if (is.null(name)) 
[13:21:54.504]                               next
[13:21:54.504]                             if (!grepl(pattern, name)) 
[13:21:54.504]                               next
[13:21:54.504]                             invokeRestart(restart)
[13:21:54.504]                             muffled <- TRUE
[13:21:54.504]                             break
[13:21:54.504]                           }
[13:21:54.504]                         }
[13:21:54.504]                       }
[13:21:54.504]                       invisible(muffled)
[13:21:54.504]                     }
[13:21:54.504]                     muffleCondition(cond, pattern = "^muffle")
[13:21:54.504]                   }
[13:21:54.504]                 }
[13:21:54.504]                 else {
[13:21:54.504]                   if (TRUE) {
[13:21:54.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:54.504]                     {
[13:21:54.504]                       inherits <- base::inherits
[13:21:54.504]                       invokeRestart <- base::invokeRestart
[13:21:54.504]                       is.null <- base::is.null
[13:21:54.504]                       muffled <- FALSE
[13:21:54.504]                       if (inherits(cond, "message")) {
[13:21:54.504]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:54.504]                         if (muffled) 
[13:21:54.504]                           invokeRestart("muffleMessage")
[13:21:54.504]                       }
[13:21:54.504]                       else if (inherits(cond, "warning")) {
[13:21:54.504]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:54.504]                         if (muffled) 
[13:21:54.504]                           invokeRestart("muffleWarning")
[13:21:54.504]                       }
[13:21:54.504]                       else if (inherits(cond, "condition")) {
[13:21:54.504]                         if (!is.null(pattern)) {
[13:21:54.504]                           computeRestarts <- base::computeRestarts
[13:21:54.504]                           grepl <- base::grepl
[13:21:54.504]                           restarts <- computeRestarts(cond)
[13:21:54.504]                           for (restart in restarts) {
[13:21:54.504]                             name <- restart$name
[13:21:54.504]                             if (is.null(name)) 
[13:21:54.504]                               next
[13:21:54.504]                             if (!grepl(pattern, name)) 
[13:21:54.504]                               next
[13:21:54.504]                             invokeRestart(restart)
[13:21:54.504]                             muffled <- TRUE
[13:21:54.504]                             break
[13:21:54.504]                           }
[13:21:54.504]                         }
[13:21:54.504]                       }
[13:21:54.504]                       invisible(muffled)
[13:21:54.504]                     }
[13:21:54.504]                     muffleCondition(cond, pattern = "^muffle")
[13:21:54.504]                   }
[13:21:54.504]                 }
[13:21:54.504]             }
[13:21:54.504]         }))
[13:21:54.504]     }, error = function(ex) {
[13:21:54.504]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:54.504]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:54.504]                 ...future.rng), started = ...future.startTime, 
[13:21:54.504]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:54.504]             version = "1.8"), class = "FutureResult")
[13:21:54.504]     }, finally = {
[13:21:54.504]         if (!identical(...future.workdir, getwd())) 
[13:21:54.504]             setwd(...future.workdir)
[13:21:54.504]         {
[13:21:54.504]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:54.504]                 ...future.oldOptions$nwarnings <- NULL
[13:21:54.504]             }
[13:21:54.504]             base::options(...future.oldOptions)
[13:21:54.504]             if (.Platform$OS.type == "windows") {
[13:21:54.504]                 old_names <- names(...future.oldEnvVars)
[13:21:54.504]                 envs <- base::Sys.getenv()
[13:21:54.504]                 names <- names(envs)
[13:21:54.504]                 common <- intersect(names, old_names)
[13:21:54.504]                 added <- setdiff(names, old_names)
[13:21:54.504]                 removed <- setdiff(old_names, names)
[13:21:54.504]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:54.504]                   envs[common]]
[13:21:54.504]                 NAMES <- toupper(changed)
[13:21:54.504]                 args <- list()
[13:21:54.504]                 for (kk in seq_along(NAMES)) {
[13:21:54.504]                   name <- changed[[kk]]
[13:21:54.504]                   NAME <- NAMES[[kk]]
[13:21:54.504]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:54.504]                     next
[13:21:54.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:54.504]                 }
[13:21:54.504]                 NAMES <- toupper(added)
[13:21:54.504]                 for (kk in seq_along(NAMES)) {
[13:21:54.504]                   name <- added[[kk]]
[13:21:54.504]                   NAME <- NAMES[[kk]]
[13:21:54.504]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:54.504]                     next
[13:21:54.504]                   args[[name]] <- ""
[13:21:54.504]                 }
[13:21:54.504]                 NAMES <- toupper(removed)
[13:21:54.504]                 for (kk in seq_along(NAMES)) {
[13:21:54.504]                   name <- removed[[kk]]
[13:21:54.504]                   NAME <- NAMES[[kk]]
[13:21:54.504]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:54.504]                     next
[13:21:54.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:54.504]                 }
[13:21:54.504]                 if (length(args) > 0) 
[13:21:54.504]                   base::do.call(base::Sys.setenv, args = args)
[13:21:54.504]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:54.504]             }
[13:21:54.504]             else {
[13:21:54.504]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:54.504]             }
[13:21:54.504]             {
[13:21:54.504]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:54.504]                   0L) {
[13:21:54.504]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:54.504]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:54.504]                   base::options(opts)
[13:21:54.504]                 }
[13:21:54.504]                 {
[13:21:54.504]                   {
[13:21:54.504]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:54.504]                     NULL
[13:21:54.504]                   }
[13:21:54.504]                   options(future.plan = NULL)
[13:21:54.504]                   if (is.na(NA_character_)) 
[13:21:54.504]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:54.504]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:54.504]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:54.504]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:54.504]                     envir = parent.frame()) 
[13:21:54.504]                   {
[13:21:54.504]                     if (is.function(workers)) 
[13:21:54.504]                       workers <- workers()
[13:21:54.504]                     workers <- structure(as.integer(workers), 
[13:21:54.504]                       class = class(workers))
[13:21:54.504]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:54.504]                       workers >= 1)
[13:21:54.504]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:54.504]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:54.504]                     }
[13:21:54.504]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:54.504]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:54.504]                       envir = envir)
[13:21:54.504]                     if (!future$lazy) 
[13:21:54.504]                       future <- run(future)
[13:21:54.504]                     invisible(future)
[13:21:54.504]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:54.504]                 }
[13:21:54.504]             }
[13:21:54.504]         }
[13:21:54.504]     })
[13:21:54.504]     if (TRUE) {
[13:21:54.504]         base::sink(type = "output", split = FALSE)
[13:21:54.504]         if (TRUE) {
[13:21:54.504]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:54.504]         }
[13:21:54.504]         else {
[13:21:54.504]             ...future.result["stdout"] <- base::list(NULL)
[13:21:54.504]         }
[13:21:54.504]         base::close(...future.stdout)
[13:21:54.504]         ...future.stdout <- NULL
[13:21:54.504]     }
[13:21:54.504]     ...future.result$conditions <- ...future.conditions
[13:21:54.504]     ...future.result$finished <- base::Sys.time()
[13:21:54.504]     ...future.result
[13:21:54.504] }
[13:21:54.507] MultisessionFuture started
[13:21:54.507] - Launch lazy future ... done
[13:21:54.507] run() for ‘MultisessionFuture’ ... done
[13:21:55.054] receiveMessageFromWorker() for ClusterFuture ...
[13:21:55.055] - Validating connection of MultisessionFuture
[13:21:55.055] - received message: FutureResult
[13:21:55.055] - Received FutureResult
[13:21:55.055] - Erased future from FutureRegistry
[13:21:55.055] result() for ClusterFuture ...
[13:21:55.055] - result already collected: FutureResult
[13:21:55.055] result() for ClusterFuture ... done
[13:21:55.055] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:55.056] A MultisessionFuture was resolved
- w/ exception ...
[13:21:55.056] getGlobalsAndPackages() ...
[13:21:55.056] Searching for globals...
[13:21:55.056] - globals found: [2] ‘list’, ‘stop’
[13:21:55.057] Searching for globals ... DONE
[13:21:55.057] Resolving globals: FALSE
[13:21:55.057] 
[13:21:55.057] 
[13:21:55.057] getGlobalsAndPackages() ... DONE
[13:21:55.058] run() for ‘Future’ ...
[13:21:55.058] - state: ‘created’
[13:21:55.058] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:55.072] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:55.072] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:55.072]   - Field: ‘node’
[13:21:55.072]   - Field: ‘label’
[13:21:55.072]   - Field: ‘local’
[13:21:55.072]   - Field: ‘owner’
[13:21:55.073]   - Field: ‘envir’
[13:21:55.073]   - Field: ‘workers’
[13:21:55.073]   - Field: ‘packages’
[13:21:55.073]   - Field: ‘gc’
[13:21:55.073]   - Field: ‘conditions’
[13:21:55.073]   - Field: ‘persistent’
[13:21:55.073]   - Field: ‘expr’
[13:21:55.073]   - Field: ‘uuid’
[13:21:55.073]   - Field: ‘seed’
[13:21:55.073]   - Field: ‘version’
[13:21:55.073]   - Field: ‘result’
[13:21:55.074]   - Field: ‘asynchronous’
[13:21:55.074]   - Field: ‘calls’
[13:21:55.074]   - Field: ‘globals’
[13:21:55.074]   - Field: ‘stdout’
[13:21:55.074]   - Field: ‘earlySignal’
[13:21:55.074]   - Field: ‘lazy’
[13:21:55.074]   - Field: ‘state’
[13:21:55.074] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:55.074] - Launch lazy future ...
[13:21:55.075] Packages needed by the future expression (n = 0): <none>
[13:21:55.075] Packages needed by future strategies (n = 0): <none>
[13:21:55.075] {
[13:21:55.075]     {
[13:21:55.075]         {
[13:21:55.075]             ...future.startTime <- base::Sys.time()
[13:21:55.075]             {
[13:21:55.075]                 {
[13:21:55.075]                   {
[13:21:55.075]                     {
[13:21:55.075]                       base::local({
[13:21:55.075]                         has_future <- base::requireNamespace("future", 
[13:21:55.075]                           quietly = TRUE)
[13:21:55.075]                         if (has_future) {
[13:21:55.075]                           ns <- base::getNamespace("future")
[13:21:55.075]                           version <- ns[[".package"]][["version"]]
[13:21:55.075]                           if (is.null(version)) 
[13:21:55.075]                             version <- utils::packageVersion("future")
[13:21:55.075]                         }
[13:21:55.075]                         else {
[13:21:55.075]                           version <- NULL
[13:21:55.075]                         }
[13:21:55.075]                         if (!has_future || version < "1.8.0") {
[13:21:55.075]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:55.075]                             "", base::R.version$version.string), 
[13:21:55.075]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:55.075]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:55.075]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:55.075]                               "release", "version")], collapse = " "), 
[13:21:55.075]                             hostname = base::Sys.info()[["nodename"]])
[13:21:55.075]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:55.075]                             info)
[13:21:55.075]                           info <- base::paste(info, collapse = "; ")
[13:21:55.075]                           if (!has_future) {
[13:21:55.075]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:55.075]                               info)
[13:21:55.075]                           }
[13:21:55.075]                           else {
[13:21:55.075]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:55.075]                               info, version)
[13:21:55.075]                           }
[13:21:55.075]                           base::stop(msg)
[13:21:55.075]                         }
[13:21:55.075]                       })
[13:21:55.075]                     }
[13:21:55.075]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:55.075]                     base::options(mc.cores = 1L)
[13:21:55.075]                   }
[13:21:55.075]                   options(future.plan = NULL)
[13:21:55.075]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:55.075]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:55.075]                 }
[13:21:55.075]                 ...future.workdir <- getwd()
[13:21:55.075]             }
[13:21:55.075]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:55.075]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:55.075]         }
[13:21:55.075]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:55.075]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:55.075]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:55.075]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:55.075]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:55.075]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:55.075]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:55.075]             base::names(...future.oldOptions))
[13:21:55.075]     }
[13:21:55.075]     if (FALSE) {
[13:21:55.075]     }
[13:21:55.075]     else {
[13:21:55.075]         if (TRUE) {
[13:21:55.075]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:55.075]                 open = "w")
[13:21:55.075]         }
[13:21:55.075]         else {
[13:21:55.075]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:55.075]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:55.075]         }
[13:21:55.075]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:55.075]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:55.075]             base::sink(type = "output", split = FALSE)
[13:21:55.075]             base::close(...future.stdout)
[13:21:55.075]         }, add = TRUE)
[13:21:55.075]     }
[13:21:55.075]     ...future.frame <- base::sys.nframe()
[13:21:55.075]     ...future.conditions <- base::list()
[13:21:55.075]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:55.075]     if (FALSE) {
[13:21:55.075]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:55.075]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:55.075]     }
[13:21:55.075]     ...future.result <- base::tryCatch({
[13:21:55.075]         base::withCallingHandlers({
[13:21:55.075]             ...future.value <- base::withVisible(base::local({
[13:21:55.075]                 ...future.makeSendCondition <- local({
[13:21:55.075]                   sendCondition <- NULL
[13:21:55.075]                   function(frame = 1L) {
[13:21:55.075]                     if (is.function(sendCondition)) 
[13:21:55.075]                       return(sendCondition)
[13:21:55.075]                     ns <- getNamespace("parallel")
[13:21:55.075]                     if (exists("sendData", mode = "function", 
[13:21:55.075]                       envir = ns)) {
[13:21:55.075]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:55.075]                         envir = ns)
[13:21:55.075]                       envir <- sys.frame(frame)
[13:21:55.075]                       master <- NULL
[13:21:55.075]                       while (!identical(envir, .GlobalEnv) && 
[13:21:55.075]                         !identical(envir, emptyenv())) {
[13:21:55.075]                         if (exists("master", mode = "list", envir = envir, 
[13:21:55.075]                           inherits = FALSE)) {
[13:21:55.075]                           master <- get("master", mode = "list", 
[13:21:55.075]                             envir = envir, inherits = FALSE)
[13:21:55.075]                           if (inherits(master, c("SOCKnode", 
[13:21:55.075]                             "SOCK0node"))) {
[13:21:55.075]                             sendCondition <<- function(cond) {
[13:21:55.075]                               data <- list(type = "VALUE", value = cond, 
[13:21:55.075]                                 success = TRUE)
[13:21:55.075]                               parallel_sendData(master, data)
[13:21:55.075]                             }
[13:21:55.075]                             return(sendCondition)
[13:21:55.075]                           }
[13:21:55.075]                         }
[13:21:55.075]                         frame <- frame + 1L
[13:21:55.075]                         envir <- sys.frame(frame)
[13:21:55.075]                       }
[13:21:55.075]                     }
[13:21:55.075]                     sendCondition <<- function(cond) NULL
[13:21:55.075]                   }
[13:21:55.075]                 })
[13:21:55.075]                 withCallingHandlers({
[13:21:55.075]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:21:55.075]                 }, immediateCondition = function(cond) {
[13:21:55.075]                   sendCondition <- ...future.makeSendCondition()
[13:21:55.075]                   sendCondition(cond)
[13:21:55.075]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:55.075]                   {
[13:21:55.075]                     inherits <- base::inherits
[13:21:55.075]                     invokeRestart <- base::invokeRestart
[13:21:55.075]                     is.null <- base::is.null
[13:21:55.075]                     muffled <- FALSE
[13:21:55.075]                     if (inherits(cond, "message")) {
[13:21:55.075]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:55.075]                       if (muffled) 
[13:21:55.075]                         invokeRestart("muffleMessage")
[13:21:55.075]                     }
[13:21:55.075]                     else if (inherits(cond, "warning")) {
[13:21:55.075]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:55.075]                       if (muffled) 
[13:21:55.075]                         invokeRestart("muffleWarning")
[13:21:55.075]                     }
[13:21:55.075]                     else if (inherits(cond, "condition")) {
[13:21:55.075]                       if (!is.null(pattern)) {
[13:21:55.075]                         computeRestarts <- base::computeRestarts
[13:21:55.075]                         grepl <- base::grepl
[13:21:55.075]                         restarts <- computeRestarts(cond)
[13:21:55.075]                         for (restart in restarts) {
[13:21:55.075]                           name <- restart$name
[13:21:55.075]                           if (is.null(name)) 
[13:21:55.075]                             next
[13:21:55.075]                           if (!grepl(pattern, name)) 
[13:21:55.075]                             next
[13:21:55.075]                           invokeRestart(restart)
[13:21:55.075]                           muffled <- TRUE
[13:21:55.075]                           break
[13:21:55.075]                         }
[13:21:55.075]                       }
[13:21:55.075]                     }
[13:21:55.075]                     invisible(muffled)
[13:21:55.075]                   }
[13:21:55.075]                   muffleCondition(cond)
[13:21:55.075]                 })
[13:21:55.075]             }))
[13:21:55.075]             future::FutureResult(value = ...future.value$value, 
[13:21:55.075]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:55.075]                   ...future.rng), globalenv = if (FALSE) 
[13:21:55.075]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:55.075]                     ...future.globalenv.names))
[13:21:55.075]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:55.075]         }, condition = base::local({
[13:21:55.075]             c <- base::c
[13:21:55.075]             inherits <- base::inherits
[13:21:55.075]             invokeRestart <- base::invokeRestart
[13:21:55.075]             length <- base::length
[13:21:55.075]             list <- base::list
[13:21:55.075]             seq.int <- base::seq.int
[13:21:55.075]             signalCondition <- base::signalCondition
[13:21:55.075]             sys.calls <- base::sys.calls
[13:21:55.075]             `[[` <- base::`[[`
[13:21:55.075]             `+` <- base::`+`
[13:21:55.075]             `<<-` <- base::`<<-`
[13:21:55.075]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:55.075]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:55.075]                   3L)]
[13:21:55.075]             }
[13:21:55.075]             function(cond) {
[13:21:55.075]                 is_error <- inherits(cond, "error")
[13:21:55.075]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:55.075]                   NULL)
[13:21:55.075]                 if (is_error) {
[13:21:55.075]                   sessionInformation <- function() {
[13:21:55.075]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:55.075]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:55.075]                       search = base::search(), system = base::Sys.info())
[13:21:55.075]                   }
[13:21:55.075]                   ...future.conditions[[length(...future.conditions) + 
[13:21:55.075]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:55.075]                     cond$call), session = sessionInformation(), 
[13:21:55.075]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:55.075]                   signalCondition(cond)
[13:21:55.075]                 }
[13:21:55.075]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:55.075]                 "immediateCondition"))) {
[13:21:55.075]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:55.075]                   ...future.conditions[[length(...future.conditions) + 
[13:21:55.075]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:55.075]                   if (TRUE && !signal) {
[13:21:55.075]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:55.075]                     {
[13:21:55.075]                       inherits <- base::inherits
[13:21:55.075]                       invokeRestart <- base::invokeRestart
[13:21:55.075]                       is.null <- base::is.null
[13:21:55.075]                       muffled <- FALSE
[13:21:55.075]                       if (inherits(cond, "message")) {
[13:21:55.075]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:55.075]                         if (muffled) 
[13:21:55.075]                           invokeRestart("muffleMessage")
[13:21:55.075]                       }
[13:21:55.075]                       else if (inherits(cond, "warning")) {
[13:21:55.075]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:55.075]                         if (muffled) 
[13:21:55.075]                           invokeRestart("muffleWarning")
[13:21:55.075]                       }
[13:21:55.075]                       else if (inherits(cond, "condition")) {
[13:21:55.075]                         if (!is.null(pattern)) {
[13:21:55.075]                           computeRestarts <- base::computeRestarts
[13:21:55.075]                           grepl <- base::grepl
[13:21:55.075]                           restarts <- computeRestarts(cond)
[13:21:55.075]                           for (restart in restarts) {
[13:21:55.075]                             name <- restart$name
[13:21:55.075]                             if (is.null(name)) 
[13:21:55.075]                               next
[13:21:55.075]                             if (!grepl(pattern, name)) 
[13:21:55.075]                               next
[13:21:55.075]                             invokeRestart(restart)
[13:21:55.075]                             muffled <- TRUE
[13:21:55.075]                             break
[13:21:55.075]                           }
[13:21:55.075]                         }
[13:21:55.075]                       }
[13:21:55.075]                       invisible(muffled)
[13:21:55.075]                     }
[13:21:55.075]                     muffleCondition(cond, pattern = "^muffle")
[13:21:55.075]                   }
[13:21:55.075]                 }
[13:21:55.075]                 else {
[13:21:55.075]                   if (TRUE) {
[13:21:55.075]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:55.075]                     {
[13:21:55.075]                       inherits <- base::inherits
[13:21:55.075]                       invokeRestart <- base::invokeRestart
[13:21:55.075]                       is.null <- base::is.null
[13:21:55.075]                       muffled <- FALSE
[13:21:55.075]                       if (inherits(cond, "message")) {
[13:21:55.075]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:55.075]                         if (muffled) 
[13:21:55.075]                           invokeRestart("muffleMessage")
[13:21:55.075]                       }
[13:21:55.075]                       else if (inherits(cond, "warning")) {
[13:21:55.075]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:55.075]                         if (muffled) 
[13:21:55.075]                           invokeRestart("muffleWarning")
[13:21:55.075]                       }
[13:21:55.075]                       else if (inherits(cond, "condition")) {
[13:21:55.075]                         if (!is.null(pattern)) {
[13:21:55.075]                           computeRestarts <- base::computeRestarts
[13:21:55.075]                           grepl <- base::grepl
[13:21:55.075]                           restarts <- computeRestarts(cond)
[13:21:55.075]                           for (restart in restarts) {
[13:21:55.075]                             name <- restart$name
[13:21:55.075]                             if (is.null(name)) 
[13:21:55.075]                               next
[13:21:55.075]                             if (!grepl(pattern, name)) 
[13:21:55.075]                               next
[13:21:55.075]                             invokeRestart(restart)
[13:21:55.075]                             muffled <- TRUE
[13:21:55.075]                             break
[13:21:55.075]                           }
[13:21:55.075]                         }
[13:21:55.075]                       }
[13:21:55.075]                       invisible(muffled)
[13:21:55.075]                     }
[13:21:55.075]                     muffleCondition(cond, pattern = "^muffle")
[13:21:55.075]                   }
[13:21:55.075]                 }
[13:21:55.075]             }
[13:21:55.075]         }))
[13:21:55.075]     }, error = function(ex) {
[13:21:55.075]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:55.075]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:55.075]                 ...future.rng), started = ...future.startTime, 
[13:21:55.075]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:55.075]             version = "1.8"), class = "FutureResult")
[13:21:55.075]     }, finally = {
[13:21:55.075]         if (!identical(...future.workdir, getwd())) 
[13:21:55.075]             setwd(...future.workdir)
[13:21:55.075]         {
[13:21:55.075]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:55.075]                 ...future.oldOptions$nwarnings <- NULL
[13:21:55.075]             }
[13:21:55.075]             base::options(...future.oldOptions)
[13:21:55.075]             if (.Platform$OS.type == "windows") {
[13:21:55.075]                 old_names <- names(...future.oldEnvVars)
[13:21:55.075]                 envs <- base::Sys.getenv()
[13:21:55.075]                 names <- names(envs)
[13:21:55.075]                 common <- intersect(names, old_names)
[13:21:55.075]                 added <- setdiff(names, old_names)
[13:21:55.075]                 removed <- setdiff(old_names, names)
[13:21:55.075]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:55.075]                   envs[common]]
[13:21:55.075]                 NAMES <- toupper(changed)
[13:21:55.075]                 args <- list()
[13:21:55.075]                 for (kk in seq_along(NAMES)) {
[13:21:55.075]                   name <- changed[[kk]]
[13:21:55.075]                   NAME <- NAMES[[kk]]
[13:21:55.075]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:55.075]                     next
[13:21:55.075]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:55.075]                 }
[13:21:55.075]                 NAMES <- toupper(added)
[13:21:55.075]                 for (kk in seq_along(NAMES)) {
[13:21:55.075]                   name <- added[[kk]]
[13:21:55.075]                   NAME <- NAMES[[kk]]
[13:21:55.075]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:55.075]                     next
[13:21:55.075]                   args[[name]] <- ""
[13:21:55.075]                 }
[13:21:55.075]                 NAMES <- toupper(removed)
[13:21:55.075]                 for (kk in seq_along(NAMES)) {
[13:21:55.075]                   name <- removed[[kk]]
[13:21:55.075]                   NAME <- NAMES[[kk]]
[13:21:55.075]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:55.075]                     next
[13:21:55.075]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:55.075]                 }
[13:21:55.075]                 if (length(args) > 0) 
[13:21:55.075]                   base::do.call(base::Sys.setenv, args = args)
[13:21:55.075]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:55.075]             }
[13:21:55.075]             else {
[13:21:55.075]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:55.075]             }
[13:21:55.075]             {
[13:21:55.075]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:55.075]                   0L) {
[13:21:55.075]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:55.075]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:55.075]                   base::options(opts)
[13:21:55.075]                 }
[13:21:55.075]                 {
[13:21:55.075]                   {
[13:21:55.075]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:55.075]                     NULL
[13:21:55.075]                   }
[13:21:55.075]                   options(future.plan = NULL)
[13:21:55.075]                   if (is.na(NA_character_)) 
[13:21:55.075]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:55.075]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:55.075]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:55.075]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:55.075]                     envir = parent.frame()) 
[13:21:55.075]                   {
[13:21:55.075]                     if (is.function(workers)) 
[13:21:55.075]                       workers <- workers()
[13:21:55.075]                     workers <- structure(as.integer(workers), 
[13:21:55.075]                       class = class(workers))
[13:21:55.075]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:55.075]                       workers >= 1)
[13:21:55.075]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:55.075]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:55.075]                     }
[13:21:55.075]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:55.075]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:55.075]                       envir = envir)
[13:21:55.075]                     if (!future$lazy) 
[13:21:55.075]                       future <- run(future)
[13:21:55.075]                     invisible(future)
[13:21:55.075]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:55.075]                 }
[13:21:55.075]             }
[13:21:55.075]         }
[13:21:55.075]     })
[13:21:55.075]     if (TRUE) {
[13:21:55.075]         base::sink(type = "output", split = FALSE)
[13:21:55.075]         if (TRUE) {
[13:21:55.075]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:55.075]         }
[13:21:55.075]         else {
[13:21:55.075]             ...future.result["stdout"] <- base::list(NULL)
[13:21:55.075]         }
[13:21:55.075]         base::close(...future.stdout)
[13:21:55.075]         ...future.stdout <- NULL
[13:21:55.075]     }
[13:21:55.075]     ...future.result$conditions <- ...future.conditions
[13:21:55.075]     ...future.result$finished <- base::Sys.time()
[13:21:55.075]     ...future.result
[13:21:55.075] }
[13:21:55.078] MultisessionFuture started
[13:21:55.078] - Launch lazy future ... done
[13:21:55.078] run() for ‘MultisessionFuture’ ... done
[13:21:55.125] receiveMessageFromWorker() for ClusterFuture ...
[13:21:55.126] - Validating connection of MultisessionFuture
[13:21:55.126] - received message: FutureResult
[13:21:55.126] - Received FutureResult
[13:21:55.126] - Erased future from FutureRegistry
[13:21:55.126] result() for ClusterFuture ...
[13:21:55.127] - result already collected: FutureResult
[13:21:55.127] result() for ClusterFuture ... done
[13:21:55.127] signalConditions() ...
[13:21:55.127]  - include = ‘immediateCondition’
[13:21:55.127]  - exclude = 
[13:21:55.127]  - resignal = FALSE
[13:21:55.127]  - Number of conditions: 1
[13:21:55.127] signalConditions() ... done
[13:21:55.127] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:55.127] A MultisessionFuture was resolved
[13:21:55.127] getGlobalsAndPackages() ...
[13:21:55.128] Searching for globals...
[13:21:55.128] - globals found: [2] ‘list’, ‘stop’
[13:21:55.128] Searching for globals ... DONE
[13:21:55.128] Resolving globals: FALSE
[13:21:55.129] 
[13:21:55.129] 
[13:21:55.129] getGlobalsAndPackages() ... DONE
[13:21:55.129] run() for ‘Future’ ...
[13:21:55.129] - state: ‘created’
[13:21:55.129] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:55.144] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:55.144] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:55.144]   - Field: ‘node’
[13:21:55.144]   - Field: ‘label’
[13:21:55.144]   - Field: ‘local’
[13:21:55.144]   - Field: ‘owner’
[13:21:55.144]   - Field: ‘envir’
[13:21:55.144]   - Field: ‘workers’
[13:21:55.145]   - Field: ‘packages’
[13:21:55.145]   - Field: ‘gc’
[13:21:55.145]   - Field: ‘conditions’
[13:21:55.145]   - Field: ‘persistent’
[13:21:55.145]   - Field: ‘expr’
[13:21:55.145]   - Field: ‘uuid’
[13:21:55.145]   - Field: ‘seed’
[13:21:55.145]   - Field: ‘version’
[13:21:55.145]   - Field: ‘result’
[13:21:55.145]   - Field: ‘asynchronous’
[13:21:55.145]   - Field: ‘calls’
[13:21:55.146]   - Field: ‘globals’
[13:21:55.146]   - Field: ‘stdout’
[13:21:55.146]   - Field: ‘earlySignal’
[13:21:55.146]   - Field: ‘lazy’
[13:21:55.146]   - Field: ‘state’
[13:21:55.146] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:55.146] - Launch lazy future ...
[13:21:55.146] Packages needed by the future expression (n = 0): <none>
[13:21:55.147] Packages needed by future strategies (n = 0): <none>
[13:21:55.147] {
[13:21:55.147]     {
[13:21:55.147]         {
[13:21:55.147]             ...future.startTime <- base::Sys.time()
[13:21:55.147]             {
[13:21:55.147]                 {
[13:21:55.147]                   {
[13:21:55.147]                     {
[13:21:55.147]                       base::local({
[13:21:55.147]                         has_future <- base::requireNamespace("future", 
[13:21:55.147]                           quietly = TRUE)
[13:21:55.147]                         if (has_future) {
[13:21:55.147]                           ns <- base::getNamespace("future")
[13:21:55.147]                           version <- ns[[".package"]][["version"]]
[13:21:55.147]                           if (is.null(version)) 
[13:21:55.147]                             version <- utils::packageVersion("future")
[13:21:55.147]                         }
[13:21:55.147]                         else {
[13:21:55.147]                           version <- NULL
[13:21:55.147]                         }
[13:21:55.147]                         if (!has_future || version < "1.8.0") {
[13:21:55.147]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:55.147]                             "", base::R.version$version.string), 
[13:21:55.147]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:55.147]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:55.147]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:55.147]                               "release", "version")], collapse = " "), 
[13:21:55.147]                             hostname = base::Sys.info()[["nodename"]])
[13:21:55.147]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:55.147]                             info)
[13:21:55.147]                           info <- base::paste(info, collapse = "; ")
[13:21:55.147]                           if (!has_future) {
[13:21:55.147]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:55.147]                               info)
[13:21:55.147]                           }
[13:21:55.147]                           else {
[13:21:55.147]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:55.147]                               info, version)
[13:21:55.147]                           }
[13:21:55.147]                           base::stop(msg)
[13:21:55.147]                         }
[13:21:55.147]                       })
[13:21:55.147]                     }
[13:21:55.147]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:55.147]                     base::options(mc.cores = 1L)
[13:21:55.147]                   }
[13:21:55.147]                   options(future.plan = NULL)
[13:21:55.147]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:55.147]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:55.147]                 }
[13:21:55.147]                 ...future.workdir <- getwd()
[13:21:55.147]             }
[13:21:55.147]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:55.147]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:55.147]         }
[13:21:55.147]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:55.147]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:55.147]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:55.147]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:55.147]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:55.147]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:55.147]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:55.147]             base::names(...future.oldOptions))
[13:21:55.147]     }
[13:21:55.147]     if (FALSE) {
[13:21:55.147]     }
[13:21:55.147]     else {
[13:21:55.147]         if (TRUE) {
[13:21:55.147]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:55.147]                 open = "w")
[13:21:55.147]         }
[13:21:55.147]         else {
[13:21:55.147]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:55.147]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:55.147]         }
[13:21:55.147]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:55.147]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:55.147]             base::sink(type = "output", split = FALSE)
[13:21:55.147]             base::close(...future.stdout)
[13:21:55.147]         }, add = TRUE)
[13:21:55.147]     }
[13:21:55.147]     ...future.frame <- base::sys.nframe()
[13:21:55.147]     ...future.conditions <- base::list()
[13:21:55.147]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:55.147]     if (FALSE) {
[13:21:55.147]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:55.147]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:55.147]     }
[13:21:55.147]     ...future.result <- base::tryCatch({
[13:21:55.147]         base::withCallingHandlers({
[13:21:55.147]             ...future.value <- base::withVisible(base::local({
[13:21:55.147]                 ...future.makeSendCondition <- local({
[13:21:55.147]                   sendCondition <- NULL
[13:21:55.147]                   function(frame = 1L) {
[13:21:55.147]                     if (is.function(sendCondition)) 
[13:21:55.147]                       return(sendCondition)
[13:21:55.147]                     ns <- getNamespace("parallel")
[13:21:55.147]                     if (exists("sendData", mode = "function", 
[13:21:55.147]                       envir = ns)) {
[13:21:55.147]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:55.147]                         envir = ns)
[13:21:55.147]                       envir <- sys.frame(frame)
[13:21:55.147]                       master <- NULL
[13:21:55.147]                       while (!identical(envir, .GlobalEnv) && 
[13:21:55.147]                         !identical(envir, emptyenv())) {
[13:21:55.147]                         if (exists("master", mode = "list", envir = envir, 
[13:21:55.147]                           inherits = FALSE)) {
[13:21:55.147]                           master <- get("master", mode = "list", 
[13:21:55.147]                             envir = envir, inherits = FALSE)
[13:21:55.147]                           if (inherits(master, c("SOCKnode", 
[13:21:55.147]                             "SOCK0node"))) {
[13:21:55.147]                             sendCondition <<- function(cond) {
[13:21:55.147]                               data <- list(type = "VALUE", value = cond, 
[13:21:55.147]                                 success = TRUE)
[13:21:55.147]                               parallel_sendData(master, data)
[13:21:55.147]                             }
[13:21:55.147]                             return(sendCondition)
[13:21:55.147]                           }
[13:21:55.147]                         }
[13:21:55.147]                         frame <- frame + 1L
[13:21:55.147]                         envir <- sys.frame(frame)
[13:21:55.147]                       }
[13:21:55.147]                     }
[13:21:55.147]                     sendCondition <<- function(cond) NULL
[13:21:55.147]                   }
[13:21:55.147]                 })
[13:21:55.147]                 withCallingHandlers({
[13:21:55.147]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:21:55.147]                 }, immediateCondition = function(cond) {
[13:21:55.147]                   sendCondition <- ...future.makeSendCondition()
[13:21:55.147]                   sendCondition(cond)
[13:21:55.147]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:55.147]                   {
[13:21:55.147]                     inherits <- base::inherits
[13:21:55.147]                     invokeRestart <- base::invokeRestart
[13:21:55.147]                     is.null <- base::is.null
[13:21:55.147]                     muffled <- FALSE
[13:21:55.147]                     if (inherits(cond, "message")) {
[13:21:55.147]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:55.147]                       if (muffled) 
[13:21:55.147]                         invokeRestart("muffleMessage")
[13:21:55.147]                     }
[13:21:55.147]                     else if (inherits(cond, "warning")) {
[13:21:55.147]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:55.147]                       if (muffled) 
[13:21:55.147]                         invokeRestart("muffleWarning")
[13:21:55.147]                     }
[13:21:55.147]                     else if (inherits(cond, "condition")) {
[13:21:55.147]                       if (!is.null(pattern)) {
[13:21:55.147]                         computeRestarts <- base::computeRestarts
[13:21:55.147]                         grepl <- base::grepl
[13:21:55.147]                         restarts <- computeRestarts(cond)
[13:21:55.147]                         for (restart in restarts) {
[13:21:55.147]                           name <- restart$name
[13:21:55.147]                           if (is.null(name)) 
[13:21:55.147]                             next
[13:21:55.147]                           if (!grepl(pattern, name)) 
[13:21:55.147]                             next
[13:21:55.147]                           invokeRestart(restart)
[13:21:55.147]                           muffled <- TRUE
[13:21:55.147]                           break
[13:21:55.147]                         }
[13:21:55.147]                       }
[13:21:55.147]                     }
[13:21:55.147]                     invisible(muffled)
[13:21:55.147]                   }
[13:21:55.147]                   muffleCondition(cond)
[13:21:55.147]                 })
[13:21:55.147]             }))
[13:21:55.147]             future::FutureResult(value = ...future.value$value, 
[13:21:55.147]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:55.147]                   ...future.rng), globalenv = if (FALSE) 
[13:21:55.147]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:55.147]                     ...future.globalenv.names))
[13:21:55.147]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:55.147]         }, condition = base::local({
[13:21:55.147]             c <- base::c
[13:21:55.147]             inherits <- base::inherits
[13:21:55.147]             invokeRestart <- base::invokeRestart
[13:21:55.147]             length <- base::length
[13:21:55.147]             list <- base::list
[13:21:55.147]             seq.int <- base::seq.int
[13:21:55.147]             signalCondition <- base::signalCondition
[13:21:55.147]             sys.calls <- base::sys.calls
[13:21:55.147]             `[[` <- base::`[[`
[13:21:55.147]             `+` <- base::`+`
[13:21:55.147]             `<<-` <- base::`<<-`
[13:21:55.147]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:55.147]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:55.147]                   3L)]
[13:21:55.147]             }
[13:21:55.147]             function(cond) {
[13:21:55.147]                 is_error <- inherits(cond, "error")
[13:21:55.147]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:55.147]                   NULL)
[13:21:55.147]                 if (is_error) {
[13:21:55.147]                   sessionInformation <- function() {
[13:21:55.147]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:55.147]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:55.147]                       search = base::search(), system = base::Sys.info())
[13:21:55.147]                   }
[13:21:55.147]                   ...future.conditions[[length(...future.conditions) + 
[13:21:55.147]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:55.147]                     cond$call), session = sessionInformation(), 
[13:21:55.147]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:55.147]                   signalCondition(cond)
[13:21:55.147]                 }
[13:21:55.147]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:55.147]                 "immediateCondition"))) {
[13:21:55.147]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:55.147]                   ...future.conditions[[length(...future.conditions) + 
[13:21:55.147]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:55.147]                   if (TRUE && !signal) {
[13:21:55.147]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:55.147]                     {
[13:21:55.147]                       inherits <- base::inherits
[13:21:55.147]                       invokeRestart <- base::invokeRestart
[13:21:55.147]                       is.null <- base::is.null
[13:21:55.147]                       muffled <- FALSE
[13:21:55.147]                       if (inherits(cond, "message")) {
[13:21:55.147]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:55.147]                         if (muffled) 
[13:21:55.147]                           invokeRestart("muffleMessage")
[13:21:55.147]                       }
[13:21:55.147]                       else if (inherits(cond, "warning")) {
[13:21:55.147]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:55.147]                         if (muffled) 
[13:21:55.147]                           invokeRestart("muffleWarning")
[13:21:55.147]                       }
[13:21:55.147]                       else if (inherits(cond, "condition")) {
[13:21:55.147]                         if (!is.null(pattern)) {
[13:21:55.147]                           computeRestarts <- base::computeRestarts
[13:21:55.147]                           grepl <- base::grepl
[13:21:55.147]                           restarts <- computeRestarts(cond)
[13:21:55.147]                           for (restart in restarts) {
[13:21:55.147]                             name <- restart$name
[13:21:55.147]                             if (is.null(name)) 
[13:21:55.147]                               next
[13:21:55.147]                             if (!grepl(pattern, name)) 
[13:21:55.147]                               next
[13:21:55.147]                             invokeRestart(restart)
[13:21:55.147]                             muffled <- TRUE
[13:21:55.147]                             break
[13:21:55.147]                           }
[13:21:55.147]                         }
[13:21:55.147]                       }
[13:21:55.147]                       invisible(muffled)
[13:21:55.147]                     }
[13:21:55.147]                     muffleCondition(cond, pattern = "^muffle")
[13:21:55.147]                   }
[13:21:55.147]                 }
[13:21:55.147]                 else {
[13:21:55.147]                   if (TRUE) {
[13:21:55.147]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:55.147]                     {
[13:21:55.147]                       inherits <- base::inherits
[13:21:55.147]                       invokeRestart <- base::invokeRestart
[13:21:55.147]                       is.null <- base::is.null
[13:21:55.147]                       muffled <- FALSE
[13:21:55.147]                       if (inherits(cond, "message")) {
[13:21:55.147]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:55.147]                         if (muffled) 
[13:21:55.147]                           invokeRestart("muffleMessage")
[13:21:55.147]                       }
[13:21:55.147]                       else if (inherits(cond, "warning")) {
[13:21:55.147]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:55.147]                         if (muffled) 
[13:21:55.147]                           invokeRestart("muffleWarning")
[13:21:55.147]                       }
[13:21:55.147]                       else if (inherits(cond, "condition")) {
[13:21:55.147]                         if (!is.null(pattern)) {
[13:21:55.147]                           computeRestarts <- base::computeRestarts
[13:21:55.147]                           grepl <- base::grepl
[13:21:55.147]                           restarts <- computeRestarts(cond)
[13:21:55.147]                           for (restart in restarts) {
[13:21:55.147]                             name <- restart$name
[13:21:55.147]                             if (is.null(name)) 
[13:21:55.147]                               next
[13:21:55.147]                             if (!grepl(pattern, name)) 
[13:21:55.147]                               next
[13:21:55.147]                             invokeRestart(restart)
[13:21:55.147]                             muffled <- TRUE
[13:21:55.147]                             break
[13:21:55.147]                           }
[13:21:55.147]                         }
[13:21:55.147]                       }
[13:21:55.147]                       invisible(muffled)
[13:21:55.147]                     }
[13:21:55.147]                     muffleCondition(cond, pattern = "^muffle")
[13:21:55.147]                   }
[13:21:55.147]                 }
[13:21:55.147]             }
[13:21:55.147]         }))
[13:21:55.147]     }, error = function(ex) {
[13:21:55.147]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:55.147]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:55.147]                 ...future.rng), started = ...future.startTime, 
[13:21:55.147]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:55.147]             version = "1.8"), class = "FutureResult")
[13:21:55.147]     }, finally = {
[13:21:55.147]         if (!identical(...future.workdir, getwd())) 
[13:21:55.147]             setwd(...future.workdir)
[13:21:55.147]         {
[13:21:55.147]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:55.147]                 ...future.oldOptions$nwarnings <- NULL
[13:21:55.147]             }
[13:21:55.147]             base::options(...future.oldOptions)
[13:21:55.147]             if (.Platform$OS.type == "windows") {
[13:21:55.147]                 old_names <- names(...future.oldEnvVars)
[13:21:55.147]                 envs <- base::Sys.getenv()
[13:21:55.147]                 names <- names(envs)
[13:21:55.147]                 common <- intersect(names, old_names)
[13:21:55.147]                 added <- setdiff(names, old_names)
[13:21:55.147]                 removed <- setdiff(old_names, names)
[13:21:55.147]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:55.147]                   envs[common]]
[13:21:55.147]                 NAMES <- toupper(changed)
[13:21:55.147]                 args <- list()
[13:21:55.147]                 for (kk in seq_along(NAMES)) {
[13:21:55.147]                   name <- changed[[kk]]
[13:21:55.147]                   NAME <- NAMES[[kk]]
[13:21:55.147]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:55.147]                     next
[13:21:55.147]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:55.147]                 }
[13:21:55.147]                 NAMES <- toupper(added)
[13:21:55.147]                 for (kk in seq_along(NAMES)) {
[13:21:55.147]                   name <- added[[kk]]
[13:21:55.147]                   NAME <- NAMES[[kk]]
[13:21:55.147]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:55.147]                     next
[13:21:55.147]                   args[[name]] <- ""
[13:21:55.147]                 }
[13:21:55.147]                 NAMES <- toupper(removed)
[13:21:55.147]                 for (kk in seq_along(NAMES)) {
[13:21:55.147]                   name <- removed[[kk]]
[13:21:55.147]                   NAME <- NAMES[[kk]]
[13:21:55.147]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:55.147]                     next
[13:21:55.147]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:55.147]                 }
[13:21:55.147]                 if (length(args) > 0) 
[13:21:55.147]                   base::do.call(base::Sys.setenv, args = args)
[13:21:55.147]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:55.147]             }
[13:21:55.147]             else {
[13:21:55.147]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:55.147]             }
[13:21:55.147]             {
[13:21:55.147]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:55.147]                   0L) {
[13:21:55.147]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:55.147]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:55.147]                   base::options(opts)
[13:21:55.147]                 }
[13:21:55.147]                 {
[13:21:55.147]                   {
[13:21:55.147]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:55.147]                     NULL
[13:21:55.147]                   }
[13:21:55.147]                   options(future.plan = NULL)
[13:21:55.147]                   if (is.na(NA_character_)) 
[13:21:55.147]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:55.147]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:55.147]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:55.147]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:55.147]                     envir = parent.frame()) 
[13:21:55.147]                   {
[13:21:55.147]                     if (is.function(workers)) 
[13:21:55.147]                       workers <- workers()
[13:21:55.147]                     workers <- structure(as.integer(workers), 
[13:21:55.147]                       class = class(workers))
[13:21:55.147]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:55.147]                       workers >= 1)
[13:21:55.147]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:55.147]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:55.147]                     }
[13:21:55.147]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:55.147]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:55.147]                       envir = envir)
[13:21:55.147]                     if (!future$lazy) 
[13:21:55.147]                       future <- run(future)
[13:21:55.147]                     invisible(future)
[13:21:55.147]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:55.147]                 }
[13:21:55.147]             }
[13:21:55.147]         }
[13:21:55.147]     })
[13:21:55.147]     if (TRUE) {
[13:21:55.147]         base::sink(type = "output", split = FALSE)
[13:21:55.147]         if (TRUE) {
[13:21:55.147]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:55.147]         }
[13:21:55.147]         else {
[13:21:55.147]             ...future.result["stdout"] <- base::list(NULL)
[13:21:55.147]         }
[13:21:55.147]         base::close(...future.stdout)
[13:21:55.147]         ...future.stdout <- NULL
[13:21:55.147]     }
[13:21:55.147]     ...future.result$conditions <- ...future.conditions
[13:21:55.147]     ...future.result$finished <- base::Sys.time()
[13:21:55.147]     ...future.result
[13:21:55.147] }
[13:21:55.150] MultisessionFuture started
[13:21:55.150] - Launch lazy future ... done
[13:21:55.150] run() for ‘MultisessionFuture’ ... done
[13:21:55.198] receiveMessageFromWorker() for ClusterFuture ...
[13:21:55.198] - Validating connection of MultisessionFuture
[13:21:55.198] - received message: FutureResult
[13:21:55.198] - Received FutureResult
[13:21:55.198] - Erased future from FutureRegistry
[13:21:55.199] result() for ClusterFuture ...
[13:21:55.199] - result already collected: FutureResult
[13:21:55.199] result() for ClusterFuture ... done
[13:21:55.199] signalConditions() ...
[13:21:55.199]  - include = ‘immediateCondition’
[13:21:55.199]  - exclude = 
[13:21:55.199]  - resignal = FALSE
[13:21:55.199]  - Number of conditions: 1
[13:21:55.199] signalConditions() ... done
[13:21:55.199] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:55.199] A MultisessionFuture was resolved
- result = TRUE, recursive = 0 ... DONE
- result = TRUE, recursive = 1 ...
[13:21:55.200] getGlobalsAndPackages() ...
[13:21:55.200] Searching for globals...
[13:21:55.201] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:21:55.201] Searching for globals ... DONE
[13:21:55.201] Resolving globals: FALSE
[13:21:55.202] 
[13:21:55.202] 
[13:21:55.202] getGlobalsAndPackages() ... DONE
[13:21:55.202] run() for ‘Future’ ...
[13:21:55.202] - state: ‘created’
[13:21:55.202] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:55.217] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:55.217] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:55.217]   - Field: ‘node’
[13:21:55.217]   - Field: ‘label’
[13:21:55.217]   - Field: ‘local’
[13:21:55.217]   - Field: ‘owner’
[13:21:55.217]   - Field: ‘envir’
[13:21:55.217]   - Field: ‘workers’
[13:21:55.217]   - Field: ‘packages’
[13:21:55.217]   - Field: ‘gc’
[13:21:55.218]   - Field: ‘conditions’
[13:21:55.218]   - Field: ‘persistent’
[13:21:55.218]   - Field: ‘expr’
[13:21:55.218]   - Field: ‘uuid’
[13:21:55.218]   - Field: ‘seed’
[13:21:55.218]   - Field: ‘version’
[13:21:55.218]   - Field: ‘result’
[13:21:55.218]   - Field: ‘asynchronous’
[13:21:55.218]   - Field: ‘calls’
[13:21:55.218]   - Field: ‘globals’
[13:21:55.218]   - Field: ‘stdout’
[13:21:55.219]   - Field: ‘earlySignal’
[13:21:55.219]   - Field: ‘lazy’
[13:21:55.219]   - Field: ‘state’
[13:21:55.219] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:55.219] - Launch lazy future ...
[13:21:55.219] Packages needed by the future expression (n = 0): <none>
[13:21:55.219] Packages needed by future strategies (n = 0): <none>
[13:21:55.220] {
[13:21:55.220]     {
[13:21:55.220]         {
[13:21:55.220]             ...future.startTime <- base::Sys.time()
[13:21:55.220]             {
[13:21:55.220]                 {
[13:21:55.220]                   {
[13:21:55.220]                     {
[13:21:55.220]                       base::local({
[13:21:55.220]                         has_future <- base::requireNamespace("future", 
[13:21:55.220]                           quietly = TRUE)
[13:21:55.220]                         if (has_future) {
[13:21:55.220]                           ns <- base::getNamespace("future")
[13:21:55.220]                           version <- ns[[".package"]][["version"]]
[13:21:55.220]                           if (is.null(version)) 
[13:21:55.220]                             version <- utils::packageVersion("future")
[13:21:55.220]                         }
[13:21:55.220]                         else {
[13:21:55.220]                           version <- NULL
[13:21:55.220]                         }
[13:21:55.220]                         if (!has_future || version < "1.8.0") {
[13:21:55.220]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:55.220]                             "", base::R.version$version.string), 
[13:21:55.220]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:55.220]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:55.220]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:55.220]                               "release", "version")], collapse = " "), 
[13:21:55.220]                             hostname = base::Sys.info()[["nodename"]])
[13:21:55.220]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:55.220]                             info)
[13:21:55.220]                           info <- base::paste(info, collapse = "; ")
[13:21:55.220]                           if (!has_future) {
[13:21:55.220]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:55.220]                               info)
[13:21:55.220]                           }
[13:21:55.220]                           else {
[13:21:55.220]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:55.220]                               info, version)
[13:21:55.220]                           }
[13:21:55.220]                           base::stop(msg)
[13:21:55.220]                         }
[13:21:55.220]                       })
[13:21:55.220]                     }
[13:21:55.220]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:55.220]                     base::options(mc.cores = 1L)
[13:21:55.220]                   }
[13:21:55.220]                   options(future.plan = NULL)
[13:21:55.220]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:55.220]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:55.220]                 }
[13:21:55.220]                 ...future.workdir <- getwd()
[13:21:55.220]             }
[13:21:55.220]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:55.220]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:55.220]         }
[13:21:55.220]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:55.220]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:55.220]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:55.220]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:55.220]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:55.220]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:55.220]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:55.220]             base::names(...future.oldOptions))
[13:21:55.220]     }
[13:21:55.220]     if (FALSE) {
[13:21:55.220]     }
[13:21:55.220]     else {
[13:21:55.220]         if (TRUE) {
[13:21:55.220]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:55.220]                 open = "w")
[13:21:55.220]         }
[13:21:55.220]         else {
[13:21:55.220]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:55.220]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:55.220]         }
[13:21:55.220]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:55.220]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:55.220]             base::sink(type = "output", split = FALSE)
[13:21:55.220]             base::close(...future.stdout)
[13:21:55.220]         }, add = TRUE)
[13:21:55.220]     }
[13:21:55.220]     ...future.frame <- base::sys.nframe()
[13:21:55.220]     ...future.conditions <- base::list()
[13:21:55.220]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:55.220]     if (FALSE) {
[13:21:55.220]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:55.220]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:55.220]     }
[13:21:55.220]     ...future.result <- base::tryCatch({
[13:21:55.220]         base::withCallingHandlers({
[13:21:55.220]             ...future.value <- base::withVisible(base::local({
[13:21:55.220]                 ...future.makeSendCondition <- local({
[13:21:55.220]                   sendCondition <- NULL
[13:21:55.220]                   function(frame = 1L) {
[13:21:55.220]                     if (is.function(sendCondition)) 
[13:21:55.220]                       return(sendCondition)
[13:21:55.220]                     ns <- getNamespace("parallel")
[13:21:55.220]                     if (exists("sendData", mode = "function", 
[13:21:55.220]                       envir = ns)) {
[13:21:55.220]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:55.220]                         envir = ns)
[13:21:55.220]                       envir <- sys.frame(frame)
[13:21:55.220]                       master <- NULL
[13:21:55.220]                       while (!identical(envir, .GlobalEnv) && 
[13:21:55.220]                         !identical(envir, emptyenv())) {
[13:21:55.220]                         if (exists("master", mode = "list", envir = envir, 
[13:21:55.220]                           inherits = FALSE)) {
[13:21:55.220]                           master <- get("master", mode = "list", 
[13:21:55.220]                             envir = envir, inherits = FALSE)
[13:21:55.220]                           if (inherits(master, c("SOCKnode", 
[13:21:55.220]                             "SOCK0node"))) {
[13:21:55.220]                             sendCondition <<- function(cond) {
[13:21:55.220]                               data <- list(type = "VALUE", value = cond, 
[13:21:55.220]                                 success = TRUE)
[13:21:55.220]                               parallel_sendData(master, data)
[13:21:55.220]                             }
[13:21:55.220]                             return(sendCondition)
[13:21:55.220]                           }
[13:21:55.220]                         }
[13:21:55.220]                         frame <- frame + 1L
[13:21:55.220]                         envir <- sys.frame(frame)
[13:21:55.220]                       }
[13:21:55.220]                     }
[13:21:55.220]                     sendCondition <<- function(cond) NULL
[13:21:55.220]                   }
[13:21:55.220]                 })
[13:21:55.220]                 withCallingHandlers({
[13:21:55.220]                   {
[13:21:55.220]                     Sys.sleep(0.5)
[13:21:55.220]                     list(a = 1, b = 42L)
[13:21:55.220]                   }
[13:21:55.220]                 }, immediateCondition = function(cond) {
[13:21:55.220]                   sendCondition <- ...future.makeSendCondition()
[13:21:55.220]                   sendCondition(cond)
[13:21:55.220]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:55.220]                   {
[13:21:55.220]                     inherits <- base::inherits
[13:21:55.220]                     invokeRestart <- base::invokeRestart
[13:21:55.220]                     is.null <- base::is.null
[13:21:55.220]                     muffled <- FALSE
[13:21:55.220]                     if (inherits(cond, "message")) {
[13:21:55.220]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:55.220]                       if (muffled) 
[13:21:55.220]                         invokeRestart("muffleMessage")
[13:21:55.220]                     }
[13:21:55.220]                     else if (inherits(cond, "warning")) {
[13:21:55.220]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:55.220]                       if (muffled) 
[13:21:55.220]                         invokeRestart("muffleWarning")
[13:21:55.220]                     }
[13:21:55.220]                     else if (inherits(cond, "condition")) {
[13:21:55.220]                       if (!is.null(pattern)) {
[13:21:55.220]                         computeRestarts <- base::computeRestarts
[13:21:55.220]                         grepl <- base::grepl
[13:21:55.220]                         restarts <- computeRestarts(cond)
[13:21:55.220]                         for (restart in restarts) {
[13:21:55.220]                           name <- restart$name
[13:21:55.220]                           if (is.null(name)) 
[13:21:55.220]                             next
[13:21:55.220]                           if (!grepl(pattern, name)) 
[13:21:55.220]                             next
[13:21:55.220]                           invokeRestart(restart)
[13:21:55.220]                           muffled <- TRUE
[13:21:55.220]                           break
[13:21:55.220]                         }
[13:21:55.220]                       }
[13:21:55.220]                     }
[13:21:55.220]                     invisible(muffled)
[13:21:55.220]                   }
[13:21:55.220]                   muffleCondition(cond)
[13:21:55.220]                 })
[13:21:55.220]             }))
[13:21:55.220]             future::FutureResult(value = ...future.value$value, 
[13:21:55.220]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:55.220]                   ...future.rng), globalenv = if (FALSE) 
[13:21:55.220]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:55.220]                     ...future.globalenv.names))
[13:21:55.220]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:55.220]         }, condition = base::local({
[13:21:55.220]             c <- base::c
[13:21:55.220]             inherits <- base::inherits
[13:21:55.220]             invokeRestart <- base::invokeRestart
[13:21:55.220]             length <- base::length
[13:21:55.220]             list <- base::list
[13:21:55.220]             seq.int <- base::seq.int
[13:21:55.220]             signalCondition <- base::signalCondition
[13:21:55.220]             sys.calls <- base::sys.calls
[13:21:55.220]             `[[` <- base::`[[`
[13:21:55.220]             `+` <- base::`+`
[13:21:55.220]             `<<-` <- base::`<<-`
[13:21:55.220]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:55.220]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:55.220]                   3L)]
[13:21:55.220]             }
[13:21:55.220]             function(cond) {
[13:21:55.220]                 is_error <- inherits(cond, "error")
[13:21:55.220]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:55.220]                   NULL)
[13:21:55.220]                 if (is_error) {
[13:21:55.220]                   sessionInformation <- function() {
[13:21:55.220]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:55.220]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:55.220]                       search = base::search(), system = base::Sys.info())
[13:21:55.220]                   }
[13:21:55.220]                   ...future.conditions[[length(...future.conditions) + 
[13:21:55.220]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:55.220]                     cond$call), session = sessionInformation(), 
[13:21:55.220]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:55.220]                   signalCondition(cond)
[13:21:55.220]                 }
[13:21:55.220]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:55.220]                 "immediateCondition"))) {
[13:21:55.220]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:55.220]                   ...future.conditions[[length(...future.conditions) + 
[13:21:55.220]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:55.220]                   if (TRUE && !signal) {
[13:21:55.220]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:55.220]                     {
[13:21:55.220]                       inherits <- base::inherits
[13:21:55.220]                       invokeRestart <- base::invokeRestart
[13:21:55.220]                       is.null <- base::is.null
[13:21:55.220]                       muffled <- FALSE
[13:21:55.220]                       if (inherits(cond, "message")) {
[13:21:55.220]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:55.220]                         if (muffled) 
[13:21:55.220]                           invokeRestart("muffleMessage")
[13:21:55.220]                       }
[13:21:55.220]                       else if (inherits(cond, "warning")) {
[13:21:55.220]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:55.220]                         if (muffled) 
[13:21:55.220]                           invokeRestart("muffleWarning")
[13:21:55.220]                       }
[13:21:55.220]                       else if (inherits(cond, "condition")) {
[13:21:55.220]                         if (!is.null(pattern)) {
[13:21:55.220]                           computeRestarts <- base::computeRestarts
[13:21:55.220]                           grepl <- base::grepl
[13:21:55.220]                           restarts <- computeRestarts(cond)
[13:21:55.220]                           for (restart in restarts) {
[13:21:55.220]                             name <- restart$name
[13:21:55.220]                             if (is.null(name)) 
[13:21:55.220]                               next
[13:21:55.220]                             if (!grepl(pattern, name)) 
[13:21:55.220]                               next
[13:21:55.220]                             invokeRestart(restart)
[13:21:55.220]                             muffled <- TRUE
[13:21:55.220]                             break
[13:21:55.220]                           }
[13:21:55.220]                         }
[13:21:55.220]                       }
[13:21:55.220]                       invisible(muffled)
[13:21:55.220]                     }
[13:21:55.220]                     muffleCondition(cond, pattern = "^muffle")
[13:21:55.220]                   }
[13:21:55.220]                 }
[13:21:55.220]                 else {
[13:21:55.220]                   if (TRUE) {
[13:21:55.220]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:55.220]                     {
[13:21:55.220]                       inherits <- base::inherits
[13:21:55.220]                       invokeRestart <- base::invokeRestart
[13:21:55.220]                       is.null <- base::is.null
[13:21:55.220]                       muffled <- FALSE
[13:21:55.220]                       if (inherits(cond, "message")) {
[13:21:55.220]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:55.220]                         if (muffled) 
[13:21:55.220]                           invokeRestart("muffleMessage")
[13:21:55.220]                       }
[13:21:55.220]                       else if (inherits(cond, "warning")) {
[13:21:55.220]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:55.220]                         if (muffled) 
[13:21:55.220]                           invokeRestart("muffleWarning")
[13:21:55.220]                       }
[13:21:55.220]                       else if (inherits(cond, "condition")) {
[13:21:55.220]                         if (!is.null(pattern)) {
[13:21:55.220]                           computeRestarts <- base::computeRestarts
[13:21:55.220]                           grepl <- base::grepl
[13:21:55.220]                           restarts <- computeRestarts(cond)
[13:21:55.220]                           for (restart in restarts) {
[13:21:55.220]                             name <- restart$name
[13:21:55.220]                             if (is.null(name)) 
[13:21:55.220]                               next
[13:21:55.220]                             if (!grepl(pattern, name)) 
[13:21:55.220]                               next
[13:21:55.220]                             invokeRestart(restart)
[13:21:55.220]                             muffled <- TRUE
[13:21:55.220]                             break
[13:21:55.220]                           }
[13:21:55.220]                         }
[13:21:55.220]                       }
[13:21:55.220]                       invisible(muffled)
[13:21:55.220]                     }
[13:21:55.220]                     muffleCondition(cond, pattern = "^muffle")
[13:21:55.220]                   }
[13:21:55.220]                 }
[13:21:55.220]             }
[13:21:55.220]         }))
[13:21:55.220]     }, error = function(ex) {
[13:21:55.220]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:55.220]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:55.220]                 ...future.rng), started = ...future.startTime, 
[13:21:55.220]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:55.220]             version = "1.8"), class = "FutureResult")
[13:21:55.220]     }, finally = {
[13:21:55.220]         if (!identical(...future.workdir, getwd())) 
[13:21:55.220]             setwd(...future.workdir)
[13:21:55.220]         {
[13:21:55.220]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:55.220]                 ...future.oldOptions$nwarnings <- NULL
[13:21:55.220]             }
[13:21:55.220]             base::options(...future.oldOptions)
[13:21:55.220]             if (.Platform$OS.type == "windows") {
[13:21:55.220]                 old_names <- names(...future.oldEnvVars)
[13:21:55.220]                 envs <- base::Sys.getenv()
[13:21:55.220]                 names <- names(envs)
[13:21:55.220]                 common <- intersect(names, old_names)
[13:21:55.220]                 added <- setdiff(names, old_names)
[13:21:55.220]                 removed <- setdiff(old_names, names)
[13:21:55.220]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:55.220]                   envs[common]]
[13:21:55.220]                 NAMES <- toupper(changed)
[13:21:55.220]                 args <- list()
[13:21:55.220]                 for (kk in seq_along(NAMES)) {
[13:21:55.220]                   name <- changed[[kk]]
[13:21:55.220]                   NAME <- NAMES[[kk]]
[13:21:55.220]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:55.220]                     next
[13:21:55.220]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:55.220]                 }
[13:21:55.220]                 NAMES <- toupper(added)
[13:21:55.220]                 for (kk in seq_along(NAMES)) {
[13:21:55.220]                   name <- added[[kk]]
[13:21:55.220]                   NAME <- NAMES[[kk]]
[13:21:55.220]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:55.220]                     next
[13:21:55.220]                   args[[name]] <- ""
[13:21:55.220]                 }
[13:21:55.220]                 NAMES <- toupper(removed)
[13:21:55.220]                 for (kk in seq_along(NAMES)) {
[13:21:55.220]                   name <- removed[[kk]]
[13:21:55.220]                   NAME <- NAMES[[kk]]
[13:21:55.220]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:55.220]                     next
[13:21:55.220]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:55.220]                 }
[13:21:55.220]                 if (length(args) > 0) 
[13:21:55.220]                   base::do.call(base::Sys.setenv, args = args)
[13:21:55.220]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:55.220]             }
[13:21:55.220]             else {
[13:21:55.220]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:55.220]             }
[13:21:55.220]             {
[13:21:55.220]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:55.220]                   0L) {
[13:21:55.220]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:55.220]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:55.220]                   base::options(opts)
[13:21:55.220]                 }
[13:21:55.220]                 {
[13:21:55.220]                   {
[13:21:55.220]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:55.220]                     NULL
[13:21:55.220]                   }
[13:21:55.220]                   options(future.plan = NULL)
[13:21:55.220]                   if (is.na(NA_character_)) 
[13:21:55.220]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:55.220]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:55.220]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:55.220]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:55.220]                     envir = parent.frame()) 
[13:21:55.220]                   {
[13:21:55.220]                     if (is.function(workers)) 
[13:21:55.220]                       workers <- workers()
[13:21:55.220]                     workers <- structure(as.integer(workers), 
[13:21:55.220]                       class = class(workers))
[13:21:55.220]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:55.220]                       workers >= 1)
[13:21:55.220]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:55.220]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:55.220]                     }
[13:21:55.220]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:55.220]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:55.220]                       envir = envir)
[13:21:55.220]                     if (!future$lazy) 
[13:21:55.220]                       future <- run(future)
[13:21:55.220]                     invisible(future)
[13:21:55.220]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:55.220]                 }
[13:21:55.220]             }
[13:21:55.220]         }
[13:21:55.220]     })
[13:21:55.220]     if (TRUE) {
[13:21:55.220]         base::sink(type = "output", split = FALSE)
[13:21:55.220]         if (TRUE) {
[13:21:55.220]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:55.220]         }
[13:21:55.220]         else {
[13:21:55.220]             ...future.result["stdout"] <- base::list(NULL)
[13:21:55.220]         }
[13:21:55.220]         base::close(...future.stdout)
[13:21:55.220]         ...future.stdout <- NULL
[13:21:55.220]     }
[13:21:55.220]     ...future.result$conditions <- ...future.conditions
[13:21:55.220]     ...future.result$finished <- base::Sys.time()
[13:21:55.220]     ...future.result
[13:21:55.220] }
[13:21:55.223] MultisessionFuture started
[13:21:55.223] - Launch lazy future ... done
[13:21:55.223] run() for ‘MultisessionFuture’ ... done
[13:21:55.771] receiveMessageFromWorker() for ClusterFuture ...
[13:21:55.771] - Validating connection of MultisessionFuture
[13:21:55.771] - received message: FutureResult
[13:21:55.771] - Received FutureResult
[13:21:55.771] - Erased future from FutureRegistry
[13:21:55.772] result() for ClusterFuture ...
[13:21:55.772] - result already collected: FutureResult
[13:21:55.772] result() for ClusterFuture ... done
[13:21:55.772] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:55.775] resolve() on list ...
[13:21:55.775]  recursive: 0
[13:21:55.775]  length: 2
[13:21:55.775]  elements: ‘a’, ‘b’
[13:21:55.775]  length: 1 (resolved future 1)
[13:21:55.775]  length: 0 (resolved future 2)
[13:21:55.775] resolve() on list ... DONE
[13:21:55.775] A MultisessionFuture was resolved (and resolved itself)
[13:21:55.776] getGlobalsAndPackages() ...
[13:21:55.776] Searching for globals...
[13:21:55.777] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:21:55.777] Searching for globals ... DONE
[13:21:55.777] Resolving globals: FALSE
[13:21:55.777] 
[13:21:55.778] 
[13:21:55.778] getGlobalsAndPackages() ... DONE
[13:21:55.778] run() for ‘Future’ ...
[13:21:55.778] - state: ‘created’
[13:21:55.778] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:55.793] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:55.793] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:55.793]   - Field: ‘node’
[13:21:55.793]   - Field: ‘label’
[13:21:55.793]   - Field: ‘local’
[13:21:55.793]   - Field: ‘owner’
[13:21:55.793]   - Field: ‘envir’
[13:21:55.793]   - Field: ‘workers’
[13:21:55.794]   - Field: ‘packages’
[13:21:55.794]   - Field: ‘gc’
[13:21:55.794]   - Field: ‘conditions’
[13:21:55.794]   - Field: ‘persistent’
[13:21:55.794]   - Field: ‘expr’
[13:21:55.794]   - Field: ‘uuid’
[13:21:55.794]   - Field: ‘seed’
[13:21:55.794]   - Field: ‘version’
[13:21:55.794]   - Field: ‘result’
[13:21:55.794]   - Field: ‘asynchronous’
[13:21:55.794]   - Field: ‘calls’
[13:21:55.794]   - Field: ‘globals’
[13:21:55.795]   - Field: ‘stdout’
[13:21:55.795]   - Field: ‘earlySignal’
[13:21:55.795]   - Field: ‘lazy’
[13:21:55.795]   - Field: ‘state’
[13:21:55.795] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:55.795] - Launch lazy future ...
[13:21:55.795] Packages needed by the future expression (n = 0): <none>
[13:21:55.795] Packages needed by future strategies (n = 0): <none>
[13:21:55.796] {
[13:21:55.796]     {
[13:21:55.796]         {
[13:21:55.796]             ...future.startTime <- base::Sys.time()
[13:21:55.796]             {
[13:21:55.796]                 {
[13:21:55.796]                   {
[13:21:55.796]                     {
[13:21:55.796]                       base::local({
[13:21:55.796]                         has_future <- base::requireNamespace("future", 
[13:21:55.796]                           quietly = TRUE)
[13:21:55.796]                         if (has_future) {
[13:21:55.796]                           ns <- base::getNamespace("future")
[13:21:55.796]                           version <- ns[[".package"]][["version"]]
[13:21:55.796]                           if (is.null(version)) 
[13:21:55.796]                             version <- utils::packageVersion("future")
[13:21:55.796]                         }
[13:21:55.796]                         else {
[13:21:55.796]                           version <- NULL
[13:21:55.796]                         }
[13:21:55.796]                         if (!has_future || version < "1.8.0") {
[13:21:55.796]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:55.796]                             "", base::R.version$version.string), 
[13:21:55.796]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:55.796]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:55.796]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:55.796]                               "release", "version")], collapse = " "), 
[13:21:55.796]                             hostname = base::Sys.info()[["nodename"]])
[13:21:55.796]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:55.796]                             info)
[13:21:55.796]                           info <- base::paste(info, collapse = "; ")
[13:21:55.796]                           if (!has_future) {
[13:21:55.796]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:55.796]                               info)
[13:21:55.796]                           }
[13:21:55.796]                           else {
[13:21:55.796]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:55.796]                               info, version)
[13:21:55.796]                           }
[13:21:55.796]                           base::stop(msg)
[13:21:55.796]                         }
[13:21:55.796]                       })
[13:21:55.796]                     }
[13:21:55.796]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:55.796]                     base::options(mc.cores = 1L)
[13:21:55.796]                   }
[13:21:55.796]                   options(future.plan = NULL)
[13:21:55.796]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:55.796]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:55.796]                 }
[13:21:55.796]                 ...future.workdir <- getwd()
[13:21:55.796]             }
[13:21:55.796]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:55.796]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:55.796]         }
[13:21:55.796]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:55.796]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:55.796]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:55.796]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:55.796]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:55.796]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:55.796]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:55.796]             base::names(...future.oldOptions))
[13:21:55.796]     }
[13:21:55.796]     if (FALSE) {
[13:21:55.796]     }
[13:21:55.796]     else {
[13:21:55.796]         if (TRUE) {
[13:21:55.796]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:55.796]                 open = "w")
[13:21:55.796]         }
[13:21:55.796]         else {
[13:21:55.796]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:55.796]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:55.796]         }
[13:21:55.796]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:55.796]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:55.796]             base::sink(type = "output", split = FALSE)
[13:21:55.796]             base::close(...future.stdout)
[13:21:55.796]         }, add = TRUE)
[13:21:55.796]     }
[13:21:55.796]     ...future.frame <- base::sys.nframe()
[13:21:55.796]     ...future.conditions <- base::list()
[13:21:55.796]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:55.796]     if (FALSE) {
[13:21:55.796]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:55.796]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:55.796]     }
[13:21:55.796]     ...future.result <- base::tryCatch({
[13:21:55.796]         base::withCallingHandlers({
[13:21:55.796]             ...future.value <- base::withVisible(base::local({
[13:21:55.796]                 ...future.makeSendCondition <- local({
[13:21:55.796]                   sendCondition <- NULL
[13:21:55.796]                   function(frame = 1L) {
[13:21:55.796]                     if (is.function(sendCondition)) 
[13:21:55.796]                       return(sendCondition)
[13:21:55.796]                     ns <- getNamespace("parallel")
[13:21:55.796]                     if (exists("sendData", mode = "function", 
[13:21:55.796]                       envir = ns)) {
[13:21:55.796]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:55.796]                         envir = ns)
[13:21:55.796]                       envir <- sys.frame(frame)
[13:21:55.796]                       master <- NULL
[13:21:55.796]                       while (!identical(envir, .GlobalEnv) && 
[13:21:55.796]                         !identical(envir, emptyenv())) {
[13:21:55.796]                         if (exists("master", mode = "list", envir = envir, 
[13:21:55.796]                           inherits = FALSE)) {
[13:21:55.796]                           master <- get("master", mode = "list", 
[13:21:55.796]                             envir = envir, inherits = FALSE)
[13:21:55.796]                           if (inherits(master, c("SOCKnode", 
[13:21:55.796]                             "SOCK0node"))) {
[13:21:55.796]                             sendCondition <<- function(cond) {
[13:21:55.796]                               data <- list(type = "VALUE", value = cond, 
[13:21:55.796]                                 success = TRUE)
[13:21:55.796]                               parallel_sendData(master, data)
[13:21:55.796]                             }
[13:21:55.796]                             return(sendCondition)
[13:21:55.796]                           }
[13:21:55.796]                         }
[13:21:55.796]                         frame <- frame + 1L
[13:21:55.796]                         envir <- sys.frame(frame)
[13:21:55.796]                       }
[13:21:55.796]                     }
[13:21:55.796]                     sendCondition <<- function(cond) NULL
[13:21:55.796]                   }
[13:21:55.796]                 })
[13:21:55.796]                 withCallingHandlers({
[13:21:55.796]                   {
[13:21:55.796]                     Sys.sleep(0.5)
[13:21:55.796]                     list(a = 1, b = 42L)
[13:21:55.796]                   }
[13:21:55.796]                 }, immediateCondition = function(cond) {
[13:21:55.796]                   sendCondition <- ...future.makeSendCondition()
[13:21:55.796]                   sendCondition(cond)
[13:21:55.796]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:55.796]                   {
[13:21:55.796]                     inherits <- base::inherits
[13:21:55.796]                     invokeRestart <- base::invokeRestart
[13:21:55.796]                     is.null <- base::is.null
[13:21:55.796]                     muffled <- FALSE
[13:21:55.796]                     if (inherits(cond, "message")) {
[13:21:55.796]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:55.796]                       if (muffled) 
[13:21:55.796]                         invokeRestart("muffleMessage")
[13:21:55.796]                     }
[13:21:55.796]                     else if (inherits(cond, "warning")) {
[13:21:55.796]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:55.796]                       if (muffled) 
[13:21:55.796]                         invokeRestart("muffleWarning")
[13:21:55.796]                     }
[13:21:55.796]                     else if (inherits(cond, "condition")) {
[13:21:55.796]                       if (!is.null(pattern)) {
[13:21:55.796]                         computeRestarts <- base::computeRestarts
[13:21:55.796]                         grepl <- base::grepl
[13:21:55.796]                         restarts <- computeRestarts(cond)
[13:21:55.796]                         for (restart in restarts) {
[13:21:55.796]                           name <- restart$name
[13:21:55.796]                           if (is.null(name)) 
[13:21:55.796]                             next
[13:21:55.796]                           if (!grepl(pattern, name)) 
[13:21:55.796]                             next
[13:21:55.796]                           invokeRestart(restart)
[13:21:55.796]                           muffled <- TRUE
[13:21:55.796]                           break
[13:21:55.796]                         }
[13:21:55.796]                       }
[13:21:55.796]                     }
[13:21:55.796]                     invisible(muffled)
[13:21:55.796]                   }
[13:21:55.796]                   muffleCondition(cond)
[13:21:55.796]                 })
[13:21:55.796]             }))
[13:21:55.796]             future::FutureResult(value = ...future.value$value, 
[13:21:55.796]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:55.796]                   ...future.rng), globalenv = if (FALSE) 
[13:21:55.796]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:55.796]                     ...future.globalenv.names))
[13:21:55.796]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:55.796]         }, condition = base::local({
[13:21:55.796]             c <- base::c
[13:21:55.796]             inherits <- base::inherits
[13:21:55.796]             invokeRestart <- base::invokeRestart
[13:21:55.796]             length <- base::length
[13:21:55.796]             list <- base::list
[13:21:55.796]             seq.int <- base::seq.int
[13:21:55.796]             signalCondition <- base::signalCondition
[13:21:55.796]             sys.calls <- base::sys.calls
[13:21:55.796]             `[[` <- base::`[[`
[13:21:55.796]             `+` <- base::`+`
[13:21:55.796]             `<<-` <- base::`<<-`
[13:21:55.796]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:55.796]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:55.796]                   3L)]
[13:21:55.796]             }
[13:21:55.796]             function(cond) {
[13:21:55.796]                 is_error <- inherits(cond, "error")
[13:21:55.796]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:55.796]                   NULL)
[13:21:55.796]                 if (is_error) {
[13:21:55.796]                   sessionInformation <- function() {
[13:21:55.796]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:55.796]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:55.796]                       search = base::search(), system = base::Sys.info())
[13:21:55.796]                   }
[13:21:55.796]                   ...future.conditions[[length(...future.conditions) + 
[13:21:55.796]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:55.796]                     cond$call), session = sessionInformation(), 
[13:21:55.796]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:55.796]                   signalCondition(cond)
[13:21:55.796]                 }
[13:21:55.796]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:55.796]                 "immediateCondition"))) {
[13:21:55.796]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:55.796]                   ...future.conditions[[length(...future.conditions) + 
[13:21:55.796]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:55.796]                   if (TRUE && !signal) {
[13:21:55.796]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:55.796]                     {
[13:21:55.796]                       inherits <- base::inherits
[13:21:55.796]                       invokeRestart <- base::invokeRestart
[13:21:55.796]                       is.null <- base::is.null
[13:21:55.796]                       muffled <- FALSE
[13:21:55.796]                       if (inherits(cond, "message")) {
[13:21:55.796]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:55.796]                         if (muffled) 
[13:21:55.796]                           invokeRestart("muffleMessage")
[13:21:55.796]                       }
[13:21:55.796]                       else if (inherits(cond, "warning")) {
[13:21:55.796]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:55.796]                         if (muffled) 
[13:21:55.796]                           invokeRestart("muffleWarning")
[13:21:55.796]                       }
[13:21:55.796]                       else if (inherits(cond, "condition")) {
[13:21:55.796]                         if (!is.null(pattern)) {
[13:21:55.796]                           computeRestarts <- base::computeRestarts
[13:21:55.796]                           grepl <- base::grepl
[13:21:55.796]                           restarts <- computeRestarts(cond)
[13:21:55.796]                           for (restart in restarts) {
[13:21:55.796]                             name <- restart$name
[13:21:55.796]                             if (is.null(name)) 
[13:21:55.796]                               next
[13:21:55.796]                             if (!grepl(pattern, name)) 
[13:21:55.796]                               next
[13:21:55.796]                             invokeRestart(restart)
[13:21:55.796]                             muffled <- TRUE
[13:21:55.796]                             break
[13:21:55.796]                           }
[13:21:55.796]                         }
[13:21:55.796]                       }
[13:21:55.796]                       invisible(muffled)
[13:21:55.796]                     }
[13:21:55.796]                     muffleCondition(cond, pattern = "^muffle")
[13:21:55.796]                   }
[13:21:55.796]                 }
[13:21:55.796]                 else {
[13:21:55.796]                   if (TRUE) {
[13:21:55.796]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:55.796]                     {
[13:21:55.796]                       inherits <- base::inherits
[13:21:55.796]                       invokeRestart <- base::invokeRestart
[13:21:55.796]                       is.null <- base::is.null
[13:21:55.796]                       muffled <- FALSE
[13:21:55.796]                       if (inherits(cond, "message")) {
[13:21:55.796]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:55.796]                         if (muffled) 
[13:21:55.796]                           invokeRestart("muffleMessage")
[13:21:55.796]                       }
[13:21:55.796]                       else if (inherits(cond, "warning")) {
[13:21:55.796]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:55.796]                         if (muffled) 
[13:21:55.796]                           invokeRestart("muffleWarning")
[13:21:55.796]                       }
[13:21:55.796]                       else if (inherits(cond, "condition")) {
[13:21:55.796]                         if (!is.null(pattern)) {
[13:21:55.796]                           computeRestarts <- base::computeRestarts
[13:21:55.796]                           grepl <- base::grepl
[13:21:55.796]                           restarts <- computeRestarts(cond)
[13:21:55.796]                           for (restart in restarts) {
[13:21:55.796]                             name <- restart$name
[13:21:55.796]                             if (is.null(name)) 
[13:21:55.796]                               next
[13:21:55.796]                             if (!grepl(pattern, name)) 
[13:21:55.796]                               next
[13:21:55.796]                             invokeRestart(restart)
[13:21:55.796]                             muffled <- TRUE
[13:21:55.796]                             break
[13:21:55.796]                           }
[13:21:55.796]                         }
[13:21:55.796]                       }
[13:21:55.796]                       invisible(muffled)
[13:21:55.796]                     }
[13:21:55.796]                     muffleCondition(cond, pattern = "^muffle")
[13:21:55.796]                   }
[13:21:55.796]                 }
[13:21:55.796]             }
[13:21:55.796]         }))
[13:21:55.796]     }, error = function(ex) {
[13:21:55.796]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:55.796]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:55.796]                 ...future.rng), started = ...future.startTime, 
[13:21:55.796]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:55.796]             version = "1.8"), class = "FutureResult")
[13:21:55.796]     }, finally = {
[13:21:55.796]         if (!identical(...future.workdir, getwd())) 
[13:21:55.796]             setwd(...future.workdir)
[13:21:55.796]         {
[13:21:55.796]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:55.796]                 ...future.oldOptions$nwarnings <- NULL
[13:21:55.796]             }
[13:21:55.796]             base::options(...future.oldOptions)
[13:21:55.796]             if (.Platform$OS.type == "windows") {
[13:21:55.796]                 old_names <- names(...future.oldEnvVars)
[13:21:55.796]                 envs <- base::Sys.getenv()
[13:21:55.796]                 names <- names(envs)
[13:21:55.796]                 common <- intersect(names, old_names)
[13:21:55.796]                 added <- setdiff(names, old_names)
[13:21:55.796]                 removed <- setdiff(old_names, names)
[13:21:55.796]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:55.796]                   envs[common]]
[13:21:55.796]                 NAMES <- toupper(changed)
[13:21:55.796]                 args <- list()
[13:21:55.796]                 for (kk in seq_along(NAMES)) {
[13:21:55.796]                   name <- changed[[kk]]
[13:21:55.796]                   NAME <- NAMES[[kk]]
[13:21:55.796]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:55.796]                     next
[13:21:55.796]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:55.796]                 }
[13:21:55.796]                 NAMES <- toupper(added)
[13:21:55.796]                 for (kk in seq_along(NAMES)) {
[13:21:55.796]                   name <- added[[kk]]
[13:21:55.796]                   NAME <- NAMES[[kk]]
[13:21:55.796]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:55.796]                     next
[13:21:55.796]                   args[[name]] <- ""
[13:21:55.796]                 }
[13:21:55.796]                 NAMES <- toupper(removed)
[13:21:55.796]                 for (kk in seq_along(NAMES)) {
[13:21:55.796]                   name <- removed[[kk]]
[13:21:55.796]                   NAME <- NAMES[[kk]]
[13:21:55.796]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:55.796]                     next
[13:21:55.796]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:55.796]                 }
[13:21:55.796]                 if (length(args) > 0) 
[13:21:55.796]                   base::do.call(base::Sys.setenv, args = args)
[13:21:55.796]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:55.796]             }
[13:21:55.796]             else {
[13:21:55.796]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:55.796]             }
[13:21:55.796]             {
[13:21:55.796]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:55.796]                   0L) {
[13:21:55.796]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:55.796]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:55.796]                   base::options(opts)
[13:21:55.796]                 }
[13:21:55.796]                 {
[13:21:55.796]                   {
[13:21:55.796]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:55.796]                     NULL
[13:21:55.796]                   }
[13:21:55.796]                   options(future.plan = NULL)
[13:21:55.796]                   if (is.na(NA_character_)) 
[13:21:55.796]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:55.796]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:55.796]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:55.796]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:55.796]                     envir = parent.frame()) 
[13:21:55.796]                   {
[13:21:55.796]                     if (is.function(workers)) 
[13:21:55.796]                       workers <- workers()
[13:21:55.796]                     workers <- structure(as.integer(workers), 
[13:21:55.796]                       class = class(workers))
[13:21:55.796]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:55.796]                       workers >= 1)
[13:21:55.796]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:55.796]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:55.796]                     }
[13:21:55.796]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:55.796]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:55.796]                       envir = envir)
[13:21:55.796]                     if (!future$lazy) 
[13:21:55.796]                       future <- run(future)
[13:21:55.796]                     invisible(future)
[13:21:55.796]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:55.796]                 }
[13:21:55.796]             }
[13:21:55.796]         }
[13:21:55.796]     })
[13:21:55.796]     if (TRUE) {
[13:21:55.796]         base::sink(type = "output", split = FALSE)
[13:21:55.796]         if (TRUE) {
[13:21:55.796]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:55.796]         }
[13:21:55.796]         else {
[13:21:55.796]             ...future.result["stdout"] <- base::list(NULL)
[13:21:55.796]         }
[13:21:55.796]         base::close(...future.stdout)
[13:21:55.796]         ...future.stdout <- NULL
[13:21:55.796]     }
[13:21:55.796]     ...future.result$conditions <- ...future.conditions
[13:21:55.796]     ...future.result$finished <- base::Sys.time()
[13:21:55.796]     ...future.result
[13:21:55.796] }
[13:21:55.799] MultisessionFuture started
[13:21:55.799] - Launch lazy future ... done
[13:21:55.799] run() for ‘MultisessionFuture’ ... done
[13:21:56.346] receiveMessageFromWorker() for ClusterFuture ...
[13:21:56.347] - Validating connection of MultisessionFuture
[13:21:56.347] - received message: FutureResult
[13:21:56.347] - Received FutureResult
[13:21:56.347] - Erased future from FutureRegistry
[13:21:56.347] result() for ClusterFuture ...
[13:21:56.347] - result already collected: FutureResult
[13:21:56.347] result() for ClusterFuture ... done
[13:21:56.347] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:56.348] resolve() on list ...
[13:21:56.348]  recursive: 0
[13:21:56.348]  length: 2
[13:21:56.348]  elements: ‘a’, ‘b’
[13:21:56.348]  length: 1 (resolved future 1)
[13:21:56.348]  length: 0 (resolved future 2)
[13:21:56.348] resolve() on list ... DONE
[13:21:56.348] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[13:21:56.348] getGlobalsAndPackages() ...
[13:21:56.349] Searching for globals...
[13:21:56.349] - globals found: [2] ‘list’, ‘stop’
[13:21:56.349] Searching for globals ... DONE
[13:21:56.349] Resolving globals: FALSE
[13:21:56.350] 
[13:21:56.350] 
[13:21:56.350] getGlobalsAndPackages() ... DONE
[13:21:56.350] run() for ‘Future’ ...
[13:21:56.350] - state: ‘created’
[13:21:56.350] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:56.366] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:56.366] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:56.366]   - Field: ‘node’
[13:21:56.366]   - Field: ‘label’
[13:21:56.366]   - Field: ‘local’
[13:21:56.366]   - Field: ‘owner’
[13:21:56.366]   - Field: ‘envir’
[13:21:56.366]   - Field: ‘workers’
[13:21:56.366]   - Field: ‘packages’
[13:21:56.367]   - Field: ‘gc’
[13:21:56.367]   - Field: ‘conditions’
[13:21:56.367]   - Field: ‘persistent’
[13:21:56.367]   - Field: ‘expr’
[13:21:56.367]   - Field: ‘uuid’
[13:21:56.367]   - Field: ‘seed’
[13:21:56.367]   - Field: ‘version’
[13:21:56.367]   - Field: ‘result’
[13:21:56.367]   - Field: ‘asynchronous’
[13:21:56.367]   - Field: ‘calls’
[13:21:56.368]   - Field: ‘globals’
[13:21:56.368]   - Field: ‘stdout’
[13:21:56.368]   - Field: ‘earlySignal’
[13:21:56.368]   - Field: ‘lazy’
[13:21:56.368]   - Field: ‘state’
[13:21:56.368] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:56.368] - Launch lazy future ...
[13:21:56.368] Packages needed by the future expression (n = 0): <none>
[13:21:56.368] Packages needed by future strategies (n = 0): <none>
[13:21:56.369] {
[13:21:56.369]     {
[13:21:56.369]         {
[13:21:56.369]             ...future.startTime <- base::Sys.time()
[13:21:56.369]             {
[13:21:56.369]                 {
[13:21:56.369]                   {
[13:21:56.369]                     {
[13:21:56.369]                       base::local({
[13:21:56.369]                         has_future <- base::requireNamespace("future", 
[13:21:56.369]                           quietly = TRUE)
[13:21:56.369]                         if (has_future) {
[13:21:56.369]                           ns <- base::getNamespace("future")
[13:21:56.369]                           version <- ns[[".package"]][["version"]]
[13:21:56.369]                           if (is.null(version)) 
[13:21:56.369]                             version <- utils::packageVersion("future")
[13:21:56.369]                         }
[13:21:56.369]                         else {
[13:21:56.369]                           version <- NULL
[13:21:56.369]                         }
[13:21:56.369]                         if (!has_future || version < "1.8.0") {
[13:21:56.369]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:56.369]                             "", base::R.version$version.string), 
[13:21:56.369]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:56.369]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:56.369]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:56.369]                               "release", "version")], collapse = " "), 
[13:21:56.369]                             hostname = base::Sys.info()[["nodename"]])
[13:21:56.369]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:56.369]                             info)
[13:21:56.369]                           info <- base::paste(info, collapse = "; ")
[13:21:56.369]                           if (!has_future) {
[13:21:56.369]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:56.369]                               info)
[13:21:56.369]                           }
[13:21:56.369]                           else {
[13:21:56.369]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:56.369]                               info, version)
[13:21:56.369]                           }
[13:21:56.369]                           base::stop(msg)
[13:21:56.369]                         }
[13:21:56.369]                       })
[13:21:56.369]                     }
[13:21:56.369]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:56.369]                     base::options(mc.cores = 1L)
[13:21:56.369]                   }
[13:21:56.369]                   options(future.plan = NULL)
[13:21:56.369]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:56.369]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:56.369]                 }
[13:21:56.369]                 ...future.workdir <- getwd()
[13:21:56.369]             }
[13:21:56.369]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:56.369]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:56.369]         }
[13:21:56.369]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:56.369]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:56.369]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:56.369]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:56.369]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:56.369]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:56.369]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:56.369]             base::names(...future.oldOptions))
[13:21:56.369]     }
[13:21:56.369]     if (FALSE) {
[13:21:56.369]     }
[13:21:56.369]     else {
[13:21:56.369]         if (TRUE) {
[13:21:56.369]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:56.369]                 open = "w")
[13:21:56.369]         }
[13:21:56.369]         else {
[13:21:56.369]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:56.369]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:56.369]         }
[13:21:56.369]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:56.369]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:56.369]             base::sink(type = "output", split = FALSE)
[13:21:56.369]             base::close(...future.stdout)
[13:21:56.369]         }, add = TRUE)
[13:21:56.369]     }
[13:21:56.369]     ...future.frame <- base::sys.nframe()
[13:21:56.369]     ...future.conditions <- base::list()
[13:21:56.369]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:56.369]     if (FALSE) {
[13:21:56.369]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:56.369]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:56.369]     }
[13:21:56.369]     ...future.result <- base::tryCatch({
[13:21:56.369]         base::withCallingHandlers({
[13:21:56.369]             ...future.value <- base::withVisible(base::local({
[13:21:56.369]                 ...future.makeSendCondition <- local({
[13:21:56.369]                   sendCondition <- NULL
[13:21:56.369]                   function(frame = 1L) {
[13:21:56.369]                     if (is.function(sendCondition)) 
[13:21:56.369]                       return(sendCondition)
[13:21:56.369]                     ns <- getNamespace("parallel")
[13:21:56.369]                     if (exists("sendData", mode = "function", 
[13:21:56.369]                       envir = ns)) {
[13:21:56.369]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:56.369]                         envir = ns)
[13:21:56.369]                       envir <- sys.frame(frame)
[13:21:56.369]                       master <- NULL
[13:21:56.369]                       while (!identical(envir, .GlobalEnv) && 
[13:21:56.369]                         !identical(envir, emptyenv())) {
[13:21:56.369]                         if (exists("master", mode = "list", envir = envir, 
[13:21:56.369]                           inherits = FALSE)) {
[13:21:56.369]                           master <- get("master", mode = "list", 
[13:21:56.369]                             envir = envir, inherits = FALSE)
[13:21:56.369]                           if (inherits(master, c("SOCKnode", 
[13:21:56.369]                             "SOCK0node"))) {
[13:21:56.369]                             sendCondition <<- function(cond) {
[13:21:56.369]                               data <- list(type = "VALUE", value = cond, 
[13:21:56.369]                                 success = TRUE)
[13:21:56.369]                               parallel_sendData(master, data)
[13:21:56.369]                             }
[13:21:56.369]                             return(sendCondition)
[13:21:56.369]                           }
[13:21:56.369]                         }
[13:21:56.369]                         frame <- frame + 1L
[13:21:56.369]                         envir <- sys.frame(frame)
[13:21:56.369]                       }
[13:21:56.369]                     }
[13:21:56.369]                     sendCondition <<- function(cond) NULL
[13:21:56.369]                   }
[13:21:56.369]                 })
[13:21:56.369]                 withCallingHandlers({
[13:21:56.369]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:21:56.369]                 }, immediateCondition = function(cond) {
[13:21:56.369]                   sendCondition <- ...future.makeSendCondition()
[13:21:56.369]                   sendCondition(cond)
[13:21:56.369]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:56.369]                   {
[13:21:56.369]                     inherits <- base::inherits
[13:21:56.369]                     invokeRestart <- base::invokeRestart
[13:21:56.369]                     is.null <- base::is.null
[13:21:56.369]                     muffled <- FALSE
[13:21:56.369]                     if (inherits(cond, "message")) {
[13:21:56.369]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:56.369]                       if (muffled) 
[13:21:56.369]                         invokeRestart("muffleMessage")
[13:21:56.369]                     }
[13:21:56.369]                     else if (inherits(cond, "warning")) {
[13:21:56.369]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:56.369]                       if (muffled) 
[13:21:56.369]                         invokeRestart("muffleWarning")
[13:21:56.369]                     }
[13:21:56.369]                     else if (inherits(cond, "condition")) {
[13:21:56.369]                       if (!is.null(pattern)) {
[13:21:56.369]                         computeRestarts <- base::computeRestarts
[13:21:56.369]                         grepl <- base::grepl
[13:21:56.369]                         restarts <- computeRestarts(cond)
[13:21:56.369]                         for (restart in restarts) {
[13:21:56.369]                           name <- restart$name
[13:21:56.369]                           if (is.null(name)) 
[13:21:56.369]                             next
[13:21:56.369]                           if (!grepl(pattern, name)) 
[13:21:56.369]                             next
[13:21:56.369]                           invokeRestart(restart)
[13:21:56.369]                           muffled <- TRUE
[13:21:56.369]                           break
[13:21:56.369]                         }
[13:21:56.369]                       }
[13:21:56.369]                     }
[13:21:56.369]                     invisible(muffled)
[13:21:56.369]                   }
[13:21:56.369]                   muffleCondition(cond)
[13:21:56.369]                 })
[13:21:56.369]             }))
[13:21:56.369]             future::FutureResult(value = ...future.value$value, 
[13:21:56.369]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:56.369]                   ...future.rng), globalenv = if (FALSE) 
[13:21:56.369]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:56.369]                     ...future.globalenv.names))
[13:21:56.369]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:56.369]         }, condition = base::local({
[13:21:56.369]             c <- base::c
[13:21:56.369]             inherits <- base::inherits
[13:21:56.369]             invokeRestart <- base::invokeRestart
[13:21:56.369]             length <- base::length
[13:21:56.369]             list <- base::list
[13:21:56.369]             seq.int <- base::seq.int
[13:21:56.369]             signalCondition <- base::signalCondition
[13:21:56.369]             sys.calls <- base::sys.calls
[13:21:56.369]             `[[` <- base::`[[`
[13:21:56.369]             `+` <- base::`+`
[13:21:56.369]             `<<-` <- base::`<<-`
[13:21:56.369]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:56.369]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:56.369]                   3L)]
[13:21:56.369]             }
[13:21:56.369]             function(cond) {
[13:21:56.369]                 is_error <- inherits(cond, "error")
[13:21:56.369]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:56.369]                   NULL)
[13:21:56.369]                 if (is_error) {
[13:21:56.369]                   sessionInformation <- function() {
[13:21:56.369]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:56.369]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:56.369]                       search = base::search(), system = base::Sys.info())
[13:21:56.369]                   }
[13:21:56.369]                   ...future.conditions[[length(...future.conditions) + 
[13:21:56.369]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:56.369]                     cond$call), session = sessionInformation(), 
[13:21:56.369]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:56.369]                   signalCondition(cond)
[13:21:56.369]                 }
[13:21:56.369]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:56.369]                 "immediateCondition"))) {
[13:21:56.369]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:56.369]                   ...future.conditions[[length(...future.conditions) + 
[13:21:56.369]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:56.369]                   if (TRUE && !signal) {
[13:21:56.369]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:56.369]                     {
[13:21:56.369]                       inherits <- base::inherits
[13:21:56.369]                       invokeRestart <- base::invokeRestart
[13:21:56.369]                       is.null <- base::is.null
[13:21:56.369]                       muffled <- FALSE
[13:21:56.369]                       if (inherits(cond, "message")) {
[13:21:56.369]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:56.369]                         if (muffled) 
[13:21:56.369]                           invokeRestart("muffleMessage")
[13:21:56.369]                       }
[13:21:56.369]                       else if (inherits(cond, "warning")) {
[13:21:56.369]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:56.369]                         if (muffled) 
[13:21:56.369]                           invokeRestart("muffleWarning")
[13:21:56.369]                       }
[13:21:56.369]                       else if (inherits(cond, "condition")) {
[13:21:56.369]                         if (!is.null(pattern)) {
[13:21:56.369]                           computeRestarts <- base::computeRestarts
[13:21:56.369]                           grepl <- base::grepl
[13:21:56.369]                           restarts <- computeRestarts(cond)
[13:21:56.369]                           for (restart in restarts) {
[13:21:56.369]                             name <- restart$name
[13:21:56.369]                             if (is.null(name)) 
[13:21:56.369]                               next
[13:21:56.369]                             if (!grepl(pattern, name)) 
[13:21:56.369]                               next
[13:21:56.369]                             invokeRestart(restart)
[13:21:56.369]                             muffled <- TRUE
[13:21:56.369]                             break
[13:21:56.369]                           }
[13:21:56.369]                         }
[13:21:56.369]                       }
[13:21:56.369]                       invisible(muffled)
[13:21:56.369]                     }
[13:21:56.369]                     muffleCondition(cond, pattern = "^muffle")
[13:21:56.369]                   }
[13:21:56.369]                 }
[13:21:56.369]                 else {
[13:21:56.369]                   if (TRUE) {
[13:21:56.369]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:56.369]                     {
[13:21:56.369]                       inherits <- base::inherits
[13:21:56.369]                       invokeRestart <- base::invokeRestart
[13:21:56.369]                       is.null <- base::is.null
[13:21:56.369]                       muffled <- FALSE
[13:21:56.369]                       if (inherits(cond, "message")) {
[13:21:56.369]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:56.369]                         if (muffled) 
[13:21:56.369]                           invokeRestart("muffleMessage")
[13:21:56.369]                       }
[13:21:56.369]                       else if (inherits(cond, "warning")) {
[13:21:56.369]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:56.369]                         if (muffled) 
[13:21:56.369]                           invokeRestart("muffleWarning")
[13:21:56.369]                       }
[13:21:56.369]                       else if (inherits(cond, "condition")) {
[13:21:56.369]                         if (!is.null(pattern)) {
[13:21:56.369]                           computeRestarts <- base::computeRestarts
[13:21:56.369]                           grepl <- base::grepl
[13:21:56.369]                           restarts <- computeRestarts(cond)
[13:21:56.369]                           for (restart in restarts) {
[13:21:56.369]                             name <- restart$name
[13:21:56.369]                             if (is.null(name)) 
[13:21:56.369]                               next
[13:21:56.369]                             if (!grepl(pattern, name)) 
[13:21:56.369]                               next
[13:21:56.369]                             invokeRestart(restart)
[13:21:56.369]                             muffled <- TRUE
[13:21:56.369]                             break
[13:21:56.369]                           }
[13:21:56.369]                         }
[13:21:56.369]                       }
[13:21:56.369]                       invisible(muffled)
[13:21:56.369]                     }
[13:21:56.369]                     muffleCondition(cond, pattern = "^muffle")
[13:21:56.369]                   }
[13:21:56.369]                 }
[13:21:56.369]             }
[13:21:56.369]         }))
[13:21:56.369]     }, error = function(ex) {
[13:21:56.369]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:56.369]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:56.369]                 ...future.rng), started = ...future.startTime, 
[13:21:56.369]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:56.369]             version = "1.8"), class = "FutureResult")
[13:21:56.369]     }, finally = {
[13:21:56.369]         if (!identical(...future.workdir, getwd())) 
[13:21:56.369]             setwd(...future.workdir)
[13:21:56.369]         {
[13:21:56.369]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:56.369]                 ...future.oldOptions$nwarnings <- NULL
[13:21:56.369]             }
[13:21:56.369]             base::options(...future.oldOptions)
[13:21:56.369]             if (.Platform$OS.type == "windows") {
[13:21:56.369]                 old_names <- names(...future.oldEnvVars)
[13:21:56.369]                 envs <- base::Sys.getenv()
[13:21:56.369]                 names <- names(envs)
[13:21:56.369]                 common <- intersect(names, old_names)
[13:21:56.369]                 added <- setdiff(names, old_names)
[13:21:56.369]                 removed <- setdiff(old_names, names)
[13:21:56.369]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:56.369]                   envs[common]]
[13:21:56.369]                 NAMES <- toupper(changed)
[13:21:56.369]                 args <- list()
[13:21:56.369]                 for (kk in seq_along(NAMES)) {
[13:21:56.369]                   name <- changed[[kk]]
[13:21:56.369]                   NAME <- NAMES[[kk]]
[13:21:56.369]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:56.369]                     next
[13:21:56.369]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:56.369]                 }
[13:21:56.369]                 NAMES <- toupper(added)
[13:21:56.369]                 for (kk in seq_along(NAMES)) {
[13:21:56.369]                   name <- added[[kk]]
[13:21:56.369]                   NAME <- NAMES[[kk]]
[13:21:56.369]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:56.369]                     next
[13:21:56.369]                   args[[name]] <- ""
[13:21:56.369]                 }
[13:21:56.369]                 NAMES <- toupper(removed)
[13:21:56.369]                 for (kk in seq_along(NAMES)) {
[13:21:56.369]                   name <- removed[[kk]]
[13:21:56.369]                   NAME <- NAMES[[kk]]
[13:21:56.369]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:56.369]                     next
[13:21:56.369]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:56.369]                 }
[13:21:56.369]                 if (length(args) > 0) 
[13:21:56.369]                   base::do.call(base::Sys.setenv, args = args)
[13:21:56.369]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:56.369]             }
[13:21:56.369]             else {
[13:21:56.369]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:56.369]             }
[13:21:56.369]             {
[13:21:56.369]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:56.369]                   0L) {
[13:21:56.369]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:56.369]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:56.369]                   base::options(opts)
[13:21:56.369]                 }
[13:21:56.369]                 {
[13:21:56.369]                   {
[13:21:56.369]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:56.369]                     NULL
[13:21:56.369]                   }
[13:21:56.369]                   options(future.plan = NULL)
[13:21:56.369]                   if (is.na(NA_character_)) 
[13:21:56.369]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:56.369]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:56.369]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:56.369]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:56.369]                     envir = parent.frame()) 
[13:21:56.369]                   {
[13:21:56.369]                     if (is.function(workers)) 
[13:21:56.369]                       workers <- workers()
[13:21:56.369]                     workers <- structure(as.integer(workers), 
[13:21:56.369]                       class = class(workers))
[13:21:56.369]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:56.369]                       workers >= 1)
[13:21:56.369]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:56.369]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:56.369]                     }
[13:21:56.369]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:56.369]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:56.369]                       envir = envir)
[13:21:56.369]                     if (!future$lazy) 
[13:21:56.369]                       future <- run(future)
[13:21:56.369]                     invisible(future)
[13:21:56.369]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:56.369]                 }
[13:21:56.369]             }
[13:21:56.369]         }
[13:21:56.369]     })
[13:21:56.369]     if (TRUE) {
[13:21:56.369]         base::sink(type = "output", split = FALSE)
[13:21:56.369]         if (TRUE) {
[13:21:56.369]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:56.369]         }
[13:21:56.369]         else {
[13:21:56.369]             ...future.result["stdout"] <- base::list(NULL)
[13:21:56.369]         }
[13:21:56.369]         base::close(...future.stdout)
[13:21:56.369]         ...future.stdout <- NULL
[13:21:56.369]     }
[13:21:56.369]     ...future.result$conditions <- ...future.conditions
[13:21:56.369]     ...future.result$finished <- base::Sys.time()
[13:21:56.369]     ...future.result
[13:21:56.369] }
[13:21:56.372] MultisessionFuture started
[13:21:56.372] - Launch lazy future ... done
[13:21:56.372] run() for ‘MultisessionFuture’ ... done
[13:21:56.418] receiveMessageFromWorker() for ClusterFuture ...
[13:21:56.418] - Validating connection of MultisessionFuture
[13:21:56.418] - received message: FutureResult
[13:21:56.419] - Received FutureResult
[13:21:56.419] - Erased future from FutureRegistry
[13:21:56.419] result() for ClusterFuture ...
[13:21:56.419] - result already collected: FutureResult
[13:21:56.419] result() for ClusterFuture ... done
[13:21:56.419] signalConditions() ...
[13:21:56.419]  - include = ‘immediateCondition’
[13:21:56.419]  - exclude = 
[13:21:56.419]  - resignal = FALSE
[13:21:56.420]  - Number of conditions: 1
[13:21:56.420] signalConditions() ... done
[13:21:56.420] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:56.420] A MultisessionFuture was resolved
[13:21:56.420] getGlobalsAndPackages() ...
[13:21:56.420] Searching for globals...
[13:21:56.421] - globals found: [2] ‘list’, ‘stop’
[13:21:56.421] Searching for globals ... DONE
[13:21:56.421] Resolving globals: FALSE
[13:21:56.421] 
[13:21:56.421] 
[13:21:56.422] getGlobalsAndPackages() ... DONE
[13:21:56.422] run() for ‘Future’ ...
[13:21:56.422] - state: ‘created’
[13:21:56.422] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:56.436] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:56.437] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:56.437]   - Field: ‘node’
[13:21:56.437]   - Field: ‘label’
[13:21:56.437]   - Field: ‘local’
[13:21:56.437]   - Field: ‘owner’
[13:21:56.437]   - Field: ‘envir’
[13:21:56.437]   - Field: ‘workers’
[13:21:56.437]   - Field: ‘packages’
[13:21:56.437]   - Field: ‘gc’
[13:21:56.438]   - Field: ‘conditions’
[13:21:56.438]   - Field: ‘persistent’
[13:21:56.438]   - Field: ‘expr’
[13:21:56.438]   - Field: ‘uuid’
[13:21:56.438]   - Field: ‘seed’
[13:21:56.438]   - Field: ‘version’
[13:21:56.438]   - Field: ‘result’
[13:21:56.438]   - Field: ‘asynchronous’
[13:21:56.438]   - Field: ‘calls’
[13:21:56.438]   - Field: ‘globals’
[13:21:56.438]   - Field: ‘stdout’
[13:21:56.439]   - Field: ‘earlySignal’
[13:21:56.439]   - Field: ‘lazy’
[13:21:56.439]   - Field: ‘state’
[13:21:56.439] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:56.439] - Launch lazy future ...
[13:21:56.439] Packages needed by the future expression (n = 0): <none>
[13:21:56.439] Packages needed by future strategies (n = 0): <none>
[13:21:56.440] {
[13:21:56.440]     {
[13:21:56.440]         {
[13:21:56.440]             ...future.startTime <- base::Sys.time()
[13:21:56.440]             {
[13:21:56.440]                 {
[13:21:56.440]                   {
[13:21:56.440]                     {
[13:21:56.440]                       base::local({
[13:21:56.440]                         has_future <- base::requireNamespace("future", 
[13:21:56.440]                           quietly = TRUE)
[13:21:56.440]                         if (has_future) {
[13:21:56.440]                           ns <- base::getNamespace("future")
[13:21:56.440]                           version <- ns[[".package"]][["version"]]
[13:21:56.440]                           if (is.null(version)) 
[13:21:56.440]                             version <- utils::packageVersion("future")
[13:21:56.440]                         }
[13:21:56.440]                         else {
[13:21:56.440]                           version <- NULL
[13:21:56.440]                         }
[13:21:56.440]                         if (!has_future || version < "1.8.0") {
[13:21:56.440]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:56.440]                             "", base::R.version$version.string), 
[13:21:56.440]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:56.440]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:56.440]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:56.440]                               "release", "version")], collapse = " "), 
[13:21:56.440]                             hostname = base::Sys.info()[["nodename"]])
[13:21:56.440]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:56.440]                             info)
[13:21:56.440]                           info <- base::paste(info, collapse = "; ")
[13:21:56.440]                           if (!has_future) {
[13:21:56.440]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:56.440]                               info)
[13:21:56.440]                           }
[13:21:56.440]                           else {
[13:21:56.440]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:56.440]                               info, version)
[13:21:56.440]                           }
[13:21:56.440]                           base::stop(msg)
[13:21:56.440]                         }
[13:21:56.440]                       })
[13:21:56.440]                     }
[13:21:56.440]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:56.440]                     base::options(mc.cores = 1L)
[13:21:56.440]                   }
[13:21:56.440]                   options(future.plan = NULL)
[13:21:56.440]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:56.440]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:56.440]                 }
[13:21:56.440]                 ...future.workdir <- getwd()
[13:21:56.440]             }
[13:21:56.440]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:56.440]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:56.440]         }
[13:21:56.440]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:56.440]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:56.440]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:56.440]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:56.440]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:56.440]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:56.440]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:56.440]             base::names(...future.oldOptions))
[13:21:56.440]     }
[13:21:56.440]     if (FALSE) {
[13:21:56.440]     }
[13:21:56.440]     else {
[13:21:56.440]         if (TRUE) {
[13:21:56.440]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:56.440]                 open = "w")
[13:21:56.440]         }
[13:21:56.440]         else {
[13:21:56.440]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:56.440]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:56.440]         }
[13:21:56.440]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:56.440]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:56.440]             base::sink(type = "output", split = FALSE)
[13:21:56.440]             base::close(...future.stdout)
[13:21:56.440]         }, add = TRUE)
[13:21:56.440]     }
[13:21:56.440]     ...future.frame <- base::sys.nframe()
[13:21:56.440]     ...future.conditions <- base::list()
[13:21:56.440]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:56.440]     if (FALSE) {
[13:21:56.440]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:56.440]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:56.440]     }
[13:21:56.440]     ...future.result <- base::tryCatch({
[13:21:56.440]         base::withCallingHandlers({
[13:21:56.440]             ...future.value <- base::withVisible(base::local({
[13:21:56.440]                 ...future.makeSendCondition <- local({
[13:21:56.440]                   sendCondition <- NULL
[13:21:56.440]                   function(frame = 1L) {
[13:21:56.440]                     if (is.function(sendCondition)) 
[13:21:56.440]                       return(sendCondition)
[13:21:56.440]                     ns <- getNamespace("parallel")
[13:21:56.440]                     if (exists("sendData", mode = "function", 
[13:21:56.440]                       envir = ns)) {
[13:21:56.440]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:56.440]                         envir = ns)
[13:21:56.440]                       envir <- sys.frame(frame)
[13:21:56.440]                       master <- NULL
[13:21:56.440]                       while (!identical(envir, .GlobalEnv) && 
[13:21:56.440]                         !identical(envir, emptyenv())) {
[13:21:56.440]                         if (exists("master", mode = "list", envir = envir, 
[13:21:56.440]                           inherits = FALSE)) {
[13:21:56.440]                           master <- get("master", mode = "list", 
[13:21:56.440]                             envir = envir, inherits = FALSE)
[13:21:56.440]                           if (inherits(master, c("SOCKnode", 
[13:21:56.440]                             "SOCK0node"))) {
[13:21:56.440]                             sendCondition <<- function(cond) {
[13:21:56.440]                               data <- list(type = "VALUE", value = cond, 
[13:21:56.440]                                 success = TRUE)
[13:21:56.440]                               parallel_sendData(master, data)
[13:21:56.440]                             }
[13:21:56.440]                             return(sendCondition)
[13:21:56.440]                           }
[13:21:56.440]                         }
[13:21:56.440]                         frame <- frame + 1L
[13:21:56.440]                         envir <- sys.frame(frame)
[13:21:56.440]                       }
[13:21:56.440]                     }
[13:21:56.440]                     sendCondition <<- function(cond) NULL
[13:21:56.440]                   }
[13:21:56.440]                 })
[13:21:56.440]                 withCallingHandlers({
[13:21:56.440]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:21:56.440]                 }, immediateCondition = function(cond) {
[13:21:56.440]                   sendCondition <- ...future.makeSendCondition()
[13:21:56.440]                   sendCondition(cond)
[13:21:56.440]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:56.440]                   {
[13:21:56.440]                     inherits <- base::inherits
[13:21:56.440]                     invokeRestart <- base::invokeRestart
[13:21:56.440]                     is.null <- base::is.null
[13:21:56.440]                     muffled <- FALSE
[13:21:56.440]                     if (inherits(cond, "message")) {
[13:21:56.440]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:56.440]                       if (muffled) 
[13:21:56.440]                         invokeRestart("muffleMessage")
[13:21:56.440]                     }
[13:21:56.440]                     else if (inherits(cond, "warning")) {
[13:21:56.440]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:56.440]                       if (muffled) 
[13:21:56.440]                         invokeRestart("muffleWarning")
[13:21:56.440]                     }
[13:21:56.440]                     else if (inherits(cond, "condition")) {
[13:21:56.440]                       if (!is.null(pattern)) {
[13:21:56.440]                         computeRestarts <- base::computeRestarts
[13:21:56.440]                         grepl <- base::grepl
[13:21:56.440]                         restarts <- computeRestarts(cond)
[13:21:56.440]                         for (restart in restarts) {
[13:21:56.440]                           name <- restart$name
[13:21:56.440]                           if (is.null(name)) 
[13:21:56.440]                             next
[13:21:56.440]                           if (!grepl(pattern, name)) 
[13:21:56.440]                             next
[13:21:56.440]                           invokeRestart(restart)
[13:21:56.440]                           muffled <- TRUE
[13:21:56.440]                           break
[13:21:56.440]                         }
[13:21:56.440]                       }
[13:21:56.440]                     }
[13:21:56.440]                     invisible(muffled)
[13:21:56.440]                   }
[13:21:56.440]                   muffleCondition(cond)
[13:21:56.440]                 })
[13:21:56.440]             }))
[13:21:56.440]             future::FutureResult(value = ...future.value$value, 
[13:21:56.440]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:56.440]                   ...future.rng), globalenv = if (FALSE) 
[13:21:56.440]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:56.440]                     ...future.globalenv.names))
[13:21:56.440]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:56.440]         }, condition = base::local({
[13:21:56.440]             c <- base::c
[13:21:56.440]             inherits <- base::inherits
[13:21:56.440]             invokeRestart <- base::invokeRestart
[13:21:56.440]             length <- base::length
[13:21:56.440]             list <- base::list
[13:21:56.440]             seq.int <- base::seq.int
[13:21:56.440]             signalCondition <- base::signalCondition
[13:21:56.440]             sys.calls <- base::sys.calls
[13:21:56.440]             `[[` <- base::`[[`
[13:21:56.440]             `+` <- base::`+`
[13:21:56.440]             `<<-` <- base::`<<-`
[13:21:56.440]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:56.440]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:56.440]                   3L)]
[13:21:56.440]             }
[13:21:56.440]             function(cond) {
[13:21:56.440]                 is_error <- inherits(cond, "error")
[13:21:56.440]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:56.440]                   NULL)
[13:21:56.440]                 if (is_error) {
[13:21:56.440]                   sessionInformation <- function() {
[13:21:56.440]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:56.440]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:56.440]                       search = base::search(), system = base::Sys.info())
[13:21:56.440]                   }
[13:21:56.440]                   ...future.conditions[[length(...future.conditions) + 
[13:21:56.440]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:56.440]                     cond$call), session = sessionInformation(), 
[13:21:56.440]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:56.440]                   signalCondition(cond)
[13:21:56.440]                 }
[13:21:56.440]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:56.440]                 "immediateCondition"))) {
[13:21:56.440]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:56.440]                   ...future.conditions[[length(...future.conditions) + 
[13:21:56.440]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:56.440]                   if (TRUE && !signal) {
[13:21:56.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:56.440]                     {
[13:21:56.440]                       inherits <- base::inherits
[13:21:56.440]                       invokeRestart <- base::invokeRestart
[13:21:56.440]                       is.null <- base::is.null
[13:21:56.440]                       muffled <- FALSE
[13:21:56.440]                       if (inherits(cond, "message")) {
[13:21:56.440]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:56.440]                         if (muffled) 
[13:21:56.440]                           invokeRestart("muffleMessage")
[13:21:56.440]                       }
[13:21:56.440]                       else if (inherits(cond, "warning")) {
[13:21:56.440]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:56.440]                         if (muffled) 
[13:21:56.440]                           invokeRestart("muffleWarning")
[13:21:56.440]                       }
[13:21:56.440]                       else if (inherits(cond, "condition")) {
[13:21:56.440]                         if (!is.null(pattern)) {
[13:21:56.440]                           computeRestarts <- base::computeRestarts
[13:21:56.440]                           grepl <- base::grepl
[13:21:56.440]                           restarts <- computeRestarts(cond)
[13:21:56.440]                           for (restart in restarts) {
[13:21:56.440]                             name <- restart$name
[13:21:56.440]                             if (is.null(name)) 
[13:21:56.440]                               next
[13:21:56.440]                             if (!grepl(pattern, name)) 
[13:21:56.440]                               next
[13:21:56.440]                             invokeRestart(restart)
[13:21:56.440]                             muffled <- TRUE
[13:21:56.440]                             break
[13:21:56.440]                           }
[13:21:56.440]                         }
[13:21:56.440]                       }
[13:21:56.440]                       invisible(muffled)
[13:21:56.440]                     }
[13:21:56.440]                     muffleCondition(cond, pattern = "^muffle")
[13:21:56.440]                   }
[13:21:56.440]                 }
[13:21:56.440]                 else {
[13:21:56.440]                   if (TRUE) {
[13:21:56.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:56.440]                     {
[13:21:56.440]                       inherits <- base::inherits
[13:21:56.440]                       invokeRestart <- base::invokeRestart
[13:21:56.440]                       is.null <- base::is.null
[13:21:56.440]                       muffled <- FALSE
[13:21:56.440]                       if (inherits(cond, "message")) {
[13:21:56.440]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:56.440]                         if (muffled) 
[13:21:56.440]                           invokeRestart("muffleMessage")
[13:21:56.440]                       }
[13:21:56.440]                       else if (inherits(cond, "warning")) {
[13:21:56.440]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:56.440]                         if (muffled) 
[13:21:56.440]                           invokeRestart("muffleWarning")
[13:21:56.440]                       }
[13:21:56.440]                       else if (inherits(cond, "condition")) {
[13:21:56.440]                         if (!is.null(pattern)) {
[13:21:56.440]                           computeRestarts <- base::computeRestarts
[13:21:56.440]                           grepl <- base::grepl
[13:21:56.440]                           restarts <- computeRestarts(cond)
[13:21:56.440]                           for (restart in restarts) {
[13:21:56.440]                             name <- restart$name
[13:21:56.440]                             if (is.null(name)) 
[13:21:56.440]                               next
[13:21:56.440]                             if (!grepl(pattern, name)) 
[13:21:56.440]                               next
[13:21:56.440]                             invokeRestart(restart)
[13:21:56.440]                             muffled <- TRUE
[13:21:56.440]                             break
[13:21:56.440]                           }
[13:21:56.440]                         }
[13:21:56.440]                       }
[13:21:56.440]                       invisible(muffled)
[13:21:56.440]                     }
[13:21:56.440]                     muffleCondition(cond, pattern = "^muffle")
[13:21:56.440]                   }
[13:21:56.440]                 }
[13:21:56.440]             }
[13:21:56.440]         }))
[13:21:56.440]     }, error = function(ex) {
[13:21:56.440]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:56.440]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:56.440]                 ...future.rng), started = ...future.startTime, 
[13:21:56.440]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:56.440]             version = "1.8"), class = "FutureResult")
[13:21:56.440]     }, finally = {
[13:21:56.440]         if (!identical(...future.workdir, getwd())) 
[13:21:56.440]             setwd(...future.workdir)
[13:21:56.440]         {
[13:21:56.440]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:56.440]                 ...future.oldOptions$nwarnings <- NULL
[13:21:56.440]             }
[13:21:56.440]             base::options(...future.oldOptions)
[13:21:56.440]             if (.Platform$OS.type == "windows") {
[13:21:56.440]                 old_names <- names(...future.oldEnvVars)
[13:21:56.440]                 envs <- base::Sys.getenv()
[13:21:56.440]                 names <- names(envs)
[13:21:56.440]                 common <- intersect(names, old_names)
[13:21:56.440]                 added <- setdiff(names, old_names)
[13:21:56.440]                 removed <- setdiff(old_names, names)
[13:21:56.440]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:56.440]                   envs[common]]
[13:21:56.440]                 NAMES <- toupper(changed)
[13:21:56.440]                 args <- list()
[13:21:56.440]                 for (kk in seq_along(NAMES)) {
[13:21:56.440]                   name <- changed[[kk]]
[13:21:56.440]                   NAME <- NAMES[[kk]]
[13:21:56.440]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:56.440]                     next
[13:21:56.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:56.440]                 }
[13:21:56.440]                 NAMES <- toupper(added)
[13:21:56.440]                 for (kk in seq_along(NAMES)) {
[13:21:56.440]                   name <- added[[kk]]
[13:21:56.440]                   NAME <- NAMES[[kk]]
[13:21:56.440]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:56.440]                     next
[13:21:56.440]                   args[[name]] <- ""
[13:21:56.440]                 }
[13:21:56.440]                 NAMES <- toupper(removed)
[13:21:56.440]                 for (kk in seq_along(NAMES)) {
[13:21:56.440]                   name <- removed[[kk]]
[13:21:56.440]                   NAME <- NAMES[[kk]]
[13:21:56.440]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:56.440]                     next
[13:21:56.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:56.440]                 }
[13:21:56.440]                 if (length(args) > 0) 
[13:21:56.440]                   base::do.call(base::Sys.setenv, args = args)
[13:21:56.440]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:56.440]             }
[13:21:56.440]             else {
[13:21:56.440]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:56.440]             }
[13:21:56.440]             {
[13:21:56.440]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:56.440]                   0L) {
[13:21:56.440]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:56.440]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:56.440]                   base::options(opts)
[13:21:56.440]                 }
[13:21:56.440]                 {
[13:21:56.440]                   {
[13:21:56.440]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:56.440]                     NULL
[13:21:56.440]                   }
[13:21:56.440]                   options(future.plan = NULL)
[13:21:56.440]                   if (is.na(NA_character_)) 
[13:21:56.440]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:56.440]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:56.440]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:56.440]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:56.440]                     envir = parent.frame()) 
[13:21:56.440]                   {
[13:21:56.440]                     if (is.function(workers)) 
[13:21:56.440]                       workers <- workers()
[13:21:56.440]                     workers <- structure(as.integer(workers), 
[13:21:56.440]                       class = class(workers))
[13:21:56.440]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:56.440]                       workers >= 1)
[13:21:56.440]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:56.440]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:56.440]                     }
[13:21:56.440]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:56.440]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:56.440]                       envir = envir)
[13:21:56.440]                     if (!future$lazy) 
[13:21:56.440]                       future <- run(future)
[13:21:56.440]                     invisible(future)
[13:21:56.440]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:56.440]                 }
[13:21:56.440]             }
[13:21:56.440]         }
[13:21:56.440]     })
[13:21:56.440]     if (TRUE) {
[13:21:56.440]         base::sink(type = "output", split = FALSE)
[13:21:56.440]         if (TRUE) {
[13:21:56.440]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:56.440]         }
[13:21:56.440]         else {
[13:21:56.440]             ...future.result["stdout"] <- base::list(NULL)
[13:21:56.440]         }
[13:21:56.440]         base::close(...future.stdout)
[13:21:56.440]         ...future.stdout <- NULL
[13:21:56.440]     }
[13:21:56.440]     ...future.result$conditions <- ...future.conditions
[13:21:56.440]     ...future.result$finished <- base::Sys.time()
[13:21:56.440]     ...future.result
[13:21:56.440] }
[13:21:56.443] MultisessionFuture started
[13:21:56.443] - Launch lazy future ... done
[13:21:56.443] run() for ‘MultisessionFuture’ ... done
[13:21:56.490] receiveMessageFromWorker() for ClusterFuture ...
[13:21:56.490] - Validating connection of MultisessionFuture
[13:21:56.491] - received message: FutureResult
[13:21:56.491] - Received FutureResult
[13:21:56.491] - Erased future from FutureRegistry
[13:21:56.491] result() for ClusterFuture ...
[13:21:56.491] - result already collected: FutureResult
[13:21:56.491] result() for ClusterFuture ... done
[13:21:56.491] signalConditions() ...
[13:21:56.491]  - include = ‘immediateCondition’
[13:21:56.491]  - exclude = 
[13:21:56.492]  - resignal = FALSE
[13:21:56.492]  - Number of conditions: 1
[13:21:56.492] signalConditions() ... done
[13:21:56.492] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:56.492] A MultisessionFuture was resolved
- result = TRUE, recursive = 1 ... DONE
- result = TRUE, recursive = 2 ...
[13:21:56.492] getGlobalsAndPackages() ...
[13:21:56.492] Searching for globals...
[13:21:56.493] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:21:56.494] Searching for globals ... DONE
[13:21:56.494] Resolving globals: FALSE
[13:21:56.494] 
[13:21:56.494] 
[13:21:56.494] getGlobalsAndPackages() ... DONE
[13:21:56.494] run() for ‘Future’ ...
[13:21:56.495] - state: ‘created’
[13:21:56.495] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:56.509] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:56.509] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:56.509]   - Field: ‘node’
[13:21:56.510]   - Field: ‘label’
[13:21:56.510]   - Field: ‘local’
[13:21:56.510]   - Field: ‘owner’
[13:21:56.510]   - Field: ‘envir’
[13:21:56.510]   - Field: ‘workers’
[13:21:56.510]   - Field: ‘packages’
[13:21:56.510]   - Field: ‘gc’
[13:21:56.510]   - Field: ‘conditions’
[13:21:56.510]   - Field: ‘persistent’
[13:21:56.510]   - Field: ‘expr’
[13:21:56.511]   - Field: ‘uuid’
[13:21:56.511]   - Field: ‘seed’
[13:21:56.511]   - Field: ‘version’
[13:21:56.511]   - Field: ‘result’
[13:21:56.511]   - Field: ‘asynchronous’
[13:21:56.511]   - Field: ‘calls’
[13:21:56.511]   - Field: ‘globals’
[13:21:56.511]   - Field: ‘stdout’
[13:21:56.511]   - Field: ‘earlySignal’
[13:21:56.511]   - Field: ‘lazy’
[13:21:56.511]   - Field: ‘state’
[13:21:56.512] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:56.512] - Launch lazy future ...
[13:21:56.512] Packages needed by the future expression (n = 0): <none>
[13:21:56.512] Packages needed by future strategies (n = 0): <none>
[13:21:56.513] {
[13:21:56.513]     {
[13:21:56.513]         {
[13:21:56.513]             ...future.startTime <- base::Sys.time()
[13:21:56.513]             {
[13:21:56.513]                 {
[13:21:56.513]                   {
[13:21:56.513]                     {
[13:21:56.513]                       base::local({
[13:21:56.513]                         has_future <- base::requireNamespace("future", 
[13:21:56.513]                           quietly = TRUE)
[13:21:56.513]                         if (has_future) {
[13:21:56.513]                           ns <- base::getNamespace("future")
[13:21:56.513]                           version <- ns[[".package"]][["version"]]
[13:21:56.513]                           if (is.null(version)) 
[13:21:56.513]                             version <- utils::packageVersion("future")
[13:21:56.513]                         }
[13:21:56.513]                         else {
[13:21:56.513]                           version <- NULL
[13:21:56.513]                         }
[13:21:56.513]                         if (!has_future || version < "1.8.0") {
[13:21:56.513]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:56.513]                             "", base::R.version$version.string), 
[13:21:56.513]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:56.513]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:56.513]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:56.513]                               "release", "version")], collapse = " "), 
[13:21:56.513]                             hostname = base::Sys.info()[["nodename"]])
[13:21:56.513]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:56.513]                             info)
[13:21:56.513]                           info <- base::paste(info, collapse = "; ")
[13:21:56.513]                           if (!has_future) {
[13:21:56.513]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:56.513]                               info)
[13:21:56.513]                           }
[13:21:56.513]                           else {
[13:21:56.513]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:56.513]                               info, version)
[13:21:56.513]                           }
[13:21:56.513]                           base::stop(msg)
[13:21:56.513]                         }
[13:21:56.513]                       })
[13:21:56.513]                     }
[13:21:56.513]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:56.513]                     base::options(mc.cores = 1L)
[13:21:56.513]                   }
[13:21:56.513]                   options(future.plan = NULL)
[13:21:56.513]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:56.513]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:56.513]                 }
[13:21:56.513]                 ...future.workdir <- getwd()
[13:21:56.513]             }
[13:21:56.513]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:56.513]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:56.513]         }
[13:21:56.513]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:56.513]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:56.513]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:56.513]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:56.513]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:56.513]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:56.513]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:56.513]             base::names(...future.oldOptions))
[13:21:56.513]     }
[13:21:56.513]     if (FALSE) {
[13:21:56.513]     }
[13:21:56.513]     else {
[13:21:56.513]         if (TRUE) {
[13:21:56.513]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:56.513]                 open = "w")
[13:21:56.513]         }
[13:21:56.513]         else {
[13:21:56.513]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:56.513]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:56.513]         }
[13:21:56.513]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:56.513]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:56.513]             base::sink(type = "output", split = FALSE)
[13:21:56.513]             base::close(...future.stdout)
[13:21:56.513]         }, add = TRUE)
[13:21:56.513]     }
[13:21:56.513]     ...future.frame <- base::sys.nframe()
[13:21:56.513]     ...future.conditions <- base::list()
[13:21:56.513]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:56.513]     if (FALSE) {
[13:21:56.513]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:56.513]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:56.513]     }
[13:21:56.513]     ...future.result <- base::tryCatch({
[13:21:56.513]         base::withCallingHandlers({
[13:21:56.513]             ...future.value <- base::withVisible(base::local({
[13:21:56.513]                 ...future.makeSendCondition <- local({
[13:21:56.513]                   sendCondition <- NULL
[13:21:56.513]                   function(frame = 1L) {
[13:21:56.513]                     if (is.function(sendCondition)) 
[13:21:56.513]                       return(sendCondition)
[13:21:56.513]                     ns <- getNamespace("parallel")
[13:21:56.513]                     if (exists("sendData", mode = "function", 
[13:21:56.513]                       envir = ns)) {
[13:21:56.513]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:56.513]                         envir = ns)
[13:21:56.513]                       envir <- sys.frame(frame)
[13:21:56.513]                       master <- NULL
[13:21:56.513]                       while (!identical(envir, .GlobalEnv) && 
[13:21:56.513]                         !identical(envir, emptyenv())) {
[13:21:56.513]                         if (exists("master", mode = "list", envir = envir, 
[13:21:56.513]                           inherits = FALSE)) {
[13:21:56.513]                           master <- get("master", mode = "list", 
[13:21:56.513]                             envir = envir, inherits = FALSE)
[13:21:56.513]                           if (inherits(master, c("SOCKnode", 
[13:21:56.513]                             "SOCK0node"))) {
[13:21:56.513]                             sendCondition <<- function(cond) {
[13:21:56.513]                               data <- list(type = "VALUE", value = cond, 
[13:21:56.513]                                 success = TRUE)
[13:21:56.513]                               parallel_sendData(master, data)
[13:21:56.513]                             }
[13:21:56.513]                             return(sendCondition)
[13:21:56.513]                           }
[13:21:56.513]                         }
[13:21:56.513]                         frame <- frame + 1L
[13:21:56.513]                         envir <- sys.frame(frame)
[13:21:56.513]                       }
[13:21:56.513]                     }
[13:21:56.513]                     sendCondition <<- function(cond) NULL
[13:21:56.513]                   }
[13:21:56.513]                 })
[13:21:56.513]                 withCallingHandlers({
[13:21:56.513]                   {
[13:21:56.513]                     Sys.sleep(0.5)
[13:21:56.513]                     list(a = 1, b = 42L)
[13:21:56.513]                   }
[13:21:56.513]                 }, immediateCondition = function(cond) {
[13:21:56.513]                   sendCondition <- ...future.makeSendCondition()
[13:21:56.513]                   sendCondition(cond)
[13:21:56.513]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:56.513]                   {
[13:21:56.513]                     inherits <- base::inherits
[13:21:56.513]                     invokeRestart <- base::invokeRestart
[13:21:56.513]                     is.null <- base::is.null
[13:21:56.513]                     muffled <- FALSE
[13:21:56.513]                     if (inherits(cond, "message")) {
[13:21:56.513]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:56.513]                       if (muffled) 
[13:21:56.513]                         invokeRestart("muffleMessage")
[13:21:56.513]                     }
[13:21:56.513]                     else if (inherits(cond, "warning")) {
[13:21:56.513]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:56.513]                       if (muffled) 
[13:21:56.513]                         invokeRestart("muffleWarning")
[13:21:56.513]                     }
[13:21:56.513]                     else if (inherits(cond, "condition")) {
[13:21:56.513]                       if (!is.null(pattern)) {
[13:21:56.513]                         computeRestarts <- base::computeRestarts
[13:21:56.513]                         grepl <- base::grepl
[13:21:56.513]                         restarts <- computeRestarts(cond)
[13:21:56.513]                         for (restart in restarts) {
[13:21:56.513]                           name <- restart$name
[13:21:56.513]                           if (is.null(name)) 
[13:21:56.513]                             next
[13:21:56.513]                           if (!grepl(pattern, name)) 
[13:21:56.513]                             next
[13:21:56.513]                           invokeRestart(restart)
[13:21:56.513]                           muffled <- TRUE
[13:21:56.513]                           break
[13:21:56.513]                         }
[13:21:56.513]                       }
[13:21:56.513]                     }
[13:21:56.513]                     invisible(muffled)
[13:21:56.513]                   }
[13:21:56.513]                   muffleCondition(cond)
[13:21:56.513]                 })
[13:21:56.513]             }))
[13:21:56.513]             future::FutureResult(value = ...future.value$value, 
[13:21:56.513]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:56.513]                   ...future.rng), globalenv = if (FALSE) 
[13:21:56.513]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:56.513]                     ...future.globalenv.names))
[13:21:56.513]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:56.513]         }, condition = base::local({
[13:21:56.513]             c <- base::c
[13:21:56.513]             inherits <- base::inherits
[13:21:56.513]             invokeRestart <- base::invokeRestart
[13:21:56.513]             length <- base::length
[13:21:56.513]             list <- base::list
[13:21:56.513]             seq.int <- base::seq.int
[13:21:56.513]             signalCondition <- base::signalCondition
[13:21:56.513]             sys.calls <- base::sys.calls
[13:21:56.513]             `[[` <- base::`[[`
[13:21:56.513]             `+` <- base::`+`
[13:21:56.513]             `<<-` <- base::`<<-`
[13:21:56.513]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:56.513]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:56.513]                   3L)]
[13:21:56.513]             }
[13:21:56.513]             function(cond) {
[13:21:56.513]                 is_error <- inherits(cond, "error")
[13:21:56.513]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:56.513]                   NULL)
[13:21:56.513]                 if (is_error) {
[13:21:56.513]                   sessionInformation <- function() {
[13:21:56.513]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:56.513]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:56.513]                       search = base::search(), system = base::Sys.info())
[13:21:56.513]                   }
[13:21:56.513]                   ...future.conditions[[length(...future.conditions) + 
[13:21:56.513]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:56.513]                     cond$call), session = sessionInformation(), 
[13:21:56.513]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:56.513]                   signalCondition(cond)
[13:21:56.513]                 }
[13:21:56.513]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:56.513]                 "immediateCondition"))) {
[13:21:56.513]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:56.513]                   ...future.conditions[[length(...future.conditions) + 
[13:21:56.513]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:56.513]                   if (TRUE && !signal) {
[13:21:56.513]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:56.513]                     {
[13:21:56.513]                       inherits <- base::inherits
[13:21:56.513]                       invokeRestart <- base::invokeRestart
[13:21:56.513]                       is.null <- base::is.null
[13:21:56.513]                       muffled <- FALSE
[13:21:56.513]                       if (inherits(cond, "message")) {
[13:21:56.513]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:56.513]                         if (muffled) 
[13:21:56.513]                           invokeRestart("muffleMessage")
[13:21:56.513]                       }
[13:21:56.513]                       else if (inherits(cond, "warning")) {
[13:21:56.513]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:56.513]                         if (muffled) 
[13:21:56.513]                           invokeRestart("muffleWarning")
[13:21:56.513]                       }
[13:21:56.513]                       else if (inherits(cond, "condition")) {
[13:21:56.513]                         if (!is.null(pattern)) {
[13:21:56.513]                           computeRestarts <- base::computeRestarts
[13:21:56.513]                           grepl <- base::grepl
[13:21:56.513]                           restarts <- computeRestarts(cond)
[13:21:56.513]                           for (restart in restarts) {
[13:21:56.513]                             name <- restart$name
[13:21:56.513]                             if (is.null(name)) 
[13:21:56.513]                               next
[13:21:56.513]                             if (!grepl(pattern, name)) 
[13:21:56.513]                               next
[13:21:56.513]                             invokeRestart(restart)
[13:21:56.513]                             muffled <- TRUE
[13:21:56.513]                             break
[13:21:56.513]                           }
[13:21:56.513]                         }
[13:21:56.513]                       }
[13:21:56.513]                       invisible(muffled)
[13:21:56.513]                     }
[13:21:56.513]                     muffleCondition(cond, pattern = "^muffle")
[13:21:56.513]                   }
[13:21:56.513]                 }
[13:21:56.513]                 else {
[13:21:56.513]                   if (TRUE) {
[13:21:56.513]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:56.513]                     {
[13:21:56.513]                       inherits <- base::inherits
[13:21:56.513]                       invokeRestart <- base::invokeRestart
[13:21:56.513]                       is.null <- base::is.null
[13:21:56.513]                       muffled <- FALSE
[13:21:56.513]                       if (inherits(cond, "message")) {
[13:21:56.513]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:56.513]                         if (muffled) 
[13:21:56.513]                           invokeRestart("muffleMessage")
[13:21:56.513]                       }
[13:21:56.513]                       else if (inherits(cond, "warning")) {
[13:21:56.513]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:56.513]                         if (muffled) 
[13:21:56.513]                           invokeRestart("muffleWarning")
[13:21:56.513]                       }
[13:21:56.513]                       else if (inherits(cond, "condition")) {
[13:21:56.513]                         if (!is.null(pattern)) {
[13:21:56.513]                           computeRestarts <- base::computeRestarts
[13:21:56.513]                           grepl <- base::grepl
[13:21:56.513]                           restarts <- computeRestarts(cond)
[13:21:56.513]                           for (restart in restarts) {
[13:21:56.513]                             name <- restart$name
[13:21:56.513]                             if (is.null(name)) 
[13:21:56.513]                               next
[13:21:56.513]                             if (!grepl(pattern, name)) 
[13:21:56.513]                               next
[13:21:56.513]                             invokeRestart(restart)
[13:21:56.513]                             muffled <- TRUE
[13:21:56.513]                             break
[13:21:56.513]                           }
[13:21:56.513]                         }
[13:21:56.513]                       }
[13:21:56.513]                       invisible(muffled)
[13:21:56.513]                     }
[13:21:56.513]                     muffleCondition(cond, pattern = "^muffle")
[13:21:56.513]                   }
[13:21:56.513]                 }
[13:21:56.513]             }
[13:21:56.513]         }))
[13:21:56.513]     }, error = function(ex) {
[13:21:56.513]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:56.513]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:56.513]                 ...future.rng), started = ...future.startTime, 
[13:21:56.513]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:56.513]             version = "1.8"), class = "FutureResult")
[13:21:56.513]     }, finally = {
[13:21:56.513]         if (!identical(...future.workdir, getwd())) 
[13:21:56.513]             setwd(...future.workdir)
[13:21:56.513]         {
[13:21:56.513]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:56.513]                 ...future.oldOptions$nwarnings <- NULL
[13:21:56.513]             }
[13:21:56.513]             base::options(...future.oldOptions)
[13:21:56.513]             if (.Platform$OS.type == "windows") {
[13:21:56.513]                 old_names <- names(...future.oldEnvVars)
[13:21:56.513]                 envs <- base::Sys.getenv()
[13:21:56.513]                 names <- names(envs)
[13:21:56.513]                 common <- intersect(names, old_names)
[13:21:56.513]                 added <- setdiff(names, old_names)
[13:21:56.513]                 removed <- setdiff(old_names, names)
[13:21:56.513]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:56.513]                   envs[common]]
[13:21:56.513]                 NAMES <- toupper(changed)
[13:21:56.513]                 args <- list()
[13:21:56.513]                 for (kk in seq_along(NAMES)) {
[13:21:56.513]                   name <- changed[[kk]]
[13:21:56.513]                   NAME <- NAMES[[kk]]
[13:21:56.513]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:56.513]                     next
[13:21:56.513]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:56.513]                 }
[13:21:56.513]                 NAMES <- toupper(added)
[13:21:56.513]                 for (kk in seq_along(NAMES)) {
[13:21:56.513]                   name <- added[[kk]]
[13:21:56.513]                   NAME <- NAMES[[kk]]
[13:21:56.513]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:56.513]                     next
[13:21:56.513]                   args[[name]] <- ""
[13:21:56.513]                 }
[13:21:56.513]                 NAMES <- toupper(removed)
[13:21:56.513]                 for (kk in seq_along(NAMES)) {
[13:21:56.513]                   name <- removed[[kk]]
[13:21:56.513]                   NAME <- NAMES[[kk]]
[13:21:56.513]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:56.513]                     next
[13:21:56.513]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:56.513]                 }
[13:21:56.513]                 if (length(args) > 0) 
[13:21:56.513]                   base::do.call(base::Sys.setenv, args = args)
[13:21:56.513]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:56.513]             }
[13:21:56.513]             else {
[13:21:56.513]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:56.513]             }
[13:21:56.513]             {
[13:21:56.513]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:56.513]                   0L) {
[13:21:56.513]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:56.513]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:56.513]                   base::options(opts)
[13:21:56.513]                 }
[13:21:56.513]                 {
[13:21:56.513]                   {
[13:21:56.513]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:56.513]                     NULL
[13:21:56.513]                   }
[13:21:56.513]                   options(future.plan = NULL)
[13:21:56.513]                   if (is.na(NA_character_)) 
[13:21:56.513]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:56.513]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:56.513]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:56.513]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:56.513]                     envir = parent.frame()) 
[13:21:56.513]                   {
[13:21:56.513]                     if (is.function(workers)) 
[13:21:56.513]                       workers <- workers()
[13:21:56.513]                     workers <- structure(as.integer(workers), 
[13:21:56.513]                       class = class(workers))
[13:21:56.513]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:56.513]                       workers >= 1)
[13:21:56.513]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:56.513]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:56.513]                     }
[13:21:56.513]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:56.513]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:56.513]                       envir = envir)
[13:21:56.513]                     if (!future$lazy) 
[13:21:56.513]                       future <- run(future)
[13:21:56.513]                     invisible(future)
[13:21:56.513]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:56.513]                 }
[13:21:56.513]             }
[13:21:56.513]         }
[13:21:56.513]     })
[13:21:56.513]     if (TRUE) {
[13:21:56.513]         base::sink(type = "output", split = FALSE)
[13:21:56.513]         if (TRUE) {
[13:21:56.513]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:56.513]         }
[13:21:56.513]         else {
[13:21:56.513]             ...future.result["stdout"] <- base::list(NULL)
[13:21:56.513]         }
[13:21:56.513]         base::close(...future.stdout)
[13:21:56.513]         ...future.stdout <- NULL
[13:21:56.513]     }
[13:21:56.513]     ...future.result$conditions <- ...future.conditions
[13:21:56.513]     ...future.result$finished <- base::Sys.time()
[13:21:56.513]     ...future.result
[13:21:56.513] }
[13:21:56.516] MultisessionFuture started
[13:21:56.516] - Launch lazy future ... done
[13:21:56.516] run() for ‘MultisessionFuture’ ... done
[13:21:57.063] receiveMessageFromWorker() for ClusterFuture ...
[13:21:57.063] - Validating connection of MultisessionFuture
[13:21:57.063] - received message: FutureResult
[13:21:57.063] - Received FutureResult
[13:21:57.063] - Erased future from FutureRegistry
[13:21:57.064] result() for ClusterFuture ...
[13:21:57.064] - result already collected: FutureResult
[13:21:57.064] result() for ClusterFuture ... done
[13:21:57.064] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:57.064] resolve() on list ...
[13:21:57.064]  recursive: 1
[13:21:57.064]  length: 2
[13:21:57.064]  elements: ‘a’, ‘b’
[13:21:57.065]  length: 1 (resolved future 1)
[13:21:57.065]  length: 0 (resolved future 2)
[13:21:57.065] resolve() on list ... DONE
[13:21:57.065] A MultisessionFuture was resolved (and resolved itself)
[13:21:57.065] getGlobalsAndPackages() ...
[13:21:57.065] Searching for globals...
[13:21:57.066] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:21:57.066] Searching for globals ... DONE
[13:21:57.066] Resolving globals: FALSE
[13:21:57.067] 
[13:21:57.067] 
[13:21:57.067] getGlobalsAndPackages() ... DONE
[13:21:57.067] run() for ‘Future’ ...
[13:21:57.067] - state: ‘created’
[13:21:57.067] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:57.082] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:57.082] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:57.082]   - Field: ‘node’
[13:21:57.082]   - Field: ‘label’
[13:21:57.082]   - Field: ‘local’
[13:21:57.082]   - Field: ‘owner’
[13:21:57.082]   - Field: ‘envir’
[13:21:57.083]   - Field: ‘workers’
[13:21:57.083]   - Field: ‘packages’
[13:21:57.083]   - Field: ‘gc’
[13:21:57.083]   - Field: ‘conditions’
[13:21:57.083]   - Field: ‘persistent’
[13:21:57.083]   - Field: ‘expr’
[13:21:57.083]   - Field: ‘uuid’
[13:21:57.083]   - Field: ‘seed’
[13:21:57.083]   - Field: ‘version’
[13:21:57.083]   - Field: ‘result’
[13:21:57.084]   - Field: ‘asynchronous’
[13:21:57.084]   - Field: ‘calls’
[13:21:57.084]   - Field: ‘globals’
[13:21:57.084]   - Field: ‘stdout’
[13:21:57.084]   - Field: ‘earlySignal’
[13:21:57.084]   - Field: ‘lazy’
[13:21:57.084]   - Field: ‘state’
[13:21:57.084] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:57.084] - Launch lazy future ...
[13:21:57.085] Packages needed by the future expression (n = 0): <none>
[13:21:57.085] Packages needed by future strategies (n = 0): <none>
[13:21:57.085] {
[13:21:57.085]     {
[13:21:57.085]         {
[13:21:57.085]             ...future.startTime <- base::Sys.time()
[13:21:57.085]             {
[13:21:57.085]                 {
[13:21:57.085]                   {
[13:21:57.085]                     {
[13:21:57.085]                       base::local({
[13:21:57.085]                         has_future <- base::requireNamespace("future", 
[13:21:57.085]                           quietly = TRUE)
[13:21:57.085]                         if (has_future) {
[13:21:57.085]                           ns <- base::getNamespace("future")
[13:21:57.085]                           version <- ns[[".package"]][["version"]]
[13:21:57.085]                           if (is.null(version)) 
[13:21:57.085]                             version <- utils::packageVersion("future")
[13:21:57.085]                         }
[13:21:57.085]                         else {
[13:21:57.085]                           version <- NULL
[13:21:57.085]                         }
[13:21:57.085]                         if (!has_future || version < "1.8.0") {
[13:21:57.085]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:57.085]                             "", base::R.version$version.string), 
[13:21:57.085]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:57.085]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:57.085]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:57.085]                               "release", "version")], collapse = " "), 
[13:21:57.085]                             hostname = base::Sys.info()[["nodename"]])
[13:21:57.085]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:57.085]                             info)
[13:21:57.085]                           info <- base::paste(info, collapse = "; ")
[13:21:57.085]                           if (!has_future) {
[13:21:57.085]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:57.085]                               info)
[13:21:57.085]                           }
[13:21:57.085]                           else {
[13:21:57.085]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:57.085]                               info, version)
[13:21:57.085]                           }
[13:21:57.085]                           base::stop(msg)
[13:21:57.085]                         }
[13:21:57.085]                       })
[13:21:57.085]                     }
[13:21:57.085]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:57.085]                     base::options(mc.cores = 1L)
[13:21:57.085]                   }
[13:21:57.085]                   options(future.plan = NULL)
[13:21:57.085]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:57.085]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:57.085]                 }
[13:21:57.085]                 ...future.workdir <- getwd()
[13:21:57.085]             }
[13:21:57.085]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:57.085]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:57.085]         }
[13:21:57.085]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:57.085]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:57.085]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:57.085]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:57.085]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:57.085]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:57.085]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:57.085]             base::names(...future.oldOptions))
[13:21:57.085]     }
[13:21:57.085]     if (FALSE) {
[13:21:57.085]     }
[13:21:57.085]     else {
[13:21:57.085]         if (TRUE) {
[13:21:57.085]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:57.085]                 open = "w")
[13:21:57.085]         }
[13:21:57.085]         else {
[13:21:57.085]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:57.085]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:57.085]         }
[13:21:57.085]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:57.085]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:57.085]             base::sink(type = "output", split = FALSE)
[13:21:57.085]             base::close(...future.stdout)
[13:21:57.085]         }, add = TRUE)
[13:21:57.085]     }
[13:21:57.085]     ...future.frame <- base::sys.nframe()
[13:21:57.085]     ...future.conditions <- base::list()
[13:21:57.085]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:57.085]     if (FALSE) {
[13:21:57.085]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:57.085]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:57.085]     }
[13:21:57.085]     ...future.result <- base::tryCatch({
[13:21:57.085]         base::withCallingHandlers({
[13:21:57.085]             ...future.value <- base::withVisible(base::local({
[13:21:57.085]                 ...future.makeSendCondition <- local({
[13:21:57.085]                   sendCondition <- NULL
[13:21:57.085]                   function(frame = 1L) {
[13:21:57.085]                     if (is.function(sendCondition)) 
[13:21:57.085]                       return(sendCondition)
[13:21:57.085]                     ns <- getNamespace("parallel")
[13:21:57.085]                     if (exists("sendData", mode = "function", 
[13:21:57.085]                       envir = ns)) {
[13:21:57.085]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:57.085]                         envir = ns)
[13:21:57.085]                       envir <- sys.frame(frame)
[13:21:57.085]                       master <- NULL
[13:21:57.085]                       while (!identical(envir, .GlobalEnv) && 
[13:21:57.085]                         !identical(envir, emptyenv())) {
[13:21:57.085]                         if (exists("master", mode = "list", envir = envir, 
[13:21:57.085]                           inherits = FALSE)) {
[13:21:57.085]                           master <- get("master", mode = "list", 
[13:21:57.085]                             envir = envir, inherits = FALSE)
[13:21:57.085]                           if (inherits(master, c("SOCKnode", 
[13:21:57.085]                             "SOCK0node"))) {
[13:21:57.085]                             sendCondition <<- function(cond) {
[13:21:57.085]                               data <- list(type = "VALUE", value = cond, 
[13:21:57.085]                                 success = TRUE)
[13:21:57.085]                               parallel_sendData(master, data)
[13:21:57.085]                             }
[13:21:57.085]                             return(sendCondition)
[13:21:57.085]                           }
[13:21:57.085]                         }
[13:21:57.085]                         frame <- frame + 1L
[13:21:57.085]                         envir <- sys.frame(frame)
[13:21:57.085]                       }
[13:21:57.085]                     }
[13:21:57.085]                     sendCondition <<- function(cond) NULL
[13:21:57.085]                   }
[13:21:57.085]                 })
[13:21:57.085]                 withCallingHandlers({
[13:21:57.085]                   {
[13:21:57.085]                     Sys.sleep(0.5)
[13:21:57.085]                     list(a = 1, b = 42L)
[13:21:57.085]                   }
[13:21:57.085]                 }, immediateCondition = function(cond) {
[13:21:57.085]                   sendCondition <- ...future.makeSendCondition()
[13:21:57.085]                   sendCondition(cond)
[13:21:57.085]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:57.085]                   {
[13:21:57.085]                     inherits <- base::inherits
[13:21:57.085]                     invokeRestart <- base::invokeRestart
[13:21:57.085]                     is.null <- base::is.null
[13:21:57.085]                     muffled <- FALSE
[13:21:57.085]                     if (inherits(cond, "message")) {
[13:21:57.085]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:57.085]                       if (muffled) 
[13:21:57.085]                         invokeRestart("muffleMessage")
[13:21:57.085]                     }
[13:21:57.085]                     else if (inherits(cond, "warning")) {
[13:21:57.085]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:57.085]                       if (muffled) 
[13:21:57.085]                         invokeRestart("muffleWarning")
[13:21:57.085]                     }
[13:21:57.085]                     else if (inherits(cond, "condition")) {
[13:21:57.085]                       if (!is.null(pattern)) {
[13:21:57.085]                         computeRestarts <- base::computeRestarts
[13:21:57.085]                         grepl <- base::grepl
[13:21:57.085]                         restarts <- computeRestarts(cond)
[13:21:57.085]                         for (restart in restarts) {
[13:21:57.085]                           name <- restart$name
[13:21:57.085]                           if (is.null(name)) 
[13:21:57.085]                             next
[13:21:57.085]                           if (!grepl(pattern, name)) 
[13:21:57.085]                             next
[13:21:57.085]                           invokeRestart(restart)
[13:21:57.085]                           muffled <- TRUE
[13:21:57.085]                           break
[13:21:57.085]                         }
[13:21:57.085]                       }
[13:21:57.085]                     }
[13:21:57.085]                     invisible(muffled)
[13:21:57.085]                   }
[13:21:57.085]                   muffleCondition(cond)
[13:21:57.085]                 })
[13:21:57.085]             }))
[13:21:57.085]             future::FutureResult(value = ...future.value$value, 
[13:21:57.085]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:57.085]                   ...future.rng), globalenv = if (FALSE) 
[13:21:57.085]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:57.085]                     ...future.globalenv.names))
[13:21:57.085]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:57.085]         }, condition = base::local({
[13:21:57.085]             c <- base::c
[13:21:57.085]             inherits <- base::inherits
[13:21:57.085]             invokeRestart <- base::invokeRestart
[13:21:57.085]             length <- base::length
[13:21:57.085]             list <- base::list
[13:21:57.085]             seq.int <- base::seq.int
[13:21:57.085]             signalCondition <- base::signalCondition
[13:21:57.085]             sys.calls <- base::sys.calls
[13:21:57.085]             `[[` <- base::`[[`
[13:21:57.085]             `+` <- base::`+`
[13:21:57.085]             `<<-` <- base::`<<-`
[13:21:57.085]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:57.085]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:57.085]                   3L)]
[13:21:57.085]             }
[13:21:57.085]             function(cond) {
[13:21:57.085]                 is_error <- inherits(cond, "error")
[13:21:57.085]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:57.085]                   NULL)
[13:21:57.085]                 if (is_error) {
[13:21:57.085]                   sessionInformation <- function() {
[13:21:57.085]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:57.085]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:57.085]                       search = base::search(), system = base::Sys.info())
[13:21:57.085]                   }
[13:21:57.085]                   ...future.conditions[[length(...future.conditions) + 
[13:21:57.085]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:57.085]                     cond$call), session = sessionInformation(), 
[13:21:57.085]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:57.085]                   signalCondition(cond)
[13:21:57.085]                 }
[13:21:57.085]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:57.085]                 "immediateCondition"))) {
[13:21:57.085]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:57.085]                   ...future.conditions[[length(...future.conditions) + 
[13:21:57.085]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:57.085]                   if (TRUE && !signal) {
[13:21:57.085]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:57.085]                     {
[13:21:57.085]                       inherits <- base::inherits
[13:21:57.085]                       invokeRestart <- base::invokeRestart
[13:21:57.085]                       is.null <- base::is.null
[13:21:57.085]                       muffled <- FALSE
[13:21:57.085]                       if (inherits(cond, "message")) {
[13:21:57.085]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:57.085]                         if (muffled) 
[13:21:57.085]                           invokeRestart("muffleMessage")
[13:21:57.085]                       }
[13:21:57.085]                       else if (inherits(cond, "warning")) {
[13:21:57.085]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:57.085]                         if (muffled) 
[13:21:57.085]                           invokeRestart("muffleWarning")
[13:21:57.085]                       }
[13:21:57.085]                       else if (inherits(cond, "condition")) {
[13:21:57.085]                         if (!is.null(pattern)) {
[13:21:57.085]                           computeRestarts <- base::computeRestarts
[13:21:57.085]                           grepl <- base::grepl
[13:21:57.085]                           restarts <- computeRestarts(cond)
[13:21:57.085]                           for (restart in restarts) {
[13:21:57.085]                             name <- restart$name
[13:21:57.085]                             if (is.null(name)) 
[13:21:57.085]                               next
[13:21:57.085]                             if (!grepl(pattern, name)) 
[13:21:57.085]                               next
[13:21:57.085]                             invokeRestart(restart)
[13:21:57.085]                             muffled <- TRUE
[13:21:57.085]                             break
[13:21:57.085]                           }
[13:21:57.085]                         }
[13:21:57.085]                       }
[13:21:57.085]                       invisible(muffled)
[13:21:57.085]                     }
[13:21:57.085]                     muffleCondition(cond, pattern = "^muffle")
[13:21:57.085]                   }
[13:21:57.085]                 }
[13:21:57.085]                 else {
[13:21:57.085]                   if (TRUE) {
[13:21:57.085]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:57.085]                     {
[13:21:57.085]                       inherits <- base::inherits
[13:21:57.085]                       invokeRestart <- base::invokeRestart
[13:21:57.085]                       is.null <- base::is.null
[13:21:57.085]                       muffled <- FALSE
[13:21:57.085]                       if (inherits(cond, "message")) {
[13:21:57.085]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:57.085]                         if (muffled) 
[13:21:57.085]                           invokeRestart("muffleMessage")
[13:21:57.085]                       }
[13:21:57.085]                       else if (inherits(cond, "warning")) {
[13:21:57.085]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:57.085]                         if (muffled) 
[13:21:57.085]                           invokeRestart("muffleWarning")
[13:21:57.085]                       }
[13:21:57.085]                       else if (inherits(cond, "condition")) {
[13:21:57.085]                         if (!is.null(pattern)) {
[13:21:57.085]                           computeRestarts <- base::computeRestarts
[13:21:57.085]                           grepl <- base::grepl
[13:21:57.085]                           restarts <- computeRestarts(cond)
[13:21:57.085]                           for (restart in restarts) {
[13:21:57.085]                             name <- restart$name
[13:21:57.085]                             if (is.null(name)) 
[13:21:57.085]                               next
[13:21:57.085]                             if (!grepl(pattern, name)) 
[13:21:57.085]                               next
[13:21:57.085]                             invokeRestart(restart)
[13:21:57.085]                             muffled <- TRUE
[13:21:57.085]                             break
[13:21:57.085]                           }
[13:21:57.085]                         }
[13:21:57.085]                       }
[13:21:57.085]                       invisible(muffled)
[13:21:57.085]                     }
[13:21:57.085]                     muffleCondition(cond, pattern = "^muffle")
[13:21:57.085]                   }
[13:21:57.085]                 }
[13:21:57.085]             }
[13:21:57.085]         }))
[13:21:57.085]     }, error = function(ex) {
[13:21:57.085]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:57.085]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:57.085]                 ...future.rng), started = ...future.startTime, 
[13:21:57.085]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:57.085]             version = "1.8"), class = "FutureResult")
[13:21:57.085]     }, finally = {
[13:21:57.085]         if (!identical(...future.workdir, getwd())) 
[13:21:57.085]             setwd(...future.workdir)
[13:21:57.085]         {
[13:21:57.085]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:57.085]                 ...future.oldOptions$nwarnings <- NULL
[13:21:57.085]             }
[13:21:57.085]             base::options(...future.oldOptions)
[13:21:57.085]             if (.Platform$OS.type == "windows") {
[13:21:57.085]                 old_names <- names(...future.oldEnvVars)
[13:21:57.085]                 envs <- base::Sys.getenv()
[13:21:57.085]                 names <- names(envs)
[13:21:57.085]                 common <- intersect(names, old_names)
[13:21:57.085]                 added <- setdiff(names, old_names)
[13:21:57.085]                 removed <- setdiff(old_names, names)
[13:21:57.085]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:57.085]                   envs[common]]
[13:21:57.085]                 NAMES <- toupper(changed)
[13:21:57.085]                 args <- list()
[13:21:57.085]                 for (kk in seq_along(NAMES)) {
[13:21:57.085]                   name <- changed[[kk]]
[13:21:57.085]                   NAME <- NAMES[[kk]]
[13:21:57.085]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:57.085]                     next
[13:21:57.085]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:57.085]                 }
[13:21:57.085]                 NAMES <- toupper(added)
[13:21:57.085]                 for (kk in seq_along(NAMES)) {
[13:21:57.085]                   name <- added[[kk]]
[13:21:57.085]                   NAME <- NAMES[[kk]]
[13:21:57.085]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:57.085]                     next
[13:21:57.085]                   args[[name]] <- ""
[13:21:57.085]                 }
[13:21:57.085]                 NAMES <- toupper(removed)
[13:21:57.085]                 for (kk in seq_along(NAMES)) {
[13:21:57.085]                   name <- removed[[kk]]
[13:21:57.085]                   NAME <- NAMES[[kk]]
[13:21:57.085]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:57.085]                     next
[13:21:57.085]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:57.085]                 }
[13:21:57.085]                 if (length(args) > 0) 
[13:21:57.085]                   base::do.call(base::Sys.setenv, args = args)
[13:21:57.085]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:57.085]             }
[13:21:57.085]             else {
[13:21:57.085]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:57.085]             }
[13:21:57.085]             {
[13:21:57.085]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:57.085]                   0L) {
[13:21:57.085]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:57.085]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:57.085]                   base::options(opts)
[13:21:57.085]                 }
[13:21:57.085]                 {
[13:21:57.085]                   {
[13:21:57.085]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:57.085]                     NULL
[13:21:57.085]                   }
[13:21:57.085]                   options(future.plan = NULL)
[13:21:57.085]                   if (is.na(NA_character_)) 
[13:21:57.085]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:57.085]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:57.085]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:57.085]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:57.085]                     envir = parent.frame()) 
[13:21:57.085]                   {
[13:21:57.085]                     if (is.function(workers)) 
[13:21:57.085]                       workers <- workers()
[13:21:57.085]                     workers <- structure(as.integer(workers), 
[13:21:57.085]                       class = class(workers))
[13:21:57.085]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:57.085]                       workers >= 1)
[13:21:57.085]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:57.085]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:57.085]                     }
[13:21:57.085]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:57.085]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:57.085]                       envir = envir)
[13:21:57.085]                     if (!future$lazy) 
[13:21:57.085]                       future <- run(future)
[13:21:57.085]                     invisible(future)
[13:21:57.085]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:57.085]                 }
[13:21:57.085]             }
[13:21:57.085]         }
[13:21:57.085]     })
[13:21:57.085]     if (TRUE) {
[13:21:57.085]         base::sink(type = "output", split = FALSE)
[13:21:57.085]         if (TRUE) {
[13:21:57.085]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:57.085]         }
[13:21:57.085]         else {
[13:21:57.085]             ...future.result["stdout"] <- base::list(NULL)
[13:21:57.085]         }
[13:21:57.085]         base::close(...future.stdout)
[13:21:57.085]         ...future.stdout <- NULL
[13:21:57.085]     }
[13:21:57.085]     ...future.result$conditions <- ...future.conditions
[13:21:57.085]     ...future.result$finished <- base::Sys.time()
[13:21:57.085]     ...future.result
[13:21:57.085] }
[13:21:57.091] MultisessionFuture started
[13:21:57.091] - Launch lazy future ... done
[13:21:57.091] run() for ‘MultisessionFuture’ ... done
[13:21:57.639] receiveMessageFromWorker() for ClusterFuture ...
[13:21:57.639] - Validating connection of MultisessionFuture
[13:21:57.639] - received message: FutureResult
[13:21:57.639] - Received FutureResult
[13:21:57.639] - Erased future from FutureRegistry
[13:21:57.639] result() for ClusterFuture ...
[13:21:57.639] - result already collected: FutureResult
[13:21:57.640] result() for ClusterFuture ... done
[13:21:57.640] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:57.640] resolve() on list ...
[13:21:57.640]  recursive: 1
[13:21:57.640]  length: 2
[13:21:57.640]  elements: ‘a’, ‘b’
[13:21:57.640]  length: 1 (resolved future 1)
[13:21:57.640]  length: 0 (resolved future 2)
[13:21:57.640] resolve() on list ... DONE
[13:21:57.640] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[13:21:57.641] getGlobalsAndPackages() ...
[13:21:57.641] Searching for globals...
[13:21:57.641] - globals found: [2] ‘list’, ‘stop’
[13:21:57.642] Searching for globals ... DONE
[13:21:57.642] Resolving globals: FALSE
[13:21:57.642] 
[13:21:57.642] 
[13:21:57.642] getGlobalsAndPackages() ... DONE
[13:21:57.642] run() for ‘Future’ ...
[13:21:57.642] - state: ‘created’
[13:21:57.643] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:57.657] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:57.657] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:57.657]   - Field: ‘node’
[13:21:57.658]   - Field: ‘label’
[13:21:57.658]   - Field: ‘local’
[13:21:57.658]   - Field: ‘owner’
[13:21:57.658]   - Field: ‘envir’
[13:21:57.658]   - Field: ‘workers’
[13:21:57.658]   - Field: ‘packages’
[13:21:57.658]   - Field: ‘gc’
[13:21:57.658]   - Field: ‘conditions’
[13:21:57.658]   - Field: ‘persistent’
[13:21:57.658]   - Field: ‘expr’
[13:21:57.658]   - Field: ‘uuid’
[13:21:57.659]   - Field: ‘seed’
[13:21:57.659]   - Field: ‘version’
[13:21:57.659]   - Field: ‘result’
[13:21:57.659]   - Field: ‘asynchronous’
[13:21:57.659]   - Field: ‘calls’
[13:21:57.659]   - Field: ‘globals’
[13:21:57.659]   - Field: ‘stdout’
[13:21:57.659]   - Field: ‘earlySignal’
[13:21:57.659]   - Field: ‘lazy’
[13:21:57.659]   - Field: ‘state’
[13:21:57.659] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:57.660] - Launch lazy future ...
[13:21:57.660] Packages needed by the future expression (n = 0): <none>
[13:21:57.660] Packages needed by future strategies (n = 0): <none>
[13:21:57.660] {
[13:21:57.660]     {
[13:21:57.660]         {
[13:21:57.660]             ...future.startTime <- base::Sys.time()
[13:21:57.660]             {
[13:21:57.660]                 {
[13:21:57.660]                   {
[13:21:57.660]                     {
[13:21:57.660]                       base::local({
[13:21:57.660]                         has_future <- base::requireNamespace("future", 
[13:21:57.660]                           quietly = TRUE)
[13:21:57.660]                         if (has_future) {
[13:21:57.660]                           ns <- base::getNamespace("future")
[13:21:57.660]                           version <- ns[[".package"]][["version"]]
[13:21:57.660]                           if (is.null(version)) 
[13:21:57.660]                             version <- utils::packageVersion("future")
[13:21:57.660]                         }
[13:21:57.660]                         else {
[13:21:57.660]                           version <- NULL
[13:21:57.660]                         }
[13:21:57.660]                         if (!has_future || version < "1.8.0") {
[13:21:57.660]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:57.660]                             "", base::R.version$version.string), 
[13:21:57.660]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:57.660]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:57.660]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:57.660]                               "release", "version")], collapse = " "), 
[13:21:57.660]                             hostname = base::Sys.info()[["nodename"]])
[13:21:57.660]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:57.660]                             info)
[13:21:57.660]                           info <- base::paste(info, collapse = "; ")
[13:21:57.660]                           if (!has_future) {
[13:21:57.660]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:57.660]                               info)
[13:21:57.660]                           }
[13:21:57.660]                           else {
[13:21:57.660]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:57.660]                               info, version)
[13:21:57.660]                           }
[13:21:57.660]                           base::stop(msg)
[13:21:57.660]                         }
[13:21:57.660]                       })
[13:21:57.660]                     }
[13:21:57.660]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:57.660]                     base::options(mc.cores = 1L)
[13:21:57.660]                   }
[13:21:57.660]                   options(future.plan = NULL)
[13:21:57.660]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:57.660]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:57.660]                 }
[13:21:57.660]                 ...future.workdir <- getwd()
[13:21:57.660]             }
[13:21:57.660]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:57.660]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:57.660]         }
[13:21:57.660]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:57.660]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:57.660]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:57.660]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:57.660]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:57.660]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:57.660]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:57.660]             base::names(...future.oldOptions))
[13:21:57.660]     }
[13:21:57.660]     if (FALSE) {
[13:21:57.660]     }
[13:21:57.660]     else {
[13:21:57.660]         if (TRUE) {
[13:21:57.660]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:57.660]                 open = "w")
[13:21:57.660]         }
[13:21:57.660]         else {
[13:21:57.660]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:57.660]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:57.660]         }
[13:21:57.660]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:57.660]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:57.660]             base::sink(type = "output", split = FALSE)
[13:21:57.660]             base::close(...future.stdout)
[13:21:57.660]         }, add = TRUE)
[13:21:57.660]     }
[13:21:57.660]     ...future.frame <- base::sys.nframe()
[13:21:57.660]     ...future.conditions <- base::list()
[13:21:57.660]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:57.660]     if (FALSE) {
[13:21:57.660]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:57.660]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:57.660]     }
[13:21:57.660]     ...future.result <- base::tryCatch({
[13:21:57.660]         base::withCallingHandlers({
[13:21:57.660]             ...future.value <- base::withVisible(base::local({
[13:21:57.660]                 ...future.makeSendCondition <- local({
[13:21:57.660]                   sendCondition <- NULL
[13:21:57.660]                   function(frame = 1L) {
[13:21:57.660]                     if (is.function(sendCondition)) 
[13:21:57.660]                       return(sendCondition)
[13:21:57.660]                     ns <- getNamespace("parallel")
[13:21:57.660]                     if (exists("sendData", mode = "function", 
[13:21:57.660]                       envir = ns)) {
[13:21:57.660]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:57.660]                         envir = ns)
[13:21:57.660]                       envir <- sys.frame(frame)
[13:21:57.660]                       master <- NULL
[13:21:57.660]                       while (!identical(envir, .GlobalEnv) && 
[13:21:57.660]                         !identical(envir, emptyenv())) {
[13:21:57.660]                         if (exists("master", mode = "list", envir = envir, 
[13:21:57.660]                           inherits = FALSE)) {
[13:21:57.660]                           master <- get("master", mode = "list", 
[13:21:57.660]                             envir = envir, inherits = FALSE)
[13:21:57.660]                           if (inherits(master, c("SOCKnode", 
[13:21:57.660]                             "SOCK0node"))) {
[13:21:57.660]                             sendCondition <<- function(cond) {
[13:21:57.660]                               data <- list(type = "VALUE", value = cond, 
[13:21:57.660]                                 success = TRUE)
[13:21:57.660]                               parallel_sendData(master, data)
[13:21:57.660]                             }
[13:21:57.660]                             return(sendCondition)
[13:21:57.660]                           }
[13:21:57.660]                         }
[13:21:57.660]                         frame <- frame + 1L
[13:21:57.660]                         envir <- sys.frame(frame)
[13:21:57.660]                       }
[13:21:57.660]                     }
[13:21:57.660]                     sendCondition <<- function(cond) NULL
[13:21:57.660]                   }
[13:21:57.660]                 })
[13:21:57.660]                 withCallingHandlers({
[13:21:57.660]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:21:57.660]                 }, immediateCondition = function(cond) {
[13:21:57.660]                   sendCondition <- ...future.makeSendCondition()
[13:21:57.660]                   sendCondition(cond)
[13:21:57.660]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:57.660]                   {
[13:21:57.660]                     inherits <- base::inherits
[13:21:57.660]                     invokeRestart <- base::invokeRestart
[13:21:57.660]                     is.null <- base::is.null
[13:21:57.660]                     muffled <- FALSE
[13:21:57.660]                     if (inherits(cond, "message")) {
[13:21:57.660]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:57.660]                       if (muffled) 
[13:21:57.660]                         invokeRestart("muffleMessage")
[13:21:57.660]                     }
[13:21:57.660]                     else if (inherits(cond, "warning")) {
[13:21:57.660]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:57.660]                       if (muffled) 
[13:21:57.660]                         invokeRestart("muffleWarning")
[13:21:57.660]                     }
[13:21:57.660]                     else if (inherits(cond, "condition")) {
[13:21:57.660]                       if (!is.null(pattern)) {
[13:21:57.660]                         computeRestarts <- base::computeRestarts
[13:21:57.660]                         grepl <- base::grepl
[13:21:57.660]                         restarts <- computeRestarts(cond)
[13:21:57.660]                         for (restart in restarts) {
[13:21:57.660]                           name <- restart$name
[13:21:57.660]                           if (is.null(name)) 
[13:21:57.660]                             next
[13:21:57.660]                           if (!grepl(pattern, name)) 
[13:21:57.660]                             next
[13:21:57.660]                           invokeRestart(restart)
[13:21:57.660]                           muffled <- TRUE
[13:21:57.660]                           break
[13:21:57.660]                         }
[13:21:57.660]                       }
[13:21:57.660]                     }
[13:21:57.660]                     invisible(muffled)
[13:21:57.660]                   }
[13:21:57.660]                   muffleCondition(cond)
[13:21:57.660]                 })
[13:21:57.660]             }))
[13:21:57.660]             future::FutureResult(value = ...future.value$value, 
[13:21:57.660]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:57.660]                   ...future.rng), globalenv = if (FALSE) 
[13:21:57.660]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:57.660]                     ...future.globalenv.names))
[13:21:57.660]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:57.660]         }, condition = base::local({
[13:21:57.660]             c <- base::c
[13:21:57.660]             inherits <- base::inherits
[13:21:57.660]             invokeRestart <- base::invokeRestart
[13:21:57.660]             length <- base::length
[13:21:57.660]             list <- base::list
[13:21:57.660]             seq.int <- base::seq.int
[13:21:57.660]             signalCondition <- base::signalCondition
[13:21:57.660]             sys.calls <- base::sys.calls
[13:21:57.660]             `[[` <- base::`[[`
[13:21:57.660]             `+` <- base::`+`
[13:21:57.660]             `<<-` <- base::`<<-`
[13:21:57.660]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:57.660]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:57.660]                   3L)]
[13:21:57.660]             }
[13:21:57.660]             function(cond) {
[13:21:57.660]                 is_error <- inherits(cond, "error")
[13:21:57.660]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:57.660]                   NULL)
[13:21:57.660]                 if (is_error) {
[13:21:57.660]                   sessionInformation <- function() {
[13:21:57.660]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:57.660]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:57.660]                       search = base::search(), system = base::Sys.info())
[13:21:57.660]                   }
[13:21:57.660]                   ...future.conditions[[length(...future.conditions) + 
[13:21:57.660]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:57.660]                     cond$call), session = sessionInformation(), 
[13:21:57.660]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:57.660]                   signalCondition(cond)
[13:21:57.660]                 }
[13:21:57.660]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:57.660]                 "immediateCondition"))) {
[13:21:57.660]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:57.660]                   ...future.conditions[[length(...future.conditions) + 
[13:21:57.660]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:57.660]                   if (TRUE && !signal) {
[13:21:57.660]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:57.660]                     {
[13:21:57.660]                       inherits <- base::inherits
[13:21:57.660]                       invokeRestart <- base::invokeRestart
[13:21:57.660]                       is.null <- base::is.null
[13:21:57.660]                       muffled <- FALSE
[13:21:57.660]                       if (inherits(cond, "message")) {
[13:21:57.660]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:57.660]                         if (muffled) 
[13:21:57.660]                           invokeRestart("muffleMessage")
[13:21:57.660]                       }
[13:21:57.660]                       else if (inherits(cond, "warning")) {
[13:21:57.660]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:57.660]                         if (muffled) 
[13:21:57.660]                           invokeRestart("muffleWarning")
[13:21:57.660]                       }
[13:21:57.660]                       else if (inherits(cond, "condition")) {
[13:21:57.660]                         if (!is.null(pattern)) {
[13:21:57.660]                           computeRestarts <- base::computeRestarts
[13:21:57.660]                           grepl <- base::grepl
[13:21:57.660]                           restarts <- computeRestarts(cond)
[13:21:57.660]                           for (restart in restarts) {
[13:21:57.660]                             name <- restart$name
[13:21:57.660]                             if (is.null(name)) 
[13:21:57.660]                               next
[13:21:57.660]                             if (!grepl(pattern, name)) 
[13:21:57.660]                               next
[13:21:57.660]                             invokeRestart(restart)
[13:21:57.660]                             muffled <- TRUE
[13:21:57.660]                             break
[13:21:57.660]                           }
[13:21:57.660]                         }
[13:21:57.660]                       }
[13:21:57.660]                       invisible(muffled)
[13:21:57.660]                     }
[13:21:57.660]                     muffleCondition(cond, pattern = "^muffle")
[13:21:57.660]                   }
[13:21:57.660]                 }
[13:21:57.660]                 else {
[13:21:57.660]                   if (TRUE) {
[13:21:57.660]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:57.660]                     {
[13:21:57.660]                       inherits <- base::inherits
[13:21:57.660]                       invokeRestart <- base::invokeRestart
[13:21:57.660]                       is.null <- base::is.null
[13:21:57.660]                       muffled <- FALSE
[13:21:57.660]                       if (inherits(cond, "message")) {
[13:21:57.660]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:57.660]                         if (muffled) 
[13:21:57.660]                           invokeRestart("muffleMessage")
[13:21:57.660]                       }
[13:21:57.660]                       else if (inherits(cond, "warning")) {
[13:21:57.660]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:57.660]                         if (muffled) 
[13:21:57.660]                           invokeRestart("muffleWarning")
[13:21:57.660]                       }
[13:21:57.660]                       else if (inherits(cond, "condition")) {
[13:21:57.660]                         if (!is.null(pattern)) {
[13:21:57.660]                           computeRestarts <- base::computeRestarts
[13:21:57.660]                           grepl <- base::grepl
[13:21:57.660]                           restarts <- computeRestarts(cond)
[13:21:57.660]                           for (restart in restarts) {
[13:21:57.660]                             name <- restart$name
[13:21:57.660]                             if (is.null(name)) 
[13:21:57.660]                               next
[13:21:57.660]                             if (!grepl(pattern, name)) 
[13:21:57.660]                               next
[13:21:57.660]                             invokeRestart(restart)
[13:21:57.660]                             muffled <- TRUE
[13:21:57.660]                             break
[13:21:57.660]                           }
[13:21:57.660]                         }
[13:21:57.660]                       }
[13:21:57.660]                       invisible(muffled)
[13:21:57.660]                     }
[13:21:57.660]                     muffleCondition(cond, pattern = "^muffle")
[13:21:57.660]                   }
[13:21:57.660]                 }
[13:21:57.660]             }
[13:21:57.660]         }))
[13:21:57.660]     }, error = function(ex) {
[13:21:57.660]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:57.660]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:57.660]                 ...future.rng), started = ...future.startTime, 
[13:21:57.660]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:57.660]             version = "1.8"), class = "FutureResult")
[13:21:57.660]     }, finally = {
[13:21:57.660]         if (!identical(...future.workdir, getwd())) 
[13:21:57.660]             setwd(...future.workdir)
[13:21:57.660]         {
[13:21:57.660]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:57.660]                 ...future.oldOptions$nwarnings <- NULL
[13:21:57.660]             }
[13:21:57.660]             base::options(...future.oldOptions)
[13:21:57.660]             if (.Platform$OS.type == "windows") {
[13:21:57.660]                 old_names <- names(...future.oldEnvVars)
[13:21:57.660]                 envs <- base::Sys.getenv()
[13:21:57.660]                 names <- names(envs)
[13:21:57.660]                 common <- intersect(names, old_names)
[13:21:57.660]                 added <- setdiff(names, old_names)
[13:21:57.660]                 removed <- setdiff(old_names, names)
[13:21:57.660]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:57.660]                   envs[common]]
[13:21:57.660]                 NAMES <- toupper(changed)
[13:21:57.660]                 args <- list()
[13:21:57.660]                 for (kk in seq_along(NAMES)) {
[13:21:57.660]                   name <- changed[[kk]]
[13:21:57.660]                   NAME <- NAMES[[kk]]
[13:21:57.660]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:57.660]                     next
[13:21:57.660]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:57.660]                 }
[13:21:57.660]                 NAMES <- toupper(added)
[13:21:57.660]                 for (kk in seq_along(NAMES)) {
[13:21:57.660]                   name <- added[[kk]]
[13:21:57.660]                   NAME <- NAMES[[kk]]
[13:21:57.660]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:57.660]                     next
[13:21:57.660]                   args[[name]] <- ""
[13:21:57.660]                 }
[13:21:57.660]                 NAMES <- toupper(removed)
[13:21:57.660]                 for (kk in seq_along(NAMES)) {
[13:21:57.660]                   name <- removed[[kk]]
[13:21:57.660]                   NAME <- NAMES[[kk]]
[13:21:57.660]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:57.660]                     next
[13:21:57.660]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:57.660]                 }
[13:21:57.660]                 if (length(args) > 0) 
[13:21:57.660]                   base::do.call(base::Sys.setenv, args = args)
[13:21:57.660]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:57.660]             }
[13:21:57.660]             else {
[13:21:57.660]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:57.660]             }
[13:21:57.660]             {
[13:21:57.660]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:57.660]                   0L) {
[13:21:57.660]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:57.660]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:57.660]                   base::options(opts)
[13:21:57.660]                 }
[13:21:57.660]                 {
[13:21:57.660]                   {
[13:21:57.660]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:57.660]                     NULL
[13:21:57.660]                   }
[13:21:57.660]                   options(future.plan = NULL)
[13:21:57.660]                   if (is.na(NA_character_)) 
[13:21:57.660]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:57.660]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:57.660]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:57.660]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:57.660]                     envir = parent.frame()) 
[13:21:57.660]                   {
[13:21:57.660]                     if (is.function(workers)) 
[13:21:57.660]                       workers <- workers()
[13:21:57.660]                     workers <- structure(as.integer(workers), 
[13:21:57.660]                       class = class(workers))
[13:21:57.660]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:57.660]                       workers >= 1)
[13:21:57.660]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:57.660]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:57.660]                     }
[13:21:57.660]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:57.660]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:57.660]                       envir = envir)
[13:21:57.660]                     if (!future$lazy) 
[13:21:57.660]                       future <- run(future)
[13:21:57.660]                     invisible(future)
[13:21:57.660]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:57.660]                 }
[13:21:57.660]             }
[13:21:57.660]         }
[13:21:57.660]     })
[13:21:57.660]     if (TRUE) {
[13:21:57.660]         base::sink(type = "output", split = FALSE)
[13:21:57.660]         if (TRUE) {
[13:21:57.660]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:57.660]         }
[13:21:57.660]         else {
[13:21:57.660]             ...future.result["stdout"] <- base::list(NULL)
[13:21:57.660]         }
[13:21:57.660]         base::close(...future.stdout)
[13:21:57.660]         ...future.stdout <- NULL
[13:21:57.660]     }
[13:21:57.660]     ...future.result$conditions <- ...future.conditions
[13:21:57.660]     ...future.result$finished <- base::Sys.time()
[13:21:57.660]     ...future.result
[13:21:57.660] }
[13:21:57.663] MultisessionFuture started
[13:21:57.664] - Launch lazy future ... done
[13:21:57.664] run() for ‘MultisessionFuture’ ... done
[13:21:57.709] receiveMessageFromWorker() for ClusterFuture ...
[13:21:57.710] - Validating connection of MultisessionFuture
[13:21:57.710] - received message: FutureResult
[13:21:57.710] - Received FutureResult
[13:21:57.710] - Erased future from FutureRegistry
[13:21:57.710] result() for ClusterFuture ...
[13:21:57.711] - result already collected: FutureResult
[13:21:57.711] result() for ClusterFuture ... done
[13:21:57.711] signalConditions() ...
[13:21:57.711]  - include = ‘immediateCondition’
[13:21:57.711]  - exclude = 
[13:21:57.711]  - resignal = FALSE
[13:21:57.711]  - Number of conditions: 1
[13:21:57.711] signalConditions() ... done
[13:21:57.711] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:57.711] A MultisessionFuture was resolved
[13:21:57.711] getGlobalsAndPackages() ...
[13:21:57.712] Searching for globals...
[13:21:57.712] - globals found: [2] ‘list’, ‘stop’
[13:21:57.712] Searching for globals ... DONE
[13:21:57.712] Resolving globals: FALSE
[13:21:57.713] 
[13:21:57.713] 
[13:21:57.713] getGlobalsAndPackages() ... DONE
[13:21:57.713] run() for ‘Future’ ...
[13:21:57.713] - state: ‘created’
[13:21:57.713] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:57.729] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:57.729] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:57.729]   - Field: ‘node’
[13:21:57.729]   - Field: ‘label’
[13:21:57.729]   - Field: ‘local’
[13:21:57.729]   - Field: ‘owner’
[13:21:57.729]   - Field: ‘envir’
[13:21:57.730]   - Field: ‘workers’
[13:21:57.730]   - Field: ‘packages’
[13:21:57.730]   - Field: ‘gc’
[13:21:57.730]   - Field: ‘conditions’
[13:21:57.730]   - Field: ‘persistent’
[13:21:57.730]   - Field: ‘expr’
[13:21:57.730]   - Field: ‘uuid’
[13:21:57.730]   - Field: ‘seed’
[13:21:57.730]   - Field: ‘version’
[13:21:57.730]   - Field: ‘result’
[13:21:57.730]   - Field: ‘asynchronous’
[13:21:57.731]   - Field: ‘calls’
[13:21:57.731]   - Field: ‘globals’
[13:21:57.731]   - Field: ‘stdout’
[13:21:57.731]   - Field: ‘earlySignal’
[13:21:57.731]   - Field: ‘lazy’
[13:21:57.731]   - Field: ‘state’
[13:21:57.731] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:57.731] - Launch lazy future ...
[13:21:57.731] Packages needed by the future expression (n = 0): <none>
[13:21:57.732] Packages needed by future strategies (n = 0): <none>
[13:21:57.732] {
[13:21:57.732]     {
[13:21:57.732]         {
[13:21:57.732]             ...future.startTime <- base::Sys.time()
[13:21:57.732]             {
[13:21:57.732]                 {
[13:21:57.732]                   {
[13:21:57.732]                     {
[13:21:57.732]                       base::local({
[13:21:57.732]                         has_future <- base::requireNamespace("future", 
[13:21:57.732]                           quietly = TRUE)
[13:21:57.732]                         if (has_future) {
[13:21:57.732]                           ns <- base::getNamespace("future")
[13:21:57.732]                           version <- ns[[".package"]][["version"]]
[13:21:57.732]                           if (is.null(version)) 
[13:21:57.732]                             version <- utils::packageVersion("future")
[13:21:57.732]                         }
[13:21:57.732]                         else {
[13:21:57.732]                           version <- NULL
[13:21:57.732]                         }
[13:21:57.732]                         if (!has_future || version < "1.8.0") {
[13:21:57.732]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:57.732]                             "", base::R.version$version.string), 
[13:21:57.732]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:57.732]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:57.732]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:57.732]                               "release", "version")], collapse = " "), 
[13:21:57.732]                             hostname = base::Sys.info()[["nodename"]])
[13:21:57.732]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:57.732]                             info)
[13:21:57.732]                           info <- base::paste(info, collapse = "; ")
[13:21:57.732]                           if (!has_future) {
[13:21:57.732]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:57.732]                               info)
[13:21:57.732]                           }
[13:21:57.732]                           else {
[13:21:57.732]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:57.732]                               info, version)
[13:21:57.732]                           }
[13:21:57.732]                           base::stop(msg)
[13:21:57.732]                         }
[13:21:57.732]                       })
[13:21:57.732]                     }
[13:21:57.732]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:57.732]                     base::options(mc.cores = 1L)
[13:21:57.732]                   }
[13:21:57.732]                   options(future.plan = NULL)
[13:21:57.732]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:57.732]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:57.732]                 }
[13:21:57.732]                 ...future.workdir <- getwd()
[13:21:57.732]             }
[13:21:57.732]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:57.732]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:57.732]         }
[13:21:57.732]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:57.732]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:57.732]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:57.732]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:57.732]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:57.732]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:57.732]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:57.732]             base::names(...future.oldOptions))
[13:21:57.732]     }
[13:21:57.732]     if (FALSE) {
[13:21:57.732]     }
[13:21:57.732]     else {
[13:21:57.732]         if (TRUE) {
[13:21:57.732]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:57.732]                 open = "w")
[13:21:57.732]         }
[13:21:57.732]         else {
[13:21:57.732]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:57.732]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:57.732]         }
[13:21:57.732]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:57.732]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:57.732]             base::sink(type = "output", split = FALSE)
[13:21:57.732]             base::close(...future.stdout)
[13:21:57.732]         }, add = TRUE)
[13:21:57.732]     }
[13:21:57.732]     ...future.frame <- base::sys.nframe()
[13:21:57.732]     ...future.conditions <- base::list()
[13:21:57.732]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:57.732]     if (FALSE) {
[13:21:57.732]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:57.732]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:57.732]     }
[13:21:57.732]     ...future.result <- base::tryCatch({
[13:21:57.732]         base::withCallingHandlers({
[13:21:57.732]             ...future.value <- base::withVisible(base::local({
[13:21:57.732]                 ...future.makeSendCondition <- local({
[13:21:57.732]                   sendCondition <- NULL
[13:21:57.732]                   function(frame = 1L) {
[13:21:57.732]                     if (is.function(sendCondition)) 
[13:21:57.732]                       return(sendCondition)
[13:21:57.732]                     ns <- getNamespace("parallel")
[13:21:57.732]                     if (exists("sendData", mode = "function", 
[13:21:57.732]                       envir = ns)) {
[13:21:57.732]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:57.732]                         envir = ns)
[13:21:57.732]                       envir <- sys.frame(frame)
[13:21:57.732]                       master <- NULL
[13:21:57.732]                       while (!identical(envir, .GlobalEnv) && 
[13:21:57.732]                         !identical(envir, emptyenv())) {
[13:21:57.732]                         if (exists("master", mode = "list", envir = envir, 
[13:21:57.732]                           inherits = FALSE)) {
[13:21:57.732]                           master <- get("master", mode = "list", 
[13:21:57.732]                             envir = envir, inherits = FALSE)
[13:21:57.732]                           if (inherits(master, c("SOCKnode", 
[13:21:57.732]                             "SOCK0node"))) {
[13:21:57.732]                             sendCondition <<- function(cond) {
[13:21:57.732]                               data <- list(type = "VALUE", value = cond, 
[13:21:57.732]                                 success = TRUE)
[13:21:57.732]                               parallel_sendData(master, data)
[13:21:57.732]                             }
[13:21:57.732]                             return(sendCondition)
[13:21:57.732]                           }
[13:21:57.732]                         }
[13:21:57.732]                         frame <- frame + 1L
[13:21:57.732]                         envir <- sys.frame(frame)
[13:21:57.732]                       }
[13:21:57.732]                     }
[13:21:57.732]                     sendCondition <<- function(cond) NULL
[13:21:57.732]                   }
[13:21:57.732]                 })
[13:21:57.732]                 withCallingHandlers({
[13:21:57.732]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:21:57.732]                 }, immediateCondition = function(cond) {
[13:21:57.732]                   sendCondition <- ...future.makeSendCondition()
[13:21:57.732]                   sendCondition(cond)
[13:21:57.732]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:57.732]                   {
[13:21:57.732]                     inherits <- base::inherits
[13:21:57.732]                     invokeRestart <- base::invokeRestart
[13:21:57.732]                     is.null <- base::is.null
[13:21:57.732]                     muffled <- FALSE
[13:21:57.732]                     if (inherits(cond, "message")) {
[13:21:57.732]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:57.732]                       if (muffled) 
[13:21:57.732]                         invokeRestart("muffleMessage")
[13:21:57.732]                     }
[13:21:57.732]                     else if (inherits(cond, "warning")) {
[13:21:57.732]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:57.732]                       if (muffled) 
[13:21:57.732]                         invokeRestart("muffleWarning")
[13:21:57.732]                     }
[13:21:57.732]                     else if (inherits(cond, "condition")) {
[13:21:57.732]                       if (!is.null(pattern)) {
[13:21:57.732]                         computeRestarts <- base::computeRestarts
[13:21:57.732]                         grepl <- base::grepl
[13:21:57.732]                         restarts <- computeRestarts(cond)
[13:21:57.732]                         for (restart in restarts) {
[13:21:57.732]                           name <- restart$name
[13:21:57.732]                           if (is.null(name)) 
[13:21:57.732]                             next
[13:21:57.732]                           if (!grepl(pattern, name)) 
[13:21:57.732]                             next
[13:21:57.732]                           invokeRestart(restart)
[13:21:57.732]                           muffled <- TRUE
[13:21:57.732]                           break
[13:21:57.732]                         }
[13:21:57.732]                       }
[13:21:57.732]                     }
[13:21:57.732]                     invisible(muffled)
[13:21:57.732]                   }
[13:21:57.732]                   muffleCondition(cond)
[13:21:57.732]                 })
[13:21:57.732]             }))
[13:21:57.732]             future::FutureResult(value = ...future.value$value, 
[13:21:57.732]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:57.732]                   ...future.rng), globalenv = if (FALSE) 
[13:21:57.732]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:57.732]                     ...future.globalenv.names))
[13:21:57.732]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:57.732]         }, condition = base::local({
[13:21:57.732]             c <- base::c
[13:21:57.732]             inherits <- base::inherits
[13:21:57.732]             invokeRestart <- base::invokeRestart
[13:21:57.732]             length <- base::length
[13:21:57.732]             list <- base::list
[13:21:57.732]             seq.int <- base::seq.int
[13:21:57.732]             signalCondition <- base::signalCondition
[13:21:57.732]             sys.calls <- base::sys.calls
[13:21:57.732]             `[[` <- base::`[[`
[13:21:57.732]             `+` <- base::`+`
[13:21:57.732]             `<<-` <- base::`<<-`
[13:21:57.732]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:57.732]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:57.732]                   3L)]
[13:21:57.732]             }
[13:21:57.732]             function(cond) {
[13:21:57.732]                 is_error <- inherits(cond, "error")
[13:21:57.732]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:57.732]                   NULL)
[13:21:57.732]                 if (is_error) {
[13:21:57.732]                   sessionInformation <- function() {
[13:21:57.732]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:57.732]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:57.732]                       search = base::search(), system = base::Sys.info())
[13:21:57.732]                   }
[13:21:57.732]                   ...future.conditions[[length(...future.conditions) + 
[13:21:57.732]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:57.732]                     cond$call), session = sessionInformation(), 
[13:21:57.732]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:57.732]                   signalCondition(cond)
[13:21:57.732]                 }
[13:21:57.732]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:57.732]                 "immediateCondition"))) {
[13:21:57.732]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:57.732]                   ...future.conditions[[length(...future.conditions) + 
[13:21:57.732]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:57.732]                   if (TRUE && !signal) {
[13:21:57.732]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:57.732]                     {
[13:21:57.732]                       inherits <- base::inherits
[13:21:57.732]                       invokeRestart <- base::invokeRestart
[13:21:57.732]                       is.null <- base::is.null
[13:21:57.732]                       muffled <- FALSE
[13:21:57.732]                       if (inherits(cond, "message")) {
[13:21:57.732]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:57.732]                         if (muffled) 
[13:21:57.732]                           invokeRestart("muffleMessage")
[13:21:57.732]                       }
[13:21:57.732]                       else if (inherits(cond, "warning")) {
[13:21:57.732]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:57.732]                         if (muffled) 
[13:21:57.732]                           invokeRestart("muffleWarning")
[13:21:57.732]                       }
[13:21:57.732]                       else if (inherits(cond, "condition")) {
[13:21:57.732]                         if (!is.null(pattern)) {
[13:21:57.732]                           computeRestarts <- base::computeRestarts
[13:21:57.732]                           grepl <- base::grepl
[13:21:57.732]                           restarts <- computeRestarts(cond)
[13:21:57.732]                           for (restart in restarts) {
[13:21:57.732]                             name <- restart$name
[13:21:57.732]                             if (is.null(name)) 
[13:21:57.732]                               next
[13:21:57.732]                             if (!grepl(pattern, name)) 
[13:21:57.732]                               next
[13:21:57.732]                             invokeRestart(restart)
[13:21:57.732]                             muffled <- TRUE
[13:21:57.732]                             break
[13:21:57.732]                           }
[13:21:57.732]                         }
[13:21:57.732]                       }
[13:21:57.732]                       invisible(muffled)
[13:21:57.732]                     }
[13:21:57.732]                     muffleCondition(cond, pattern = "^muffle")
[13:21:57.732]                   }
[13:21:57.732]                 }
[13:21:57.732]                 else {
[13:21:57.732]                   if (TRUE) {
[13:21:57.732]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:57.732]                     {
[13:21:57.732]                       inherits <- base::inherits
[13:21:57.732]                       invokeRestart <- base::invokeRestart
[13:21:57.732]                       is.null <- base::is.null
[13:21:57.732]                       muffled <- FALSE
[13:21:57.732]                       if (inherits(cond, "message")) {
[13:21:57.732]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:57.732]                         if (muffled) 
[13:21:57.732]                           invokeRestart("muffleMessage")
[13:21:57.732]                       }
[13:21:57.732]                       else if (inherits(cond, "warning")) {
[13:21:57.732]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:57.732]                         if (muffled) 
[13:21:57.732]                           invokeRestart("muffleWarning")
[13:21:57.732]                       }
[13:21:57.732]                       else if (inherits(cond, "condition")) {
[13:21:57.732]                         if (!is.null(pattern)) {
[13:21:57.732]                           computeRestarts <- base::computeRestarts
[13:21:57.732]                           grepl <- base::grepl
[13:21:57.732]                           restarts <- computeRestarts(cond)
[13:21:57.732]                           for (restart in restarts) {
[13:21:57.732]                             name <- restart$name
[13:21:57.732]                             if (is.null(name)) 
[13:21:57.732]                               next
[13:21:57.732]                             if (!grepl(pattern, name)) 
[13:21:57.732]                               next
[13:21:57.732]                             invokeRestart(restart)
[13:21:57.732]                             muffled <- TRUE
[13:21:57.732]                             break
[13:21:57.732]                           }
[13:21:57.732]                         }
[13:21:57.732]                       }
[13:21:57.732]                       invisible(muffled)
[13:21:57.732]                     }
[13:21:57.732]                     muffleCondition(cond, pattern = "^muffle")
[13:21:57.732]                   }
[13:21:57.732]                 }
[13:21:57.732]             }
[13:21:57.732]         }))
[13:21:57.732]     }, error = function(ex) {
[13:21:57.732]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:57.732]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:57.732]                 ...future.rng), started = ...future.startTime, 
[13:21:57.732]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:57.732]             version = "1.8"), class = "FutureResult")
[13:21:57.732]     }, finally = {
[13:21:57.732]         if (!identical(...future.workdir, getwd())) 
[13:21:57.732]             setwd(...future.workdir)
[13:21:57.732]         {
[13:21:57.732]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:57.732]                 ...future.oldOptions$nwarnings <- NULL
[13:21:57.732]             }
[13:21:57.732]             base::options(...future.oldOptions)
[13:21:57.732]             if (.Platform$OS.type == "windows") {
[13:21:57.732]                 old_names <- names(...future.oldEnvVars)
[13:21:57.732]                 envs <- base::Sys.getenv()
[13:21:57.732]                 names <- names(envs)
[13:21:57.732]                 common <- intersect(names, old_names)
[13:21:57.732]                 added <- setdiff(names, old_names)
[13:21:57.732]                 removed <- setdiff(old_names, names)
[13:21:57.732]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:57.732]                   envs[common]]
[13:21:57.732]                 NAMES <- toupper(changed)
[13:21:57.732]                 args <- list()
[13:21:57.732]                 for (kk in seq_along(NAMES)) {
[13:21:57.732]                   name <- changed[[kk]]
[13:21:57.732]                   NAME <- NAMES[[kk]]
[13:21:57.732]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:57.732]                     next
[13:21:57.732]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:57.732]                 }
[13:21:57.732]                 NAMES <- toupper(added)
[13:21:57.732]                 for (kk in seq_along(NAMES)) {
[13:21:57.732]                   name <- added[[kk]]
[13:21:57.732]                   NAME <- NAMES[[kk]]
[13:21:57.732]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:57.732]                     next
[13:21:57.732]                   args[[name]] <- ""
[13:21:57.732]                 }
[13:21:57.732]                 NAMES <- toupper(removed)
[13:21:57.732]                 for (kk in seq_along(NAMES)) {
[13:21:57.732]                   name <- removed[[kk]]
[13:21:57.732]                   NAME <- NAMES[[kk]]
[13:21:57.732]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:57.732]                     next
[13:21:57.732]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:57.732]                 }
[13:21:57.732]                 if (length(args) > 0) 
[13:21:57.732]                   base::do.call(base::Sys.setenv, args = args)
[13:21:57.732]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:57.732]             }
[13:21:57.732]             else {
[13:21:57.732]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:57.732]             }
[13:21:57.732]             {
[13:21:57.732]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:57.732]                   0L) {
[13:21:57.732]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:57.732]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:57.732]                   base::options(opts)
[13:21:57.732]                 }
[13:21:57.732]                 {
[13:21:57.732]                   {
[13:21:57.732]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:57.732]                     NULL
[13:21:57.732]                   }
[13:21:57.732]                   options(future.plan = NULL)
[13:21:57.732]                   if (is.na(NA_character_)) 
[13:21:57.732]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:57.732]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:57.732]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:57.732]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:57.732]                     envir = parent.frame()) 
[13:21:57.732]                   {
[13:21:57.732]                     if (is.function(workers)) 
[13:21:57.732]                       workers <- workers()
[13:21:57.732]                     workers <- structure(as.integer(workers), 
[13:21:57.732]                       class = class(workers))
[13:21:57.732]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:57.732]                       workers >= 1)
[13:21:57.732]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:57.732]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:57.732]                     }
[13:21:57.732]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:57.732]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:57.732]                       envir = envir)
[13:21:57.732]                     if (!future$lazy) 
[13:21:57.732]                       future <- run(future)
[13:21:57.732]                     invisible(future)
[13:21:57.732]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:57.732]                 }
[13:21:57.732]             }
[13:21:57.732]         }
[13:21:57.732]     })
[13:21:57.732]     if (TRUE) {
[13:21:57.732]         base::sink(type = "output", split = FALSE)
[13:21:57.732]         if (TRUE) {
[13:21:57.732]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:57.732]         }
[13:21:57.732]         else {
[13:21:57.732]             ...future.result["stdout"] <- base::list(NULL)
[13:21:57.732]         }
[13:21:57.732]         base::close(...future.stdout)
[13:21:57.732]         ...future.stdout <- NULL
[13:21:57.732]     }
[13:21:57.732]     ...future.result$conditions <- ...future.conditions
[13:21:57.732]     ...future.result$finished <- base::Sys.time()
[13:21:57.732]     ...future.result
[13:21:57.732] }
[13:21:57.735] MultisessionFuture started
[13:21:57.735] - Launch lazy future ... done
[13:21:57.735] run() for ‘MultisessionFuture’ ... done
[13:21:57.782] receiveMessageFromWorker() for ClusterFuture ...
[13:21:57.782] - Validating connection of MultisessionFuture
[13:21:57.782] - received message: FutureResult
[13:21:57.783] - Received FutureResult
[13:21:57.783] - Erased future from FutureRegistry
[13:21:57.783] result() for ClusterFuture ...
[13:21:57.783] - result already collected: FutureResult
[13:21:57.783] result() for ClusterFuture ... done
[13:21:57.783] signalConditions() ...
[13:21:57.783]  - include = ‘immediateCondition’
[13:21:57.783]  - exclude = 
[13:21:57.783]  - resignal = FALSE
[13:21:57.783]  - Number of conditions: 1
[13:21:57.784] signalConditions() ... done
[13:21:57.784] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:57.784] A MultisessionFuture was resolved
- result = TRUE, recursive = 2 ... DONE
- result = TRUE, recursive = Inf ...
[13:21:57.784] getGlobalsAndPackages() ...
[13:21:57.784] Searching for globals...
[13:21:57.785] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:21:57.785] Searching for globals ... DONE
[13:21:57.786] Resolving globals: FALSE
[13:21:57.786] 
[13:21:57.786] 
[13:21:57.786] getGlobalsAndPackages() ... DONE
[13:21:57.786] run() for ‘Future’ ...
[13:21:57.786] - state: ‘created’
[13:21:57.787] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:57.801] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:57.801] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:57.801]   - Field: ‘node’
[13:21:57.801]   - Field: ‘label’
[13:21:57.801]   - Field: ‘local’
[13:21:57.801]   - Field: ‘owner’
[13:21:57.801]   - Field: ‘envir’
[13:21:57.801]   - Field: ‘workers’
[13:21:57.801]   - Field: ‘packages’
[13:21:57.802]   - Field: ‘gc’
[13:21:57.802]   - Field: ‘conditions’
[13:21:57.802]   - Field: ‘persistent’
[13:21:57.802]   - Field: ‘expr’
[13:21:57.802]   - Field: ‘uuid’
[13:21:57.802]   - Field: ‘seed’
[13:21:57.802]   - Field: ‘version’
[13:21:57.802]   - Field: ‘result’
[13:21:57.802]   - Field: ‘asynchronous’
[13:21:57.802]   - Field: ‘calls’
[13:21:57.802]   - Field: ‘globals’
[13:21:57.803]   - Field: ‘stdout’
[13:21:57.803]   - Field: ‘earlySignal’
[13:21:57.803]   - Field: ‘lazy’
[13:21:57.803]   - Field: ‘state’
[13:21:57.803] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:57.803] - Launch lazy future ...
[13:21:57.803] Packages needed by the future expression (n = 0): <none>
[13:21:57.803] Packages needed by future strategies (n = 0): <none>
[13:21:57.804] {
[13:21:57.804]     {
[13:21:57.804]         {
[13:21:57.804]             ...future.startTime <- base::Sys.time()
[13:21:57.804]             {
[13:21:57.804]                 {
[13:21:57.804]                   {
[13:21:57.804]                     {
[13:21:57.804]                       base::local({
[13:21:57.804]                         has_future <- base::requireNamespace("future", 
[13:21:57.804]                           quietly = TRUE)
[13:21:57.804]                         if (has_future) {
[13:21:57.804]                           ns <- base::getNamespace("future")
[13:21:57.804]                           version <- ns[[".package"]][["version"]]
[13:21:57.804]                           if (is.null(version)) 
[13:21:57.804]                             version <- utils::packageVersion("future")
[13:21:57.804]                         }
[13:21:57.804]                         else {
[13:21:57.804]                           version <- NULL
[13:21:57.804]                         }
[13:21:57.804]                         if (!has_future || version < "1.8.0") {
[13:21:57.804]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:57.804]                             "", base::R.version$version.string), 
[13:21:57.804]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:57.804]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:57.804]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:57.804]                               "release", "version")], collapse = " "), 
[13:21:57.804]                             hostname = base::Sys.info()[["nodename"]])
[13:21:57.804]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:57.804]                             info)
[13:21:57.804]                           info <- base::paste(info, collapse = "; ")
[13:21:57.804]                           if (!has_future) {
[13:21:57.804]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:57.804]                               info)
[13:21:57.804]                           }
[13:21:57.804]                           else {
[13:21:57.804]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:57.804]                               info, version)
[13:21:57.804]                           }
[13:21:57.804]                           base::stop(msg)
[13:21:57.804]                         }
[13:21:57.804]                       })
[13:21:57.804]                     }
[13:21:57.804]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:57.804]                     base::options(mc.cores = 1L)
[13:21:57.804]                   }
[13:21:57.804]                   options(future.plan = NULL)
[13:21:57.804]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:57.804]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:57.804]                 }
[13:21:57.804]                 ...future.workdir <- getwd()
[13:21:57.804]             }
[13:21:57.804]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:57.804]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:57.804]         }
[13:21:57.804]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:57.804]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:57.804]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:57.804]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:57.804]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:57.804]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:57.804]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:57.804]             base::names(...future.oldOptions))
[13:21:57.804]     }
[13:21:57.804]     if (FALSE) {
[13:21:57.804]     }
[13:21:57.804]     else {
[13:21:57.804]         if (TRUE) {
[13:21:57.804]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:57.804]                 open = "w")
[13:21:57.804]         }
[13:21:57.804]         else {
[13:21:57.804]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:57.804]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:57.804]         }
[13:21:57.804]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:57.804]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:57.804]             base::sink(type = "output", split = FALSE)
[13:21:57.804]             base::close(...future.stdout)
[13:21:57.804]         }, add = TRUE)
[13:21:57.804]     }
[13:21:57.804]     ...future.frame <- base::sys.nframe()
[13:21:57.804]     ...future.conditions <- base::list()
[13:21:57.804]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:57.804]     if (FALSE) {
[13:21:57.804]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:57.804]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:57.804]     }
[13:21:57.804]     ...future.result <- base::tryCatch({
[13:21:57.804]         base::withCallingHandlers({
[13:21:57.804]             ...future.value <- base::withVisible(base::local({
[13:21:57.804]                 ...future.makeSendCondition <- local({
[13:21:57.804]                   sendCondition <- NULL
[13:21:57.804]                   function(frame = 1L) {
[13:21:57.804]                     if (is.function(sendCondition)) 
[13:21:57.804]                       return(sendCondition)
[13:21:57.804]                     ns <- getNamespace("parallel")
[13:21:57.804]                     if (exists("sendData", mode = "function", 
[13:21:57.804]                       envir = ns)) {
[13:21:57.804]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:57.804]                         envir = ns)
[13:21:57.804]                       envir <- sys.frame(frame)
[13:21:57.804]                       master <- NULL
[13:21:57.804]                       while (!identical(envir, .GlobalEnv) && 
[13:21:57.804]                         !identical(envir, emptyenv())) {
[13:21:57.804]                         if (exists("master", mode = "list", envir = envir, 
[13:21:57.804]                           inherits = FALSE)) {
[13:21:57.804]                           master <- get("master", mode = "list", 
[13:21:57.804]                             envir = envir, inherits = FALSE)
[13:21:57.804]                           if (inherits(master, c("SOCKnode", 
[13:21:57.804]                             "SOCK0node"))) {
[13:21:57.804]                             sendCondition <<- function(cond) {
[13:21:57.804]                               data <- list(type = "VALUE", value = cond, 
[13:21:57.804]                                 success = TRUE)
[13:21:57.804]                               parallel_sendData(master, data)
[13:21:57.804]                             }
[13:21:57.804]                             return(sendCondition)
[13:21:57.804]                           }
[13:21:57.804]                         }
[13:21:57.804]                         frame <- frame + 1L
[13:21:57.804]                         envir <- sys.frame(frame)
[13:21:57.804]                       }
[13:21:57.804]                     }
[13:21:57.804]                     sendCondition <<- function(cond) NULL
[13:21:57.804]                   }
[13:21:57.804]                 })
[13:21:57.804]                 withCallingHandlers({
[13:21:57.804]                   {
[13:21:57.804]                     Sys.sleep(0.5)
[13:21:57.804]                     list(a = 1, b = 42L)
[13:21:57.804]                   }
[13:21:57.804]                 }, immediateCondition = function(cond) {
[13:21:57.804]                   sendCondition <- ...future.makeSendCondition()
[13:21:57.804]                   sendCondition(cond)
[13:21:57.804]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:57.804]                   {
[13:21:57.804]                     inherits <- base::inherits
[13:21:57.804]                     invokeRestart <- base::invokeRestart
[13:21:57.804]                     is.null <- base::is.null
[13:21:57.804]                     muffled <- FALSE
[13:21:57.804]                     if (inherits(cond, "message")) {
[13:21:57.804]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:57.804]                       if (muffled) 
[13:21:57.804]                         invokeRestart("muffleMessage")
[13:21:57.804]                     }
[13:21:57.804]                     else if (inherits(cond, "warning")) {
[13:21:57.804]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:57.804]                       if (muffled) 
[13:21:57.804]                         invokeRestart("muffleWarning")
[13:21:57.804]                     }
[13:21:57.804]                     else if (inherits(cond, "condition")) {
[13:21:57.804]                       if (!is.null(pattern)) {
[13:21:57.804]                         computeRestarts <- base::computeRestarts
[13:21:57.804]                         grepl <- base::grepl
[13:21:57.804]                         restarts <- computeRestarts(cond)
[13:21:57.804]                         for (restart in restarts) {
[13:21:57.804]                           name <- restart$name
[13:21:57.804]                           if (is.null(name)) 
[13:21:57.804]                             next
[13:21:57.804]                           if (!grepl(pattern, name)) 
[13:21:57.804]                             next
[13:21:57.804]                           invokeRestart(restart)
[13:21:57.804]                           muffled <- TRUE
[13:21:57.804]                           break
[13:21:57.804]                         }
[13:21:57.804]                       }
[13:21:57.804]                     }
[13:21:57.804]                     invisible(muffled)
[13:21:57.804]                   }
[13:21:57.804]                   muffleCondition(cond)
[13:21:57.804]                 })
[13:21:57.804]             }))
[13:21:57.804]             future::FutureResult(value = ...future.value$value, 
[13:21:57.804]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:57.804]                   ...future.rng), globalenv = if (FALSE) 
[13:21:57.804]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:57.804]                     ...future.globalenv.names))
[13:21:57.804]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:57.804]         }, condition = base::local({
[13:21:57.804]             c <- base::c
[13:21:57.804]             inherits <- base::inherits
[13:21:57.804]             invokeRestart <- base::invokeRestart
[13:21:57.804]             length <- base::length
[13:21:57.804]             list <- base::list
[13:21:57.804]             seq.int <- base::seq.int
[13:21:57.804]             signalCondition <- base::signalCondition
[13:21:57.804]             sys.calls <- base::sys.calls
[13:21:57.804]             `[[` <- base::`[[`
[13:21:57.804]             `+` <- base::`+`
[13:21:57.804]             `<<-` <- base::`<<-`
[13:21:57.804]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:57.804]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:57.804]                   3L)]
[13:21:57.804]             }
[13:21:57.804]             function(cond) {
[13:21:57.804]                 is_error <- inherits(cond, "error")
[13:21:57.804]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:57.804]                   NULL)
[13:21:57.804]                 if (is_error) {
[13:21:57.804]                   sessionInformation <- function() {
[13:21:57.804]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:57.804]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:57.804]                       search = base::search(), system = base::Sys.info())
[13:21:57.804]                   }
[13:21:57.804]                   ...future.conditions[[length(...future.conditions) + 
[13:21:57.804]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:57.804]                     cond$call), session = sessionInformation(), 
[13:21:57.804]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:57.804]                   signalCondition(cond)
[13:21:57.804]                 }
[13:21:57.804]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:57.804]                 "immediateCondition"))) {
[13:21:57.804]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:57.804]                   ...future.conditions[[length(...future.conditions) + 
[13:21:57.804]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:57.804]                   if (TRUE && !signal) {
[13:21:57.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:57.804]                     {
[13:21:57.804]                       inherits <- base::inherits
[13:21:57.804]                       invokeRestart <- base::invokeRestart
[13:21:57.804]                       is.null <- base::is.null
[13:21:57.804]                       muffled <- FALSE
[13:21:57.804]                       if (inherits(cond, "message")) {
[13:21:57.804]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:57.804]                         if (muffled) 
[13:21:57.804]                           invokeRestart("muffleMessage")
[13:21:57.804]                       }
[13:21:57.804]                       else if (inherits(cond, "warning")) {
[13:21:57.804]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:57.804]                         if (muffled) 
[13:21:57.804]                           invokeRestart("muffleWarning")
[13:21:57.804]                       }
[13:21:57.804]                       else if (inherits(cond, "condition")) {
[13:21:57.804]                         if (!is.null(pattern)) {
[13:21:57.804]                           computeRestarts <- base::computeRestarts
[13:21:57.804]                           grepl <- base::grepl
[13:21:57.804]                           restarts <- computeRestarts(cond)
[13:21:57.804]                           for (restart in restarts) {
[13:21:57.804]                             name <- restart$name
[13:21:57.804]                             if (is.null(name)) 
[13:21:57.804]                               next
[13:21:57.804]                             if (!grepl(pattern, name)) 
[13:21:57.804]                               next
[13:21:57.804]                             invokeRestart(restart)
[13:21:57.804]                             muffled <- TRUE
[13:21:57.804]                             break
[13:21:57.804]                           }
[13:21:57.804]                         }
[13:21:57.804]                       }
[13:21:57.804]                       invisible(muffled)
[13:21:57.804]                     }
[13:21:57.804]                     muffleCondition(cond, pattern = "^muffle")
[13:21:57.804]                   }
[13:21:57.804]                 }
[13:21:57.804]                 else {
[13:21:57.804]                   if (TRUE) {
[13:21:57.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:57.804]                     {
[13:21:57.804]                       inherits <- base::inherits
[13:21:57.804]                       invokeRestart <- base::invokeRestart
[13:21:57.804]                       is.null <- base::is.null
[13:21:57.804]                       muffled <- FALSE
[13:21:57.804]                       if (inherits(cond, "message")) {
[13:21:57.804]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:57.804]                         if (muffled) 
[13:21:57.804]                           invokeRestart("muffleMessage")
[13:21:57.804]                       }
[13:21:57.804]                       else if (inherits(cond, "warning")) {
[13:21:57.804]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:57.804]                         if (muffled) 
[13:21:57.804]                           invokeRestart("muffleWarning")
[13:21:57.804]                       }
[13:21:57.804]                       else if (inherits(cond, "condition")) {
[13:21:57.804]                         if (!is.null(pattern)) {
[13:21:57.804]                           computeRestarts <- base::computeRestarts
[13:21:57.804]                           grepl <- base::grepl
[13:21:57.804]                           restarts <- computeRestarts(cond)
[13:21:57.804]                           for (restart in restarts) {
[13:21:57.804]                             name <- restart$name
[13:21:57.804]                             if (is.null(name)) 
[13:21:57.804]                               next
[13:21:57.804]                             if (!grepl(pattern, name)) 
[13:21:57.804]                               next
[13:21:57.804]                             invokeRestart(restart)
[13:21:57.804]                             muffled <- TRUE
[13:21:57.804]                             break
[13:21:57.804]                           }
[13:21:57.804]                         }
[13:21:57.804]                       }
[13:21:57.804]                       invisible(muffled)
[13:21:57.804]                     }
[13:21:57.804]                     muffleCondition(cond, pattern = "^muffle")
[13:21:57.804]                   }
[13:21:57.804]                 }
[13:21:57.804]             }
[13:21:57.804]         }))
[13:21:57.804]     }, error = function(ex) {
[13:21:57.804]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:57.804]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:57.804]                 ...future.rng), started = ...future.startTime, 
[13:21:57.804]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:57.804]             version = "1.8"), class = "FutureResult")
[13:21:57.804]     }, finally = {
[13:21:57.804]         if (!identical(...future.workdir, getwd())) 
[13:21:57.804]             setwd(...future.workdir)
[13:21:57.804]         {
[13:21:57.804]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:57.804]                 ...future.oldOptions$nwarnings <- NULL
[13:21:57.804]             }
[13:21:57.804]             base::options(...future.oldOptions)
[13:21:57.804]             if (.Platform$OS.type == "windows") {
[13:21:57.804]                 old_names <- names(...future.oldEnvVars)
[13:21:57.804]                 envs <- base::Sys.getenv()
[13:21:57.804]                 names <- names(envs)
[13:21:57.804]                 common <- intersect(names, old_names)
[13:21:57.804]                 added <- setdiff(names, old_names)
[13:21:57.804]                 removed <- setdiff(old_names, names)
[13:21:57.804]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:57.804]                   envs[common]]
[13:21:57.804]                 NAMES <- toupper(changed)
[13:21:57.804]                 args <- list()
[13:21:57.804]                 for (kk in seq_along(NAMES)) {
[13:21:57.804]                   name <- changed[[kk]]
[13:21:57.804]                   NAME <- NAMES[[kk]]
[13:21:57.804]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:57.804]                     next
[13:21:57.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:57.804]                 }
[13:21:57.804]                 NAMES <- toupper(added)
[13:21:57.804]                 for (kk in seq_along(NAMES)) {
[13:21:57.804]                   name <- added[[kk]]
[13:21:57.804]                   NAME <- NAMES[[kk]]
[13:21:57.804]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:57.804]                     next
[13:21:57.804]                   args[[name]] <- ""
[13:21:57.804]                 }
[13:21:57.804]                 NAMES <- toupper(removed)
[13:21:57.804]                 for (kk in seq_along(NAMES)) {
[13:21:57.804]                   name <- removed[[kk]]
[13:21:57.804]                   NAME <- NAMES[[kk]]
[13:21:57.804]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:57.804]                     next
[13:21:57.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:57.804]                 }
[13:21:57.804]                 if (length(args) > 0) 
[13:21:57.804]                   base::do.call(base::Sys.setenv, args = args)
[13:21:57.804]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:57.804]             }
[13:21:57.804]             else {
[13:21:57.804]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:57.804]             }
[13:21:57.804]             {
[13:21:57.804]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:57.804]                   0L) {
[13:21:57.804]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:57.804]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:57.804]                   base::options(opts)
[13:21:57.804]                 }
[13:21:57.804]                 {
[13:21:57.804]                   {
[13:21:57.804]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:57.804]                     NULL
[13:21:57.804]                   }
[13:21:57.804]                   options(future.plan = NULL)
[13:21:57.804]                   if (is.na(NA_character_)) 
[13:21:57.804]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:57.804]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:57.804]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:57.804]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:57.804]                     envir = parent.frame()) 
[13:21:57.804]                   {
[13:21:57.804]                     if (is.function(workers)) 
[13:21:57.804]                       workers <- workers()
[13:21:57.804]                     workers <- structure(as.integer(workers), 
[13:21:57.804]                       class = class(workers))
[13:21:57.804]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:57.804]                       workers >= 1)
[13:21:57.804]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:57.804]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:57.804]                     }
[13:21:57.804]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:57.804]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:57.804]                       envir = envir)
[13:21:57.804]                     if (!future$lazy) 
[13:21:57.804]                       future <- run(future)
[13:21:57.804]                     invisible(future)
[13:21:57.804]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:57.804]                 }
[13:21:57.804]             }
[13:21:57.804]         }
[13:21:57.804]     })
[13:21:57.804]     if (TRUE) {
[13:21:57.804]         base::sink(type = "output", split = FALSE)
[13:21:57.804]         if (TRUE) {
[13:21:57.804]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:57.804]         }
[13:21:57.804]         else {
[13:21:57.804]             ...future.result["stdout"] <- base::list(NULL)
[13:21:57.804]         }
[13:21:57.804]         base::close(...future.stdout)
[13:21:57.804]         ...future.stdout <- NULL
[13:21:57.804]     }
[13:21:57.804]     ...future.result$conditions <- ...future.conditions
[13:21:57.804]     ...future.result$finished <- base::Sys.time()
[13:21:57.804]     ...future.result
[13:21:57.804] }
[13:21:57.807] MultisessionFuture started
[13:21:57.807] - Launch lazy future ... done
[13:21:57.807] run() for ‘MultisessionFuture’ ... done
[13:21:58.365] receiveMessageFromWorker() for ClusterFuture ...
[13:21:58.365] - Validating connection of MultisessionFuture
[13:21:58.365] - received message: FutureResult
[13:21:58.365] - Received FutureResult
[13:21:58.365] - Erased future from FutureRegistry
[13:21:58.365] result() for ClusterFuture ...
[13:21:58.366] - result already collected: FutureResult
[13:21:58.366] result() for ClusterFuture ... done
[13:21:58.366] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:58.366] resolve() on list ...
[13:21:58.366]  recursive: Inf
[13:21:58.366]  length: 2
[13:21:58.366]  elements: ‘a’, ‘b’
[13:21:58.366]  length: 1 (resolved future 1)
[13:21:58.366]  length: 0 (resolved future 2)
[13:21:58.366] resolve() on list ... DONE
[13:21:58.366] A MultisessionFuture was resolved (and resolved itself)
[13:21:58.367] getGlobalsAndPackages() ...
[13:21:58.367] Searching for globals...
[13:21:58.368] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:21:58.368] Searching for globals ... DONE
[13:21:58.368] Resolving globals: FALSE
[13:21:58.368] 
[13:21:58.368] 
[13:21:58.369] getGlobalsAndPackages() ... DONE
[13:21:58.369] run() for ‘Future’ ...
[13:21:58.369] - state: ‘created’
[13:21:58.369] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:58.383] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:58.384] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:58.384]   - Field: ‘node’
[13:21:58.384]   - Field: ‘label’
[13:21:58.384]   - Field: ‘local’
[13:21:58.384]   - Field: ‘owner’
[13:21:58.384]   - Field: ‘envir’
[13:21:58.384]   - Field: ‘workers’
[13:21:58.384]   - Field: ‘packages’
[13:21:58.384]   - Field: ‘gc’
[13:21:58.384]   - Field: ‘conditions’
[13:21:58.385]   - Field: ‘persistent’
[13:21:58.385]   - Field: ‘expr’
[13:21:58.385]   - Field: ‘uuid’
[13:21:58.385]   - Field: ‘seed’
[13:21:58.385]   - Field: ‘version’
[13:21:58.385]   - Field: ‘result’
[13:21:58.385]   - Field: ‘asynchronous’
[13:21:58.385]   - Field: ‘calls’
[13:21:58.385]   - Field: ‘globals’
[13:21:58.385]   - Field: ‘stdout’
[13:21:58.386]   - Field: ‘earlySignal’
[13:21:58.386]   - Field: ‘lazy’
[13:21:58.386]   - Field: ‘state’
[13:21:58.386] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:58.386] - Launch lazy future ...
[13:21:58.386] Packages needed by the future expression (n = 0): <none>
[13:21:58.386] Packages needed by future strategies (n = 0): <none>
[13:21:58.387] {
[13:21:58.387]     {
[13:21:58.387]         {
[13:21:58.387]             ...future.startTime <- base::Sys.time()
[13:21:58.387]             {
[13:21:58.387]                 {
[13:21:58.387]                   {
[13:21:58.387]                     {
[13:21:58.387]                       base::local({
[13:21:58.387]                         has_future <- base::requireNamespace("future", 
[13:21:58.387]                           quietly = TRUE)
[13:21:58.387]                         if (has_future) {
[13:21:58.387]                           ns <- base::getNamespace("future")
[13:21:58.387]                           version <- ns[[".package"]][["version"]]
[13:21:58.387]                           if (is.null(version)) 
[13:21:58.387]                             version <- utils::packageVersion("future")
[13:21:58.387]                         }
[13:21:58.387]                         else {
[13:21:58.387]                           version <- NULL
[13:21:58.387]                         }
[13:21:58.387]                         if (!has_future || version < "1.8.0") {
[13:21:58.387]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:58.387]                             "", base::R.version$version.string), 
[13:21:58.387]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:58.387]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:58.387]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:58.387]                               "release", "version")], collapse = " "), 
[13:21:58.387]                             hostname = base::Sys.info()[["nodename"]])
[13:21:58.387]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:58.387]                             info)
[13:21:58.387]                           info <- base::paste(info, collapse = "; ")
[13:21:58.387]                           if (!has_future) {
[13:21:58.387]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:58.387]                               info)
[13:21:58.387]                           }
[13:21:58.387]                           else {
[13:21:58.387]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:58.387]                               info, version)
[13:21:58.387]                           }
[13:21:58.387]                           base::stop(msg)
[13:21:58.387]                         }
[13:21:58.387]                       })
[13:21:58.387]                     }
[13:21:58.387]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:58.387]                     base::options(mc.cores = 1L)
[13:21:58.387]                   }
[13:21:58.387]                   options(future.plan = NULL)
[13:21:58.387]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:58.387]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:58.387]                 }
[13:21:58.387]                 ...future.workdir <- getwd()
[13:21:58.387]             }
[13:21:58.387]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:58.387]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:58.387]         }
[13:21:58.387]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:58.387]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:58.387]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:58.387]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:58.387]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:58.387]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:58.387]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:58.387]             base::names(...future.oldOptions))
[13:21:58.387]     }
[13:21:58.387]     if (FALSE) {
[13:21:58.387]     }
[13:21:58.387]     else {
[13:21:58.387]         if (TRUE) {
[13:21:58.387]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:58.387]                 open = "w")
[13:21:58.387]         }
[13:21:58.387]         else {
[13:21:58.387]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:58.387]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:58.387]         }
[13:21:58.387]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:58.387]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:58.387]             base::sink(type = "output", split = FALSE)
[13:21:58.387]             base::close(...future.stdout)
[13:21:58.387]         }, add = TRUE)
[13:21:58.387]     }
[13:21:58.387]     ...future.frame <- base::sys.nframe()
[13:21:58.387]     ...future.conditions <- base::list()
[13:21:58.387]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:58.387]     if (FALSE) {
[13:21:58.387]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:58.387]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:58.387]     }
[13:21:58.387]     ...future.result <- base::tryCatch({
[13:21:58.387]         base::withCallingHandlers({
[13:21:58.387]             ...future.value <- base::withVisible(base::local({
[13:21:58.387]                 ...future.makeSendCondition <- local({
[13:21:58.387]                   sendCondition <- NULL
[13:21:58.387]                   function(frame = 1L) {
[13:21:58.387]                     if (is.function(sendCondition)) 
[13:21:58.387]                       return(sendCondition)
[13:21:58.387]                     ns <- getNamespace("parallel")
[13:21:58.387]                     if (exists("sendData", mode = "function", 
[13:21:58.387]                       envir = ns)) {
[13:21:58.387]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:58.387]                         envir = ns)
[13:21:58.387]                       envir <- sys.frame(frame)
[13:21:58.387]                       master <- NULL
[13:21:58.387]                       while (!identical(envir, .GlobalEnv) && 
[13:21:58.387]                         !identical(envir, emptyenv())) {
[13:21:58.387]                         if (exists("master", mode = "list", envir = envir, 
[13:21:58.387]                           inherits = FALSE)) {
[13:21:58.387]                           master <- get("master", mode = "list", 
[13:21:58.387]                             envir = envir, inherits = FALSE)
[13:21:58.387]                           if (inherits(master, c("SOCKnode", 
[13:21:58.387]                             "SOCK0node"))) {
[13:21:58.387]                             sendCondition <<- function(cond) {
[13:21:58.387]                               data <- list(type = "VALUE", value = cond, 
[13:21:58.387]                                 success = TRUE)
[13:21:58.387]                               parallel_sendData(master, data)
[13:21:58.387]                             }
[13:21:58.387]                             return(sendCondition)
[13:21:58.387]                           }
[13:21:58.387]                         }
[13:21:58.387]                         frame <- frame + 1L
[13:21:58.387]                         envir <- sys.frame(frame)
[13:21:58.387]                       }
[13:21:58.387]                     }
[13:21:58.387]                     sendCondition <<- function(cond) NULL
[13:21:58.387]                   }
[13:21:58.387]                 })
[13:21:58.387]                 withCallingHandlers({
[13:21:58.387]                   {
[13:21:58.387]                     Sys.sleep(0.5)
[13:21:58.387]                     list(a = 1, b = 42L)
[13:21:58.387]                   }
[13:21:58.387]                 }, immediateCondition = function(cond) {
[13:21:58.387]                   sendCondition <- ...future.makeSendCondition()
[13:21:58.387]                   sendCondition(cond)
[13:21:58.387]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:58.387]                   {
[13:21:58.387]                     inherits <- base::inherits
[13:21:58.387]                     invokeRestart <- base::invokeRestart
[13:21:58.387]                     is.null <- base::is.null
[13:21:58.387]                     muffled <- FALSE
[13:21:58.387]                     if (inherits(cond, "message")) {
[13:21:58.387]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:58.387]                       if (muffled) 
[13:21:58.387]                         invokeRestart("muffleMessage")
[13:21:58.387]                     }
[13:21:58.387]                     else if (inherits(cond, "warning")) {
[13:21:58.387]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:58.387]                       if (muffled) 
[13:21:58.387]                         invokeRestart("muffleWarning")
[13:21:58.387]                     }
[13:21:58.387]                     else if (inherits(cond, "condition")) {
[13:21:58.387]                       if (!is.null(pattern)) {
[13:21:58.387]                         computeRestarts <- base::computeRestarts
[13:21:58.387]                         grepl <- base::grepl
[13:21:58.387]                         restarts <- computeRestarts(cond)
[13:21:58.387]                         for (restart in restarts) {
[13:21:58.387]                           name <- restart$name
[13:21:58.387]                           if (is.null(name)) 
[13:21:58.387]                             next
[13:21:58.387]                           if (!grepl(pattern, name)) 
[13:21:58.387]                             next
[13:21:58.387]                           invokeRestart(restart)
[13:21:58.387]                           muffled <- TRUE
[13:21:58.387]                           break
[13:21:58.387]                         }
[13:21:58.387]                       }
[13:21:58.387]                     }
[13:21:58.387]                     invisible(muffled)
[13:21:58.387]                   }
[13:21:58.387]                   muffleCondition(cond)
[13:21:58.387]                 })
[13:21:58.387]             }))
[13:21:58.387]             future::FutureResult(value = ...future.value$value, 
[13:21:58.387]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:58.387]                   ...future.rng), globalenv = if (FALSE) 
[13:21:58.387]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:58.387]                     ...future.globalenv.names))
[13:21:58.387]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:58.387]         }, condition = base::local({
[13:21:58.387]             c <- base::c
[13:21:58.387]             inherits <- base::inherits
[13:21:58.387]             invokeRestart <- base::invokeRestart
[13:21:58.387]             length <- base::length
[13:21:58.387]             list <- base::list
[13:21:58.387]             seq.int <- base::seq.int
[13:21:58.387]             signalCondition <- base::signalCondition
[13:21:58.387]             sys.calls <- base::sys.calls
[13:21:58.387]             `[[` <- base::`[[`
[13:21:58.387]             `+` <- base::`+`
[13:21:58.387]             `<<-` <- base::`<<-`
[13:21:58.387]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:58.387]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:58.387]                   3L)]
[13:21:58.387]             }
[13:21:58.387]             function(cond) {
[13:21:58.387]                 is_error <- inherits(cond, "error")
[13:21:58.387]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:58.387]                   NULL)
[13:21:58.387]                 if (is_error) {
[13:21:58.387]                   sessionInformation <- function() {
[13:21:58.387]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:58.387]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:58.387]                       search = base::search(), system = base::Sys.info())
[13:21:58.387]                   }
[13:21:58.387]                   ...future.conditions[[length(...future.conditions) + 
[13:21:58.387]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:58.387]                     cond$call), session = sessionInformation(), 
[13:21:58.387]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:58.387]                   signalCondition(cond)
[13:21:58.387]                 }
[13:21:58.387]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:58.387]                 "immediateCondition"))) {
[13:21:58.387]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:58.387]                   ...future.conditions[[length(...future.conditions) + 
[13:21:58.387]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:58.387]                   if (TRUE && !signal) {
[13:21:58.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:58.387]                     {
[13:21:58.387]                       inherits <- base::inherits
[13:21:58.387]                       invokeRestart <- base::invokeRestart
[13:21:58.387]                       is.null <- base::is.null
[13:21:58.387]                       muffled <- FALSE
[13:21:58.387]                       if (inherits(cond, "message")) {
[13:21:58.387]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:58.387]                         if (muffled) 
[13:21:58.387]                           invokeRestart("muffleMessage")
[13:21:58.387]                       }
[13:21:58.387]                       else if (inherits(cond, "warning")) {
[13:21:58.387]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:58.387]                         if (muffled) 
[13:21:58.387]                           invokeRestart("muffleWarning")
[13:21:58.387]                       }
[13:21:58.387]                       else if (inherits(cond, "condition")) {
[13:21:58.387]                         if (!is.null(pattern)) {
[13:21:58.387]                           computeRestarts <- base::computeRestarts
[13:21:58.387]                           grepl <- base::grepl
[13:21:58.387]                           restarts <- computeRestarts(cond)
[13:21:58.387]                           for (restart in restarts) {
[13:21:58.387]                             name <- restart$name
[13:21:58.387]                             if (is.null(name)) 
[13:21:58.387]                               next
[13:21:58.387]                             if (!grepl(pattern, name)) 
[13:21:58.387]                               next
[13:21:58.387]                             invokeRestart(restart)
[13:21:58.387]                             muffled <- TRUE
[13:21:58.387]                             break
[13:21:58.387]                           }
[13:21:58.387]                         }
[13:21:58.387]                       }
[13:21:58.387]                       invisible(muffled)
[13:21:58.387]                     }
[13:21:58.387]                     muffleCondition(cond, pattern = "^muffle")
[13:21:58.387]                   }
[13:21:58.387]                 }
[13:21:58.387]                 else {
[13:21:58.387]                   if (TRUE) {
[13:21:58.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:58.387]                     {
[13:21:58.387]                       inherits <- base::inherits
[13:21:58.387]                       invokeRestart <- base::invokeRestart
[13:21:58.387]                       is.null <- base::is.null
[13:21:58.387]                       muffled <- FALSE
[13:21:58.387]                       if (inherits(cond, "message")) {
[13:21:58.387]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:58.387]                         if (muffled) 
[13:21:58.387]                           invokeRestart("muffleMessage")
[13:21:58.387]                       }
[13:21:58.387]                       else if (inherits(cond, "warning")) {
[13:21:58.387]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:58.387]                         if (muffled) 
[13:21:58.387]                           invokeRestart("muffleWarning")
[13:21:58.387]                       }
[13:21:58.387]                       else if (inherits(cond, "condition")) {
[13:21:58.387]                         if (!is.null(pattern)) {
[13:21:58.387]                           computeRestarts <- base::computeRestarts
[13:21:58.387]                           grepl <- base::grepl
[13:21:58.387]                           restarts <- computeRestarts(cond)
[13:21:58.387]                           for (restart in restarts) {
[13:21:58.387]                             name <- restart$name
[13:21:58.387]                             if (is.null(name)) 
[13:21:58.387]                               next
[13:21:58.387]                             if (!grepl(pattern, name)) 
[13:21:58.387]                               next
[13:21:58.387]                             invokeRestart(restart)
[13:21:58.387]                             muffled <- TRUE
[13:21:58.387]                             break
[13:21:58.387]                           }
[13:21:58.387]                         }
[13:21:58.387]                       }
[13:21:58.387]                       invisible(muffled)
[13:21:58.387]                     }
[13:21:58.387]                     muffleCondition(cond, pattern = "^muffle")
[13:21:58.387]                   }
[13:21:58.387]                 }
[13:21:58.387]             }
[13:21:58.387]         }))
[13:21:58.387]     }, error = function(ex) {
[13:21:58.387]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:58.387]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:58.387]                 ...future.rng), started = ...future.startTime, 
[13:21:58.387]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:58.387]             version = "1.8"), class = "FutureResult")
[13:21:58.387]     }, finally = {
[13:21:58.387]         if (!identical(...future.workdir, getwd())) 
[13:21:58.387]             setwd(...future.workdir)
[13:21:58.387]         {
[13:21:58.387]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:58.387]                 ...future.oldOptions$nwarnings <- NULL
[13:21:58.387]             }
[13:21:58.387]             base::options(...future.oldOptions)
[13:21:58.387]             if (.Platform$OS.type == "windows") {
[13:21:58.387]                 old_names <- names(...future.oldEnvVars)
[13:21:58.387]                 envs <- base::Sys.getenv()
[13:21:58.387]                 names <- names(envs)
[13:21:58.387]                 common <- intersect(names, old_names)
[13:21:58.387]                 added <- setdiff(names, old_names)
[13:21:58.387]                 removed <- setdiff(old_names, names)
[13:21:58.387]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:58.387]                   envs[common]]
[13:21:58.387]                 NAMES <- toupper(changed)
[13:21:58.387]                 args <- list()
[13:21:58.387]                 for (kk in seq_along(NAMES)) {
[13:21:58.387]                   name <- changed[[kk]]
[13:21:58.387]                   NAME <- NAMES[[kk]]
[13:21:58.387]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:58.387]                     next
[13:21:58.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:58.387]                 }
[13:21:58.387]                 NAMES <- toupper(added)
[13:21:58.387]                 for (kk in seq_along(NAMES)) {
[13:21:58.387]                   name <- added[[kk]]
[13:21:58.387]                   NAME <- NAMES[[kk]]
[13:21:58.387]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:58.387]                     next
[13:21:58.387]                   args[[name]] <- ""
[13:21:58.387]                 }
[13:21:58.387]                 NAMES <- toupper(removed)
[13:21:58.387]                 for (kk in seq_along(NAMES)) {
[13:21:58.387]                   name <- removed[[kk]]
[13:21:58.387]                   NAME <- NAMES[[kk]]
[13:21:58.387]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:58.387]                     next
[13:21:58.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:58.387]                 }
[13:21:58.387]                 if (length(args) > 0) 
[13:21:58.387]                   base::do.call(base::Sys.setenv, args = args)
[13:21:58.387]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:58.387]             }
[13:21:58.387]             else {
[13:21:58.387]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:58.387]             }
[13:21:58.387]             {
[13:21:58.387]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:58.387]                   0L) {
[13:21:58.387]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:58.387]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:58.387]                   base::options(opts)
[13:21:58.387]                 }
[13:21:58.387]                 {
[13:21:58.387]                   {
[13:21:58.387]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:58.387]                     NULL
[13:21:58.387]                   }
[13:21:58.387]                   options(future.plan = NULL)
[13:21:58.387]                   if (is.na(NA_character_)) 
[13:21:58.387]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:58.387]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:58.387]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:58.387]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:58.387]                     envir = parent.frame()) 
[13:21:58.387]                   {
[13:21:58.387]                     if (is.function(workers)) 
[13:21:58.387]                       workers <- workers()
[13:21:58.387]                     workers <- structure(as.integer(workers), 
[13:21:58.387]                       class = class(workers))
[13:21:58.387]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:58.387]                       workers >= 1)
[13:21:58.387]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:58.387]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:58.387]                     }
[13:21:58.387]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:58.387]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:58.387]                       envir = envir)
[13:21:58.387]                     if (!future$lazy) 
[13:21:58.387]                       future <- run(future)
[13:21:58.387]                     invisible(future)
[13:21:58.387]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:58.387]                 }
[13:21:58.387]             }
[13:21:58.387]         }
[13:21:58.387]     })
[13:21:58.387]     if (TRUE) {
[13:21:58.387]         base::sink(type = "output", split = FALSE)
[13:21:58.387]         if (TRUE) {
[13:21:58.387]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:58.387]         }
[13:21:58.387]         else {
[13:21:58.387]             ...future.result["stdout"] <- base::list(NULL)
[13:21:58.387]         }
[13:21:58.387]         base::close(...future.stdout)
[13:21:58.387]         ...future.stdout <- NULL
[13:21:58.387]     }
[13:21:58.387]     ...future.result$conditions <- ...future.conditions
[13:21:58.387]     ...future.result$finished <- base::Sys.time()
[13:21:58.387]     ...future.result
[13:21:58.387] }
[13:21:58.390] MultisessionFuture started
[13:21:58.390] - Launch lazy future ... done
[13:21:58.391] run() for ‘MultisessionFuture’ ... done
[13:21:58.939] receiveMessageFromWorker() for ClusterFuture ...
[13:21:58.939] - Validating connection of MultisessionFuture
[13:21:58.939] - received message: FutureResult
[13:21:58.939] - Received FutureResult
[13:21:58.939] - Erased future from FutureRegistry
[13:21:58.940] result() for ClusterFuture ...
[13:21:58.940] - result already collected: FutureResult
[13:21:58.940] result() for ClusterFuture ... done
[13:21:58.940] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:58.940] resolve() on list ...
[13:21:58.940]  recursive: Inf
[13:21:58.940]  length: 2
[13:21:58.940]  elements: ‘a’, ‘b’
[13:21:58.941]  length: 1 (resolved future 1)
[13:21:58.941]  length: 0 (resolved future 2)
[13:21:58.941] resolve() on list ... DONE
[13:21:58.941] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[13:21:58.944] getGlobalsAndPackages() ...
[13:21:58.944] Searching for globals...
[13:21:58.945] - globals found: [2] ‘list’, ‘stop’
[13:21:58.945] Searching for globals ... DONE
[13:21:58.945] Resolving globals: FALSE
[13:21:58.946] 
[13:21:58.946] 
[13:21:58.946] getGlobalsAndPackages() ... DONE
[13:21:58.946] run() for ‘Future’ ...
[13:21:58.946] - state: ‘created’
[13:21:58.946] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:58.960] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:58.960] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:58.961]   - Field: ‘node’
[13:21:58.961]   - Field: ‘label’
[13:21:58.961]   - Field: ‘local’
[13:21:58.961]   - Field: ‘owner’
[13:21:58.961]   - Field: ‘envir’
[13:21:58.961]   - Field: ‘workers’
[13:21:58.961]   - Field: ‘packages’
[13:21:58.961]   - Field: ‘gc’
[13:21:58.961]   - Field: ‘conditions’
[13:21:58.961]   - Field: ‘persistent’
[13:21:58.961]   - Field: ‘expr’
[13:21:58.962]   - Field: ‘uuid’
[13:21:58.962]   - Field: ‘seed’
[13:21:58.962]   - Field: ‘version’
[13:21:58.962]   - Field: ‘result’
[13:21:58.962]   - Field: ‘asynchronous’
[13:21:58.962]   - Field: ‘calls’
[13:21:58.962]   - Field: ‘globals’
[13:21:58.962]   - Field: ‘stdout’
[13:21:58.962]   - Field: ‘earlySignal’
[13:21:58.962]   - Field: ‘lazy’
[13:21:58.962]   - Field: ‘state’
[13:21:58.962] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:58.963] - Launch lazy future ...
[13:21:58.963] Packages needed by the future expression (n = 0): <none>
[13:21:58.963] Packages needed by future strategies (n = 0): <none>
[13:21:58.963] {
[13:21:58.963]     {
[13:21:58.963]         {
[13:21:58.963]             ...future.startTime <- base::Sys.time()
[13:21:58.963]             {
[13:21:58.963]                 {
[13:21:58.963]                   {
[13:21:58.963]                     {
[13:21:58.963]                       base::local({
[13:21:58.963]                         has_future <- base::requireNamespace("future", 
[13:21:58.963]                           quietly = TRUE)
[13:21:58.963]                         if (has_future) {
[13:21:58.963]                           ns <- base::getNamespace("future")
[13:21:58.963]                           version <- ns[[".package"]][["version"]]
[13:21:58.963]                           if (is.null(version)) 
[13:21:58.963]                             version <- utils::packageVersion("future")
[13:21:58.963]                         }
[13:21:58.963]                         else {
[13:21:58.963]                           version <- NULL
[13:21:58.963]                         }
[13:21:58.963]                         if (!has_future || version < "1.8.0") {
[13:21:58.963]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:58.963]                             "", base::R.version$version.string), 
[13:21:58.963]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:58.963]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:58.963]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:58.963]                               "release", "version")], collapse = " "), 
[13:21:58.963]                             hostname = base::Sys.info()[["nodename"]])
[13:21:58.963]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:58.963]                             info)
[13:21:58.963]                           info <- base::paste(info, collapse = "; ")
[13:21:58.963]                           if (!has_future) {
[13:21:58.963]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:58.963]                               info)
[13:21:58.963]                           }
[13:21:58.963]                           else {
[13:21:58.963]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:58.963]                               info, version)
[13:21:58.963]                           }
[13:21:58.963]                           base::stop(msg)
[13:21:58.963]                         }
[13:21:58.963]                       })
[13:21:58.963]                     }
[13:21:58.963]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:58.963]                     base::options(mc.cores = 1L)
[13:21:58.963]                   }
[13:21:58.963]                   options(future.plan = NULL)
[13:21:58.963]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:58.963]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:58.963]                 }
[13:21:58.963]                 ...future.workdir <- getwd()
[13:21:58.963]             }
[13:21:58.963]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:58.963]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:58.963]         }
[13:21:58.963]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:58.963]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:58.963]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:58.963]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:58.963]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:58.963]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:58.963]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:58.963]             base::names(...future.oldOptions))
[13:21:58.963]     }
[13:21:58.963]     if (FALSE) {
[13:21:58.963]     }
[13:21:58.963]     else {
[13:21:58.963]         if (TRUE) {
[13:21:58.963]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:58.963]                 open = "w")
[13:21:58.963]         }
[13:21:58.963]         else {
[13:21:58.963]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:58.963]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:58.963]         }
[13:21:58.963]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:58.963]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:58.963]             base::sink(type = "output", split = FALSE)
[13:21:58.963]             base::close(...future.stdout)
[13:21:58.963]         }, add = TRUE)
[13:21:58.963]     }
[13:21:58.963]     ...future.frame <- base::sys.nframe()
[13:21:58.963]     ...future.conditions <- base::list()
[13:21:58.963]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:58.963]     if (FALSE) {
[13:21:58.963]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:58.963]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:58.963]     }
[13:21:58.963]     ...future.result <- base::tryCatch({
[13:21:58.963]         base::withCallingHandlers({
[13:21:58.963]             ...future.value <- base::withVisible(base::local({
[13:21:58.963]                 ...future.makeSendCondition <- local({
[13:21:58.963]                   sendCondition <- NULL
[13:21:58.963]                   function(frame = 1L) {
[13:21:58.963]                     if (is.function(sendCondition)) 
[13:21:58.963]                       return(sendCondition)
[13:21:58.963]                     ns <- getNamespace("parallel")
[13:21:58.963]                     if (exists("sendData", mode = "function", 
[13:21:58.963]                       envir = ns)) {
[13:21:58.963]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:58.963]                         envir = ns)
[13:21:58.963]                       envir <- sys.frame(frame)
[13:21:58.963]                       master <- NULL
[13:21:58.963]                       while (!identical(envir, .GlobalEnv) && 
[13:21:58.963]                         !identical(envir, emptyenv())) {
[13:21:58.963]                         if (exists("master", mode = "list", envir = envir, 
[13:21:58.963]                           inherits = FALSE)) {
[13:21:58.963]                           master <- get("master", mode = "list", 
[13:21:58.963]                             envir = envir, inherits = FALSE)
[13:21:58.963]                           if (inherits(master, c("SOCKnode", 
[13:21:58.963]                             "SOCK0node"))) {
[13:21:58.963]                             sendCondition <<- function(cond) {
[13:21:58.963]                               data <- list(type = "VALUE", value = cond, 
[13:21:58.963]                                 success = TRUE)
[13:21:58.963]                               parallel_sendData(master, data)
[13:21:58.963]                             }
[13:21:58.963]                             return(sendCondition)
[13:21:58.963]                           }
[13:21:58.963]                         }
[13:21:58.963]                         frame <- frame + 1L
[13:21:58.963]                         envir <- sys.frame(frame)
[13:21:58.963]                       }
[13:21:58.963]                     }
[13:21:58.963]                     sendCondition <<- function(cond) NULL
[13:21:58.963]                   }
[13:21:58.963]                 })
[13:21:58.963]                 withCallingHandlers({
[13:21:58.963]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:21:58.963]                 }, immediateCondition = function(cond) {
[13:21:58.963]                   sendCondition <- ...future.makeSendCondition()
[13:21:58.963]                   sendCondition(cond)
[13:21:58.963]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:58.963]                   {
[13:21:58.963]                     inherits <- base::inherits
[13:21:58.963]                     invokeRestart <- base::invokeRestart
[13:21:58.963]                     is.null <- base::is.null
[13:21:58.963]                     muffled <- FALSE
[13:21:58.963]                     if (inherits(cond, "message")) {
[13:21:58.963]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:58.963]                       if (muffled) 
[13:21:58.963]                         invokeRestart("muffleMessage")
[13:21:58.963]                     }
[13:21:58.963]                     else if (inherits(cond, "warning")) {
[13:21:58.963]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:58.963]                       if (muffled) 
[13:21:58.963]                         invokeRestart("muffleWarning")
[13:21:58.963]                     }
[13:21:58.963]                     else if (inherits(cond, "condition")) {
[13:21:58.963]                       if (!is.null(pattern)) {
[13:21:58.963]                         computeRestarts <- base::computeRestarts
[13:21:58.963]                         grepl <- base::grepl
[13:21:58.963]                         restarts <- computeRestarts(cond)
[13:21:58.963]                         for (restart in restarts) {
[13:21:58.963]                           name <- restart$name
[13:21:58.963]                           if (is.null(name)) 
[13:21:58.963]                             next
[13:21:58.963]                           if (!grepl(pattern, name)) 
[13:21:58.963]                             next
[13:21:58.963]                           invokeRestart(restart)
[13:21:58.963]                           muffled <- TRUE
[13:21:58.963]                           break
[13:21:58.963]                         }
[13:21:58.963]                       }
[13:21:58.963]                     }
[13:21:58.963]                     invisible(muffled)
[13:21:58.963]                   }
[13:21:58.963]                   muffleCondition(cond)
[13:21:58.963]                 })
[13:21:58.963]             }))
[13:21:58.963]             future::FutureResult(value = ...future.value$value, 
[13:21:58.963]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:58.963]                   ...future.rng), globalenv = if (FALSE) 
[13:21:58.963]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:58.963]                     ...future.globalenv.names))
[13:21:58.963]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:58.963]         }, condition = base::local({
[13:21:58.963]             c <- base::c
[13:21:58.963]             inherits <- base::inherits
[13:21:58.963]             invokeRestart <- base::invokeRestart
[13:21:58.963]             length <- base::length
[13:21:58.963]             list <- base::list
[13:21:58.963]             seq.int <- base::seq.int
[13:21:58.963]             signalCondition <- base::signalCondition
[13:21:58.963]             sys.calls <- base::sys.calls
[13:21:58.963]             `[[` <- base::`[[`
[13:21:58.963]             `+` <- base::`+`
[13:21:58.963]             `<<-` <- base::`<<-`
[13:21:58.963]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:58.963]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:58.963]                   3L)]
[13:21:58.963]             }
[13:21:58.963]             function(cond) {
[13:21:58.963]                 is_error <- inherits(cond, "error")
[13:21:58.963]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:58.963]                   NULL)
[13:21:58.963]                 if (is_error) {
[13:21:58.963]                   sessionInformation <- function() {
[13:21:58.963]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:58.963]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:58.963]                       search = base::search(), system = base::Sys.info())
[13:21:58.963]                   }
[13:21:58.963]                   ...future.conditions[[length(...future.conditions) + 
[13:21:58.963]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:58.963]                     cond$call), session = sessionInformation(), 
[13:21:58.963]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:58.963]                   signalCondition(cond)
[13:21:58.963]                 }
[13:21:58.963]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:58.963]                 "immediateCondition"))) {
[13:21:58.963]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:58.963]                   ...future.conditions[[length(...future.conditions) + 
[13:21:58.963]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:58.963]                   if (TRUE && !signal) {
[13:21:58.963]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:58.963]                     {
[13:21:58.963]                       inherits <- base::inherits
[13:21:58.963]                       invokeRestart <- base::invokeRestart
[13:21:58.963]                       is.null <- base::is.null
[13:21:58.963]                       muffled <- FALSE
[13:21:58.963]                       if (inherits(cond, "message")) {
[13:21:58.963]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:58.963]                         if (muffled) 
[13:21:58.963]                           invokeRestart("muffleMessage")
[13:21:58.963]                       }
[13:21:58.963]                       else if (inherits(cond, "warning")) {
[13:21:58.963]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:58.963]                         if (muffled) 
[13:21:58.963]                           invokeRestart("muffleWarning")
[13:21:58.963]                       }
[13:21:58.963]                       else if (inherits(cond, "condition")) {
[13:21:58.963]                         if (!is.null(pattern)) {
[13:21:58.963]                           computeRestarts <- base::computeRestarts
[13:21:58.963]                           grepl <- base::grepl
[13:21:58.963]                           restarts <- computeRestarts(cond)
[13:21:58.963]                           for (restart in restarts) {
[13:21:58.963]                             name <- restart$name
[13:21:58.963]                             if (is.null(name)) 
[13:21:58.963]                               next
[13:21:58.963]                             if (!grepl(pattern, name)) 
[13:21:58.963]                               next
[13:21:58.963]                             invokeRestart(restart)
[13:21:58.963]                             muffled <- TRUE
[13:21:58.963]                             break
[13:21:58.963]                           }
[13:21:58.963]                         }
[13:21:58.963]                       }
[13:21:58.963]                       invisible(muffled)
[13:21:58.963]                     }
[13:21:58.963]                     muffleCondition(cond, pattern = "^muffle")
[13:21:58.963]                   }
[13:21:58.963]                 }
[13:21:58.963]                 else {
[13:21:58.963]                   if (TRUE) {
[13:21:58.963]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:58.963]                     {
[13:21:58.963]                       inherits <- base::inherits
[13:21:58.963]                       invokeRestart <- base::invokeRestart
[13:21:58.963]                       is.null <- base::is.null
[13:21:58.963]                       muffled <- FALSE
[13:21:58.963]                       if (inherits(cond, "message")) {
[13:21:58.963]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:58.963]                         if (muffled) 
[13:21:58.963]                           invokeRestart("muffleMessage")
[13:21:58.963]                       }
[13:21:58.963]                       else if (inherits(cond, "warning")) {
[13:21:58.963]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:58.963]                         if (muffled) 
[13:21:58.963]                           invokeRestart("muffleWarning")
[13:21:58.963]                       }
[13:21:58.963]                       else if (inherits(cond, "condition")) {
[13:21:58.963]                         if (!is.null(pattern)) {
[13:21:58.963]                           computeRestarts <- base::computeRestarts
[13:21:58.963]                           grepl <- base::grepl
[13:21:58.963]                           restarts <- computeRestarts(cond)
[13:21:58.963]                           for (restart in restarts) {
[13:21:58.963]                             name <- restart$name
[13:21:58.963]                             if (is.null(name)) 
[13:21:58.963]                               next
[13:21:58.963]                             if (!grepl(pattern, name)) 
[13:21:58.963]                               next
[13:21:58.963]                             invokeRestart(restart)
[13:21:58.963]                             muffled <- TRUE
[13:21:58.963]                             break
[13:21:58.963]                           }
[13:21:58.963]                         }
[13:21:58.963]                       }
[13:21:58.963]                       invisible(muffled)
[13:21:58.963]                     }
[13:21:58.963]                     muffleCondition(cond, pattern = "^muffle")
[13:21:58.963]                   }
[13:21:58.963]                 }
[13:21:58.963]             }
[13:21:58.963]         }))
[13:21:58.963]     }, error = function(ex) {
[13:21:58.963]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:58.963]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:58.963]                 ...future.rng), started = ...future.startTime, 
[13:21:58.963]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:58.963]             version = "1.8"), class = "FutureResult")
[13:21:58.963]     }, finally = {
[13:21:58.963]         if (!identical(...future.workdir, getwd())) 
[13:21:58.963]             setwd(...future.workdir)
[13:21:58.963]         {
[13:21:58.963]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:58.963]                 ...future.oldOptions$nwarnings <- NULL
[13:21:58.963]             }
[13:21:58.963]             base::options(...future.oldOptions)
[13:21:58.963]             if (.Platform$OS.type == "windows") {
[13:21:58.963]                 old_names <- names(...future.oldEnvVars)
[13:21:58.963]                 envs <- base::Sys.getenv()
[13:21:58.963]                 names <- names(envs)
[13:21:58.963]                 common <- intersect(names, old_names)
[13:21:58.963]                 added <- setdiff(names, old_names)
[13:21:58.963]                 removed <- setdiff(old_names, names)
[13:21:58.963]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:58.963]                   envs[common]]
[13:21:58.963]                 NAMES <- toupper(changed)
[13:21:58.963]                 args <- list()
[13:21:58.963]                 for (kk in seq_along(NAMES)) {
[13:21:58.963]                   name <- changed[[kk]]
[13:21:58.963]                   NAME <- NAMES[[kk]]
[13:21:58.963]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:58.963]                     next
[13:21:58.963]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:58.963]                 }
[13:21:58.963]                 NAMES <- toupper(added)
[13:21:58.963]                 for (kk in seq_along(NAMES)) {
[13:21:58.963]                   name <- added[[kk]]
[13:21:58.963]                   NAME <- NAMES[[kk]]
[13:21:58.963]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:58.963]                     next
[13:21:58.963]                   args[[name]] <- ""
[13:21:58.963]                 }
[13:21:58.963]                 NAMES <- toupper(removed)
[13:21:58.963]                 for (kk in seq_along(NAMES)) {
[13:21:58.963]                   name <- removed[[kk]]
[13:21:58.963]                   NAME <- NAMES[[kk]]
[13:21:58.963]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:58.963]                     next
[13:21:58.963]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:58.963]                 }
[13:21:58.963]                 if (length(args) > 0) 
[13:21:58.963]                   base::do.call(base::Sys.setenv, args = args)
[13:21:58.963]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:58.963]             }
[13:21:58.963]             else {
[13:21:58.963]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:58.963]             }
[13:21:58.963]             {
[13:21:58.963]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:58.963]                   0L) {
[13:21:58.963]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:58.963]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:58.963]                   base::options(opts)
[13:21:58.963]                 }
[13:21:58.963]                 {
[13:21:58.963]                   {
[13:21:58.963]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:58.963]                     NULL
[13:21:58.963]                   }
[13:21:58.963]                   options(future.plan = NULL)
[13:21:58.963]                   if (is.na(NA_character_)) 
[13:21:58.963]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:58.963]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:58.963]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:58.963]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:58.963]                     envir = parent.frame()) 
[13:21:58.963]                   {
[13:21:58.963]                     if (is.function(workers)) 
[13:21:58.963]                       workers <- workers()
[13:21:58.963]                     workers <- structure(as.integer(workers), 
[13:21:58.963]                       class = class(workers))
[13:21:58.963]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:58.963]                       workers >= 1)
[13:21:58.963]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:58.963]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:58.963]                     }
[13:21:58.963]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:58.963]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:58.963]                       envir = envir)
[13:21:58.963]                     if (!future$lazy) 
[13:21:58.963]                       future <- run(future)
[13:21:58.963]                     invisible(future)
[13:21:58.963]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:58.963]                 }
[13:21:58.963]             }
[13:21:58.963]         }
[13:21:58.963]     })
[13:21:58.963]     if (TRUE) {
[13:21:58.963]         base::sink(type = "output", split = FALSE)
[13:21:58.963]         if (TRUE) {
[13:21:58.963]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:58.963]         }
[13:21:58.963]         else {
[13:21:58.963]             ...future.result["stdout"] <- base::list(NULL)
[13:21:58.963]         }
[13:21:58.963]         base::close(...future.stdout)
[13:21:58.963]         ...future.stdout <- NULL
[13:21:58.963]     }
[13:21:58.963]     ...future.result$conditions <- ...future.conditions
[13:21:58.963]     ...future.result$finished <- base::Sys.time()
[13:21:58.963]     ...future.result
[13:21:58.963] }
[13:21:58.967] MultisessionFuture started
[13:21:58.967] - Launch lazy future ... done
[13:21:58.967] run() for ‘MultisessionFuture’ ... done
[13:21:59.014] receiveMessageFromWorker() for ClusterFuture ...
[13:21:59.014] - Validating connection of MultisessionFuture
[13:21:59.014] - received message: FutureResult
[13:21:59.015] - Received FutureResult
[13:21:59.015] - Erased future from FutureRegistry
[13:21:59.015] result() for ClusterFuture ...
[13:21:59.015] - result already collected: FutureResult
[13:21:59.015] result() for ClusterFuture ... done
[13:21:59.015] signalConditions() ...
[13:21:59.015]  - include = ‘immediateCondition’
[13:21:59.015]  - exclude = 
[13:21:59.015]  - resignal = FALSE
[13:21:59.015]  - Number of conditions: 1
[13:21:59.015] signalConditions() ... done
[13:21:59.016] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:59.016] A MultisessionFuture was resolved
[13:21:59.016] getGlobalsAndPackages() ...
[13:21:59.016] Searching for globals...
[13:21:59.016] - globals found: [2] ‘list’, ‘stop’
[13:21:59.017] Searching for globals ... DONE
[13:21:59.017] Resolving globals: FALSE
[13:21:59.017] 
[13:21:59.017] 
[13:21:59.017] getGlobalsAndPackages() ... DONE
[13:21:59.018] run() for ‘Future’ ...
[13:21:59.018] - state: ‘created’
[13:21:59.018] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:59.032] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:59.032] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:59.032]   - Field: ‘node’
[13:21:59.033]   - Field: ‘label’
[13:21:59.033]   - Field: ‘local’
[13:21:59.033]   - Field: ‘owner’
[13:21:59.033]   - Field: ‘envir’
[13:21:59.033]   - Field: ‘workers’
[13:21:59.033]   - Field: ‘packages’
[13:21:59.033]   - Field: ‘gc’
[13:21:59.033]   - Field: ‘conditions’
[13:21:59.033]   - Field: ‘persistent’
[13:21:59.033]   - Field: ‘expr’
[13:21:59.034]   - Field: ‘uuid’
[13:21:59.034]   - Field: ‘seed’
[13:21:59.034]   - Field: ‘version’
[13:21:59.034]   - Field: ‘result’
[13:21:59.034]   - Field: ‘asynchronous’
[13:21:59.034]   - Field: ‘calls’
[13:21:59.034]   - Field: ‘globals’
[13:21:59.034]   - Field: ‘stdout’
[13:21:59.034]   - Field: ‘earlySignal’
[13:21:59.034]   - Field: ‘lazy’
[13:21:59.034]   - Field: ‘state’
[13:21:59.035] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:59.035] - Launch lazy future ...
[13:21:59.035] Packages needed by the future expression (n = 0): <none>
[13:21:59.035] Packages needed by future strategies (n = 0): <none>
[13:21:59.035] {
[13:21:59.035]     {
[13:21:59.035]         {
[13:21:59.035]             ...future.startTime <- base::Sys.time()
[13:21:59.035]             {
[13:21:59.035]                 {
[13:21:59.035]                   {
[13:21:59.035]                     {
[13:21:59.035]                       base::local({
[13:21:59.035]                         has_future <- base::requireNamespace("future", 
[13:21:59.035]                           quietly = TRUE)
[13:21:59.035]                         if (has_future) {
[13:21:59.035]                           ns <- base::getNamespace("future")
[13:21:59.035]                           version <- ns[[".package"]][["version"]]
[13:21:59.035]                           if (is.null(version)) 
[13:21:59.035]                             version <- utils::packageVersion("future")
[13:21:59.035]                         }
[13:21:59.035]                         else {
[13:21:59.035]                           version <- NULL
[13:21:59.035]                         }
[13:21:59.035]                         if (!has_future || version < "1.8.0") {
[13:21:59.035]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:59.035]                             "", base::R.version$version.string), 
[13:21:59.035]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:59.035]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:59.035]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:59.035]                               "release", "version")], collapse = " "), 
[13:21:59.035]                             hostname = base::Sys.info()[["nodename"]])
[13:21:59.035]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:59.035]                             info)
[13:21:59.035]                           info <- base::paste(info, collapse = "; ")
[13:21:59.035]                           if (!has_future) {
[13:21:59.035]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:59.035]                               info)
[13:21:59.035]                           }
[13:21:59.035]                           else {
[13:21:59.035]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:59.035]                               info, version)
[13:21:59.035]                           }
[13:21:59.035]                           base::stop(msg)
[13:21:59.035]                         }
[13:21:59.035]                       })
[13:21:59.035]                     }
[13:21:59.035]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:59.035]                     base::options(mc.cores = 1L)
[13:21:59.035]                   }
[13:21:59.035]                   options(future.plan = NULL)
[13:21:59.035]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:59.035]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:59.035]                 }
[13:21:59.035]                 ...future.workdir <- getwd()
[13:21:59.035]             }
[13:21:59.035]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:59.035]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:59.035]         }
[13:21:59.035]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:59.035]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:59.035]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:59.035]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:59.035]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:59.035]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:59.035]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:59.035]             base::names(...future.oldOptions))
[13:21:59.035]     }
[13:21:59.035]     if (FALSE) {
[13:21:59.035]     }
[13:21:59.035]     else {
[13:21:59.035]         if (TRUE) {
[13:21:59.035]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:59.035]                 open = "w")
[13:21:59.035]         }
[13:21:59.035]         else {
[13:21:59.035]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:59.035]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:59.035]         }
[13:21:59.035]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:59.035]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:59.035]             base::sink(type = "output", split = FALSE)
[13:21:59.035]             base::close(...future.stdout)
[13:21:59.035]         }, add = TRUE)
[13:21:59.035]     }
[13:21:59.035]     ...future.frame <- base::sys.nframe()
[13:21:59.035]     ...future.conditions <- base::list()
[13:21:59.035]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:59.035]     if (FALSE) {
[13:21:59.035]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:59.035]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:59.035]     }
[13:21:59.035]     ...future.result <- base::tryCatch({
[13:21:59.035]         base::withCallingHandlers({
[13:21:59.035]             ...future.value <- base::withVisible(base::local({
[13:21:59.035]                 ...future.makeSendCondition <- local({
[13:21:59.035]                   sendCondition <- NULL
[13:21:59.035]                   function(frame = 1L) {
[13:21:59.035]                     if (is.function(sendCondition)) 
[13:21:59.035]                       return(sendCondition)
[13:21:59.035]                     ns <- getNamespace("parallel")
[13:21:59.035]                     if (exists("sendData", mode = "function", 
[13:21:59.035]                       envir = ns)) {
[13:21:59.035]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:59.035]                         envir = ns)
[13:21:59.035]                       envir <- sys.frame(frame)
[13:21:59.035]                       master <- NULL
[13:21:59.035]                       while (!identical(envir, .GlobalEnv) && 
[13:21:59.035]                         !identical(envir, emptyenv())) {
[13:21:59.035]                         if (exists("master", mode = "list", envir = envir, 
[13:21:59.035]                           inherits = FALSE)) {
[13:21:59.035]                           master <- get("master", mode = "list", 
[13:21:59.035]                             envir = envir, inherits = FALSE)
[13:21:59.035]                           if (inherits(master, c("SOCKnode", 
[13:21:59.035]                             "SOCK0node"))) {
[13:21:59.035]                             sendCondition <<- function(cond) {
[13:21:59.035]                               data <- list(type = "VALUE", value = cond, 
[13:21:59.035]                                 success = TRUE)
[13:21:59.035]                               parallel_sendData(master, data)
[13:21:59.035]                             }
[13:21:59.035]                             return(sendCondition)
[13:21:59.035]                           }
[13:21:59.035]                         }
[13:21:59.035]                         frame <- frame + 1L
[13:21:59.035]                         envir <- sys.frame(frame)
[13:21:59.035]                       }
[13:21:59.035]                     }
[13:21:59.035]                     sendCondition <<- function(cond) NULL
[13:21:59.035]                   }
[13:21:59.035]                 })
[13:21:59.035]                 withCallingHandlers({
[13:21:59.035]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:21:59.035]                 }, immediateCondition = function(cond) {
[13:21:59.035]                   sendCondition <- ...future.makeSendCondition()
[13:21:59.035]                   sendCondition(cond)
[13:21:59.035]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:59.035]                   {
[13:21:59.035]                     inherits <- base::inherits
[13:21:59.035]                     invokeRestart <- base::invokeRestart
[13:21:59.035]                     is.null <- base::is.null
[13:21:59.035]                     muffled <- FALSE
[13:21:59.035]                     if (inherits(cond, "message")) {
[13:21:59.035]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:59.035]                       if (muffled) 
[13:21:59.035]                         invokeRestart("muffleMessage")
[13:21:59.035]                     }
[13:21:59.035]                     else if (inherits(cond, "warning")) {
[13:21:59.035]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:59.035]                       if (muffled) 
[13:21:59.035]                         invokeRestart("muffleWarning")
[13:21:59.035]                     }
[13:21:59.035]                     else if (inherits(cond, "condition")) {
[13:21:59.035]                       if (!is.null(pattern)) {
[13:21:59.035]                         computeRestarts <- base::computeRestarts
[13:21:59.035]                         grepl <- base::grepl
[13:21:59.035]                         restarts <- computeRestarts(cond)
[13:21:59.035]                         for (restart in restarts) {
[13:21:59.035]                           name <- restart$name
[13:21:59.035]                           if (is.null(name)) 
[13:21:59.035]                             next
[13:21:59.035]                           if (!grepl(pattern, name)) 
[13:21:59.035]                             next
[13:21:59.035]                           invokeRestart(restart)
[13:21:59.035]                           muffled <- TRUE
[13:21:59.035]                           break
[13:21:59.035]                         }
[13:21:59.035]                       }
[13:21:59.035]                     }
[13:21:59.035]                     invisible(muffled)
[13:21:59.035]                   }
[13:21:59.035]                   muffleCondition(cond)
[13:21:59.035]                 })
[13:21:59.035]             }))
[13:21:59.035]             future::FutureResult(value = ...future.value$value, 
[13:21:59.035]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:59.035]                   ...future.rng), globalenv = if (FALSE) 
[13:21:59.035]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:59.035]                     ...future.globalenv.names))
[13:21:59.035]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:59.035]         }, condition = base::local({
[13:21:59.035]             c <- base::c
[13:21:59.035]             inherits <- base::inherits
[13:21:59.035]             invokeRestart <- base::invokeRestart
[13:21:59.035]             length <- base::length
[13:21:59.035]             list <- base::list
[13:21:59.035]             seq.int <- base::seq.int
[13:21:59.035]             signalCondition <- base::signalCondition
[13:21:59.035]             sys.calls <- base::sys.calls
[13:21:59.035]             `[[` <- base::`[[`
[13:21:59.035]             `+` <- base::`+`
[13:21:59.035]             `<<-` <- base::`<<-`
[13:21:59.035]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:59.035]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:59.035]                   3L)]
[13:21:59.035]             }
[13:21:59.035]             function(cond) {
[13:21:59.035]                 is_error <- inherits(cond, "error")
[13:21:59.035]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:59.035]                   NULL)
[13:21:59.035]                 if (is_error) {
[13:21:59.035]                   sessionInformation <- function() {
[13:21:59.035]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:59.035]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:59.035]                       search = base::search(), system = base::Sys.info())
[13:21:59.035]                   }
[13:21:59.035]                   ...future.conditions[[length(...future.conditions) + 
[13:21:59.035]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:59.035]                     cond$call), session = sessionInformation(), 
[13:21:59.035]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:59.035]                   signalCondition(cond)
[13:21:59.035]                 }
[13:21:59.035]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:59.035]                 "immediateCondition"))) {
[13:21:59.035]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:59.035]                   ...future.conditions[[length(...future.conditions) + 
[13:21:59.035]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:59.035]                   if (TRUE && !signal) {
[13:21:59.035]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:59.035]                     {
[13:21:59.035]                       inherits <- base::inherits
[13:21:59.035]                       invokeRestart <- base::invokeRestart
[13:21:59.035]                       is.null <- base::is.null
[13:21:59.035]                       muffled <- FALSE
[13:21:59.035]                       if (inherits(cond, "message")) {
[13:21:59.035]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:59.035]                         if (muffled) 
[13:21:59.035]                           invokeRestart("muffleMessage")
[13:21:59.035]                       }
[13:21:59.035]                       else if (inherits(cond, "warning")) {
[13:21:59.035]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:59.035]                         if (muffled) 
[13:21:59.035]                           invokeRestart("muffleWarning")
[13:21:59.035]                       }
[13:21:59.035]                       else if (inherits(cond, "condition")) {
[13:21:59.035]                         if (!is.null(pattern)) {
[13:21:59.035]                           computeRestarts <- base::computeRestarts
[13:21:59.035]                           grepl <- base::grepl
[13:21:59.035]                           restarts <- computeRestarts(cond)
[13:21:59.035]                           for (restart in restarts) {
[13:21:59.035]                             name <- restart$name
[13:21:59.035]                             if (is.null(name)) 
[13:21:59.035]                               next
[13:21:59.035]                             if (!grepl(pattern, name)) 
[13:21:59.035]                               next
[13:21:59.035]                             invokeRestart(restart)
[13:21:59.035]                             muffled <- TRUE
[13:21:59.035]                             break
[13:21:59.035]                           }
[13:21:59.035]                         }
[13:21:59.035]                       }
[13:21:59.035]                       invisible(muffled)
[13:21:59.035]                     }
[13:21:59.035]                     muffleCondition(cond, pattern = "^muffle")
[13:21:59.035]                   }
[13:21:59.035]                 }
[13:21:59.035]                 else {
[13:21:59.035]                   if (TRUE) {
[13:21:59.035]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:59.035]                     {
[13:21:59.035]                       inherits <- base::inherits
[13:21:59.035]                       invokeRestart <- base::invokeRestart
[13:21:59.035]                       is.null <- base::is.null
[13:21:59.035]                       muffled <- FALSE
[13:21:59.035]                       if (inherits(cond, "message")) {
[13:21:59.035]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:59.035]                         if (muffled) 
[13:21:59.035]                           invokeRestart("muffleMessage")
[13:21:59.035]                       }
[13:21:59.035]                       else if (inherits(cond, "warning")) {
[13:21:59.035]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:59.035]                         if (muffled) 
[13:21:59.035]                           invokeRestart("muffleWarning")
[13:21:59.035]                       }
[13:21:59.035]                       else if (inherits(cond, "condition")) {
[13:21:59.035]                         if (!is.null(pattern)) {
[13:21:59.035]                           computeRestarts <- base::computeRestarts
[13:21:59.035]                           grepl <- base::grepl
[13:21:59.035]                           restarts <- computeRestarts(cond)
[13:21:59.035]                           for (restart in restarts) {
[13:21:59.035]                             name <- restart$name
[13:21:59.035]                             if (is.null(name)) 
[13:21:59.035]                               next
[13:21:59.035]                             if (!grepl(pattern, name)) 
[13:21:59.035]                               next
[13:21:59.035]                             invokeRestart(restart)
[13:21:59.035]                             muffled <- TRUE
[13:21:59.035]                             break
[13:21:59.035]                           }
[13:21:59.035]                         }
[13:21:59.035]                       }
[13:21:59.035]                       invisible(muffled)
[13:21:59.035]                     }
[13:21:59.035]                     muffleCondition(cond, pattern = "^muffle")
[13:21:59.035]                   }
[13:21:59.035]                 }
[13:21:59.035]             }
[13:21:59.035]         }))
[13:21:59.035]     }, error = function(ex) {
[13:21:59.035]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:59.035]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:59.035]                 ...future.rng), started = ...future.startTime, 
[13:21:59.035]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:59.035]             version = "1.8"), class = "FutureResult")
[13:21:59.035]     }, finally = {
[13:21:59.035]         if (!identical(...future.workdir, getwd())) 
[13:21:59.035]             setwd(...future.workdir)
[13:21:59.035]         {
[13:21:59.035]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:59.035]                 ...future.oldOptions$nwarnings <- NULL
[13:21:59.035]             }
[13:21:59.035]             base::options(...future.oldOptions)
[13:21:59.035]             if (.Platform$OS.type == "windows") {
[13:21:59.035]                 old_names <- names(...future.oldEnvVars)
[13:21:59.035]                 envs <- base::Sys.getenv()
[13:21:59.035]                 names <- names(envs)
[13:21:59.035]                 common <- intersect(names, old_names)
[13:21:59.035]                 added <- setdiff(names, old_names)
[13:21:59.035]                 removed <- setdiff(old_names, names)
[13:21:59.035]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:59.035]                   envs[common]]
[13:21:59.035]                 NAMES <- toupper(changed)
[13:21:59.035]                 args <- list()
[13:21:59.035]                 for (kk in seq_along(NAMES)) {
[13:21:59.035]                   name <- changed[[kk]]
[13:21:59.035]                   NAME <- NAMES[[kk]]
[13:21:59.035]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:59.035]                     next
[13:21:59.035]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:59.035]                 }
[13:21:59.035]                 NAMES <- toupper(added)
[13:21:59.035]                 for (kk in seq_along(NAMES)) {
[13:21:59.035]                   name <- added[[kk]]
[13:21:59.035]                   NAME <- NAMES[[kk]]
[13:21:59.035]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:59.035]                     next
[13:21:59.035]                   args[[name]] <- ""
[13:21:59.035]                 }
[13:21:59.035]                 NAMES <- toupper(removed)
[13:21:59.035]                 for (kk in seq_along(NAMES)) {
[13:21:59.035]                   name <- removed[[kk]]
[13:21:59.035]                   NAME <- NAMES[[kk]]
[13:21:59.035]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:59.035]                     next
[13:21:59.035]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:59.035]                 }
[13:21:59.035]                 if (length(args) > 0) 
[13:21:59.035]                   base::do.call(base::Sys.setenv, args = args)
[13:21:59.035]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:59.035]             }
[13:21:59.035]             else {
[13:21:59.035]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:59.035]             }
[13:21:59.035]             {
[13:21:59.035]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:59.035]                   0L) {
[13:21:59.035]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:59.035]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:59.035]                   base::options(opts)
[13:21:59.035]                 }
[13:21:59.035]                 {
[13:21:59.035]                   {
[13:21:59.035]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:59.035]                     NULL
[13:21:59.035]                   }
[13:21:59.035]                   options(future.plan = NULL)
[13:21:59.035]                   if (is.na(NA_character_)) 
[13:21:59.035]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:59.035]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:59.035]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:59.035]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:59.035]                     envir = parent.frame()) 
[13:21:59.035]                   {
[13:21:59.035]                     if (is.function(workers)) 
[13:21:59.035]                       workers <- workers()
[13:21:59.035]                     workers <- structure(as.integer(workers), 
[13:21:59.035]                       class = class(workers))
[13:21:59.035]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:59.035]                       workers >= 1)
[13:21:59.035]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:59.035]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:59.035]                     }
[13:21:59.035]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:59.035]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:59.035]                       envir = envir)
[13:21:59.035]                     if (!future$lazy) 
[13:21:59.035]                       future <- run(future)
[13:21:59.035]                     invisible(future)
[13:21:59.035]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:59.035]                 }
[13:21:59.035]             }
[13:21:59.035]         }
[13:21:59.035]     })
[13:21:59.035]     if (TRUE) {
[13:21:59.035]         base::sink(type = "output", split = FALSE)
[13:21:59.035]         if (TRUE) {
[13:21:59.035]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:59.035]         }
[13:21:59.035]         else {
[13:21:59.035]             ...future.result["stdout"] <- base::list(NULL)
[13:21:59.035]         }
[13:21:59.035]         base::close(...future.stdout)
[13:21:59.035]         ...future.stdout <- NULL
[13:21:59.035]     }
[13:21:59.035]     ...future.result$conditions <- ...future.conditions
[13:21:59.035]     ...future.result$finished <- base::Sys.time()
[13:21:59.035]     ...future.result
[13:21:59.035] }
[13:21:59.039] MultisessionFuture started
[13:21:59.039] - Launch lazy future ... done
[13:21:59.039] run() for ‘MultisessionFuture’ ... done
[13:21:59.090] receiveMessageFromWorker() for ClusterFuture ...
[13:21:59.090] - Validating connection of MultisessionFuture
[13:21:59.092] - received message: FutureResult
[13:21:59.092] - Received FutureResult
[13:21:59.092] - Erased future from FutureRegistry
[13:21:59.092] result() for ClusterFuture ...
[13:21:59.092] - result already collected: FutureResult
[13:21:59.092] result() for ClusterFuture ... done
[13:21:59.092] signalConditions() ...
[13:21:59.092]  - include = ‘immediateCondition’
[13:21:59.093]  - exclude = 
[13:21:59.093]  - resignal = FALSE
[13:21:59.093]  - Number of conditions: 1
[13:21:59.093] signalConditions() ... done
[13:21:59.093] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:59.093] A MultisessionFuture was resolved
- result = TRUE, recursive = Inf ... DONE
*** resolve() for Future objects ... DONE
*** resolve() for lists ...
[13:21:59.093] resolve() on list ...
[13:21:59.094]  recursive: 0
[13:21:59.094]  length: 2
[13:21:59.094]  elements: ‘a’, ‘b’
[13:21:59.094]  length: 1 (resolved future 1)
[13:21:59.094]  length: 0 (resolved future 2)
[13:21:59.094] resolve() on list ... DONE
[13:21:59.094] getGlobalsAndPackages() ...
[13:21:59.094] Searching for globals...
[13:21:59.095] 
[13:21:59.095] Searching for globals ... DONE
[13:21:59.095] - globals: [0] <none>
[13:21:59.095] getGlobalsAndPackages() ... DONE
[13:21:59.095] run() for ‘Future’ ...
[13:21:59.095] - state: ‘created’
[13:21:59.095] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:59.112] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:59.112] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:59.112]   - Field: ‘node’
[13:21:59.112]   - Field: ‘label’
[13:21:59.112]   - Field: ‘local’
[13:21:59.112]   - Field: ‘owner’
[13:21:59.112]   - Field: ‘envir’
[13:21:59.112]   - Field: ‘workers’
[13:21:59.112]   - Field: ‘packages’
[13:21:59.113]   - Field: ‘gc’
[13:21:59.113]   - Field: ‘conditions’
[13:21:59.113]   - Field: ‘persistent’
[13:21:59.113]   - Field: ‘expr’
[13:21:59.113]   - Field: ‘uuid’
[13:21:59.113]   - Field: ‘seed’
[13:21:59.113]   - Field: ‘version’
[13:21:59.113]   - Field: ‘result’
[13:21:59.113]   - Field: ‘asynchronous’
[13:21:59.114]   - Field: ‘calls’
[13:21:59.114]   - Field: ‘globals’
[13:21:59.114]   - Field: ‘stdout’
[13:21:59.114]   - Field: ‘earlySignal’
[13:21:59.114]   - Field: ‘lazy’
[13:21:59.114]   - Field: ‘state’
[13:21:59.114] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:59.114] - Launch lazy future ...
[13:21:59.114] Packages needed by the future expression (n = 0): <none>
[13:21:59.115] Packages needed by future strategies (n = 0): <none>
[13:21:59.115] {
[13:21:59.115]     {
[13:21:59.115]         {
[13:21:59.115]             ...future.startTime <- base::Sys.time()
[13:21:59.115]             {
[13:21:59.115]                 {
[13:21:59.115]                   {
[13:21:59.115]                     {
[13:21:59.115]                       base::local({
[13:21:59.115]                         has_future <- base::requireNamespace("future", 
[13:21:59.115]                           quietly = TRUE)
[13:21:59.115]                         if (has_future) {
[13:21:59.115]                           ns <- base::getNamespace("future")
[13:21:59.115]                           version <- ns[[".package"]][["version"]]
[13:21:59.115]                           if (is.null(version)) 
[13:21:59.115]                             version <- utils::packageVersion("future")
[13:21:59.115]                         }
[13:21:59.115]                         else {
[13:21:59.115]                           version <- NULL
[13:21:59.115]                         }
[13:21:59.115]                         if (!has_future || version < "1.8.0") {
[13:21:59.115]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:59.115]                             "", base::R.version$version.string), 
[13:21:59.115]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:59.115]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:59.115]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:59.115]                               "release", "version")], collapse = " "), 
[13:21:59.115]                             hostname = base::Sys.info()[["nodename"]])
[13:21:59.115]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:59.115]                             info)
[13:21:59.115]                           info <- base::paste(info, collapse = "; ")
[13:21:59.115]                           if (!has_future) {
[13:21:59.115]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:59.115]                               info)
[13:21:59.115]                           }
[13:21:59.115]                           else {
[13:21:59.115]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:59.115]                               info, version)
[13:21:59.115]                           }
[13:21:59.115]                           base::stop(msg)
[13:21:59.115]                         }
[13:21:59.115]                       })
[13:21:59.115]                     }
[13:21:59.115]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:59.115]                     base::options(mc.cores = 1L)
[13:21:59.115]                   }
[13:21:59.115]                   options(future.plan = NULL)
[13:21:59.115]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:59.115]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:59.115]                 }
[13:21:59.115]                 ...future.workdir <- getwd()
[13:21:59.115]             }
[13:21:59.115]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:59.115]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:59.115]         }
[13:21:59.115]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:59.115]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:59.115]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:59.115]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:59.115]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:59.115]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:59.115]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:59.115]             base::names(...future.oldOptions))
[13:21:59.115]     }
[13:21:59.115]     if (FALSE) {
[13:21:59.115]     }
[13:21:59.115]     else {
[13:21:59.115]         if (TRUE) {
[13:21:59.115]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:59.115]                 open = "w")
[13:21:59.115]         }
[13:21:59.115]         else {
[13:21:59.115]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:59.115]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:59.115]         }
[13:21:59.115]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:59.115]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:59.115]             base::sink(type = "output", split = FALSE)
[13:21:59.115]             base::close(...future.stdout)
[13:21:59.115]         }, add = TRUE)
[13:21:59.115]     }
[13:21:59.115]     ...future.frame <- base::sys.nframe()
[13:21:59.115]     ...future.conditions <- base::list()
[13:21:59.115]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:59.115]     if (FALSE) {
[13:21:59.115]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:59.115]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:59.115]     }
[13:21:59.115]     ...future.result <- base::tryCatch({
[13:21:59.115]         base::withCallingHandlers({
[13:21:59.115]             ...future.value <- base::withVisible(base::local({
[13:21:59.115]                 ...future.makeSendCondition <- local({
[13:21:59.115]                   sendCondition <- NULL
[13:21:59.115]                   function(frame = 1L) {
[13:21:59.115]                     if (is.function(sendCondition)) 
[13:21:59.115]                       return(sendCondition)
[13:21:59.115]                     ns <- getNamespace("parallel")
[13:21:59.115]                     if (exists("sendData", mode = "function", 
[13:21:59.115]                       envir = ns)) {
[13:21:59.115]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:59.115]                         envir = ns)
[13:21:59.115]                       envir <- sys.frame(frame)
[13:21:59.115]                       master <- NULL
[13:21:59.115]                       while (!identical(envir, .GlobalEnv) && 
[13:21:59.115]                         !identical(envir, emptyenv())) {
[13:21:59.115]                         if (exists("master", mode = "list", envir = envir, 
[13:21:59.115]                           inherits = FALSE)) {
[13:21:59.115]                           master <- get("master", mode = "list", 
[13:21:59.115]                             envir = envir, inherits = FALSE)
[13:21:59.115]                           if (inherits(master, c("SOCKnode", 
[13:21:59.115]                             "SOCK0node"))) {
[13:21:59.115]                             sendCondition <<- function(cond) {
[13:21:59.115]                               data <- list(type = "VALUE", value = cond, 
[13:21:59.115]                                 success = TRUE)
[13:21:59.115]                               parallel_sendData(master, data)
[13:21:59.115]                             }
[13:21:59.115]                             return(sendCondition)
[13:21:59.115]                           }
[13:21:59.115]                         }
[13:21:59.115]                         frame <- frame + 1L
[13:21:59.115]                         envir <- sys.frame(frame)
[13:21:59.115]                       }
[13:21:59.115]                     }
[13:21:59.115]                     sendCondition <<- function(cond) NULL
[13:21:59.115]                   }
[13:21:59.115]                 })
[13:21:59.115]                 withCallingHandlers({
[13:21:59.115]                   1
[13:21:59.115]                 }, immediateCondition = function(cond) {
[13:21:59.115]                   sendCondition <- ...future.makeSendCondition()
[13:21:59.115]                   sendCondition(cond)
[13:21:59.115]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:59.115]                   {
[13:21:59.115]                     inherits <- base::inherits
[13:21:59.115]                     invokeRestart <- base::invokeRestart
[13:21:59.115]                     is.null <- base::is.null
[13:21:59.115]                     muffled <- FALSE
[13:21:59.115]                     if (inherits(cond, "message")) {
[13:21:59.115]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:59.115]                       if (muffled) 
[13:21:59.115]                         invokeRestart("muffleMessage")
[13:21:59.115]                     }
[13:21:59.115]                     else if (inherits(cond, "warning")) {
[13:21:59.115]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:59.115]                       if (muffled) 
[13:21:59.115]                         invokeRestart("muffleWarning")
[13:21:59.115]                     }
[13:21:59.115]                     else if (inherits(cond, "condition")) {
[13:21:59.115]                       if (!is.null(pattern)) {
[13:21:59.115]                         computeRestarts <- base::computeRestarts
[13:21:59.115]                         grepl <- base::grepl
[13:21:59.115]                         restarts <- computeRestarts(cond)
[13:21:59.115]                         for (restart in restarts) {
[13:21:59.115]                           name <- restart$name
[13:21:59.115]                           if (is.null(name)) 
[13:21:59.115]                             next
[13:21:59.115]                           if (!grepl(pattern, name)) 
[13:21:59.115]                             next
[13:21:59.115]                           invokeRestart(restart)
[13:21:59.115]                           muffled <- TRUE
[13:21:59.115]                           break
[13:21:59.115]                         }
[13:21:59.115]                       }
[13:21:59.115]                     }
[13:21:59.115]                     invisible(muffled)
[13:21:59.115]                   }
[13:21:59.115]                   muffleCondition(cond)
[13:21:59.115]                 })
[13:21:59.115]             }))
[13:21:59.115]             future::FutureResult(value = ...future.value$value, 
[13:21:59.115]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:59.115]                   ...future.rng), globalenv = if (FALSE) 
[13:21:59.115]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:59.115]                     ...future.globalenv.names))
[13:21:59.115]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:59.115]         }, condition = base::local({
[13:21:59.115]             c <- base::c
[13:21:59.115]             inherits <- base::inherits
[13:21:59.115]             invokeRestart <- base::invokeRestart
[13:21:59.115]             length <- base::length
[13:21:59.115]             list <- base::list
[13:21:59.115]             seq.int <- base::seq.int
[13:21:59.115]             signalCondition <- base::signalCondition
[13:21:59.115]             sys.calls <- base::sys.calls
[13:21:59.115]             `[[` <- base::`[[`
[13:21:59.115]             `+` <- base::`+`
[13:21:59.115]             `<<-` <- base::`<<-`
[13:21:59.115]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:59.115]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:59.115]                   3L)]
[13:21:59.115]             }
[13:21:59.115]             function(cond) {
[13:21:59.115]                 is_error <- inherits(cond, "error")
[13:21:59.115]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:59.115]                   NULL)
[13:21:59.115]                 if (is_error) {
[13:21:59.115]                   sessionInformation <- function() {
[13:21:59.115]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:59.115]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:59.115]                       search = base::search(), system = base::Sys.info())
[13:21:59.115]                   }
[13:21:59.115]                   ...future.conditions[[length(...future.conditions) + 
[13:21:59.115]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:59.115]                     cond$call), session = sessionInformation(), 
[13:21:59.115]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:59.115]                   signalCondition(cond)
[13:21:59.115]                 }
[13:21:59.115]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:59.115]                 "immediateCondition"))) {
[13:21:59.115]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:59.115]                   ...future.conditions[[length(...future.conditions) + 
[13:21:59.115]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:59.115]                   if (TRUE && !signal) {
[13:21:59.115]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:59.115]                     {
[13:21:59.115]                       inherits <- base::inherits
[13:21:59.115]                       invokeRestart <- base::invokeRestart
[13:21:59.115]                       is.null <- base::is.null
[13:21:59.115]                       muffled <- FALSE
[13:21:59.115]                       if (inherits(cond, "message")) {
[13:21:59.115]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:59.115]                         if (muffled) 
[13:21:59.115]                           invokeRestart("muffleMessage")
[13:21:59.115]                       }
[13:21:59.115]                       else if (inherits(cond, "warning")) {
[13:21:59.115]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:59.115]                         if (muffled) 
[13:21:59.115]                           invokeRestart("muffleWarning")
[13:21:59.115]                       }
[13:21:59.115]                       else if (inherits(cond, "condition")) {
[13:21:59.115]                         if (!is.null(pattern)) {
[13:21:59.115]                           computeRestarts <- base::computeRestarts
[13:21:59.115]                           grepl <- base::grepl
[13:21:59.115]                           restarts <- computeRestarts(cond)
[13:21:59.115]                           for (restart in restarts) {
[13:21:59.115]                             name <- restart$name
[13:21:59.115]                             if (is.null(name)) 
[13:21:59.115]                               next
[13:21:59.115]                             if (!grepl(pattern, name)) 
[13:21:59.115]                               next
[13:21:59.115]                             invokeRestart(restart)
[13:21:59.115]                             muffled <- TRUE
[13:21:59.115]                             break
[13:21:59.115]                           }
[13:21:59.115]                         }
[13:21:59.115]                       }
[13:21:59.115]                       invisible(muffled)
[13:21:59.115]                     }
[13:21:59.115]                     muffleCondition(cond, pattern = "^muffle")
[13:21:59.115]                   }
[13:21:59.115]                 }
[13:21:59.115]                 else {
[13:21:59.115]                   if (TRUE) {
[13:21:59.115]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:59.115]                     {
[13:21:59.115]                       inherits <- base::inherits
[13:21:59.115]                       invokeRestart <- base::invokeRestart
[13:21:59.115]                       is.null <- base::is.null
[13:21:59.115]                       muffled <- FALSE
[13:21:59.115]                       if (inherits(cond, "message")) {
[13:21:59.115]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:59.115]                         if (muffled) 
[13:21:59.115]                           invokeRestart("muffleMessage")
[13:21:59.115]                       }
[13:21:59.115]                       else if (inherits(cond, "warning")) {
[13:21:59.115]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:59.115]                         if (muffled) 
[13:21:59.115]                           invokeRestart("muffleWarning")
[13:21:59.115]                       }
[13:21:59.115]                       else if (inherits(cond, "condition")) {
[13:21:59.115]                         if (!is.null(pattern)) {
[13:21:59.115]                           computeRestarts <- base::computeRestarts
[13:21:59.115]                           grepl <- base::grepl
[13:21:59.115]                           restarts <- computeRestarts(cond)
[13:21:59.115]                           for (restart in restarts) {
[13:21:59.115]                             name <- restart$name
[13:21:59.115]                             if (is.null(name)) 
[13:21:59.115]                               next
[13:21:59.115]                             if (!grepl(pattern, name)) 
[13:21:59.115]                               next
[13:21:59.115]                             invokeRestart(restart)
[13:21:59.115]                             muffled <- TRUE
[13:21:59.115]                             break
[13:21:59.115]                           }
[13:21:59.115]                         }
[13:21:59.115]                       }
[13:21:59.115]                       invisible(muffled)
[13:21:59.115]                     }
[13:21:59.115]                     muffleCondition(cond, pattern = "^muffle")
[13:21:59.115]                   }
[13:21:59.115]                 }
[13:21:59.115]             }
[13:21:59.115]         }))
[13:21:59.115]     }, error = function(ex) {
[13:21:59.115]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:59.115]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:59.115]                 ...future.rng), started = ...future.startTime, 
[13:21:59.115]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:59.115]             version = "1.8"), class = "FutureResult")
[13:21:59.115]     }, finally = {
[13:21:59.115]         if (!identical(...future.workdir, getwd())) 
[13:21:59.115]             setwd(...future.workdir)
[13:21:59.115]         {
[13:21:59.115]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:59.115]                 ...future.oldOptions$nwarnings <- NULL
[13:21:59.115]             }
[13:21:59.115]             base::options(...future.oldOptions)
[13:21:59.115]             if (.Platform$OS.type == "windows") {
[13:21:59.115]                 old_names <- names(...future.oldEnvVars)
[13:21:59.115]                 envs <- base::Sys.getenv()
[13:21:59.115]                 names <- names(envs)
[13:21:59.115]                 common <- intersect(names, old_names)
[13:21:59.115]                 added <- setdiff(names, old_names)
[13:21:59.115]                 removed <- setdiff(old_names, names)
[13:21:59.115]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:59.115]                   envs[common]]
[13:21:59.115]                 NAMES <- toupper(changed)
[13:21:59.115]                 args <- list()
[13:21:59.115]                 for (kk in seq_along(NAMES)) {
[13:21:59.115]                   name <- changed[[kk]]
[13:21:59.115]                   NAME <- NAMES[[kk]]
[13:21:59.115]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:59.115]                     next
[13:21:59.115]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:59.115]                 }
[13:21:59.115]                 NAMES <- toupper(added)
[13:21:59.115]                 for (kk in seq_along(NAMES)) {
[13:21:59.115]                   name <- added[[kk]]
[13:21:59.115]                   NAME <- NAMES[[kk]]
[13:21:59.115]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:59.115]                     next
[13:21:59.115]                   args[[name]] <- ""
[13:21:59.115]                 }
[13:21:59.115]                 NAMES <- toupper(removed)
[13:21:59.115]                 for (kk in seq_along(NAMES)) {
[13:21:59.115]                   name <- removed[[kk]]
[13:21:59.115]                   NAME <- NAMES[[kk]]
[13:21:59.115]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:59.115]                     next
[13:21:59.115]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:59.115]                 }
[13:21:59.115]                 if (length(args) > 0) 
[13:21:59.115]                   base::do.call(base::Sys.setenv, args = args)
[13:21:59.115]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:59.115]             }
[13:21:59.115]             else {
[13:21:59.115]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:59.115]             }
[13:21:59.115]             {
[13:21:59.115]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:59.115]                   0L) {
[13:21:59.115]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:59.115]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:59.115]                   base::options(opts)
[13:21:59.115]                 }
[13:21:59.115]                 {
[13:21:59.115]                   {
[13:21:59.115]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:59.115]                     NULL
[13:21:59.115]                   }
[13:21:59.115]                   options(future.plan = NULL)
[13:21:59.115]                   if (is.na(NA_character_)) 
[13:21:59.115]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:59.115]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:59.115]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:59.115]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:59.115]                     envir = parent.frame()) 
[13:21:59.115]                   {
[13:21:59.115]                     if (is.function(workers)) 
[13:21:59.115]                       workers <- workers()
[13:21:59.115]                     workers <- structure(as.integer(workers), 
[13:21:59.115]                       class = class(workers))
[13:21:59.115]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:59.115]                       workers >= 1)
[13:21:59.115]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:59.115]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:59.115]                     }
[13:21:59.115]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:59.115]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:59.115]                       envir = envir)
[13:21:59.115]                     if (!future$lazy) 
[13:21:59.115]                       future <- run(future)
[13:21:59.115]                     invisible(future)
[13:21:59.115]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:59.115]                 }
[13:21:59.115]             }
[13:21:59.115]         }
[13:21:59.115]     })
[13:21:59.115]     if (TRUE) {
[13:21:59.115]         base::sink(type = "output", split = FALSE)
[13:21:59.115]         if (TRUE) {
[13:21:59.115]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:59.115]         }
[13:21:59.115]         else {
[13:21:59.115]             ...future.result["stdout"] <- base::list(NULL)
[13:21:59.115]         }
[13:21:59.115]         base::close(...future.stdout)
[13:21:59.115]         ...future.stdout <- NULL
[13:21:59.115]     }
[13:21:59.115]     ...future.result$conditions <- ...future.conditions
[13:21:59.115]     ...future.result$finished <- base::Sys.time()
[13:21:59.115]     ...future.result
[13:21:59.115] }
[13:21:59.118] MultisessionFuture started
[13:21:59.118] - Launch lazy future ... done
[13:21:59.118] run() for ‘MultisessionFuture’ ... done
[13:21:59.118] getGlobalsAndPackages() ...
[13:21:59.119] Searching for globals...
[13:21:59.119] 
[13:21:59.119] Searching for globals ... DONE
[13:21:59.119] - globals: [0] <none>
[13:21:59.119] getGlobalsAndPackages() ... DONE
[13:21:59.119] run() for ‘Future’ ...
[13:21:59.119] - state: ‘created’
[13:21:59.120] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:59.133] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:59.134] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:59.134]   - Field: ‘node’
[13:21:59.134]   - Field: ‘label’
[13:21:59.134]   - Field: ‘local’
[13:21:59.134]   - Field: ‘owner’
[13:21:59.134]   - Field: ‘envir’
[13:21:59.134]   - Field: ‘workers’
[13:21:59.134]   - Field: ‘packages’
[13:21:59.134]   - Field: ‘gc’
[13:21:59.134]   - Field: ‘conditions’
[13:21:59.135]   - Field: ‘persistent’
[13:21:59.135]   - Field: ‘expr’
[13:21:59.135]   - Field: ‘uuid’
[13:21:59.135]   - Field: ‘seed’
[13:21:59.135]   - Field: ‘version’
[13:21:59.135]   - Field: ‘result’
[13:21:59.135]   - Field: ‘asynchronous’
[13:21:59.135]   - Field: ‘calls’
[13:21:59.135]   - Field: ‘globals’
[13:21:59.135]   - Field: ‘stdout’
[13:21:59.135]   - Field: ‘earlySignal’
[13:21:59.136]   - Field: ‘lazy’
[13:21:59.136]   - Field: ‘state’
[13:21:59.136] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:59.136] - Launch lazy future ...
[13:21:59.136] Packages needed by the future expression (n = 0): <none>
[13:21:59.136] Packages needed by future strategies (n = 0): <none>
[13:21:59.137] {
[13:21:59.137]     {
[13:21:59.137]         {
[13:21:59.137]             ...future.startTime <- base::Sys.time()
[13:21:59.137]             {
[13:21:59.137]                 {
[13:21:59.137]                   {
[13:21:59.137]                     {
[13:21:59.137]                       base::local({
[13:21:59.137]                         has_future <- base::requireNamespace("future", 
[13:21:59.137]                           quietly = TRUE)
[13:21:59.137]                         if (has_future) {
[13:21:59.137]                           ns <- base::getNamespace("future")
[13:21:59.137]                           version <- ns[[".package"]][["version"]]
[13:21:59.137]                           if (is.null(version)) 
[13:21:59.137]                             version <- utils::packageVersion("future")
[13:21:59.137]                         }
[13:21:59.137]                         else {
[13:21:59.137]                           version <- NULL
[13:21:59.137]                         }
[13:21:59.137]                         if (!has_future || version < "1.8.0") {
[13:21:59.137]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:59.137]                             "", base::R.version$version.string), 
[13:21:59.137]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:59.137]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:59.137]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:59.137]                               "release", "version")], collapse = " "), 
[13:21:59.137]                             hostname = base::Sys.info()[["nodename"]])
[13:21:59.137]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:59.137]                             info)
[13:21:59.137]                           info <- base::paste(info, collapse = "; ")
[13:21:59.137]                           if (!has_future) {
[13:21:59.137]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:59.137]                               info)
[13:21:59.137]                           }
[13:21:59.137]                           else {
[13:21:59.137]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:59.137]                               info, version)
[13:21:59.137]                           }
[13:21:59.137]                           base::stop(msg)
[13:21:59.137]                         }
[13:21:59.137]                       })
[13:21:59.137]                     }
[13:21:59.137]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:59.137]                     base::options(mc.cores = 1L)
[13:21:59.137]                   }
[13:21:59.137]                   options(future.plan = NULL)
[13:21:59.137]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:59.137]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:59.137]                 }
[13:21:59.137]                 ...future.workdir <- getwd()
[13:21:59.137]             }
[13:21:59.137]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:59.137]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:59.137]         }
[13:21:59.137]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:59.137]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:59.137]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:59.137]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:59.137]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:59.137]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:59.137]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:59.137]             base::names(...future.oldOptions))
[13:21:59.137]     }
[13:21:59.137]     if (FALSE) {
[13:21:59.137]     }
[13:21:59.137]     else {
[13:21:59.137]         if (TRUE) {
[13:21:59.137]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:59.137]                 open = "w")
[13:21:59.137]         }
[13:21:59.137]         else {
[13:21:59.137]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:59.137]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:59.137]         }
[13:21:59.137]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:59.137]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:59.137]             base::sink(type = "output", split = FALSE)
[13:21:59.137]             base::close(...future.stdout)
[13:21:59.137]         }, add = TRUE)
[13:21:59.137]     }
[13:21:59.137]     ...future.frame <- base::sys.nframe()
[13:21:59.137]     ...future.conditions <- base::list()
[13:21:59.137]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:59.137]     if (FALSE) {
[13:21:59.137]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:59.137]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:59.137]     }
[13:21:59.137]     ...future.result <- base::tryCatch({
[13:21:59.137]         base::withCallingHandlers({
[13:21:59.137]             ...future.value <- base::withVisible(base::local({
[13:21:59.137]                 ...future.makeSendCondition <- local({
[13:21:59.137]                   sendCondition <- NULL
[13:21:59.137]                   function(frame = 1L) {
[13:21:59.137]                     if (is.function(sendCondition)) 
[13:21:59.137]                       return(sendCondition)
[13:21:59.137]                     ns <- getNamespace("parallel")
[13:21:59.137]                     if (exists("sendData", mode = "function", 
[13:21:59.137]                       envir = ns)) {
[13:21:59.137]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:59.137]                         envir = ns)
[13:21:59.137]                       envir <- sys.frame(frame)
[13:21:59.137]                       master <- NULL
[13:21:59.137]                       while (!identical(envir, .GlobalEnv) && 
[13:21:59.137]                         !identical(envir, emptyenv())) {
[13:21:59.137]                         if (exists("master", mode = "list", envir = envir, 
[13:21:59.137]                           inherits = FALSE)) {
[13:21:59.137]                           master <- get("master", mode = "list", 
[13:21:59.137]                             envir = envir, inherits = FALSE)
[13:21:59.137]                           if (inherits(master, c("SOCKnode", 
[13:21:59.137]                             "SOCK0node"))) {
[13:21:59.137]                             sendCondition <<- function(cond) {
[13:21:59.137]                               data <- list(type = "VALUE", value = cond, 
[13:21:59.137]                                 success = TRUE)
[13:21:59.137]                               parallel_sendData(master, data)
[13:21:59.137]                             }
[13:21:59.137]                             return(sendCondition)
[13:21:59.137]                           }
[13:21:59.137]                         }
[13:21:59.137]                         frame <- frame + 1L
[13:21:59.137]                         envir <- sys.frame(frame)
[13:21:59.137]                       }
[13:21:59.137]                     }
[13:21:59.137]                     sendCondition <<- function(cond) NULL
[13:21:59.137]                   }
[13:21:59.137]                 })
[13:21:59.137]                 withCallingHandlers({
[13:21:59.137]                   2
[13:21:59.137]                 }, immediateCondition = function(cond) {
[13:21:59.137]                   sendCondition <- ...future.makeSendCondition()
[13:21:59.137]                   sendCondition(cond)
[13:21:59.137]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:59.137]                   {
[13:21:59.137]                     inherits <- base::inherits
[13:21:59.137]                     invokeRestart <- base::invokeRestart
[13:21:59.137]                     is.null <- base::is.null
[13:21:59.137]                     muffled <- FALSE
[13:21:59.137]                     if (inherits(cond, "message")) {
[13:21:59.137]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:59.137]                       if (muffled) 
[13:21:59.137]                         invokeRestart("muffleMessage")
[13:21:59.137]                     }
[13:21:59.137]                     else if (inherits(cond, "warning")) {
[13:21:59.137]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:59.137]                       if (muffled) 
[13:21:59.137]                         invokeRestart("muffleWarning")
[13:21:59.137]                     }
[13:21:59.137]                     else if (inherits(cond, "condition")) {
[13:21:59.137]                       if (!is.null(pattern)) {
[13:21:59.137]                         computeRestarts <- base::computeRestarts
[13:21:59.137]                         grepl <- base::grepl
[13:21:59.137]                         restarts <- computeRestarts(cond)
[13:21:59.137]                         for (restart in restarts) {
[13:21:59.137]                           name <- restart$name
[13:21:59.137]                           if (is.null(name)) 
[13:21:59.137]                             next
[13:21:59.137]                           if (!grepl(pattern, name)) 
[13:21:59.137]                             next
[13:21:59.137]                           invokeRestart(restart)
[13:21:59.137]                           muffled <- TRUE
[13:21:59.137]                           break
[13:21:59.137]                         }
[13:21:59.137]                       }
[13:21:59.137]                     }
[13:21:59.137]                     invisible(muffled)
[13:21:59.137]                   }
[13:21:59.137]                   muffleCondition(cond)
[13:21:59.137]                 })
[13:21:59.137]             }))
[13:21:59.137]             future::FutureResult(value = ...future.value$value, 
[13:21:59.137]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:59.137]                   ...future.rng), globalenv = if (FALSE) 
[13:21:59.137]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:59.137]                     ...future.globalenv.names))
[13:21:59.137]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:59.137]         }, condition = base::local({
[13:21:59.137]             c <- base::c
[13:21:59.137]             inherits <- base::inherits
[13:21:59.137]             invokeRestart <- base::invokeRestart
[13:21:59.137]             length <- base::length
[13:21:59.137]             list <- base::list
[13:21:59.137]             seq.int <- base::seq.int
[13:21:59.137]             signalCondition <- base::signalCondition
[13:21:59.137]             sys.calls <- base::sys.calls
[13:21:59.137]             `[[` <- base::`[[`
[13:21:59.137]             `+` <- base::`+`
[13:21:59.137]             `<<-` <- base::`<<-`
[13:21:59.137]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:59.137]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:59.137]                   3L)]
[13:21:59.137]             }
[13:21:59.137]             function(cond) {
[13:21:59.137]                 is_error <- inherits(cond, "error")
[13:21:59.137]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:59.137]                   NULL)
[13:21:59.137]                 if (is_error) {
[13:21:59.137]                   sessionInformation <- function() {
[13:21:59.137]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:59.137]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:59.137]                       search = base::search(), system = base::Sys.info())
[13:21:59.137]                   }
[13:21:59.137]                   ...future.conditions[[length(...future.conditions) + 
[13:21:59.137]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:59.137]                     cond$call), session = sessionInformation(), 
[13:21:59.137]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:59.137]                   signalCondition(cond)
[13:21:59.137]                 }
[13:21:59.137]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:59.137]                 "immediateCondition"))) {
[13:21:59.137]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:59.137]                   ...future.conditions[[length(...future.conditions) + 
[13:21:59.137]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:59.137]                   if (TRUE && !signal) {
[13:21:59.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:59.137]                     {
[13:21:59.137]                       inherits <- base::inherits
[13:21:59.137]                       invokeRestart <- base::invokeRestart
[13:21:59.137]                       is.null <- base::is.null
[13:21:59.137]                       muffled <- FALSE
[13:21:59.137]                       if (inherits(cond, "message")) {
[13:21:59.137]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:59.137]                         if (muffled) 
[13:21:59.137]                           invokeRestart("muffleMessage")
[13:21:59.137]                       }
[13:21:59.137]                       else if (inherits(cond, "warning")) {
[13:21:59.137]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:59.137]                         if (muffled) 
[13:21:59.137]                           invokeRestart("muffleWarning")
[13:21:59.137]                       }
[13:21:59.137]                       else if (inherits(cond, "condition")) {
[13:21:59.137]                         if (!is.null(pattern)) {
[13:21:59.137]                           computeRestarts <- base::computeRestarts
[13:21:59.137]                           grepl <- base::grepl
[13:21:59.137]                           restarts <- computeRestarts(cond)
[13:21:59.137]                           for (restart in restarts) {
[13:21:59.137]                             name <- restart$name
[13:21:59.137]                             if (is.null(name)) 
[13:21:59.137]                               next
[13:21:59.137]                             if (!grepl(pattern, name)) 
[13:21:59.137]                               next
[13:21:59.137]                             invokeRestart(restart)
[13:21:59.137]                             muffled <- TRUE
[13:21:59.137]                             break
[13:21:59.137]                           }
[13:21:59.137]                         }
[13:21:59.137]                       }
[13:21:59.137]                       invisible(muffled)
[13:21:59.137]                     }
[13:21:59.137]                     muffleCondition(cond, pattern = "^muffle")
[13:21:59.137]                   }
[13:21:59.137]                 }
[13:21:59.137]                 else {
[13:21:59.137]                   if (TRUE) {
[13:21:59.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:59.137]                     {
[13:21:59.137]                       inherits <- base::inherits
[13:21:59.137]                       invokeRestart <- base::invokeRestart
[13:21:59.137]                       is.null <- base::is.null
[13:21:59.137]                       muffled <- FALSE
[13:21:59.137]                       if (inherits(cond, "message")) {
[13:21:59.137]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:59.137]                         if (muffled) 
[13:21:59.137]                           invokeRestart("muffleMessage")
[13:21:59.137]                       }
[13:21:59.137]                       else if (inherits(cond, "warning")) {
[13:21:59.137]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:59.137]                         if (muffled) 
[13:21:59.137]                           invokeRestart("muffleWarning")
[13:21:59.137]                       }
[13:21:59.137]                       else if (inherits(cond, "condition")) {
[13:21:59.137]                         if (!is.null(pattern)) {
[13:21:59.137]                           computeRestarts <- base::computeRestarts
[13:21:59.137]                           grepl <- base::grepl
[13:21:59.137]                           restarts <- computeRestarts(cond)
[13:21:59.137]                           for (restart in restarts) {
[13:21:59.137]                             name <- restart$name
[13:21:59.137]                             if (is.null(name)) 
[13:21:59.137]                               next
[13:21:59.137]                             if (!grepl(pattern, name)) 
[13:21:59.137]                               next
[13:21:59.137]                             invokeRestart(restart)
[13:21:59.137]                             muffled <- TRUE
[13:21:59.137]                             break
[13:21:59.137]                           }
[13:21:59.137]                         }
[13:21:59.137]                       }
[13:21:59.137]                       invisible(muffled)
[13:21:59.137]                     }
[13:21:59.137]                     muffleCondition(cond, pattern = "^muffle")
[13:21:59.137]                   }
[13:21:59.137]                 }
[13:21:59.137]             }
[13:21:59.137]         }))
[13:21:59.137]     }, error = function(ex) {
[13:21:59.137]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:59.137]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:59.137]                 ...future.rng), started = ...future.startTime, 
[13:21:59.137]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:59.137]             version = "1.8"), class = "FutureResult")
[13:21:59.137]     }, finally = {
[13:21:59.137]         if (!identical(...future.workdir, getwd())) 
[13:21:59.137]             setwd(...future.workdir)
[13:21:59.137]         {
[13:21:59.137]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:59.137]                 ...future.oldOptions$nwarnings <- NULL
[13:21:59.137]             }
[13:21:59.137]             base::options(...future.oldOptions)
[13:21:59.137]             if (.Platform$OS.type == "windows") {
[13:21:59.137]                 old_names <- names(...future.oldEnvVars)
[13:21:59.137]                 envs <- base::Sys.getenv()
[13:21:59.137]                 names <- names(envs)
[13:21:59.137]                 common <- intersect(names, old_names)
[13:21:59.137]                 added <- setdiff(names, old_names)
[13:21:59.137]                 removed <- setdiff(old_names, names)
[13:21:59.137]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:59.137]                   envs[common]]
[13:21:59.137]                 NAMES <- toupper(changed)
[13:21:59.137]                 args <- list()
[13:21:59.137]                 for (kk in seq_along(NAMES)) {
[13:21:59.137]                   name <- changed[[kk]]
[13:21:59.137]                   NAME <- NAMES[[kk]]
[13:21:59.137]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:59.137]                     next
[13:21:59.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:59.137]                 }
[13:21:59.137]                 NAMES <- toupper(added)
[13:21:59.137]                 for (kk in seq_along(NAMES)) {
[13:21:59.137]                   name <- added[[kk]]
[13:21:59.137]                   NAME <- NAMES[[kk]]
[13:21:59.137]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:59.137]                     next
[13:21:59.137]                   args[[name]] <- ""
[13:21:59.137]                 }
[13:21:59.137]                 NAMES <- toupper(removed)
[13:21:59.137]                 for (kk in seq_along(NAMES)) {
[13:21:59.137]                   name <- removed[[kk]]
[13:21:59.137]                   NAME <- NAMES[[kk]]
[13:21:59.137]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:59.137]                     next
[13:21:59.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:59.137]                 }
[13:21:59.137]                 if (length(args) > 0) 
[13:21:59.137]                   base::do.call(base::Sys.setenv, args = args)
[13:21:59.137]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:59.137]             }
[13:21:59.137]             else {
[13:21:59.137]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:59.137]             }
[13:21:59.137]             {
[13:21:59.137]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:59.137]                   0L) {
[13:21:59.137]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:59.137]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:59.137]                   base::options(opts)
[13:21:59.137]                 }
[13:21:59.137]                 {
[13:21:59.137]                   {
[13:21:59.137]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:59.137]                     NULL
[13:21:59.137]                   }
[13:21:59.137]                   options(future.plan = NULL)
[13:21:59.137]                   if (is.na(NA_character_)) 
[13:21:59.137]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:59.137]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:59.137]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:59.137]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:59.137]                     envir = parent.frame()) 
[13:21:59.137]                   {
[13:21:59.137]                     if (is.function(workers)) 
[13:21:59.137]                       workers <- workers()
[13:21:59.137]                     workers <- structure(as.integer(workers), 
[13:21:59.137]                       class = class(workers))
[13:21:59.137]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:59.137]                       workers >= 1)
[13:21:59.137]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:59.137]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:59.137]                     }
[13:21:59.137]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:59.137]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:59.137]                       envir = envir)
[13:21:59.137]                     if (!future$lazy) 
[13:21:59.137]                       future <- run(future)
[13:21:59.137]                     invisible(future)
[13:21:59.137]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:59.137]                 }
[13:21:59.137]             }
[13:21:59.137]         }
[13:21:59.137]     })
[13:21:59.137]     if (TRUE) {
[13:21:59.137]         base::sink(type = "output", split = FALSE)
[13:21:59.137]         if (TRUE) {
[13:21:59.137]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:59.137]         }
[13:21:59.137]         else {
[13:21:59.137]             ...future.result["stdout"] <- base::list(NULL)
[13:21:59.137]         }
[13:21:59.137]         base::close(...future.stdout)
[13:21:59.137]         ...future.stdout <- NULL
[13:21:59.137]     }
[13:21:59.137]     ...future.result$conditions <- ...future.conditions
[13:21:59.137]     ...future.result$finished <- base::Sys.time()
[13:21:59.137]     ...future.result
[13:21:59.137] }
[13:21:59.139] Poll #1 (0): usedNodes() = 2, workers = 2
[13:21:59.150] receiveMessageFromWorker() for ClusterFuture ...
[13:21:59.150] - Validating connection of MultisessionFuture
[13:21:59.150] - received message: FutureResult
[13:21:59.150] - Received FutureResult
[13:21:59.150] - Erased future from FutureRegistry
[13:21:59.150] result() for ClusterFuture ...
[13:21:59.150] - result already collected: FutureResult
[13:21:59.150] result() for ClusterFuture ... done
[13:21:59.151] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:59.151] result() for ClusterFuture ...
[13:21:59.151] - result already collected: FutureResult
[13:21:59.151] result() for ClusterFuture ... done
[13:21:59.151] result() for ClusterFuture ...
[13:21:59.151] - result already collected: FutureResult
[13:21:59.151] result() for ClusterFuture ... done
[13:21:59.152] MultisessionFuture started
[13:21:59.152] - Launch lazy future ... done
[13:21:59.153] run() for ‘MultisessionFuture’ ... done
[13:21:59.153] resolve() on list ...
[13:21:59.153]  recursive: 0
[13:21:59.153]  length: 3
[13:21:59.153]  elements: ‘a’, ‘b’, ‘’
[13:21:59.174]  length: 2 (resolved future 3)
[13:21:59.185] receiveMessageFromWorker() for ClusterFuture ...
[13:21:59.185] - Validating connection of MultisessionFuture
[13:21:59.185] - received message: FutureResult
[13:21:59.185] - Received FutureResult
[13:21:59.185] - Erased future from FutureRegistry
[13:21:59.185] result() for ClusterFuture ...
[13:21:59.185] - result already collected: FutureResult
[13:21:59.186] result() for ClusterFuture ... done
[13:21:59.186] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:59.186] Future #1
[13:21:59.186]  length: 1 (resolved future 1)
[13:21:59.207] receiveMessageFromWorker() for ClusterFuture ...
[13:21:59.207] - Validating connection of MultisessionFuture
[13:21:59.207] - received message: FutureResult
[13:21:59.207] - Received FutureResult
[13:21:59.207] - Erased future from FutureRegistry
[13:21:59.208] result() for ClusterFuture ...
[13:21:59.208] - result already collected: FutureResult
[13:21:59.208] result() for ClusterFuture ... done
[13:21:59.208] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:59.208] Future #2
[13:21:59.208]  length: 0 (resolved future 2)
[13:21:59.208] resolve() on list ... DONE
[13:21:59.208] getGlobalsAndPackages() ...
[13:21:59.208] Searching for globals...
[13:21:59.209] 
[13:21:59.209] Searching for globals ... DONE
[13:21:59.209] - globals: [0] <none>
[13:21:59.209] getGlobalsAndPackages() ... DONE
[13:21:59.209] getGlobalsAndPackages() ...
[13:21:59.209] Searching for globals...
[13:21:59.210] 
[13:21:59.210] Searching for globals ... DONE
[13:21:59.210] - globals: [0] <none>
[13:21:59.210] getGlobalsAndPackages() ... DONE
[13:21:59.210] run() for ‘Future’ ...
[13:21:59.210] - state: ‘created’
[13:21:59.210] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:59.225] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:59.225] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:59.225]   - Field: ‘node’
[13:21:59.225]   - Field: ‘label’
[13:21:59.225]   - Field: ‘local’
[13:21:59.225]   - Field: ‘owner’
[13:21:59.225]   - Field: ‘envir’
[13:21:59.226]   - Field: ‘workers’
[13:21:59.226]   - Field: ‘packages’
[13:21:59.226]   - Field: ‘gc’
[13:21:59.226]   - Field: ‘conditions’
[13:21:59.226]   - Field: ‘persistent’
[13:21:59.226]   - Field: ‘expr’
[13:21:59.226]   - Field: ‘uuid’
[13:21:59.226]   - Field: ‘seed’
[13:21:59.226]   - Field: ‘version’
[13:21:59.226]   - Field: ‘result’
[13:21:59.226]   - Field: ‘asynchronous’
[13:21:59.227]   - Field: ‘calls’
[13:21:59.227]   - Field: ‘globals’
[13:21:59.227]   - Field: ‘stdout’
[13:21:59.227]   - Field: ‘earlySignal’
[13:21:59.227]   - Field: ‘lazy’
[13:21:59.227]   - Field: ‘state’
[13:21:59.227] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:59.227] - Launch lazy future ...
[13:21:59.227] Packages needed by the future expression (n = 0): <none>
[13:21:59.228] Packages needed by future strategies (n = 0): <none>
[13:21:59.228] {
[13:21:59.228]     {
[13:21:59.228]         {
[13:21:59.228]             ...future.startTime <- base::Sys.time()
[13:21:59.228]             {
[13:21:59.228]                 {
[13:21:59.228]                   {
[13:21:59.228]                     {
[13:21:59.228]                       base::local({
[13:21:59.228]                         has_future <- base::requireNamespace("future", 
[13:21:59.228]                           quietly = TRUE)
[13:21:59.228]                         if (has_future) {
[13:21:59.228]                           ns <- base::getNamespace("future")
[13:21:59.228]                           version <- ns[[".package"]][["version"]]
[13:21:59.228]                           if (is.null(version)) 
[13:21:59.228]                             version <- utils::packageVersion("future")
[13:21:59.228]                         }
[13:21:59.228]                         else {
[13:21:59.228]                           version <- NULL
[13:21:59.228]                         }
[13:21:59.228]                         if (!has_future || version < "1.8.0") {
[13:21:59.228]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:59.228]                             "", base::R.version$version.string), 
[13:21:59.228]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:59.228]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:59.228]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:59.228]                               "release", "version")], collapse = " "), 
[13:21:59.228]                             hostname = base::Sys.info()[["nodename"]])
[13:21:59.228]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:59.228]                             info)
[13:21:59.228]                           info <- base::paste(info, collapse = "; ")
[13:21:59.228]                           if (!has_future) {
[13:21:59.228]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:59.228]                               info)
[13:21:59.228]                           }
[13:21:59.228]                           else {
[13:21:59.228]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:59.228]                               info, version)
[13:21:59.228]                           }
[13:21:59.228]                           base::stop(msg)
[13:21:59.228]                         }
[13:21:59.228]                       })
[13:21:59.228]                     }
[13:21:59.228]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:59.228]                     base::options(mc.cores = 1L)
[13:21:59.228]                   }
[13:21:59.228]                   options(future.plan = NULL)
[13:21:59.228]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:59.228]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:59.228]                 }
[13:21:59.228]                 ...future.workdir <- getwd()
[13:21:59.228]             }
[13:21:59.228]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:59.228]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:59.228]         }
[13:21:59.228]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:59.228]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:59.228]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:59.228]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:59.228]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:59.228]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:59.228]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:59.228]             base::names(...future.oldOptions))
[13:21:59.228]     }
[13:21:59.228]     if (FALSE) {
[13:21:59.228]     }
[13:21:59.228]     else {
[13:21:59.228]         if (TRUE) {
[13:21:59.228]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:59.228]                 open = "w")
[13:21:59.228]         }
[13:21:59.228]         else {
[13:21:59.228]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:59.228]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:59.228]         }
[13:21:59.228]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:59.228]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:59.228]             base::sink(type = "output", split = FALSE)
[13:21:59.228]             base::close(...future.stdout)
[13:21:59.228]         }, add = TRUE)
[13:21:59.228]     }
[13:21:59.228]     ...future.frame <- base::sys.nframe()
[13:21:59.228]     ...future.conditions <- base::list()
[13:21:59.228]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:59.228]     if (FALSE) {
[13:21:59.228]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:59.228]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:59.228]     }
[13:21:59.228]     ...future.result <- base::tryCatch({
[13:21:59.228]         base::withCallingHandlers({
[13:21:59.228]             ...future.value <- base::withVisible(base::local({
[13:21:59.228]                 ...future.makeSendCondition <- local({
[13:21:59.228]                   sendCondition <- NULL
[13:21:59.228]                   function(frame = 1L) {
[13:21:59.228]                     if (is.function(sendCondition)) 
[13:21:59.228]                       return(sendCondition)
[13:21:59.228]                     ns <- getNamespace("parallel")
[13:21:59.228]                     if (exists("sendData", mode = "function", 
[13:21:59.228]                       envir = ns)) {
[13:21:59.228]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:59.228]                         envir = ns)
[13:21:59.228]                       envir <- sys.frame(frame)
[13:21:59.228]                       master <- NULL
[13:21:59.228]                       while (!identical(envir, .GlobalEnv) && 
[13:21:59.228]                         !identical(envir, emptyenv())) {
[13:21:59.228]                         if (exists("master", mode = "list", envir = envir, 
[13:21:59.228]                           inherits = FALSE)) {
[13:21:59.228]                           master <- get("master", mode = "list", 
[13:21:59.228]                             envir = envir, inherits = FALSE)
[13:21:59.228]                           if (inherits(master, c("SOCKnode", 
[13:21:59.228]                             "SOCK0node"))) {
[13:21:59.228]                             sendCondition <<- function(cond) {
[13:21:59.228]                               data <- list(type = "VALUE", value = cond, 
[13:21:59.228]                                 success = TRUE)
[13:21:59.228]                               parallel_sendData(master, data)
[13:21:59.228]                             }
[13:21:59.228]                             return(sendCondition)
[13:21:59.228]                           }
[13:21:59.228]                         }
[13:21:59.228]                         frame <- frame + 1L
[13:21:59.228]                         envir <- sys.frame(frame)
[13:21:59.228]                       }
[13:21:59.228]                     }
[13:21:59.228]                     sendCondition <<- function(cond) NULL
[13:21:59.228]                   }
[13:21:59.228]                 })
[13:21:59.228]                 withCallingHandlers({
[13:21:59.228]                   2
[13:21:59.228]                 }, immediateCondition = function(cond) {
[13:21:59.228]                   sendCondition <- ...future.makeSendCondition()
[13:21:59.228]                   sendCondition(cond)
[13:21:59.228]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:59.228]                   {
[13:21:59.228]                     inherits <- base::inherits
[13:21:59.228]                     invokeRestart <- base::invokeRestart
[13:21:59.228]                     is.null <- base::is.null
[13:21:59.228]                     muffled <- FALSE
[13:21:59.228]                     if (inherits(cond, "message")) {
[13:21:59.228]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:59.228]                       if (muffled) 
[13:21:59.228]                         invokeRestart("muffleMessage")
[13:21:59.228]                     }
[13:21:59.228]                     else if (inherits(cond, "warning")) {
[13:21:59.228]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:59.228]                       if (muffled) 
[13:21:59.228]                         invokeRestart("muffleWarning")
[13:21:59.228]                     }
[13:21:59.228]                     else if (inherits(cond, "condition")) {
[13:21:59.228]                       if (!is.null(pattern)) {
[13:21:59.228]                         computeRestarts <- base::computeRestarts
[13:21:59.228]                         grepl <- base::grepl
[13:21:59.228]                         restarts <- computeRestarts(cond)
[13:21:59.228]                         for (restart in restarts) {
[13:21:59.228]                           name <- restart$name
[13:21:59.228]                           if (is.null(name)) 
[13:21:59.228]                             next
[13:21:59.228]                           if (!grepl(pattern, name)) 
[13:21:59.228]                             next
[13:21:59.228]                           invokeRestart(restart)
[13:21:59.228]                           muffled <- TRUE
[13:21:59.228]                           break
[13:21:59.228]                         }
[13:21:59.228]                       }
[13:21:59.228]                     }
[13:21:59.228]                     invisible(muffled)
[13:21:59.228]                   }
[13:21:59.228]                   muffleCondition(cond)
[13:21:59.228]                 })
[13:21:59.228]             }))
[13:21:59.228]             future::FutureResult(value = ...future.value$value, 
[13:21:59.228]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:59.228]                   ...future.rng), globalenv = if (FALSE) 
[13:21:59.228]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:59.228]                     ...future.globalenv.names))
[13:21:59.228]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:59.228]         }, condition = base::local({
[13:21:59.228]             c <- base::c
[13:21:59.228]             inherits <- base::inherits
[13:21:59.228]             invokeRestart <- base::invokeRestart
[13:21:59.228]             length <- base::length
[13:21:59.228]             list <- base::list
[13:21:59.228]             seq.int <- base::seq.int
[13:21:59.228]             signalCondition <- base::signalCondition
[13:21:59.228]             sys.calls <- base::sys.calls
[13:21:59.228]             `[[` <- base::`[[`
[13:21:59.228]             `+` <- base::`+`
[13:21:59.228]             `<<-` <- base::`<<-`
[13:21:59.228]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:59.228]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:59.228]                   3L)]
[13:21:59.228]             }
[13:21:59.228]             function(cond) {
[13:21:59.228]                 is_error <- inherits(cond, "error")
[13:21:59.228]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:59.228]                   NULL)
[13:21:59.228]                 if (is_error) {
[13:21:59.228]                   sessionInformation <- function() {
[13:21:59.228]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:59.228]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:59.228]                       search = base::search(), system = base::Sys.info())
[13:21:59.228]                   }
[13:21:59.228]                   ...future.conditions[[length(...future.conditions) + 
[13:21:59.228]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:59.228]                     cond$call), session = sessionInformation(), 
[13:21:59.228]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:59.228]                   signalCondition(cond)
[13:21:59.228]                 }
[13:21:59.228]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:59.228]                 "immediateCondition"))) {
[13:21:59.228]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:59.228]                   ...future.conditions[[length(...future.conditions) + 
[13:21:59.228]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:59.228]                   if (TRUE && !signal) {
[13:21:59.228]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:59.228]                     {
[13:21:59.228]                       inherits <- base::inherits
[13:21:59.228]                       invokeRestart <- base::invokeRestart
[13:21:59.228]                       is.null <- base::is.null
[13:21:59.228]                       muffled <- FALSE
[13:21:59.228]                       if (inherits(cond, "message")) {
[13:21:59.228]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:59.228]                         if (muffled) 
[13:21:59.228]                           invokeRestart("muffleMessage")
[13:21:59.228]                       }
[13:21:59.228]                       else if (inherits(cond, "warning")) {
[13:21:59.228]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:59.228]                         if (muffled) 
[13:21:59.228]                           invokeRestart("muffleWarning")
[13:21:59.228]                       }
[13:21:59.228]                       else if (inherits(cond, "condition")) {
[13:21:59.228]                         if (!is.null(pattern)) {
[13:21:59.228]                           computeRestarts <- base::computeRestarts
[13:21:59.228]                           grepl <- base::grepl
[13:21:59.228]                           restarts <- computeRestarts(cond)
[13:21:59.228]                           for (restart in restarts) {
[13:21:59.228]                             name <- restart$name
[13:21:59.228]                             if (is.null(name)) 
[13:21:59.228]                               next
[13:21:59.228]                             if (!grepl(pattern, name)) 
[13:21:59.228]                               next
[13:21:59.228]                             invokeRestart(restart)
[13:21:59.228]                             muffled <- TRUE
[13:21:59.228]                             break
[13:21:59.228]                           }
[13:21:59.228]                         }
[13:21:59.228]                       }
[13:21:59.228]                       invisible(muffled)
[13:21:59.228]                     }
[13:21:59.228]                     muffleCondition(cond, pattern = "^muffle")
[13:21:59.228]                   }
[13:21:59.228]                 }
[13:21:59.228]                 else {
[13:21:59.228]                   if (TRUE) {
[13:21:59.228]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:59.228]                     {
[13:21:59.228]                       inherits <- base::inherits
[13:21:59.228]                       invokeRestart <- base::invokeRestart
[13:21:59.228]                       is.null <- base::is.null
[13:21:59.228]                       muffled <- FALSE
[13:21:59.228]                       if (inherits(cond, "message")) {
[13:21:59.228]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:59.228]                         if (muffled) 
[13:21:59.228]                           invokeRestart("muffleMessage")
[13:21:59.228]                       }
[13:21:59.228]                       else if (inherits(cond, "warning")) {
[13:21:59.228]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:59.228]                         if (muffled) 
[13:21:59.228]                           invokeRestart("muffleWarning")
[13:21:59.228]                       }
[13:21:59.228]                       else if (inherits(cond, "condition")) {
[13:21:59.228]                         if (!is.null(pattern)) {
[13:21:59.228]                           computeRestarts <- base::computeRestarts
[13:21:59.228]                           grepl <- base::grepl
[13:21:59.228]                           restarts <- computeRestarts(cond)
[13:21:59.228]                           for (restart in restarts) {
[13:21:59.228]                             name <- restart$name
[13:21:59.228]                             if (is.null(name)) 
[13:21:59.228]                               next
[13:21:59.228]                             if (!grepl(pattern, name)) 
[13:21:59.228]                               next
[13:21:59.228]                             invokeRestart(restart)
[13:21:59.228]                             muffled <- TRUE
[13:21:59.228]                             break
[13:21:59.228]                           }
[13:21:59.228]                         }
[13:21:59.228]                       }
[13:21:59.228]                       invisible(muffled)
[13:21:59.228]                     }
[13:21:59.228]                     muffleCondition(cond, pattern = "^muffle")
[13:21:59.228]                   }
[13:21:59.228]                 }
[13:21:59.228]             }
[13:21:59.228]         }))
[13:21:59.228]     }, error = function(ex) {
[13:21:59.228]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:59.228]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:59.228]                 ...future.rng), started = ...future.startTime, 
[13:21:59.228]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:59.228]             version = "1.8"), class = "FutureResult")
[13:21:59.228]     }, finally = {
[13:21:59.228]         if (!identical(...future.workdir, getwd())) 
[13:21:59.228]             setwd(...future.workdir)
[13:21:59.228]         {
[13:21:59.228]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:59.228]                 ...future.oldOptions$nwarnings <- NULL
[13:21:59.228]             }
[13:21:59.228]             base::options(...future.oldOptions)
[13:21:59.228]             if (.Platform$OS.type == "windows") {
[13:21:59.228]                 old_names <- names(...future.oldEnvVars)
[13:21:59.228]                 envs <- base::Sys.getenv()
[13:21:59.228]                 names <- names(envs)
[13:21:59.228]                 common <- intersect(names, old_names)
[13:21:59.228]                 added <- setdiff(names, old_names)
[13:21:59.228]                 removed <- setdiff(old_names, names)
[13:21:59.228]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:59.228]                   envs[common]]
[13:21:59.228]                 NAMES <- toupper(changed)
[13:21:59.228]                 args <- list()
[13:21:59.228]                 for (kk in seq_along(NAMES)) {
[13:21:59.228]                   name <- changed[[kk]]
[13:21:59.228]                   NAME <- NAMES[[kk]]
[13:21:59.228]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:59.228]                     next
[13:21:59.228]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:59.228]                 }
[13:21:59.228]                 NAMES <- toupper(added)
[13:21:59.228]                 for (kk in seq_along(NAMES)) {
[13:21:59.228]                   name <- added[[kk]]
[13:21:59.228]                   NAME <- NAMES[[kk]]
[13:21:59.228]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:59.228]                     next
[13:21:59.228]                   args[[name]] <- ""
[13:21:59.228]                 }
[13:21:59.228]                 NAMES <- toupper(removed)
[13:21:59.228]                 for (kk in seq_along(NAMES)) {
[13:21:59.228]                   name <- removed[[kk]]
[13:21:59.228]                   NAME <- NAMES[[kk]]
[13:21:59.228]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:59.228]                     next
[13:21:59.228]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:59.228]                 }
[13:21:59.228]                 if (length(args) > 0) 
[13:21:59.228]                   base::do.call(base::Sys.setenv, args = args)
[13:21:59.228]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:59.228]             }
[13:21:59.228]             else {
[13:21:59.228]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:59.228]             }
[13:21:59.228]             {
[13:21:59.228]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:59.228]                   0L) {
[13:21:59.228]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:59.228]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:59.228]                   base::options(opts)
[13:21:59.228]                 }
[13:21:59.228]                 {
[13:21:59.228]                   {
[13:21:59.228]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:59.228]                     NULL
[13:21:59.228]                   }
[13:21:59.228]                   options(future.plan = NULL)
[13:21:59.228]                   if (is.na(NA_character_)) 
[13:21:59.228]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:59.228]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:59.228]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:59.228]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:59.228]                     envir = parent.frame()) 
[13:21:59.228]                   {
[13:21:59.228]                     if (is.function(workers)) 
[13:21:59.228]                       workers <- workers()
[13:21:59.228]                     workers <- structure(as.integer(workers), 
[13:21:59.228]                       class = class(workers))
[13:21:59.228]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:59.228]                       workers >= 1)
[13:21:59.228]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:59.228]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:59.228]                     }
[13:21:59.228]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:59.228]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:59.228]                       envir = envir)
[13:21:59.228]                     if (!future$lazy) 
[13:21:59.228]                       future <- run(future)
[13:21:59.228]                     invisible(future)
[13:21:59.228]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:59.228]                 }
[13:21:59.228]             }
[13:21:59.228]         }
[13:21:59.228]     })
[13:21:59.228]     if (TRUE) {
[13:21:59.228]         base::sink(type = "output", split = FALSE)
[13:21:59.228]         if (TRUE) {
[13:21:59.228]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:59.228]         }
[13:21:59.228]         else {
[13:21:59.228]             ...future.result["stdout"] <- base::list(NULL)
[13:21:59.228]         }
[13:21:59.228]         base::close(...future.stdout)
[13:21:59.228]         ...future.stdout <- NULL
[13:21:59.228]     }
[13:21:59.228]     ...future.result$conditions <- ...future.conditions
[13:21:59.228]     ...future.result$finished <- base::Sys.time()
[13:21:59.228]     ...future.result
[13:21:59.228] }
[13:21:59.231] MultisessionFuture started
[13:21:59.232] - Launch lazy future ... done
[13:21:59.232] run() for ‘MultisessionFuture’ ... done
[13:21:59.232] resolve() on list ...
[13:21:59.232]  recursive: 0
[13:21:59.232]  length: 3
[13:21:59.232]  elements: ‘a’, ‘b’, ‘’
[13:21:59.232] run() for ‘Future’ ...
[13:21:59.232] - state: ‘created’
[13:21:59.233] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:59.247] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:59.247] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:59.247]   - Field: ‘node’
[13:21:59.247]   - Field: ‘label’
[13:21:59.247]   - Field: ‘local’
[13:21:59.247]   - Field: ‘owner’
[13:21:59.248]   - Field: ‘envir’
[13:21:59.248]   - Field: ‘workers’
[13:21:59.248]   - Field: ‘packages’
[13:21:59.248]   - Field: ‘gc’
[13:21:59.248]   - Field: ‘conditions’
[13:21:59.248]   - Field: ‘persistent’
[13:21:59.248]   - Field: ‘expr’
[13:21:59.248]   - Field: ‘uuid’
[13:21:59.248]   - Field: ‘seed’
[13:21:59.248]   - Field: ‘version’
[13:21:59.248]   - Field: ‘result’
[13:21:59.249]   - Field: ‘asynchronous’
[13:21:59.249]   - Field: ‘calls’
[13:21:59.249]   - Field: ‘globals’
[13:21:59.249]   - Field: ‘stdout’
[13:21:59.249]   - Field: ‘earlySignal’
[13:21:59.249]   - Field: ‘lazy’
[13:21:59.249]   - Field: ‘state’
[13:21:59.249] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:59.249] - Launch lazy future ...
[13:21:59.250] Packages needed by the future expression (n = 0): <none>
[13:21:59.250] Packages needed by future strategies (n = 0): <none>
[13:21:59.250] {
[13:21:59.250]     {
[13:21:59.250]         {
[13:21:59.250]             ...future.startTime <- base::Sys.time()
[13:21:59.250]             {
[13:21:59.250]                 {
[13:21:59.250]                   {
[13:21:59.250]                     {
[13:21:59.250]                       base::local({
[13:21:59.250]                         has_future <- base::requireNamespace("future", 
[13:21:59.250]                           quietly = TRUE)
[13:21:59.250]                         if (has_future) {
[13:21:59.250]                           ns <- base::getNamespace("future")
[13:21:59.250]                           version <- ns[[".package"]][["version"]]
[13:21:59.250]                           if (is.null(version)) 
[13:21:59.250]                             version <- utils::packageVersion("future")
[13:21:59.250]                         }
[13:21:59.250]                         else {
[13:21:59.250]                           version <- NULL
[13:21:59.250]                         }
[13:21:59.250]                         if (!has_future || version < "1.8.0") {
[13:21:59.250]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:59.250]                             "", base::R.version$version.string), 
[13:21:59.250]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:59.250]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:59.250]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:59.250]                               "release", "version")], collapse = " "), 
[13:21:59.250]                             hostname = base::Sys.info()[["nodename"]])
[13:21:59.250]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:59.250]                             info)
[13:21:59.250]                           info <- base::paste(info, collapse = "; ")
[13:21:59.250]                           if (!has_future) {
[13:21:59.250]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:59.250]                               info)
[13:21:59.250]                           }
[13:21:59.250]                           else {
[13:21:59.250]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:59.250]                               info, version)
[13:21:59.250]                           }
[13:21:59.250]                           base::stop(msg)
[13:21:59.250]                         }
[13:21:59.250]                       })
[13:21:59.250]                     }
[13:21:59.250]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:59.250]                     base::options(mc.cores = 1L)
[13:21:59.250]                   }
[13:21:59.250]                   options(future.plan = NULL)
[13:21:59.250]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:59.250]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:59.250]                 }
[13:21:59.250]                 ...future.workdir <- getwd()
[13:21:59.250]             }
[13:21:59.250]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:59.250]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:59.250]         }
[13:21:59.250]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:59.250]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:59.250]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:59.250]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:59.250]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:59.250]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:59.250]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:59.250]             base::names(...future.oldOptions))
[13:21:59.250]     }
[13:21:59.250]     if (FALSE) {
[13:21:59.250]     }
[13:21:59.250]     else {
[13:21:59.250]         if (TRUE) {
[13:21:59.250]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:59.250]                 open = "w")
[13:21:59.250]         }
[13:21:59.250]         else {
[13:21:59.250]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:59.250]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:59.250]         }
[13:21:59.250]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:59.250]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:59.250]             base::sink(type = "output", split = FALSE)
[13:21:59.250]             base::close(...future.stdout)
[13:21:59.250]         }, add = TRUE)
[13:21:59.250]     }
[13:21:59.250]     ...future.frame <- base::sys.nframe()
[13:21:59.250]     ...future.conditions <- base::list()
[13:21:59.250]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:59.250]     if (FALSE) {
[13:21:59.250]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:59.250]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:59.250]     }
[13:21:59.250]     ...future.result <- base::tryCatch({
[13:21:59.250]         base::withCallingHandlers({
[13:21:59.250]             ...future.value <- base::withVisible(base::local({
[13:21:59.250]                 ...future.makeSendCondition <- local({
[13:21:59.250]                   sendCondition <- NULL
[13:21:59.250]                   function(frame = 1L) {
[13:21:59.250]                     if (is.function(sendCondition)) 
[13:21:59.250]                       return(sendCondition)
[13:21:59.250]                     ns <- getNamespace("parallel")
[13:21:59.250]                     if (exists("sendData", mode = "function", 
[13:21:59.250]                       envir = ns)) {
[13:21:59.250]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:59.250]                         envir = ns)
[13:21:59.250]                       envir <- sys.frame(frame)
[13:21:59.250]                       master <- NULL
[13:21:59.250]                       while (!identical(envir, .GlobalEnv) && 
[13:21:59.250]                         !identical(envir, emptyenv())) {
[13:21:59.250]                         if (exists("master", mode = "list", envir = envir, 
[13:21:59.250]                           inherits = FALSE)) {
[13:21:59.250]                           master <- get("master", mode = "list", 
[13:21:59.250]                             envir = envir, inherits = FALSE)
[13:21:59.250]                           if (inherits(master, c("SOCKnode", 
[13:21:59.250]                             "SOCK0node"))) {
[13:21:59.250]                             sendCondition <<- function(cond) {
[13:21:59.250]                               data <- list(type = "VALUE", value = cond, 
[13:21:59.250]                                 success = TRUE)
[13:21:59.250]                               parallel_sendData(master, data)
[13:21:59.250]                             }
[13:21:59.250]                             return(sendCondition)
[13:21:59.250]                           }
[13:21:59.250]                         }
[13:21:59.250]                         frame <- frame + 1L
[13:21:59.250]                         envir <- sys.frame(frame)
[13:21:59.250]                       }
[13:21:59.250]                     }
[13:21:59.250]                     sendCondition <<- function(cond) NULL
[13:21:59.250]                   }
[13:21:59.250]                 })
[13:21:59.250]                 withCallingHandlers({
[13:21:59.250]                   1
[13:21:59.250]                 }, immediateCondition = function(cond) {
[13:21:59.250]                   sendCondition <- ...future.makeSendCondition()
[13:21:59.250]                   sendCondition(cond)
[13:21:59.250]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:59.250]                   {
[13:21:59.250]                     inherits <- base::inherits
[13:21:59.250]                     invokeRestart <- base::invokeRestart
[13:21:59.250]                     is.null <- base::is.null
[13:21:59.250]                     muffled <- FALSE
[13:21:59.250]                     if (inherits(cond, "message")) {
[13:21:59.250]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:59.250]                       if (muffled) 
[13:21:59.250]                         invokeRestart("muffleMessage")
[13:21:59.250]                     }
[13:21:59.250]                     else if (inherits(cond, "warning")) {
[13:21:59.250]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:59.250]                       if (muffled) 
[13:21:59.250]                         invokeRestart("muffleWarning")
[13:21:59.250]                     }
[13:21:59.250]                     else if (inherits(cond, "condition")) {
[13:21:59.250]                       if (!is.null(pattern)) {
[13:21:59.250]                         computeRestarts <- base::computeRestarts
[13:21:59.250]                         grepl <- base::grepl
[13:21:59.250]                         restarts <- computeRestarts(cond)
[13:21:59.250]                         for (restart in restarts) {
[13:21:59.250]                           name <- restart$name
[13:21:59.250]                           if (is.null(name)) 
[13:21:59.250]                             next
[13:21:59.250]                           if (!grepl(pattern, name)) 
[13:21:59.250]                             next
[13:21:59.250]                           invokeRestart(restart)
[13:21:59.250]                           muffled <- TRUE
[13:21:59.250]                           break
[13:21:59.250]                         }
[13:21:59.250]                       }
[13:21:59.250]                     }
[13:21:59.250]                     invisible(muffled)
[13:21:59.250]                   }
[13:21:59.250]                   muffleCondition(cond)
[13:21:59.250]                 })
[13:21:59.250]             }))
[13:21:59.250]             future::FutureResult(value = ...future.value$value, 
[13:21:59.250]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:59.250]                   ...future.rng), globalenv = if (FALSE) 
[13:21:59.250]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:59.250]                     ...future.globalenv.names))
[13:21:59.250]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:59.250]         }, condition = base::local({
[13:21:59.250]             c <- base::c
[13:21:59.250]             inherits <- base::inherits
[13:21:59.250]             invokeRestart <- base::invokeRestart
[13:21:59.250]             length <- base::length
[13:21:59.250]             list <- base::list
[13:21:59.250]             seq.int <- base::seq.int
[13:21:59.250]             signalCondition <- base::signalCondition
[13:21:59.250]             sys.calls <- base::sys.calls
[13:21:59.250]             `[[` <- base::`[[`
[13:21:59.250]             `+` <- base::`+`
[13:21:59.250]             `<<-` <- base::`<<-`
[13:21:59.250]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:59.250]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:59.250]                   3L)]
[13:21:59.250]             }
[13:21:59.250]             function(cond) {
[13:21:59.250]                 is_error <- inherits(cond, "error")
[13:21:59.250]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:59.250]                   NULL)
[13:21:59.250]                 if (is_error) {
[13:21:59.250]                   sessionInformation <- function() {
[13:21:59.250]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:59.250]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:59.250]                       search = base::search(), system = base::Sys.info())
[13:21:59.250]                   }
[13:21:59.250]                   ...future.conditions[[length(...future.conditions) + 
[13:21:59.250]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:59.250]                     cond$call), session = sessionInformation(), 
[13:21:59.250]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:59.250]                   signalCondition(cond)
[13:21:59.250]                 }
[13:21:59.250]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:59.250]                 "immediateCondition"))) {
[13:21:59.250]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:59.250]                   ...future.conditions[[length(...future.conditions) + 
[13:21:59.250]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:59.250]                   if (TRUE && !signal) {
[13:21:59.250]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:59.250]                     {
[13:21:59.250]                       inherits <- base::inherits
[13:21:59.250]                       invokeRestart <- base::invokeRestart
[13:21:59.250]                       is.null <- base::is.null
[13:21:59.250]                       muffled <- FALSE
[13:21:59.250]                       if (inherits(cond, "message")) {
[13:21:59.250]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:59.250]                         if (muffled) 
[13:21:59.250]                           invokeRestart("muffleMessage")
[13:21:59.250]                       }
[13:21:59.250]                       else if (inherits(cond, "warning")) {
[13:21:59.250]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:59.250]                         if (muffled) 
[13:21:59.250]                           invokeRestart("muffleWarning")
[13:21:59.250]                       }
[13:21:59.250]                       else if (inherits(cond, "condition")) {
[13:21:59.250]                         if (!is.null(pattern)) {
[13:21:59.250]                           computeRestarts <- base::computeRestarts
[13:21:59.250]                           grepl <- base::grepl
[13:21:59.250]                           restarts <- computeRestarts(cond)
[13:21:59.250]                           for (restart in restarts) {
[13:21:59.250]                             name <- restart$name
[13:21:59.250]                             if (is.null(name)) 
[13:21:59.250]                               next
[13:21:59.250]                             if (!grepl(pattern, name)) 
[13:21:59.250]                               next
[13:21:59.250]                             invokeRestart(restart)
[13:21:59.250]                             muffled <- TRUE
[13:21:59.250]                             break
[13:21:59.250]                           }
[13:21:59.250]                         }
[13:21:59.250]                       }
[13:21:59.250]                       invisible(muffled)
[13:21:59.250]                     }
[13:21:59.250]                     muffleCondition(cond, pattern = "^muffle")
[13:21:59.250]                   }
[13:21:59.250]                 }
[13:21:59.250]                 else {
[13:21:59.250]                   if (TRUE) {
[13:21:59.250]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:59.250]                     {
[13:21:59.250]                       inherits <- base::inherits
[13:21:59.250]                       invokeRestart <- base::invokeRestart
[13:21:59.250]                       is.null <- base::is.null
[13:21:59.250]                       muffled <- FALSE
[13:21:59.250]                       if (inherits(cond, "message")) {
[13:21:59.250]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:59.250]                         if (muffled) 
[13:21:59.250]                           invokeRestart("muffleMessage")
[13:21:59.250]                       }
[13:21:59.250]                       else if (inherits(cond, "warning")) {
[13:21:59.250]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:59.250]                         if (muffled) 
[13:21:59.250]                           invokeRestart("muffleWarning")
[13:21:59.250]                       }
[13:21:59.250]                       else if (inherits(cond, "condition")) {
[13:21:59.250]                         if (!is.null(pattern)) {
[13:21:59.250]                           computeRestarts <- base::computeRestarts
[13:21:59.250]                           grepl <- base::grepl
[13:21:59.250]                           restarts <- computeRestarts(cond)
[13:21:59.250]                           for (restart in restarts) {
[13:21:59.250]                             name <- restart$name
[13:21:59.250]                             if (is.null(name)) 
[13:21:59.250]                               next
[13:21:59.250]                             if (!grepl(pattern, name)) 
[13:21:59.250]                               next
[13:21:59.250]                             invokeRestart(restart)
[13:21:59.250]                             muffled <- TRUE
[13:21:59.250]                             break
[13:21:59.250]                           }
[13:21:59.250]                         }
[13:21:59.250]                       }
[13:21:59.250]                       invisible(muffled)
[13:21:59.250]                     }
[13:21:59.250]                     muffleCondition(cond, pattern = "^muffle")
[13:21:59.250]                   }
[13:21:59.250]                 }
[13:21:59.250]             }
[13:21:59.250]         }))
[13:21:59.250]     }, error = function(ex) {
[13:21:59.250]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:59.250]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:59.250]                 ...future.rng), started = ...future.startTime, 
[13:21:59.250]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:59.250]             version = "1.8"), class = "FutureResult")
[13:21:59.250]     }, finally = {
[13:21:59.250]         if (!identical(...future.workdir, getwd())) 
[13:21:59.250]             setwd(...future.workdir)
[13:21:59.250]         {
[13:21:59.250]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:59.250]                 ...future.oldOptions$nwarnings <- NULL
[13:21:59.250]             }
[13:21:59.250]             base::options(...future.oldOptions)
[13:21:59.250]             if (.Platform$OS.type == "windows") {
[13:21:59.250]                 old_names <- names(...future.oldEnvVars)
[13:21:59.250]                 envs <- base::Sys.getenv()
[13:21:59.250]                 names <- names(envs)
[13:21:59.250]                 common <- intersect(names, old_names)
[13:21:59.250]                 added <- setdiff(names, old_names)
[13:21:59.250]                 removed <- setdiff(old_names, names)
[13:21:59.250]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:59.250]                   envs[common]]
[13:21:59.250]                 NAMES <- toupper(changed)
[13:21:59.250]                 args <- list()
[13:21:59.250]                 for (kk in seq_along(NAMES)) {
[13:21:59.250]                   name <- changed[[kk]]
[13:21:59.250]                   NAME <- NAMES[[kk]]
[13:21:59.250]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:59.250]                     next
[13:21:59.250]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:59.250]                 }
[13:21:59.250]                 NAMES <- toupper(added)
[13:21:59.250]                 for (kk in seq_along(NAMES)) {
[13:21:59.250]                   name <- added[[kk]]
[13:21:59.250]                   NAME <- NAMES[[kk]]
[13:21:59.250]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:59.250]                     next
[13:21:59.250]                   args[[name]] <- ""
[13:21:59.250]                 }
[13:21:59.250]                 NAMES <- toupper(removed)
[13:21:59.250]                 for (kk in seq_along(NAMES)) {
[13:21:59.250]                   name <- removed[[kk]]
[13:21:59.250]                   NAME <- NAMES[[kk]]
[13:21:59.250]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:59.250]                     next
[13:21:59.250]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:59.250]                 }
[13:21:59.250]                 if (length(args) > 0) 
[13:21:59.250]                   base::do.call(base::Sys.setenv, args = args)
[13:21:59.250]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:59.250]             }
[13:21:59.250]             else {
[13:21:59.250]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:59.250]             }
[13:21:59.250]             {
[13:21:59.250]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:59.250]                   0L) {
[13:21:59.250]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:59.250]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:59.250]                   base::options(opts)
[13:21:59.250]                 }
[13:21:59.250]                 {
[13:21:59.250]                   {
[13:21:59.250]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:59.250]                     NULL
[13:21:59.250]                   }
[13:21:59.250]                   options(future.plan = NULL)
[13:21:59.250]                   if (is.na(NA_character_)) 
[13:21:59.250]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:59.250]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:59.250]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:59.250]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:59.250]                     envir = parent.frame()) 
[13:21:59.250]                   {
[13:21:59.250]                     if (is.function(workers)) 
[13:21:59.250]                       workers <- workers()
[13:21:59.250]                     workers <- structure(as.integer(workers), 
[13:21:59.250]                       class = class(workers))
[13:21:59.250]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:59.250]                       workers >= 1)
[13:21:59.250]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:59.250]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:59.250]                     }
[13:21:59.250]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:59.250]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:59.250]                       envir = envir)
[13:21:59.250]                     if (!future$lazy) 
[13:21:59.250]                       future <- run(future)
[13:21:59.250]                     invisible(future)
[13:21:59.250]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:59.250]                 }
[13:21:59.250]             }
[13:21:59.250]         }
[13:21:59.250]     })
[13:21:59.250]     if (TRUE) {
[13:21:59.250]         base::sink(type = "output", split = FALSE)
[13:21:59.250]         if (TRUE) {
[13:21:59.250]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:59.250]         }
[13:21:59.250]         else {
[13:21:59.250]             ...future.result["stdout"] <- base::list(NULL)
[13:21:59.250]         }
[13:21:59.250]         base::close(...future.stdout)
[13:21:59.250]         ...future.stdout <- NULL
[13:21:59.250]     }
[13:21:59.250]     ...future.result$conditions <- ...future.conditions
[13:21:59.250]     ...future.result$finished <- base::Sys.time()
[13:21:59.250]     ...future.result
[13:21:59.250] }
[13:21:59.253] MultisessionFuture started
[13:21:59.254] - Launch lazy future ... done
[13:21:59.254] run() for ‘MultisessionFuture’ ... done
[13:21:59.275]  length: 2 (resolved future 3)
[13:21:59.296] receiveMessageFromWorker() for ClusterFuture ...
[13:21:59.296] - Validating connection of MultisessionFuture
[13:21:59.297] - received message: FutureResult
[13:21:59.297] - Received FutureResult
[13:21:59.297] - Erased future from FutureRegistry
[13:21:59.297] result() for ClusterFuture ...
[13:21:59.297] - result already collected: FutureResult
[13:21:59.297] result() for ClusterFuture ... done
[13:21:59.297] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:59.297] Future #2
[13:21:59.297]  length: 1 (resolved future 2)
[13:21:59.308] receiveMessageFromWorker() for ClusterFuture ...
[13:21:59.308] - Validating connection of MultisessionFuture
[13:21:59.308] - received message: FutureResult
[13:21:59.309] - Received FutureResult
[13:21:59.309] - Erased future from FutureRegistry
[13:21:59.309] result() for ClusterFuture ...
[13:21:59.309] - result already collected: FutureResult
[13:21:59.309] result() for ClusterFuture ... done
[13:21:59.309] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:59.309] Future #1
[13:21:59.309]  length: 0 (resolved future 1)
[13:21:59.309] resolve() on list ... DONE
[13:21:59.310] getGlobalsAndPackages() ...
[13:21:59.310] Searching for globals...
[13:21:59.310] 
[13:21:59.310] Searching for globals ... DONE
[13:21:59.310] - globals: [0] <none>
[13:21:59.310] getGlobalsAndPackages() ... DONE
[13:21:59.311] getGlobalsAndPackages() ...
[13:21:59.311] Searching for globals...
[13:21:59.311] 
[13:21:59.311] Searching for globals ... DONE
[13:21:59.311] - globals: [0] <none>
[13:21:59.311] getGlobalsAndPackages() ... DONE
[13:21:59.314] resolve() on list ...
[13:21:59.315]  recursive: 0
[13:21:59.315]  length: 3
[13:21:59.315]  elements: ‘a’, ‘b’, ‘’
[13:21:59.315] run() for ‘Future’ ...
[13:21:59.315] - state: ‘created’
[13:21:59.315] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:59.330] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:59.330] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:59.330]   - Field: ‘node’
[13:21:59.330]   - Field: ‘label’
[13:21:59.330]   - Field: ‘local’
[13:21:59.330]   - Field: ‘owner’
[13:21:59.330]   - Field: ‘envir’
[13:21:59.331]   - Field: ‘workers’
[13:21:59.331]   - Field: ‘packages’
[13:21:59.331]   - Field: ‘gc’
[13:21:59.331]   - Field: ‘conditions’
[13:21:59.331]   - Field: ‘persistent’
[13:21:59.331]   - Field: ‘expr’
[13:21:59.331]   - Field: ‘uuid’
[13:21:59.331]   - Field: ‘seed’
[13:21:59.331]   - Field: ‘version’
[13:21:59.331]   - Field: ‘result’
[13:21:59.331]   - Field: ‘asynchronous’
[13:21:59.332]   - Field: ‘calls’
[13:21:59.332]   - Field: ‘globals’
[13:21:59.332]   - Field: ‘stdout’
[13:21:59.332]   - Field: ‘earlySignal’
[13:21:59.332]   - Field: ‘lazy’
[13:21:59.332]   - Field: ‘state’
[13:21:59.332] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:59.332] - Launch lazy future ...
[13:21:59.332] Packages needed by the future expression (n = 0): <none>
[13:21:59.333] Packages needed by future strategies (n = 0): <none>
[13:21:59.333] {
[13:21:59.333]     {
[13:21:59.333]         {
[13:21:59.333]             ...future.startTime <- base::Sys.time()
[13:21:59.333]             {
[13:21:59.333]                 {
[13:21:59.333]                   {
[13:21:59.333]                     {
[13:21:59.333]                       base::local({
[13:21:59.333]                         has_future <- base::requireNamespace("future", 
[13:21:59.333]                           quietly = TRUE)
[13:21:59.333]                         if (has_future) {
[13:21:59.333]                           ns <- base::getNamespace("future")
[13:21:59.333]                           version <- ns[[".package"]][["version"]]
[13:21:59.333]                           if (is.null(version)) 
[13:21:59.333]                             version <- utils::packageVersion("future")
[13:21:59.333]                         }
[13:21:59.333]                         else {
[13:21:59.333]                           version <- NULL
[13:21:59.333]                         }
[13:21:59.333]                         if (!has_future || version < "1.8.0") {
[13:21:59.333]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:59.333]                             "", base::R.version$version.string), 
[13:21:59.333]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:59.333]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:59.333]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:59.333]                               "release", "version")], collapse = " "), 
[13:21:59.333]                             hostname = base::Sys.info()[["nodename"]])
[13:21:59.333]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:59.333]                             info)
[13:21:59.333]                           info <- base::paste(info, collapse = "; ")
[13:21:59.333]                           if (!has_future) {
[13:21:59.333]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:59.333]                               info)
[13:21:59.333]                           }
[13:21:59.333]                           else {
[13:21:59.333]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:59.333]                               info, version)
[13:21:59.333]                           }
[13:21:59.333]                           base::stop(msg)
[13:21:59.333]                         }
[13:21:59.333]                       })
[13:21:59.333]                     }
[13:21:59.333]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:59.333]                     base::options(mc.cores = 1L)
[13:21:59.333]                   }
[13:21:59.333]                   options(future.plan = NULL)
[13:21:59.333]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:59.333]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:59.333]                 }
[13:21:59.333]                 ...future.workdir <- getwd()
[13:21:59.333]             }
[13:21:59.333]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:59.333]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:59.333]         }
[13:21:59.333]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:59.333]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:59.333]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:59.333]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:59.333]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:59.333]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:59.333]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:59.333]             base::names(...future.oldOptions))
[13:21:59.333]     }
[13:21:59.333]     if (FALSE) {
[13:21:59.333]     }
[13:21:59.333]     else {
[13:21:59.333]         if (TRUE) {
[13:21:59.333]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:59.333]                 open = "w")
[13:21:59.333]         }
[13:21:59.333]         else {
[13:21:59.333]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:59.333]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:59.333]         }
[13:21:59.333]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:59.333]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:59.333]             base::sink(type = "output", split = FALSE)
[13:21:59.333]             base::close(...future.stdout)
[13:21:59.333]         }, add = TRUE)
[13:21:59.333]     }
[13:21:59.333]     ...future.frame <- base::sys.nframe()
[13:21:59.333]     ...future.conditions <- base::list()
[13:21:59.333]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:59.333]     if (FALSE) {
[13:21:59.333]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:59.333]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:59.333]     }
[13:21:59.333]     ...future.result <- base::tryCatch({
[13:21:59.333]         base::withCallingHandlers({
[13:21:59.333]             ...future.value <- base::withVisible(base::local({
[13:21:59.333]                 ...future.makeSendCondition <- local({
[13:21:59.333]                   sendCondition <- NULL
[13:21:59.333]                   function(frame = 1L) {
[13:21:59.333]                     if (is.function(sendCondition)) 
[13:21:59.333]                       return(sendCondition)
[13:21:59.333]                     ns <- getNamespace("parallel")
[13:21:59.333]                     if (exists("sendData", mode = "function", 
[13:21:59.333]                       envir = ns)) {
[13:21:59.333]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:59.333]                         envir = ns)
[13:21:59.333]                       envir <- sys.frame(frame)
[13:21:59.333]                       master <- NULL
[13:21:59.333]                       while (!identical(envir, .GlobalEnv) && 
[13:21:59.333]                         !identical(envir, emptyenv())) {
[13:21:59.333]                         if (exists("master", mode = "list", envir = envir, 
[13:21:59.333]                           inherits = FALSE)) {
[13:21:59.333]                           master <- get("master", mode = "list", 
[13:21:59.333]                             envir = envir, inherits = FALSE)
[13:21:59.333]                           if (inherits(master, c("SOCKnode", 
[13:21:59.333]                             "SOCK0node"))) {
[13:21:59.333]                             sendCondition <<- function(cond) {
[13:21:59.333]                               data <- list(type = "VALUE", value = cond, 
[13:21:59.333]                                 success = TRUE)
[13:21:59.333]                               parallel_sendData(master, data)
[13:21:59.333]                             }
[13:21:59.333]                             return(sendCondition)
[13:21:59.333]                           }
[13:21:59.333]                         }
[13:21:59.333]                         frame <- frame + 1L
[13:21:59.333]                         envir <- sys.frame(frame)
[13:21:59.333]                       }
[13:21:59.333]                     }
[13:21:59.333]                     sendCondition <<- function(cond) NULL
[13:21:59.333]                   }
[13:21:59.333]                 })
[13:21:59.333]                 withCallingHandlers({
[13:21:59.333]                   1
[13:21:59.333]                 }, immediateCondition = function(cond) {
[13:21:59.333]                   sendCondition <- ...future.makeSendCondition()
[13:21:59.333]                   sendCondition(cond)
[13:21:59.333]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:59.333]                   {
[13:21:59.333]                     inherits <- base::inherits
[13:21:59.333]                     invokeRestart <- base::invokeRestart
[13:21:59.333]                     is.null <- base::is.null
[13:21:59.333]                     muffled <- FALSE
[13:21:59.333]                     if (inherits(cond, "message")) {
[13:21:59.333]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:59.333]                       if (muffled) 
[13:21:59.333]                         invokeRestart("muffleMessage")
[13:21:59.333]                     }
[13:21:59.333]                     else if (inherits(cond, "warning")) {
[13:21:59.333]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:59.333]                       if (muffled) 
[13:21:59.333]                         invokeRestart("muffleWarning")
[13:21:59.333]                     }
[13:21:59.333]                     else if (inherits(cond, "condition")) {
[13:21:59.333]                       if (!is.null(pattern)) {
[13:21:59.333]                         computeRestarts <- base::computeRestarts
[13:21:59.333]                         grepl <- base::grepl
[13:21:59.333]                         restarts <- computeRestarts(cond)
[13:21:59.333]                         for (restart in restarts) {
[13:21:59.333]                           name <- restart$name
[13:21:59.333]                           if (is.null(name)) 
[13:21:59.333]                             next
[13:21:59.333]                           if (!grepl(pattern, name)) 
[13:21:59.333]                             next
[13:21:59.333]                           invokeRestart(restart)
[13:21:59.333]                           muffled <- TRUE
[13:21:59.333]                           break
[13:21:59.333]                         }
[13:21:59.333]                       }
[13:21:59.333]                     }
[13:21:59.333]                     invisible(muffled)
[13:21:59.333]                   }
[13:21:59.333]                   muffleCondition(cond)
[13:21:59.333]                 })
[13:21:59.333]             }))
[13:21:59.333]             future::FutureResult(value = ...future.value$value, 
[13:21:59.333]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:59.333]                   ...future.rng), globalenv = if (FALSE) 
[13:21:59.333]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:59.333]                     ...future.globalenv.names))
[13:21:59.333]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:59.333]         }, condition = base::local({
[13:21:59.333]             c <- base::c
[13:21:59.333]             inherits <- base::inherits
[13:21:59.333]             invokeRestart <- base::invokeRestart
[13:21:59.333]             length <- base::length
[13:21:59.333]             list <- base::list
[13:21:59.333]             seq.int <- base::seq.int
[13:21:59.333]             signalCondition <- base::signalCondition
[13:21:59.333]             sys.calls <- base::sys.calls
[13:21:59.333]             `[[` <- base::`[[`
[13:21:59.333]             `+` <- base::`+`
[13:21:59.333]             `<<-` <- base::`<<-`
[13:21:59.333]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:59.333]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:59.333]                   3L)]
[13:21:59.333]             }
[13:21:59.333]             function(cond) {
[13:21:59.333]                 is_error <- inherits(cond, "error")
[13:21:59.333]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:59.333]                   NULL)
[13:21:59.333]                 if (is_error) {
[13:21:59.333]                   sessionInformation <- function() {
[13:21:59.333]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:59.333]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:59.333]                       search = base::search(), system = base::Sys.info())
[13:21:59.333]                   }
[13:21:59.333]                   ...future.conditions[[length(...future.conditions) + 
[13:21:59.333]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:59.333]                     cond$call), session = sessionInformation(), 
[13:21:59.333]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:59.333]                   signalCondition(cond)
[13:21:59.333]                 }
[13:21:59.333]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:59.333]                 "immediateCondition"))) {
[13:21:59.333]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:59.333]                   ...future.conditions[[length(...future.conditions) + 
[13:21:59.333]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:59.333]                   if (TRUE && !signal) {
[13:21:59.333]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:59.333]                     {
[13:21:59.333]                       inherits <- base::inherits
[13:21:59.333]                       invokeRestart <- base::invokeRestart
[13:21:59.333]                       is.null <- base::is.null
[13:21:59.333]                       muffled <- FALSE
[13:21:59.333]                       if (inherits(cond, "message")) {
[13:21:59.333]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:59.333]                         if (muffled) 
[13:21:59.333]                           invokeRestart("muffleMessage")
[13:21:59.333]                       }
[13:21:59.333]                       else if (inherits(cond, "warning")) {
[13:21:59.333]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:59.333]                         if (muffled) 
[13:21:59.333]                           invokeRestart("muffleWarning")
[13:21:59.333]                       }
[13:21:59.333]                       else if (inherits(cond, "condition")) {
[13:21:59.333]                         if (!is.null(pattern)) {
[13:21:59.333]                           computeRestarts <- base::computeRestarts
[13:21:59.333]                           grepl <- base::grepl
[13:21:59.333]                           restarts <- computeRestarts(cond)
[13:21:59.333]                           for (restart in restarts) {
[13:21:59.333]                             name <- restart$name
[13:21:59.333]                             if (is.null(name)) 
[13:21:59.333]                               next
[13:21:59.333]                             if (!grepl(pattern, name)) 
[13:21:59.333]                               next
[13:21:59.333]                             invokeRestart(restart)
[13:21:59.333]                             muffled <- TRUE
[13:21:59.333]                             break
[13:21:59.333]                           }
[13:21:59.333]                         }
[13:21:59.333]                       }
[13:21:59.333]                       invisible(muffled)
[13:21:59.333]                     }
[13:21:59.333]                     muffleCondition(cond, pattern = "^muffle")
[13:21:59.333]                   }
[13:21:59.333]                 }
[13:21:59.333]                 else {
[13:21:59.333]                   if (TRUE) {
[13:21:59.333]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:59.333]                     {
[13:21:59.333]                       inherits <- base::inherits
[13:21:59.333]                       invokeRestart <- base::invokeRestart
[13:21:59.333]                       is.null <- base::is.null
[13:21:59.333]                       muffled <- FALSE
[13:21:59.333]                       if (inherits(cond, "message")) {
[13:21:59.333]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:59.333]                         if (muffled) 
[13:21:59.333]                           invokeRestart("muffleMessage")
[13:21:59.333]                       }
[13:21:59.333]                       else if (inherits(cond, "warning")) {
[13:21:59.333]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:59.333]                         if (muffled) 
[13:21:59.333]                           invokeRestart("muffleWarning")
[13:21:59.333]                       }
[13:21:59.333]                       else if (inherits(cond, "condition")) {
[13:21:59.333]                         if (!is.null(pattern)) {
[13:21:59.333]                           computeRestarts <- base::computeRestarts
[13:21:59.333]                           grepl <- base::grepl
[13:21:59.333]                           restarts <- computeRestarts(cond)
[13:21:59.333]                           for (restart in restarts) {
[13:21:59.333]                             name <- restart$name
[13:21:59.333]                             if (is.null(name)) 
[13:21:59.333]                               next
[13:21:59.333]                             if (!grepl(pattern, name)) 
[13:21:59.333]                               next
[13:21:59.333]                             invokeRestart(restart)
[13:21:59.333]                             muffled <- TRUE
[13:21:59.333]                             break
[13:21:59.333]                           }
[13:21:59.333]                         }
[13:21:59.333]                       }
[13:21:59.333]                       invisible(muffled)
[13:21:59.333]                     }
[13:21:59.333]                     muffleCondition(cond, pattern = "^muffle")
[13:21:59.333]                   }
[13:21:59.333]                 }
[13:21:59.333]             }
[13:21:59.333]         }))
[13:21:59.333]     }, error = function(ex) {
[13:21:59.333]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:59.333]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:59.333]                 ...future.rng), started = ...future.startTime, 
[13:21:59.333]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:59.333]             version = "1.8"), class = "FutureResult")
[13:21:59.333]     }, finally = {
[13:21:59.333]         if (!identical(...future.workdir, getwd())) 
[13:21:59.333]             setwd(...future.workdir)
[13:21:59.333]         {
[13:21:59.333]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:59.333]                 ...future.oldOptions$nwarnings <- NULL
[13:21:59.333]             }
[13:21:59.333]             base::options(...future.oldOptions)
[13:21:59.333]             if (.Platform$OS.type == "windows") {
[13:21:59.333]                 old_names <- names(...future.oldEnvVars)
[13:21:59.333]                 envs <- base::Sys.getenv()
[13:21:59.333]                 names <- names(envs)
[13:21:59.333]                 common <- intersect(names, old_names)
[13:21:59.333]                 added <- setdiff(names, old_names)
[13:21:59.333]                 removed <- setdiff(old_names, names)
[13:21:59.333]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:59.333]                   envs[common]]
[13:21:59.333]                 NAMES <- toupper(changed)
[13:21:59.333]                 args <- list()
[13:21:59.333]                 for (kk in seq_along(NAMES)) {
[13:21:59.333]                   name <- changed[[kk]]
[13:21:59.333]                   NAME <- NAMES[[kk]]
[13:21:59.333]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:59.333]                     next
[13:21:59.333]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:59.333]                 }
[13:21:59.333]                 NAMES <- toupper(added)
[13:21:59.333]                 for (kk in seq_along(NAMES)) {
[13:21:59.333]                   name <- added[[kk]]
[13:21:59.333]                   NAME <- NAMES[[kk]]
[13:21:59.333]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:59.333]                     next
[13:21:59.333]                   args[[name]] <- ""
[13:21:59.333]                 }
[13:21:59.333]                 NAMES <- toupper(removed)
[13:21:59.333]                 for (kk in seq_along(NAMES)) {
[13:21:59.333]                   name <- removed[[kk]]
[13:21:59.333]                   NAME <- NAMES[[kk]]
[13:21:59.333]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:59.333]                     next
[13:21:59.333]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:59.333]                 }
[13:21:59.333]                 if (length(args) > 0) 
[13:21:59.333]                   base::do.call(base::Sys.setenv, args = args)
[13:21:59.333]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:59.333]             }
[13:21:59.333]             else {
[13:21:59.333]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:59.333]             }
[13:21:59.333]             {
[13:21:59.333]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:59.333]                   0L) {
[13:21:59.333]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:59.333]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:59.333]                   base::options(opts)
[13:21:59.333]                 }
[13:21:59.333]                 {
[13:21:59.333]                   {
[13:21:59.333]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:59.333]                     NULL
[13:21:59.333]                   }
[13:21:59.333]                   options(future.plan = NULL)
[13:21:59.333]                   if (is.na(NA_character_)) 
[13:21:59.333]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:59.333]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:59.333]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:59.333]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:59.333]                     envir = parent.frame()) 
[13:21:59.333]                   {
[13:21:59.333]                     if (is.function(workers)) 
[13:21:59.333]                       workers <- workers()
[13:21:59.333]                     workers <- structure(as.integer(workers), 
[13:21:59.333]                       class = class(workers))
[13:21:59.333]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:59.333]                       workers >= 1)
[13:21:59.333]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:59.333]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:59.333]                     }
[13:21:59.333]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:59.333]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:59.333]                       envir = envir)
[13:21:59.333]                     if (!future$lazy) 
[13:21:59.333]                       future <- run(future)
[13:21:59.333]                     invisible(future)
[13:21:59.333]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:59.333]                 }
[13:21:59.333]             }
[13:21:59.333]         }
[13:21:59.333]     })
[13:21:59.333]     if (TRUE) {
[13:21:59.333]         base::sink(type = "output", split = FALSE)
[13:21:59.333]         if (TRUE) {
[13:21:59.333]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:59.333]         }
[13:21:59.333]         else {
[13:21:59.333]             ...future.result["stdout"] <- base::list(NULL)
[13:21:59.333]         }
[13:21:59.333]         base::close(...future.stdout)
[13:21:59.333]         ...future.stdout <- NULL
[13:21:59.333]     }
[13:21:59.333]     ...future.result$conditions <- ...future.conditions
[13:21:59.333]     ...future.result$finished <- base::Sys.time()
[13:21:59.333]     ...future.result
[13:21:59.333] }
[13:21:59.336] MultisessionFuture started
[13:21:59.336] - Launch lazy future ... done
[13:21:59.336] run() for ‘MultisessionFuture’ ... done
[13:21:59.347] run() for ‘Future’ ...
[13:21:59.347] - state: ‘created’
[13:21:59.347] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:59.362] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:59.362] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:59.363]   - Field: ‘node’
[13:21:59.363]   - Field: ‘label’
[13:21:59.363]   - Field: ‘local’
[13:21:59.363]   - Field: ‘owner’
[13:21:59.363]   - Field: ‘envir’
[13:21:59.363]   - Field: ‘workers’
[13:21:59.363]   - Field: ‘packages’
[13:21:59.363]   - Field: ‘gc’
[13:21:59.363]   - Field: ‘conditions’
[13:21:59.363]   - Field: ‘persistent’
[13:21:59.364]   - Field: ‘expr’
[13:21:59.364]   - Field: ‘uuid’
[13:21:59.364]   - Field: ‘seed’
[13:21:59.364]   - Field: ‘version’
[13:21:59.364]   - Field: ‘result’
[13:21:59.364]   - Field: ‘asynchronous’
[13:21:59.364]   - Field: ‘calls’
[13:21:59.364]   - Field: ‘globals’
[13:21:59.364]   - Field: ‘stdout’
[13:21:59.364]   - Field: ‘earlySignal’
[13:21:59.364]   - Field: ‘lazy’
[13:21:59.365]   - Field: ‘state’
[13:21:59.365] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:59.365] - Launch lazy future ...
[13:21:59.365] Packages needed by the future expression (n = 0): <none>
[13:21:59.365] Packages needed by future strategies (n = 0): <none>
[13:21:59.366] {
[13:21:59.366]     {
[13:21:59.366]         {
[13:21:59.366]             ...future.startTime <- base::Sys.time()
[13:21:59.366]             {
[13:21:59.366]                 {
[13:21:59.366]                   {
[13:21:59.366]                     {
[13:21:59.366]                       base::local({
[13:21:59.366]                         has_future <- base::requireNamespace("future", 
[13:21:59.366]                           quietly = TRUE)
[13:21:59.366]                         if (has_future) {
[13:21:59.366]                           ns <- base::getNamespace("future")
[13:21:59.366]                           version <- ns[[".package"]][["version"]]
[13:21:59.366]                           if (is.null(version)) 
[13:21:59.366]                             version <- utils::packageVersion("future")
[13:21:59.366]                         }
[13:21:59.366]                         else {
[13:21:59.366]                           version <- NULL
[13:21:59.366]                         }
[13:21:59.366]                         if (!has_future || version < "1.8.0") {
[13:21:59.366]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:59.366]                             "", base::R.version$version.string), 
[13:21:59.366]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:59.366]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:59.366]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:59.366]                               "release", "version")], collapse = " "), 
[13:21:59.366]                             hostname = base::Sys.info()[["nodename"]])
[13:21:59.366]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:59.366]                             info)
[13:21:59.366]                           info <- base::paste(info, collapse = "; ")
[13:21:59.366]                           if (!has_future) {
[13:21:59.366]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:59.366]                               info)
[13:21:59.366]                           }
[13:21:59.366]                           else {
[13:21:59.366]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:59.366]                               info, version)
[13:21:59.366]                           }
[13:21:59.366]                           base::stop(msg)
[13:21:59.366]                         }
[13:21:59.366]                       })
[13:21:59.366]                     }
[13:21:59.366]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:59.366]                     base::options(mc.cores = 1L)
[13:21:59.366]                   }
[13:21:59.366]                   options(future.plan = NULL)
[13:21:59.366]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:59.366]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:59.366]                 }
[13:21:59.366]                 ...future.workdir <- getwd()
[13:21:59.366]             }
[13:21:59.366]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:59.366]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:59.366]         }
[13:21:59.366]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:59.366]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:59.366]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:59.366]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:59.366]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:59.366]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:59.366]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:59.366]             base::names(...future.oldOptions))
[13:21:59.366]     }
[13:21:59.366]     if (FALSE) {
[13:21:59.366]     }
[13:21:59.366]     else {
[13:21:59.366]         if (TRUE) {
[13:21:59.366]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:59.366]                 open = "w")
[13:21:59.366]         }
[13:21:59.366]         else {
[13:21:59.366]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:59.366]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:59.366]         }
[13:21:59.366]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:59.366]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:59.366]             base::sink(type = "output", split = FALSE)
[13:21:59.366]             base::close(...future.stdout)
[13:21:59.366]         }, add = TRUE)
[13:21:59.366]     }
[13:21:59.366]     ...future.frame <- base::sys.nframe()
[13:21:59.366]     ...future.conditions <- base::list()
[13:21:59.366]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:59.366]     if (FALSE) {
[13:21:59.366]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:59.366]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:59.366]     }
[13:21:59.366]     ...future.result <- base::tryCatch({
[13:21:59.366]         base::withCallingHandlers({
[13:21:59.366]             ...future.value <- base::withVisible(base::local({
[13:21:59.366]                 ...future.makeSendCondition <- local({
[13:21:59.366]                   sendCondition <- NULL
[13:21:59.366]                   function(frame = 1L) {
[13:21:59.366]                     if (is.function(sendCondition)) 
[13:21:59.366]                       return(sendCondition)
[13:21:59.366]                     ns <- getNamespace("parallel")
[13:21:59.366]                     if (exists("sendData", mode = "function", 
[13:21:59.366]                       envir = ns)) {
[13:21:59.366]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:59.366]                         envir = ns)
[13:21:59.366]                       envir <- sys.frame(frame)
[13:21:59.366]                       master <- NULL
[13:21:59.366]                       while (!identical(envir, .GlobalEnv) && 
[13:21:59.366]                         !identical(envir, emptyenv())) {
[13:21:59.366]                         if (exists("master", mode = "list", envir = envir, 
[13:21:59.366]                           inherits = FALSE)) {
[13:21:59.366]                           master <- get("master", mode = "list", 
[13:21:59.366]                             envir = envir, inherits = FALSE)
[13:21:59.366]                           if (inherits(master, c("SOCKnode", 
[13:21:59.366]                             "SOCK0node"))) {
[13:21:59.366]                             sendCondition <<- function(cond) {
[13:21:59.366]                               data <- list(type = "VALUE", value = cond, 
[13:21:59.366]                                 success = TRUE)
[13:21:59.366]                               parallel_sendData(master, data)
[13:21:59.366]                             }
[13:21:59.366]                             return(sendCondition)
[13:21:59.366]                           }
[13:21:59.366]                         }
[13:21:59.366]                         frame <- frame + 1L
[13:21:59.366]                         envir <- sys.frame(frame)
[13:21:59.366]                       }
[13:21:59.366]                     }
[13:21:59.366]                     sendCondition <<- function(cond) NULL
[13:21:59.366]                   }
[13:21:59.366]                 })
[13:21:59.366]                 withCallingHandlers({
[13:21:59.366]                   2
[13:21:59.366]                 }, immediateCondition = function(cond) {
[13:21:59.366]                   sendCondition <- ...future.makeSendCondition()
[13:21:59.366]                   sendCondition(cond)
[13:21:59.366]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:59.366]                   {
[13:21:59.366]                     inherits <- base::inherits
[13:21:59.366]                     invokeRestart <- base::invokeRestart
[13:21:59.366]                     is.null <- base::is.null
[13:21:59.366]                     muffled <- FALSE
[13:21:59.366]                     if (inherits(cond, "message")) {
[13:21:59.366]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:59.366]                       if (muffled) 
[13:21:59.366]                         invokeRestart("muffleMessage")
[13:21:59.366]                     }
[13:21:59.366]                     else if (inherits(cond, "warning")) {
[13:21:59.366]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:59.366]                       if (muffled) 
[13:21:59.366]                         invokeRestart("muffleWarning")
[13:21:59.366]                     }
[13:21:59.366]                     else if (inherits(cond, "condition")) {
[13:21:59.366]                       if (!is.null(pattern)) {
[13:21:59.366]                         computeRestarts <- base::computeRestarts
[13:21:59.366]                         grepl <- base::grepl
[13:21:59.366]                         restarts <- computeRestarts(cond)
[13:21:59.366]                         for (restart in restarts) {
[13:21:59.366]                           name <- restart$name
[13:21:59.366]                           if (is.null(name)) 
[13:21:59.366]                             next
[13:21:59.366]                           if (!grepl(pattern, name)) 
[13:21:59.366]                             next
[13:21:59.366]                           invokeRestart(restart)
[13:21:59.366]                           muffled <- TRUE
[13:21:59.366]                           break
[13:21:59.366]                         }
[13:21:59.366]                       }
[13:21:59.366]                     }
[13:21:59.366]                     invisible(muffled)
[13:21:59.366]                   }
[13:21:59.366]                   muffleCondition(cond)
[13:21:59.366]                 })
[13:21:59.366]             }))
[13:21:59.366]             future::FutureResult(value = ...future.value$value, 
[13:21:59.366]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:59.366]                   ...future.rng), globalenv = if (FALSE) 
[13:21:59.366]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:59.366]                     ...future.globalenv.names))
[13:21:59.366]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:59.366]         }, condition = base::local({
[13:21:59.366]             c <- base::c
[13:21:59.366]             inherits <- base::inherits
[13:21:59.366]             invokeRestart <- base::invokeRestart
[13:21:59.366]             length <- base::length
[13:21:59.366]             list <- base::list
[13:21:59.366]             seq.int <- base::seq.int
[13:21:59.366]             signalCondition <- base::signalCondition
[13:21:59.366]             sys.calls <- base::sys.calls
[13:21:59.366]             `[[` <- base::`[[`
[13:21:59.366]             `+` <- base::`+`
[13:21:59.366]             `<<-` <- base::`<<-`
[13:21:59.366]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:59.366]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:59.366]                   3L)]
[13:21:59.366]             }
[13:21:59.366]             function(cond) {
[13:21:59.366]                 is_error <- inherits(cond, "error")
[13:21:59.366]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:59.366]                   NULL)
[13:21:59.366]                 if (is_error) {
[13:21:59.366]                   sessionInformation <- function() {
[13:21:59.366]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:59.366]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:59.366]                       search = base::search(), system = base::Sys.info())
[13:21:59.366]                   }
[13:21:59.366]                   ...future.conditions[[length(...future.conditions) + 
[13:21:59.366]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:59.366]                     cond$call), session = sessionInformation(), 
[13:21:59.366]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:59.366]                   signalCondition(cond)
[13:21:59.366]                 }
[13:21:59.366]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:59.366]                 "immediateCondition"))) {
[13:21:59.366]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:59.366]                   ...future.conditions[[length(...future.conditions) + 
[13:21:59.366]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:59.366]                   if (TRUE && !signal) {
[13:21:59.366]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:59.366]                     {
[13:21:59.366]                       inherits <- base::inherits
[13:21:59.366]                       invokeRestart <- base::invokeRestart
[13:21:59.366]                       is.null <- base::is.null
[13:21:59.366]                       muffled <- FALSE
[13:21:59.366]                       if (inherits(cond, "message")) {
[13:21:59.366]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:59.366]                         if (muffled) 
[13:21:59.366]                           invokeRestart("muffleMessage")
[13:21:59.366]                       }
[13:21:59.366]                       else if (inherits(cond, "warning")) {
[13:21:59.366]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:59.366]                         if (muffled) 
[13:21:59.366]                           invokeRestart("muffleWarning")
[13:21:59.366]                       }
[13:21:59.366]                       else if (inherits(cond, "condition")) {
[13:21:59.366]                         if (!is.null(pattern)) {
[13:21:59.366]                           computeRestarts <- base::computeRestarts
[13:21:59.366]                           grepl <- base::grepl
[13:21:59.366]                           restarts <- computeRestarts(cond)
[13:21:59.366]                           for (restart in restarts) {
[13:21:59.366]                             name <- restart$name
[13:21:59.366]                             if (is.null(name)) 
[13:21:59.366]                               next
[13:21:59.366]                             if (!grepl(pattern, name)) 
[13:21:59.366]                               next
[13:21:59.366]                             invokeRestart(restart)
[13:21:59.366]                             muffled <- TRUE
[13:21:59.366]                             break
[13:21:59.366]                           }
[13:21:59.366]                         }
[13:21:59.366]                       }
[13:21:59.366]                       invisible(muffled)
[13:21:59.366]                     }
[13:21:59.366]                     muffleCondition(cond, pattern = "^muffle")
[13:21:59.366]                   }
[13:21:59.366]                 }
[13:21:59.366]                 else {
[13:21:59.366]                   if (TRUE) {
[13:21:59.366]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:59.366]                     {
[13:21:59.366]                       inherits <- base::inherits
[13:21:59.366]                       invokeRestart <- base::invokeRestart
[13:21:59.366]                       is.null <- base::is.null
[13:21:59.366]                       muffled <- FALSE
[13:21:59.366]                       if (inherits(cond, "message")) {
[13:21:59.366]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:59.366]                         if (muffled) 
[13:21:59.366]                           invokeRestart("muffleMessage")
[13:21:59.366]                       }
[13:21:59.366]                       else if (inherits(cond, "warning")) {
[13:21:59.366]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:59.366]                         if (muffled) 
[13:21:59.366]                           invokeRestart("muffleWarning")
[13:21:59.366]                       }
[13:21:59.366]                       else if (inherits(cond, "condition")) {
[13:21:59.366]                         if (!is.null(pattern)) {
[13:21:59.366]                           computeRestarts <- base::computeRestarts
[13:21:59.366]                           grepl <- base::grepl
[13:21:59.366]                           restarts <- computeRestarts(cond)
[13:21:59.366]                           for (restart in restarts) {
[13:21:59.366]                             name <- restart$name
[13:21:59.366]                             if (is.null(name)) 
[13:21:59.366]                               next
[13:21:59.366]                             if (!grepl(pattern, name)) 
[13:21:59.366]                               next
[13:21:59.366]                             invokeRestart(restart)
[13:21:59.366]                             muffled <- TRUE
[13:21:59.366]                             break
[13:21:59.366]                           }
[13:21:59.366]                         }
[13:21:59.366]                       }
[13:21:59.366]                       invisible(muffled)
[13:21:59.366]                     }
[13:21:59.366]                     muffleCondition(cond, pattern = "^muffle")
[13:21:59.366]                   }
[13:21:59.366]                 }
[13:21:59.366]             }
[13:21:59.366]         }))
[13:21:59.366]     }, error = function(ex) {
[13:21:59.366]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:59.366]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:59.366]                 ...future.rng), started = ...future.startTime, 
[13:21:59.366]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:59.366]             version = "1.8"), class = "FutureResult")
[13:21:59.366]     }, finally = {
[13:21:59.366]         if (!identical(...future.workdir, getwd())) 
[13:21:59.366]             setwd(...future.workdir)
[13:21:59.366]         {
[13:21:59.366]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:59.366]                 ...future.oldOptions$nwarnings <- NULL
[13:21:59.366]             }
[13:21:59.366]             base::options(...future.oldOptions)
[13:21:59.366]             if (.Platform$OS.type == "windows") {
[13:21:59.366]                 old_names <- names(...future.oldEnvVars)
[13:21:59.366]                 envs <- base::Sys.getenv()
[13:21:59.366]                 names <- names(envs)
[13:21:59.366]                 common <- intersect(names, old_names)
[13:21:59.366]                 added <- setdiff(names, old_names)
[13:21:59.366]                 removed <- setdiff(old_names, names)
[13:21:59.366]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:59.366]                   envs[common]]
[13:21:59.366]                 NAMES <- toupper(changed)
[13:21:59.366]                 args <- list()
[13:21:59.366]                 for (kk in seq_along(NAMES)) {
[13:21:59.366]                   name <- changed[[kk]]
[13:21:59.366]                   NAME <- NAMES[[kk]]
[13:21:59.366]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:59.366]                     next
[13:21:59.366]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:59.366]                 }
[13:21:59.366]                 NAMES <- toupper(added)
[13:21:59.366]                 for (kk in seq_along(NAMES)) {
[13:21:59.366]                   name <- added[[kk]]
[13:21:59.366]                   NAME <- NAMES[[kk]]
[13:21:59.366]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:59.366]                     next
[13:21:59.366]                   args[[name]] <- ""
[13:21:59.366]                 }
[13:21:59.366]                 NAMES <- toupper(removed)
[13:21:59.366]                 for (kk in seq_along(NAMES)) {
[13:21:59.366]                   name <- removed[[kk]]
[13:21:59.366]                   NAME <- NAMES[[kk]]
[13:21:59.366]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:59.366]                     next
[13:21:59.366]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:59.366]                 }
[13:21:59.366]                 if (length(args) > 0) 
[13:21:59.366]                   base::do.call(base::Sys.setenv, args = args)
[13:21:59.366]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:59.366]             }
[13:21:59.366]             else {
[13:21:59.366]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:59.366]             }
[13:21:59.366]             {
[13:21:59.366]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:59.366]                   0L) {
[13:21:59.366]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:59.366]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:59.366]                   base::options(opts)
[13:21:59.366]                 }
[13:21:59.366]                 {
[13:21:59.366]                   {
[13:21:59.366]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:59.366]                     NULL
[13:21:59.366]                   }
[13:21:59.366]                   options(future.plan = NULL)
[13:21:59.366]                   if (is.na(NA_character_)) 
[13:21:59.366]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:59.366]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:59.366]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:59.366]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:59.366]                     envir = parent.frame()) 
[13:21:59.366]                   {
[13:21:59.366]                     if (is.function(workers)) 
[13:21:59.366]                       workers <- workers()
[13:21:59.366]                     workers <- structure(as.integer(workers), 
[13:21:59.366]                       class = class(workers))
[13:21:59.366]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:59.366]                       workers >= 1)
[13:21:59.366]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:59.366]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:59.366]                     }
[13:21:59.366]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:59.366]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:59.366]                       envir = envir)
[13:21:59.366]                     if (!future$lazy) 
[13:21:59.366]                       future <- run(future)
[13:21:59.366]                     invisible(future)
[13:21:59.366]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:59.366]                 }
[13:21:59.366]             }
[13:21:59.366]         }
[13:21:59.366]     })
[13:21:59.366]     if (TRUE) {
[13:21:59.366]         base::sink(type = "output", split = FALSE)
[13:21:59.366]         if (TRUE) {
[13:21:59.366]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:59.366]         }
[13:21:59.366]         else {
[13:21:59.366]             ...future.result["stdout"] <- base::list(NULL)
[13:21:59.366]         }
[13:21:59.366]         base::close(...future.stdout)
[13:21:59.366]         ...future.stdout <- NULL
[13:21:59.366]     }
[13:21:59.366]     ...future.result$conditions <- ...future.conditions
[13:21:59.366]     ...future.result$finished <- base::Sys.time()
[13:21:59.366]     ...future.result
[13:21:59.366] }
[13:21:59.369] MultisessionFuture started
[13:21:59.369] - Launch lazy future ... done
[13:21:59.369] run() for ‘MultisessionFuture’ ... done
[13:21:59.380]  length: 2 (resolved future 3)
[13:21:59.390] receiveMessageFromWorker() for ClusterFuture ...
[13:21:59.390] - Validating connection of MultisessionFuture
[13:21:59.391] - received message: FutureResult
[13:21:59.391] - Received FutureResult
[13:21:59.391] - Erased future from FutureRegistry
[13:21:59.391] result() for ClusterFuture ...
[13:21:59.391] - result already collected: FutureResult
[13:21:59.391] result() for ClusterFuture ... done
[13:21:59.391] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:59.391] Future #1
[13:21:59.391]  length: 1 (resolved future 1)
[13:21:59.418] receiveMessageFromWorker() for ClusterFuture ...
[13:21:59.418] - Validating connection of MultisessionFuture
[13:21:59.418] - received message: FutureResult
[13:21:59.418] - Received FutureResult
[13:21:59.419] - Erased future from FutureRegistry
[13:21:59.419] result() for ClusterFuture ...
[13:21:59.419] - result already collected: FutureResult
[13:21:59.419] result() for ClusterFuture ... done
[13:21:59.419] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:59.419] Future #2
[13:21:59.419]  length: 0 (resolved future 2)
[13:21:59.419] resolve() on list ... DONE
[13:21:59.419] getGlobalsAndPackages() ...
[13:21:59.419] Searching for globals...
[13:21:59.420] 
[13:21:59.420] Searching for globals ... DONE
[13:21:59.420] - globals: [0] <none>
[13:21:59.420] getGlobalsAndPackages() ... DONE
[13:21:59.420] run() for ‘Future’ ...
[13:21:59.420] - state: ‘created’
[13:21:59.421] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:59.436] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:59.436] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:59.436]   - Field: ‘node’
[13:21:59.436]   - Field: ‘label’
[13:21:59.437]   - Field: ‘local’
[13:21:59.437]   - Field: ‘owner’
[13:21:59.437]   - Field: ‘envir’
[13:21:59.437]   - Field: ‘workers’
[13:21:59.437]   - Field: ‘packages’
[13:21:59.437]   - Field: ‘gc’
[13:21:59.437]   - Field: ‘conditions’
[13:21:59.437]   - Field: ‘persistent’
[13:21:59.437]   - Field: ‘expr’
[13:21:59.438]   - Field: ‘uuid’
[13:21:59.438]   - Field: ‘seed’
[13:21:59.438]   - Field: ‘version’
[13:21:59.438]   - Field: ‘result’
[13:21:59.438]   - Field: ‘asynchronous’
[13:21:59.438]   - Field: ‘calls’
[13:21:59.438]   - Field: ‘globals’
[13:21:59.438]   - Field: ‘stdout’
[13:21:59.438]   - Field: ‘earlySignal’
[13:21:59.438]   - Field: ‘lazy’
[13:21:59.438]   - Field: ‘state’
[13:21:59.438] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:59.439] - Launch lazy future ...
[13:21:59.439] Packages needed by the future expression (n = 0): <none>
[13:21:59.439] Packages needed by future strategies (n = 0): <none>
[13:21:59.439] {
[13:21:59.439]     {
[13:21:59.439]         {
[13:21:59.439]             ...future.startTime <- base::Sys.time()
[13:21:59.439]             {
[13:21:59.439]                 {
[13:21:59.439]                   {
[13:21:59.439]                     {
[13:21:59.439]                       base::local({
[13:21:59.439]                         has_future <- base::requireNamespace("future", 
[13:21:59.439]                           quietly = TRUE)
[13:21:59.439]                         if (has_future) {
[13:21:59.439]                           ns <- base::getNamespace("future")
[13:21:59.439]                           version <- ns[[".package"]][["version"]]
[13:21:59.439]                           if (is.null(version)) 
[13:21:59.439]                             version <- utils::packageVersion("future")
[13:21:59.439]                         }
[13:21:59.439]                         else {
[13:21:59.439]                           version <- NULL
[13:21:59.439]                         }
[13:21:59.439]                         if (!has_future || version < "1.8.0") {
[13:21:59.439]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:59.439]                             "", base::R.version$version.string), 
[13:21:59.439]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:59.439]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:59.439]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:59.439]                               "release", "version")], collapse = " "), 
[13:21:59.439]                             hostname = base::Sys.info()[["nodename"]])
[13:21:59.439]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:59.439]                             info)
[13:21:59.439]                           info <- base::paste(info, collapse = "; ")
[13:21:59.439]                           if (!has_future) {
[13:21:59.439]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:59.439]                               info)
[13:21:59.439]                           }
[13:21:59.439]                           else {
[13:21:59.439]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:59.439]                               info, version)
[13:21:59.439]                           }
[13:21:59.439]                           base::stop(msg)
[13:21:59.439]                         }
[13:21:59.439]                       })
[13:21:59.439]                     }
[13:21:59.439]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:59.439]                     base::options(mc.cores = 1L)
[13:21:59.439]                   }
[13:21:59.439]                   options(future.plan = NULL)
[13:21:59.439]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:59.439]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:59.439]                 }
[13:21:59.439]                 ...future.workdir <- getwd()
[13:21:59.439]             }
[13:21:59.439]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:59.439]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:59.439]         }
[13:21:59.439]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:59.439]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:59.439]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:59.439]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:59.439]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:59.439]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:59.439]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:59.439]             base::names(...future.oldOptions))
[13:21:59.439]     }
[13:21:59.439]     if (FALSE) {
[13:21:59.439]     }
[13:21:59.439]     else {
[13:21:59.439]         if (TRUE) {
[13:21:59.439]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:59.439]                 open = "w")
[13:21:59.439]         }
[13:21:59.439]         else {
[13:21:59.439]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:59.439]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:59.439]         }
[13:21:59.439]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:59.439]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:59.439]             base::sink(type = "output", split = FALSE)
[13:21:59.439]             base::close(...future.stdout)
[13:21:59.439]         }, add = TRUE)
[13:21:59.439]     }
[13:21:59.439]     ...future.frame <- base::sys.nframe()
[13:21:59.439]     ...future.conditions <- base::list()
[13:21:59.439]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:59.439]     if (FALSE) {
[13:21:59.439]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:59.439]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:59.439]     }
[13:21:59.439]     ...future.result <- base::tryCatch({
[13:21:59.439]         base::withCallingHandlers({
[13:21:59.439]             ...future.value <- base::withVisible(base::local({
[13:21:59.439]                 ...future.makeSendCondition <- local({
[13:21:59.439]                   sendCondition <- NULL
[13:21:59.439]                   function(frame = 1L) {
[13:21:59.439]                     if (is.function(sendCondition)) 
[13:21:59.439]                       return(sendCondition)
[13:21:59.439]                     ns <- getNamespace("parallel")
[13:21:59.439]                     if (exists("sendData", mode = "function", 
[13:21:59.439]                       envir = ns)) {
[13:21:59.439]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:59.439]                         envir = ns)
[13:21:59.439]                       envir <- sys.frame(frame)
[13:21:59.439]                       master <- NULL
[13:21:59.439]                       while (!identical(envir, .GlobalEnv) && 
[13:21:59.439]                         !identical(envir, emptyenv())) {
[13:21:59.439]                         if (exists("master", mode = "list", envir = envir, 
[13:21:59.439]                           inherits = FALSE)) {
[13:21:59.439]                           master <- get("master", mode = "list", 
[13:21:59.439]                             envir = envir, inherits = FALSE)
[13:21:59.439]                           if (inherits(master, c("SOCKnode", 
[13:21:59.439]                             "SOCK0node"))) {
[13:21:59.439]                             sendCondition <<- function(cond) {
[13:21:59.439]                               data <- list(type = "VALUE", value = cond, 
[13:21:59.439]                                 success = TRUE)
[13:21:59.439]                               parallel_sendData(master, data)
[13:21:59.439]                             }
[13:21:59.439]                             return(sendCondition)
[13:21:59.439]                           }
[13:21:59.439]                         }
[13:21:59.439]                         frame <- frame + 1L
[13:21:59.439]                         envir <- sys.frame(frame)
[13:21:59.439]                       }
[13:21:59.439]                     }
[13:21:59.439]                     sendCondition <<- function(cond) NULL
[13:21:59.439]                   }
[13:21:59.439]                 })
[13:21:59.439]                 withCallingHandlers({
[13:21:59.439]                   1
[13:21:59.439]                 }, immediateCondition = function(cond) {
[13:21:59.439]                   sendCondition <- ...future.makeSendCondition()
[13:21:59.439]                   sendCondition(cond)
[13:21:59.439]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:59.439]                   {
[13:21:59.439]                     inherits <- base::inherits
[13:21:59.439]                     invokeRestart <- base::invokeRestart
[13:21:59.439]                     is.null <- base::is.null
[13:21:59.439]                     muffled <- FALSE
[13:21:59.439]                     if (inherits(cond, "message")) {
[13:21:59.439]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:59.439]                       if (muffled) 
[13:21:59.439]                         invokeRestart("muffleMessage")
[13:21:59.439]                     }
[13:21:59.439]                     else if (inherits(cond, "warning")) {
[13:21:59.439]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:59.439]                       if (muffled) 
[13:21:59.439]                         invokeRestart("muffleWarning")
[13:21:59.439]                     }
[13:21:59.439]                     else if (inherits(cond, "condition")) {
[13:21:59.439]                       if (!is.null(pattern)) {
[13:21:59.439]                         computeRestarts <- base::computeRestarts
[13:21:59.439]                         grepl <- base::grepl
[13:21:59.439]                         restarts <- computeRestarts(cond)
[13:21:59.439]                         for (restart in restarts) {
[13:21:59.439]                           name <- restart$name
[13:21:59.439]                           if (is.null(name)) 
[13:21:59.439]                             next
[13:21:59.439]                           if (!grepl(pattern, name)) 
[13:21:59.439]                             next
[13:21:59.439]                           invokeRestart(restart)
[13:21:59.439]                           muffled <- TRUE
[13:21:59.439]                           break
[13:21:59.439]                         }
[13:21:59.439]                       }
[13:21:59.439]                     }
[13:21:59.439]                     invisible(muffled)
[13:21:59.439]                   }
[13:21:59.439]                   muffleCondition(cond)
[13:21:59.439]                 })
[13:21:59.439]             }))
[13:21:59.439]             future::FutureResult(value = ...future.value$value, 
[13:21:59.439]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:59.439]                   ...future.rng), globalenv = if (FALSE) 
[13:21:59.439]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:59.439]                     ...future.globalenv.names))
[13:21:59.439]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:59.439]         }, condition = base::local({
[13:21:59.439]             c <- base::c
[13:21:59.439]             inherits <- base::inherits
[13:21:59.439]             invokeRestart <- base::invokeRestart
[13:21:59.439]             length <- base::length
[13:21:59.439]             list <- base::list
[13:21:59.439]             seq.int <- base::seq.int
[13:21:59.439]             signalCondition <- base::signalCondition
[13:21:59.439]             sys.calls <- base::sys.calls
[13:21:59.439]             `[[` <- base::`[[`
[13:21:59.439]             `+` <- base::`+`
[13:21:59.439]             `<<-` <- base::`<<-`
[13:21:59.439]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:59.439]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:59.439]                   3L)]
[13:21:59.439]             }
[13:21:59.439]             function(cond) {
[13:21:59.439]                 is_error <- inherits(cond, "error")
[13:21:59.439]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:59.439]                   NULL)
[13:21:59.439]                 if (is_error) {
[13:21:59.439]                   sessionInformation <- function() {
[13:21:59.439]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:59.439]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:59.439]                       search = base::search(), system = base::Sys.info())
[13:21:59.439]                   }
[13:21:59.439]                   ...future.conditions[[length(...future.conditions) + 
[13:21:59.439]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:59.439]                     cond$call), session = sessionInformation(), 
[13:21:59.439]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:59.439]                   signalCondition(cond)
[13:21:59.439]                 }
[13:21:59.439]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:59.439]                 "immediateCondition"))) {
[13:21:59.439]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:59.439]                   ...future.conditions[[length(...future.conditions) + 
[13:21:59.439]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:59.439]                   if (TRUE && !signal) {
[13:21:59.439]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:59.439]                     {
[13:21:59.439]                       inherits <- base::inherits
[13:21:59.439]                       invokeRestart <- base::invokeRestart
[13:21:59.439]                       is.null <- base::is.null
[13:21:59.439]                       muffled <- FALSE
[13:21:59.439]                       if (inherits(cond, "message")) {
[13:21:59.439]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:59.439]                         if (muffled) 
[13:21:59.439]                           invokeRestart("muffleMessage")
[13:21:59.439]                       }
[13:21:59.439]                       else if (inherits(cond, "warning")) {
[13:21:59.439]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:59.439]                         if (muffled) 
[13:21:59.439]                           invokeRestart("muffleWarning")
[13:21:59.439]                       }
[13:21:59.439]                       else if (inherits(cond, "condition")) {
[13:21:59.439]                         if (!is.null(pattern)) {
[13:21:59.439]                           computeRestarts <- base::computeRestarts
[13:21:59.439]                           grepl <- base::grepl
[13:21:59.439]                           restarts <- computeRestarts(cond)
[13:21:59.439]                           for (restart in restarts) {
[13:21:59.439]                             name <- restart$name
[13:21:59.439]                             if (is.null(name)) 
[13:21:59.439]                               next
[13:21:59.439]                             if (!grepl(pattern, name)) 
[13:21:59.439]                               next
[13:21:59.439]                             invokeRestart(restart)
[13:21:59.439]                             muffled <- TRUE
[13:21:59.439]                             break
[13:21:59.439]                           }
[13:21:59.439]                         }
[13:21:59.439]                       }
[13:21:59.439]                       invisible(muffled)
[13:21:59.439]                     }
[13:21:59.439]                     muffleCondition(cond, pattern = "^muffle")
[13:21:59.439]                   }
[13:21:59.439]                 }
[13:21:59.439]                 else {
[13:21:59.439]                   if (TRUE) {
[13:21:59.439]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:59.439]                     {
[13:21:59.439]                       inherits <- base::inherits
[13:21:59.439]                       invokeRestart <- base::invokeRestart
[13:21:59.439]                       is.null <- base::is.null
[13:21:59.439]                       muffled <- FALSE
[13:21:59.439]                       if (inherits(cond, "message")) {
[13:21:59.439]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:59.439]                         if (muffled) 
[13:21:59.439]                           invokeRestart("muffleMessage")
[13:21:59.439]                       }
[13:21:59.439]                       else if (inherits(cond, "warning")) {
[13:21:59.439]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:59.439]                         if (muffled) 
[13:21:59.439]                           invokeRestart("muffleWarning")
[13:21:59.439]                       }
[13:21:59.439]                       else if (inherits(cond, "condition")) {
[13:21:59.439]                         if (!is.null(pattern)) {
[13:21:59.439]                           computeRestarts <- base::computeRestarts
[13:21:59.439]                           grepl <- base::grepl
[13:21:59.439]                           restarts <- computeRestarts(cond)
[13:21:59.439]                           for (restart in restarts) {
[13:21:59.439]                             name <- restart$name
[13:21:59.439]                             if (is.null(name)) 
[13:21:59.439]                               next
[13:21:59.439]                             if (!grepl(pattern, name)) 
[13:21:59.439]                               next
[13:21:59.439]                             invokeRestart(restart)
[13:21:59.439]                             muffled <- TRUE
[13:21:59.439]                             break
[13:21:59.439]                           }
[13:21:59.439]                         }
[13:21:59.439]                       }
[13:21:59.439]                       invisible(muffled)
[13:21:59.439]                     }
[13:21:59.439]                     muffleCondition(cond, pattern = "^muffle")
[13:21:59.439]                   }
[13:21:59.439]                 }
[13:21:59.439]             }
[13:21:59.439]         }))
[13:21:59.439]     }, error = function(ex) {
[13:21:59.439]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:59.439]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:59.439]                 ...future.rng), started = ...future.startTime, 
[13:21:59.439]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:59.439]             version = "1.8"), class = "FutureResult")
[13:21:59.439]     }, finally = {
[13:21:59.439]         if (!identical(...future.workdir, getwd())) 
[13:21:59.439]             setwd(...future.workdir)
[13:21:59.439]         {
[13:21:59.439]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:59.439]                 ...future.oldOptions$nwarnings <- NULL
[13:21:59.439]             }
[13:21:59.439]             base::options(...future.oldOptions)
[13:21:59.439]             if (.Platform$OS.type == "windows") {
[13:21:59.439]                 old_names <- names(...future.oldEnvVars)
[13:21:59.439]                 envs <- base::Sys.getenv()
[13:21:59.439]                 names <- names(envs)
[13:21:59.439]                 common <- intersect(names, old_names)
[13:21:59.439]                 added <- setdiff(names, old_names)
[13:21:59.439]                 removed <- setdiff(old_names, names)
[13:21:59.439]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:59.439]                   envs[common]]
[13:21:59.439]                 NAMES <- toupper(changed)
[13:21:59.439]                 args <- list()
[13:21:59.439]                 for (kk in seq_along(NAMES)) {
[13:21:59.439]                   name <- changed[[kk]]
[13:21:59.439]                   NAME <- NAMES[[kk]]
[13:21:59.439]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:59.439]                     next
[13:21:59.439]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:59.439]                 }
[13:21:59.439]                 NAMES <- toupper(added)
[13:21:59.439]                 for (kk in seq_along(NAMES)) {
[13:21:59.439]                   name <- added[[kk]]
[13:21:59.439]                   NAME <- NAMES[[kk]]
[13:21:59.439]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:59.439]                     next
[13:21:59.439]                   args[[name]] <- ""
[13:21:59.439]                 }
[13:21:59.439]                 NAMES <- toupper(removed)
[13:21:59.439]                 for (kk in seq_along(NAMES)) {
[13:21:59.439]                   name <- removed[[kk]]
[13:21:59.439]                   NAME <- NAMES[[kk]]
[13:21:59.439]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:59.439]                     next
[13:21:59.439]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:59.439]                 }
[13:21:59.439]                 if (length(args) > 0) 
[13:21:59.439]                   base::do.call(base::Sys.setenv, args = args)
[13:21:59.439]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:59.439]             }
[13:21:59.439]             else {
[13:21:59.439]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:59.439]             }
[13:21:59.439]             {
[13:21:59.439]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:59.439]                   0L) {
[13:21:59.439]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:59.439]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:59.439]                   base::options(opts)
[13:21:59.439]                 }
[13:21:59.439]                 {
[13:21:59.439]                   {
[13:21:59.439]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:59.439]                     NULL
[13:21:59.439]                   }
[13:21:59.439]                   options(future.plan = NULL)
[13:21:59.439]                   if (is.na(NA_character_)) 
[13:21:59.439]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:59.439]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:59.439]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:59.439]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:59.439]                     envir = parent.frame()) 
[13:21:59.439]                   {
[13:21:59.439]                     if (is.function(workers)) 
[13:21:59.439]                       workers <- workers()
[13:21:59.439]                     workers <- structure(as.integer(workers), 
[13:21:59.439]                       class = class(workers))
[13:21:59.439]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:59.439]                       workers >= 1)
[13:21:59.439]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:59.439]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:59.439]                     }
[13:21:59.439]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:59.439]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:59.439]                       envir = envir)
[13:21:59.439]                     if (!future$lazy) 
[13:21:59.439]                       future <- run(future)
[13:21:59.439]                     invisible(future)
[13:21:59.439]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:59.439]                 }
[13:21:59.439]             }
[13:21:59.439]         }
[13:21:59.439]     })
[13:21:59.439]     if (TRUE) {
[13:21:59.439]         base::sink(type = "output", split = FALSE)
[13:21:59.439]         if (TRUE) {
[13:21:59.439]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:59.439]         }
[13:21:59.439]         else {
[13:21:59.439]             ...future.result["stdout"] <- base::list(NULL)
[13:21:59.439]         }
[13:21:59.439]         base::close(...future.stdout)
[13:21:59.439]         ...future.stdout <- NULL
[13:21:59.439]     }
[13:21:59.439]     ...future.result$conditions <- ...future.conditions
[13:21:59.439]     ...future.result$finished <- base::Sys.time()
[13:21:59.439]     ...future.result
[13:21:59.439] }
[13:21:59.443] MultisessionFuture started
[13:21:59.443] - Launch lazy future ... done
[13:21:59.443] run() for ‘MultisessionFuture’ ... done
[13:21:59.443] getGlobalsAndPackages() ...
[13:21:59.443] Searching for globals...
[13:21:59.444] - globals found: [2] ‘{’, ‘Sys.sleep’
[13:21:59.444] Searching for globals ... DONE
[13:21:59.444] Resolving globals: FALSE
[13:21:59.445] 
[13:21:59.445] 
[13:21:59.445] getGlobalsAndPackages() ... DONE
[13:21:59.445] run() for ‘Future’ ...
[13:21:59.445] - state: ‘created’
[13:21:59.445] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:21:59.460] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:21:59.460] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:21:59.460]   - Field: ‘node’
[13:21:59.460]   - Field: ‘label’
[13:21:59.460]   - Field: ‘local’
[13:21:59.460]   - Field: ‘owner’
[13:21:59.460]   - Field: ‘envir’
[13:21:59.461]   - Field: ‘workers’
[13:21:59.461]   - Field: ‘packages’
[13:21:59.461]   - Field: ‘gc’
[13:21:59.461]   - Field: ‘conditions’
[13:21:59.461]   - Field: ‘persistent’
[13:21:59.461]   - Field: ‘expr’
[13:21:59.461]   - Field: ‘uuid’
[13:21:59.461]   - Field: ‘seed’
[13:21:59.461]   - Field: ‘version’
[13:21:59.461]   - Field: ‘result’
[13:21:59.462]   - Field: ‘asynchronous’
[13:21:59.462]   - Field: ‘calls’
[13:21:59.462]   - Field: ‘globals’
[13:21:59.462]   - Field: ‘stdout’
[13:21:59.462]   - Field: ‘earlySignal’
[13:21:59.462]   - Field: ‘lazy’
[13:21:59.462]   - Field: ‘state’
[13:21:59.462] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:21:59.462] - Launch lazy future ...
[13:21:59.463] Packages needed by the future expression (n = 0): <none>
[13:21:59.463] Packages needed by future strategies (n = 0): <none>
[13:21:59.463] {
[13:21:59.463]     {
[13:21:59.463]         {
[13:21:59.463]             ...future.startTime <- base::Sys.time()
[13:21:59.463]             {
[13:21:59.463]                 {
[13:21:59.463]                   {
[13:21:59.463]                     {
[13:21:59.463]                       base::local({
[13:21:59.463]                         has_future <- base::requireNamespace("future", 
[13:21:59.463]                           quietly = TRUE)
[13:21:59.463]                         if (has_future) {
[13:21:59.463]                           ns <- base::getNamespace("future")
[13:21:59.463]                           version <- ns[[".package"]][["version"]]
[13:21:59.463]                           if (is.null(version)) 
[13:21:59.463]                             version <- utils::packageVersion("future")
[13:21:59.463]                         }
[13:21:59.463]                         else {
[13:21:59.463]                           version <- NULL
[13:21:59.463]                         }
[13:21:59.463]                         if (!has_future || version < "1.8.0") {
[13:21:59.463]                           info <- base::c(r_version = base::gsub("R version ", 
[13:21:59.463]                             "", base::R.version$version.string), 
[13:21:59.463]                             platform = base::sprintf("%s (%s-bit)", 
[13:21:59.463]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:21:59.463]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:21:59.463]                               "release", "version")], collapse = " "), 
[13:21:59.463]                             hostname = base::Sys.info()[["nodename"]])
[13:21:59.463]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:21:59.463]                             info)
[13:21:59.463]                           info <- base::paste(info, collapse = "; ")
[13:21:59.463]                           if (!has_future) {
[13:21:59.463]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:21:59.463]                               info)
[13:21:59.463]                           }
[13:21:59.463]                           else {
[13:21:59.463]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:21:59.463]                               info, version)
[13:21:59.463]                           }
[13:21:59.463]                           base::stop(msg)
[13:21:59.463]                         }
[13:21:59.463]                       })
[13:21:59.463]                     }
[13:21:59.463]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:21:59.463]                     base::options(mc.cores = 1L)
[13:21:59.463]                   }
[13:21:59.463]                   options(future.plan = NULL)
[13:21:59.463]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:21:59.463]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:21:59.463]                 }
[13:21:59.463]                 ...future.workdir <- getwd()
[13:21:59.463]             }
[13:21:59.463]             ...future.oldOptions <- base::as.list(base::.Options)
[13:21:59.463]             ...future.oldEnvVars <- base::Sys.getenv()
[13:21:59.463]         }
[13:21:59.463]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:21:59.463]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:21:59.463]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:21:59.463]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:21:59.463]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:21:59.463]             future.stdout.windows.reencode = NULL, width = 80L)
[13:21:59.463]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:21:59.463]             base::names(...future.oldOptions))
[13:21:59.463]     }
[13:21:59.463]     if (FALSE) {
[13:21:59.463]     }
[13:21:59.463]     else {
[13:21:59.463]         if (TRUE) {
[13:21:59.463]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:21:59.463]                 open = "w")
[13:21:59.463]         }
[13:21:59.463]         else {
[13:21:59.463]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:21:59.463]                 windows = "NUL", "/dev/null"), open = "w")
[13:21:59.463]         }
[13:21:59.463]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:21:59.463]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:21:59.463]             base::sink(type = "output", split = FALSE)
[13:21:59.463]             base::close(...future.stdout)
[13:21:59.463]         }, add = TRUE)
[13:21:59.463]     }
[13:21:59.463]     ...future.frame <- base::sys.nframe()
[13:21:59.463]     ...future.conditions <- base::list()
[13:21:59.463]     ...future.rng <- base::globalenv()$.Random.seed
[13:21:59.463]     if (FALSE) {
[13:21:59.463]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:21:59.463]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:21:59.463]     }
[13:21:59.463]     ...future.result <- base::tryCatch({
[13:21:59.463]         base::withCallingHandlers({
[13:21:59.463]             ...future.value <- base::withVisible(base::local({
[13:21:59.463]                 ...future.makeSendCondition <- local({
[13:21:59.463]                   sendCondition <- NULL
[13:21:59.463]                   function(frame = 1L) {
[13:21:59.463]                     if (is.function(sendCondition)) 
[13:21:59.463]                       return(sendCondition)
[13:21:59.463]                     ns <- getNamespace("parallel")
[13:21:59.463]                     if (exists("sendData", mode = "function", 
[13:21:59.463]                       envir = ns)) {
[13:21:59.463]                       parallel_sendData <- get("sendData", mode = "function", 
[13:21:59.463]                         envir = ns)
[13:21:59.463]                       envir <- sys.frame(frame)
[13:21:59.463]                       master <- NULL
[13:21:59.463]                       while (!identical(envir, .GlobalEnv) && 
[13:21:59.463]                         !identical(envir, emptyenv())) {
[13:21:59.463]                         if (exists("master", mode = "list", envir = envir, 
[13:21:59.463]                           inherits = FALSE)) {
[13:21:59.463]                           master <- get("master", mode = "list", 
[13:21:59.463]                             envir = envir, inherits = FALSE)
[13:21:59.463]                           if (inherits(master, c("SOCKnode", 
[13:21:59.463]                             "SOCK0node"))) {
[13:21:59.463]                             sendCondition <<- function(cond) {
[13:21:59.463]                               data <- list(type = "VALUE", value = cond, 
[13:21:59.463]                                 success = TRUE)
[13:21:59.463]                               parallel_sendData(master, data)
[13:21:59.463]                             }
[13:21:59.463]                             return(sendCondition)
[13:21:59.463]                           }
[13:21:59.463]                         }
[13:21:59.463]                         frame <- frame + 1L
[13:21:59.463]                         envir <- sys.frame(frame)
[13:21:59.463]                       }
[13:21:59.463]                     }
[13:21:59.463]                     sendCondition <<- function(cond) NULL
[13:21:59.463]                   }
[13:21:59.463]                 })
[13:21:59.463]                 withCallingHandlers({
[13:21:59.463]                   {
[13:21:59.463]                     Sys.sleep(0.5)
[13:21:59.463]                     2
[13:21:59.463]                   }
[13:21:59.463]                 }, immediateCondition = function(cond) {
[13:21:59.463]                   sendCondition <- ...future.makeSendCondition()
[13:21:59.463]                   sendCondition(cond)
[13:21:59.463]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:59.463]                   {
[13:21:59.463]                     inherits <- base::inherits
[13:21:59.463]                     invokeRestart <- base::invokeRestart
[13:21:59.463]                     is.null <- base::is.null
[13:21:59.463]                     muffled <- FALSE
[13:21:59.463]                     if (inherits(cond, "message")) {
[13:21:59.463]                       muffled <- grepl(pattern, "muffleMessage")
[13:21:59.463]                       if (muffled) 
[13:21:59.463]                         invokeRestart("muffleMessage")
[13:21:59.463]                     }
[13:21:59.463]                     else if (inherits(cond, "warning")) {
[13:21:59.463]                       muffled <- grepl(pattern, "muffleWarning")
[13:21:59.463]                       if (muffled) 
[13:21:59.463]                         invokeRestart("muffleWarning")
[13:21:59.463]                     }
[13:21:59.463]                     else if (inherits(cond, "condition")) {
[13:21:59.463]                       if (!is.null(pattern)) {
[13:21:59.463]                         computeRestarts <- base::computeRestarts
[13:21:59.463]                         grepl <- base::grepl
[13:21:59.463]                         restarts <- computeRestarts(cond)
[13:21:59.463]                         for (restart in restarts) {
[13:21:59.463]                           name <- restart$name
[13:21:59.463]                           if (is.null(name)) 
[13:21:59.463]                             next
[13:21:59.463]                           if (!grepl(pattern, name)) 
[13:21:59.463]                             next
[13:21:59.463]                           invokeRestart(restart)
[13:21:59.463]                           muffled <- TRUE
[13:21:59.463]                           break
[13:21:59.463]                         }
[13:21:59.463]                       }
[13:21:59.463]                     }
[13:21:59.463]                     invisible(muffled)
[13:21:59.463]                   }
[13:21:59.463]                   muffleCondition(cond)
[13:21:59.463]                 })
[13:21:59.463]             }))
[13:21:59.463]             future::FutureResult(value = ...future.value$value, 
[13:21:59.463]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:59.463]                   ...future.rng), globalenv = if (FALSE) 
[13:21:59.463]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:21:59.463]                     ...future.globalenv.names))
[13:21:59.463]                 else NULL, started = ...future.startTime, version = "1.8")
[13:21:59.463]         }, condition = base::local({
[13:21:59.463]             c <- base::c
[13:21:59.463]             inherits <- base::inherits
[13:21:59.463]             invokeRestart <- base::invokeRestart
[13:21:59.463]             length <- base::length
[13:21:59.463]             list <- base::list
[13:21:59.463]             seq.int <- base::seq.int
[13:21:59.463]             signalCondition <- base::signalCondition
[13:21:59.463]             sys.calls <- base::sys.calls
[13:21:59.463]             `[[` <- base::`[[`
[13:21:59.463]             `+` <- base::`+`
[13:21:59.463]             `<<-` <- base::`<<-`
[13:21:59.463]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:21:59.463]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:21:59.463]                   3L)]
[13:21:59.463]             }
[13:21:59.463]             function(cond) {
[13:21:59.463]                 is_error <- inherits(cond, "error")
[13:21:59.463]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:21:59.463]                   NULL)
[13:21:59.463]                 if (is_error) {
[13:21:59.463]                   sessionInformation <- function() {
[13:21:59.463]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:21:59.463]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:21:59.463]                       search = base::search(), system = base::Sys.info())
[13:21:59.463]                   }
[13:21:59.463]                   ...future.conditions[[length(...future.conditions) + 
[13:21:59.463]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:21:59.463]                     cond$call), session = sessionInformation(), 
[13:21:59.463]                     timestamp = base::Sys.time(), signaled = 0L)
[13:21:59.463]                   signalCondition(cond)
[13:21:59.463]                 }
[13:21:59.463]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:21:59.463]                 "immediateCondition"))) {
[13:21:59.463]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:21:59.463]                   ...future.conditions[[length(...future.conditions) + 
[13:21:59.463]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:21:59.463]                   if (TRUE && !signal) {
[13:21:59.463]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:59.463]                     {
[13:21:59.463]                       inherits <- base::inherits
[13:21:59.463]                       invokeRestart <- base::invokeRestart
[13:21:59.463]                       is.null <- base::is.null
[13:21:59.463]                       muffled <- FALSE
[13:21:59.463]                       if (inherits(cond, "message")) {
[13:21:59.463]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:59.463]                         if (muffled) 
[13:21:59.463]                           invokeRestart("muffleMessage")
[13:21:59.463]                       }
[13:21:59.463]                       else if (inherits(cond, "warning")) {
[13:21:59.463]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:59.463]                         if (muffled) 
[13:21:59.463]                           invokeRestart("muffleWarning")
[13:21:59.463]                       }
[13:21:59.463]                       else if (inherits(cond, "condition")) {
[13:21:59.463]                         if (!is.null(pattern)) {
[13:21:59.463]                           computeRestarts <- base::computeRestarts
[13:21:59.463]                           grepl <- base::grepl
[13:21:59.463]                           restarts <- computeRestarts(cond)
[13:21:59.463]                           for (restart in restarts) {
[13:21:59.463]                             name <- restart$name
[13:21:59.463]                             if (is.null(name)) 
[13:21:59.463]                               next
[13:21:59.463]                             if (!grepl(pattern, name)) 
[13:21:59.463]                               next
[13:21:59.463]                             invokeRestart(restart)
[13:21:59.463]                             muffled <- TRUE
[13:21:59.463]                             break
[13:21:59.463]                           }
[13:21:59.463]                         }
[13:21:59.463]                       }
[13:21:59.463]                       invisible(muffled)
[13:21:59.463]                     }
[13:21:59.463]                     muffleCondition(cond, pattern = "^muffle")
[13:21:59.463]                   }
[13:21:59.463]                 }
[13:21:59.463]                 else {
[13:21:59.463]                   if (TRUE) {
[13:21:59.463]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:21:59.463]                     {
[13:21:59.463]                       inherits <- base::inherits
[13:21:59.463]                       invokeRestart <- base::invokeRestart
[13:21:59.463]                       is.null <- base::is.null
[13:21:59.463]                       muffled <- FALSE
[13:21:59.463]                       if (inherits(cond, "message")) {
[13:21:59.463]                         muffled <- grepl(pattern, "muffleMessage")
[13:21:59.463]                         if (muffled) 
[13:21:59.463]                           invokeRestart("muffleMessage")
[13:21:59.463]                       }
[13:21:59.463]                       else if (inherits(cond, "warning")) {
[13:21:59.463]                         muffled <- grepl(pattern, "muffleWarning")
[13:21:59.463]                         if (muffled) 
[13:21:59.463]                           invokeRestart("muffleWarning")
[13:21:59.463]                       }
[13:21:59.463]                       else if (inherits(cond, "condition")) {
[13:21:59.463]                         if (!is.null(pattern)) {
[13:21:59.463]                           computeRestarts <- base::computeRestarts
[13:21:59.463]                           grepl <- base::grepl
[13:21:59.463]                           restarts <- computeRestarts(cond)
[13:21:59.463]                           for (restart in restarts) {
[13:21:59.463]                             name <- restart$name
[13:21:59.463]                             if (is.null(name)) 
[13:21:59.463]                               next
[13:21:59.463]                             if (!grepl(pattern, name)) 
[13:21:59.463]                               next
[13:21:59.463]                             invokeRestart(restart)
[13:21:59.463]                             muffled <- TRUE
[13:21:59.463]                             break
[13:21:59.463]                           }
[13:21:59.463]                         }
[13:21:59.463]                       }
[13:21:59.463]                       invisible(muffled)
[13:21:59.463]                     }
[13:21:59.463]                     muffleCondition(cond, pattern = "^muffle")
[13:21:59.463]                   }
[13:21:59.463]                 }
[13:21:59.463]             }
[13:21:59.463]         }))
[13:21:59.463]     }, error = function(ex) {
[13:21:59.463]         base::structure(base::list(value = NULL, visible = NULL, 
[13:21:59.463]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:21:59.463]                 ...future.rng), started = ...future.startTime, 
[13:21:59.463]             finished = Sys.time(), session_uuid = NA_character_, 
[13:21:59.463]             version = "1.8"), class = "FutureResult")
[13:21:59.463]     }, finally = {
[13:21:59.463]         if (!identical(...future.workdir, getwd())) 
[13:21:59.463]             setwd(...future.workdir)
[13:21:59.463]         {
[13:21:59.463]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:21:59.463]                 ...future.oldOptions$nwarnings <- NULL
[13:21:59.463]             }
[13:21:59.463]             base::options(...future.oldOptions)
[13:21:59.463]             if (.Platform$OS.type == "windows") {
[13:21:59.463]                 old_names <- names(...future.oldEnvVars)
[13:21:59.463]                 envs <- base::Sys.getenv()
[13:21:59.463]                 names <- names(envs)
[13:21:59.463]                 common <- intersect(names, old_names)
[13:21:59.463]                 added <- setdiff(names, old_names)
[13:21:59.463]                 removed <- setdiff(old_names, names)
[13:21:59.463]                 changed <- common[...future.oldEnvVars[common] != 
[13:21:59.463]                   envs[common]]
[13:21:59.463]                 NAMES <- toupper(changed)
[13:21:59.463]                 args <- list()
[13:21:59.463]                 for (kk in seq_along(NAMES)) {
[13:21:59.463]                   name <- changed[[kk]]
[13:21:59.463]                   NAME <- NAMES[[kk]]
[13:21:59.463]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:59.463]                     next
[13:21:59.463]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:59.463]                 }
[13:21:59.463]                 NAMES <- toupper(added)
[13:21:59.463]                 for (kk in seq_along(NAMES)) {
[13:21:59.463]                   name <- added[[kk]]
[13:21:59.463]                   NAME <- NAMES[[kk]]
[13:21:59.463]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:59.463]                     next
[13:21:59.463]                   args[[name]] <- ""
[13:21:59.463]                 }
[13:21:59.463]                 NAMES <- toupper(removed)
[13:21:59.463]                 for (kk in seq_along(NAMES)) {
[13:21:59.463]                   name <- removed[[kk]]
[13:21:59.463]                   NAME <- NAMES[[kk]]
[13:21:59.463]                   if (name != NAME && is.element(NAME, old_names)) 
[13:21:59.463]                     next
[13:21:59.463]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:21:59.463]                 }
[13:21:59.463]                 if (length(args) > 0) 
[13:21:59.463]                   base::do.call(base::Sys.setenv, args = args)
[13:21:59.463]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:21:59.463]             }
[13:21:59.463]             else {
[13:21:59.463]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:21:59.463]             }
[13:21:59.463]             {
[13:21:59.463]                 if (base::length(...future.futureOptionsAdded) > 
[13:21:59.463]                   0L) {
[13:21:59.463]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:21:59.463]                   base::names(opts) <- ...future.futureOptionsAdded
[13:21:59.463]                   base::options(opts)
[13:21:59.463]                 }
[13:21:59.463]                 {
[13:21:59.463]                   {
[13:21:59.463]                     base::options(mc.cores = ...future.mc.cores.old)
[13:21:59.463]                     NULL
[13:21:59.463]                   }
[13:21:59.463]                   options(future.plan = NULL)
[13:21:59.463]                   if (is.na(NA_character_)) 
[13:21:59.463]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:21:59.463]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:21:59.463]                   future::plan(list(function (..., workers = availableCores(), 
[13:21:59.463]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:21:59.463]                     envir = parent.frame()) 
[13:21:59.463]                   {
[13:21:59.463]                     if (is.function(workers)) 
[13:21:59.463]                       workers <- workers()
[13:21:59.463]                     workers <- structure(as.integer(workers), 
[13:21:59.463]                       class = class(workers))
[13:21:59.463]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:21:59.463]                       workers >= 1)
[13:21:59.463]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:21:59.463]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:21:59.463]                     }
[13:21:59.463]                     future <- MultisessionFuture(..., workers = workers, 
[13:21:59.463]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:21:59.463]                       envir = envir)
[13:21:59.463]                     if (!future$lazy) 
[13:21:59.463]                       future <- run(future)
[13:21:59.463]                     invisible(future)
[13:21:59.463]                   }), .cleanup = FALSE, .init = FALSE)
[13:21:59.463]                 }
[13:21:59.463]             }
[13:21:59.463]         }
[13:21:59.463]     })
[13:21:59.463]     if (TRUE) {
[13:21:59.463]         base::sink(type = "output", split = FALSE)
[13:21:59.463]         if (TRUE) {
[13:21:59.463]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:21:59.463]         }
[13:21:59.463]         else {
[13:21:59.463]             ...future.result["stdout"] <- base::list(NULL)
[13:21:59.463]         }
[13:21:59.463]         base::close(...future.stdout)
[13:21:59.463]         ...future.stdout <- NULL
[13:21:59.463]     }
[13:21:59.463]     ...future.result$conditions <- ...future.conditions
[13:21:59.463]     ...future.result$finished <- base::Sys.time()
[13:21:59.463]     ...future.result
[13:21:59.463] }
[13:21:59.466] MultisessionFuture started
[13:21:59.466] - Launch lazy future ... done
[13:21:59.466] run() for ‘MultisessionFuture’ ... done
[13:21:59.467] resolve() on list ...
[13:21:59.467]  recursive: 0
[13:21:59.467]  length: 1
[13:21:59.467] 
[13:21:59.490] receiveMessageFromWorker() for ClusterFuture ...
[13:21:59.490] - Validating connection of MultisessionFuture
[13:21:59.490] - received message: FutureResult
[13:21:59.490] - Received FutureResult
[13:21:59.490] - Erased future from FutureRegistry
[13:21:59.490] result() for ClusterFuture ...
[13:21:59.490] - result already collected: FutureResult
[13:21:59.491] result() for ClusterFuture ... done
[13:21:59.491] receiveMessageFromWorker() for ClusterFuture ... done
[13:21:59.491] Future #1
[13:21:59.491]  length: 0 (resolved future 1)
[13:21:59.491] resolve() on list ... DONE
[13:21:59.491] resolve() on list ...
[13:21:59.491]  recursive: 0
[13:21:59.491]  length: 1
[13:21:59.491] 
[13:22:00.028] receiveMessageFromWorker() for ClusterFuture ...
[13:22:00.028] - Validating connection of MultisessionFuture
[13:22:00.028] - received message: FutureResult
[13:22:00.029] - Received FutureResult
[13:22:00.029] - Erased future from FutureRegistry
[13:22:00.029] result() for ClusterFuture ...
[13:22:00.029] - result already collected: FutureResult
[13:22:00.029] result() for ClusterFuture ... done
[13:22:00.029] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:00.029] Future #1
[13:22:00.029]  length: 0 (resolved future 1)
[13:22:00.029] resolve() on list ... DONE
[13:22:00.030] resolve() on list ...
[13:22:00.030]  recursive: 0
[13:22:00.030]  length: 1
[13:22:00.030] 
[13:22:00.030]  length: 0 (resolved future 1)
[13:22:00.030] resolve() on list ... DONE
[13:22:00.030] resolve() on list ...
[13:22:00.030]  recursive: 0
[13:22:00.030]  length: 4
[13:22:00.030] 
[13:22:00.031] Future #1
[13:22:00.031]  length: 3 (resolved future 1)
[13:22:00.031] Future #2
[13:22:00.031]  length: 2 (resolved future 2)
[13:22:00.031]  length: 1 (resolved future 3)
[13:22:00.031]  length: 0 (resolved future 4)
[13:22:00.031] resolve() on list ... DONE
[13:22:00.031] resolve() on list ...
[13:22:00.031]  recursive: 0
[13:22:00.032]  length: 4
[13:22:00.032] 
[13:22:00.032] Future #1
[13:22:00.032]  length: 3 (resolved future 1)
[13:22:00.032] Future #2
[13:22:00.032]  length: 2 (resolved future 2)
[13:22:00.032]  length: 1 (resolved future 3)
[13:22:00.032]  length: 0 (resolved future 4)
[13:22:00.032] resolve() on list ... DONE
[13:22:00.032] resolve() on list ...
[13:22:00.033]  recursive: 0
[13:22:00.033]  length: 1
[13:22:00.033] 
[13:22:00.033]  length: 0 (resolved future 1)
[13:22:00.033] resolve() on list ... DONE
[13:22:00.033] getGlobalsAndPackages() ...
[13:22:00.033] Searching for globals...
[13:22:00.034] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:22:00.034] Searching for globals ... DONE
[13:22:00.034] Resolving globals: FALSE
[13:22:00.035] The total size of the 1 globals is 56 bytes (56 bytes)
[13:22:00.035] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:22:00.035] - globals: [1] ‘kk’
[13:22:00.035] 
[13:22:00.035] getGlobalsAndPackages() ... DONE
[13:22:00.036] run() for ‘Future’ ...
[13:22:00.036] - state: ‘created’
[13:22:00.036] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:00.050] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:00.050] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:00.051]   - Field: ‘node’
[13:22:00.051]   - Field: ‘label’
[13:22:00.051]   - Field: ‘local’
[13:22:00.051]   - Field: ‘owner’
[13:22:00.051]   - Field: ‘envir’
[13:22:00.051]   - Field: ‘workers’
[13:22:00.051]   - Field: ‘packages’
[13:22:00.051]   - Field: ‘gc’
[13:22:00.051]   - Field: ‘conditions’
[13:22:00.051]   - Field: ‘persistent’
[13:22:00.052]   - Field: ‘expr’
[13:22:00.052]   - Field: ‘uuid’
[13:22:00.052]   - Field: ‘seed’
[13:22:00.052]   - Field: ‘version’
[13:22:00.052]   - Field: ‘result’
[13:22:00.052]   - Field: ‘asynchronous’
[13:22:00.052]   - Field: ‘calls’
[13:22:00.052]   - Field: ‘globals’
[13:22:00.052]   - Field: ‘stdout’
[13:22:00.052]   - Field: ‘earlySignal’
[13:22:00.052]   - Field: ‘lazy’
[13:22:00.053]   - Field: ‘state’
[13:22:00.053] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:00.053] - Launch lazy future ...
[13:22:00.053] Packages needed by the future expression (n = 0): <none>
[13:22:00.053] Packages needed by future strategies (n = 0): <none>
[13:22:00.054] {
[13:22:00.054]     {
[13:22:00.054]         {
[13:22:00.054]             ...future.startTime <- base::Sys.time()
[13:22:00.054]             {
[13:22:00.054]                 {
[13:22:00.054]                   {
[13:22:00.054]                     {
[13:22:00.054]                       base::local({
[13:22:00.054]                         has_future <- base::requireNamespace("future", 
[13:22:00.054]                           quietly = TRUE)
[13:22:00.054]                         if (has_future) {
[13:22:00.054]                           ns <- base::getNamespace("future")
[13:22:00.054]                           version <- ns[[".package"]][["version"]]
[13:22:00.054]                           if (is.null(version)) 
[13:22:00.054]                             version <- utils::packageVersion("future")
[13:22:00.054]                         }
[13:22:00.054]                         else {
[13:22:00.054]                           version <- NULL
[13:22:00.054]                         }
[13:22:00.054]                         if (!has_future || version < "1.8.0") {
[13:22:00.054]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:00.054]                             "", base::R.version$version.string), 
[13:22:00.054]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:00.054]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:00.054]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:00.054]                               "release", "version")], collapse = " "), 
[13:22:00.054]                             hostname = base::Sys.info()[["nodename"]])
[13:22:00.054]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:00.054]                             info)
[13:22:00.054]                           info <- base::paste(info, collapse = "; ")
[13:22:00.054]                           if (!has_future) {
[13:22:00.054]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:00.054]                               info)
[13:22:00.054]                           }
[13:22:00.054]                           else {
[13:22:00.054]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:00.054]                               info, version)
[13:22:00.054]                           }
[13:22:00.054]                           base::stop(msg)
[13:22:00.054]                         }
[13:22:00.054]                       })
[13:22:00.054]                     }
[13:22:00.054]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:00.054]                     base::options(mc.cores = 1L)
[13:22:00.054]                   }
[13:22:00.054]                   options(future.plan = NULL)
[13:22:00.054]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:00.054]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:00.054]                 }
[13:22:00.054]                 ...future.workdir <- getwd()
[13:22:00.054]             }
[13:22:00.054]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:00.054]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:00.054]         }
[13:22:00.054]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:00.054]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:00.054]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:00.054]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:00.054]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:00.054]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:00.054]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:00.054]             base::names(...future.oldOptions))
[13:22:00.054]     }
[13:22:00.054]     if (FALSE) {
[13:22:00.054]     }
[13:22:00.054]     else {
[13:22:00.054]         if (TRUE) {
[13:22:00.054]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:00.054]                 open = "w")
[13:22:00.054]         }
[13:22:00.054]         else {
[13:22:00.054]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:00.054]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:00.054]         }
[13:22:00.054]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:00.054]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:00.054]             base::sink(type = "output", split = FALSE)
[13:22:00.054]             base::close(...future.stdout)
[13:22:00.054]         }, add = TRUE)
[13:22:00.054]     }
[13:22:00.054]     ...future.frame <- base::sys.nframe()
[13:22:00.054]     ...future.conditions <- base::list()
[13:22:00.054]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:00.054]     if (FALSE) {
[13:22:00.054]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:00.054]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:00.054]     }
[13:22:00.054]     ...future.result <- base::tryCatch({
[13:22:00.054]         base::withCallingHandlers({
[13:22:00.054]             ...future.value <- base::withVisible(base::local({
[13:22:00.054]                 ...future.makeSendCondition <- local({
[13:22:00.054]                   sendCondition <- NULL
[13:22:00.054]                   function(frame = 1L) {
[13:22:00.054]                     if (is.function(sendCondition)) 
[13:22:00.054]                       return(sendCondition)
[13:22:00.054]                     ns <- getNamespace("parallel")
[13:22:00.054]                     if (exists("sendData", mode = "function", 
[13:22:00.054]                       envir = ns)) {
[13:22:00.054]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:00.054]                         envir = ns)
[13:22:00.054]                       envir <- sys.frame(frame)
[13:22:00.054]                       master <- NULL
[13:22:00.054]                       while (!identical(envir, .GlobalEnv) && 
[13:22:00.054]                         !identical(envir, emptyenv())) {
[13:22:00.054]                         if (exists("master", mode = "list", envir = envir, 
[13:22:00.054]                           inherits = FALSE)) {
[13:22:00.054]                           master <- get("master", mode = "list", 
[13:22:00.054]                             envir = envir, inherits = FALSE)
[13:22:00.054]                           if (inherits(master, c("SOCKnode", 
[13:22:00.054]                             "SOCK0node"))) {
[13:22:00.054]                             sendCondition <<- function(cond) {
[13:22:00.054]                               data <- list(type = "VALUE", value = cond, 
[13:22:00.054]                                 success = TRUE)
[13:22:00.054]                               parallel_sendData(master, data)
[13:22:00.054]                             }
[13:22:00.054]                             return(sendCondition)
[13:22:00.054]                           }
[13:22:00.054]                         }
[13:22:00.054]                         frame <- frame + 1L
[13:22:00.054]                         envir <- sys.frame(frame)
[13:22:00.054]                       }
[13:22:00.054]                     }
[13:22:00.054]                     sendCondition <<- function(cond) NULL
[13:22:00.054]                   }
[13:22:00.054]                 })
[13:22:00.054]                 withCallingHandlers({
[13:22:00.054]                   {
[13:22:00.054]                     Sys.sleep(0.1)
[13:22:00.054]                     kk
[13:22:00.054]                   }
[13:22:00.054]                 }, immediateCondition = function(cond) {
[13:22:00.054]                   sendCondition <- ...future.makeSendCondition()
[13:22:00.054]                   sendCondition(cond)
[13:22:00.054]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.054]                   {
[13:22:00.054]                     inherits <- base::inherits
[13:22:00.054]                     invokeRestart <- base::invokeRestart
[13:22:00.054]                     is.null <- base::is.null
[13:22:00.054]                     muffled <- FALSE
[13:22:00.054]                     if (inherits(cond, "message")) {
[13:22:00.054]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:00.054]                       if (muffled) 
[13:22:00.054]                         invokeRestart("muffleMessage")
[13:22:00.054]                     }
[13:22:00.054]                     else if (inherits(cond, "warning")) {
[13:22:00.054]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:00.054]                       if (muffled) 
[13:22:00.054]                         invokeRestart("muffleWarning")
[13:22:00.054]                     }
[13:22:00.054]                     else if (inherits(cond, "condition")) {
[13:22:00.054]                       if (!is.null(pattern)) {
[13:22:00.054]                         computeRestarts <- base::computeRestarts
[13:22:00.054]                         grepl <- base::grepl
[13:22:00.054]                         restarts <- computeRestarts(cond)
[13:22:00.054]                         for (restart in restarts) {
[13:22:00.054]                           name <- restart$name
[13:22:00.054]                           if (is.null(name)) 
[13:22:00.054]                             next
[13:22:00.054]                           if (!grepl(pattern, name)) 
[13:22:00.054]                             next
[13:22:00.054]                           invokeRestart(restart)
[13:22:00.054]                           muffled <- TRUE
[13:22:00.054]                           break
[13:22:00.054]                         }
[13:22:00.054]                       }
[13:22:00.054]                     }
[13:22:00.054]                     invisible(muffled)
[13:22:00.054]                   }
[13:22:00.054]                   muffleCondition(cond)
[13:22:00.054]                 })
[13:22:00.054]             }))
[13:22:00.054]             future::FutureResult(value = ...future.value$value, 
[13:22:00.054]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:00.054]                   ...future.rng), globalenv = if (FALSE) 
[13:22:00.054]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:00.054]                     ...future.globalenv.names))
[13:22:00.054]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:00.054]         }, condition = base::local({
[13:22:00.054]             c <- base::c
[13:22:00.054]             inherits <- base::inherits
[13:22:00.054]             invokeRestart <- base::invokeRestart
[13:22:00.054]             length <- base::length
[13:22:00.054]             list <- base::list
[13:22:00.054]             seq.int <- base::seq.int
[13:22:00.054]             signalCondition <- base::signalCondition
[13:22:00.054]             sys.calls <- base::sys.calls
[13:22:00.054]             `[[` <- base::`[[`
[13:22:00.054]             `+` <- base::`+`
[13:22:00.054]             `<<-` <- base::`<<-`
[13:22:00.054]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:00.054]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:00.054]                   3L)]
[13:22:00.054]             }
[13:22:00.054]             function(cond) {
[13:22:00.054]                 is_error <- inherits(cond, "error")
[13:22:00.054]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:00.054]                   NULL)
[13:22:00.054]                 if (is_error) {
[13:22:00.054]                   sessionInformation <- function() {
[13:22:00.054]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:00.054]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:00.054]                       search = base::search(), system = base::Sys.info())
[13:22:00.054]                   }
[13:22:00.054]                   ...future.conditions[[length(...future.conditions) + 
[13:22:00.054]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:00.054]                     cond$call), session = sessionInformation(), 
[13:22:00.054]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:00.054]                   signalCondition(cond)
[13:22:00.054]                 }
[13:22:00.054]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:00.054]                 "immediateCondition"))) {
[13:22:00.054]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:00.054]                   ...future.conditions[[length(...future.conditions) + 
[13:22:00.054]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:00.054]                   if (TRUE && !signal) {
[13:22:00.054]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.054]                     {
[13:22:00.054]                       inherits <- base::inherits
[13:22:00.054]                       invokeRestart <- base::invokeRestart
[13:22:00.054]                       is.null <- base::is.null
[13:22:00.054]                       muffled <- FALSE
[13:22:00.054]                       if (inherits(cond, "message")) {
[13:22:00.054]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:00.054]                         if (muffled) 
[13:22:00.054]                           invokeRestart("muffleMessage")
[13:22:00.054]                       }
[13:22:00.054]                       else if (inherits(cond, "warning")) {
[13:22:00.054]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:00.054]                         if (muffled) 
[13:22:00.054]                           invokeRestart("muffleWarning")
[13:22:00.054]                       }
[13:22:00.054]                       else if (inherits(cond, "condition")) {
[13:22:00.054]                         if (!is.null(pattern)) {
[13:22:00.054]                           computeRestarts <- base::computeRestarts
[13:22:00.054]                           grepl <- base::grepl
[13:22:00.054]                           restarts <- computeRestarts(cond)
[13:22:00.054]                           for (restart in restarts) {
[13:22:00.054]                             name <- restart$name
[13:22:00.054]                             if (is.null(name)) 
[13:22:00.054]                               next
[13:22:00.054]                             if (!grepl(pattern, name)) 
[13:22:00.054]                               next
[13:22:00.054]                             invokeRestart(restart)
[13:22:00.054]                             muffled <- TRUE
[13:22:00.054]                             break
[13:22:00.054]                           }
[13:22:00.054]                         }
[13:22:00.054]                       }
[13:22:00.054]                       invisible(muffled)
[13:22:00.054]                     }
[13:22:00.054]                     muffleCondition(cond, pattern = "^muffle")
[13:22:00.054]                   }
[13:22:00.054]                 }
[13:22:00.054]                 else {
[13:22:00.054]                   if (TRUE) {
[13:22:00.054]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.054]                     {
[13:22:00.054]                       inherits <- base::inherits
[13:22:00.054]                       invokeRestart <- base::invokeRestart
[13:22:00.054]                       is.null <- base::is.null
[13:22:00.054]                       muffled <- FALSE
[13:22:00.054]                       if (inherits(cond, "message")) {
[13:22:00.054]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:00.054]                         if (muffled) 
[13:22:00.054]                           invokeRestart("muffleMessage")
[13:22:00.054]                       }
[13:22:00.054]                       else if (inherits(cond, "warning")) {
[13:22:00.054]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:00.054]                         if (muffled) 
[13:22:00.054]                           invokeRestart("muffleWarning")
[13:22:00.054]                       }
[13:22:00.054]                       else if (inherits(cond, "condition")) {
[13:22:00.054]                         if (!is.null(pattern)) {
[13:22:00.054]                           computeRestarts <- base::computeRestarts
[13:22:00.054]                           grepl <- base::grepl
[13:22:00.054]                           restarts <- computeRestarts(cond)
[13:22:00.054]                           for (restart in restarts) {
[13:22:00.054]                             name <- restart$name
[13:22:00.054]                             if (is.null(name)) 
[13:22:00.054]                               next
[13:22:00.054]                             if (!grepl(pattern, name)) 
[13:22:00.054]                               next
[13:22:00.054]                             invokeRestart(restart)
[13:22:00.054]                             muffled <- TRUE
[13:22:00.054]                             break
[13:22:00.054]                           }
[13:22:00.054]                         }
[13:22:00.054]                       }
[13:22:00.054]                       invisible(muffled)
[13:22:00.054]                     }
[13:22:00.054]                     muffleCondition(cond, pattern = "^muffle")
[13:22:00.054]                   }
[13:22:00.054]                 }
[13:22:00.054]             }
[13:22:00.054]         }))
[13:22:00.054]     }, error = function(ex) {
[13:22:00.054]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:00.054]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:00.054]                 ...future.rng), started = ...future.startTime, 
[13:22:00.054]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:00.054]             version = "1.8"), class = "FutureResult")
[13:22:00.054]     }, finally = {
[13:22:00.054]         if (!identical(...future.workdir, getwd())) 
[13:22:00.054]             setwd(...future.workdir)
[13:22:00.054]         {
[13:22:00.054]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:00.054]                 ...future.oldOptions$nwarnings <- NULL
[13:22:00.054]             }
[13:22:00.054]             base::options(...future.oldOptions)
[13:22:00.054]             if (.Platform$OS.type == "windows") {
[13:22:00.054]                 old_names <- names(...future.oldEnvVars)
[13:22:00.054]                 envs <- base::Sys.getenv()
[13:22:00.054]                 names <- names(envs)
[13:22:00.054]                 common <- intersect(names, old_names)
[13:22:00.054]                 added <- setdiff(names, old_names)
[13:22:00.054]                 removed <- setdiff(old_names, names)
[13:22:00.054]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:00.054]                   envs[common]]
[13:22:00.054]                 NAMES <- toupper(changed)
[13:22:00.054]                 args <- list()
[13:22:00.054]                 for (kk in seq_along(NAMES)) {
[13:22:00.054]                   name <- changed[[kk]]
[13:22:00.054]                   NAME <- NAMES[[kk]]
[13:22:00.054]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.054]                     next
[13:22:00.054]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:00.054]                 }
[13:22:00.054]                 NAMES <- toupper(added)
[13:22:00.054]                 for (kk in seq_along(NAMES)) {
[13:22:00.054]                   name <- added[[kk]]
[13:22:00.054]                   NAME <- NAMES[[kk]]
[13:22:00.054]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.054]                     next
[13:22:00.054]                   args[[name]] <- ""
[13:22:00.054]                 }
[13:22:00.054]                 NAMES <- toupper(removed)
[13:22:00.054]                 for (kk in seq_along(NAMES)) {
[13:22:00.054]                   name <- removed[[kk]]
[13:22:00.054]                   NAME <- NAMES[[kk]]
[13:22:00.054]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.054]                     next
[13:22:00.054]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:00.054]                 }
[13:22:00.054]                 if (length(args) > 0) 
[13:22:00.054]                   base::do.call(base::Sys.setenv, args = args)
[13:22:00.054]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:00.054]             }
[13:22:00.054]             else {
[13:22:00.054]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:00.054]             }
[13:22:00.054]             {
[13:22:00.054]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:00.054]                   0L) {
[13:22:00.054]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:00.054]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:00.054]                   base::options(opts)
[13:22:00.054]                 }
[13:22:00.054]                 {
[13:22:00.054]                   {
[13:22:00.054]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:00.054]                     NULL
[13:22:00.054]                   }
[13:22:00.054]                   options(future.plan = NULL)
[13:22:00.054]                   if (is.na(NA_character_)) 
[13:22:00.054]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:00.054]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:00.054]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:00.054]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:00.054]                     envir = parent.frame()) 
[13:22:00.054]                   {
[13:22:00.054]                     if (is.function(workers)) 
[13:22:00.054]                       workers <- workers()
[13:22:00.054]                     workers <- structure(as.integer(workers), 
[13:22:00.054]                       class = class(workers))
[13:22:00.054]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:00.054]                       workers >= 1)
[13:22:00.054]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:00.054]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:00.054]                     }
[13:22:00.054]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:00.054]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:00.054]                       envir = envir)
[13:22:00.054]                     if (!future$lazy) 
[13:22:00.054]                       future <- run(future)
[13:22:00.054]                     invisible(future)
[13:22:00.054]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:00.054]                 }
[13:22:00.054]             }
[13:22:00.054]         }
[13:22:00.054]     })
[13:22:00.054]     if (TRUE) {
[13:22:00.054]         base::sink(type = "output", split = FALSE)
[13:22:00.054]         if (TRUE) {
[13:22:00.054]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:00.054]         }
[13:22:00.054]         else {
[13:22:00.054]             ...future.result["stdout"] <- base::list(NULL)
[13:22:00.054]         }
[13:22:00.054]         base::close(...future.stdout)
[13:22:00.054]         ...future.stdout <- NULL
[13:22:00.054]     }
[13:22:00.054]     ...future.result$conditions <- ...future.conditions
[13:22:00.054]     ...future.result$finished <- base::Sys.time()
[13:22:00.054]     ...future.result
[13:22:00.054] }
[13:22:00.056] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[13:22:00.057] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[13:22:00.057] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[13:22:00.057] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[13:22:00.058] MultisessionFuture started
[13:22:00.058] - Launch lazy future ... done
[13:22:00.058] run() for ‘MultisessionFuture’ ... done
[13:22:00.058] getGlobalsAndPackages() ...
[13:22:00.058] Searching for globals...
[13:22:00.059] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:22:00.059] Searching for globals ... DONE
[13:22:00.059] Resolving globals: FALSE
[13:22:00.060] The total size of the 1 globals is 56 bytes (56 bytes)
[13:22:00.060] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:22:00.060] - globals: [1] ‘kk’
[13:22:00.060] 
[13:22:00.060] getGlobalsAndPackages() ... DONE
[13:22:00.060] run() for ‘Future’ ...
[13:22:00.061] - state: ‘created’
[13:22:00.061] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:00.075] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:00.075] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:00.075]   - Field: ‘node’
[13:22:00.075]   - Field: ‘label’
[13:22:00.075]   - Field: ‘local’
[13:22:00.075]   - Field: ‘owner’
[13:22:00.075]   - Field: ‘envir’
[13:22:00.076]   - Field: ‘workers’
[13:22:00.076]   - Field: ‘packages’
[13:22:00.076]   - Field: ‘gc’
[13:22:00.076]   - Field: ‘conditions’
[13:22:00.076]   - Field: ‘persistent’
[13:22:00.076]   - Field: ‘expr’
[13:22:00.079]   - Field: ‘uuid’
[13:22:00.079]   - Field: ‘seed’
[13:22:00.079]   - Field: ‘version’
[13:22:00.079]   - Field: ‘result’
[13:22:00.079]   - Field: ‘asynchronous’
[13:22:00.079]   - Field: ‘calls’
[13:22:00.079]   - Field: ‘globals’
[13:22:00.079]   - Field: ‘stdout’
[13:22:00.080]   - Field: ‘earlySignal’
[13:22:00.080]   - Field: ‘lazy’
[13:22:00.080]   - Field: ‘state’
[13:22:00.080] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:00.080] - Launch lazy future ...
[13:22:00.080] Packages needed by the future expression (n = 0): <none>
[13:22:00.080] Packages needed by future strategies (n = 0): <none>
[13:22:00.081] {
[13:22:00.081]     {
[13:22:00.081]         {
[13:22:00.081]             ...future.startTime <- base::Sys.time()
[13:22:00.081]             {
[13:22:00.081]                 {
[13:22:00.081]                   {
[13:22:00.081]                     {
[13:22:00.081]                       base::local({
[13:22:00.081]                         has_future <- base::requireNamespace("future", 
[13:22:00.081]                           quietly = TRUE)
[13:22:00.081]                         if (has_future) {
[13:22:00.081]                           ns <- base::getNamespace("future")
[13:22:00.081]                           version <- ns[[".package"]][["version"]]
[13:22:00.081]                           if (is.null(version)) 
[13:22:00.081]                             version <- utils::packageVersion("future")
[13:22:00.081]                         }
[13:22:00.081]                         else {
[13:22:00.081]                           version <- NULL
[13:22:00.081]                         }
[13:22:00.081]                         if (!has_future || version < "1.8.0") {
[13:22:00.081]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:00.081]                             "", base::R.version$version.string), 
[13:22:00.081]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:00.081]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:00.081]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:00.081]                               "release", "version")], collapse = " "), 
[13:22:00.081]                             hostname = base::Sys.info()[["nodename"]])
[13:22:00.081]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:00.081]                             info)
[13:22:00.081]                           info <- base::paste(info, collapse = "; ")
[13:22:00.081]                           if (!has_future) {
[13:22:00.081]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:00.081]                               info)
[13:22:00.081]                           }
[13:22:00.081]                           else {
[13:22:00.081]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:00.081]                               info, version)
[13:22:00.081]                           }
[13:22:00.081]                           base::stop(msg)
[13:22:00.081]                         }
[13:22:00.081]                       })
[13:22:00.081]                     }
[13:22:00.081]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:00.081]                     base::options(mc.cores = 1L)
[13:22:00.081]                   }
[13:22:00.081]                   options(future.plan = NULL)
[13:22:00.081]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:00.081]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:00.081]                 }
[13:22:00.081]                 ...future.workdir <- getwd()
[13:22:00.081]             }
[13:22:00.081]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:00.081]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:00.081]         }
[13:22:00.081]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:00.081]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:00.081]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:00.081]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:00.081]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:00.081]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:00.081]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:00.081]             base::names(...future.oldOptions))
[13:22:00.081]     }
[13:22:00.081]     if (FALSE) {
[13:22:00.081]     }
[13:22:00.081]     else {
[13:22:00.081]         if (TRUE) {
[13:22:00.081]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:00.081]                 open = "w")
[13:22:00.081]         }
[13:22:00.081]         else {
[13:22:00.081]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:00.081]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:00.081]         }
[13:22:00.081]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:00.081]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:00.081]             base::sink(type = "output", split = FALSE)
[13:22:00.081]             base::close(...future.stdout)
[13:22:00.081]         }, add = TRUE)
[13:22:00.081]     }
[13:22:00.081]     ...future.frame <- base::sys.nframe()
[13:22:00.081]     ...future.conditions <- base::list()
[13:22:00.081]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:00.081]     if (FALSE) {
[13:22:00.081]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:00.081]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:00.081]     }
[13:22:00.081]     ...future.result <- base::tryCatch({
[13:22:00.081]         base::withCallingHandlers({
[13:22:00.081]             ...future.value <- base::withVisible(base::local({
[13:22:00.081]                 ...future.makeSendCondition <- local({
[13:22:00.081]                   sendCondition <- NULL
[13:22:00.081]                   function(frame = 1L) {
[13:22:00.081]                     if (is.function(sendCondition)) 
[13:22:00.081]                       return(sendCondition)
[13:22:00.081]                     ns <- getNamespace("parallel")
[13:22:00.081]                     if (exists("sendData", mode = "function", 
[13:22:00.081]                       envir = ns)) {
[13:22:00.081]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:00.081]                         envir = ns)
[13:22:00.081]                       envir <- sys.frame(frame)
[13:22:00.081]                       master <- NULL
[13:22:00.081]                       while (!identical(envir, .GlobalEnv) && 
[13:22:00.081]                         !identical(envir, emptyenv())) {
[13:22:00.081]                         if (exists("master", mode = "list", envir = envir, 
[13:22:00.081]                           inherits = FALSE)) {
[13:22:00.081]                           master <- get("master", mode = "list", 
[13:22:00.081]                             envir = envir, inherits = FALSE)
[13:22:00.081]                           if (inherits(master, c("SOCKnode", 
[13:22:00.081]                             "SOCK0node"))) {
[13:22:00.081]                             sendCondition <<- function(cond) {
[13:22:00.081]                               data <- list(type = "VALUE", value = cond, 
[13:22:00.081]                                 success = TRUE)
[13:22:00.081]                               parallel_sendData(master, data)
[13:22:00.081]                             }
[13:22:00.081]                             return(sendCondition)
[13:22:00.081]                           }
[13:22:00.081]                         }
[13:22:00.081]                         frame <- frame + 1L
[13:22:00.081]                         envir <- sys.frame(frame)
[13:22:00.081]                       }
[13:22:00.081]                     }
[13:22:00.081]                     sendCondition <<- function(cond) NULL
[13:22:00.081]                   }
[13:22:00.081]                 })
[13:22:00.081]                 withCallingHandlers({
[13:22:00.081]                   {
[13:22:00.081]                     Sys.sleep(0.1)
[13:22:00.081]                     kk
[13:22:00.081]                   }
[13:22:00.081]                 }, immediateCondition = function(cond) {
[13:22:00.081]                   sendCondition <- ...future.makeSendCondition()
[13:22:00.081]                   sendCondition(cond)
[13:22:00.081]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.081]                   {
[13:22:00.081]                     inherits <- base::inherits
[13:22:00.081]                     invokeRestart <- base::invokeRestart
[13:22:00.081]                     is.null <- base::is.null
[13:22:00.081]                     muffled <- FALSE
[13:22:00.081]                     if (inherits(cond, "message")) {
[13:22:00.081]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:00.081]                       if (muffled) 
[13:22:00.081]                         invokeRestart("muffleMessage")
[13:22:00.081]                     }
[13:22:00.081]                     else if (inherits(cond, "warning")) {
[13:22:00.081]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:00.081]                       if (muffled) 
[13:22:00.081]                         invokeRestart("muffleWarning")
[13:22:00.081]                     }
[13:22:00.081]                     else if (inherits(cond, "condition")) {
[13:22:00.081]                       if (!is.null(pattern)) {
[13:22:00.081]                         computeRestarts <- base::computeRestarts
[13:22:00.081]                         grepl <- base::grepl
[13:22:00.081]                         restarts <- computeRestarts(cond)
[13:22:00.081]                         for (restart in restarts) {
[13:22:00.081]                           name <- restart$name
[13:22:00.081]                           if (is.null(name)) 
[13:22:00.081]                             next
[13:22:00.081]                           if (!grepl(pattern, name)) 
[13:22:00.081]                             next
[13:22:00.081]                           invokeRestart(restart)
[13:22:00.081]                           muffled <- TRUE
[13:22:00.081]                           break
[13:22:00.081]                         }
[13:22:00.081]                       }
[13:22:00.081]                     }
[13:22:00.081]                     invisible(muffled)
[13:22:00.081]                   }
[13:22:00.081]                   muffleCondition(cond)
[13:22:00.081]                 })
[13:22:00.081]             }))
[13:22:00.081]             future::FutureResult(value = ...future.value$value, 
[13:22:00.081]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:00.081]                   ...future.rng), globalenv = if (FALSE) 
[13:22:00.081]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:00.081]                     ...future.globalenv.names))
[13:22:00.081]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:00.081]         }, condition = base::local({
[13:22:00.081]             c <- base::c
[13:22:00.081]             inherits <- base::inherits
[13:22:00.081]             invokeRestart <- base::invokeRestart
[13:22:00.081]             length <- base::length
[13:22:00.081]             list <- base::list
[13:22:00.081]             seq.int <- base::seq.int
[13:22:00.081]             signalCondition <- base::signalCondition
[13:22:00.081]             sys.calls <- base::sys.calls
[13:22:00.081]             `[[` <- base::`[[`
[13:22:00.081]             `+` <- base::`+`
[13:22:00.081]             `<<-` <- base::`<<-`
[13:22:00.081]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:00.081]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:00.081]                   3L)]
[13:22:00.081]             }
[13:22:00.081]             function(cond) {
[13:22:00.081]                 is_error <- inherits(cond, "error")
[13:22:00.081]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:00.081]                   NULL)
[13:22:00.081]                 if (is_error) {
[13:22:00.081]                   sessionInformation <- function() {
[13:22:00.081]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:00.081]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:00.081]                       search = base::search(), system = base::Sys.info())
[13:22:00.081]                   }
[13:22:00.081]                   ...future.conditions[[length(...future.conditions) + 
[13:22:00.081]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:00.081]                     cond$call), session = sessionInformation(), 
[13:22:00.081]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:00.081]                   signalCondition(cond)
[13:22:00.081]                 }
[13:22:00.081]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:00.081]                 "immediateCondition"))) {
[13:22:00.081]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:00.081]                   ...future.conditions[[length(...future.conditions) + 
[13:22:00.081]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:00.081]                   if (TRUE && !signal) {
[13:22:00.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.081]                     {
[13:22:00.081]                       inherits <- base::inherits
[13:22:00.081]                       invokeRestart <- base::invokeRestart
[13:22:00.081]                       is.null <- base::is.null
[13:22:00.081]                       muffled <- FALSE
[13:22:00.081]                       if (inherits(cond, "message")) {
[13:22:00.081]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:00.081]                         if (muffled) 
[13:22:00.081]                           invokeRestart("muffleMessage")
[13:22:00.081]                       }
[13:22:00.081]                       else if (inherits(cond, "warning")) {
[13:22:00.081]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:00.081]                         if (muffled) 
[13:22:00.081]                           invokeRestart("muffleWarning")
[13:22:00.081]                       }
[13:22:00.081]                       else if (inherits(cond, "condition")) {
[13:22:00.081]                         if (!is.null(pattern)) {
[13:22:00.081]                           computeRestarts <- base::computeRestarts
[13:22:00.081]                           grepl <- base::grepl
[13:22:00.081]                           restarts <- computeRestarts(cond)
[13:22:00.081]                           for (restart in restarts) {
[13:22:00.081]                             name <- restart$name
[13:22:00.081]                             if (is.null(name)) 
[13:22:00.081]                               next
[13:22:00.081]                             if (!grepl(pattern, name)) 
[13:22:00.081]                               next
[13:22:00.081]                             invokeRestart(restart)
[13:22:00.081]                             muffled <- TRUE
[13:22:00.081]                             break
[13:22:00.081]                           }
[13:22:00.081]                         }
[13:22:00.081]                       }
[13:22:00.081]                       invisible(muffled)
[13:22:00.081]                     }
[13:22:00.081]                     muffleCondition(cond, pattern = "^muffle")
[13:22:00.081]                   }
[13:22:00.081]                 }
[13:22:00.081]                 else {
[13:22:00.081]                   if (TRUE) {
[13:22:00.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.081]                     {
[13:22:00.081]                       inherits <- base::inherits
[13:22:00.081]                       invokeRestart <- base::invokeRestart
[13:22:00.081]                       is.null <- base::is.null
[13:22:00.081]                       muffled <- FALSE
[13:22:00.081]                       if (inherits(cond, "message")) {
[13:22:00.081]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:00.081]                         if (muffled) 
[13:22:00.081]                           invokeRestart("muffleMessage")
[13:22:00.081]                       }
[13:22:00.081]                       else if (inherits(cond, "warning")) {
[13:22:00.081]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:00.081]                         if (muffled) 
[13:22:00.081]                           invokeRestart("muffleWarning")
[13:22:00.081]                       }
[13:22:00.081]                       else if (inherits(cond, "condition")) {
[13:22:00.081]                         if (!is.null(pattern)) {
[13:22:00.081]                           computeRestarts <- base::computeRestarts
[13:22:00.081]                           grepl <- base::grepl
[13:22:00.081]                           restarts <- computeRestarts(cond)
[13:22:00.081]                           for (restart in restarts) {
[13:22:00.081]                             name <- restart$name
[13:22:00.081]                             if (is.null(name)) 
[13:22:00.081]                               next
[13:22:00.081]                             if (!grepl(pattern, name)) 
[13:22:00.081]                               next
[13:22:00.081]                             invokeRestart(restart)
[13:22:00.081]                             muffled <- TRUE
[13:22:00.081]                             break
[13:22:00.081]                           }
[13:22:00.081]                         }
[13:22:00.081]                       }
[13:22:00.081]                       invisible(muffled)
[13:22:00.081]                     }
[13:22:00.081]                     muffleCondition(cond, pattern = "^muffle")
[13:22:00.081]                   }
[13:22:00.081]                 }
[13:22:00.081]             }
[13:22:00.081]         }))
[13:22:00.081]     }, error = function(ex) {
[13:22:00.081]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:00.081]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:00.081]                 ...future.rng), started = ...future.startTime, 
[13:22:00.081]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:00.081]             version = "1.8"), class = "FutureResult")
[13:22:00.081]     }, finally = {
[13:22:00.081]         if (!identical(...future.workdir, getwd())) 
[13:22:00.081]             setwd(...future.workdir)
[13:22:00.081]         {
[13:22:00.081]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:00.081]                 ...future.oldOptions$nwarnings <- NULL
[13:22:00.081]             }
[13:22:00.081]             base::options(...future.oldOptions)
[13:22:00.081]             if (.Platform$OS.type == "windows") {
[13:22:00.081]                 old_names <- names(...future.oldEnvVars)
[13:22:00.081]                 envs <- base::Sys.getenv()
[13:22:00.081]                 names <- names(envs)
[13:22:00.081]                 common <- intersect(names, old_names)
[13:22:00.081]                 added <- setdiff(names, old_names)
[13:22:00.081]                 removed <- setdiff(old_names, names)
[13:22:00.081]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:00.081]                   envs[common]]
[13:22:00.081]                 NAMES <- toupper(changed)
[13:22:00.081]                 args <- list()
[13:22:00.081]                 for (kk in seq_along(NAMES)) {
[13:22:00.081]                   name <- changed[[kk]]
[13:22:00.081]                   NAME <- NAMES[[kk]]
[13:22:00.081]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.081]                     next
[13:22:00.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:00.081]                 }
[13:22:00.081]                 NAMES <- toupper(added)
[13:22:00.081]                 for (kk in seq_along(NAMES)) {
[13:22:00.081]                   name <- added[[kk]]
[13:22:00.081]                   NAME <- NAMES[[kk]]
[13:22:00.081]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.081]                     next
[13:22:00.081]                   args[[name]] <- ""
[13:22:00.081]                 }
[13:22:00.081]                 NAMES <- toupper(removed)
[13:22:00.081]                 for (kk in seq_along(NAMES)) {
[13:22:00.081]                   name <- removed[[kk]]
[13:22:00.081]                   NAME <- NAMES[[kk]]
[13:22:00.081]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.081]                     next
[13:22:00.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:00.081]                 }
[13:22:00.081]                 if (length(args) > 0) 
[13:22:00.081]                   base::do.call(base::Sys.setenv, args = args)
[13:22:00.081]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:00.081]             }
[13:22:00.081]             else {
[13:22:00.081]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:00.081]             }
[13:22:00.081]             {
[13:22:00.081]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:00.081]                   0L) {
[13:22:00.081]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:00.081]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:00.081]                   base::options(opts)
[13:22:00.081]                 }
[13:22:00.081]                 {
[13:22:00.081]                   {
[13:22:00.081]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:00.081]                     NULL
[13:22:00.081]                   }
[13:22:00.081]                   options(future.plan = NULL)
[13:22:00.081]                   if (is.na(NA_character_)) 
[13:22:00.081]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:00.081]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:00.081]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:00.081]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:00.081]                     envir = parent.frame()) 
[13:22:00.081]                   {
[13:22:00.081]                     if (is.function(workers)) 
[13:22:00.081]                       workers <- workers()
[13:22:00.081]                     workers <- structure(as.integer(workers), 
[13:22:00.081]                       class = class(workers))
[13:22:00.081]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:00.081]                       workers >= 1)
[13:22:00.081]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:00.081]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:00.081]                     }
[13:22:00.081]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:00.081]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:00.081]                       envir = envir)
[13:22:00.081]                     if (!future$lazy) 
[13:22:00.081]                       future <- run(future)
[13:22:00.081]                     invisible(future)
[13:22:00.081]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:00.081]                 }
[13:22:00.081]             }
[13:22:00.081]         }
[13:22:00.081]     })
[13:22:00.081]     if (TRUE) {
[13:22:00.081]         base::sink(type = "output", split = FALSE)
[13:22:00.081]         if (TRUE) {
[13:22:00.081]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:00.081]         }
[13:22:00.081]         else {
[13:22:00.081]             ...future.result["stdout"] <- base::list(NULL)
[13:22:00.081]         }
[13:22:00.081]         base::close(...future.stdout)
[13:22:00.081]         ...future.stdout <- NULL
[13:22:00.081]     }
[13:22:00.081]     ...future.result$conditions <- ...future.conditions
[13:22:00.081]     ...future.result$finished <- base::Sys.time()
[13:22:00.081]     ...future.result
[13:22:00.081] }
[13:22:00.084] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[13:22:00.084] Exporting ‘kk’ (56 bytes) to cluster node #2 ...
[13:22:00.084] Exporting ‘kk’ (56 bytes) to cluster node #2 ... DONE
[13:22:00.084] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[13:22:00.085] MultisessionFuture started
[13:22:00.085] - Launch lazy future ... done
[13:22:00.085] run() for ‘MultisessionFuture’ ... done
[13:22:00.085] getGlobalsAndPackages() ...
[13:22:00.085] Searching for globals...
[13:22:00.086] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:22:00.086] Searching for globals ... DONE
[13:22:00.086] Resolving globals: FALSE
[13:22:00.087] The total size of the 1 globals is 56 bytes (56 bytes)
[13:22:00.087] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:22:00.087] - globals: [1] ‘kk’
[13:22:00.087] 
[13:22:00.087] getGlobalsAndPackages() ... DONE
[13:22:00.087] run() for ‘Future’ ...
[13:22:00.088] - state: ‘created’
[13:22:00.088] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:00.102] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:00.103] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:00.103]   - Field: ‘node’
[13:22:00.103]   - Field: ‘label’
[13:22:00.103]   - Field: ‘local’
[13:22:00.103]   - Field: ‘owner’
[13:22:00.103]   - Field: ‘envir’
[13:22:00.103]   - Field: ‘workers’
[13:22:00.103]   - Field: ‘packages’
[13:22:00.103]   - Field: ‘gc’
[13:22:00.103]   - Field: ‘conditions’
[13:22:00.104]   - Field: ‘persistent’
[13:22:00.104]   - Field: ‘expr’
[13:22:00.104]   - Field: ‘uuid’
[13:22:00.104]   - Field: ‘seed’
[13:22:00.104]   - Field: ‘version’
[13:22:00.104]   - Field: ‘result’
[13:22:00.104]   - Field: ‘asynchronous’
[13:22:00.104]   - Field: ‘calls’
[13:22:00.104]   - Field: ‘globals’
[13:22:00.104]   - Field: ‘stdout’
[13:22:00.104]   - Field: ‘earlySignal’
[13:22:00.104]   - Field: ‘lazy’
[13:22:00.105]   - Field: ‘state’
[13:22:00.105] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:00.105] - Launch lazy future ...
[13:22:00.105] Packages needed by the future expression (n = 0): <none>
[13:22:00.105] Packages needed by future strategies (n = 0): <none>
[13:22:00.106] {
[13:22:00.106]     {
[13:22:00.106]         {
[13:22:00.106]             ...future.startTime <- base::Sys.time()
[13:22:00.106]             {
[13:22:00.106]                 {
[13:22:00.106]                   {
[13:22:00.106]                     {
[13:22:00.106]                       base::local({
[13:22:00.106]                         has_future <- base::requireNamespace("future", 
[13:22:00.106]                           quietly = TRUE)
[13:22:00.106]                         if (has_future) {
[13:22:00.106]                           ns <- base::getNamespace("future")
[13:22:00.106]                           version <- ns[[".package"]][["version"]]
[13:22:00.106]                           if (is.null(version)) 
[13:22:00.106]                             version <- utils::packageVersion("future")
[13:22:00.106]                         }
[13:22:00.106]                         else {
[13:22:00.106]                           version <- NULL
[13:22:00.106]                         }
[13:22:00.106]                         if (!has_future || version < "1.8.0") {
[13:22:00.106]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:00.106]                             "", base::R.version$version.string), 
[13:22:00.106]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:00.106]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:00.106]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:00.106]                               "release", "version")], collapse = " "), 
[13:22:00.106]                             hostname = base::Sys.info()[["nodename"]])
[13:22:00.106]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:00.106]                             info)
[13:22:00.106]                           info <- base::paste(info, collapse = "; ")
[13:22:00.106]                           if (!has_future) {
[13:22:00.106]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:00.106]                               info)
[13:22:00.106]                           }
[13:22:00.106]                           else {
[13:22:00.106]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:00.106]                               info, version)
[13:22:00.106]                           }
[13:22:00.106]                           base::stop(msg)
[13:22:00.106]                         }
[13:22:00.106]                       })
[13:22:00.106]                     }
[13:22:00.106]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:00.106]                     base::options(mc.cores = 1L)
[13:22:00.106]                   }
[13:22:00.106]                   options(future.plan = NULL)
[13:22:00.106]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:00.106]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:00.106]                 }
[13:22:00.106]                 ...future.workdir <- getwd()
[13:22:00.106]             }
[13:22:00.106]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:00.106]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:00.106]         }
[13:22:00.106]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:00.106]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:00.106]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:00.106]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:00.106]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:00.106]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:00.106]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:00.106]             base::names(...future.oldOptions))
[13:22:00.106]     }
[13:22:00.106]     if (FALSE) {
[13:22:00.106]     }
[13:22:00.106]     else {
[13:22:00.106]         if (TRUE) {
[13:22:00.106]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:00.106]                 open = "w")
[13:22:00.106]         }
[13:22:00.106]         else {
[13:22:00.106]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:00.106]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:00.106]         }
[13:22:00.106]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:00.106]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:00.106]             base::sink(type = "output", split = FALSE)
[13:22:00.106]             base::close(...future.stdout)
[13:22:00.106]         }, add = TRUE)
[13:22:00.106]     }
[13:22:00.106]     ...future.frame <- base::sys.nframe()
[13:22:00.106]     ...future.conditions <- base::list()
[13:22:00.106]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:00.106]     if (FALSE) {
[13:22:00.106]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:00.106]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:00.106]     }
[13:22:00.106]     ...future.result <- base::tryCatch({
[13:22:00.106]         base::withCallingHandlers({
[13:22:00.106]             ...future.value <- base::withVisible(base::local({
[13:22:00.106]                 ...future.makeSendCondition <- local({
[13:22:00.106]                   sendCondition <- NULL
[13:22:00.106]                   function(frame = 1L) {
[13:22:00.106]                     if (is.function(sendCondition)) 
[13:22:00.106]                       return(sendCondition)
[13:22:00.106]                     ns <- getNamespace("parallel")
[13:22:00.106]                     if (exists("sendData", mode = "function", 
[13:22:00.106]                       envir = ns)) {
[13:22:00.106]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:00.106]                         envir = ns)
[13:22:00.106]                       envir <- sys.frame(frame)
[13:22:00.106]                       master <- NULL
[13:22:00.106]                       while (!identical(envir, .GlobalEnv) && 
[13:22:00.106]                         !identical(envir, emptyenv())) {
[13:22:00.106]                         if (exists("master", mode = "list", envir = envir, 
[13:22:00.106]                           inherits = FALSE)) {
[13:22:00.106]                           master <- get("master", mode = "list", 
[13:22:00.106]                             envir = envir, inherits = FALSE)
[13:22:00.106]                           if (inherits(master, c("SOCKnode", 
[13:22:00.106]                             "SOCK0node"))) {
[13:22:00.106]                             sendCondition <<- function(cond) {
[13:22:00.106]                               data <- list(type = "VALUE", value = cond, 
[13:22:00.106]                                 success = TRUE)
[13:22:00.106]                               parallel_sendData(master, data)
[13:22:00.106]                             }
[13:22:00.106]                             return(sendCondition)
[13:22:00.106]                           }
[13:22:00.106]                         }
[13:22:00.106]                         frame <- frame + 1L
[13:22:00.106]                         envir <- sys.frame(frame)
[13:22:00.106]                       }
[13:22:00.106]                     }
[13:22:00.106]                     sendCondition <<- function(cond) NULL
[13:22:00.106]                   }
[13:22:00.106]                 })
[13:22:00.106]                 withCallingHandlers({
[13:22:00.106]                   {
[13:22:00.106]                     Sys.sleep(0.1)
[13:22:00.106]                     kk
[13:22:00.106]                   }
[13:22:00.106]                 }, immediateCondition = function(cond) {
[13:22:00.106]                   sendCondition <- ...future.makeSendCondition()
[13:22:00.106]                   sendCondition(cond)
[13:22:00.106]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.106]                   {
[13:22:00.106]                     inherits <- base::inherits
[13:22:00.106]                     invokeRestart <- base::invokeRestart
[13:22:00.106]                     is.null <- base::is.null
[13:22:00.106]                     muffled <- FALSE
[13:22:00.106]                     if (inherits(cond, "message")) {
[13:22:00.106]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:00.106]                       if (muffled) 
[13:22:00.106]                         invokeRestart("muffleMessage")
[13:22:00.106]                     }
[13:22:00.106]                     else if (inherits(cond, "warning")) {
[13:22:00.106]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:00.106]                       if (muffled) 
[13:22:00.106]                         invokeRestart("muffleWarning")
[13:22:00.106]                     }
[13:22:00.106]                     else if (inherits(cond, "condition")) {
[13:22:00.106]                       if (!is.null(pattern)) {
[13:22:00.106]                         computeRestarts <- base::computeRestarts
[13:22:00.106]                         grepl <- base::grepl
[13:22:00.106]                         restarts <- computeRestarts(cond)
[13:22:00.106]                         for (restart in restarts) {
[13:22:00.106]                           name <- restart$name
[13:22:00.106]                           if (is.null(name)) 
[13:22:00.106]                             next
[13:22:00.106]                           if (!grepl(pattern, name)) 
[13:22:00.106]                             next
[13:22:00.106]                           invokeRestart(restart)
[13:22:00.106]                           muffled <- TRUE
[13:22:00.106]                           break
[13:22:00.106]                         }
[13:22:00.106]                       }
[13:22:00.106]                     }
[13:22:00.106]                     invisible(muffled)
[13:22:00.106]                   }
[13:22:00.106]                   muffleCondition(cond)
[13:22:00.106]                 })
[13:22:00.106]             }))
[13:22:00.106]             future::FutureResult(value = ...future.value$value, 
[13:22:00.106]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:00.106]                   ...future.rng), globalenv = if (FALSE) 
[13:22:00.106]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:00.106]                     ...future.globalenv.names))
[13:22:00.106]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:00.106]         }, condition = base::local({
[13:22:00.106]             c <- base::c
[13:22:00.106]             inherits <- base::inherits
[13:22:00.106]             invokeRestart <- base::invokeRestart
[13:22:00.106]             length <- base::length
[13:22:00.106]             list <- base::list
[13:22:00.106]             seq.int <- base::seq.int
[13:22:00.106]             signalCondition <- base::signalCondition
[13:22:00.106]             sys.calls <- base::sys.calls
[13:22:00.106]             `[[` <- base::`[[`
[13:22:00.106]             `+` <- base::`+`
[13:22:00.106]             `<<-` <- base::`<<-`
[13:22:00.106]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:00.106]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:00.106]                   3L)]
[13:22:00.106]             }
[13:22:00.106]             function(cond) {
[13:22:00.106]                 is_error <- inherits(cond, "error")
[13:22:00.106]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:00.106]                   NULL)
[13:22:00.106]                 if (is_error) {
[13:22:00.106]                   sessionInformation <- function() {
[13:22:00.106]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:00.106]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:00.106]                       search = base::search(), system = base::Sys.info())
[13:22:00.106]                   }
[13:22:00.106]                   ...future.conditions[[length(...future.conditions) + 
[13:22:00.106]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:00.106]                     cond$call), session = sessionInformation(), 
[13:22:00.106]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:00.106]                   signalCondition(cond)
[13:22:00.106]                 }
[13:22:00.106]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:00.106]                 "immediateCondition"))) {
[13:22:00.106]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:00.106]                   ...future.conditions[[length(...future.conditions) + 
[13:22:00.106]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:00.106]                   if (TRUE && !signal) {
[13:22:00.106]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.106]                     {
[13:22:00.106]                       inherits <- base::inherits
[13:22:00.106]                       invokeRestart <- base::invokeRestart
[13:22:00.106]                       is.null <- base::is.null
[13:22:00.106]                       muffled <- FALSE
[13:22:00.106]                       if (inherits(cond, "message")) {
[13:22:00.106]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:00.106]                         if (muffled) 
[13:22:00.106]                           invokeRestart("muffleMessage")
[13:22:00.106]                       }
[13:22:00.106]                       else if (inherits(cond, "warning")) {
[13:22:00.106]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:00.106]                         if (muffled) 
[13:22:00.106]                           invokeRestart("muffleWarning")
[13:22:00.106]                       }
[13:22:00.106]                       else if (inherits(cond, "condition")) {
[13:22:00.106]                         if (!is.null(pattern)) {
[13:22:00.106]                           computeRestarts <- base::computeRestarts
[13:22:00.106]                           grepl <- base::grepl
[13:22:00.106]                           restarts <- computeRestarts(cond)
[13:22:00.106]                           for (restart in restarts) {
[13:22:00.106]                             name <- restart$name
[13:22:00.106]                             if (is.null(name)) 
[13:22:00.106]                               next
[13:22:00.106]                             if (!grepl(pattern, name)) 
[13:22:00.106]                               next
[13:22:00.106]                             invokeRestart(restart)
[13:22:00.106]                             muffled <- TRUE
[13:22:00.106]                             break
[13:22:00.106]                           }
[13:22:00.106]                         }
[13:22:00.106]                       }
[13:22:00.106]                       invisible(muffled)
[13:22:00.106]                     }
[13:22:00.106]                     muffleCondition(cond, pattern = "^muffle")
[13:22:00.106]                   }
[13:22:00.106]                 }
[13:22:00.106]                 else {
[13:22:00.106]                   if (TRUE) {
[13:22:00.106]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.106]                     {
[13:22:00.106]                       inherits <- base::inherits
[13:22:00.106]                       invokeRestart <- base::invokeRestart
[13:22:00.106]                       is.null <- base::is.null
[13:22:00.106]                       muffled <- FALSE
[13:22:00.106]                       if (inherits(cond, "message")) {
[13:22:00.106]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:00.106]                         if (muffled) 
[13:22:00.106]                           invokeRestart("muffleMessage")
[13:22:00.106]                       }
[13:22:00.106]                       else if (inherits(cond, "warning")) {
[13:22:00.106]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:00.106]                         if (muffled) 
[13:22:00.106]                           invokeRestart("muffleWarning")
[13:22:00.106]                       }
[13:22:00.106]                       else if (inherits(cond, "condition")) {
[13:22:00.106]                         if (!is.null(pattern)) {
[13:22:00.106]                           computeRestarts <- base::computeRestarts
[13:22:00.106]                           grepl <- base::grepl
[13:22:00.106]                           restarts <- computeRestarts(cond)
[13:22:00.106]                           for (restart in restarts) {
[13:22:00.106]                             name <- restart$name
[13:22:00.106]                             if (is.null(name)) 
[13:22:00.106]                               next
[13:22:00.106]                             if (!grepl(pattern, name)) 
[13:22:00.106]                               next
[13:22:00.106]                             invokeRestart(restart)
[13:22:00.106]                             muffled <- TRUE
[13:22:00.106]                             break
[13:22:00.106]                           }
[13:22:00.106]                         }
[13:22:00.106]                       }
[13:22:00.106]                       invisible(muffled)
[13:22:00.106]                     }
[13:22:00.106]                     muffleCondition(cond, pattern = "^muffle")
[13:22:00.106]                   }
[13:22:00.106]                 }
[13:22:00.106]             }
[13:22:00.106]         }))
[13:22:00.106]     }, error = function(ex) {
[13:22:00.106]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:00.106]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:00.106]                 ...future.rng), started = ...future.startTime, 
[13:22:00.106]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:00.106]             version = "1.8"), class = "FutureResult")
[13:22:00.106]     }, finally = {
[13:22:00.106]         if (!identical(...future.workdir, getwd())) 
[13:22:00.106]             setwd(...future.workdir)
[13:22:00.106]         {
[13:22:00.106]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:00.106]                 ...future.oldOptions$nwarnings <- NULL
[13:22:00.106]             }
[13:22:00.106]             base::options(...future.oldOptions)
[13:22:00.106]             if (.Platform$OS.type == "windows") {
[13:22:00.106]                 old_names <- names(...future.oldEnvVars)
[13:22:00.106]                 envs <- base::Sys.getenv()
[13:22:00.106]                 names <- names(envs)
[13:22:00.106]                 common <- intersect(names, old_names)
[13:22:00.106]                 added <- setdiff(names, old_names)
[13:22:00.106]                 removed <- setdiff(old_names, names)
[13:22:00.106]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:00.106]                   envs[common]]
[13:22:00.106]                 NAMES <- toupper(changed)
[13:22:00.106]                 args <- list()
[13:22:00.106]                 for (kk in seq_along(NAMES)) {
[13:22:00.106]                   name <- changed[[kk]]
[13:22:00.106]                   NAME <- NAMES[[kk]]
[13:22:00.106]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.106]                     next
[13:22:00.106]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:00.106]                 }
[13:22:00.106]                 NAMES <- toupper(added)
[13:22:00.106]                 for (kk in seq_along(NAMES)) {
[13:22:00.106]                   name <- added[[kk]]
[13:22:00.106]                   NAME <- NAMES[[kk]]
[13:22:00.106]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.106]                     next
[13:22:00.106]                   args[[name]] <- ""
[13:22:00.106]                 }
[13:22:00.106]                 NAMES <- toupper(removed)
[13:22:00.106]                 for (kk in seq_along(NAMES)) {
[13:22:00.106]                   name <- removed[[kk]]
[13:22:00.106]                   NAME <- NAMES[[kk]]
[13:22:00.106]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.106]                     next
[13:22:00.106]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:00.106]                 }
[13:22:00.106]                 if (length(args) > 0) 
[13:22:00.106]                   base::do.call(base::Sys.setenv, args = args)
[13:22:00.106]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:00.106]             }
[13:22:00.106]             else {
[13:22:00.106]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:00.106]             }
[13:22:00.106]             {
[13:22:00.106]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:00.106]                   0L) {
[13:22:00.106]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:00.106]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:00.106]                   base::options(opts)
[13:22:00.106]                 }
[13:22:00.106]                 {
[13:22:00.106]                   {
[13:22:00.106]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:00.106]                     NULL
[13:22:00.106]                   }
[13:22:00.106]                   options(future.plan = NULL)
[13:22:00.106]                   if (is.na(NA_character_)) 
[13:22:00.106]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:00.106]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:00.106]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:00.106]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:00.106]                     envir = parent.frame()) 
[13:22:00.106]                   {
[13:22:00.106]                     if (is.function(workers)) 
[13:22:00.106]                       workers <- workers()
[13:22:00.106]                     workers <- structure(as.integer(workers), 
[13:22:00.106]                       class = class(workers))
[13:22:00.106]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:00.106]                       workers >= 1)
[13:22:00.106]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:00.106]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:00.106]                     }
[13:22:00.106]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:00.106]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:00.106]                       envir = envir)
[13:22:00.106]                     if (!future$lazy) 
[13:22:00.106]                       future <- run(future)
[13:22:00.106]                     invisible(future)
[13:22:00.106]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:00.106]                 }
[13:22:00.106]             }
[13:22:00.106]         }
[13:22:00.106]     })
[13:22:00.106]     if (TRUE) {
[13:22:00.106]         base::sink(type = "output", split = FALSE)
[13:22:00.106]         if (TRUE) {
[13:22:00.106]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:00.106]         }
[13:22:00.106]         else {
[13:22:00.106]             ...future.result["stdout"] <- base::list(NULL)
[13:22:00.106]         }
[13:22:00.106]         base::close(...future.stdout)
[13:22:00.106]         ...future.stdout <- NULL
[13:22:00.106]     }
[13:22:00.106]     ...future.result$conditions <- ...future.conditions
[13:22:00.106]     ...future.result$finished <- base::Sys.time()
[13:22:00.106]     ...future.result
[13:22:00.106] }
[13:22:00.108] Poll #1 (0): usedNodes() = 2, workers = 2
[13:22:00.139] Poll #2 (0.03 secs): usedNodes() = 2, workers = 2
[13:22:00.171] Poll #3 (0.06 secs): usedNodes() = 2, workers = 2
[13:22:00.202] Poll #4 (0.09 secs): usedNodes() = 2, workers = 2
[13:22:00.214] receiveMessageFromWorker() for ClusterFuture ...
[13:22:00.214] - Validating connection of MultisessionFuture
[13:22:00.214] - received message: FutureResult
[13:22:00.214] - Received FutureResult
[13:22:00.214] - Erased future from FutureRegistry
[13:22:00.214] result() for ClusterFuture ...
[13:22:00.214] - result already collected: FutureResult
[13:22:00.214] result() for ClusterFuture ... done
[13:22:00.214] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:00.215] result() for ClusterFuture ...
[13:22:00.215] - result already collected: FutureResult
[13:22:00.215] result() for ClusterFuture ... done
[13:22:00.215] result() for ClusterFuture ...
[13:22:00.215] - result already collected: FutureResult
[13:22:00.215] result() for ClusterFuture ... done
[13:22:00.216] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[13:22:00.216] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[13:22:00.216] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[13:22:00.216] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[13:22:00.217] MultisessionFuture started
[13:22:00.217] - Launch lazy future ... done
[13:22:00.217] run() for ‘MultisessionFuture’ ... done
[13:22:00.218] resolve() on list ...
[13:22:00.218]  recursive: 0
[13:22:00.218]  length: 3
[13:22:00.218] 
[13:22:00.218] Future #1
[13:22:00.218]  length: 2 (resolved future 1)
[13:22:00.250] receiveMessageFromWorker() for ClusterFuture ...
[13:22:00.250] - Validating connection of MultisessionFuture
[13:22:00.250] - received message: FutureResult
[13:22:00.250] - Received FutureResult
[13:22:00.250] - Erased future from FutureRegistry
[13:22:00.250] result() for ClusterFuture ...
[13:22:00.250] - result already collected: FutureResult
[13:22:00.250] result() for ClusterFuture ... done
[13:22:00.251] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:00.251] Future #2
[13:22:00.251]  length: 1 (resolved future 2)
[13:22:00.375] receiveMessageFromWorker() for ClusterFuture ...
[13:22:00.375] - Validating connection of MultisessionFuture
[13:22:00.375] - received message: FutureResult
[13:22:00.376] - Received FutureResult
[13:22:00.376] - Erased future from FutureRegistry
[13:22:00.376] result() for ClusterFuture ...
[13:22:00.376] - result already collected: FutureResult
[13:22:00.376] result() for ClusterFuture ... done
[13:22:00.376] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:00.376] Future #3
[13:22:00.376]  length: 0 (resolved future 3)
[13:22:00.376] resolve() on list ... DONE
[13:22:00.377] getGlobalsAndPackages() ...
[13:22:00.377] Searching for globals...
[13:22:00.378] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:22:00.378] Searching for globals ... DONE
[13:22:00.378] Resolving globals: FALSE
[13:22:00.378] The total size of the 1 globals is 56 bytes (56 bytes)
[13:22:00.379] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:22:00.379] - globals: [1] ‘kk’
[13:22:00.379] 
[13:22:00.379] getGlobalsAndPackages() ... DONE
[13:22:00.379] getGlobalsAndPackages() ...
[13:22:00.379] Searching for globals...
[13:22:00.380] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:22:00.380] Searching for globals ... DONE
[13:22:00.381] Resolving globals: FALSE
[13:22:00.381] The total size of the 1 globals is 56 bytes (56 bytes)
[13:22:00.381] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:22:00.381] - globals: [1] ‘kk’
[13:22:00.381] 
[13:22:00.382] getGlobalsAndPackages() ... DONE
[13:22:00.382] getGlobalsAndPackages() ...
[13:22:00.382] Searching for globals...
[13:22:00.383] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:22:00.383] Searching for globals ... DONE
[13:22:00.383] Resolving globals: FALSE
[13:22:00.383] The total size of the 1 globals is 56 bytes (56 bytes)
[13:22:00.384] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:22:00.384] - globals: [1] ‘kk’
[13:22:00.384] 
[13:22:00.384] getGlobalsAndPackages() ... DONE
[13:22:00.384] resolve() on list ...
[13:22:00.384]  recursive: 0
[13:22:00.384]  length: 3
[13:22:00.384] 
[13:22:00.385] run() for ‘Future’ ...
[13:22:00.385] - state: ‘created’
[13:22:00.385] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:00.399] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:00.399] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:00.399]   - Field: ‘node’
[13:22:00.399]   - Field: ‘label’
[13:22:00.400]   - Field: ‘local’
[13:22:00.400]   - Field: ‘owner’
[13:22:00.400]   - Field: ‘envir’
[13:22:00.400]   - Field: ‘workers’
[13:22:00.400]   - Field: ‘packages’
[13:22:00.400]   - Field: ‘gc’
[13:22:00.400]   - Field: ‘conditions’
[13:22:00.400]   - Field: ‘persistent’
[13:22:00.400]   - Field: ‘expr’
[13:22:00.400]   - Field: ‘uuid’
[13:22:00.400]   - Field: ‘seed’
[13:22:00.400]   - Field: ‘version’
[13:22:00.401]   - Field: ‘result’
[13:22:00.401]   - Field: ‘asynchronous’
[13:22:00.401]   - Field: ‘calls’
[13:22:00.401]   - Field: ‘globals’
[13:22:00.401]   - Field: ‘stdout’
[13:22:00.401]   - Field: ‘earlySignal’
[13:22:00.401]   - Field: ‘lazy’
[13:22:00.401]   - Field: ‘state’
[13:22:00.401] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:00.401] - Launch lazy future ...
[13:22:00.402] Packages needed by the future expression (n = 0): <none>
[13:22:00.402] Packages needed by future strategies (n = 0): <none>
[13:22:00.402] {
[13:22:00.402]     {
[13:22:00.402]         {
[13:22:00.402]             ...future.startTime <- base::Sys.time()
[13:22:00.402]             {
[13:22:00.402]                 {
[13:22:00.402]                   {
[13:22:00.402]                     {
[13:22:00.402]                       base::local({
[13:22:00.402]                         has_future <- base::requireNamespace("future", 
[13:22:00.402]                           quietly = TRUE)
[13:22:00.402]                         if (has_future) {
[13:22:00.402]                           ns <- base::getNamespace("future")
[13:22:00.402]                           version <- ns[[".package"]][["version"]]
[13:22:00.402]                           if (is.null(version)) 
[13:22:00.402]                             version <- utils::packageVersion("future")
[13:22:00.402]                         }
[13:22:00.402]                         else {
[13:22:00.402]                           version <- NULL
[13:22:00.402]                         }
[13:22:00.402]                         if (!has_future || version < "1.8.0") {
[13:22:00.402]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:00.402]                             "", base::R.version$version.string), 
[13:22:00.402]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:00.402]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:00.402]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:00.402]                               "release", "version")], collapse = " "), 
[13:22:00.402]                             hostname = base::Sys.info()[["nodename"]])
[13:22:00.402]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:00.402]                             info)
[13:22:00.402]                           info <- base::paste(info, collapse = "; ")
[13:22:00.402]                           if (!has_future) {
[13:22:00.402]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:00.402]                               info)
[13:22:00.402]                           }
[13:22:00.402]                           else {
[13:22:00.402]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:00.402]                               info, version)
[13:22:00.402]                           }
[13:22:00.402]                           base::stop(msg)
[13:22:00.402]                         }
[13:22:00.402]                       })
[13:22:00.402]                     }
[13:22:00.402]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:00.402]                     base::options(mc.cores = 1L)
[13:22:00.402]                   }
[13:22:00.402]                   options(future.plan = NULL)
[13:22:00.402]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:00.402]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:00.402]                 }
[13:22:00.402]                 ...future.workdir <- getwd()
[13:22:00.402]             }
[13:22:00.402]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:00.402]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:00.402]         }
[13:22:00.402]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:00.402]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:00.402]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:00.402]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:00.402]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:00.402]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:00.402]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:00.402]             base::names(...future.oldOptions))
[13:22:00.402]     }
[13:22:00.402]     if (FALSE) {
[13:22:00.402]     }
[13:22:00.402]     else {
[13:22:00.402]         if (TRUE) {
[13:22:00.402]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:00.402]                 open = "w")
[13:22:00.402]         }
[13:22:00.402]         else {
[13:22:00.402]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:00.402]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:00.402]         }
[13:22:00.402]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:00.402]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:00.402]             base::sink(type = "output", split = FALSE)
[13:22:00.402]             base::close(...future.stdout)
[13:22:00.402]         }, add = TRUE)
[13:22:00.402]     }
[13:22:00.402]     ...future.frame <- base::sys.nframe()
[13:22:00.402]     ...future.conditions <- base::list()
[13:22:00.402]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:00.402]     if (FALSE) {
[13:22:00.402]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:00.402]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:00.402]     }
[13:22:00.402]     ...future.result <- base::tryCatch({
[13:22:00.402]         base::withCallingHandlers({
[13:22:00.402]             ...future.value <- base::withVisible(base::local({
[13:22:00.402]                 ...future.makeSendCondition <- local({
[13:22:00.402]                   sendCondition <- NULL
[13:22:00.402]                   function(frame = 1L) {
[13:22:00.402]                     if (is.function(sendCondition)) 
[13:22:00.402]                       return(sendCondition)
[13:22:00.402]                     ns <- getNamespace("parallel")
[13:22:00.402]                     if (exists("sendData", mode = "function", 
[13:22:00.402]                       envir = ns)) {
[13:22:00.402]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:00.402]                         envir = ns)
[13:22:00.402]                       envir <- sys.frame(frame)
[13:22:00.402]                       master <- NULL
[13:22:00.402]                       while (!identical(envir, .GlobalEnv) && 
[13:22:00.402]                         !identical(envir, emptyenv())) {
[13:22:00.402]                         if (exists("master", mode = "list", envir = envir, 
[13:22:00.402]                           inherits = FALSE)) {
[13:22:00.402]                           master <- get("master", mode = "list", 
[13:22:00.402]                             envir = envir, inherits = FALSE)
[13:22:00.402]                           if (inherits(master, c("SOCKnode", 
[13:22:00.402]                             "SOCK0node"))) {
[13:22:00.402]                             sendCondition <<- function(cond) {
[13:22:00.402]                               data <- list(type = "VALUE", value = cond, 
[13:22:00.402]                                 success = TRUE)
[13:22:00.402]                               parallel_sendData(master, data)
[13:22:00.402]                             }
[13:22:00.402]                             return(sendCondition)
[13:22:00.402]                           }
[13:22:00.402]                         }
[13:22:00.402]                         frame <- frame + 1L
[13:22:00.402]                         envir <- sys.frame(frame)
[13:22:00.402]                       }
[13:22:00.402]                     }
[13:22:00.402]                     sendCondition <<- function(cond) NULL
[13:22:00.402]                   }
[13:22:00.402]                 })
[13:22:00.402]                 withCallingHandlers({
[13:22:00.402]                   {
[13:22:00.402]                     Sys.sleep(0.1)
[13:22:00.402]                     kk
[13:22:00.402]                   }
[13:22:00.402]                 }, immediateCondition = function(cond) {
[13:22:00.402]                   sendCondition <- ...future.makeSendCondition()
[13:22:00.402]                   sendCondition(cond)
[13:22:00.402]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.402]                   {
[13:22:00.402]                     inherits <- base::inherits
[13:22:00.402]                     invokeRestart <- base::invokeRestart
[13:22:00.402]                     is.null <- base::is.null
[13:22:00.402]                     muffled <- FALSE
[13:22:00.402]                     if (inherits(cond, "message")) {
[13:22:00.402]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:00.402]                       if (muffled) 
[13:22:00.402]                         invokeRestart("muffleMessage")
[13:22:00.402]                     }
[13:22:00.402]                     else if (inherits(cond, "warning")) {
[13:22:00.402]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:00.402]                       if (muffled) 
[13:22:00.402]                         invokeRestart("muffleWarning")
[13:22:00.402]                     }
[13:22:00.402]                     else if (inherits(cond, "condition")) {
[13:22:00.402]                       if (!is.null(pattern)) {
[13:22:00.402]                         computeRestarts <- base::computeRestarts
[13:22:00.402]                         grepl <- base::grepl
[13:22:00.402]                         restarts <- computeRestarts(cond)
[13:22:00.402]                         for (restart in restarts) {
[13:22:00.402]                           name <- restart$name
[13:22:00.402]                           if (is.null(name)) 
[13:22:00.402]                             next
[13:22:00.402]                           if (!grepl(pattern, name)) 
[13:22:00.402]                             next
[13:22:00.402]                           invokeRestart(restart)
[13:22:00.402]                           muffled <- TRUE
[13:22:00.402]                           break
[13:22:00.402]                         }
[13:22:00.402]                       }
[13:22:00.402]                     }
[13:22:00.402]                     invisible(muffled)
[13:22:00.402]                   }
[13:22:00.402]                   muffleCondition(cond)
[13:22:00.402]                 })
[13:22:00.402]             }))
[13:22:00.402]             future::FutureResult(value = ...future.value$value, 
[13:22:00.402]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:00.402]                   ...future.rng), globalenv = if (FALSE) 
[13:22:00.402]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:00.402]                     ...future.globalenv.names))
[13:22:00.402]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:00.402]         }, condition = base::local({
[13:22:00.402]             c <- base::c
[13:22:00.402]             inherits <- base::inherits
[13:22:00.402]             invokeRestart <- base::invokeRestart
[13:22:00.402]             length <- base::length
[13:22:00.402]             list <- base::list
[13:22:00.402]             seq.int <- base::seq.int
[13:22:00.402]             signalCondition <- base::signalCondition
[13:22:00.402]             sys.calls <- base::sys.calls
[13:22:00.402]             `[[` <- base::`[[`
[13:22:00.402]             `+` <- base::`+`
[13:22:00.402]             `<<-` <- base::`<<-`
[13:22:00.402]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:00.402]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:00.402]                   3L)]
[13:22:00.402]             }
[13:22:00.402]             function(cond) {
[13:22:00.402]                 is_error <- inherits(cond, "error")
[13:22:00.402]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:00.402]                   NULL)
[13:22:00.402]                 if (is_error) {
[13:22:00.402]                   sessionInformation <- function() {
[13:22:00.402]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:00.402]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:00.402]                       search = base::search(), system = base::Sys.info())
[13:22:00.402]                   }
[13:22:00.402]                   ...future.conditions[[length(...future.conditions) + 
[13:22:00.402]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:00.402]                     cond$call), session = sessionInformation(), 
[13:22:00.402]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:00.402]                   signalCondition(cond)
[13:22:00.402]                 }
[13:22:00.402]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:00.402]                 "immediateCondition"))) {
[13:22:00.402]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:00.402]                   ...future.conditions[[length(...future.conditions) + 
[13:22:00.402]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:00.402]                   if (TRUE && !signal) {
[13:22:00.402]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.402]                     {
[13:22:00.402]                       inherits <- base::inherits
[13:22:00.402]                       invokeRestart <- base::invokeRestart
[13:22:00.402]                       is.null <- base::is.null
[13:22:00.402]                       muffled <- FALSE
[13:22:00.402]                       if (inherits(cond, "message")) {
[13:22:00.402]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:00.402]                         if (muffled) 
[13:22:00.402]                           invokeRestart("muffleMessage")
[13:22:00.402]                       }
[13:22:00.402]                       else if (inherits(cond, "warning")) {
[13:22:00.402]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:00.402]                         if (muffled) 
[13:22:00.402]                           invokeRestart("muffleWarning")
[13:22:00.402]                       }
[13:22:00.402]                       else if (inherits(cond, "condition")) {
[13:22:00.402]                         if (!is.null(pattern)) {
[13:22:00.402]                           computeRestarts <- base::computeRestarts
[13:22:00.402]                           grepl <- base::grepl
[13:22:00.402]                           restarts <- computeRestarts(cond)
[13:22:00.402]                           for (restart in restarts) {
[13:22:00.402]                             name <- restart$name
[13:22:00.402]                             if (is.null(name)) 
[13:22:00.402]                               next
[13:22:00.402]                             if (!grepl(pattern, name)) 
[13:22:00.402]                               next
[13:22:00.402]                             invokeRestart(restart)
[13:22:00.402]                             muffled <- TRUE
[13:22:00.402]                             break
[13:22:00.402]                           }
[13:22:00.402]                         }
[13:22:00.402]                       }
[13:22:00.402]                       invisible(muffled)
[13:22:00.402]                     }
[13:22:00.402]                     muffleCondition(cond, pattern = "^muffle")
[13:22:00.402]                   }
[13:22:00.402]                 }
[13:22:00.402]                 else {
[13:22:00.402]                   if (TRUE) {
[13:22:00.402]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.402]                     {
[13:22:00.402]                       inherits <- base::inherits
[13:22:00.402]                       invokeRestart <- base::invokeRestart
[13:22:00.402]                       is.null <- base::is.null
[13:22:00.402]                       muffled <- FALSE
[13:22:00.402]                       if (inherits(cond, "message")) {
[13:22:00.402]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:00.402]                         if (muffled) 
[13:22:00.402]                           invokeRestart("muffleMessage")
[13:22:00.402]                       }
[13:22:00.402]                       else if (inherits(cond, "warning")) {
[13:22:00.402]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:00.402]                         if (muffled) 
[13:22:00.402]                           invokeRestart("muffleWarning")
[13:22:00.402]                       }
[13:22:00.402]                       else if (inherits(cond, "condition")) {
[13:22:00.402]                         if (!is.null(pattern)) {
[13:22:00.402]                           computeRestarts <- base::computeRestarts
[13:22:00.402]                           grepl <- base::grepl
[13:22:00.402]                           restarts <- computeRestarts(cond)
[13:22:00.402]                           for (restart in restarts) {
[13:22:00.402]                             name <- restart$name
[13:22:00.402]                             if (is.null(name)) 
[13:22:00.402]                               next
[13:22:00.402]                             if (!grepl(pattern, name)) 
[13:22:00.402]                               next
[13:22:00.402]                             invokeRestart(restart)
[13:22:00.402]                             muffled <- TRUE
[13:22:00.402]                             break
[13:22:00.402]                           }
[13:22:00.402]                         }
[13:22:00.402]                       }
[13:22:00.402]                       invisible(muffled)
[13:22:00.402]                     }
[13:22:00.402]                     muffleCondition(cond, pattern = "^muffle")
[13:22:00.402]                   }
[13:22:00.402]                 }
[13:22:00.402]             }
[13:22:00.402]         }))
[13:22:00.402]     }, error = function(ex) {
[13:22:00.402]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:00.402]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:00.402]                 ...future.rng), started = ...future.startTime, 
[13:22:00.402]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:00.402]             version = "1.8"), class = "FutureResult")
[13:22:00.402]     }, finally = {
[13:22:00.402]         if (!identical(...future.workdir, getwd())) 
[13:22:00.402]             setwd(...future.workdir)
[13:22:00.402]         {
[13:22:00.402]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:00.402]                 ...future.oldOptions$nwarnings <- NULL
[13:22:00.402]             }
[13:22:00.402]             base::options(...future.oldOptions)
[13:22:00.402]             if (.Platform$OS.type == "windows") {
[13:22:00.402]                 old_names <- names(...future.oldEnvVars)
[13:22:00.402]                 envs <- base::Sys.getenv()
[13:22:00.402]                 names <- names(envs)
[13:22:00.402]                 common <- intersect(names, old_names)
[13:22:00.402]                 added <- setdiff(names, old_names)
[13:22:00.402]                 removed <- setdiff(old_names, names)
[13:22:00.402]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:00.402]                   envs[common]]
[13:22:00.402]                 NAMES <- toupper(changed)
[13:22:00.402]                 args <- list()
[13:22:00.402]                 for (kk in seq_along(NAMES)) {
[13:22:00.402]                   name <- changed[[kk]]
[13:22:00.402]                   NAME <- NAMES[[kk]]
[13:22:00.402]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.402]                     next
[13:22:00.402]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:00.402]                 }
[13:22:00.402]                 NAMES <- toupper(added)
[13:22:00.402]                 for (kk in seq_along(NAMES)) {
[13:22:00.402]                   name <- added[[kk]]
[13:22:00.402]                   NAME <- NAMES[[kk]]
[13:22:00.402]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.402]                     next
[13:22:00.402]                   args[[name]] <- ""
[13:22:00.402]                 }
[13:22:00.402]                 NAMES <- toupper(removed)
[13:22:00.402]                 for (kk in seq_along(NAMES)) {
[13:22:00.402]                   name <- removed[[kk]]
[13:22:00.402]                   NAME <- NAMES[[kk]]
[13:22:00.402]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.402]                     next
[13:22:00.402]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:00.402]                 }
[13:22:00.402]                 if (length(args) > 0) 
[13:22:00.402]                   base::do.call(base::Sys.setenv, args = args)
[13:22:00.402]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:00.402]             }
[13:22:00.402]             else {
[13:22:00.402]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:00.402]             }
[13:22:00.402]             {
[13:22:00.402]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:00.402]                   0L) {
[13:22:00.402]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:00.402]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:00.402]                   base::options(opts)
[13:22:00.402]                 }
[13:22:00.402]                 {
[13:22:00.402]                   {
[13:22:00.402]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:00.402]                     NULL
[13:22:00.402]                   }
[13:22:00.402]                   options(future.plan = NULL)
[13:22:00.402]                   if (is.na(NA_character_)) 
[13:22:00.402]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:00.402]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:00.402]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:00.402]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:00.402]                     envir = parent.frame()) 
[13:22:00.402]                   {
[13:22:00.402]                     if (is.function(workers)) 
[13:22:00.402]                       workers <- workers()
[13:22:00.402]                     workers <- structure(as.integer(workers), 
[13:22:00.402]                       class = class(workers))
[13:22:00.402]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:00.402]                       workers >= 1)
[13:22:00.402]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:00.402]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:00.402]                     }
[13:22:00.402]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:00.402]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:00.402]                       envir = envir)
[13:22:00.402]                     if (!future$lazy) 
[13:22:00.402]                       future <- run(future)
[13:22:00.402]                     invisible(future)
[13:22:00.402]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:00.402]                 }
[13:22:00.402]             }
[13:22:00.402]         }
[13:22:00.402]     })
[13:22:00.402]     if (TRUE) {
[13:22:00.402]         base::sink(type = "output", split = FALSE)
[13:22:00.402]         if (TRUE) {
[13:22:00.402]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:00.402]         }
[13:22:00.402]         else {
[13:22:00.402]             ...future.result["stdout"] <- base::list(NULL)
[13:22:00.402]         }
[13:22:00.402]         base::close(...future.stdout)
[13:22:00.402]         ...future.stdout <- NULL
[13:22:00.402]     }
[13:22:00.402]     ...future.result$conditions <- ...future.conditions
[13:22:00.402]     ...future.result$finished <- base::Sys.time()
[13:22:00.402]     ...future.result
[13:22:00.402] }
[13:22:00.405] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[13:22:00.405] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[13:22:00.406] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[13:22:00.406] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[13:22:00.406] MultisessionFuture started
[13:22:00.406] - Launch lazy future ... done
[13:22:00.406] run() for ‘MultisessionFuture’ ... done
[13:22:00.417] run() for ‘Future’ ...
[13:22:00.417] - state: ‘created’
[13:22:00.417] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:00.431] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:00.432] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:00.432]   - Field: ‘node’
[13:22:00.432]   - Field: ‘label’
[13:22:00.432]   - Field: ‘local’
[13:22:00.432]   - Field: ‘owner’
[13:22:00.432]   - Field: ‘envir’
[13:22:00.432]   - Field: ‘workers’
[13:22:00.432]   - Field: ‘packages’
[13:22:00.432]   - Field: ‘gc’
[13:22:00.432]   - Field: ‘conditions’
[13:22:00.432]   - Field: ‘persistent’
[13:22:00.433]   - Field: ‘expr’
[13:22:00.433]   - Field: ‘uuid’
[13:22:00.433]   - Field: ‘seed’
[13:22:00.433]   - Field: ‘version’
[13:22:00.433]   - Field: ‘result’
[13:22:00.433]   - Field: ‘asynchronous’
[13:22:00.433]   - Field: ‘calls’
[13:22:00.433]   - Field: ‘globals’
[13:22:00.433]   - Field: ‘stdout’
[13:22:00.433]   - Field: ‘earlySignal’
[13:22:00.434]   - Field: ‘lazy’
[13:22:00.434]   - Field: ‘state’
[13:22:00.434] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:00.434] - Launch lazy future ...
[13:22:00.434] Packages needed by the future expression (n = 0): <none>
[13:22:00.434] Packages needed by future strategies (n = 0): <none>
[13:22:00.435] {
[13:22:00.435]     {
[13:22:00.435]         {
[13:22:00.435]             ...future.startTime <- base::Sys.time()
[13:22:00.435]             {
[13:22:00.435]                 {
[13:22:00.435]                   {
[13:22:00.435]                     {
[13:22:00.435]                       base::local({
[13:22:00.435]                         has_future <- base::requireNamespace("future", 
[13:22:00.435]                           quietly = TRUE)
[13:22:00.435]                         if (has_future) {
[13:22:00.435]                           ns <- base::getNamespace("future")
[13:22:00.435]                           version <- ns[[".package"]][["version"]]
[13:22:00.435]                           if (is.null(version)) 
[13:22:00.435]                             version <- utils::packageVersion("future")
[13:22:00.435]                         }
[13:22:00.435]                         else {
[13:22:00.435]                           version <- NULL
[13:22:00.435]                         }
[13:22:00.435]                         if (!has_future || version < "1.8.0") {
[13:22:00.435]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:00.435]                             "", base::R.version$version.string), 
[13:22:00.435]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:00.435]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:00.435]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:00.435]                               "release", "version")], collapse = " "), 
[13:22:00.435]                             hostname = base::Sys.info()[["nodename"]])
[13:22:00.435]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:00.435]                             info)
[13:22:00.435]                           info <- base::paste(info, collapse = "; ")
[13:22:00.435]                           if (!has_future) {
[13:22:00.435]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:00.435]                               info)
[13:22:00.435]                           }
[13:22:00.435]                           else {
[13:22:00.435]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:00.435]                               info, version)
[13:22:00.435]                           }
[13:22:00.435]                           base::stop(msg)
[13:22:00.435]                         }
[13:22:00.435]                       })
[13:22:00.435]                     }
[13:22:00.435]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:00.435]                     base::options(mc.cores = 1L)
[13:22:00.435]                   }
[13:22:00.435]                   options(future.plan = NULL)
[13:22:00.435]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:00.435]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:00.435]                 }
[13:22:00.435]                 ...future.workdir <- getwd()
[13:22:00.435]             }
[13:22:00.435]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:00.435]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:00.435]         }
[13:22:00.435]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:00.435]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:00.435]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:00.435]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:00.435]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:00.435]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:00.435]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:00.435]             base::names(...future.oldOptions))
[13:22:00.435]     }
[13:22:00.435]     if (FALSE) {
[13:22:00.435]     }
[13:22:00.435]     else {
[13:22:00.435]         if (TRUE) {
[13:22:00.435]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:00.435]                 open = "w")
[13:22:00.435]         }
[13:22:00.435]         else {
[13:22:00.435]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:00.435]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:00.435]         }
[13:22:00.435]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:00.435]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:00.435]             base::sink(type = "output", split = FALSE)
[13:22:00.435]             base::close(...future.stdout)
[13:22:00.435]         }, add = TRUE)
[13:22:00.435]     }
[13:22:00.435]     ...future.frame <- base::sys.nframe()
[13:22:00.435]     ...future.conditions <- base::list()
[13:22:00.435]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:00.435]     if (FALSE) {
[13:22:00.435]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:00.435]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:00.435]     }
[13:22:00.435]     ...future.result <- base::tryCatch({
[13:22:00.435]         base::withCallingHandlers({
[13:22:00.435]             ...future.value <- base::withVisible(base::local({
[13:22:00.435]                 ...future.makeSendCondition <- local({
[13:22:00.435]                   sendCondition <- NULL
[13:22:00.435]                   function(frame = 1L) {
[13:22:00.435]                     if (is.function(sendCondition)) 
[13:22:00.435]                       return(sendCondition)
[13:22:00.435]                     ns <- getNamespace("parallel")
[13:22:00.435]                     if (exists("sendData", mode = "function", 
[13:22:00.435]                       envir = ns)) {
[13:22:00.435]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:00.435]                         envir = ns)
[13:22:00.435]                       envir <- sys.frame(frame)
[13:22:00.435]                       master <- NULL
[13:22:00.435]                       while (!identical(envir, .GlobalEnv) && 
[13:22:00.435]                         !identical(envir, emptyenv())) {
[13:22:00.435]                         if (exists("master", mode = "list", envir = envir, 
[13:22:00.435]                           inherits = FALSE)) {
[13:22:00.435]                           master <- get("master", mode = "list", 
[13:22:00.435]                             envir = envir, inherits = FALSE)
[13:22:00.435]                           if (inherits(master, c("SOCKnode", 
[13:22:00.435]                             "SOCK0node"))) {
[13:22:00.435]                             sendCondition <<- function(cond) {
[13:22:00.435]                               data <- list(type = "VALUE", value = cond, 
[13:22:00.435]                                 success = TRUE)
[13:22:00.435]                               parallel_sendData(master, data)
[13:22:00.435]                             }
[13:22:00.435]                             return(sendCondition)
[13:22:00.435]                           }
[13:22:00.435]                         }
[13:22:00.435]                         frame <- frame + 1L
[13:22:00.435]                         envir <- sys.frame(frame)
[13:22:00.435]                       }
[13:22:00.435]                     }
[13:22:00.435]                     sendCondition <<- function(cond) NULL
[13:22:00.435]                   }
[13:22:00.435]                 })
[13:22:00.435]                 withCallingHandlers({
[13:22:00.435]                   {
[13:22:00.435]                     Sys.sleep(0.1)
[13:22:00.435]                     kk
[13:22:00.435]                   }
[13:22:00.435]                 }, immediateCondition = function(cond) {
[13:22:00.435]                   sendCondition <- ...future.makeSendCondition()
[13:22:00.435]                   sendCondition(cond)
[13:22:00.435]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.435]                   {
[13:22:00.435]                     inherits <- base::inherits
[13:22:00.435]                     invokeRestart <- base::invokeRestart
[13:22:00.435]                     is.null <- base::is.null
[13:22:00.435]                     muffled <- FALSE
[13:22:00.435]                     if (inherits(cond, "message")) {
[13:22:00.435]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:00.435]                       if (muffled) 
[13:22:00.435]                         invokeRestart("muffleMessage")
[13:22:00.435]                     }
[13:22:00.435]                     else if (inherits(cond, "warning")) {
[13:22:00.435]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:00.435]                       if (muffled) 
[13:22:00.435]                         invokeRestart("muffleWarning")
[13:22:00.435]                     }
[13:22:00.435]                     else if (inherits(cond, "condition")) {
[13:22:00.435]                       if (!is.null(pattern)) {
[13:22:00.435]                         computeRestarts <- base::computeRestarts
[13:22:00.435]                         grepl <- base::grepl
[13:22:00.435]                         restarts <- computeRestarts(cond)
[13:22:00.435]                         for (restart in restarts) {
[13:22:00.435]                           name <- restart$name
[13:22:00.435]                           if (is.null(name)) 
[13:22:00.435]                             next
[13:22:00.435]                           if (!grepl(pattern, name)) 
[13:22:00.435]                             next
[13:22:00.435]                           invokeRestart(restart)
[13:22:00.435]                           muffled <- TRUE
[13:22:00.435]                           break
[13:22:00.435]                         }
[13:22:00.435]                       }
[13:22:00.435]                     }
[13:22:00.435]                     invisible(muffled)
[13:22:00.435]                   }
[13:22:00.435]                   muffleCondition(cond)
[13:22:00.435]                 })
[13:22:00.435]             }))
[13:22:00.435]             future::FutureResult(value = ...future.value$value, 
[13:22:00.435]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:00.435]                   ...future.rng), globalenv = if (FALSE) 
[13:22:00.435]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:00.435]                     ...future.globalenv.names))
[13:22:00.435]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:00.435]         }, condition = base::local({
[13:22:00.435]             c <- base::c
[13:22:00.435]             inherits <- base::inherits
[13:22:00.435]             invokeRestart <- base::invokeRestart
[13:22:00.435]             length <- base::length
[13:22:00.435]             list <- base::list
[13:22:00.435]             seq.int <- base::seq.int
[13:22:00.435]             signalCondition <- base::signalCondition
[13:22:00.435]             sys.calls <- base::sys.calls
[13:22:00.435]             `[[` <- base::`[[`
[13:22:00.435]             `+` <- base::`+`
[13:22:00.435]             `<<-` <- base::`<<-`
[13:22:00.435]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:00.435]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:00.435]                   3L)]
[13:22:00.435]             }
[13:22:00.435]             function(cond) {
[13:22:00.435]                 is_error <- inherits(cond, "error")
[13:22:00.435]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:00.435]                   NULL)
[13:22:00.435]                 if (is_error) {
[13:22:00.435]                   sessionInformation <- function() {
[13:22:00.435]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:00.435]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:00.435]                       search = base::search(), system = base::Sys.info())
[13:22:00.435]                   }
[13:22:00.435]                   ...future.conditions[[length(...future.conditions) + 
[13:22:00.435]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:00.435]                     cond$call), session = sessionInformation(), 
[13:22:00.435]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:00.435]                   signalCondition(cond)
[13:22:00.435]                 }
[13:22:00.435]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:00.435]                 "immediateCondition"))) {
[13:22:00.435]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:00.435]                   ...future.conditions[[length(...future.conditions) + 
[13:22:00.435]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:00.435]                   if (TRUE && !signal) {
[13:22:00.435]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.435]                     {
[13:22:00.435]                       inherits <- base::inherits
[13:22:00.435]                       invokeRestart <- base::invokeRestart
[13:22:00.435]                       is.null <- base::is.null
[13:22:00.435]                       muffled <- FALSE
[13:22:00.435]                       if (inherits(cond, "message")) {
[13:22:00.435]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:00.435]                         if (muffled) 
[13:22:00.435]                           invokeRestart("muffleMessage")
[13:22:00.435]                       }
[13:22:00.435]                       else if (inherits(cond, "warning")) {
[13:22:00.435]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:00.435]                         if (muffled) 
[13:22:00.435]                           invokeRestart("muffleWarning")
[13:22:00.435]                       }
[13:22:00.435]                       else if (inherits(cond, "condition")) {
[13:22:00.435]                         if (!is.null(pattern)) {
[13:22:00.435]                           computeRestarts <- base::computeRestarts
[13:22:00.435]                           grepl <- base::grepl
[13:22:00.435]                           restarts <- computeRestarts(cond)
[13:22:00.435]                           for (restart in restarts) {
[13:22:00.435]                             name <- restart$name
[13:22:00.435]                             if (is.null(name)) 
[13:22:00.435]                               next
[13:22:00.435]                             if (!grepl(pattern, name)) 
[13:22:00.435]                               next
[13:22:00.435]                             invokeRestart(restart)
[13:22:00.435]                             muffled <- TRUE
[13:22:00.435]                             break
[13:22:00.435]                           }
[13:22:00.435]                         }
[13:22:00.435]                       }
[13:22:00.435]                       invisible(muffled)
[13:22:00.435]                     }
[13:22:00.435]                     muffleCondition(cond, pattern = "^muffle")
[13:22:00.435]                   }
[13:22:00.435]                 }
[13:22:00.435]                 else {
[13:22:00.435]                   if (TRUE) {
[13:22:00.435]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.435]                     {
[13:22:00.435]                       inherits <- base::inherits
[13:22:00.435]                       invokeRestart <- base::invokeRestart
[13:22:00.435]                       is.null <- base::is.null
[13:22:00.435]                       muffled <- FALSE
[13:22:00.435]                       if (inherits(cond, "message")) {
[13:22:00.435]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:00.435]                         if (muffled) 
[13:22:00.435]                           invokeRestart("muffleMessage")
[13:22:00.435]                       }
[13:22:00.435]                       else if (inherits(cond, "warning")) {
[13:22:00.435]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:00.435]                         if (muffled) 
[13:22:00.435]                           invokeRestart("muffleWarning")
[13:22:00.435]                       }
[13:22:00.435]                       else if (inherits(cond, "condition")) {
[13:22:00.435]                         if (!is.null(pattern)) {
[13:22:00.435]                           computeRestarts <- base::computeRestarts
[13:22:00.435]                           grepl <- base::grepl
[13:22:00.435]                           restarts <- computeRestarts(cond)
[13:22:00.435]                           for (restart in restarts) {
[13:22:00.435]                             name <- restart$name
[13:22:00.435]                             if (is.null(name)) 
[13:22:00.435]                               next
[13:22:00.435]                             if (!grepl(pattern, name)) 
[13:22:00.435]                               next
[13:22:00.435]                             invokeRestart(restart)
[13:22:00.435]                             muffled <- TRUE
[13:22:00.435]                             break
[13:22:00.435]                           }
[13:22:00.435]                         }
[13:22:00.435]                       }
[13:22:00.435]                       invisible(muffled)
[13:22:00.435]                     }
[13:22:00.435]                     muffleCondition(cond, pattern = "^muffle")
[13:22:00.435]                   }
[13:22:00.435]                 }
[13:22:00.435]             }
[13:22:00.435]         }))
[13:22:00.435]     }, error = function(ex) {
[13:22:00.435]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:00.435]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:00.435]                 ...future.rng), started = ...future.startTime, 
[13:22:00.435]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:00.435]             version = "1.8"), class = "FutureResult")
[13:22:00.435]     }, finally = {
[13:22:00.435]         if (!identical(...future.workdir, getwd())) 
[13:22:00.435]             setwd(...future.workdir)
[13:22:00.435]         {
[13:22:00.435]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:00.435]                 ...future.oldOptions$nwarnings <- NULL
[13:22:00.435]             }
[13:22:00.435]             base::options(...future.oldOptions)
[13:22:00.435]             if (.Platform$OS.type == "windows") {
[13:22:00.435]                 old_names <- names(...future.oldEnvVars)
[13:22:00.435]                 envs <- base::Sys.getenv()
[13:22:00.435]                 names <- names(envs)
[13:22:00.435]                 common <- intersect(names, old_names)
[13:22:00.435]                 added <- setdiff(names, old_names)
[13:22:00.435]                 removed <- setdiff(old_names, names)
[13:22:00.435]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:00.435]                   envs[common]]
[13:22:00.435]                 NAMES <- toupper(changed)
[13:22:00.435]                 args <- list()
[13:22:00.435]                 for (kk in seq_along(NAMES)) {
[13:22:00.435]                   name <- changed[[kk]]
[13:22:00.435]                   NAME <- NAMES[[kk]]
[13:22:00.435]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.435]                     next
[13:22:00.435]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:00.435]                 }
[13:22:00.435]                 NAMES <- toupper(added)
[13:22:00.435]                 for (kk in seq_along(NAMES)) {
[13:22:00.435]                   name <- added[[kk]]
[13:22:00.435]                   NAME <- NAMES[[kk]]
[13:22:00.435]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.435]                     next
[13:22:00.435]                   args[[name]] <- ""
[13:22:00.435]                 }
[13:22:00.435]                 NAMES <- toupper(removed)
[13:22:00.435]                 for (kk in seq_along(NAMES)) {
[13:22:00.435]                   name <- removed[[kk]]
[13:22:00.435]                   NAME <- NAMES[[kk]]
[13:22:00.435]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.435]                     next
[13:22:00.435]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:00.435]                 }
[13:22:00.435]                 if (length(args) > 0) 
[13:22:00.435]                   base::do.call(base::Sys.setenv, args = args)
[13:22:00.435]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:00.435]             }
[13:22:00.435]             else {
[13:22:00.435]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:00.435]             }
[13:22:00.435]             {
[13:22:00.435]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:00.435]                   0L) {
[13:22:00.435]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:00.435]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:00.435]                   base::options(opts)
[13:22:00.435]                 }
[13:22:00.435]                 {
[13:22:00.435]                   {
[13:22:00.435]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:00.435]                     NULL
[13:22:00.435]                   }
[13:22:00.435]                   options(future.plan = NULL)
[13:22:00.435]                   if (is.na(NA_character_)) 
[13:22:00.435]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:00.435]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:00.435]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:00.435]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:00.435]                     envir = parent.frame()) 
[13:22:00.435]                   {
[13:22:00.435]                     if (is.function(workers)) 
[13:22:00.435]                       workers <- workers()
[13:22:00.435]                     workers <- structure(as.integer(workers), 
[13:22:00.435]                       class = class(workers))
[13:22:00.435]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:00.435]                       workers >= 1)
[13:22:00.435]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:00.435]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:00.435]                     }
[13:22:00.435]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:00.435]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:00.435]                       envir = envir)
[13:22:00.435]                     if (!future$lazy) 
[13:22:00.435]                       future <- run(future)
[13:22:00.435]                     invisible(future)
[13:22:00.435]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:00.435]                 }
[13:22:00.435]             }
[13:22:00.435]         }
[13:22:00.435]     })
[13:22:00.435]     if (TRUE) {
[13:22:00.435]         base::sink(type = "output", split = FALSE)
[13:22:00.435]         if (TRUE) {
[13:22:00.435]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:00.435]         }
[13:22:00.435]         else {
[13:22:00.435]             ...future.result["stdout"] <- base::list(NULL)
[13:22:00.435]         }
[13:22:00.435]         base::close(...future.stdout)
[13:22:00.435]         ...future.stdout <- NULL
[13:22:00.435]     }
[13:22:00.435]     ...future.result$conditions <- ...future.conditions
[13:22:00.435]     ...future.result$finished <- base::Sys.time()
[13:22:00.435]     ...future.result
[13:22:00.435] }
[13:22:00.437] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[13:22:00.437] Exporting ‘kk’ (56 bytes) to cluster node #2 ...
[13:22:00.438] Exporting ‘kk’ (56 bytes) to cluster node #2 ... DONE
[13:22:00.438] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[13:22:00.438] MultisessionFuture started
[13:22:00.438] - Launch lazy future ... done
[13:22:00.439] run() for ‘MultisessionFuture’ ... done
[13:22:00.449] run() for ‘Future’ ...
[13:22:00.449] - state: ‘created’
[13:22:00.449] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:00.464] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:00.464] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:00.465]   - Field: ‘node’
[13:22:00.465]   - Field: ‘label’
[13:22:00.465]   - Field: ‘local’
[13:22:00.465]   - Field: ‘owner’
[13:22:00.465]   - Field: ‘envir’
[13:22:00.465]   - Field: ‘workers’
[13:22:00.465]   - Field: ‘packages’
[13:22:00.465]   - Field: ‘gc’
[13:22:00.465]   - Field: ‘conditions’
[13:22:00.466]   - Field: ‘persistent’
[13:22:00.466]   - Field: ‘expr’
[13:22:00.466]   - Field: ‘uuid’
[13:22:00.466]   - Field: ‘seed’
[13:22:00.466]   - Field: ‘version’
[13:22:00.466]   - Field: ‘result’
[13:22:00.466]   - Field: ‘asynchronous’
[13:22:00.466]   - Field: ‘calls’
[13:22:00.466]   - Field: ‘globals’
[13:22:00.466]   - Field: ‘stdout’
[13:22:00.466]   - Field: ‘earlySignal’
[13:22:00.466]   - Field: ‘lazy’
[13:22:00.467]   - Field: ‘state’
[13:22:00.467] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:00.467] - Launch lazy future ...
[13:22:00.467] Packages needed by the future expression (n = 0): <none>
[13:22:00.467] Packages needed by future strategies (n = 0): <none>
[13:22:00.468] {
[13:22:00.468]     {
[13:22:00.468]         {
[13:22:00.468]             ...future.startTime <- base::Sys.time()
[13:22:00.468]             {
[13:22:00.468]                 {
[13:22:00.468]                   {
[13:22:00.468]                     {
[13:22:00.468]                       base::local({
[13:22:00.468]                         has_future <- base::requireNamespace("future", 
[13:22:00.468]                           quietly = TRUE)
[13:22:00.468]                         if (has_future) {
[13:22:00.468]                           ns <- base::getNamespace("future")
[13:22:00.468]                           version <- ns[[".package"]][["version"]]
[13:22:00.468]                           if (is.null(version)) 
[13:22:00.468]                             version <- utils::packageVersion("future")
[13:22:00.468]                         }
[13:22:00.468]                         else {
[13:22:00.468]                           version <- NULL
[13:22:00.468]                         }
[13:22:00.468]                         if (!has_future || version < "1.8.0") {
[13:22:00.468]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:00.468]                             "", base::R.version$version.string), 
[13:22:00.468]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:00.468]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:00.468]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:00.468]                               "release", "version")], collapse = " "), 
[13:22:00.468]                             hostname = base::Sys.info()[["nodename"]])
[13:22:00.468]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:00.468]                             info)
[13:22:00.468]                           info <- base::paste(info, collapse = "; ")
[13:22:00.468]                           if (!has_future) {
[13:22:00.468]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:00.468]                               info)
[13:22:00.468]                           }
[13:22:00.468]                           else {
[13:22:00.468]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:00.468]                               info, version)
[13:22:00.468]                           }
[13:22:00.468]                           base::stop(msg)
[13:22:00.468]                         }
[13:22:00.468]                       })
[13:22:00.468]                     }
[13:22:00.468]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:00.468]                     base::options(mc.cores = 1L)
[13:22:00.468]                   }
[13:22:00.468]                   options(future.plan = NULL)
[13:22:00.468]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:00.468]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:00.468]                 }
[13:22:00.468]                 ...future.workdir <- getwd()
[13:22:00.468]             }
[13:22:00.468]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:00.468]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:00.468]         }
[13:22:00.468]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:00.468]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:00.468]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:00.468]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:00.468]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:00.468]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:00.468]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:00.468]             base::names(...future.oldOptions))
[13:22:00.468]     }
[13:22:00.468]     if (FALSE) {
[13:22:00.468]     }
[13:22:00.468]     else {
[13:22:00.468]         if (TRUE) {
[13:22:00.468]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:00.468]                 open = "w")
[13:22:00.468]         }
[13:22:00.468]         else {
[13:22:00.468]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:00.468]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:00.468]         }
[13:22:00.468]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:00.468]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:00.468]             base::sink(type = "output", split = FALSE)
[13:22:00.468]             base::close(...future.stdout)
[13:22:00.468]         }, add = TRUE)
[13:22:00.468]     }
[13:22:00.468]     ...future.frame <- base::sys.nframe()
[13:22:00.468]     ...future.conditions <- base::list()
[13:22:00.468]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:00.468]     if (FALSE) {
[13:22:00.468]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:00.468]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:00.468]     }
[13:22:00.468]     ...future.result <- base::tryCatch({
[13:22:00.468]         base::withCallingHandlers({
[13:22:00.468]             ...future.value <- base::withVisible(base::local({
[13:22:00.468]                 ...future.makeSendCondition <- local({
[13:22:00.468]                   sendCondition <- NULL
[13:22:00.468]                   function(frame = 1L) {
[13:22:00.468]                     if (is.function(sendCondition)) 
[13:22:00.468]                       return(sendCondition)
[13:22:00.468]                     ns <- getNamespace("parallel")
[13:22:00.468]                     if (exists("sendData", mode = "function", 
[13:22:00.468]                       envir = ns)) {
[13:22:00.468]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:00.468]                         envir = ns)
[13:22:00.468]                       envir <- sys.frame(frame)
[13:22:00.468]                       master <- NULL
[13:22:00.468]                       while (!identical(envir, .GlobalEnv) && 
[13:22:00.468]                         !identical(envir, emptyenv())) {
[13:22:00.468]                         if (exists("master", mode = "list", envir = envir, 
[13:22:00.468]                           inherits = FALSE)) {
[13:22:00.468]                           master <- get("master", mode = "list", 
[13:22:00.468]                             envir = envir, inherits = FALSE)
[13:22:00.468]                           if (inherits(master, c("SOCKnode", 
[13:22:00.468]                             "SOCK0node"))) {
[13:22:00.468]                             sendCondition <<- function(cond) {
[13:22:00.468]                               data <- list(type = "VALUE", value = cond, 
[13:22:00.468]                                 success = TRUE)
[13:22:00.468]                               parallel_sendData(master, data)
[13:22:00.468]                             }
[13:22:00.468]                             return(sendCondition)
[13:22:00.468]                           }
[13:22:00.468]                         }
[13:22:00.468]                         frame <- frame + 1L
[13:22:00.468]                         envir <- sys.frame(frame)
[13:22:00.468]                       }
[13:22:00.468]                     }
[13:22:00.468]                     sendCondition <<- function(cond) NULL
[13:22:00.468]                   }
[13:22:00.468]                 })
[13:22:00.468]                 withCallingHandlers({
[13:22:00.468]                   {
[13:22:00.468]                     Sys.sleep(0.1)
[13:22:00.468]                     kk
[13:22:00.468]                   }
[13:22:00.468]                 }, immediateCondition = function(cond) {
[13:22:00.468]                   sendCondition <- ...future.makeSendCondition()
[13:22:00.468]                   sendCondition(cond)
[13:22:00.468]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.468]                   {
[13:22:00.468]                     inherits <- base::inherits
[13:22:00.468]                     invokeRestart <- base::invokeRestart
[13:22:00.468]                     is.null <- base::is.null
[13:22:00.468]                     muffled <- FALSE
[13:22:00.468]                     if (inherits(cond, "message")) {
[13:22:00.468]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:00.468]                       if (muffled) 
[13:22:00.468]                         invokeRestart("muffleMessage")
[13:22:00.468]                     }
[13:22:00.468]                     else if (inherits(cond, "warning")) {
[13:22:00.468]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:00.468]                       if (muffled) 
[13:22:00.468]                         invokeRestart("muffleWarning")
[13:22:00.468]                     }
[13:22:00.468]                     else if (inherits(cond, "condition")) {
[13:22:00.468]                       if (!is.null(pattern)) {
[13:22:00.468]                         computeRestarts <- base::computeRestarts
[13:22:00.468]                         grepl <- base::grepl
[13:22:00.468]                         restarts <- computeRestarts(cond)
[13:22:00.468]                         for (restart in restarts) {
[13:22:00.468]                           name <- restart$name
[13:22:00.468]                           if (is.null(name)) 
[13:22:00.468]                             next
[13:22:00.468]                           if (!grepl(pattern, name)) 
[13:22:00.468]                             next
[13:22:00.468]                           invokeRestart(restart)
[13:22:00.468]                           muffled <- TRUE
[13:22:00.468]                           break
[13:22:00.468]                         }
[13:22:00.468]                       }
[13:22:00.468]                     }
[13:22:00.468]                     invisible(muffled)
[13:22:00.468]                   }
[13:22:00.468]                   muffleCondition(cond)
[13:22:00.468]                 })
[13:22:00.468]             }))
[13:22:00.468]             future::FutureResult(value = ...future.value$value, 
[13:22:00.468]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:00.468]                   ...future.rng), globalenv = if (FALSE) 
[13:22:00.468]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:00.468]                     ...future.globalenv.names))
[13:22:00.468]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:00.468]         }, condition = base::local({
[13:22:00.468]             c <- base::c
[13:22:00.468]             inherits <- base::inherits
[13:22:00.468]             invokeRestart <- base::invokeRestart
[13:22:00.468]             length <- base::length
[13:22:00.468]             list <- base::list
[13:22:00.468]             seq.int <- base::seq.int
[13:22:00.468]             signalCondition <- base::signalCondition
[13:22:00.468]             sys.calls <- base::sys.calls
[13:22:00.468]             `[[` <- base::`[[`
[13:22:00.468]             `+` <- base::`+`
[13:22:00.468]             `<<-` <- base::`<<-`
[13:22:00.468]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:00.468]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:00.468]                   3L)]
[13:22:00.468]             }
[13:22:00.468]             function(cond) {
[13:22:00.468]                 is_error <- inherits(cond, "error")
[13:22:00.468]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:00.468]                   NULL)
[13:22:00.468]                 if (is_error) {
[13:22:00.468]                   sessionInformation <- function() {
[13:22:00.468]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:00.468]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:00.468]                       search = base::search(), system = base::Sys.info())
[13:22:00.468]                   }
[13:22:00.468]                   ...future.conditions[[length(...future.conditions) + 
[13:22:00.468]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:00.468]                     cond$call), session = sessionInformation(), 
[13:22:00.468]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:00.468]                   signalCondition(cond)
[13:22:00.468]                 }
[13:22:00.468]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:00.468]                 "immediateCondition"))) {
[13:22:00.468]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:00.468]                   ...future.conditions[[length(...future.conditions) + 
[13:22:00.468]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:00.468]                   if (TRUE && !signal) {
[13:22:00.468]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.468]                     {
[13:22:00.468]                       inherits <- base::inherits
[13:22:00.468]                       invokeRestart <- base::invokeRestart
[13:22:00.468]                       is.null <- base::is.null
[13:22:00.468]                       muffled <- FALSE
[13:22:00.468]                       if (inherits(cond, "message")) {
[13:22:00.468]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:00.468]                         if (muffled) 
[13:22:00.468]                           invokeRestart("muffleMessage")
[13:22:00.468]                       }
[13:22:00.468]                       else if (inherits(cond, "warning")) {
[13:22:00.468]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:00.468]                         if (muffled) 
[13:22:00.468]                           invokeRestart("muffleWarning")
[13:22:00.468]                       }
[13:22:00.468]                       else if (inherits(cond, "condition")) {
[13:22:00.468]                         if (!is.null(pattern)) {
[13:22:00.468]                           computeRestarts <- base::computeRestarts
[13:22:00.468]                           grepl <- base::grepl
[13:22:00.468]                           restarts <- computeRestarts(cond)
[13:22:00.468]                           for (restart in restarts) {
[13:22:00.468]                             name <- restart$name
[13:22:00.468]                             if (is.null(name)) 
[13:22:00.468]                               next
[13:22:00.468]                             if (!grepl(pattern, name)) 
[13:22:00.468]                               next
[13:22:00.468]                             invokeRestart(restart)
[13:22:00.468]                             muffled <- TRUE
[13:22:00.468]                             break
[13:22:00.468]                           }
[13:22:00.468]                         }
[13:22:00.468]                       }
[13:22:00.468]                       invisible(muffled)
[13:22:00.468]                     }
[13:22:00.468]                     muffleCondition(cond, pattern = "^muffle")
[13:22:00.468]                   }
[13:22:00.468]                 }
[13:22:00.468]                 else {
[13:22:00.468]                   if (TRUE) {
[13:22:00.468]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.468]                     {
[13:22:00.468]                       inherits <- base::inherits
[13:22:00.468]                       invokeRestart <- base::invokeRestart
[13:22:00.468]                       is.null <- base::is.null
[13:22:00.468]                       muffled <- FALSE
[13:22:00.468]                       if (inherits(cond, "message")) {
[13:22:00.468]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:00.468]                         if (muffled) 
[13:22:00.468]                           invokeRestart("muffleMessage")
[13:22:00.468]                       }
[13:22:00.468]                       else if (inherits(cond, "warning")) {
[13:22:00.468]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:00.468]                         if (muffled) 
[13:22:00.468]                           invokeRestart("muffleWarning")
[13:22:00.468]                       }
[13:22:00.468]                       else if (inherits(cond, "condition")) {
[13:22:00.468]                         if (!is.null(pattern)) {
[13:22:00.468]                           computeRestarts <- base::computeRestarts
[13:22:00.468]                           grepl <- base::grepl
[13:22:00.468]                           restarts <- computeRestarts(cond)
[13:22:00.468]                           for (restart in restarts) {
[13:22:00.468]                             name <- restart$name
[13:22:00.468]                             if (is.null(name)) 
[13:22:00.468]                               next
[13:22:00.468]                             if (!grepl(pattern, name)) 
[13:22:00.468]                               next
[13:22:00.468]                             invokeRestart(restart)
[13:22:00.468]                             muffled <- TRUE
[13:22:00.468]                             break
[13:22:00.468]                           }
[13:22:00.468]                         }
[13:22:00.468]                       }
[13:22:00.468]                       invisible(muffled)
[13:22:00.468]                     }
[13:22:00.468]                     muffleCondition(cond, pattern = "^muffle")
[13:22:00.468]                   }
[13:22:00.468]                 }
[13:22:00.468]             }
[13:22:00.468]         }))
[13:22:00.468]     }, error = function(ex) {
[13:22:00.468]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:00.468]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:00.468]                 ...future.rng), started = ...future.startTime, 
[13:22:00.468]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:00.468]             version = "1.8"), class = "FutureResult")
[13:22:00.468]     }, finally = {
[13:22:00.468]         if (!identical(...future.workdir, getwd())) 
[13:22:00.468]             setwd(...future.workdir)
[13:22:00.468]         {
[13:22:00.468]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:00.468]                 ...future.oldOptions$nwarnings <- NULL
[13:22:00.468]             }
[13:22:00.468]             base::options(...future.oldOptions)
[13:22:00.468]             if (.Platform$OS.type == "windows") {
[13:22:00.468]                 old_names <- names(...future.oldEnvVars)
[13:22:00.468]                 envs <- base::Sys.getenv()
[13:22:00.468]                 names <- names(envs)
[13:22:00.468]                 common <- intersect(names, old_names)
[13:22:00.468]                 added <- setdiff(names, old_names)
[13:22:00.468]                 removed <- setdiff(old_names, names)
[13:22:00.468]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:00.468]                   envs[common]]
[13:22:00.468]                 NAMES <- toupper(changed)
[13:22:00.468]                 args <- list()
[13:22:00.468]                 for (kk in seq_along(NAMES)) {
[13:22:00.468]                   name <- changed[[kk]]
[13:22:00.468]                   NAME <- NAMES[[kk]]
[13:22:00.468]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.468]                     next
[13:22:00.468]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:00.468]                 }
[13:22:00.468]                 NAMES <- toupper(added)
[13:22:00.468]                 for (kk in seq_along(NAMES)) {
[13:22:00.468]                   name <- added[[kk]]
[13:22:00.468]                   NAME <- NAMES[[kk]]
[13:22:00.468]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.468]                     next
[13:22:00.468]                   args[[name]] <- ""
[13:22:00.468]                 }
[13:22:00.468]                 NAMES <- toupper(removed)
[13:22:00.468]                 for (kk in seq_along(NAMES)) {
[13:22:00.468]                   name <- removed[[kk]]
[13:22:00.468]                   NAME <- NAMES[[kk]]
[13:22:00.468]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.468]                     next
[13:22:00.468]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:00.468]                 }
[13:22:00.468]                 if (length(args) > 0) 
[13:22:00.468]                   base::do.call(base::Sys.setenv, args = args)
[13:22:00.468]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:00.468]             }
[13:22:00.468]             else {
[13:22:00.468]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:00.468]             }
[13:22:00.468]             {
[13:22:00.468]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:00.468]                   0L) {
[13:22:00.468]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:00.468]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:00.468]                   base::options(opts)
[13:22:00.468]                 }
[13:22:00.468]                 {
[13:22:00.468]                   {
[13:22:00.468]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:00.468]                     NULL
[13:22:00.468]                   }
[13:22:00.468]                   options(future.plan = NULL)
[13:22:00.468]                   if (is.na(NA_character_)) 
[13:22:00.468]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:00.468]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:00.468]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:00.468]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:00.468]                     envir = parent.frame()) 
[13:22:00.468]                   {
[13:22:00.468]                     if (is.function(workers)) 
[13:22:00.468]                       workers <- workers()
[13:22:00.468]                     workers <- structure(as.integer(workers), 
[13:22:00.468]                       class = class(workers))
[13:22:00.468]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:00.468]                       workers >= 1)
[13:22:00.468]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:00.468]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:00.468]                     }
[13:22:00.468]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:00.468]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:00.468]                       envir = envir)
[13:22:00.468]                     if (!future$lazy) 
[13:22:00.468]                       future <- run(future)
[13:22:00.468]                     invisible(future)
[13:22:00.468]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:00.468]                 }
[13:22:00.468]             }
[13:22:00.468]         }
[13:22:00.468]     })
[13:22:00.468]     if (TRUE) {
[13:22:00.468]         base::sink(type = "output", split = FALSE)
[13:22:00.468]         if (TRUE) {
[13:22:00.468]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:00.468]         }
[13:22:00.468]         else {
[13:22:00.468]             ...future.result["stdout"] <- base::list(NULL)
[13:22:00.468]         }
[13:22:00.468]         base::close(...future.stdout)
[13:22:00.468]         ...future.stdout <- NULL
[13:22:00.468]     }
[13:22:00.468]     ...future.result$conditions <- ...future.conditions
[13:22:00.468]     ...future.result$finished <- base::Sys.time()
[13:22:00.468]     ...future.result
[13:22:00.468] }
[13:22:00.470] Poll #1 (0): usedNodes() = 2, workers = 2
[13:22:00.502] Poll #2 (0.03 secs): usedNodes() = 2, workers = 2
[13:22:00.533] Poll #3 (0.06 secs): usedNodes() = 2, workers = 2
[13:22:00.554] receiveMessageFromWorker() for ClusterFuture ...
[13:22:00.554] - Validating connection of MultisessionFuture
[13:22:00.554] - received message: FutureResult
[13:22:00.555] - Received FutureResult
[13:22:00.555] - Erased future from FutureRegistry
[13:22:00.555] result() for ClusterFuture ...
[13:22:00.555] - result already collected: FutureResult
[13:22:00.555] result() for ClusterFuture ... done
[13:22:00.555] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:00.555] result() for ClusterFuture ...
[13:22:00.555] - result already collected: FutureResult
[13:22:00.555] result() for ClusterFuture ... done
[13:22:00.556] result() for ClusterFuture ...
[13:22:00.556] - result already collected: FutureResult
[13:22:00.556] result() for ClusterFuture ... done
[13:22:00.556] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[13:22:00.557] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[13:22:00.557] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[13:22:00.557] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[13:22:00.558] MultisessionFuture started
[13:22:00.558] - Launch lazy future ... done
[13:22:00.558] run() for ‘MultisessionFuture’ ... done
[13:22:00.578] Future #1
[13:22:00.579]  length: 2 (resolved future 1)
[13:22:00.586] receiveMessageFromWorker() for ClusterFuture ...
[13:22:00.587] - Validating connection of MultisessionFuture
[13:22:00.587] - received message: FutureResult
[13:22:00.587] - Received FutureResult
[13:22:00.587] - Erased future from FutureRegistry
[13:22:00.587] result() for ClusterFuture ...
[13:22:00.587] - result already collected: FutureResult
[13:22:00.587] result() for ClusterFuture ... done
[13:22:00.587] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:00.588] Future #2
[13:22:00.588]  length: 1 (resolved future 2)
[13:22:00.712] receiveMessageFromWorker() for ClusterFuture ...
[13:22:00.712] - Validating connection of MultisessionFuture
[13:22:00.712] - received message: FutureResult
[13:22:00.712] - Received FutureResult
[13:22:00.712] - Erased future from FutureRegistry
[13:22:00.712] result() for ClusterFuture ...
[13:22:00.712] - result already collected: FutureResult
[13:22:00.713] result() for ClusterFuture ... done
[13:22:00.713] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:00.713] Future #3
[13:22:00.713]  length: 0 (resolved future 3)
[13:22:00.713] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[13:22:00.714] resolve() on environment ...
[13:22:00.714]  recursive: 0
[13:22:00.714]  elements: [2] ‘a’, ‘b’
[13:22:00.714]  length: 1 (resolved future 1)
[13:22:00.714]  length: 0 (resolved future 2)
[13:22:00.714] resolve() on environment ... DONE
[13:22:00.715] getGlobalsAndPackages() ...
[13:22:00.715] Searching for globals...
[13:22:00.715] 
[13:22:00.715] Searching for globals ... DONE
[13:22:00.715] - globals: [0] <none>
[13:22:00.716] getGlobalsAndPackages() ... DONE
[13:22:00.716] run() for ‘Future’ ...
[13:22:00.716] - state: ‘created’
[13:22:00.716] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:00.739] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:00.739] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:00.739]   - Field: ‘node’
[13:22:00.739]   - Field: ‘label’
[13:22:00.739]   - Field: ‘local’
[13:22:00.739]   - Field: ‘owner’
[13:22:00.739]   - Field: ‘envir’
[13:22:00.739]   - Field: ‘workers’
[13:22:00.739]   - Field: ‘packages’
[13:22:00.740]   - Field: ‘gc’
[13:22:00.740]   - Field: ‘conditions’
[13:22:00.740]   - Field: ‘persistent’
[13:22:00.740]   - Field: ‘expr’
[13:22:00.740]   - Field: ‘uuid’
[13:22:00.740]   - Field: ‘seed’
[13:22:00.740]   - Field: ‘version’
[13:22:00.740]   - Field: ‘result’
[13:22:00.740]   - Field: ‘asynchronous’
[13:22:00.740]   - Field: ‘calls’
[13:22:00.740]   - Field: ‘globals’
[13:22:00.741]   - Field: ‘stdout’
[13:22:00.741]   - Field: ‘earlySignal’
[13:22:00.741]   - Field: ‘lazy’
[13:22:00.741]   - Field: ‘state’
[13:22:00.741] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:00.741] - Launch lazy future ...
[13:22:00.741] Packages needed by the future expression (n = 0): <none>
[13:22:00.741] Packages needed by future strategies (n = 0): <none>
[13:22:00.742] {
[13:22:00.742]     {
[13:22:00.742]         {
[13:22:00.742]             ...future.startTime <- base::Sys.time()
[13:22:00.742]             {
[13:22:00.742]                 {
[13:22:00.742]                   {
[13:22:00.742]                     {
[13:22:00.742]                       base::local({
[13:22:00.742]                         has_future <- base::requireNamespace("future", 
[13:22:00.742]                           quietly = TRUE)
[13:22:00.742]                         if (has_future) {
[13:22:00.742]                           ns <- base::getNamespace("future")
[13:22:00.742]                           version <- ns[[".package"]][["version"]]
[13:22:00.742]                           if (is.null(version)) 
[13:22:00.742]                             version <- utils::packageVersion("future")
[13:22:00.742]                         }
[13:22:00.742]                         else {
[13:22:00.742]                           version <- NULL
[13:22:00.742]                         }
[13:22:00.742]                         if (!has_future || version < "1.8.0") {
[13:22:00.742]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:00.742]                             "", base::R.version$version.string), 
[13:22:00.742]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:00.742]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:00.742]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:00.742]                               "release", "version")], collapse = " "), 
[13:22:00.742]                             hostname = base::Sys.info()[["nodename"]])
[13:22:00.742]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:00.742]                             info)
[13:22:00.742]                           info <- base::paste(info, collapse = "; ")
[13:22:00.742]                           if (!has_future) {
[13:22:00.742]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:00.742]                               info)
[13:22:00.742]                           }
[13:22:00.742]                           else {
[13:22:00.742]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:00.742]                               info, version)
[13:22:00.742]                           }
[13:22:00.742]                           base::stop(msg)
[13:22:00.742]                         }
[13:22:00.742]                       })
[13:22:00.742]                     }
[13:22:00.742]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:00.742]                     base::options(mc.cores = 1L)
[13:22:00.742]                   }
[13:22:00.742]                   options(future.plan = NULL)
[13:22:00.742]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:00.742]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:00.742]                 }
[13:22:00.742]                 ...future.workdir <- getwd()
[13:22:00.742]             }
[13:22:00.742]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:00.742]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:00.742]         }
[13:22:00.742]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:00.742]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:00.742]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:00.742]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:00.742]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:00.742]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:00.742]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:00.742]             base::names(...future.oldOptions))
[13:22:00.742]     }
[13:22:00.742]     if (FALSE) {
[13:22:00.742]     }
[13:22:00.742]     else {
[13:22:00.742]         if (TRUE) {
[13:22:00.742]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:00.742]                 open = "w")
[13:22:00.742]         }
[13:22:00.742]         else {
[13:22:00.742]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:00.742]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:00.742]         }
[13:22:00.742]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:00.742]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:00.742]             base::sink(type = "output", split = FALSE)
[13:22:00.742]             base::close(...future.stdout)
[13:22:00.742]         }, add = TRUE)
[13:22:00.742]     }
[13:22:00.742]     ...future.frame <- base::sys.nframe()
[13:22:00.742]     ...future.conditions <- base::list()
[13:22:00.742]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:00.742]     if (FALSE) {
[13:22:00.742]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:00.742]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:00.742]     }
[13:22:00.742]     ...future.result <- base::tryCatch({
[13:22:00.742]         base::withCallingHandlers({
[13:22:00.742]             ...future.value <- base::withVisible(base::local({
[13:22:00.742]                 ...future.makeSendCondition <- local({
[13:22:00.742]                   sendCondition <- NULL
[13:22:00.742]                   function(frame = 1L) {
[13:22:00.742]                     if (is.function(sendCondition)) 
[13:22:00.742]                       return(sendCondition)
[13:22:00.742]                     ns <- getNamespace("parallel")
[13:22:00.742]                     if (exists("sendData", mode = "function", 
[13:22:00.742]                       envir = ns)) {
[13:22:00.742]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:00.742]                         envir = ns)
[13:22:00.742]                       envir <- sys.frame(frame)
[13:22:00.742]                       master <- NULL
[13:22:00.742]                       while (!identical(envir, .GlobalEnv) && 
[13:22:00.742]                         !identical(envir, emptyenv())) {
[13:22:00.742]                         if (exists("master", mode = "list", envir = envir, 
[13:22:00.742]                           inherits = FALSE)) {
[13:22:00.742]                           master <- get("master", mode = "list", 
[13:22:00.742]                             envir = envir, inherits = FALSE)
[13:22:00.742]                           if (inherits(master, c("SOCKnode", 
[13:22:00.742]                             "SOCK0node"))) {
[13:22:00.742]                             sendCondition <<- function(cond) {
[13:22:00.742]                               data <- list(type = "VALUE", value = cond, 
[13:22:00.742]                                 success = TRUE)
[13:22:00.742]                               parallel_sendData(master, data)
[13:22:00.742]                             }
[13:22:00.742]                             return(sendCondition)
[13:22:00.742]                           }
[13:22:00.742]                         }
[13:22:00.742]                         frame <- frame + 1L
[13:22:00.742]                         envir <- sys.frame(frame)
[13:22:00.742]                       }
[13:22:00.742]                     }
[13:22:00.742]                     sendCondition <<- function(cond) NULL
[13:22:00.742]                   }
[13:22:00.742]                 })
[13:22:00.742]                 withCallingHandlers({
[13:22:00.742]                   1
[13:22:00.742]                 }, immediateCondition = function(cond) {
[13:22:00.742]                   sendCondition <- ...future.makeSendCondition()
[13:22:00.742]                   sendCondition(cond)
[13:22:00.742]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.742]                   {
[13:22:00.742]                     inherits <- base::inherits
[13:22:00.742]                     invokeRestart <- base::invokeRestart
[13:22:00.742]                     is.null <- base::is.null
[13:22:00.742]                     muffled <- FALSE
[13:22:00.742]                     if (inherits(cond, "message")) {
[13:22:00.742]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:00.742]                       if (muffled) 
[13:22:00.742]                         invokeRestart("muffleMessage")
[13:22:00.742]                     }
[13:22:00.742]                     else if (inherits(cond, "warning")) {
[13:22:00.742]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:00.742]                       if (muffled) 
[13:22:00.742]                         invokeRestart("muffleWarning")
[13:22:00.742]                     }
[13:22:00.742]                     else if (inherits(cond, "condition")) {
[13:22:00.742]                       if (!is.null(pattern)) {
[13:22:00.742]                         computeRestarts <- base::computeRestarts
[13:22:00.742]                         grepl <- base::grepl
[13:22:00.742]                         restarts <- computeRestarts(cond)
[13:22:00.742]                         for (restart in restarts) {
[13:22:00.742]                           name <- restart$name
[13:22:00.742]                           if (is.null(name)) 
[13:22:00.742]                             next
[13:22:00.742]                           if (!grepl(pattern, name)) 
[13:22:00.742]                             next
[13:22:00.742]                           invokeRestart(restart)
[13:22:00.742]                           muffled <- TRUE
[13:22:00.742]                           break
[13:22:00.742]                         }
[13:22:00.742]                       }
[13:22:00.742]                     }
[13:22:00.742]                     invisible(muffled)
[13:22:00.742]                   }
[13:22:00.742]                   muffleCondition(cond)
[13:22:00.742]                 })
[13:22:00.742]             }))
[13:22:00.742]             future::FutureResult(value = ...future.value$value, 
[13:22:00.742]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:00.742]                   ...future.rng), globalenv = if (FALSE) 
[13:22:00.742]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:00.742]                     ...future.globalenv.names))
[13:22:00.742]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:00.742]         }, condition = base::local({
[13:22:00.742]             c <- base::c
[13:22:00.742]             inherits <- base::inherits
[13:22:00.742]             invokeRestart <- base::invokeRestart
[13:22:00.742]             length <- base::length
[13:22:00.742]             list <- base::list
[13:22:00.742]             seq.int <- base::seq.int
[13:22:00.742]             signalCondition <- base::signalCondition
[13:22:00.742]             sys.calls <- base::sys.calls
[13:22:00.742]             `[[` <- base::`[[`
[13:22:00.742]             `+` <- base::`+`
[13:22:00.742]             `<<-` <- base::`<<-`
[13:22:00.742]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:00.742]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:00.742]                   3L)]
[13:22:00.742]             }
[13:22:00.742]             function(cond) {
[13:22:00.742]                 is_error <- inherits(cond, "error")
[13:22:00.742]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:00.742]                   NULL)
[13:22:00.742]                 if (is_error) {
[13:22:00.742]                   sessionInformation <- function() {
[13:22:00.742]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:00.742]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:00.742]                       search = base::search(), system = base::Sys.info())
[13:22:00.742]                   }
[13:22:00.742]                   ...future.conditions[[length(...future.conditions) + 
[13:22:00.742]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:00.742]                     cond$call), session = sessionInformation(), 
[13:22:00.742]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:00.742]                   signalCondition(cond)
[13:22:00.742]                 }
[13:22:00.742]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:00.742]                 "immediateCondition"))) {
[13:22:00.742]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:00.742]                   ...future.conditions[[length(...future.conditions) + 
[13:22:00.742]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:00.742]                   if (TRUE && !signal) {
[13:22:00.742]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.742]                     {
[13:22:00.742]                       inherits <- base::inherits
[13:22:00.742]                       invokeRestart <- base::invokeRestart
[13:22:00.742]                       is.null <- base::is.null
[13:22:00.742]                       muffled <- FALSE
[13:22:00.742]                       if (inherits(cond, "message")) {
[13:22:00.742]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:00.742]                         if (muffled) 
[13:22:00.742]                           invokeRestart("muffleMessage")
[13:22:00.742]                       }
[13:22:00.742]                       else if (inherits(cond, "warning")) {
[13:22:00.742]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:00.742]                         if (muffled) 
[13:22:00.742]                           invokeRestart("muffleWarning")
[13:22:00.742]                       }
[13:22:00.742]                       else if (inherits(cond, "condition")) {
[13:22:00.742]                         if (!is.null(pattern)) {
[13:22:00.742]                           computeRestarts <- base::computeRestarts
[13:22:00.742]                           grepl <- base::grepl
[13:22:00.742]                           restarts <- computeRestarts(cond)
[13:22:00.742]                           for (restart in restarts) {
[13:22:00.742]                             name <- restart$name
[13:22:00.742]                             if (is.null(name)) 
[13:22:00.742]                               next
[13:22:00.742]                             if (!grepl(pattern, name)) 
[13:22:00.742]                               next
[13:22:00.742]                             invokeRestart(restart)
[13:22:00.742]                             muffled <- TRUE
[13:22:00.742]                             break
[13:22:00.742]                           }
[13:22:00.742]                         }
[13:22:00.742]                       }
[13:22:00.742]                       invisible(muffled)
[13:22:00.742]                     }
[13:22:00.742]                     muffleCondition(cond, pattern = "^muffle")
[13:22:00.742]                   }
[13:22:00.742]                 }
[13:22:00.742]                 else {
[13:22:00.742]                   if (TRUE) {
[13:22:00.742]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.742]                     {
[13:22:00.742]                       inherits <- base::inherits
[13:22:00.742]                       invokeRestart <- base::invokeRestart
[13:22:00.742]                       is.null <- base::is.null
[13:22:00.742]                       muffled <- FALSE
[13:22:00.742]                       if (inherits(cond, "message")) {
[13:22:00.742]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:00.742]                         if (muffled) 
[13:22:00.742]                           invokeRestart("muffleMessage")
[13:22:00.742]                       }
[13:22:00.742]                       else if (inherits(cond, "warning")) {
[13:22:00.742]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:00.742]                         if (muffled) 
[13:22:00.742]                           invokeRestart("muffleWarning")
[13:22:00.742]                       }
[13:22:00.742]                       else if (inherits(cond, "condition")) {
[13:22:00.742]                         if (!is.null(pattern)) {
[13:22:00.742]                           computeRestarts <- base::computeRestarts
[13:22:00.742]                           grepl <- base::grepl
[13:22:00.742]                           restarts <- computeRestarts(cond)
[13:22:00.742]                           for (restart in restarts) {
[13:22:00.742]                             name <- restart$name
[13:22:00.742]                             if (is.null(name)) 
[13:22:00.742]                               next
[13:22:00.742]                             if (!grepl(pattern, name)) 
[13:22:00.742]                               next
[13:22:00.742]                             invokeRestart(restart)
[13:22:00.742]                             muffled <- TRUE
[13:22:00.742]                             break
[13:22:00.742]                           }
[13:22:00.742]                         }
[13:22:00.742]                       }
[13:22:00.742]                       invisible(muffled)
[13:22:00.742]                     }
[13:22:00.742]                     muffleCondition(cond, pattern = "^muffle")
[13:22:00.742]                   }
[13:22:00.742]                 }
[13:22:00.742]             }
[13:22:00.742]         }))
[13:22:00.742]     }, error = function(ex) {
[13:22:00.742]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:00.742]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:00.742]                 ...future.rng), started = ...future.startTime, 
[13:22:00.742]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:00.742]             version = "1.8"), class = "FutureResult")
[13:22:00.742]     }, finally = {
[13:22:00.742]         if (!identical(...future.workdir, getwd())) 
[13:22:00.742]             setwd(...future.workdir)
[13:22:00.742]         {
[13:22:00.742]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:00.742]                 ...future.oldOptions$nwarnings <- NULL
[13:22:00.742]             }
[13:22:00.742]             base::options(...future.oldOptions)
[13:22:00.742]             if (.Platform$OS.type == "windows") {
[13:22:00.742]                 old_names <- names(...future.oldEnvVars)
[13:22:00.742]                 envs <- base::Sys.getenv()
[13:22:00.742]                 names <- names(envs)
[13:22:00.742]                 common <- intersect(names, old_names)
[13:22:00.742]                 added <- setdiff(names, old_names)
[13:22:00.742]                 removed <- setdiff(old_names, names)
[13:22:00.742]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:00.742]                   envs[common]]
[13:22:00.742]                 NAMES <- toupper(changed)
[13:22:00.742]                 args <- list()
[13:22:00.742]                 for (kk in seq_along(NAMES)) {
[13:22:00.742]                   name <- changed[[kk]]
[13:22:00.742]                   NAME <- NAMES[[kk]]
[13:22:00.742]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.742]                     next
[13:22:00.742]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:00.742]                 }
[13:22:00.742]                 NAMES <- toupper(added)
[13:22:00.742]                 for (kk in seq_along(NAMES)) {
[13:22:00.742]                   name <- added[[kk]]
[13:22:00.742]                   NAME <- NAMES[[kk]]
[13:22:00.742]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.742]                     next
[13:22:00.742]                   args[[name]] <- ""
[13:22:00.742]                 }
[13:22:00.742]                 NAMES <- toupper(removed)
[13:22:00.742]                 for (kk in seq_along(NAMES)) {
[13:22:00.742]                   name <- removed[[kk]]
[13:22:00.742]                   NAME <- NAMES[[kk]]
[13:22:00.742]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.742]                     next
[13:22:00.742]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:00.742]                 }
[13:22:00.742]                 if (length(args) > 0) 
[13:22:00.742]                   base::do.call(base::Sys.setenv, args = args)
[13:22:00.742]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:00.742]             }
[13:22:00.742]             else {
[13:22:00.742]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:00.742]             }
[13:22:00.742]             {
[13:22:00.742]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:00.742]                   0L) {
[13:22:00.742]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:00.742]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:00.742]                   base::options(opts)
[13:22:00.742]                 }
[13:22:00.742]                 {
[13:22:00.742]                   {
[13:22:00.742]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:00.742]                     NULL
[13:22:00.742]                   }
[13:22:00.742]                   options(future.plan = NULL)
[13:22:00.742]                   if (is.na(NA_character_)) 
[13:22:00.742]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:00.742]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:00.742]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:00.742]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:00.742]                     envir = parent.frame()) 
[13:22:00.742]                   {
[13:22:00.742]                     if (is.function(workers)) 
[13:22:00.742]                       workers <- workers()
[13:22:00.742]                     workers <- structure(as.integer(workers), 
[13:22:00.742]                       class = class(workers))
[13:22:00.742]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:00.742]                       workers >= 1)
[13:22:00.742]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:00.742]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:00.742]                     }
[13:22:00.742]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:00.742]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:00.742]                       envir = envir)
[13:22:00.742]                     if (!future$lazy) 
[13:22:00.742]                       future <- run(future)
[13:22:00.742]                     invisible(future)
[13:22:00.742]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:00.742]                 }
[13:22:00.742]             }
[13:22:00.742]         }
[13:22:00.742]     })
[13:22:00.742]     if (TRUE) {
[13:22:00.742]         base::sink(type = "output", split = FALSE)
[13:22:00.742]         if (TRUE) {
[13:22:00.742]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:00.742]         }
[13:22:00.742]         else {
[13:22:00.742]             ...future.result["stdout"] <- base::list(NULL)
[13:22:00.742]         }
[13:22:00.742]         base::close(...future.stdout)
[13:22:00.742]         ...future.stdout <- NULL
[13:22:00.742]     }
[13:22:00.742]     ...future.result$conditions <- ...future.conditions
[13:22:00.742]     ...future.result$finished <- base::Sys.time()
[13:22:00.742]     ...future.result
[13:22:00.742] }
[13:22:00.745] MultisessionFuture started
[13:22:00.745] - Launch lazy future ... done
[13:22:00.745] run() for ‘MultisessionFuture’ ... done
[13:22:00.745] getGlobalsAndPackages() ...
[13:22:00.745] Searching for globals...
[13:22:00.746] 
[13:22:00.746] Searching for globals ... DONE
[13:22:00.746] - globals: [0] <none>
[13:22:00.746] getGlobalsAndPackages() ... DONE
[13:22:00.746] run() for ‘Future’ ...
[13:22:00.746] - state: ‘created’
[13:22:00.746] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:00.761] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:00.761] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:00.761]   - Field: ‘node’
[13:22:00.761]   - Field: ‘label’
[13:22:00.761]   - Field: ‘local’
[13:22:00.761]   - Field: ‘owner’
[13:22:00.762]   - Field: ‘envir’
[13:22:00.762]   - Field: ‘workers’
[13:22:00.762]   - Field: ‘packages’
[13:22:00.762]   - Field: ‘gc’
[13:22:00.762]   - Field: ‘conditions’
[13:22:00.762]   - Field: ‘persistent’
[13:22:00.762]   - Field: ‘expr’
[13:22:00.762]   - Field: ‘uuid’
[13:22:00.762]   - Field: ‘seed’
[13:22:00.762]   - Field: ‘version’
[13:22:00.763]   - Field: ‘result’
[13:22:00.763]   - Field: ‘asynchronous’
[13:22:00.763]   - Field: ‘calls’
[13:22:00.763]   - Field: ‘globals’
[13:22:00.763]   - Field: ‘stdout’
[13:22:00.763]   - Field: ‘earlySignal’
[13:22:00.763]   - Field: ‘lazy’
[13:22:00.763]   - Field: ‘state’
[13:22:00.763] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:00.763] - Launch lazy future ...
[13:22:00.764] Packages needed by the future expression (n = 0): <none>
[13:22:00.764] Packages needed by future strategies (n = 0): <none>
[13:22:00.764] {
[13:22:00.764]     {
[13:22:00.764]         {
[13:22:00.764]             ...future.startTime <- base::Sys.time()
[13:22:00.764]             {
[13:22:00.764]                 {
[13:22:00.764]                   {
[13:22:00.764]                     {
[13:22:00.764]                       base::local({
[13:22:00.764]                         has_future <- base::requireNamespace("future", 
[13:22:00.764]                           quietly = TRUE)
[13:22:00.764]                         if (has_future) {
[13:22:00.764]                           ns <- base::getNamespace("future")
[13:22:00.764]                           version <- ns[[".package"]][["version"]]
[13:22:00.764]                           if (is.null(version)) 
[13:22:00.764]                             version <- utils::packageVersion("future")
[13:22:00.764]                         }
[13:22:00.764]                         else {
[13:22:00.764]                           version <- NULL
[13:22:00.764]                         }
[13:22:00.764]                         if (!has_future || version < "1.8.0") {
[13:22:00.764]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:00.764]                             "", base::R.version$version.string), 
[13:22:00.764]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:00.764]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:00.764]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:00.764]                               "release", "version")], collapse = " "), 
[13:22:00.764]                             hostname = base::Sys.info()[["nodename"]])
[13:22:00.764]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:00.764]                             info)
[13:22:00.764]                           info <- base::paste(info, collapse = "; ")
[13:22:00.764]                           if (!has_future) {
[13:22:00.764]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:00.764]                               info)
[13:22:00.764]                           }
[13:22:00.764]                           else {
[13:22:00.764]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:00.764]                               info, version)
[13:22:00.764]                           }
[13:22:00.764]                           base::stop(msg)
[13:22:00.764]                         }
[13:22:00.764]                       })
[13:22:00.764]                     }
[13:22:00.764]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:00.764]                     base::options(mc.cores = 1L)
[13:22:00.764]                   }
[13:22:00.764]                   options(future.plan = NULL)
[13:22:00.764]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:00.764]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:00.764]                 }
[13:22:00.764]                 ...future.workdir <- getwd()
[13:22:00.764]             }
[13:22:00.764]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:00.764]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:00.764]         }
[13:22:00.764]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:00.764]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:00.764]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:00.764]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:00.764]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:00.764]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:00.764]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:00.764]             base::names(...future.oldOptions))
[13:22:00.764]     }
[13:22:00.764]     if (FALSE) {
[13:22:00.764]     }
[13:22:00.764]     else {
[13:22:00.764]         if (TRUE) {
[13:22:00.764]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:00.764]                 open = "w")
[13:22:00.764]         }
[13:22:00.764]         else {
[13:22:00.764]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:00.764]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:00.764]         }
[13:22:00.764]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:00.764]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:00.764]             base::sink(type = "output", split = FALSE)
[13:22:00.764]             base::close(...future.stdout)
[13:22:00.764]         }, add = TRUE)
[13:22:00.764]     }
[13:22:00.764]     ...future.frame <- base::sys.nframe()
[13:22:00.764]     ...future.conditions <- base::list()
[13:22:00.764]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:00.764]     if (FALSE) {
[13:22:00.764]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:00.764]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:00.764]     }
[13:22:00.764]     ...future.result <- base::tryCatch({
[13:22:00.764]         base::withCallingHandlers({
[13:22:00.764]             ...future.value <- base::withVisible(base::local({
[13:22:00.764]                 ...future.makeSendCondition <- local({
[13:22:00.764]                   sendCondition <- NULL
[13:22:00.764]                   function(frame = 1L) {
[13:22:00.764]                     if (is.function(sendCondition)) 
[13:22:00.764]                       return(sendCondition)
[13:22:00.764]                     ns <- getNamespace("parallel")
[13:22:00.764]                     if (exists("sendData", mode = "function", 
[13:22:00.764]                       envir = ns)) {
[13:22:00.764]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:00.764]                         envir = ns)
[13:22:00.764]                       envir <- sys.frame(frame)
[13:22:00.764]                       master <- NULL
[13:22:00.764]                       while (!identical(envir, .GlobalEnv) && 
[13:22:00.764]                         !identical(envir, emptyenv())) {
[13:22:00.764]                         if (exists("master", mode = "list", envir = envir, 
[13:22:00.764]                           inherits = FALSE)) {
[13:22:00.764]                           master <- get("master", mode = "list", 
[13:22:00.764]                             envir = envir, inherits = FALSE)
[13:22:00.764]                           if (inherits(master, c("SOCKnode", 
[13:22:00.764]                             "SOCK0node"))) {
[13:22:00.764]                             sendCondition <<- function(cond) {
[13:22:00.764]                               data <- list(type = "VALUE", value = cond, 
[13:22:00.764]                                 success = TRUE)
[13:22:00.764]                               parallel_sendData(master, data)
[13:22:00.764]                             }
[13:22:00.764]                             return(sendCondition)
[13:22:00.764]                           }
[13:22:00.764]                         }
[13:22:00.764]                         frame <- frame + 1L
[13:22:00.764]                         envir <- sys.frame(frame)
[13:22:00.764]                       }
[13:22:00.764]                     }
[13:22:00.764]                     sendCondition <<- function(cond) NULL
[13:22:00.764]                   }
[13:22:00.764]                 })
[13:22:00.764]                 withCallingHandlers({
[13:22:00.764]                   2
[13:22:00.764]                 }, immediateCondition = function(cond) {
[13:22:00.764]                   sendCondition <- ...future.makeSendCondition()
[13:22:00.764]                   sendCondition(cond)
[13:22:00.764]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.764]                   {
[13:22:00.764]                     inherits <- base::inherits
[13:22:00.764]                     invokeRestart <- base::invokeRestart
[13:22:00.764]                     is.null <- base::is.null
[13:22:00.764]                     muffled <- FALSE
[13:22:00.764]                     if (inherits(cond, "message")) {
[13:22:00.764]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:00.764]                       if (muffled) 
[13:22:00.764]                         invokeRestart("muffleMessage")
[13:22:00.764]                     }
[13:22:00.764]                     else if (inherits(cond, "warning")) {
[13:22:00.764]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:00.764]                       if (muffled) 
[13:22:00.764]                         invokeRestart("muffleWarning")
[13:22:00.764]                     }
[13:22:00.764]                     else if (inherits(cond, "condition")) {
[13:22:00.764]                       if (!is.null(pattern)) {
[13:22:00.764]                         computeRestarts <- base::computeRestarts
[13:22:00.764]                         grepl <- base::grepl
[13:22:00.764]                         restarts <- computeRestarts(cond)
[13:22:00.764]                         for (restart in restarts) {
[13:22:00.764]                           name <- restart$name
[13:22:00.764]                           if (is.null(name)) 
[13:22:00.764]                             next
[13:22:00.764]                           if (!grepl(pattern, name)) 
[13:22:00.764]                             next
[13:22:00.764]                           invokeRestart(restart)
[13:22:00.764]                           muffled <- TRUE
[13:22:00.764]                           break
[13:22:00.764]                         }
[13:22:00.764]                       }
[13:22:00.764]                     }
[13:22:00.764]                     invisible(muffled)
[13:22:00.764]                   }
[13:22:00.764]                   muffleCondition(cond)
[13:22:00.764]                 })
[13:22:00.764]             }))
[13:22:00.764]             future::FutureResult(value = ...future.value$value, 
[13:22:00.764]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:00.764]                   ...future.rng), globalenv = if (FALSE) 
[13:22:00.764]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:00.764]                     ...future.globalenv.names))
[13:22:00.764]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:00.764]         }, condition = base::local({
[13:22:00.764]             c <- base::c
[13:22:00.764]             inherits <- base::inherits
[13:22:00.764]             invokeRestart <- base::invokeRestart
[13:22:00.764]             length <- base::length
[13:22:00.764]             list <- base::list
[13:22:00.764]             seq.int <- base::seq.int
[13:22:00.764]             signalCondition <- base::signalCondition
[13:22:00.764]             sys.calls <- base::sys.calls
[13:22:00.764]             `[[` <- base::`[[`
[13:22:00.764]             `+` <- base::`+`
[13:22:00.764]             `<<-` <- base::`<<-`
[13:22:00.764]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:00.764]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:00.764]                   3L)]
[13:22:00.764]             }
[13:22:00.764]             function(cond) {
[13:22:00.764]                 is_error <- inherits(cond, "error")
[13:22:00.764]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:00.764]                   NULL)
[13:22:00.764]                 if (is_error) {
[13:22:00.764]                   sessionInformation <- function() {
[13:22:00.764]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:00.764]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:00.764]                       search = base::search(), system = base::Sys.info())
[13:22:00.764]                   }
[13:22:00.764]                   ...future.conditions[[length(...future.conditions) + 
[13:22:00.764]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:00.764]                     cond$call), session = sessionInformation(), 
[13:22:00.764]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:00.764]                   signalCondition(cond)
[13:22:00.764]                 }
[13:22:00.764]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:00.764]                 "immediateCondition"))) {
[13:22:00.764]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:00.764]                   ...future.conditions[[length(...future.conditions) + 
[13:22:00.764]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:00.764]                   if (TRUE && !signal) {
[13:22:00.764]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.764]                     {
[13:22:00.764]                       inherits <- base::inherits
[13:22:00.764]                       invokeRestart <- base::invokeRestart
[13:22:00.764]                       is.null <- base::is.null
[13:22:00.764]                       muffled <- FALSE
[13:22:00.764]                       if (inherits(cond, "message")) {
[13:22:00.764]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:00.764]                         if (muffled) 
[13:22:00.764]                           invokeRestart("muffleMessage")
[13:22:00.764]                       }
[13:22:00.764]                       else if (inherits(cond, "warning")) {
[13:22:00.764]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:00.764]                         if (muffled) 
[13:22:00.764]                           invokeRestart("muffleWarning")
[13:22:00.764]                       }
[13:22:00.764]                       else if (inherits(cond, "condition")) {
[13:22:00.764]                         if (!is.null(pattern)) {
[13:22:00.764]                           computeRestarts <- base::computeRestarts
[13:22:00.764]                           grepl <- base::grepl
[13:22:00.764]                           restarts <- computeRestarts(cond)
[13:22:00.764]                           for (restart in restarts) {
[13:22:00.764]                             name <- restart$name
[13:22:00.764]                             if (is.null(name)) 
[13:22:00.764]                               next
[13:22:00.764]                             if (!grepl(pattern, name)) 
[13:22:00.764]                               next
[13:22:00.764]                             invokeRestart(restart)
[13:22:00.764]                             muffled <- TRUE
[13:22:00.764]                             break
[13:22:00.764]                           }
[13:22:00.764]                         }
[13:22:00.764]                       }
[13:22:00.764]                       invisible(muffled)
[13:22:00.764]                     }
[13:22:00.764]                     muffleCondition(cond, pattern = "^muffle")
[13:22:00.764]                   }
[13:22:00.764]                 }
[13:22:00.764]                 else {
[13:22:00.764]                   if (TRUE) {
[13:22:00.764]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.764]                     {
[13:22:00.764]                       inherits <- base::inherits
[13:22:00.764]                       invokeRestart <- base::invokeRestart
[13:22:00.764]                       is.null <- base::is.null
[13:22:00.764]                       muffled <- FALSE
[13:22:00.764]                       if (inherits(cond, "message")) {
[13:22:00.764]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:00.764]                         if (muffled) 
[13:22:00.764]                           invokeRestart("muffleMessage")
[13:22:00.764]                       }
[13:22:00.764]                       else if (inherits(cond, "warning")) {
[13:22:00.764]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:00.764]                         if (muffled) 
[13:22:00.764]                           invokeRestart("muffleWarning")
[13:22:00.764]                       }
[13:22:00.764]                       else if (inherits(cond, "condition")) {
[13:22:00.764]                         if (!is.null(pattern)) {
[13:22:00.764]                           computeRestarts <- base::computeRestarts
[13:22:00.764]                           grepl <- base::grepl
[13:22:00.764]                           restarts <- computeRestarts(cond)
[13:22:00.764]                           for (restart in restarts) {
[13:22:00.764]                             name <- restart$name
[13:22:00.764]                             if (is.null(name)) 
[13:22:00.764]                               next
[13:22:00.764]                             if (!grepl(pattern, name)) 
[13:22:00.764]                               next
[13:22:00.764]                             invokeRestart(restart)
[13:22:00.764]                             muffled <- TRUE
[13:22:00.764]                             break
[13:22:00.764]                           }
[13:22:00.764]                         }
[13:22:00.764]                       }
[13:22:00.764]                       invisible(muffled)
[13:22:00.764]                     }
[13:22:00.764]                     muffleCondition(cond, pattern = "^muffle")
[13:22:00.764]                   }
[13:22:00.764]                 }
[13:22:00.764]             }
[13:22:00.764]         }))
[13:22:00.764]     }, error = function(ex) {
[13:22:00.764]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:00.764]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:00.764]                 ...future.rng), started = ...future.startTime, 
[13:22:00.764]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:00.764]             version = "1.8"), class = "FutureResult")
[13:22:00.764]     }, finally = {
[13:22:00.764]         if (!identical(...future.workdir, getwd())) 
[13:22:00.764]             setwd(...future.workdir)
[13:22:00.764]         {
[13:22:00.764]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:00.764]                 ...future.oldOptions$nwarnings <- NULL
[13:22:00.764]             }
[13:22:00.764]             base::options(...future.oldOptions)
[13:22:00.764]             if (.Platform$OS.type == "windows") {
[13:22:00.764]                 old_names <- names(...future.oldEnvVars)
[13:22:00.764]                 envs <- base::Sys.getenv()
[13:22:00.764]                 names <- names(envs)
[13:22:00.764]                 common <- intersect(names, old_names)
[13:22:00.764]                 added <- setdiff(names, old_names)
[13:22:00.764]                 removed <- setdiff(old_names, names)
[13:22:00.764]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:00.764]                   envs[common]]
[13:22:00.764]                 NAMES <- toupper(changed)
[13:22:00.764]                 args <- list()
[13:22:00.764]                 for (kk in seq_along(NAMES)) {
[13:22:00.764]                   name <- changed[[kk]]
[13:22:00.764]                   NAME <- NAMES[[kk]]
[13:22:00.764]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.764]                     next
[13:22:00.764]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:00.764]                 }
[13:22:00.764]                 NAMES <- toupper(added)
[13:22:00.764]                 for (kk in seq_along(NAMES)) {
[13:22:00.764]                   name <- added[[kk]]
[13:22:00.764]                   NAME <- NAMES[[kk]]
[13:22:00.764]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.764]                     next
[13:22:00.764]                   args[[name]] <- ""
[13:22:00.764]                 }
[13:22:00.764]                 NAMES <- toupper(removed)
[13:22:00.764]                 for (kk in seq_along(NAMES)) {
[13:22:00.764]                   name <- removed[[kk]]
[13:22:00.764]                   NAME <- NAMES[[kk]]
[13:22:00.764]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.764]                     next
[13:22:00.764]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:00.764]                 }
[13:22:00.764]                 if (length(args) > 0) 
[13:22:00.764]                   base::do.call(base::Sys.setenv, args = args)
[13:22:00.764]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:00.764]             }
[13:22:00.764]             else {
[13:22:00.764]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:00.764]             }
[13:22:00.764]             {
[13:22:00.764]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:00.764]                   0L) {
[13:22:00.764]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:00.764]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:00.764]                   base::options(opts)
[13:22:00.764]                 }
[13:22:00.764]                 {
[13:22:00.764]                   {
[13:22:00.764]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:00.764]                     NULL
[13:22:00.764]                   }
[13:22:00.764]                   options(future.plan = NULL)
[13:22:00.764]                   if (is.na(NA_character_)) 
[13:22:00.764]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:00.764]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:00.764]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:00.764]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:00.764]                     envir = parent.frame()) 
[13:22:00.764]                   {
[13:22:00.764]                     if (is.function(workers)) 
[13:22:00.764]                       workers <- workers()
[13:22:00.764]                     workers <- structure(as.integer(workers), 
[13:22:00.764]                       class = class(workers))
[13:22:00.764]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:00.764]                       workers >= 1)
[13:22:00.764]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:00.764]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:00.764]                     }
[13:22:00.764]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:00.764]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:00.764]                       envir = envir)
[13:22:00.764]                     if (!future$lazy) 
[13:22:00.764]                       future <- run(future)
[13:22:00.764]                     invisible(future)
[13:22:00.764]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:00.764]                 }
[13:22:00.764]             }
[13:22:00.764]         }
[13:22:00.764]     })
[13:22:00.764]     if (TRUE) {
[13:22:00.764]         base::sink(type = "output", split = FALSE)
[13:22:00.764]         if (TRUE) {
[13:22:00.764]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:00.764]         }
[13:22:00.764]         else {
[13:22:00.764]             ...future.result["stdout"] <- base::list(NULL)
[13:22:00.764]         }
[13:22:00.764]         base::close(...future.stdout)
[13:22:00.764]         ...future.stdout <- NULL
[13:22:00.764]     }
[13:22:00.764]     ...future.result$conditions <- ...future.conditions
[13:22:00.764]     ...future.result$finished <- base::Sys.time()
[13:22:00.764]     ...future.result
[13:22:00.764] }
[13:22:00.767] MultisessionFuture started
[13:22:00.767] - Launch lazy future ... done
[13:22:00.767] run() for ‘MultisessionFuture’ ... done
[13:22:00.768] resolve() on environment ...
[13:22:00.768]  recursive: 0
[13:22:00.769]  elements: [3] ‘a’, ‘b’, ‘c’
[13:22:00.790]  length: 2 (resolved future 3)
[13:22:00.800] receiveMessageFromWorker() for ClusterFuture ...
[13:22:00.801] - Validating connection of MultisessionFuture
[13:22:00.801] - received message: FutureResult
[13:22:00.801] - Received FutureResult
[13:22:00.801] - Erased future from FutureRegistry
[13:22:00.801] result() for ClusterFuture ...
[13:22:00.801] - result already collected: FutureResult
[13:22:00.801] result() for ClusterFuture ... done
[13:22:00.801] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:00.802] Future #1
[13:22:00.802]  length: 1 (resolved future 1)
[13:22:00.823] receiveMessageFromWorker() for ClusterFuture ...
[13:22:00.823] - Validating connection of MultisessionFuture
[13:22:00.823] - received message: FutureResult
[13:22:00.823] - Received FutureResult
[13:22:00.823] - Erased future from FutureRegistry
[13:22:00.823] result() for ClusterFuture ...
[13:22:00.823] - result already collected: FutureResult
[13:22:00.824] result() for ClusterFuture ... done
[13:22:00.824] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:00.824] Future #2
[13:22:00.824]  length: 0 (resolved future 2)
[13:22:00.824] resolve() on environment ... DONE
[13:22:00.825] getGlobalsAndPackages() ...
[13:22:00.825] Searching for globals...
[13:22:00.825] - globals found: [1] ‘{’
[13:22:00.826] Searching for globals ... DONE
[13:22:00.826] Resolving globals: FALSE
[13:22:00.826] 
[13:22:00.826] 
[13:22:00.826] getGlobalsAndPackages() ... DONE
[13:22:00.826] run() for ‘Future’ ...
[13:22:00.826] - state: ‘created’
[13:22:00.827] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:00.843] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:00.843] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:00.843]   - Field: ‘node’
[13:22:00.843]   - Field: ‘label’
[13:22:00.843]   - Field: ‘local’
[13:22:00.843]   - Field: ‘owner’
[13:22:00.844]   - Field: ‘envir’
[13:22:00.844]   - Field: ‘workers’
[13:22:00.844]   - Field: ‘packages’
[13:22:00.844]   - Field: ‘gc’
[13:22:00.844]   - Field: ‘conditions’
[13:22:00.844]   - Field: ‘persistent’
[13:22:00.844]   - Field: ‘expr’
[13:22:00.844]   - Field: ‘uuid’
[13:22:00.844]   - Field: ‘seed’
[13:22:00.844]   - Field: ‘version’
[13:22:00.844]   - Field: ‘result’
[13:22:00.845]   - Field: ‘asynchronous’
[13:22:00.845]   - Field: ‘calls’
[13:22:00.845]   - Field: ‘globals’
[13:22:00.845]   - Field: ‘stdout’
[13:22:00.845]   - Field: ‘earlySignal’
[13:22:00.845]   - Field: ‘lazy’
[13:22:00.845]   - Field: ‘state’
[13:22:00.845] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:00.845] - Launch lazy future ...
[13:22:00.846] Packages needed by the future expression (n = 0): <none>
[13:22:00.846] Packages needed by future strategies (n = 0): <none>
[13:22:00.846] {
[13:22:00.846]     {
[13:22:00.846]         {
[13:22:00.846]             ...future.startTime <- base::Sys.time()
[13:22:00.846]             {
[13:22:00.846]                 {
[13:22:00.846]                   {
[13:22:00.846]                     {
[13:22:00.846]                       base::local({
[13:22:00.846]                         has_future <- base::requireNamespace("future", 
[13:22:00.846]                           quietly = TRUE)
[13:22:00.846]                         if (has_future) {
[13:22:00.846]                           ns <- base::getNamespace("future")
[13:22:00.846]                           version <- ns[[".package"]][["version"]]
[13:22:00.846]                           if (is.null(version)) 
[13:22:00.846]                             version <- utils::packageVersion("future")
[13:22:00.846]                         }
[13:22:00.846]                         else {
[13:22:00.846]                           version <- NULL
[13:22:00.846]                         }
[13:22:00.846]                         if (!has_future || version < "1.8.0") {
[13:22:00.846]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:00.846]                             "", base::R.version$version.string), 
[13:22:00.846]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:00.846]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:00.846]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:00.846]                               "release", "version")], collapse = " "), 
[13:22:00.846]                             hostname = base::Sys.info()[["nodename"]])
[13:22:00.846]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:00.846]                             info)
[13:22:00.846]                           info <- base::paste(info, collapse = "; ")
[13:22:00.846]                           if (!has_future) {
[13:22:00.846]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:00.846]                               info)
[13:22:00.846]                           }
[13:22:00.846]                           else {
[13:22:00.846]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:00.846]                               info, version)
[13:22:00.846]                           }
[13:22:00.846]                           base::stop(msg)
[13:22:00.846]                         }
[13:22:00.846]                       })
[13:22:00.846]                     }
[13:22:00.846]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:00.846]                     base::options(mc.cores = 1L)
[13:22:00.846]                   }
[13:22:00.846]                   options(future.plan = NULL)
[13:22:00.846]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:00.846]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:00.846]                 }
[13:22:00.846]                 ...future.workdir <- getwd()
[13:22:00.846]             }
[13:22:00.846]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:00.846]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:00.846]         }
[13:22:00.846]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:00.846]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:00.846]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:00.846]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:00.846]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:00.846]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:00.846]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:00.846]             base::names(...future.oldOptions))
[13:22:00.846]     }
[13:22:00.846]     if (FALSE) {
[13:22:00.846]     }
[13:22:00.846]     else {
[13:22:00.846]         if (TRUE) {
[13:22:00.846]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:00.846]                 open = "w")
[13:22:00.846]         }
[13:22:00.846]         else {
[13:22:00.846]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:00.846]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:00.846]         }
[13:22:00.846]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:00.846]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:00.846]             base::sink(type = "output", split = FALSE)
[13:22:00.846]             base::close(...future.stdout)
[13:22:00.846]         }, add = TRUE)
[13:22:00.846]     }
[13:22:00.846]     ...future.frame <- base::sys.nframe()
[13:22:00.846]     ...future.conditions <- base::list()
[13:22:00.846]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:00.846]     if (FALSE) {
[13:22:00.846]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:00.846]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:00.846]     }
[13:22:00.846]     ...future.result <- base::tryCatch({
[13:22:00.846]         base::withCallingHandlers({
[13:22:00.846]             ...future.value <- base::withVisible(base::local({
[13:22:00.846]                 ...future.makeSendCondition <- local({
[13:22:00.846]                   sendCondition <- NULL
[13:22:00.846]                   function(frame = 1L) {
[13:22:00.846]                     if (is.function(sendCondition)) 
[13:22:00.846]                       return(sendCondition)
[13:22:00.846]                     ns <- getNamespace("parallel")
[13:22:00.846]                     if (exists("sendData", mode = "function", 
[13:22:00.846]                       envir = ns)) {
[13:22:00.846]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:00.846]                         envir = ns)
[13:22:00.846]                       envir <- sys.frame(frame)
[13:22:00.846]                       master <- NULL
[13:22:00.846]                       while (!identical(envir, .GlobalEnv) && 
[13:22:00.846]                         !identical(envir, emptyenv())) {
[13:22:00.846]                         if (exists("master", mode = "list", envir = envir, 
[13:22:00.846]                           inherits = FALSE)) {
[13:22:00.846]                           master <- get("master", mode = "list", 
[13:22:00.846]                             envir = envir, inherits = FALSE)
[13:22:00.846]                           if (inherits(master, c("SOCKnode", 
[13:22:00.846]                             "SOCK0node"))) {
[13:22:00.846]                             sendCondition <<- function(cond) {
[13:22:00.846]                               data <- list(type = "VALUE", value = cond, 
[13:22:00.846]                                 success = TRUE)
[13:22:00.846]                               parallel_sendData(master, data)
[13:22:00.846]                             }
[13:22:00.846]                             return(sendCondition)
[13:22:00.846]                           }
[13:22:00.846]                         }
[13:22:00.846]                         frame <- frame + 1L
[13:22:00.846]                         envir <- sys.frame(frame)
[13:22:00.846]                       }
[13:22:00.846]                     }
[13:22:00.846]                     sendCondition <<- function(cond) NULL
[13:22:00.846]                   }
[13:22:00.846]                 })
[13:22:00.846]                 withCallingHandlers({
[13:22:00.846]                   {
[13:22:00.846]                     1
[13:22:00.846]                   }
[13:22:00.846]                 }, immediateCondition = function(cond) {
[13:22:00.846]                   sendCondition <- ...future.makeSendCondition()
[13:22:00.846]                   sendCondition(cond)
[13:22:00.846]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.846]                   {
[13:22:00.846]                     inherits <- base::inherits
[13:22:00.846]                     invokeRestart <- base::invokeRestart
[13:22:00.846]                     is.null <- base::is.null
[13:22:00.846]                     muffled <- FALSE
[13:22:00.846]                     if (inherits(cond, "message")) {
[13:22:00.846]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:00.846]                       if (muffled) 
[13:22:00.846]                         invokeRestart("muffleMessage")
[13:22:00.846]                     }
[13:22:00.846]                     else if (inherits(cond, "warning")) {
[13:22:00.846]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:00.846]                       if (muffled) 
[13:22:00.846]                         invokeRestart("muffleWarning")
[13:22:00.846]                     }
[13:22:00.846]                     else if (inherits(cond, "condition")) {
[13:22:00.846]                       if (!is.null(pattern)) {
[13:22:00.846]                         computeRestarts <- base::computeRestarts
[13:22:00.846]                         grepl <- base::grepl
[13:22:00.846]                         restarts <- computeRestarts(cond)
[13:22:00.846]                         for (restart in restarts) {
[13:22:00.846]                           name <- restart$name
[13:22:00.846]                           if (is.null(name)) 
[13:22:00.846]                             next
[13:22:00.846]                           if (!grepl(pattern, name)) 
[13:22:00.846]                             next
[13:22:00.846]                           invokeRestart(restart)
[13:22:00.846]                           muffled <- TRUE
[13:22:00.846]                           break
[13:22:00.846]                         }
[13:22:00.846]                       }
[13:22:00.846]                     }
[13:22:00.846]                     invisible(muffled)
[13:22:00.846]                   }
[13:22:00.846]                   muffleCondition(cond)
[13:22:00.846]                 })
[13:22:00.846]             }))
[13:22:00.846]             future::FutureResult(value = ...future.value$value, 
[13:22:00.846]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:00.846]                   ...future.rng), globalenv = if (FALSE) 
[13:22:00.846]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:00.846]                     ...future.globalenv.names))
[13:22:00.846]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:00.846]         }, condition = base::local({
[13:22:00.846]             c <- base::c
[13:22:00.846]             inherits <- base::inherits
[13:22:00.846]             invokeRestart <- base::invokeRestart
[13:22:00.846]             length <- base::length
[13:22:00.846]             list <- base::list
[13:22:00.846]             seq.int <- base::seq.int
[13:22:00.846]             signalCondition <- base::signalCondition
[13:22:00.846]             sys.calls <- base::sys.calls
[13:22:00.846]             `[[` <- base::`[[`
[13:22:00.846]             `+` <- base::`+`
[13:22:00.846]             `<<-` <- base::`<<-`
[13:22:00.846]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:00.846]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:00.846]                   3L)]
[13:22:00.846]             }
[13:22:00.846]             function(cond) {
[13:22:00.846]                 is_error <- inherits(cond, "error")
[13:22:00.846]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:00.846]                   NULL)
[13:22:00.846]                 if (is_error) {
[13:22:00.846]                   sessionInformation <- function() {
[13:22:00.846]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:00.846]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:00.846]                       search = base::search(), system = base::Sys.info())
[13:22:00.846]                   }
[13:22:00.846]                   ...future.conditions[[length(...future.conditions) + 
[13:22:00.846]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:00.846]                     cond$call), session = sessionInformation(), 
[13:22:00.846]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:00.846]                   signalCondition(cond)
[13:22:00.846]                 }
[13:22:00.846]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:00.846]                 "immediateCondition"))) {
[13:22:00.846]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:00.846]                   ...future.conditions[[length(...future.conditions) + 
[13:22:00.846]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:00.846]                   if (TRUE && !signal) {
[13:22:00.846]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.846]                     {
[13:22:00.846]                       inherits <- base::inherits
[13:22:00.846]                       invokeRestart <- base::invokeRestart
[13:22:00.846]                       is.null <- base::is.null
[13:22:00.846]                       muffled <- FALSE
[13:22:00.846]                       if (inherits(cond, "message")) {
[13:22:00.846]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:00.846]                         if (muffled) 
[13:22:00.846]                           invokeRestart("muffleMessage")
[13:22:00.846]                       }
[13:22:00.846]                       else if (inherits(cond, "warning")) {
[13:22:00.846]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:00.846]                         if (muffled) 
[13:22:00.846]                           invokeRestart("muffleWarning")
[13:22:00.846]                       }
[13:22:00.846]                       else if (inherits(cond, "condition")) {
[13:22:00.846]                         if (!is.null(pattern)) {
[13:22:00.846]                           computeRestarts <- base::computeRestarts
[13:22:00.846]                           grepl <- base::grepl
[13:22:00.846]                           restarts <- computeRestarts(cond)
[13:22:00.846]                           for (restart in restarts) {
[13:22:00.846]                             name <- restart$name
[13:22:00.846]                             if (is.null(name)) 
[13:22:00.846]                               next
[13:22:00.846]                             if (!grepl(pattern, name)) 
[13:22:00.846]                               next
[13:22:00.846]                             invokeRestart(restart)
[13:22:00.846]                             muffled <- TRUE
[13:22:00.846]                             break
[13:22:00.846]                           }
[13:22:00.846]                         }
[13:22:00.846]                       }
[13:22:00.846]                       invisible(muffled)
[13:22:00.846]                     }
[13:22:00.846]                     muffleCondition(cond, pattern = "^muffle")
[13:22:00.846]                   }
[13:22:00.846]                 }
[13:22:00.846]                 else {
[13:22:00.846]                   if (TRUE) {
[13:22:00.846]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.846]                     {
[13:22:00.846]                       inherits <- base::inherits
[13:22:00.846]                       invokeRestart <- base::invokeRestart
[13:22:00.846]                       is.null <- base::is.null
[13:22:00.846]                       muffled <- FALSE
[13:22:00.846]                       if (inherits(cond, "message")) {
[13:22:00.846]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:00.846]                         if (muffled) 
[13:22:00.846]                           invokeRestart("muffleMessage")
[13:22:00.846]                       }
[13:22:00.846]                       else if (inherits(cond, "warning")) {
[13:22:00.846]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:00.846]                         if (muffled) 
[13:22:00.846]                           invokeRestart("muffleWarning")
[13:22:00.846]                       }
[13:22:00.846]                       else if (inherits(cond, "condition")) {
[13:22:00.846]                         if (!is.null(pattern)) {
[13:22:00.846]                           computeRestarts <- base::computeRestarts
[13:22:00.846]                           grepl <- base::grepl
[13:22:00.846]                           restarts <- computeRestarts(cond)
[13:22:00.846]                           for (restart in restarts) {
[13:22:00.846]                             name <- restart$name
[13:22:00.846]                             if (is.null(name)) 
[13:22:00.846]                               next
[13:22:00.846]                             if (!grepl(pattern, name)) 
[13:22:00.846]                               next
[13:22:00.846]                             invokeRestart(restart)
[13:22:00.846]                             muffled <- TRUE
[13:22:00.846]                             break
[13:22:00.846]                           }
[13:22:00.846]                         }
[13:22:00.846]                       }
[13:22:00.846]                       invisible(muffled)
[13:22:00.846]                     }
[13:22:00.846]                     muffleCondition(cond, pattern = "^muffle")
[13:22:00.846]                   }
[13:22:00.846]                 }
[13:22:00.846]             }
[13:22:00.846]         }))
[13:22:00.846]     }, error = function(ex) {
[13:22:00.846]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:00.846]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:00.846]                 ...future.rng), started = ...future.startTime, 
[13:22:00.846]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:00.846]             version = "1.8"), class = "FutureResult")
[13:22:00.846]     }, finally = {
[13:22:00.846]         if (!identical(...future.workdir, getwd())) 
[13:22:00.846]             setwd(...future.workdir)
[13:22:00.846]         {
[13:22:00.846]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:00.846]                 ...future.oldOptions$nwarnings <- NULL
[13:22:00.846]             }
[13:22:00.846]             base::options(...future.oldOptions)
[13:22:00.846]             if (.Platform$OS.type == "windows") {
[13:22:00.846]                 old_names <- names(...future.oldEnvVars)
[13:22:00.846]                 envs <- base::Sys.getenv()
[13:22:00.846]                 names <- names(envs)
[13:22:00.846]                 common <- intersect(names, old_names)
[13:22:00.846]                 added <- setdiff(names, old_names)
[13:22:00.846]                 removed <- setdiff(old_names, names)
[13:22:00.846]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:00.846]                   envs[common]]
[13:22:00.846]                 NAMES <- toupper(changed)
[13:22:00.846]                 args <- list()
[13:22:00.846]                 for (kk in seq_along(NAMES)) {
[13:22:00.846]                   name <- changed[[kk]]
[13:22:00.846]                   NAME <- NAMES[[kk]]
[13:22:00.846]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.846]                     next
[13:22:00.846]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:00.846]                 }
[13:22:00.846]                 NAMES <- toupper(added)
[13:22:00.846]                 for (kk in seq_along(NAMES)) {
[13:22:00.846]                   name <- added[[kk]]
[13:22:00.846]                   NAME <- NAMES[[kk]]
[13:22:00.846]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.846]                     next
[13:22:00.846]                   args[[name]] <- ""
[13:22:00.846]                 }
[13:22:00.846]                 NAMES <- toupper(removed)
[13:22:00.846]                 for (kk in seq_along(NAMES)) {
[13:22:00.846]                   name <- removed[[kk]]
[13:22:00.846]                   NAME <- NAMES[[kk]]
[13:22:00.846]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.846]                     next
[13:22:00.846]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:00.846]                 }
[13:22:00.846]                 if (length(args) > 0) 
[13:22:00.846]                   base::do.call(base::Sys.setenv, args = args)
[13:22:00.846]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:00.846]             }
[13:22:00.846]             else {
[13:22:00.846]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:00.846]             }
[13:22:00.846]             {
[13:22:00.846]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:00.846]                   0L) {
[13:22:00.846]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:00.846]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:00.846]                   base::options(opts)
[13:22:00.846]                 }
[13:22:00.846]                 {
[13:22:00.846]                   {
[13:22:00.846]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:00.846]                     NULL
[13:22:00.846]                   }
[13:22:00.846]                   options(future.plan = NULL)
[13:22:00.846]                   if (is.na(NA_character_)) 
[13:22:00.846]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:00.846]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:00.846]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:00.846]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:00.846]                     envir = parent.frame()) 
[13:22:00.846]                   {
[13:22:00.846]                     if (is.function(workers)) 
[13:22:00.846]                       workers <- workers()
[13:22:00.846]                     workers <- structure(as.integer(workers), 
[13:22:00.846]                       class = class(workers))
[13:22:00.846]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:00.846]                       workers >= 1)
[13:22:00.846]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:00.846]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:00.846]                     }
[13:22:00.846]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:00.846]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:00.846]                       envir = envir)
[13:22:00.846]                     if (!future$lazy) 
[13:22:00.846]                       future <- run(future)
[13:22:00.846]                     invisible(future)
[13:22:00.846]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:00.846]                 }
[13:22:00.846]             }
[13:22:00.846]         }
[13:22:00.846]     })
[13:22:00.846]     if (TRUE) {
[13:22:00.846]         base::sink(type = "output", split = FALSE)
[13:22:00.846]         if (TRUE) {
[13:22:00.846]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:00.846]         }
[13:22:00.846]         else {
[13:22:00.846]             ...future.result["stdout"] <- base::list(NULL)
[13:22:00.846]         }
[13:22:00.846]         base::close(...future.stdout)
[13:22:00.846]         ...future.stdout <- NULL
[13:22:00.846]     }
[13:22:00.846]     ...future.result$conditions <- ...future.conditions
[13:22:00.846]     ...future.result$finished <- base::Sys.time()
[13:22:00.846]     ...future.result
[13:22:00.846] }
[13:22:00.850] MultisessionFuture started
[13:22:00.850] - Launch lazy future ... done
[13:22:00.850] run() for ‘MultisessionFuture’ ... done
[13:22:00.850] getGlobalsAndPackages() ...
[13:22:00.850] Searching for globals...
[13:22:00.851] - globals found: [1] ‘{’
[13:22:00.851] Searching for globals ... DONE
[13:22:00.851] Resolving globals: FALSE
[13:22:00.852] 
[13:22:00.852] 
[13:22:00.852] getGlobalsAndPackages() ... DONE
[13:22:00.852] run() for ‘Future’ ...
[13:22:00.852] - state: ‘created’
[13:22:00.852] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:00.867] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:00.867] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:00.867]   - Field: ‘node’
[13:22:00.868]   - Field: ‘label’
[13:22:00.868]   - Field: ‘local’
[13:22:00.868]   - Field: ‘owner’
[13:22:00.868]   - Field: ‘envir’
[13:22:00.868]   - Field: ‘workers’
[13:22:00.868]   - Field: ‘packages’
[13:22:00.868]   - Field: ‘gc’
[13:22:00.868]   - Field: ‘conditions’
[13:22:00.868]   - Field: ‘persistent’
[13:22:00.868]   - Field: ‘expr’
[13:22:00.868]   - Field: ‘uuid’
[13:22:00.869]   - Field: ‘seed’
[13:22:00.869]   - Field: ‘version’
[13:22:00.869]   - Field: ‘result’
[13:22:00.869]   - Field: ‘asynchronous’
[13:22:00.869]   - Field: ‘calls’
[13:22:00.869]   - Field: ‘globals’
[13:22:00.869]   - Field: ‘stdout’
[13:22:00.869]   - Field: ‘earlySignal’
[13:22:00.869]   - Field: ‘lazy’
[13:22:00.869]   - Field: ‘state’
[13:22:00.870] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:00.870] - Launch lazy future ...
[13:22:00.870] Packages needed by the future expression (n = 0): <none>
[13:22:00.870] Packages needed by future strategies (n = 0): <none>
[13:22:00.871] {
[13:22:00.871]     {
[13:22:00.871]         {
[13:22:00.871]             ...future.startTime <- base::Sys.time()
[13:22:00.871]             {
[13:22:00.871]                 {
[13:22:00.871]                   {
[13:22:00.871]                     {
[13:22:00.871]                       base::local({
[13:22:00.871]                         has_future <- base::requireNamespace("future", 
[13:22:00.871]                           quietly = TRUE)
[13:22:00.871]                         if (has_future) {
[13:22:00.871]                           ns <- base::getNamespace("future")
[13:22:00.871]                           version <- ns[[".package"]][["version"]]
[13:22:00.871]                           if (is.null(version)) 
[13:22:00.871]                             version <- utils::packageVersion("future")
[13:22:00.871]                         }
[13:22:00.871]                         else {
[13:22:00.871]                           version <- NULL
[13:22:00.871]                         }
[13:22:00.871]                         if (!has_future || version < "1.8.0") {
[13:22:00.871]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:00.871]                             "", base::R.version$version.string), 
[13:22:00.871]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:00.871]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:00.871]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:00.871]                               "release", "version")], collapse = " "), 
[13:22:00.871]                             hostname = base::Sys.info()[["nodename"]])
[13:22:00.871]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:00.871]                             info)
[13:22:00.871]                           info <- base::paste(info, collapse = "; ")
[13:22:00.871]                           if (!has_future) {
[13:22:00.871]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:00.871]                               info)
[13:22:00.871]                           }
[13:22:00.871]                           else {
[13:22:00.871]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:00.871]                               info, version)
[13:22:00.871]                           }
[13:22:00.871]                           base::stop(msg)
[13:22:00.871]                         }
[13:22:00.871]                       })
[13:22:00.871]                     }
[13:22:00.871]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:00.871]                     base::options(mc.cores = 1L)
[13:22:00.871]                   }
[13:22:00.871]                   options(future.plan = NULL)
[13:22:00.871]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:00.871]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:00.871]                 }
[13:22:00.871]                 ...future.workdir <- getwd()
[13:22:00.871]             }
[13:22:00.871]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:00.871]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:00.871]         }
[13:22:00.871]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:00.871]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:00.871]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:00.871]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:00.871]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:00.871]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:00.871]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:00.871]             base::names(...future.oldOptions))
[13:22:00.871]     }
[13:22:00.871]     if (FALSE) {
[13:22:00.871]     }
[13:22:00.871]     else {
[13:22:00.871]         if (TRUE) {
[13:22:00.871]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:00.871]                 open = "w")
[13:22:00.871]         }
[13:22:00.871]         else {
[13:22:00.871]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:00.871]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:00.871]         }
[13:22:00.871]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:00.871]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:00.871]             base::sink(type = "output", split = FALSE)
[13:22:00.871]             base::close(...future.stdout)
[13:22:00.871]         }, add = TRUE)
[13:22:00.871]     }
[13:22:00.871]     ...future.frame <- base::sys.nframe()
[13:22:00.871]     ...future.conditions <- base::list()
[13:22:00.871]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:00.871]     if (FALSE) {
[13:22:00.871]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:00.871]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:00.871]     }
[13:22:00.871]     ...future.result <- base::tryCatch({
[13:22:00.871]         base::withCallingHandlers({
[13:22:00.871]             ...future.value <- base::withVisible(base::local({
[13:22:00.871]                 ...future.makeSendCondition <- local({
[13:22:00.871]                   sendCondition <- NULL
[13:22:00.871]                   function(frame = 1L) {
[13:22:00.871]                     if (is.function(sendCondition)) 
[13:22:00.871]                       return(sendCondition)
[13:22:00.871]                     ns <- getNamespace("parallel")
[13:22:00.871]                     if (exists("sendData", mode = "function", 
[13:22:00.871]                       envir = ns)) {
[13:22:00.871]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:00.871]                         envir = ns)
[13:22:00.871]                       envir <- sys.frame(frame)
[13:22:00.871]                       master <- NULL
[13:22:00.871]                       while (!identical(envir, .GlobalEnv) && 
[13:22:00.871]                         !identical(envir, emptyenv())) {
[13:22:00.871]                         if (exists("master", mode = "list", envir = envir, 
[13:22:00.871]                           inherits = FALSE)) {
[13:22:00.871]                           master <- get("master", mode = "list", 
[13:22:00.871]                             envir = envir, inherits = FALSE)
[13:22:00.871]                           if (inherits(master, c("SOCKnode", 
[13:22:00.871]                             "SOCK0node"))) {
[13:22:00.871]                             sendCondition <<- function(cond) {
[13:22:00.871]                               data <- list(type = "VALUE", value = cond, 
[13:22:00.871]                                 success = TRUE)
[13:22:00.871]                               parallel_sendData(master, data)
[13:22:00.871]                             }
[13:22:00.871]                             return(sendCondition)
[13:22:00.871]                           }
[13:22:00.871]                         }
[13:22:00.871]                         frame <- frame + 1L
[13:22:00.871]                         envir <- sys.frame(frame)
[13:22:00.871]                       }
[13:22:00.871]                     }
[13:22:00.871]                     sendCondition <<- function(cond) NULL
[13:22:00.871]                   }
[13:22:00.871]                 })
[13:22:00.871]                 withCallingHandlers({
[13:22:00.871]                   {
[13:22:00.871]                     2
[13:22:00.871]                   }
[13:22:00.871]                 }, immediateCondition = function(cond) {
[13:22:00.871]                   sendCondition <- ...future.makeSendCondition()
[13:22:00.871]                   sendCondition(cond)
[13:22:00.871]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.871]                   {
[13:22:00.871]                     inherits <- base::inherits
[13:22:00.871]                     invokeRestart <- base::invokeRestart
[13:22:00.871]                     is.null <- base::is.null
[13:22:00.871]                     muffled <- FALSE
[13:22:00.871]                     if (inherits(cond, "message")) {
[13:22:00.871]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:00.871]                       if (muffled) 
[13:22:00.871]                         invokeRestart("muffleMessage")
[13:22:00.871]                     }
[13:22:00.871]                     else if (inherits(cond, "warning")) {
[13:22:00.871]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:00.871]                       if (muffled) 
[13:22:00.871]                         invokeRestart("muffleWarning")
[13:22:00.871]                     }
[13:22:00.871]                     else if (inherits(cond, "condition")) {
[13:22:00.871]                       if (!is.null(pattern)) {
[13:22:00.871]                         computeRestarts <- base::computeRestarts
[13:22:00.871]                         grepl <- base::grepl
[13:22:00.871]                         restarts <- computeRestarts(cond)
[13:22:00.871]                         for (restart in restarts) {
[13:22:00.871]                           name <- restart$name
[13:22:00.871]                           if (is.null(name)) 
[13:22:00.871]                             next
[13:22:00.871]                           if (!grepl(pattern, name)) 
[13:22:00.871]                             next
[13:22:00.871]                           invokeRestart(restart)
[13:22:00.871]                           muffled <- TRUE
[13:22:00.871]                           break
[13:22:00.871]                         }
[13:22:00.871]                       }
[13:22:00.871]                     }
[13:22:00.871]                     invisible(muffled)
[13:22:00.871]                   }
[13:22:00.871]                   muffleCondition(cond)
[13:22:00.871]                 })
[13:22:00.871]             }))
[13:22:00.871]             future::FutureResult(value = ...future.value$value, 
[13:22:00.871]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:00.871]                   ...future.rng), globalenv = if (FALSE) 
[13:22:00.871]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:00.871]                     ...future.globalenv.names))
[13:22:00.871]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:00.871]         }, condition = base::local({
[13:22:00.871]             c <- base::c
[13:22:00.871]             inherits <- base::inherits
[13:22:00.871]             invokeRestart <- base::invokeRestart
[13:22:00.871]             length <- base::length
[13:22:00.871]             list <- base::list
[13:22:00.871]             seq.int <- base::seq.int
[13:22:00.871]             signalCondition <- base::signalCondition
[13:22:00.871]             sys.calls <- base::sys.calls
[13:22:00.871]             `[[` <- base::`[[`
[13:22:00.871]             `+` <- base::`+`
[13:22:00.871]             `<<-` <- base::`<<-`
[13:22:00.871]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:00.871]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:00.871]                   3L)]
[13:22:00.871]             }
[13:22:00.871]             function(cond) {
[13:22:00.871]                 is_error <- inherits(cond, "error")
[13:22:00.871]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:00.871]                   NULL)
[13:22:00.871]                 if (is_error) {
[13:22:00.871]                   sessionInformation <- function() {
[13:22:00.871]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:00.871]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:00.871]                       search = base::search(), system = base::Sys.info())
[13:22:00.871]                   }
[13:22:00.871]                   ...future.conditions[[length(...future.conditions) + 
[13:22:00.871]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:00.871]                     cond$call), session = sessionInformation(), 
[13:22:00.871]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:00.871]                   signalCondition(cond)
[13:22:00.871]                 }
[13:22:00.871]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:00.871]                 "immediateCondition"))) {
[13:22:00.871]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:00.871]                   ...future.conditions[[length(...future.conditions) + 
[13:22:00.871]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:00.871]                   if (TRUE && !signal) {
[13:22:00.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.871]                     {
[13:22:00.871]                       inherits <- base::inherits
[13:22:00.871]                       invokeRestart <- base::invokeRestart
[13:22:00.871]                       is.null <- base::is.null
[13:22:00.871]                       muffled <- FALSE
[13:22:00.871]                       if (inherits(cond, "message")) {
[13:22:00.871]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:00.871]                         if (muffled) 
[13:22:00.871]                           invokeRestart("muffleMessage")
[13:22:00.871]                       }
[13:22:00.871]                       else if (inherits(cond, "warning")) {
[13:22:00.871]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:00.871]                         if (muffled) 
[13:22:00.871]                           invokeRestart("muffleWarning")
[13:22:00.871]                       }
[13:22:00.871]                       else if (inherits(cond, "condition")) {
[13:22:00.871]                         if (!is.null(pattern)) {
[13:22:00.871]                           computeRestarts <- base::computeRestarts
[13:22:00.871]                           grepl <- base::grepl
[13:22:00.871]                           restarts <- computeRestarts(cond)
[13:22:00.871]                           for (restart in restarts) {
[13:22:00.871]                             name <- restart$name
[13:22:00.871]                             if (is.null(name)) 
[13:22:00.871]                               next
[13:22:00.871]                             if (!grepl(pattern, name)) 
[13:22:00.871]                               next
[13:22:00.871]                             invokeRestart(restart)
[13:22:00.871]                             muffled <- TRUE
[13:22:00.871]                             break
[13:22:00.871]                           }
[13:22:00.871]                         }
[13:22:00.871]                       }
[13:22:00.871]                       invisible(muffled)
[13:22:00.871]                     }
[13:22:00.871]                     muffleCondition(cond, pattern = "^muffle")
[13:22:00.871]                   }
[13:22:00.871]                 }
[13:22:00.871]                 else {
[13:22:00.871]                   if (TRUE) {
[13:22:00.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.871]                     {
[13:22:00.871]                       inherits <- base::inherits
[13:22:00.871]                       invokeRestart <- base::invokeRestart
[13:22:00.871]                       is.null <- base::is.null
[13:22:00.871]                       muffled <- FALSE
[13:22:00.871]                       if (inherits(cond, "message")) {
[13:22:00.871]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:00.871]                         if (muffled) 
[13:22:00.871]                           invokeRestart("muffleMessage")
[13:22:00.871]                       }
[13:22:00.871]                       else if (inherits(cond, "warning")) {
[13:22:00.871]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:00.871]                         if (muffled) 
[13:22:00.871]                           invokeRestart("muffleWarning")
[13:22:00.871]                       }
[13:22:00.871]                       else if (inherits(cond, "condition")) {
[13:22:00.871]                         if (!is.null(pattern)) {
[13:22:00.871]                           computeRestarts <- base::computeRestarts
[13:22:00.871]                           grepl <- base::grepl
[13:22:00.871]                           restarts <- computeRestarts(cond)
[13:22:00.871]                           for (restart in restarts) {
[13:22:00.871]                             name <- restart$name
[13:22:00.871]                             if (is.null(name)) 
[13:22:00.871]                               next
[13:22:00.871]                             if (!grepl(pattern, name)) 
[13:22:00.871]                               next
[13:22:00.871]                             invokeRestart(restart)
[13:22:00.871]                             muffled <- TRUE
[13:22:00.871]                             break
[13:22:00.871]                           }
[13:22:00.871]                         }
[13:22:00.871]                       }
[13:22:00.871]                       invisible(muffled)
[13:22:00.871]                     }
[13:22:00.871]                     muffleCondition(cond, pattern = "^muffle")
[13:22:00.871]                   }
[13:22:00.871]                 }
[13:22:00.871]             }
[13:22:00.871]         }))
[13:22:00.871]     }, error = function(ex) {
[13:22:00.871]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:00.871]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:00.871]                 ...future.rng), started = ...future.startTime, 
[13:22:00.871]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:00.871]             version = "1.8"), class = "FutureResult")
[13:22:00.871]     }, finally = {
[13:22:00.871]         if (!identical(...future.workdir, getwd())) 
[13:22:00.871]             setwd(...future.workdir)
[13:22:00.871]         {
[13:22:00.871]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:00.871]                 ...future.oldOptions$nwarnings <- NULL
[13:22:00.871]             }
[13:22:00.871]             base::options(...future.oldOptions)
[13:22:00.871]             if (.Platform$OS.type == "windows") {
[13:22:00.871]                 old_names <- names(...future.oldEnvVars)
[13:22:00.871]                 envs <- base::Sys.getenv()
[13:22:00.871]                 names <- names(envs)
[13:22:00.871]                 common <- intersect(names, old_names)
[13:22:00.871]                 added <- setdiff(names, old_names)
[13:22:00.871]                 removed <- setdiff(old_names, names)
[13:22:00.871]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:00.871]                   envs[common]]
[13:22:00.871]                 NAMES <- toupper(changed)
[13:22:00.871]                 args <- list()
[13:22:00.871]                 for (kk in seq_along(NAMES)) {
[13:22:00.871]                   name <- changed[[kk]]
[13:22:00.871]                   NAME <- NAMES[[kk]]
[13:22:00.871]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.871]                     next
[13:22:00.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:00.871]                 }
[13:22:00.871]                 NAMES <- toupper(added)
[13:22:00.871]                 for (kk in seq_along(NAMES)) {
[13:22:00.871]                   name <- added[[kk]]
[13:22:00.871]                   NAME <- NAMES[[kk]]
[13:22:00.871]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.871]                     next
[13:22:00.871]                   args[[name]] <- ""
[13:22:00.871]                 }
[13:22:00.871]                 NAMES <- toupper(removed)
[13:22:00.871]                 for (kk in seq_along(NAMES)) {
[13:22:00.871]                   name <- removed[[kk]]
[13:22:00.871]                   NAME <- NAMES[[kk]]
[13:22:00.871]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.871]                     next
[13:22:00.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:00.871]                 }
[13:22:00.871]                 if (length(args) > 0) 
[13:22:00.871]                   base::do.call(base::Sys.setenv, args = args)
[13:22:00.871]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:00.871]             }
[13:22:00.871]             else {
[13:22:00.871]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:00.871]             }
[13:22:00.871]             {
[13:22:00.871]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:00.871]                   0L) {
[13:22:00.871]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:00.871]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:00.871]                   base::options(opts)
[13:22:00.871]                 }
[13:22:00.871]                 {
[13:22:00.871]                   {
[13:22:00.871]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:00.871]                     NULL
[13:22:00.871]                   }
[13:22:00.871]                   options(future.plan = NULL)
[13:22:00.871]                   if (is.na(NA_character_)) 
[13:22:00.871]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:00.871]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:00.871]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:00.871]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:00.871]                     envir = parent.frame()) 
[13:22:00.871]                   {
[13:22:00.871]                     if (is.function(workers)) 
[13:22:00.871]                       workers <- workers()
[13:22:00.871]                     workers <- structure(as.integer(workers), 
[13:22:00.871]                       class = class(workers))
[13:22:00.871]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:00.871]                       workers >= 1)
[13:22:00.871]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:00.871]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:00.871]                     }
[13:22:00.871]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:00.871]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:00.871]                       envir = envir)
[13:22:00.871]                     if (!future$lazy) 
[13:22:00.871]                       future <- run(future)
[13:22:00.871]                     invisible(future)
[13:22:00.871]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:00.871]                 }
[13:22:00.871]             }
[13:22:00.871]         }
[13:22:00.871]     })
[13:22:00.871]     if (TRUE) {
[13:22:00.871]         base::sink(type = "output", split = FALSE)
[13:22:00.871]         if (TRUE) {
[13:22:00.871]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:00.871]         }
[13:22:00.871]         else {
[13:22:00.871]             ...future.result["stdout"] <- base::list(NULL)
[13:22:00.871]         }
[13:22:00.871]         base::close(...future.stdout)
[13:22:00.871]         ...future.stdout <- NULL
[13:22:00.871]     }
[13:22:00.871]     ...future.result$conditions <- ...future.conditions
[13:22:00.871]     ...future.result$finished <- base::Sys.time()
[13:22:00.871]     ...future.result
[13:22:00.871] }
[13:22:00.874] MultisessionFuture started
[13:22:00.874] - Launch lazy future ... done
[13:22:00.874] run() for ‘MultisessionFuture’ ... done
[13:22:00.875] resolve() on environment ...
[13:22:00.875]  recursive: 0
[13:22:00.875]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[13:22:00.896]  length: 2 (resolved future 3)
[13:22:00.907] receiveMessageFromWorker() for ClusterFuture ...
[13:22:00.907] - Validating connection of MultisessionFuture
[13:22:00.907] - received message: FutureResult
[13:22:00.907] - Received FutureResult
[13:22:00.908] - Erased future from FutureRegistry
[13:22:00.908] result() for ClusterFuture ...
[13:22:00.908] - result already collected: FutureResult
[13:22:00.908] result() for ClusterFuture ... done
[13:22:00.908] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:00.908] Future #1
[13:22:00.908]  length: 1 (resolved future 1)
[13:22:00.929] receiveMessageFromWorker() for ClusterFuture ...
[13:22:00.930] - Validating connection of MultisessionFuture
[13:22:00.930] - received message: FutureResult
[13:22:00.930] - Received FutureResult
[13:22:00.930] - Erased future from FutureRegistry
[13:22:00.930] result() for ClusterFuture ...
[13:22:00.930] - result already collected: FutureResult
[13:22:00.930] result() for ClusterFuture ... done
[13:22:00.930] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:00.931] Future #2
[13:22:00.931]  length: 0 (resolved future 2)
[13:22:00.931] resolve() on environment ... DONE
[13:22:00.931] getGlobalsAndPackages() ...
[13:22:00.931] Searching for globals...
[13:22:00.932] - globals found: [1] ‘{’
[13:22:00.932] Searching for globals ... DONE
[13:22:00.932] Resolving globals: FALSE
[13:22:00.933] 
[13:22:00.933] 
[13:22:00.933] getGlobalsAndPackages() ... DONE
[13:22:00.933] run() for ‘Future’ ...
[13:22:00.933] - state: ‘created’
[13:22:00.933] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:00.948] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:00.948] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:00.948]   - Field: ‘node’
[13:22:00.948]   - Field: ‘label’
[13:22:00.948]   - Field: ‘local’
[13:22:00.948]   - Field: ‘owner’
[13:22:00.948]   - Field: ‘envir’
[13:22:00.948]   - Field: ‘workers’
[13:22:00.949]   - Field: ‘packages’
[13:22:00.949]   - Field: ‘gc’
[13:22:00.949]   - Field: ‘conditions’
[13:22:00.949]   - Field: ‘persistent’
[13:22:00.949]   - Field: ‘expr’
[13:22:00.949]   - Field: ‘uuid’
[13:22:00.949]   - Field: ‘seed’
[13:22:00.949]   - Field: ‘version’
[13:22:00.949]   - Field: ‘result’
[13:22:00.949]   - Field: ‘asynchronous’
[13:22:00.949]   - Field: ‘calls’
[13:22:00.950]   - Field: ‘globals’
[13:22:00.950]   - Field: ‘stdout’
[13:22:00.950]   - Field: ‘earlySignal’
[13:22:00.950]   - Field: ‘lazy’
[13:22:00.950]   - Field: ‘state’
[13:22:00.950] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:00.950] - Launch lazy future ...
[13:22:00.950] Packages needed by the future expression (n = 0): <none>
[13:22:00.951] Packages needed by future strategies (n = 0): <none>
[13:22:00.951] {
[13:22:00.951]     {
[13:22:00.951]         {
[13:22:00.951]             ...future.startTime <- base::Sys.time()
[13:22:00.951]             {
[13:22:00.951]                 {
[13:22:00.951]                   {
[13:22:00.951]                     {
[13:22:00.951]                       base::local({
[13:22:00.951]                         has_future <- base::requireNamespace("future", 
[13:22:00.951]                           quietly = TRUE)
[13:22:00.951]                         if (has_future) {
[13:22:00.951]                           ns <- base::getNamespace("future")
[13:22:00.951]                           version <- ns[[".package"]][["version"]]
[13:22:00.951]                           if (is.null(version)) 
[13:22:00.951]                             version <- utils::packageVersion("future")
[13:22:00.951]                         }
[13:22:00.951]                         else {
[13:22:00.951]                           version <- NULL
[13:22:00.951]                         }
[13:22:00.951]                         if (!has_future || version < "1.8.0") {
[13:22:00.951]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:00.951]                             "", base::R.version$version.string), 
[13:22:00.951]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:00.951]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:00.951]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:00.951]                               "release", "version")], collapse = " "), 
[13:22:00.951]                             hostname = base::Sys.info()[["nodename"]])
[13:22:00.951]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:00.951]                             info)
[13:22:00.951]                           info <- base::paste(info, collapse = "; ")
[13:22:00.951]                           if (!has_future) {
[13:22:00.951]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:00.951]                               info)
[13:22:00.951]                           }
[13:22:00.951]                           else {
[13:22:00.951]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:00.951]                               info, version)
[13:22:00.951]                           }
[13:22:00.951]                           base::stop(msg)
[13:22:00.951]                         }
[13:22:00.951]                       })
[13:22:00.951]                     }
[13:22:00.951]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:00.951]                     base::options(mc.cores = 1L)
[13:22:00.951]                   }
[13:22:00.951]                   options(future.plan = NULL)
[13:22:00.951]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:00.951]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:00.951]                 }
[13:22:00.951]                 ...future.workdir <- getwd()
[13:22:00.951]             }
[13:22:00.951]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:00.951]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:00.951]         }
[13:22:00.951]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:00.951]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:00.951]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:00.951]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:00.951]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:00.951]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:00.951]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:00.951]             base::names(...future.oldOptions))
[13:22:00.951]     }
[13:22:00.951]     if (FALSE) {
[13:22:00.951]     }
[13:22:00.951]     else {
[13:22:00.951]         if (TRUE) {
[13:22:00.951]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:00.951]                 open = "w")
[13:22:00.951]         }
[13:22:00.951]         else {
[13:22:00.951]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:00.951]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:00.951]         }
[13:22:00.951]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:00.951]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:00.951]             base::sink(type = "output", split = FALSE)
[13:22:00.951]             base::close(...future.stdout)
[13:22:00.951]         }, add = TRUE)
[13:22:00.951]     }
[13:22:00.951]     ...future.frame <- base::sys.nframe()
[13:22:00.951]     ...future.conditions <- base::list()
[13:22:00.951]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:00.951]     if (FALSE) {
[13:22:00.951]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:00.951]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:00.951]     }
[13:22:00.951]     ...future.result <- base::tryCatch({
[13:22:00.951]         base::withCallingHandlers({
[13:22:00.951]             ...future.value <- base::withVisible(base::local({
[13:22:00.951]                 ...future.makeSendCondition <- local({
[13:22:00.951]                   sendCondition <- NULL
[13:22:00.951]                   function(frame = 1L) {
[13:22:00.951]                     if (is.function(sendCondition)) 
[13:22:00.951]                       return(sendCondition)
[13:22:00.951]                     ns <- getNamespace("parallel")
[13:22:00.951]                     if (exists("sendData", mode = "function", 
[13:22:00.951]                       envir = ns)) {
[13:22:00.951]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:00.951]                         envir = ns)
[13:22:00.951]                       envir <- sys.frame(frame)
[13:22:00.951]                       master <- NULL
[13:22:00.951]                       while (!identical(envir, .GlobalEnv) && 
[13:22:00.951]                         !identical(envir, emptyenv())) {
[13:22:00.951]                         if (exists("master", mode = "list", envir = envir, 
[13:22:00.951]                           inherits = FALSE)) {
[13:22:00.951]                           master <- get("master", mode = "list", 
[13:22:00.951]                             envir = envir, inherits = FALSE)
[13:22:00.951]                           if (inherits(master, c("SOCKnode", 
[13:22:00.951]                             "SOCK0node"))) {
[13:22:00.951]                             sendCondition <<- function(cond) {
[13:22:00.951]                               data <- list(type = "VALUE", value = cond, 
[13:22:00.951]                                 success = TRUE)
[13:22:00.951]                               parallel_sendData(master, data)
[13:22:00.951]                             }
[13:22:00.951]                             return(sendCondition)
[13:22:00.951]                           }
[13:22:00.951]                         }
[13:22:00.951]                         frame <- frame + 1L
[13:22:00.951]                         envir <- sys.frame(frame)
[13:22:00.951]                       }
[13:22:00.951]                     }
[13:22:00.951]                     sendCondition <<- function(cond) NULL
[13:22:00.951]                   }
[13:22:00.951]                 })
[13:22:00.951]                 withCallingHandlers({
[13:22:00.951]                   {
[13:22:00.951]                     1
[13:22:00.951]                   }
[13:22:00.951]                 }, immediateCondition = function(cond) {
[13:22:00.951]                   sendCondition <- ...future.makeSendCondition()
[13:22:00.951]                   sendCondition(cond)
[13:22:00.951]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.951]                   {
[13:22:00.951]                     inherits <- base::inherits
[13:22:00.951]                     invokeRestart <- base::invokeRestart
[13:22:00.951]                     is.null <- base::is.null
[13:22:00.951]                     muffled <- FALSE
[13:22:00.951]                     if (inherits(cond, "message")) {
[13:22:00.951]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:00.951]                       if (muffled) 
[13:22:00.951]                         invokeRestart("muffleMessage")
[13:22:00.951]                     }
[13:22:00.951]                     else if (inherits(cond, "warning")) {
[13:22:00.951]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:00.951]                       if (muffled) 
[13:22:00.951]                         invokeRestart("muffleWarning")
[13:22:00.951]                     }
[13:22:00.951]                     else if (inherits(cond, "condition")) {
[13:22:00.951]                       if (!is.null(pattern)) {
[13:22:00.951]                         computeRestarts <- base::computeRestarts
[13:22:00.951]                         grepl <- base::grepl
[13:22:00.951]                         restarts <- computeRestarts(cond)
[13:22:00.951]                         for (restart in restarts) {
[13:22:00.951]                           name <- restart$name
[13:22:00.951]                           if (is.null(name)) 
[13:22:00.951]                             next
[13:22:00.951]                           if (!grepl(pattern, name)) 
[13:22:00.951]                             next
[13:22:00.951]                           invokeRestart(restart)
[13:22:00.951]                           muffled <- TRUE
[13:22:00.951]                           break
[13:22:00.951]                         }
[13:22:00.951]                       }
[13:22:00.951]                     }
[13:22:00.951]                     invisible(muffled)
[13:22:00.951]                   }
[13:22:00.951]                   muffleCondition(cond)
[13:22:00.951]                 })
[13:22:00.951]             }))
[13:22:00.951]             future::FutureResult(value = ...future.value$value, 
[13:22:00.951]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:00.951]                   ...future.rng), globalenv = if (FALSE) 
[13:22:00.951]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:00.951]                     ...future.globalenv.names))
[13:22:00.951]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:00.951]         }, condition = base::local({
[13:22:00.951]             c <- base::c
[13:22:00.951]             inherits <- base::inherits
[13:22:00.951]             invokeRestart <- base::invokeRestart
[13:22:00.951]             length <- base::length
[13:22:00.951]             list <- base::list
[13:22:00.951]             seq.int <- base::seq.int
[13:22:00.951]             signalCondition <- base::signalCondition
[13:22:00.951]             sys.calls <- base::sys.calls
[13:22:00.951]             `[[` <- base::`[[`
[13:22:00.951]             `+` <- base::`+`
[13:22:00.951]             `<<-` <- base::`<<-`
[13:22:00.951]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:00.951]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:00.951]                   3L)]
[13:22:00.951]             }
[13:22:00.951]             function(cond) {
[13:22:00.951]                 is_error <- inherits(cond, "error")
[13:22:00.951]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:00.951]                   NULL)
[13:22:00.951]                 if (is_error) {
[13:22:00.951]                   sessionInformation <- function() {
[13:22:00.951]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:00.951]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:00.951]                       search = base::search(), system = base::Sys.info())
[13:22:00.951]                   }
[13:22:00.951]                   ...future.conditions[[length(...future.conditions) + 
[13:22:00.951]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:00.951]                     cond$call), session = sessionInformation(), 
[13:22:00.951]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:00.951]                   signalCondition(cond)
[13:22:00.951]                 }
[13:22:00.951]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:00.951]                 "immediateCondition"))) {
[13:22:00.951]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:00.951]                   ...future.conditions[[length(...future.conditions) + 
[13:22:00.951]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:00.951]                   if (TRUE && !signal) {
[13:22:00.951]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.951]                     {
[13:22:00.951]                       inherits <- base::inherits
[13:22:00.951]                       invokeRestart <- base::invokeRestart
[13:22:00.951]                       is.null <- base::is.null
[13:22:00.951]                       muffled <- FALSE
[13:22:00.951]                       if (inherits(cond, "message")) {
[13:22:00.951]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:00.951]                         if (muffled) 
[13:22:00.951]                           invokeRestart("muffleMessage")
[13:22:00.951]                       }
[13:22:00.951]                       else if (inherits(cond, "warning")) {
[13:22:00.951]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:00.951]                         if (muffled) 
[13:22:00.951]                           invokeRestart("muffleWarning")
[13:22:00.951]                       }
[13:22:00.951]                       else if (inherits(cond, "condition")) {
[13:22:00.951]                         if (!is.null(pattern)) {
[13:22:00.951]                           computeRestarts <- base::computeRestarts
[13:22:00.951]                           grepl <- base::grepl
[13:22:00.951]                           restarts <- computeRestarts(cond)
[13:22:00.951]                           for (restart in restarts) {
[13:22:00.951]                             name <- restart$name
[13:22:00.951]                             if (is.null(name)) 
[13:22:00.951]                               next
[13:22:00.951]                             if (!grepl(pattern, name)) 
[13:22:00.951]                               next
[13:22:00.951]                             invokeRestart(restart)
[13:22:00.951]                             muffled <- TRUE
[13:22:00.951]                             break
[13:22:00.951]                           }
[13:22:00.951]                         }
[13:22:00.951]                       }
[13:22:00.951]                       invisible(muffled)
[13:22:00.951]                     }
[13:22:00.951]                     muffleCondition(cond, pattern = "^muffle")
[13:22:00.951]                   }
[13:22:00.951]                 }
[13:22:00.951]                 else {
[13:22:00.951]                   if (TRUE) {
[13:22:00.951]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.951]                     {
[13:22:00.951]                       inherits <- base::inherits
[13:22:00.951]                       invokeRestart <- base::invokeRestart
[13:22:00.951]                       is.null <- base::is.null
[13:22:00.951]                       muffled <- FALSE
[13:22:00.951]                       if (inherits(cond, "message")) {
[13:22:00.951]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:00.951]                         if (muffled) 
[13:22:00.951]                           invokeRestart("muffleMessage")
[13:22:00.951]                       }
[13:22:00.951]                       else if (inherits(cond, "warning")) {
[13:22:00.951]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:00.951]                         if (muffled) 
[13:22:00.951]                           invokeRestart("muffleWarning")
[13:22:00.951]                       }
[13:22:00.951]                       else if (inherits(cond, "condition")) {
[13:22:00.951]                         if (!is.null(pattern)) {
[13:22:00.951]                           computeRestarts <- base::computeRestarts
[13:22:00.951]                           grepl <- base::grepl
[13:22:00.951]                           restarts <- computeRestarts(cond)
[13:22:00.951]                           for (restart in restarts) {
[13:22:00.951]                             name <- restart$name
[13:22:00.951]                             if (is.null(name)) 
[13:22:00.951]                               next
[13:22:00.951]                             if (!grepl(pattern, name)) 
[13:22:00.951]                               next
[13:22:00.951]                             invokeRestart(restart)
[13:22:00.951]                             muffled <- TRUE
[13:22:00.951]                             break
[13:22:00.951]                           }
[13:22:00.951]                         }
[13:22:00.951]                       }
[13:22:00.951]                       invisible(muffled)
[13:22:00.951]                     }
[13:22:00.951]                     muffleCondition(cond, pattern = "^muffle")
[13:22:00.951]                   }
[13:22:00.951]                 }
[13:22:00.951]             }
[13:22:00.951]         }))
[13:22:00.951]     }, error = function(ex) {
[13:22:00.951]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:00.951]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:00.951]                 ...future.rng), started = ...future.startTime, 
[13:22:00.951]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:00.951]             version = "1.8"), class = "FutureResult")
[13:22:00.951]     }, finally = {
[13:22:00.951]         if (!identical(...future.workdir, getwd())) 
[13:22:00.951]             setwd(...future.workdir)
[13:22:00.951]         {
[13:22:00.951]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:00.951]                 ...future.oldOptions$nwarnings <- NULL
[13:22:00.951]             }
[13:22:00.951]             base::options(...future.oldOptions)
[13:22:00.951]             if (.Platform$OS.type == "windows") {
[13:22:00.951]                 old_names <- names(...future.oldEnvVars)
[13:22:00.951]                 envs <- base::Sys.getenv()
[13:22:00.951]                 names <- names(envs)
[13:22:00.951]                 common <- intersect(names, old_names)
[13:22:00.951]                 added <- setdiff(names, old_names)
[13:22:00.951]                 removed <- setdiff(old_names, names)
[13:22:00.951]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:00.951]                   envs[common]]
[13:22:00.951]                 NAMES <- toupper(changed)
[13:22:00.951]                 args <- list()
[13:22:00.951]                 for (kk in seq_along(NAMES)) {
[13:22:00.951]                   name <- changed[[kk]]
[13:22:00.951]                   NAME <- NAMES[[kk]]
[13:22:00.951]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.951]                     next
[13:22:00.951]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:00.951]                 }
[13:22:00.951]                 NAMES <- toupper(added)
[13:22:00.951]                 for (kk in seq_along(NAMES)) {
[13:22:00.951]                   name <- added[[kk]]
[13:22:00.951]                   NAME <- NAMES[[kk]]
[13:22:00.951]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.951]                     next
[13:22:00.951]                   args[[name]] <- ""
[13:22:00.951]                 }
[13:22:00.951]                 NAMES <- toupper(removed)
[13:22:00.951]                 for (kk in seq_along(NAMES)) {
[13:22:00.951]                   name <- removed[[kk]]
[13:22:00.951]                   NAME <- NAMES[[kk]]
[13:22:00.951]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.951]                     next
[13:22:00.951]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:00.951]                 }
[13:22:00.951]                 if (length(args) > 0) 
[13:22:00.951]                   base::do.call(base::Sys.setenv, args = args)
[13:22:00.951]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:00.951]             }
[13:22:00.951]             else {
[13:22:00.951]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:00.951]             }
[13:22:00.951]             {
[13:22:00.951]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:00.951]                   0L) {
[13:22:00.951]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:00.951]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:00.951]                   base::options(opts)
[13:22:00.951]                 }
[13:22:00.951]                 {
[13:22:00.951]                   {
[13:22:00.951]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:00.951]                     NULL
[13:22:00.951]                   }
[13:22:00.951]                   options(future.plan = NULL)
[13:22:00.951]                   if (is.na(NA_character_)) 
[13:22:00.951]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:00.951]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:00.951]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:00.951]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:00.951]                     envir = parent.frame()) 
[13:22:00.951]                   {
[13:22:00.951]                     if (is.function(workers)) 
[13:22:00.951]                       workers <- workers()
[13:22:00.951]                     workers <- structure(as.integer(workers), 
[13:22:00.951]                       class = class(workers))
[13:22:00.951]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:00.951]                       workers >= 1)
[13:22:00.951]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:00.951]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:00.951]                     }
[13:22:00.951]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:00.951]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:00.951]                       envir = envir)
[13:22:00.951]                     if (!future$lazy) 
[13:22:00.951]                       future <- run(future)
[13:22:00.951]                     invisible(future)
[13:22:00.951]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:00.951]                 }
[13:22:00.951]             }
[13:22:00.951]         }
[13:22:00.951]     })
[13:22:00.951]     if (TRUE) {
[13:22:00.951]         base::sink(type = "output", split = FALSE)
[13:22:00.951]         if (TRUE) {
[13:22:00.951]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:00.951]         }
[13:22:00.951]         else {
[13:22:00.951]             ...future.result["stdout"] <- base::list(NULL)
[13:22:00.951]         }
[13:22:00.951]         base::close(...future.stdout)
[13:22:00.951]         ...future.stdout <- NULL
[13:22:00.951]     }
[13:22:00.951]     ...future.result$conditions <- ...future.conditions
[13:22:00.951]     ...future.result$finished <- base::Sys.time()
[13:22:00.951]     ...future.result
[13:22:00.951] }
[13:22:00.954] MultisessionFuture started
[13:22:00.955] - Launch lazy future ... done
[13:22:00.955] run() for ‘MultisessionFuture’ ... done
[13:22:00.955] getGlobalsAndPackages() ...
[13:22:00.955] Searching for globals...
[13:22:00.956] - globals found: [1] ‘{’
[13:22:00.956] Searching for globals ... DONE
[13:22:00.956] Resolving globals: FALSE
[13:22:00.956] 
[13:22:00.956] 
[13:22:00.956] getGlobalsAndPackages() ... DONE
[13:22:00.957] run() for ‘Future’ ...
[13:22:00.957] - state: ‘created’
[13:22:00.957] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:00.972] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:00.972] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:00.972]   - Field: ‘node’
[13:22:00.972]   - Field: ‘label’
[13:22:00.972]   - Field: ‘local’
[13:22:00.972]   - Field: ‘owner’
[13:22:00.973]   - Field: ‘envir’
[13:22:00.973]   - Field: ‘workers’
[13:22:00.973]   - Field: ‘packages’
[13:22:00.973]   - Field: ‘gc’
[13:22:00.973]   - Field: ‘conditions’
[13:22:00.973]   - Field: ‘persistent’
[13:22:00.973]   - Field: ‘expr’
[13:22:00.973]   - Field: ‘uuid’
[13:22:00.973]   - Field: ‘seed’
[13:22:00.973]   - Field: ‘version’
[13:22:00.974]   - Field: ‘result’
[13:22:00.974]   - Field: ‘asynchronous’
[13:22:00.974]   - Field: ‘calls’
[13:22:00.974]   - Field: ‘globals’
[13:22:00.974]   - Field: ‘stdout’
[13:22:00.974]   - Field: ‘earlySignal’
[13:22:00.974]   - Field: ‘lazy’
[13:22:00.974]   - Field: ‘state’
[13:22:00.974] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:00.974] - Launch lazy future ...
[13:22:00.975] Packages needed by the future expression (n = 0): <none>
[13:22:00.975] Packages needed by future strategies (n = 0): <none>
[13:22:00.975] {
[13:22:00.975]     {
[13:22:00.975]         {
[13:22:00.975]             ...future.startTime <- base::Sys.time()
[13:22:00.975]             {
[13:22:00.975]                 {
[13:22:00.975]                   {
[13:22:00.975]                     {
[13:22:00.975]                       base::local({
[13:22:00.975]                         has_future <- base::requireNamespace("future", 
[13:22:00.975]                           quietly = TRUE)
[13:22:00.975]                         if (has_future) {
[13:22:00.975]                           ns <- base::getNamespace("future")
[13:22:00.975]                           version <- ns[[".package"]][["version"]]
[13:22:00.975]                           if (is.null(version)) 
[13:22:00.975]                             version <- utils::packageVersion("future")
[13:22:00.975]                         }
[13:22:00.975]                         else {
[13:22:00.975]                           version <- NULL
[13:22:00.975]                         }
[13:22:00.975]                         if (!has_future || version < "1.8.0") {
[13:22:00.975]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:00.975]                             "", base::R.version$version.string), 
[13:22:00.975]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:00.975]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:00.975]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:00.975]                               "release", "version")], collapse = " "), 
[13:22:00.975]                             hostname = base::Sys.info()[["nodename"]])
[13:22:00.975]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:00.975]                             info)
[13:22:00.975]                           info <- base::paste(info, collapse = "; ")
[13:22:00.975]                           if (!has_future) {
[13:22:00.975]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:00.975]                               info)
[13:22:00.975]                           }
[13:22:00.975]                           else {
[13:22:00.975]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:00.975]                               info, version)
[13:22:00.975]                           }
[13:22:00.975]                           base::stop(msg)
[13:22:00.975]                         }
[13:22:00.975]                       })
[13:22:00.975]                     }
[13:22:00.975]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:00.975]                     base::options(mc.cores = 1L)
[13:22:00.975]                   }
[13:22:00.975]                   options(future.plan = NULL)
[13:22:00.975]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:00.975]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:00.975]                 }
[13:22:00.975]                 ...future.workdir <- getwd()
[13:22:00.975]             }
[13:22:00.975]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:00.975]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:00.975]         }
[13:22:00.975]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:00.975]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:00.975]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:00.975]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:00.975]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:00.975]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:00.975]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:00.975]             base::names(...future.oldOptions))
[13:22:00.975]     }
[13:22:00.975]     if (FALSE) {
[13:22:00.975]     }
[13:22:00.975]     else {
[13:22:00.975]         if (TRUE) {
[13:22:00.975]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:00.975]                 open = "w")
[13:22:00.975]         }
[13:22:00.975]         else {
[13:22:00.975]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:00.975]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:00.975]         }
[13:22:00.975]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:00.975]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:00.975]             base::sink(type = "output", split = FALSE)
[13:22:00.975]             base::close(...future.stdout)
[13:22:00.975]         }, add = TRUE)
[13:22:00.975]     }
[13:22:00.975]     ...future.frame <- base::sys.nframe()
[13:22:00.975]     ...future.conditions <- base::list()
[13:22:00.975]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:00.975]     if (FALSE) {
[13:22:00.975]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:00.975]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:00.975]     }
[13:22:00.975]     ...future.result <- base::tryCatch({
[13:22:00.975]         base::withCallingHandlers({
[13:22:00.975]             ...future.value <- base::withVisible(base::local({
[13:22:00.975]                 ...future.makeSendCondition <- local({
[13:22:00.975]                   sendCondition <- NULL
[13:22:00.975]                   function(frame = 1L) {
[13:22:00.975]                     if (is.function(sendCondition)) 
[13:22:00.975]                       return(sendCondition)
[13:22:00.975]                     ns <- getNamespace("parallel")
[13:22:00.975]                     if (exists("sendData", mode = "function", 
[13:22:00.975]                       envir = ns)) {
[13:22:00.975]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:00.975]                         envir = ns)
[13:22:00.975]                       envir <- sys.frame(frame)
[13:22:00.975]                       master <- NULL
[13:22:00.975]                       while (!identical(envir, .GlobalEnv) && 
[13:22:00.975]                         !identical(envir, emptyenv())) {
[13:22:00.975]                         if (exists("master", mode = "list", envir = envir, 
[13:22:00.975]                           inherits = FALSE)) {
[13:22:00.975]                           master <- get("master", mode = "list", 
[13:22:00.975]                             envir = envir, inherits = FALSE)
[13:22:00.975]                           if (inherits(master, c("SOCKnode", 
[13:22:00.975]                             "SOCK0node"))) {
[13:22:00.975]                             sendCondition <<- function(cond) {
[13:22:00.975]                               data <- list(type = "VALUE", value = cond, 
[13:22:00.975]                                 success = TRUE)
[13:22:00.975]                               parallel_sendData(master, data)
[13:22:00.975]                             }
[13:22:00.975]                             return(sendCondition)
[13:22:00.975]                           }
[13:22:00.975]                         }
[13:22:00.975]                         frame <- frame + 1L
[13:22:00.975]                         envir <- sys.frame(frame)
[13:22:00.975]                       }
[13:22:00.975]                     }
[13:22:00.975]                     sendCondition <<- function(cond) NULL
[13:22:00.975]                   }
[13:22:00.975]                 })
[13:22:00.975]                 withCallingHandlers({
[13:22:00.975]                   {
[13:22:00.975]                     2
[13:22:00.975]                   }
[13:22:00.975]                 }, immediateCondition = function(cond) {
[13:22:00.975]                   sendCondition <- ...future.makeSendCondition()
[13:22:00.975]                   sendCondition(cond)
[13:22:00.975]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.975]                   {
[13:22:00.975]                     inherits <- base::inherits
[13:22:00.975]                     invokeRestart <- base::invokeRestart
[13:22:00.975]                     is.null <- base::is.null
[13:22:00.975]                     muffled <- FALSE
[13:22:00.975]                     if (inherits(cond, "message")) {
[13:22:00.975]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:00.975]                       if (muffled) 
[13:22:00.975]                         invokeRestart("muffleMessage")
[13:22:00.975]                     }
[13:22:00.975]                     else if (inherits(cond, "warning")) {
[13:22:00.975]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:00.975]                       if (muffled) 
[13:22:00.975]                         invokeRestart("muffleWarning")
[13:22:00.975]                     }
[13:22:00.975]                     else if (inherits(cond, "condition")) {
[13:22:00.975]                       if (!is.null(pattern)) {
[13:22:00.975]                         computeRestarts <- base::computeRestarts
[13:22:00.975]                         grepl <- base::grepl
[13:22:00.975]                         restarts <- computeRestarts(cond)
[13:22:00.975]                         for (restart in restarts) {
[13:22:00.975]                           name <- restart$name
[13:22:00.975]                           if (is.null(name)) 
[13:22:00.975]                             next
[13:22:00.975]                           if (!grepl(pattern, name)) 
[13:22:00.975]                             next
[13:22:00.975]                           invokeRestart(restart)
[13:22:00.975]                           muffled <- TRUE
[13:22:00.975]                           break
[13:22:00.975]                         }
[13:22:00.975]                       }
[13:22:00.975]                     }
[13:22:00.975]                     invisible(muffled)
[13:22:00.975]                   }
[13:22:00.975]                   muffleCondition(cond)
[13:22:00.975]                 })
[13:22:00.975]             }))
[13:22:00.975]             future::FutureResult(value = ...future.value$value, 
[13:22:00.975]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:00.975]                   ...future.rng), globalenv = if (FALSE) 
[13:22:00.975]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:00.975]                     ...future.globalenv.names))
[13:22:00.975]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:00.975]         }, condition = base::local({
[13:22:00.975]             c <- base::c
[13:22:00.975]             inherits <- base::inherits
[13:22:00.975]             invokeRestart <- base::invokeRestart
[13:22:00.975]             length <- base::length
[13:22:00.975]             list <- base::list
[13:22:00.975]             seq.int <- base::seq.int
[13:22:00.975]             signalCondition <- base::signalCondition
[13:22:00.975]             sys.calls <- base::sys.calls
[13:22:00.975]             `[[` <- base::`[[`
[13:22:00.975]             `+` <- base::`+`
[13:22:00.975]             `<<-` <- base::`<<-`
[13:22:00.975]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:00.975]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:00.975]                   3L)]
[13:22:00.975]             }
[13:22:00.975]             function(cond) {
[13:22:00.975]                 is_error <- inherits(cond, "error")
[13:22:00.975]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:00.975]                   NULL)
[13:22:00.975]                 if (is_error) {
[13:22:00.975]                   sessionInformation <- function() {
[13:22:00.975]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:00.975]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:00.975]                       search = base::search(), system = base::Sys.info())
[13:22:00.975]                   }
[13:22:00.975]                   ...future.conditions[[length(...future.conditions) + 
[13:22:00.975]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:00.975]                     cond$call), session = sessionInformation(), 
[13:22:00.975]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:00.975]                   signalCondition(cond)
[13:22:00.975]                 }
[13:22:00.975]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:00.975]                 "immediateCondition"))) {
[13:22:00.975]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:00.975]                   ...future.conditions[[length(...future.conditions) + 
[13:22:00.975]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:00.975]                   if (TRUE && !signal) {
[13:22:00.975]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.975]                     {
[13:22:00.975]                       inherits <- base::inherits
[13:22:00.975]                       invokeRestart <- base::invokeRestart
[13:22:00.975]                       is.null <- base::is.null
[13:22:00.975]                       muffled <- FALSE
[13:22:00.975]                       if (inherits(cond, "message")) {
[13:22:00.975]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:00.975]                         if (muffled) 
[13:22:00.975]                           invokeRestart("muffleMessage")
[13:22:00.975]                       }
[13:22:00.975]                       else if (inherits(cond, "warning")) {
[13:22:00.975]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:00.975]                         if (muffled) 
[13:22:00.975]                           invokeRestart("muffleWarning")
[13:22:00.975]                       }
[13:22:00.975]                       else if (inherits(cond, "condition")) {
[13:22:00.975]                         if (!is.null(pattern)) {
[13:22:00.975]                           computeRestarts <- base::computeRestarts
[13:22:00.975]                           grepl <- base::grepl
[13:22:00.975]                           restarts <- computeRestarts(cond)
[13:22:00.975]                           for (restart in restarts) {
[13:22:00.975]                             name <- restart$name
[13:22:00.975]                             if (is.null(name)) 
[13:22:00.975]                               next
[13:22:00.975]                             if (!grepl(pattern, name)) 
[13:22:00.975]                               next
[13:22:00.975]                             invokeRestart(restart)
[13:22:00.975]                             muffled <- TRUE
[13:22:00.975]                             break
[13:22:00.975]                           }
[13:22:00.975]                         }
[13:22:00.975]                       }
[13:22:00.975]                       invisible(muffled)
[13:22:00.975]                     }
[13:22:00.975]                     muffleCondition(cond, pattern = "^muffle")
[13:22:00.975]                   }
[13:22:00.975]                 }
[13:22:00.975]                 else {
[13:22:00.975]                   if (TRUE) {
[13:22:00.975]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:00.975]                     {
[13:22:00.975]                       inherits <- base::inherits
[13:22:00.975]                       invokeRestart <- base::invokeRestart
[13:22:00.975]                       is.null <- base::is.null
[13:22:00.975]                       muffled <- FALSE
[13:22:00.975]                       if (inherits(cond, "message")) {
[13:22:00.975]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:00.975]                         if (muffled) 
[13:22:00.975]                           invokeRestart("muffleMessage")
[13:22:00.975]                       }
[13:22:00.975]                       else if (inherits(cond, "warning")) {
[13:22:00.975]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:00.975]                         if (muffled) 
[13:22:00.975]                           invokeRestart("muffleWarning")
[13:22:00.975]                       }
[13:22:00.975]                       else if (inherits(cond, "condition")) {
[13:22:00.975]                         if (!is.null(pattern)) {
[13:22:00.975]                           computeRestarts <- base::computeRestarts
[13:22:00.975]                           grepl <- base::grepl
[13:22:00.975]                           restarts <- computeRestarts(cond)
[13:22:00.975]                           for (restart in restarts) {
[13:22:00.975]                             name <- restart$name
[13:22:00.975]                             if (is.null(name)) 
[13:22:00.975]                               next
[13:22:00.975]                             if (!grepl(pattern, name)) 
[13:22:00.975]                               next
[13:22:00.975]                             invokeRestart(restart)
[13:22:00.975]                             muffled <- TRUE
[13:22:00.975]                             break
[13:22:00.975]                           }
[13:22:00.975]                         }
[13:22:00.975]                       }
[13:22:00.975]                       invisible(muffled)
[13:22:00.975]                     }
[13:22:00.975]                     muffleCondition(cond, pattern = "^muffle")
[13:22:00.975]                   }
[13:22:00.975]                 }
[13:22:00.975]             }
[13:22:00.975]         }))
[13:22:00.975]     }, error = function(ex) {
[13:22:00.975]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:00.975]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:00.975]                 ...future.rng), started = ...future.startTime, 
[13:22:00.975]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:00.975]             version = "1.8"), class = "FutureResult")
[13:22:00.975]     }, finally = {
[13:22:00.975]         if (!identical(...future.workdir, getwd())) 
[13:22:00.975]             setwd(...future.workdir)
[13:22:00.975]         {
[13:22:00.975]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:00.975]                 ...future.oldOptions$nwarnings <- NULL
[13:22:00.975]             }
[13:22:00.975]             base::options(...future.oldOptions)
[13:22:00.975]             if (.Platform$OS.type == "windows") {
[13:22:00.975]                 old_names <- names(...future.oldEnvVars)
[13:22:00.975]                 envs <- base::Sys.getenv()
[13:22:00.975]                 names <- names(envs)
[13:22:00.975]                 common <- intersect(names, old_names)
[13:22:00.975]                 added <- setdiff(names, old_names)
[13:22:00.975]                 removed <- setdiff(old_names, names)
[13:22:00.975]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:00.975]                   envs[common]]
[13:22:00.975]                 NAMES <- toupper(changed)
[13:22:00.975]                 args <- list()
[13:22:00.975]                 for (kk in seq_along(NAMES)) {
[13:22:00.975]                   name <- changed[[kk]]
[13:22:00.975]                   NAME <- NAMES[[kk]]
[13:22:00.975]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.975]                     next
[13:22:00.975]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:00.975]                 }
[13:22:00.975]                 NAMES <- toupper(added)
[13:22:00.975]                 for (kk in seq_along(NAMES)) {
[13:22:00.975]                   name <- added[[kk]]
[13:22:00.975]                   NAME <- NAMES[[kk]]
[13:22:00.975]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.975]                     next
[13:22:00.975]                   args[[name]] <- ""
[13:22:00.975]                 }
[13:22:00.975]                 NAMES <- toupper(removed)
[13:22:00.975]                 for (kk in seq_along(NAMES)) {
[13:22:00.975]                   name <- removed[[kk]]
[13:22:00.975]                   NAME <- NAMES[[kk]]
[13:22:00.975]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:00.975]                     next
[13:22:00.975]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:00.975]                 }
[13:22:00.975]                 if (length(args) > 0) 
[13:22:00.975]                   base::do.call(base::Sys.setenv, args = args)
[13:22:00.975]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:00.975]             }
[13:22:00.975]             else {
[13:22:00.975]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:00.975]             }
[13:22:00.975]             {
[13:22:00.975]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:00.975]                   0L) {
[13:22:00.975]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:00.975]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:00.975]                   base::options(opts)
[13:22:00.975]                 }
[13:22:00.975]                 {
[13:22:00.975]                   {
[13:22:00.975]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:00.975]                     NULL
[13:22:00.975]                   }
[13:22:00.975]                   options(future.plan = NULL)
[13:22:00.975]                   if (is.na(NA_character_)) 
[13:22:00.975]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:00.975]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:00.975]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:00.975]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:00.975]                     envir = parent.frame()) 
[13:22:00.975]                   {
[13:22:00.975]                     if (is.function(workers)) 
[13:22:00.975]                       workers <- workers()
[13:22:00.975]                     workers <- structure(as.integer(workers), 
[13:22:00.975]                       class = class(workers))
[13:22:00.975]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:00.975]                       workers >= 1)
[13:22:00.975]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:00.975]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:00.975]                     }
[13:22:00.975]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:00.975]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:00.975]                       envir = envir)
[13:22:00.975]                     if (!future$lazy) 
[13:22:00.975]                       future <- run(future)
[13:22:00.975]                     invisible(future)
[13:22:00.975]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:00.975]                 }
[13:22:00.975]             }
[13:22:00.975]         }
[13:22:00.975]     })
[13:22:00.975]     if (TRUE) {
[13:22:00.975]         base::sink(type = "output", split = FALSE)
[13:22:00.975]         if (TRUE) {
[13:22:00.975]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:00.975]         }
[13:22:00.975]         else {
[13:22:00.975]             ...future.result["stdout"] <- base::list(NULL)
[13:22:00.975]         }
[13:22:00.975]         base::close(...future.stdout)
[13:22:00.975]         ...future.stdout <- NULL
[13:22:00.975]     }
[13:22:00.975]     ...future.result$conditions <- ...future.conditions
[13:22:00.975]     ...future.result$finished <- base::Sys.time()
[13:22:00.975]     ...future.result
[13:22:00.975] }
[13:22:00.979] MultisessionFuture started
[13:22:00.979] - Launch lazy future ... done
[13:22:00.979] run() for ‘MultisessionFuture’ ... done
[13:22:00.980] resolve() on environment ...
[13:22:00.980]  recursive: 0
[13:22:00.980]  elements: [3] ‘a’
[13:22:01.001]  length: 2 (resolved future 3)
[13:22:01.012] receiveMessageFromWorker() for ClusterFuture ...
[13:22:01.012] - Validating connection of MultisessionFuture
[13:22:01.013] - received message: FutureResult
[13:22:01.013] - Received FutureResult
[13:22:01.013] - Erased future from FutureRegistry
[13:22:01.013] result() for ClusterFuture ...
[13:22:01.013] - result already collected: FutureResult
[13:22:01.013] result() for ClusterFuture ... done
[13:22:01.013] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:01.013] Future #1
[13:22:01.013]  length: 1 (resolved future 1)
[13:22:01.034] receiveMessageFromWorker() for ClusterFuture ...
[13:22:01.035] - Validating connection of MultisessionFuture
[13:22:01.035] - received message: FutureResult
[13:22:01.035] - Received FutureResult
[13:22:01.035] - Erased future from FutureRegistry
[13:22:01.035] result() for ClusterFuture ...
[13:22:01.035] - result already collected: FutureResult
[13:22:01.035] result() for ClusterFuture ... done
[13:22:01.036] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:01.036] Future #2
[13:22:01.036]  length: 0 (resolved future 2)
[13:22:01.036] resolve() on environment ... DONE
[13:22:01.036] resolve() on environment ...
[13:22:01.037]  recursive: 0
[13:22:01.037]  elements: [3] ‘b’
[13:22:01.037] Future #1
[13:22:01.037]  length: 2 (resolved future 1)
[13:22:01.037] Future #2
[13:22:01.037]  length: 1 (resolved future 2)
[13:22:01.038]  length: 0 (resolved future 3)
[13:22:01.041] resolve() on environment ... DONE
[13:22:01.041] resolve() on environment ...
[13:22:01.041]  recursive: 0
[13:22:01.042]  elements: [3] ‘c’
[13:22:01.042] Future #1
[13:22:01.042]  length: 2 (resolved future 1)
[13:22:01.042] Future #2
[13:22:01.042]  length: 1 (resolved future 2)
[13:22:01.042]  length: 0 (resolved future 3)
[13:22:01.043] resolve() on environment ... DONE
[13:22:01.043] resolve() on environment ...
[13:22:01.043]  recursive: 0
[13:22:01.044]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[13:22:01.044] Future #1
[13:22:01.044] result() for ClusterFuture ...
[13:22:01.044] - result already collected: FutureResult
[13:22:01.044] result() for ClusterFuture ... done
[13:22:01.044] result() for ClusterFuture ...
[13:22:01.044] - result already collected: FutureResult
[13:22:01.044] result() for ClusterFuture ... done
[13:22:01.044]  length: 2 (resolved future 1)
[13:22:01.044] Future #2
[13:22:01.045] result() for ClusterFuture ...
[13:22:01.045] - result already collected: FutureResult
[13:22:01.045] result() for ClusterFuture ... done
[13:22:01.045] result() for ClusterFuture ...
[13:22:01.045] - result already collected: FutureResult
[13:22:01.045] result() for ClusterFuture ... done
[13:22:01.045]  length: 1 (resolved future 2)
[13:22:01.045]  length: 0 (resolved future 3)
[13:22:01.045] resolve() on environment ... DONE
[13:22:01.046] resolve() on environment ...
[13:22:01.046]  recursive: 99
[13:22:01.046]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[13:22:01.046] Future #1
[13:22:01.046] result() for ClusterFuture ...
[13:22:01.047] - result already collected: FutureResult
[13:22:01.047] result() for ClusterFuture ... done
[13:22:01.047] result() for ClusterFuture ...
[13:22:01.047] - result already collected: FutureResult
[13:22:01.047] result() for ClusterFuture ... done
[13:22:01.047] A MultisessionFuture was resolved
[13:22:01.047]  length: 2 (resolved future 1)
[13:22:01.047] Future #2
[13:22:01.047] result() for ClusterFuture ...
[13:22:01.047] - result already collected: FutureResult
[13:22:01.048] result() for ClusterFuture ... done
[13:22:01.048] result() for ClusterFuture ...
[13:22:01.048] - result already collected: FutureResult
[13:22:01.048] result() for ClusterFuture ... done
[13:22:01.048] A MultisessionFuture was resolved
[13:22:01.048]  length: 1 (resolved future 2)
[13:22:01.048]  length: 0 (resolved future 3)
[13:22:01.048] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[13:22:01.049] resolve() on list environment ...
[13:22:01.049]  recursive: 0
[13:22:01.049]  length: 2
[13:22:01.050]  elements: ‘a’, ‘b’
[13:22:01.050]  length: 1 (resolved future 1)
[13:22:01.050]  length: 0 (resolved future 2)
[13:22:01.050] resolve() on list environment ... DONE
[13:22:01.050] getGlobalsAndPackages() ...
[13:22:01.050] Searching for globals...
[13:22:01.050] 
[13:22:01.051] Searching for globals ... DONE
[13:22:01.051] - globals: [0] <none>
[13:22:01.051] getGlobalsAndPackages() ... DONE
[13:22:01.051] run() for ‘Future’ ...
[13:22:01.051] - state: ‘created’
[13:22:01.051] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:01.066] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:01.066] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:01.066]   - Field: ‘node’
[13:22:01.066]   - Field: ‘label’
[13:22:01.066]   - Field: ‘local’
[13:22:01.066]   - Field: ‘owner’
[13:22:01.067]   - Field: ‘envir’
[13:22:01.067]   - Field: ‘workers’
[13:22:01.067]   - Field: ‘packages’
[13:22:01.067]   - Field: ‘gc’
[13:22:01.067]   - Field: ‘conditions’
[13:22:01.067]   - Field: ‘persistent’
[13:22:01.067]   - Field: ‘expr’
[13:22:01.067]   - Field: ‘uuid’
[13:22:01.067]   - Field: ‘seed’
[13:22:01.067]   - Field: ‘version’
[13:22:01.067]   - Field: ‘result’
[13:22:01.068]   - Field: ‘asynchronous’
[13:22:01.068]   - Field: ‘calls’
[13:22:01.068]   - Field: ‘globals’
[13:22:01.068]   - Field: ‘stdout’
[13:22:01.068]   - Field: ‘earlySignal’
[13:22:01.068]   - Field: ‘lazy’
[13:22:01.068]   - Field: ‘state’
[13:22:01.068] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:01.068] - Launch lazy future ...
[13:22:01.069] Packages needed by the future expression (n = 0): <none>
[13:22:01.069] Packages needed by future strategies (n = 0): <none>
[13:22:01.069] {
[13:22:01.069]     {
[13:22:01.069]         {
[13:22:01.069]             ...future.startTime <- base::Sys.time()
[13:22:01.069]             {
[13:22:01.069]                 {
[13:22:01.069]                   {
[13:22:01.069]                     {
[13:22:01.069]                       base::local({
[13:22:01.069]                         has_future <- base::requireNamespace("future", 
[13:22:01.069]                           quietly = TRUE)
[13:22:01.069]                         if (has_future) {
[13:22:01.069]                           ns <- base::getNamespace("future")
[13:22:01.069]                           version <- ns[[".package"]][["version"]]
[13:22:01.069]                           if (is.null(version)) 
[13:22:01.069]                             version <- utils::packageVersion("future")
[13:22:01.069]                         }
[13:22:01.069]                         else {
[13:22:01.069]                           version <- NULL
[13:22:01.069]                         }
[13:22:01.069]                         if (!has_future || version < "1.8.0") {
[13:22:01.069]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:01.069]                             "", base::R.version$version.string), 
[13:22:01.069]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:01.069]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:01.069]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:01.069]                               "release", "version")], collapse = " "), 
[13:22:01.069]                             hostname = base::Sys.info()[["nodename"]])
[13:22:01.069]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:01.069]                             info)
[13:22:01.069]                           info <- base::paste(info, collapse = "; ")
[13:22:01.069]                           if (!has_future) {
[13:22:01.069]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:01.069]                               info)
[13:22:01.069]                           }
[13:22:01.069]                           else {
[13:22:01.069]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:01.069]                               info, version)
[13:22:01.069]                           }
[13:22:01.069]                           base::stop(msg)
[13:22:01.069]                         }
[13:22:01.069]                       })
[13:22:01.069]                     }
[13:22:01.069]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:01.069]                     base::options(mc.cores = 1L)
[13:22:01.069]                   }
[13:22:01.069]                   options(future.plan = NULL)
[13:22:01.069]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:01.069]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:01.069]                 }
[13:22:01.069]                 ...future.workdir <- getwd()
[13:22:01.069]             }
[13:22:01.069]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:01.069]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:01.069]         }
[13:22:01.069]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:01.069]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:01.069]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:01.069]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:01.069]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:01.069]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:01.069]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:01.069]             base::names(...future.oldOptions))
[13:22:01.069]     }
[13:22:01.069]     if (FALSE) {
[13:22:01.069]     }
[13:22:01.069]     else {
[13:22:01.069]         if (TRUE) {
[13:22:01.069]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:01.069]                 open = "w")
[13:22:01.069]         }
[13:22:01.069]         else {
[13:22:01.069]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:01.069]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:01.069]         }
[13:22:01.069]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:01.069]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:01.069]             base::sink(type = "output", split = FALSE)
[13:22:01.069]             base::close(...future.stdout)
[13:22:01.069]         }, add = TRUE)
[13:22:01.069]     }
[13:22:01.069]     ...future.frame <- base::sys.nframe()
[13:22:01.069]     ...future.conditions <- base::list()
[13:22:01.069]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:01.069]     if (FALSE) {
[13:22:01.069]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:01.069]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:01.069]     }
[13:22:01.069]     ...future.result <- base::tryCatch({
[13:22:01.069]         base::withCallingHandlers({
[13:22:01.069]             ...future.value <- base::withVisible(base::local({
[13:22:01.069]                 ...future.makeSendCondition <- local({
[13:22:01.069]                   sendCondition <- NULL
[13:22:01.069]                   function(frame = 1L) {
[13:22:01.069]                     if (is.function(sendCondition)) 
[13:22:01.069]                       return(sendCondition)
[13:22:01.069]                     ns <- getNamespace("parallel")
[13:22:01.069]                     if (exists("sendData", mode = "function", 
[13:22:01.069]                       envir = ns)) {
[13:22:01.069]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:01.069]                         envir = ns)
[13:22:01.069]                       envir <- sys.frame(frame)
[13:22:01.069]                       master <- NULL
[13:22:01.069]                       while (!identical(envir, .GlobalEnv) && 
[13:22:01.069]                         !identical(envir, emptyenv())) {
[13:22:01.069]                         if (exists("master", mode = "list", envir = envir, 
[13:22:01.069]                           inherits = FALSE)) {
[13:22:01.069]                           master <- get("master", mode = "list", 
[13:22:01.069]                             envir = envir, inherits = FALSE)
[13:22:01.069]                           if (inherits(master, c("SOCKnode", 
[13:22:01.069]                             "SOCK0node"))) {
[13:22:01.069]                             sendCondition <<- function(cond) {
[13:22:01.069]                               data <- list(type = "VALUE", value = cond, 
[13:22:01.069]                                 success = TRUE)
[13:22:01.069]                               parallel_sendData(master, data)
[13:22:01.069]                             }
[13:22:01.069]                             return(sendCondition)
[13:22:01.069]                           }
[13:22:01.069]                         }
[13:22:01.069]                         frame <- frame + 1L
[13:22:01.069]                         envir <- sys.frame(frame)
[13:22:01.069]                       }
[13:22:01.069]                     }
[13:22:01.069]                     sendCondition <<- function(cond) NULL
[13:22:01.069]                   }
[13:22:01.069]                 })
[13:22:01.069]                 withCallingHandlers({
[13:22:01.069]                   1
[13:22:01.069]                 }, immediateCondition = function(cond) {
[13:22:01.069]                   sendCondition <- ...future.makeSendCondition()
[13:22:01.069]                   sendCondition(cond)
[13:22:01.069]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:01.069]                   {
[13:22:01.069]                     inherits <- base::inherits
[13:22:01.069]                     invokeRestart <- base::invokeRestart
[13:22:01.069]                     is.null <- base::is.null
[13:22:01.069]                     muffled <- FALSE
[13:22:01.069]                     if (inherits(cond, "message")) {
[13:22:01.069]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:01.069]                       if (muffled) 
[13:22:01.069]                         invokeRestart("muffleMessage")
[13:22:01.069]                     }
[13:22:01.069]                     else if (inherits(cond, "warning")) {
[13:22:01.069]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:01.069]                       if (muffled) 
[13:22:01.069]                         invokeRestart("muffleWarning")
[13:22:01.069]                     }
[13:22:01.069]                     else if (inherits(cond, "condition")) {
[13:22:01.069]                       if (!is.null(pattern)) {
[13:22:01.069]                         computeRestarts <- base::computeRestarts
[13:22:01.069]                         grepl <- base::grepl
[13:22:01.069]                         restarts <- computeRestarts(cond)
[13:22:01.069]                         for (restart in restarts) {
[13:22:01.069]                           name <- restart$name
[13:22:01.069]                           if (is.null(name)) 
[13:22:01.069]                             next
[13:22:01.069]                           if (!grepl(pattern, name)) 
[13:22:01.069]                             next
[13:22:01.069]                           invokeRestart(restart)
[13:22:01.069]                           muffled <- TRUE
[13:22:01.069]                           break
[13:22:01.069]                         }
[13:22:01.069]                       }
[13:22:01.069]                     }
[13:22:01.069]                     invisible(muffled)
[13:22:01.069]                   }
[13:22:01.069]                   muffleCondition(cond)
[13:22:01.069]                 })
[13:22:01.069]             }))
[13:22:01.069]             future::FutureResult(value = ...future.value$value, 
[13:22:01.069]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:01.069]                   ...future.rng), globalenv = if (FALSE) 
[13:22:01.069]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:01.069]                     ...future.globalenv.names))
[13:22:01.069]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:01.069]         }, condition = base::local({
[13:22:01.069]             c <- base::c
[13:22:01.069]             inherits <- base::inherits
[13:22:01.069]             invokeRestart <- base::invokeRestart
[13:22:01.069]             length <- base::length
[13:22:01.069]             list <- base::list
[13:22:01.069]             seq.int <- base::seq.int
[13:22:01.069]             signalCondition <- base::signalCondition
[13:22:01.069]             sys.calls <- base::sys.calls
[13:22:01.069]             `[[` <- base::`[[`
[13:22:01.069]             `+` <- base::`+`
[13:22:01.069]             `<<-` <- base::`<<-`
[13:22:01.069]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:01.069]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:01.069]                   3L)]
[13:22:01.069]             }
[13:22:01.069]             function(cond) {
[13:22:01.069]                 is_error <- inherits(cond, "error")
[13:22:01.069]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:01.069]                   NULL)
[13:22:01.069]                 if (is_error) {
[13:22:01.069]                   sessionInformation <- function() {
[13:22:01.069]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:01.069]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:01.069]                       search = base::search(), system = base::Sys.info())
[13:22:01.069]                   }
[13:22:01.069]                   ...future.conditions[[length(...future.conditions) + 
[13:22:01.069]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:01.069]                     cond$call), session = sessionInformation(), 
[13:22:01.069]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:01.069]                   signalCondition(cond)
[13:22:01.069]                 }
[13:22:01.069]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:01.069]                 "immediateCondition"))) {
[13:22:01.069]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:01.069]                   ...future.conditions[[length(...future.conditions) + 
[13:22:01.069]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:01.069]                   if (TRUE && !signal) {
[13:22:01.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:01.069]                     {
[13:22:01.069]                       inherits <- base::inherits
[13:22:01.069]                       invokeRestart <- base::invokeRestart
[13:22:01.069]                       is.null <- base::is.null
[13:22:01.069]                       muffled <- FALSE
[13:22:01.069]                       if (inherits(cond, "message")) {
[13:22:01.069]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:01.069]                         if (muffled) 
[13:22:01.069]                           invokeRestart("muffleMessage")
[13:22:01.069]                       }
[13:22:01.069]                       else if (inherits(cond, "warning")) {
[13:22:01.069]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:01.069]                         if (muffled) 
[13:22:01.069]                           invokeRestart("muffleWarning")
[13:22:01.069]                       }
[13:22:01.069]                       else if (inherits(cond, "condition")) {
[13:22:01.069]                         if (!is.null(pattern)) {
[13:22:01.069]                           computeRestarts <- base::computeRestarts
[13:22:01.069]                           grepl <- base::grepl
[13:22:01.069]                           restarts <- computeRestarts(cond)
[13:22:01.069]                           for (restart in restarts) {
[13:22:01.069]                             name <- restart$name
[13:22:01.069]                             if (is.null(name)) 
[13:22:01.069]                               next
[13:22:01.069]                             if (!grepl(pattern, name)) 
[13:22:01.069]                               next
[13:22:01.069]                             invokeRestart(restart)
[13:22:01.069]                             muffled <- TRUE
[13:22:01.069]                             break
[13:22:01.069]                           }
[13:22:01.069]                         }
[13:22:01.069]                       }
[13:22:01.069]                       invisible(muffled)
[13:22:01.069]                     }
[13:22:01.069]                     muffleCondition(cond, pattern = "^muffle")
[13:22:01.069]                   }
[13:22:01.069]                 }
[13:22:01.069]                 else {
[13:22:01.069]                   if (TRUE) {
[13:22:01.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:01.069]                     {
[13:22:01.069]                       inherits <- base::inherits
[13:22:01.069]                       invokeRestart <- base::invokeRestart
[13:22:01.069]                       is.null <- base::is.null
[13:22:01.069]                       muffled <- FALSE
[13:22:01.069]                       if (inherits(cond, "message")) {
[13:22:01.069]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:01.069]                         if (muffled) 
[13:22:01.069]                           invokeRestart("muffleMessage")
[13:22:01.069]                       }
[13:22:01.069]                       else if (inherits(cond, "warning")) {
[13:22:01.069]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:01.069]                         if (muffled) 
[13:22:01.069]                           invokeRestart("muffleWarning")
[13:22:01.069]                       }
[13:22:01.069]                       else if (inherits(cond, "condition")) {
[13:22:01.069]                         if (!is.null(pattern)) {
[13:22:01.069]                           computeRestarts <- base::computeRestarts
[13:22:01.069]                           grepl <- base::grepl
[13:22:01.069]                           restarts <- computeRestarts(cond)
[13:22:01.069]                           for (restart in restarts) {
[13:22:01.069]                             name <- restart$name
[13:22:01.069]                             if (is.null(name)) 
[13:22:01.069]                               next
[13:22:01.069]                             if (!grepl(pattern, name)) 
[13:22:01.069]                               next
[13:22:01.069]                             invokeRestart(restart)
[13:22:01.069]                             muffled <- TRUE
[13:22:01.069]                             break
[13:22:01.069]                           }
[13:22:01.069]                         }
[13:22:01.069]                       }
[13:22:01.069]                       invisible(muffled)
[13:22:01.069]                     }
[13:22:01.069]                     muffleCondition(cond, pattern = "^muffle")
[13:22:01.069]                   }
[13:22:01.069]                 }
[13:22:01.069]             }
[13:22:01.069]         }))
[13:22:01.069]     }, error = function(ex) {
[13:22:01.069]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:01.069]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:01.069]                 ...future.rng), started = ...future.startTime, 
[13:22:01.069]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:01.069]             version = "1.8"), class = "FutureResult")
[13:22:01.069]     }, finally = {
[13:22:01.069]         if (!identical(...future.workdir, getwd())) 
[13:22:01.069]             setwd(...future.workdir)
[13:22:01.069]         {
[13:22:01.069]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:01.069]                 ...future.oldOptions$nwarnings <- NULL
[13:22:01.069]             }
[13:22:01.069]             base::options(...future.oldOptions)
[13:22:01.069]             if (.Platform$OS.type == "windows") {
[13:22:01.069]                 old_names <- names(...future.oldEnvVars)
[13:22:01.069]                 envs <- base::Sys.getenv()
[13:22:01.069]                 names <- names(envs)
[13:22:01.069]                 common <- intersect(names, old_names)
[13:22:01.069]                 added <- setdiff(names, old_names)
[13:22:01.069]                 removed <- setdiff(old_names, names)
[13:22:01.069]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:01.069]                   envs[common]]
[13:22:01.069]                 NAMES <- toupper(changed)
[13:22:01.069]                 args <- list()
[13:22:01.069]                 for (kk in seq_along(NAMES)) {
[13:22:01.069]                   name <- changed[[kk]]
[13:22:01.069]                   NAME <- NAMES[[kk]]
[13:22:01.069]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:01.069]                     next
[13:22:01.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:01.069]                 }
[13:22:01.069]                 NAMES <- toupper(added)
[13:22:01.069]                 for (kk in seq_along(NAMES)) {
[13:22:01.069]                   name <- added[[kk]]
[13:22:01.069]                   NAME <- NAMES[[kk]]
[13:22:01.069]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:01.069]                     next
[13:22:01.069]                   args[[name]] <- ""
[13:22:01.069]                 }
[13:22:01.069]                 NAMES <- toupper(removed)
[13:22:01.069]                 for (kk in seq_along(NAMES)) {
[13:22:01.069]                   name <- removed[[kk]]
[13:22:01.069]                   NAME <- NAMES[[kk]]
[13:22:01.069]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:01.069]                     next
[13:22:01.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:01.069]                 }
[13:22:01.069]                 if (length(args) > 0) 
[13:22:01.069]                   base::do.call(base::Sys.setenv, args = args)
[13:22:01.069]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:01.069]             }
[13:22:01.069]             else {
[13:22:01.069]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:01.069]             }
[13:22:01.069]             {
[13:22:01.069]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:01.069]                   0L) {
[13:22:01.069]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:01.069]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:01.069]                   base::options(opts)
[13:22:01.069]                 }
[13:22:01.069]                 {
[13:22:01.069]                   {
[13:22:01.069]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:01.069]                     NULL
[13:22:01.069]                   }
[13:22:01.069]                   options(future.plan = NULL)
[13:22:01.069]                   if (is.na(NA_character_)) 
[13:22:01.069]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:01.069]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:01.069]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:01.069]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:01.069]                     envir = parent.frame()) 
[13:22:01.069]                   {
[13:22:01.069]                     if (is.function(workers)) 
[13:22:01.069]                       workers <- workers()
[13:22:01.069]                     workers <- structure(as.integer(workers), 
[13:22:01.069]                       class = class(workers))
[13:22:01.069]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:01.069]                       workers >= 1)
[13:22:01.069]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:01.069]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:01.069]                     }
[13:22:01.069]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:01.069]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:01.069]                       envir = envir)
[13:22:01.069]                     if (!future$lazy) 
[13:22:01.069]                       future <- run(future)
[13:22:01.069]                     invisible(future)
[13:22:01.069]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:01.069]                 }
[13:22:01.069]             }
[13:22:01.069]         }
[13:22:01.069]     })
[13:22:01.069]     if (TRUE) {
[13:22:01.069]         base::sink(type = "output", split = FALSE)
[13:22:01.069]         if (TRUE) {
[13:22:01.069]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:01.069]         }
[13:22:01.069]         else {
[13:22:01.069]             ...future.result["stdout"] <- base::list(NULL)
[13:22:01.069]         }
[13:22:01.069]         base::close(...future.stdout)
[13:22:01.069]         ...future.stdout <- NULL
[13:22:01.069]     }
[13:22:01.069]     ...future.result$conditions <- ...future.conditions
[13:22:01.069]     ...future.result$finished <- base::Sys.time()
[13:22:01.069]     ...future.result
[13:22:01.069] }
[13:22:01.072] MultisessionFuture started
[13:22:01.072] - Launch lazy future ... done
[13:22:01.073] run() for ‘MultisessionFuture’ ... done
[13:22:01.073] getGlobalsAndPackages() ...
[13:22:01.073] Searching for globals...
[13:22:01.073] 
[13:22:01.073] Searching for globals ... DONE
[13:22:01.073] - globals: [0] <none>
[13:22:01.073] getGlobalsAndPackages() ... DONE
[13:22:01.074] run() for ‘Future’ ...
[13:22:01.074] - state: ‘created’
[13:22:01.074] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:01.090] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:01.090] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:01.090]   - Field: ‘node’
[13:22:01.090]   - Field: ‘label’
[13:22:01.090]   - Field: ‘local’
[13:22:01.090]   - Field: ‘owner’
[13:22:01.090]   - Field: ‘envir’
[13:22:01.090]   - Field: ‘workers’
[13:22:01.090]   - Field: ‘packages’
[13:22:01.091]   - Field: ‘gc’
[13:22:01.091]   - Field: ‘conditions’
[13:22:01.091]   - Field: ‘persistent’
[13:22:01.091]   - Field: ‘expr’
[13:22:01.091]   - Field: ‘uuid’
[13:22:01.091]   - Field: ‘seed’
[13:22:01.091]   - Field: ‘version’
[13:22:01.091]   - Field: ‘result’
[13:22:01.091]   - Field: ‘asynchronous’
[13:22:01.091]   - Field: ‘calls’
[13:22:01.092]   - Field: ‘globals’
[13:22:01.092]   - Field: ‘stdout’
[13:22:01.092]   - Field: ‘earlySignal’
[13:22:01.092]   - Field: ‘lazy’
[13:22:01.092]   - Field: ‘state’
[13:22:01.092] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:01.092] - Launch lazy future ...
[13:22:01.092] Packages needed by the future expression (n = 0): <none>
[13:22:01.093] Packages needed by future strategies (n = 0): <none>
[13:22:01.093] {
[13:22:01.093]     {
[13:22:01.093]         {
[13:22:01.093]             ...future.startTime <- base::Sys.time()
[13:22:01.093]             {
[13:22:01.093]                 {
[13:22:01.093]                   {
[13:22:01.093]                     {
[13:22:01.093]                       base::local({
[13:22:01.093]                         has_future <- base::requireNamespace("future", 
[13:22:01.093]                           quietly = TRUE)
[13:22:01.093]                         if (has_future) {
[13:22:01.093]                           ns <- base::getNamespace("future")
[13:22:01.093]                           version <- ns[[".package"]][["version"]]
[13:22:01.093]                           if (is.null(version)) 
[13:22:01.093]                             version <- utils::packageVersion("future")
[13:22:01.093]                         }
[13:22:01.093]                         else {
[13:22:01.093]                           version <- NULL
[13:22:01.093]                         }
[13:22:01.093]                         if (!has_future || version < "1.8.0") {
[13:22:01.093]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:01.093]                             "", base::R.version$version.string), 
[13:22:01.093]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:01.093]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:01.093]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:01.093]                               "release", "version")], collapse = " "), 
[13:22:01.093]                             hostname = base::Sys.info()[["nodename"]])
[13:22:01.093]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:01.093]                             info)
[13:22:01.093]                           info <- base::paste(info, collapse = "; ")
[13:22:01.093]                           if (!has_future) {
[13:22:01.093]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:01.093]                               info)
[13:22:01.093]                           }
[13:22:01.093]                           else {
[13:22:01.093]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:01.093]                               info, version)
[13:22:01.093]                           }
[13:22:01.093]                           base::stop(msg)
[13:22:01.093]                         }
[13:22:01.093]                       })
[13:22:01.093]                     }
[13:22:01.093]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:01.093]                     base::options(mc.cores = 1L)
[13:22:01.093]                   }
[13:22:01.093]                   options(future.plan = NULL)
[13:22:01.093]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:01.093]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:01.093]                 }
[13:22:01.093]                 ...future.workdir <- getwd()
[13:22:01.093]             }
[13:22:01.093]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:01.093]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:01.093]         }
[13:22:01.093]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:01.093]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:01.093]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:01.093]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:01.093]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:01.093]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:01.093]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:01.093]             base::names(...future.oldOptions))
[13:22:01.093]     }
[13:22:01.093]     if (FALSE) {
[13:22:01.093]     }
[13:22:01.093]     else {
[13:22:01.093]         if (TRUE) {
[13:22:01.093]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:01.093]                 open = "w")
[13:22:01.093]         }
[13:22:01.093]         else {
[13:22:01.093]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:01.093]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:01.093]         }
[13:22:01.093]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:01.093]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:01.093]             base::sink(type = "output", split = FALSE)
[13:22:01.093]             base::close(...future.stdout)
[13:22:01.093]         }, add = TRUE)
[13:22:01.093]     }
[13:22:01.093]     ...future.frame <- base::sys.nframe()
[13:22:01.093]     ...future.conditions <- base::list()
[13:22:01.093]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:01.093]     if (FALSE) {
[13:22:01.093]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:01.093]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:01.093]     }
[13:22:01.093]     ...future.result <- base::tryCatch({
[13:22:01.093]         base::withCallingHandlers({
[13:22:01.093]             ...future.value <- base::withVisible(base::local({
[13:22:01.093]                 ...future.makeSendCondition <- local({
[13:22:01.093]                   sendCondition <- NULL
[13:22:01.093]                   function(frame = 1L) {
[13:22:01.093]                     if (is.function(sendCondition)) 
[13:22:01.093]                       return(sendCondition)
[13:22:01.093]                     ns <- getNamespace("parallel")
[13:22:01.093]                     if (exists("sendData", mode = "function", 
[13:22:01.093]                       envir = ns)) {
[13:22:01.093]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:01.093]                         envir = ns)
[13:22:01.093]                       envir <- sys.frame(frame)
[13:22:01.093]                       master <- NULL
[13:22:01.093]                       while (!identical(envir, .GlobalEnv) && 
[13:22:01.093]                         !identical(envir, emptyenv())) {
[13:22:01.093]                         if (exists("master", mode = "list", envir = envir, 
[13:22:01.093]                           inherits = FALSE)) {
[13:22:01.093]                           master <- get("master", mode = "list", 
[13:22:01.093]                             envir = envir, inherits = FALSE)
[13:22:01.093]                           if (inherits(master, c("SOCKnode", 
[13:22:01.093]                             "SOCK0node"))) {
[13:22:01.093]                             sendCondition <<- function(cond) {
[13:22:01.093]                               data <- list(type = "VALUE", value = cond, 
[13:22:01.093]                                 success = TRUE)
[13:22:01.093]                               parallel_sendData(master, data)
[13:22:01.093]                             }
[13:22:01.093]                             return(sendCondition)
[13:22:01.093]                           }
[13:22:01.093]                         }
[13:22:01.093]                         frame <- frame + 1L
[13:22:01.093]                         envir <- sys.frame(frame)
[13:22:01.093]                       }
[13:22:01.093]                     }
[13:22:01.093]                     sendCondition <<- function(cond) NULL
[13:22:01.093]                   }
[13:22:01.093]                 })
[13:22:01.093]                 withCallingHandlers({
[13:22:01.093]                   2
[13:22:01.093]                 }, immediateCondition = function(cond) {
[13:22:01.093]                   sendCondition <- ...future.makeSendCondition()
[13:22:01.093]                   sendCondition(cond)
[13:22:01.093]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:01.093]                   {
[13:22:01.093]                     inherits <- base::inherits
[13:22:01.093]                     invokeRestart <- base::invokeRestart
[13:22:01.093]                     is.null <- base::is.null
[13:22:01.093]                     muffled <- FALSE
[13:22:01.093]                     if (inherits(cond, "message")) {
[13:22:01.093]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:01.093]                       if (muffled) 
[13:22:01.093]                         invokeRestart("muffleMessage")
[13:22:01.093]                     }
[13:22:01.093]                     else if (inherits(cond, "warning")) {
[13:22:01.093]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:01.093]                       if (muffled) 
[13:22:01.093]                         invokeRestart("muffleWarning")
[13:22:01.093]                     }
[13:22:01.093]                     else if (inherits(cond, "condition")) {
[13:22:01.093]                       if (!is.null(pattern)) {
[13:22:01.093]                         computeRestarts <- base::computeRestarts
[13:22:01.093]                         grepl <- base::grepl
[13:22:01.093]                         restarts <- computeRestarts(cond)
[13:22:01.093]                         for (restart in restarts) {
[13:22:01.093]                           name <- restart$name
[13:22:01.093]                           if (is.null(name)) 
[13:22:01.093]                             next
[13:22:01.093]                           if (!grepl(pattern, name)) 
[13:22:01.093]                             next
[13:22:01.093]                           invokeRestart(restart)
[13:22:01.093]                           muffled <- TRUE
[13:22:01.093]                           break
[13:22:01.093]                         }
[13:22:01.093]                       }
[13:22:01.093]                     }
[13:22:01.093]                     invisible(muffled)
[13:22:01.093]                   }
[13:22:01.093]                   muffleCondition(cond)
[13:22:01.093]                 })
[13:22:01.093]             }))
[13:22:01.093]             future::FutureResult(value = ...future.value$value, 
[13:22:01.093]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:01.093]                   ...future.rng), globalenv = if (FALSE) 
[13:22:01.093]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:01.093]                     ...future.globalenv.names))
[13:22:01.093]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:01.093]         }, condition = base::local({
[13:22:01.093]             c <- base::c
[13:22:01.093]             inherits <- base::inherits
[13:22:01.093]             invokeRestart <- base::invokeRestart
[13:22:01.093]             length <- base::length
[13:22:01.093]             list <- base::list
[13:22:01.093]             seq.int <- base::seq.int
[13:22:01.093]             signalCondition <- base::signalCondition
[13:22:01.093]             sys.calls <- base::sys.calls
[13:22:01.093]             `[[` <- base::`[[`
[13:22:01.093]             `+` <- base::`+`
[13:22:01.093]             `<<-` <- base::`<<-`
[13:22:01.093]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:01.093]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:01.093]                   3L)]
[13:22:01.093]             }
[13:22:01.093]             function(cond) {
[13:22:01.093]                 is_error <- inherits(cond, "error")
[13:22:01.093]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:01.093]                   NULL)
[13:22:01.093]                 if (is_error) {
[13:22:01.093]                   sessionInformation <- function() {
[13:22:01.093]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:01.093]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:01.093]                       search = base::search(), system = base::Sys.info())
[13:22:01.093]                   }
[13:22:01.093]                   ...future.conditions[[length(...future.conditions) + 
[13:22:01.093]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:01.093]                     cond$call), session = sessionInformation(), 
[13:22:01.093]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:01.093]                   signalCondition(cond)
[13:22:01.093]                 }
[13:22:01.093]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:01.093]                 "immediateCondition"))) {
[13:22:01.093]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:01.093]                   ...future.conditions[[length(...future.conditions) + 
[13:22:01.093]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:01.093]                   if (TRUE && !signal) {
[13:22:01.093]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:01.093]                     {
[13:22:01.093]                       inherits <- base::inherits
[13:22:01.093]                       invokeRestart <- base::invokeRestart
[13:22:01.093]                       is.null <- base::is.null
[13:22:01.093]                       muffled <- FALSE
[13:22:01.093]                       if (inherits(cond, "message")) {
[13:22:01.093]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:01.093]                         if (muffled) 
[13:22:01.093]                           invokeRestart("muffleMessage")
[13:22:01.093]                       }
[13:22:01.093]                       else if (inherits(cond, "warning")) {
[13:22:01.093]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:01.093]                         if (muffled) 
[13:22:01.093]                           invokeRestart("muffleWarning")
[13:22:01.093]                       }
[13:22:01.093]                       else if (inherits(cond, "condition")) {
[13:22:01.093]                         if (!is.null(pattern)) {
[13:22:01.093]                           computeRestarts <- base::computeRestarts
[13:22:01.093]                           grepl <- base::grepl
[13:22:01.093]                           restarts <- computeRestarts(cond)
[13:22:01.093]                           for (restart in restarts) {
[13:22:01.093]                             name <- restart$name
[13:22:01.093]                             if (is.null(name)) 
[13:22:01.093]                               next
[13:22:01.093]                             if (!grepl(pattern, name)) 
[13:22:01.093]                               next
[13:22:01.093]                             invokeRestart(restart)
[13:22:01.093]                             muffled <- TRUE
[13:22:01.093]                             break
[13:22:01.093]                           }
[13:22:01.093]                         }
[13:22:01.093]                       }
[13:22:01.093]                       invisible(muffled)
[13:22:01.093]                     }
[13:22:01.093]                     muffleCondition(cond, pattern = "^muffle")
[13:22:01.093]                   }
[13:22:01.093]                 }
[13:22:01.093]                 else {
[13:22:01.093]                   if (TRUE) {
[13:22:01.093]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:01.093]                     {
[13:22:01.093]                       inherits <- base::inherits
[13:22:01.093]                       invokeRestart <- base::invokeRestart
[13:22:01.093]                       is.null <- base::is.null
[13:22:01.093]                       muffled <- FALSE
[13:22:01.093]                       if (inherits(cond, "message")) {
[13:22:01.093]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:01.093]                         if (muffled) 
[13:22:01.093]                           invokeRestart("muffleMessage")
[13:22:01.093]                       }
[13:22:01.093]                       else if (inherits(cond, "warning")) {
[13:22:01.093]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:01.093]                         if (muffled) 
[13:22:01.093]                           invokeRestart("muffleWarning")
[13:22:01.093]                       }
[13:22:01.093]                       else if (inherits(cond, "condition")) {
[13:22:01.093]                         if (!is.null(pattern)) {
[13:22:01.093]                           computeRestarts <- base::computeRestarts
[13:22:01.093]                           grepl <- base::grepl
[13:22:01.093]                           restarts <- computeRestarts(cond)
[13:22:01.093]                           for (restart in restarts) {
[13:22:01.093]                             name <- restart$name
[13:22:01.093]                             if (is.null(name)) 
[13:22:01.093]                               next
[13:22:01.093]                             if (!grepl(pattern, name)) 
[13:22:01.093]                               next
[13:22:01.093]                             invokeRestart(restart)
[13:22:01.093]                             muffled <- TRUE
[13:22:01.093]                             break
[13:22:01.093]                           }
[13:22:01.093]                         }
[13:22:01.093]                       }
[13:22:01.093]                       invisible(muffled)
[13:22:01.093]                     }
[13:22:01.093]                     muffleCondition(cond, pattern = "^muffle")
[13:22:01.093]                   }
[13:22:01.093]                 }
[13:22:01.093]             }
[13:22:01.093]         }))
[13:22:01.093]     }, error = function(ex) {
[13:22:01.093]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:01.093]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:01.093]                 ...future.rng), started = ...future.startTime, 
[13:22:01.093]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:01.093]             version = "1.8"), class = "FutureResult")
[13:22:01.093]     }, finally = {
[13:22:01.093]         if (!identical(...future.workdir, getwd())) 
[13:22:01.093]             setwd(...future.workdir)
[13:22:01.093]         {
[13:22:01.093]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:01.093]                 ...future.oldOptions$nwarnings <- NULL
[13:22:01.093]             }
[13:22:01.093]             base::options(...future.oldOptions)
[13:22:01.093]             if (.Platform$OS.type == "windows") {
[13:22:01.093]                 old_names <- names(...future.oldEnvVars)
[13:22:01.093]                 envs <- base::Sys.getenv()
[13:22:01.093]                 names <- names(envs)
[13:22:01.093]                 common <- intersect(names, old_names)
[13:22:01.093]                 added <- setdiff(names, old_names)
[13:22:01.093]                 removed <- setdiff(old_names, names)
[13:22:01.093]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:01.093]                   envs[common]]
[13:22:01.093]                 NAMES <- toupper(changed)
[13:22:01.093]                 args <- list()
[13:22:01.093]                 for (kk in seq_along(NAMES)) {
[13:22:01.093]                   name <- changed[[kk]]
[13:22:01.093]                   NAME <- NAMES[[kk]]
[13:22:01.093]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:01.093]                     next
[13:22:01.093]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:01.093]                 }
[13:22:01.093]                 NAMES <- toupper(added)
[13:22:01.093]                 for (kk in seq_along(NAMES)) {
[13:22:01.093]                   name <- added[[kk]]
[13:22:01.093]                   NAME <- NAMES[[kk]]
[13:22:01.093]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:01.093]                     next
[13:22:01.093]                   args[[name]] <- ""
[13:22:01.093]                 }
[13:22:01.093]                 NAMES <- toupper(removed)
[13:22:01.093]                 for (kk in seq_along(NAMES)) {
[13:22:01.093]                   name <- removed[[kk]]
[13:22:01.093]                   NAME <- NAMES[[kk]]
[13:22:01.093]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:01.093]                     next
[13:22:01.093]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:01.093]                 }
[13:22:01.093]                 if (length(args) > 0) 
[13:22:01.093]                   base::do.call(base::Sys.setenv, args = args)
[13:22:01.093]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:01.093]             }
[13:22:01.093]             else {
[13:22:01.093]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:01.093]             }
[13:22:01.093]             {
[13:22:01.093]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:01.093]                   0L) {
[13:22:01.093]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:01.093]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:01.093]                   base::options(opts)
[13:22:01.093]                 }
[13:22:01.093]                 {
[13:22:01.093]                   {
[13:22:01.093]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:01.093]                     NULL
[13:22:01.093]                   }
[13:22:01.093]                   options(future.plan = NULL)
[13:22:01.093]                   if (is.na(NA_character_)) 
[13:22:01.093]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:01.093]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:01.093]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:01.093]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:01.093]                     envir = parent.frame()) 
[13:22:01.093]                   {
[13:22:01.093]                     if (is.function(workers)) 
[13:22:01.093]                       workers <- workers()
[13:22:01.093]                     workers <- structure(as.integer(workers), 
[13:22:01.093]                       class = class(workers))
[13:22:01.093]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:01.093]                       workers >= 1)
[13:22:01.093]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:01.093]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:01.093]                     }
[13:22:01.093]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:01.093]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:01.093]                       envir = envir)
[13:22:01.093]                     if (!future$lazy) 
[13:22:01.093]                       future <- run(future)
[13:22:01.093]                     invisible(future)
[13:22:01.093]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:01.093]                 }
[13:22:01.093]             }
[13:22:01.093]         }
[13:22:01.093]     })
[13:22:01.093]     if (TRUE) {
[13:22:01.093]         base::sink(type = "output", split = FALSE)
[13:22:01.093]         if (TRUE) {
[13:22:01.093]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:01.093]         }
[13:22:01.093]         else {
[13:22:01.093]             ...future.result["stdout"] <- base::list(NULL)
[13:22:01.093]         }
[13:22:01.093]         base::close(...future.stdout)
[13:22:01.093]         ...future.stdout <- NULL
[13:22:01.093]     }
[13:22:01.093]     ...future.result$conditions <- ...future.conditions
[13:22:01.093]     ...future.result$finished <- base::Sys.time()
[13:22:01.093]     ...future.result
[13:22:01.093] }
[13:22:01.096] MultisessionFuture started
[13:22:01.096] - Launch lazy future ... done
[13:22:01.096] run() for ‘MultisessionFuture’ ... done
[13:22:01.097] resolve() on list environment ...
[13:22:01.097]  recursive: 0
[13:22:01.098]  length: 3
[13:22:01.098]  elements: ‘a’, ‘b’, ‘c’
[13:22:01.119]  length: 2 (resolved future 3)
[13:22:01.130] receiveMessageFromWorker() for ClusterFuture ...
[13:22:01.130] - Validating connection of MultisessionFuture
[13:22:01.130] - received message: FutureResult
[13:22:01.130] - Received FutureResult
[13:22:01.130] - Erased future from FutureRegistry
[13:22:01.130] result() for ClusterFuture ...
[13:22:01.130] - result already collected: FutureResult
[13:22:01.130] result() for ClusterFuture ... done
[13:22:01.131] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:01.131] Future #1
[13:22:01.131]  length: 1 (resolved future 1)
[13:22:01.152] receiveMessageFromWorker() for ClusterFuture ...
[13:22:01.152] - Validating connection of MultisessionFuture
[13:22:01.152] - received message: FutureResult
[13:22:01.152] - Received FutureResult
[13:22:01.153] - Erased future from FutureRegistry
[13:22:01.153] result() for ClusterFuture ...
[13:22:01.153] - result already collected: FutureResult
[13:22:01.153] result() for ClusterFuture ... done
[13:22:01.153] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:01.153] Future #2
[13:22:01.153]  length: 0 (resolved future 2)
[13:22:01.153] resolve() on list environment ... DONE
[13:22:01.154] getGlobalsAndPackages() ...
[13:22:01.154] Searching for globals...
[13:22:01.155] - globals found: [1] ‘{’
[13:22:01.155] Searching for globals ... DONE
[13:22:01.155] Resolving globals: FALSE
[13:22:01.155] 
[13:22:01.155] 
[13:22:01.155] getGlobalsAndPackages() ... DONE
[13:22:01.156] run() for ‘Future’ ...
[13:22:01.156] - state: ‘created’
[13:22:01.156] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:01.170] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:01.170] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:01.170]   - Field: ‘node’
[13:22:01.171]   - Field: ‘label’
[13:22:01.171]   - Field: ‘local’
[13:22:01.171]   - Field: ‘owner’
[13:22:01.171]   - Field: ‘envir’
[13:22:01.171]   - Field: ‘workers’
[13:22:01.171]   - Field: ‘packages’
[13:22:01.171]   - Field: ‘gc’
[13:22:01.171]   - Field: ‘conditions’
[13:22:01.171]   - Field: ‘persistent’
[13:22:01.171]   - Field: ‘expr’
[13:22:01.171]   - Field: ‘uuid’
[13:22:01.172]   - Field: ‘seed’
[13:22:01.172]   - Field: ‘version’
[13:22:01.172]   - Field: ‘result’
[13:22:01.172]   - Field: ‘asynchronous’
[13:22:01.172]   - Field: ‘calls’
[13:22:01.172]   - Field: ‘globals’
[13:22:01.172]   - Field: ‘stdout’
[13:22:01.172]   - Field: ‘earlySignal’
[13:22:01.172]   - Field: ‘lazy’
[13:22:01.172]   - Field: ‘state’
[13:22:01.172] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:01.173] - Launch lazy future ...
[13:22:01.173] Packages needed by the future expression (n = 0): <none>
[13:22:01.173] Packages needed by future strategies (n = 0): <none>
[13:22:01.173] {
[13:22:01.173]     {
[13:22:01.173]         {
[13:22:01.173]             ...future.startTime <- base::Sys.time()
[13:22:01.173]             {
[13:22:01.173]                 {
[13:22:01.173]                   {
[13:22:01.173]                     {
[13:22:01.173]                       base::local({
[13:22:01.173]                         has_future <- base::requireNamespace("future", 
[13:22:01.173]                           quietly = TRUE)
[13:22:01.173]                         if (has_future) {
[13:22:01.173]                           ns <- base::getNamespace("future")
[13:22:01.173]                           version <- ns[[".package"]][["version"]]
[13:22:01.173]                           if (is.null(version)) 
[13:22:01.173]                             version <- utils::packageVersion("future")
[13:22:01.173]                         }
[13:22:01.173]                         else {
[13:22:01.173]                           version <- NULL
[13:22:01.173]                         }
[13:22:01.173]                         if (!has_future || version < "1.8.0") {
[13:22:01.173]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:01.173]                             "", base::R.version$version.string), 
[13:22:01.173]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:01.173]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:01.173]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:01.173]                               "release", "version")], collapse = " "), 
[13:22:01.173]                             hostname = base::Sys.info()[["nodename"]])
[13:22:01.173]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:01.173]                             info)
[13:22:01.173]                           info <- base::paste(info, collapse = "; ")
[13:22:01.173]                           if (!has_future) {
[13:22:01.173]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:01.173]                               info)
[13:22:01.173]                           }
[13:22:01.173]                           else {
[13:22:01.173]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:01.173]                               info, version)
[13:22:01.173]                           }
[13:22:01.173]                           base::stop(msg)
[13:22:01.173]                         }
[13:22:01.173]                       })
[13:22:01.173]                     }
[13:22:01.173]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:01.173]                     base::options(mc.cores = 1L)
[13:22:01.173]                   }
[13:22:01.173]                   options(future.plan = NULL)
[13:22:01.173]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:01.173]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:01.173]                 }
[13:22:01.173]                 ...future.workdir <- getwd()
[13:22:01.173]             }
[13:22:01.173]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:01.173]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:01.173]         }
[13:22:01.173]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:01.173]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:01.173]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:01.173]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:01.173]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:01.173]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:01.173]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:01.173]             base::names(...future.oldOptions))
[13:22:01.173]     }
[13:22:01.173]     if (FALSE) {
[13:22:01.173]     }
[13:22:01.173]     else {
[13:22:01.173]         if (TRUE) {
[13:22:01.173]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:01.173]                 open = "w")
[13:22:01.173]         }
[13:22:01.173]         else {
[13:22:01.173]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:01.173]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:01.173]         }
[13:22:01.173]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:01.173]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:01.173]             base::sink(type = "output", split = FALSE)
[13:22:01.173]             base::close(...future.stdout)
[13:22:01.173]         }, add = TRUE)
[13:22:01.173]     }
[13:22:01.173]     ...future.frame <- base::sys.nframe()
[13:22:01.173]     ...future.conditions <- base::list()
[13:22:01.173]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:01.173]     if (FALSE) {
[13:22:01.173]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:01.173]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:01.173]     }
[13:22:01.173]     ...future.result <- base::tryCatch({
[13:22:01.173]         base::withCallingHandlers({
[13:22:01.173]             ...future.value <- base::withVisible(base::local({
[13:22:01.173]                 ...future.makeSendCondition <- local({
[13:22:01.173]                   sendCondition <- NULL
[13:22:01.173]                   function(frame = 1L) {
[13:22:01.173]                     if (is.function(sendCondition)) 
[13:22:01.173]                       return(sendCondition)
[13:22:01.173]                     ns <- getNamespace("parallel")
[13:22:01.173]                     if (exists("sendData", mode = "function", 
[13:22:01.173]                       envir = ns)) {
[13:22:01.173]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:01.173]                         envir = ns)
[13:22:01.173]                       envir <- sys.frame(frame)
[13:22:01.173]                       master <- NULL
[13:22:01.173]                       while (!identical(envir, .GlobalEnv) && 
[13:22:01.173]                         !identical(envir, emptyenv())) {
[13:22:01.173]                         if (exists("master", mode = "list", envir = envir, 
[13:22:01.173]                           inherits = FALSE)) {
[13:22:01.173]                           master <- get("master", mode = "list", 
[13:22:01.173]                             envir = envir, inherits = FALSE)
[13:22:01.173]                           if (inherits(master, c("SOCKnode", 
[13:22:01.173]                             "SOCK0node"))) {
[13:22:01.173]                             sendCondition <<- function(cond) {
[13:22:01.173]                               data <- list(type = "VALUE", value = cond, 
[13:22:01.173]                                 success = TRUE)
[13:22:01.173]                               parallel_sendData(master, data)
[13:22:01.173]                             }
[13:22:01.173]                             return(sendCondition)
[13:22:01.173]                           }
[13:22:01.173]                         }
[13:22:01.173]                         frame <- frame + 1L
[13:22:01.173]                         envir <- sys.frame(frame)
[13:22:01.173]                       }
[13:22:01.173]                     }
[13:22:01.173]                     sendCondition <<- function(cond) NULL
[13:22:01.173]                   }
[13:22:01.173]                 })
[13:22:01.173]                 withCallingHandlers({
[13:22:01.173]                   {
[13:22:01.173]                     1
[13:22:01.173]                   }
[13:22:01.173]                 }, immediateCondition = function(cond) {
[13:22:01.173]                   sendCondition <- ...future.makeSendCondition()
[13:22:01.173]                   sendCondition(cond)
[13:22:01.173]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:01.173]                   {
[13:22:01.173]                     inherits <- base::inherits
[13:22:01.173]                     invokeRestart <- base::invokeRestart
[13:22:01.173]                     is.null <- base::is.null
[13:22:01.173]                     muffled <- FALSE
[13:22:01.173]                     if (inherits(cond, "message")) {
[13:22:01.173]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:01.173]                       if (muffled) 
[13:22:01.173]                         invokeRestart("muffleMessage")
[13:22:01.173]                     }
[13:22:01.173]                     else if (inherits(cond, "warning")) {
[13:22:01.173]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:01.173]                       if (muffled) 
[13:22:01.173]                         invokeRestart("muffleWarning")
[13:22:01.173]                     }
[13:22:01.173]                     else if (inherits(cond, "condition")) {
[13:22:01.173]                       if (!is.null(pattern)) {
[13:22:01.173]                         computeRestarts <- base::computeRestarts
[13:22:01.173]                         grepl <- base::grepl
[13:22:01.173]                         restarts <- computeRestarts(cond)
[13:22:01.173]                         for (restart in restarts) {
[13:22:01.173]                           name <- restart$name
[13:22:01.173]                           if (is.null(name)) 
[13:22:01.173]                             next
[13:22:01.173]                           if (!grepl(pattern, name)) 
[13:22:01.173]                             next
[13:22:01.173]                           invokeRestart(restart)
[13:22:01.173]                           muffled <- TRUE
[13:22:01.173]                           break
[13:22:01.173]                         }
[13:22:01.173]                       }
[13:22:01.173]                     }
[13:22:01.173]                     invisible(muffled)
[13:22:01.173]                   }
[13:22:01.173]                   muffleCondition(cond)
[13:22:01.173]                 })
[13:22:01.173]             }))
[13:22:01.173]             future::FutureResult(value = ...future.value$value, 
[13:22:01.173]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:01.173]                   ...future.rng), globalenv = if (FALSE) 
[13:22:01.173]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:01.173]                     ...future.globalenv.names))
[13:22:01.173]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:01.173]         }, condition = base::local({
[13:22:01.173]             c <- base::c
[13:22:01.173]             inherits <- base::inherits
[13:22:01.173]             invokeRestart <- base::invokeRestart
[13:22:01.173]             length <- base::length
[13:22:01.173]             list <- base::list
[13:22:01.173]             seq.int <- base::seq.int
[13:22:01.173]             signalCondition <- base::signalCondition
[13:22:01.173]             sys.calls <- base::sys.calls
[13:22:01.173]             `[[` <- base::`[[`
[13:22:01.173]             `+` <- base::`+`
[13:22:01.173]             `<<-` <- base::`<<-`
[13:22:01.173]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:01.173]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:01.173]                   3L)]
[13:22:01.173]             }
[13:22:01.173]             function(cond) {
[13:22:01.173]                 is_error <- inherits(cond, "error")
[13:22:01.173]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:01.173]                   NULL)
[13:22:01.173]                 if (is_error) {
[13:22:01.173]                   sessionInformation <- function() {
[13:22:01.173]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:01.173]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:01.173]                       search = base::search(), system = base::Sys.info())
[13:22:01.173]                   }
[13:22:01.173]                   ...future.conditions[[length(...future.conditions) + 
[13:22:01.173]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:01.173]                     cond$call), session = sessionInformation(), 
[13:22:01.173]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:01.173]                   signalCondition(cond)
[13:22:01.173]                 }
[13:22:01.173]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:01.173]                 "immediateCondition"))) {
[13:22:01.173]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:01.173]                   ...future.conditions[[length(...future.conditions) + 
[13:22:01.173]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:01.173]                   if (TRUE && !signal) {
[13:22:01.173]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:01.173]                     {
[13:22:01.173]                       inherits <- base::inherits
[13:22:01.173]                       invokeRestart <- base::invokeRestart
[13:22:01.173]                       is.null <- base::is.null
[13:22:01.173]                       muffled <- FALSE
[13:22:01.173]                       if (inherits(cond, "message")) {
[13:22:01.173]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:01.173]                         if (muffled) 
[13:22:01.173]                           invokeRestart("muffleMessage")
[13:22:01.173]                       }
[13:22:01.173]                       else if (inherits(cond, "warning")) {
[13:22:01.173]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:01.173]                         if (muffled) 
[13:22:01.173]                           invokeRestart("muffleWarning")
[13:22:01.173]                       }
[13:22:01.173]                       else if (inherits(cond, "condition")) {
[13:22:01.173]                         if (!is.null(pattern)) {
[13:22:01.173]                           computeRestarts <- base::computeRestarts
[13:22:01.173]                           grepl <- base::grepl
[13:22:01.173]                           restarts <- computeRestarts(cond)
[13:22:01.173]                           for (restart in restarts) {
[13:22:01.173]                             name <- restart$name
[13:22:01.173]                             if (is.null(name)) 
[13:22:01.173]                               next
[13:22:01.173]                             if (!grepl(pattern, name)) 
[13:22:01.173]                               next
[13:22:01.173]                             invokeRestart(restart)
[13:22:01.173]                             muffled <- TRUE
[13:22:01.173]                             break
[13:22:01.173]                           }
[13:22:01.173]                         }
[13:22:01.173]                       }
[13:22:01.173]                       invisible(muffled)
[13:22:01.173]                     }
[13:22:01.173]                     muffleCondition(cond, pattern = "^muffle")
[13:22:01.173]                   }
[13:22:01.173]                 }
[13:22:01.173]                 else {
[13:22:01.173]                   if (TRUE) {
[13:22:01.173]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:01.173]                     {
[13:22:01.173]                       inherits <- base::inherits
[13:22:01.173]                       invokeRestart <- base::invokeRestart
[13:22:01.173]                       is.null <- base::is.null
[13:22:01.173]                       muffled <- FALSE
[13:22:01.173]                       if (inherits(cond, "message")) {
[13:22:01.173]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:01.173]                         if (muffled) 
[13:22:01.173]                           invokeRestart("muffleMessage")
[13:22:01.173]                       }
[13:22:01.173]                       else if (inherits(cond, "warning")) {
[13:22:01.173]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:01.173]                         if (muffled) 
[13:22:01.173]                           invokeRestart("muffleWarning")
[13:22:01.173]                       }
[13:22:01.173]                       else if (inherits(cond, "condition")) {
[13:22:01.173]                         if (!is.null(pattern)) {
[13:22:01.173]                           computeRestarts <- base::computeRestarts
[13:22:01.173]                           grepl <- base::grepl
[13:22:01.173]                           restarts <- computeRestarts(cond)
[13:22:01.173]                           for (restart in restarts) {
[13:22:01.173]                             name <- restart$name
[13:22:01.173]                             if (is.null(name)) 
[13:22:01.173]                               next
[13:22:01.173]                             if (!grepl(pattern, name)) 
[13:22:01.173]                               next
[13:22:01.173]                             invokeRestart(restart)
[13:22:01.173]                             muffled <- TRUE
[13:22:01.173]                             break
[13:22:01.173]                           }
[13:22:01.173]                         }
[13:22:01.173]                       }
[13:22:01.173]                       invisible(muffled)
[13:22:01.173]                     }
[13:22:01.173]                     muffleCondition(cond, pattern = "^muffle")
[13:22:01.173]                   }
[13:22:01.173]                 }
[13:22:01.173]             }
[13:22:01.173]         }))
[13:22:01.173]     }, error = function(ex) {
[13:22:01.173]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:01.173]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:01.173]                 ...future.rng), started = ...future.startTime, 
[13:22:01.173]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:01.173]             version = "1.8"), class = "FutureResult")
[13:22:01.173]     }, finally = {
[13:22:01.173]         if (!identical(...future.workdir, getwd())) 
[13:22:01.173]             setwd(...future.workdir)
[13:22:01.173]         {
[13:22:01.173]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:01.173]                 ...future.oldOptions$nwarnings <- NULL
[13:22:01.173]             }
[13:22:01.173]             base::options(...future.oldOptions)
[13:22:01.173]             if (.Platform$OS.type == "windows") {
[13:22:01.173]                 old_names <- names(...future.oldEnvVars)
[13:22:01.173]                 envs <- base::Sys.getenv()
[13:22:01.173]                 names <- names(envs)
[13:22:01.173]                 common <- intersect(names, old_names)
[13:22:01.173]                 added <- setdiff(names, old_names)
[13:22:01.173]                 removed <- setdiff(old_names, names)
[13:22:01.173]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:01.173]                   envs[common]]
[13:22:01.173]                 NAMES <- toupper(changed)
[13:22:01.173]                 args <- list()
[13:22:01.173]                 for (kk in seq_along(NAMES)) {
[13:22:01.173]                   name <- changed[[kk]]
[13:22:01.173]                   NAME <- NAMES[[kk]]
[13:22:01.173]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:01.173]                     next
[13:22:01.173]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:01.173]                 }
[13:22:01.173]                 NAMES <- toupper(added)
[13:22:01.173]                 for (kk in seq_along(NAMES)) {
[13:22:01.173]                   name <- added[[kk]]
[13:22:01.173]                   NAME <- NAMES[[kk]]
[13:22:01.173]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:01.173]                     next
[13:22:01.173]                   args[[name]] <- ""
[13:22:01.173]                 }
[13:22:01.173]                 NAMES <- toupper(removed)
[13:22:01.173]                 for (kk in seq_along(NAMES)) {
[13:22:01.173]                   name <- removed[[kk]]
[13:22:01.173]                   NAME <- NAMES[[kk]]
[13:22:01.173]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:01.173]                     next
[13:22:01.173]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:01.173]                 }
[13:22:01.173]                 if (length(args) > 0) 
[13:22:01.173]                   base::do.call(base::Sys.setenv, args = args)
[13:22:01.173]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:01.173]             }
[13:22:01.173]             else {
[13:22:01.173]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:01.173]             }
[13:22:01.173]             {
[13:22:01.173]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:01.173]                   0L) {
[13:22:01.173]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:01.173]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:01.173]                   base::options(opts)
[13:22:01.173]                 }
[13:22:01.173]                 {
[13:22:01.173]                   {
[13:22:01.173]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:01.173]                     NULL
[13:22:01.173]                   }
[13:22:01.173]                   options(future.plan = NULL)
[13:22:01.173]                   if (is.na(NA_character_)) 
[13:22:01.173]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:01.173]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:01.173]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:01.173]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:01.173]                     envir = parent.frame()) 
[13:22:01.173]                   {
[13:22:01.173]                     if (is.function(workers)) 
[13:22:01.173]                       workers <- workers()
[13:22:01.173]                     workers <- structure(as.integer(workers), 
[13:22:01.173]                       class = class(workers))
[13:22:01.173]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:01.173]                       workers >= 1)
[13:22:01.173]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:01.173]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:01.173]                     }
[13:22:01.173]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:01.173]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:01.173]                       envir = envir)
[13:22:01.173]                     if (!future$lazy) 
[13:22:01.173]                       future <- run(future)
[13:22:01.173]                     invisible(future)
[13:22:01.173]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:01.173]                 }
[13:22:01.173]             }
[13:22:01.173]         }
[13:22:01.173]     })
[13:22:01.173]     if (TRUE) {
[13:22:01.173]         base::sink(type = "output", split = FALSE)
[13:22:01.173]         if (TRUE) {
[13:22:01.173]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:01.173]         }
[13:22:01.173]         else {
[13:22:01.173]             ...future.result["stdout"] <- base::list(NULL)
[13:22:01.173]         }
[13:22:01.173]         base::close(...future.stdout)
[13:22:01.173]         ...future.stdout <- NULL
[13:22:01.173]     }
[13:22:01.173]     ...future.result$conditions <- ...future.conditions
[13:22:01.173]     ...future.result$finished <- base::Sys.time()
[13:22:01.173]     ...future.result
[13:22:01.173] }
[13:22:01.177] MultisessionFuture started
[13:22:01.177] - Launch lazy future ... done
[13:22:01.177] run() for ‘MultisessionFuture’ ... done
[13:22:01.177] getGlobalsAndPackages() ...
[13:22:01.177] Searching for globals...
[13:22:01.178] - globals found: [1] ‘{’
[13:22:01.178] Searching for globals ... DONE
[13:22:01.178] Resolving globals: FALSE
[13:22:01.178] 
[13:22:01.178] 
[13:22:01.178] getGlobalsAndPackages() ... DONE
[13:22:01.179] run() for ‘Future’ ...
[13:22:01.179] - state: ‘created’
[13:22:01.179] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:01.193] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:01.193] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:01.193]   - Field: ‘node’
[13:22:01.193]   - Field: ‘label’
[13:22:01.194]   - Field: ‘local’
[13:22:01.194]   - Field: ‘owner’
[13:22:01.194]   - Field: ‘envir’
[13:22:01.194]   - Field: ‘workers’
[13:22:01.194]   - Field: ‘packages’
[13:22:01.194]   - Field: ‘gc’
[13:22:01.194]   - Field: ‘conditions’
[13:22:01.194]   - Field: ‘persistent’
[13:22:01.194]   - Field: ‘expr’
[13:22:01.194]   - Field: ‘uuid’
[13:22:01.194]   - Field: ‘seed’
[13:22:01.195]   - Field: ‘version’
[13:22:01.195]   - Field: ‘result’
[13:22:01.195]   - Field: ‘asynchronous’
[13:22:01.195]   - Field: ‘calls’
[13:22:01.195]   - Field: ‘globals’
[13:22:01.195]   - Field: ‘stdout’
[13:22:01.195]   - Field: ‘earlySignal’
[13:22:01.195]   - Field: ‘lazy’
[13:22:01.195]   - Field: ‘state’
[13:22:01.195] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:01.195] - Launch lazy future ...
[13:22:01.196] Packages needed by the future expression (n = 0): <none>
[13:22:01.196] Packages needed by future strategies (n = 0): <none>
[13:22:01.196] {
[13:22:01.196]     {
[13:22:01.196]         {
[13:22:01.196]             ...future.startTime <- base::Sys.time()
[13:22:01.196]             {
[13:22:01.196]                 {
[13:22:01.196]                   {
[13:22:01.196]                     {
[13:22:01.196]                       base::local({
[13:22:01.196]                         has_future <- base::requireNamespace("future", 
[13:22:01.196]                           quietly = TRUE)
[13:22:01.196]                         if (has_future) {
[13:22:01.196]                           ns <- base::getNamespace("future")
[13:22:01.196]                           version <- ns[[".package"]][["version"]]
[13:22:01.196]                           if (is.null(version)) 
[13:22:01.196]                             version <- utils::packageVersion("future")
[13:22:01.196]                         }
[13:22:01.196]                         else {
[13:22:01.196]                           version <- NULL
[13:22:01.196]                         }
[13:22:01.196]                         if (!has_future || version < "1.8.0") {
[13:22:01.196]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:01.196]                             "", base::R.version$version.string), 
[13:22:01.196]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:01.196]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:01.196]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:01.196]                               "release", "version")], collapse = " "), 
[13:22:01.196]                             hostname = base::Sys.info()[["nodename"]])
[13:22:01.196]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:01.196]                             info)
[13:22:01.196]                           info <- base::paste(info, collapse = "; ")
[13:22:01.196]                           if (!has_future) {
[13:22:01.196]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:01.196]                               info)
[13:22:01.196]                           }
[13:22:01.196]                           else {
[13:22:01.196]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:01.196]                               info, version)
[13:22:01.196]                           }
[13:22:01.196]                           base::stop(msg)
[13:22:01.196]                         }
[13:22:01.196]                       })
[13:22:01.196]                     }
[13:22:01.196]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:01.196]                     base::options(mc.cores = 1L)
[13:22:01.196]                   }
[13:22:01.196]                   options(future.plan = NULL)
[13:22:01.196]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:01.196]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:01.196]                 }
[13:22:01.196]                 ...future.workdir <- getwd()
[13:22:01.196]             }
[13:22:01.196]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:01.196]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:01.196]         }
[13:22:01.196]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:01.196]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:01.196]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:01.196]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:01.196]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:01.196]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:01.196]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:01.196]             base::names(...future.oldOptions))
[13:22:01.196]     }
[13:22:01.196]     if (FALSE) {
[13:22:01.196]     }
[13:22:01.196]     else {
[13:22:01.196]         if (TRUE) {
[13:22:01.196]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:01.196]                 open = "w")
[13:22:01.196]         }
[13:22:01.196]         else {
[13:22:01.196]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:01.196]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:01.196]         }
[13:22:01.196]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:01.196]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:01.196]             base::sink(type = "output", split = FALSE)
[13:22:01.196]             base::close(...future.stdout)
[13:22:01.196]         }, add = TRUE)
[13:22:01.196]     }
[13:22:01.196]     ...future.frame <- base::sys.nframe()
[13:22:01.196]     ...future.conditions <- base::list()
[13:22:01.196]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:01.196]     if (FALSE) {
[13:22:01.196]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:01.196]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:01.196]     }
[13:22:01.196]     ...future.result <- base::tryCatch({
[13:22:01.196]         base::withCallingHandlers({
[13:22:01.196]             ...future.value <- base::withVisible(base::local({
[13:22:01.196]                 ...future.makeSendCondition <- local({
[13:22:01.196]                   sendCondition <- NULL
[13:22:01.196]                   function(frame = 1L) {
[13:22:01.196]                     if (is.function(sendCondition)) 
[13:22:01.196]                       return(sendCondition)
[13:22:01.196]                     ns <- getNamespace("parallel")
[13:22:01.196]                     if (exists("sendData", mode = "function", 
[13:22:01.196]                       envir = ns)) {
[13:22:01.196]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:01.196]                         envir = ns)
[13:22:01.196]                       envir <- sys.frame(frame)
[13:22:01.196]                       master <- NULL
[13:22:01.196]                       while (!identical(envir, .GlobalEnv) && 
[13:22:01.196]                         !identical(envir, emptyenv())) {
[13:22:01.196]                         if (exists("master", mode = "list", envir = envir, 
[13:22:01.196]                           inherits = FALSE)) {
[13:22:01.196]                           master <- get("master", mode = "list", 
[13:22:01.196]                             envir = envir, inherits = FALSE)
[13:22:01.196]                           if (inherits(master, c("SOCKnode", 
[13:22:01.196]                             "SOCK0node"))) {
[13:22:01.196]                             sendCondition <<- function(cond) {
[13:22:01.196]                               data <- list(type = "VALUE", value = cond, 
[13:22:01.196]                                 success = TRUE)
[13:22:01.196]                               parallel_sendData(master, data)
[13:22:01.196]                             }
[13:22:01.196]                             return(sendCondition)
[13:22:01.196]                           }
[13:22:01.196]                         }
[13:22:01.196]                         frame <- frame + 1L
[13:22:01.196]                         envir <- sys.frame(frame)
[13:22:01.196]                       }
[13:22:01.196]                     }
[13:22:01.196]                     sendCondition <<- function(cond) NULL
[13:22:01.196]                   }
[13:22:01.196]                 })
[13:22:01.196]                 withCallingHandlers({
[13:22:01.196]                   {
[13:22:01.196]                     2
[13:22:01.196]                   }
[13:22:01.196]                 }, immediateCondition = function(cond) {
[13:22:01.196]                   sendCondition <- ...future.makeSendCondition()
[13:22:01.196]                   sendCondition(cond)
[13:22:01.196]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:01.196]                   {
[13:22:01.196]                     inherits <- base::inherits
[13:22:01.196]                     invokeRestart <- base::invokeRestart
[13:22:01.196]                     is.null <- base::is.null
[13:22:01.196]                     muffled <- FALSE
[13:22:01.196]                     if (inherits(cond, "message")) {
[13:22:01.196]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:01.196]                       if (muffled) 
[13:22:01.196]                         invokeRestart("muffleMessage")
[13:22:01.196]                     }
[13:22:01.196]                     else if (inherits(cond, "warning")) {
[13:22:01.196]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:01.196]                       if (muffled) 
[13:22:01.196]                         invokeRestart("muffleWarning")
[13:22:01.196]                     }
[13:22:01.196]                     else if (inherits(cond, "condition")) {
[13:22:01.196]                       if (!is.null(pattern)) {
[13:22:01.196]                         computeRestarts <- base::computeRestarts
[13:22:01.196]                         grepl <- base::grepl
[13:22:01.196]                         restarts <- computeRestarts(cond)
[13:22:01.196]                         for (restart in restarts) {
[13:22:01.196]                           name <- restart$name
[13:22:01.196]                           if (is.null(name)) 
[13:22:01.196]                             next
[13:22:01.196]                           if (!grepl(pattern, name)) 
[13:22:01.196]                             next
[13:22:01.196]                           invokeRestart(restart)
[13:22:01.196]                           muffled <- TRUE
[13:22:01.196]                           break
[13:22:01.196]                         }
[13:22:01.196]                       }
[13:22:01.196]                     }
[13:22:01.196]                     invisible(muffled)
[13:22:01.196]                   }
[13:22:01.196]                   muffleCondition(cond)
[13:22:01.196]                 })
[13:22:01.196]             }))
[13:22:01.196]             future::FutureResult(value = ...future.value$value, 
[13:22:01.196]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:01.196]                   ...future.rng), globalenv = if (FALSE) 
[13:22:01.196]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:01.196]                     ...future.globalenv.names))
[13:22:01.196]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:01.196]         }, condition = base::local({
[13:22:01.196]             c <- base::c
[13:22:01.196]             inherits <- base::inherits
[13:22:01.196]             invokeRestart <- base::invokeRestart
[13:22:01.196]             length <- base::length
[13:22:01.196]             list <- base::list
[13:22:01.196]             seq.int <- base::seq.int
[13:22:01.196]             signalCondition <- base::signalCondition
[13:22:01.196]             sys.calls <- base::sys.calls
[13:22:01.196]             `[[` <- base::`[[`
[13:22:01.196]             `+` <- base::`+`
[13:22:01.196]             `<<-` <- base::`<<-`
[13:22:01.196]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:01.196]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:01.196]                   3L)]
[13:22:01.196]             }
[13:22:01.196]             function(cond) {
[13:22:01.196]                 is_error <- inherits(cond, "error")
[13:22:01.196]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:01.196]                   NULL)
[13:22:01.196]                 if (is_error) {
[13:22:01.196]                   sessionInformation <- function() {
[13:22:01.196]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:01.196]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:01.196]                       search = base::search(), system = base::Sys.info())
[13:22:01.196]                   }
[13:22:01.196]                   ...future.conditions[[length(...future.conditions) + 
[13:22:01.196]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:01.196]                     cond$call), session = sessionInformation(), 
[13:22:01.196]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:01.196]                   signalCondition(cond)
[13:22:01.196]                 }
[13:22:01.196]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:01.196]                 "immediateCondition"))) {
[13:22:01.196]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:01.196]                   ...future.conditions[[length(...future.conditions) + 
[13:22:01.196]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:01.196]                   if (TRUE && !signal) {
[13:22:01.196]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:01.196]                     {
[13:22:01.196]                       inherits <- base::inherits
[13:22:01.196]                       invokeRestart <- base::invokeRestart
[13:22:01.196]                       is.null <- base::is.null
[13:22:01.196]                       muffled <- FALSE
[13:22:01.196]                       if (inherits(cond, "message")) {
[13:22:01.196]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:01.196]                         if (muffled) 
[13:22:01.196]                           invokeRestart("muffleMessage")
[13:22:01.196]                       }
[13:22:01.196]                       else if (inherits(cond, "warning")) {
[13:22:01.196]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:01.196]                         if (muffled) 
[13:22:01.196]                           invokeRestart("muffleWarning")
[13:22:01.196]                       }
[13:22:01.196]                       else if (inherits(cond, "condition")) {
[13:22:01.196]                         if (!is.null(pattern)) {
[13:22:01.196]                           computeRestarts <- base::computeRestarts
[13:22:01.196]                           grepl <- base::grepl
[13:22:01.196]                           restarts <- computeRestarts(cond)
[13:22:01.196]                           for (restart in restarts) {
[13:22:01.196]                             name <- restart$name
[13:22:01.196]                             if (is.null(name)) 
[13:22:01.196]                               next
[13:22:01.196]                             if (!grepl(pattern, name)) 
[13:22:01.196]                               next
[13:22:01.196]                             invokeRestart(restart)
[13:22:01.196]                             muffled <- TRUE
[13:22:01.196]                             break
[13:22:01.196]                           }
[13:22:01.196]                         }
[13:22:01.196]                       }
[13:22:01.196]                       invisible(muffled)
[13:22:01.196]                     }
[13:22:01.196]                     muffleCondition(cond, pattern = "^muffle")
[13:22:01.196]                   }
[13:22:01.196]                 }
[13:22:01.196]                 else {
[13:22:01.196]                   if (TRUE) {
[13:22:01.196]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:01.196]                     {
[13:22:01.196]                       inherits <- base::inherits
[13:22:01.196]                       invokeRestart <- base::invokeRestart
[13:22:01.196]                       is.null <- base::is.null
[13:22:01.196]                       muffled <- FALSE
[13:22:01.196]                       if (inherits(cond, "message")) {
[13:22:01.196]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:01.196]                         if (muffled) 
[13:22:01.196]                           invokeRestart("muffleMessage")
[13:22:01.196]                       }
[13:22:01.196]                       else if (inherits(cond, "warning")) {
[13:22:01.196]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:01.196]                         if (muffled) 
[13:22:01.196]                           invokeRestart("muffleWarning")
[13:22:01.196]                       }
[13:22:01.196]                       else if (inherits(cond, "condition")) {
[13:22:01.196]                         if (!is.null(pattern)) {
[13:22:01.196]                           computeRestarts <- base::computeRestarts
[13:22:01.196]                           grepl <- base::grepl
[13:22:01.196]                           restarts <- computeRestarts(cond)
[13:22:01.196]                           for (restart in restarts) {
[13:22:01.196]                             name <- restart$name
[13:22:01.196]                             if (is.null(name)) 
[13:22:01.196]                               next
[13:22:01.196]                             if (!grepl(pattern, name)) 
[13:22:01.196]                               next
[13:22:01.196]                             invokeRestart(restart)
[13:22:01.196]                             muffled <- TRUE
[13:22:01.196]                             break
[13:22:01.196]                           }
[13:22:01.196]                         }
[13:22:01.196]                       }
[13:22:01.196]                       invisible(muffled)
[13:22:01.196]                     }
[13:22:01.196]                     muffleCondition(cond, pattern = "^muffle")
[13:22:01.196]                   }
[13:22:01.196]                 }
[13:22:01.196]             }
[13:22:01.196]         }))
[13:22:01.196]     }, error = function(ex) {
[13:22:01.196]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:01.196]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:01.196]                 ...future.rng), started = ...future.startTime, 
[13:22:01.196]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:01.196]             version = "1.8"), class = "FutureResult")
[13:22:01.196]     }, finally = {
[13:22:01.196]         if (!identical(...future.workdir, getwd())) 
[13:22:01.196]             setwd(...future.workdir)
[13:22:01.196]         {
[13:22:01.196]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:01.196]                 ...future.oldOptions$nwarnings <- NULL
[13:22:01.196]             }
[13:22:01.196]             base::options(...future.oldOptions)
[13:22:01.196]             if (.Platform$OS.type == "windows") {
[13:22:01.196]                 old_names <- names(...future.oldEnvVars)
[13:22:01.196]                 envs <- base::Sys.getenv()
[13:22:01.196]                 names <- names(envs)
[13:22:01.196]                 common <- intersect(names, old_names)
[13:22:01.196]                 added <- setdiff(names, old_names)
[13:22:01.196]                 removed <- setdiff(old_names, names)
[13:22:01.196]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:01.196]                   envs[common]]
[13:22:01.196]                 NAMES <- toupper(changed)
[13:22:01.196]                 args <- list()
[13:22:01.196]                 for (kk in seq_along(NAMES)) {
[13:22:01.196]                   name <- changed[[kk]]
[13:22:01.196]                   NAME <- NAMES[[kk]]
[13:22:01.196]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:01.196]                     next
[13:22:01.196]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:01.196]                 }
[13:22:01.196]                 NAMES <- toupper(added)
[13:22:01.196]                 for (kk in seq_along(NAMES)) {
[13:22:01.196]                   name <- added[[kk]]
[13:22:01.196]                   NAME <- NAMES[[kk]]
[13:22:01.196]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:01.196]                     next
[13:22:01.196]                   args[[name]] <- ""
[13:22:01.196]                 }
[13:22:01.196]                 NAMES <- toupper(removed)
[13:22:01.196]                 for (kk in seq_along(NAMES)) {
[13:22:01.196]                   name <- removed[[kk]]
[13:22:01.196]                   NAME <- NAMES[[kk]]
[13:22:01.196]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:01.196]                     next
[13:22:01.196]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:01.196]                 }
[13:22:01.196]                 if (length(args) > 0) 
[13:22:01.196]                   base::do.call(base::Sys.setenv, args = args)
[13:22:01.196]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:01.196]             }
[13:22:01.196]             else {
[13:22:01.196]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:01.196]             }
[13:22:01.196]             {
[13:22:01.196]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:01.196]                   0L) {
[13:22:01.196]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:01.196]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:01.196]                   base::options(opts)
[13:22:01.196]                 }
[13:22:01.196]                 {
[13:22:01.196]                   {
[13:22:01.196]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:01.196]                     NULL
[13:22:01.196]                   }
[13:22:01.196]                   options(future.plan = NULL)
[13:22:01.196]                   if (is.na(NA_character_)) 
[13:22:01.196]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:01.196]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:01.196]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:01.196]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:01.196]                     envir = parent.frame()) 
[13:22:01.196]                   {
[13:22:01.196]                     if (is.function(workers)) 
[13:22:01.196]                       workers <- workers()
[13:22:01.196]                     workers <- structure(as.integer(workers), 
[13:22:01.196]                       class = class(workers))
[13:22:01.196]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:01.196]                       workers >= 1)
[13:22:01.196]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:01.196]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:01.196]                     }
[13:22:01.196]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:01.196]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:01.196]                       envir = envir)
[13:22:01.196]                     if (!future$lazy) 
[13:22:01.196]                       future <- run(future)
[13:22:01.196]                     invisible(future)
[13:22:01.196]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:01.196]                 }
[13:22:01.196]             }
[13:22:01.196]         }
[13:22:01.196]     })
[13:22:01.196]     if (TRUE) {
[13:22:01.196]         base::sink(type = "output", split = FALSE)
[13:22:01.196]         if (TRUE) {
[13:22:01.196]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:01.196]         }
[13:22:01.196]         else {
[13:22:01.196]             ...future.result["stdout"] <- base::list(NULL)
[13:22:01.196]         }
[13:22:01.196]         base::close(...future.stdout)
[13:22:01.196]         ...future.stdout <- NULL
[13:22:01.196]     }
[13:22:01.196]     ...future.result$conditions <- ...future.conditions
[13:22:01.196]     ...future.result$finished <- base::Sys.time()
[13:22:01.196]     ...future.result
[13:22:01.196] }
[13:22:01.199] MultisessionFuture started
[13:22:01.200] - Launch lazy future ... done
[13:22:01.200] run() for ‘MultisessionFuture’ ... done
[13:22:01.200] resolve() on list environment ...
[13:22:01.200]  recursive: 0
[13:22:01.201]  length: 3
[13:22:01.201]  elements: ‘a’, ‘b’, ‘c’
[13:22:01.222]  length: 2 (resolved future 3)
[13:22:01.233] receiveMessageFromWorker() for ClusterFuture ...
[13:22:01.233] - Validating connection of MultisessionFuture
[13:22:01.233] - received message: FutureResult
[13:22:01.233] - Received FutureResult
[13:22:01.233] - Erased future from FutureRegistry
[13:22:01.233] result() for ClusterFuture ...
[13:22:01.234] - result already collected: FutureResult
[13:22:01.234] result() for ClusterFuture ... done
[13:22:01.234] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:01.234] Future #1
[13:22:01.234]  length: 1 (resolved future 1)
[13:22:01.255] receiveMessageFromWorker() for ClusterFuture ...
[13:22:01.255] - Validating connection of MultisessionFuture
[13:22:01.256] - received message: FutureResult
[13:22:01.256] - Received FutureResult
[13:22:01.256] - Erased future from FutureRegistry
[13:22:01.256] result() for ClusterFuture ...
[13:22:01.256] - result already collected: FutureResult
[13:22:01.256] result() for ClusterFuture ... done
[13:22:01.256] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:01.256] Future #2
[13:22:01.256]  length: 0 (resolved future 2)
[13:22:01.257] resolve() on list environment ... DONE
[13:22:01.257] getGlobalsAndPackages() ...
[13:22:01.257] Searching for globals...
[13:22:01.258] - globals found: [1] ‘{’
[13:22:01.258] Searching for globals ... DONE
[13:22:01.258] Resolving globals: FALSE
[13:22:01.258] 
[13:22:01.258] 
[13:22:01.258] getGlobalsAndPackages() ... DONE
[13:22:01.259] run() for ‘Future’ ...
[13:22:01.259] - state: ‘created’
[13:22:01.259] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:01.273] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:01.274] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:01.274]   - Field: ‘node’
[13:22:01.274]   - Field: ‘label’
[13:22:01.274]   - Field: ‘local’
[13:22:01.274]   - Field: ‘owner’
[13:22:01.274]   - Field: ‘envir’
[13:22:01.274]   - Field: ‘workers’
[13:22:01.274]   - Field: ‘packages’
[13:22:01.274]   - Field: ‘gc’
[13:22:01.274]   - Field: ‘conditions’
[13:22:01.275]   - Field: ‘persistent’
[13:22:01.275]   - Field: ‘expr’
[13:22:01.275]   - Field: ‘uuid’
[13:22:01.275]   - Field: ‘seed’
[13:22:01.275]   - Field: ‘version’
[13:22:01.275]   - Field: ‘result’
[13:22:01.275]   - Field: ‘asynchronous’
[13:22:01.275]   - Field: ‘calls’
[13:22:01.275]   - Field: ‘globals’
[13:22:01.275]   - Field: ‘stdout’
[13:22:01.275]   - Field: ‘earlySignal’
[13:22:01.276]   - Field: ‘lazy’
[13:22:01.276]   - Field: ‘state’
[13:22:01.276] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:01.276] - Launch lazy future ...
[13:22:01.276] Packages needed by the future expression (n = 0): <none>
[13:22:01.276] Packages needed by future strategies (n = 0): <none>
[13:22:01.277] {
[13:22:01.277]     {
[13:22:01.277]         {
[13:22:01.277]             ...future.startTime <- base::Sys.time()
[13:22:01.277]             {
[13:22:01.277]                 {
[13:22:01.277]                   {
[13:22:01.277]                     {
[13:22:01.277]                       base::local({
[13:22:01.277]                         has_future <- base::requireNamespace("future", 
[13:22:01.277]                           quietly = TRUE)
[13:22:01.277]                         if (has_future) {
[13:22:01.277]                           ns <- base::getNamespace("future")
[13:22:01.277]                           version <- ns[[".package"]][["version"]]
[13:22:01.277]                           if (is.null(version)) 
[13:22:01.277]                             version <- utils::packageVersion("future")
[13:22:01.277]                         }
[13:22:01.277]                         else {
[13:22:01.277]                           version <- NULL
[13:22:01.277]                         }
[13:22:01.277]                         if (!has_future || version < "1.8.0") {
[13:22:01.277]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:01.277]                             "", base::R.version$version.string), 
[13:22:01.277]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:01.277]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:01.277]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:01.277]                               "release", "version")], collapse = " "), 
[13:22:01.277]                             hostname = base::Sys.info()[["nodename"]])
[13:22:01.277]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:01.277]                             info)
[13:22:01.277]                           info <- base::paste(info, collapse = "; ")
[13:22:01.277]                           if (!has_future) {
[13:22:01.277]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:01.277]                               info)
[13:22:01.277]                           }
[13:22:01.277]                           else {
[13:22:01.277]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:01.277]                               info, version)
[13:22:01.277]                           }
[13:22:01.277]                           base::stop(msg)
[13:22:01.277]                         }
[13:22:01.277]                       })
[13:22:01.277]                     }
[13:22:01.277]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:01.277]                     base::options(mc.cores = 1L)
[13:22:01.277]                   }
[13:22:01.277]                   options(future.plan = NULL)
[13:22:01.277]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:01.277]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:01.277]                 }
[13:22:01.277]                 ...future.workdir <- getwd()
[13:22:01.277]             }
[13:22:01.277]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:01.277]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:01.277]         }
[13:22:01.277]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:01.277]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:01.277]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:01.277]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:01.277]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:01.277]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:01.277]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:01.277]             base::names(...future.oldOptions))
[13:22:01.277]     }
[13:22:01.277]     if (FALSE) {
[13:22:01.277]     }
[13:22:01.277]     else {
[13:22:01.277]         if (TRUE) {
[13:22:01.277]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:01.277]                 open = "w")
[13:22:01.277]         }
[13:22:01.277]         else {
[13:22:01.277]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:01.277]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:01.277]         }
[13:22:01.277]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:01.277]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:01.277]             base::sink(type = "output", split = FALSE)
[13:22:01.277]             base::close(...future.stdout)
[13:22:01.277]         }, add = TRUE)
[13:22:01.277]     }
[13:22:01.277]     ...future.frame <- base::sys.nframe()
[13:22:01.277]     ...future.conditions <- base::list()
[13:22:01.277]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:01.277]     if (FALSE) {
[13:22:01.277]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:01.277]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:01.277]     }
[13:22:01.277]     ...future.result <- base::tryCatch({
[13:22:01.277]         base::withCallingHandlers({
[13:22:01.277]             ...future.value <- base::withVisible(base::local({
[13:22:01.277]                 ...future.makeSendCondition <- local({
[13:22:01.277]                   sendCondition <- NULL
[13:22:01.277]                   function(frame = 1L) {
[13:22:01.277]                     if (is.function(sendCondition)) 
[13:22:01.277]                       return(sendCondition)
[13:22:01.277]                     ns <- getNamespace("parallel")
[13:22:01.277]                     if (exists("sendData", mode = "function", 
[13:22:01.277]                       envir = ns)) {
[13:22:01.277]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:01.277]                         envir = ns)
[13:22:01.277]                       envir <- sys.frame(frame)
[13:22:01.277]                       master <- NULL
[13:22:01.277]                       while (!identical(envir, .GlobalEnv) && 
[13:22:01.277]                         !identical(envir, emptyenv())) {
[13:22:01.277]                         if (exists("master", mode = "list", envir = envir, 
[13:22:01.277]                           inherits = FALSE)) {
[13:22:01.277]                           master <- get("master", mode = "list", 
[13:22:01.277]                             envir = envir, inherits = FALSE)
[13:22:01.277]                           if (inherits(master, c("SOCKnode", 
[13:22:01.277]                             "SOCK0node"))) {
[13:22:01.277]                             sendCondition <<- function(cond) {
[13:22:01.277]                               data <- list(type = "VALUE", value = cond, 
[13:22:01.277]                                 success = TRUE)
[13:22:01.277]                               parallel_sendData(master, data)
[13:22:01.277]                             }
[13:22:01.277]                             return(sendCondition)
[13:22:01.277]                           }
[13:22:01.277]                         }
[13:22:01.277]                         frame <- frame + 1L
[13:22:01.277]                         envir <- sys.frame(frame)
[13:22:01.277]                       }
[13:22:01.277]                     }
[13:22:01.277]                     sendCondition <<- function(cond) NULL
[13:22:01.277]                   }
[13:22:01.277]                 })
[13:22:01.277]                 withCallingHandlers({
[13:22:01.277]                   {
[13:22:01.277]                     1
[13:22:01.277]                   }
[13:22:01.277]                 }, immediateCondition = function(cond) {
[13:22:01.277]                   sendCondition <- ...future.makeSendCondition()
[13:22:01.277]                   sendCondition(cond)
[13:22:01.277]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:01.277]                   {
[13:22:01.277]                     inherits <- base::inherits
[13:22:01.277]                     invokeRestart <- base::invokeRestart
[13:22:01.277]                     is.null <- base::is.null
[13:22:01.277]                     muffled <- FALSE
[13:22:01.277]                     if (inherits(cond, "message")) {
[13:22:01.277]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:01.277]                       if (muffled) 
[13:22:01.277]                         invokeRestart("muffleMessage")
[13:22:01.277]                     }
[13:22:01.277]                     else if (inherits(cond, "warning")) {
[13:22:01.277]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:01.277]                       if (muffled) 
[13:22:01.277]                         invokeRestart("muffleWarning")
[13:22:01.277]                     }
[13:22:01.277]                     else if (inherits(cond, "condition")) {
[13:22:01.277]                       if (!is.null(pattern)) {
[13:22:01.277]                         computeRestarts <- base::computeRestarts
[13:22:01.277]                         grepl <- base::grepl
[13:22:01.277]                         restarts <- computeRestarts(cond)
[13:22:01.277]                         for (restart in restarts) {
[13:22:01.277]                           name <- restart$name
[13:22:01.277]                           if (is.null(name)) 
[13:22:01.277]                             next
[13:22:01.277]                           if (!grepl(pattern, name)) 
[13:22:01.277]                             next
[13:22:01.277]                           invokeRestart(restart)
[13:22:01.277]                           muffled <- TRUE
[13:22:01.277]                           break
[13:22:01.277]                         }
[13:22:01.277]                       }
[13:22:01.277]                     }
[13:22:01.277]                     invisible(muffled)
[13:22:01.277]                   }
[13:22:01.277]                   muffleCondition(cond)
[13:22:01.277]                 })
[13:22:01.277]             }))
[13:22:01.277]             future::FutureResult(value = ...future.value$value, 
[13:22:01.277]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:01.277]                   ...future.rng), globalenv = if (FALSE) 
[13:22:01.277]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:01.277]                     ...future.globalenv.names))
[13:22:01.277]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:01.277]         }, condition = base::local({
[13:22:01.277]             c <- base::c
[13:22:01.277]             inherits <- base::inherits
[13:22:01.277]             invokeRestart <- base::invokeRestart
[13:22:01.277]             length <- base::length
[13:22:01.277]             list <- base::list
[13:22:01.277]             seq.int <- base::seq.int
[13:22:01.277]             signalCondition <- base::signalCondition
[13:22:01.277]             sys.calls <- base::sys.calls
[13:22:01.277]             `[[` <- base::`[[`
[13:22:01.277]             `+` <- base::`+`
[13:22:01.277]             `<<-` <- base::`<<-`
[13:22:01.277]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:01.277]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:01.277]                   3L)]
[13:22:01.277]             }
[13:22:01.277]             function(cond) {
[13:22:01.277]                 is_error <- inherits(cond, "error")
[13:22:01.277]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:01.277]                   NULL)
[13:22:01.277]                 if (is_error) {
[13:22:01.277]                   sessionInformation <- function() {
[13:22:01.277]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:01.277]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:01.277]                       search = base::search(), system = base::Sys.info())
[13:22:01.277]                   }
[13:22:01.277]                   ...future.conditions[[length(...future.conditions) + 
[13:22:01.277]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:01.277]                     cond$call), session = sessionInformation(), 
[13:22:01.277]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:01.277]                   signalCondition(cond)
[13:22:01.277]                 }
[13:22:01.277]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:01.277]                 "immediateCondition"))) {
[13:22:01.277]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:01.277]                   ...future.conditions[[length(...future.conditions) + 
[13:22:01.277]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:01.277]                   if (TRUE && !signal) {
[13:22:01.277]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:01.277]                     {
[13:22:01.277]                       inherits <- base::inherits
[13:22:01.277]                       invokeRestart <- base::invokeRestart
[13:22:01.277]                       is.null <- base::is.null
[13:22:01.277]                       muffled <- FALSE
[13:22:01.277]                       if (inherits(cond, "message")) {
[13:22:01.277]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:01.277]                         if (muffled) 
[13:22:01.277]                           invokeRestart("muffleMessage")
[13:22:01.277]                       }
[13:22:01.277]                       else if (inherits(cond, "warning")) {
[13:22:01.277]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:01.277]                         if (muffled) 
[13:22:01.277]                           invokeRestart("muffleWarning")
[13:22:01.277]                       }
[13:22:01.277]                       else if (inherits(cond, "condition")) {
[13:22:01.277]                         if (!is.null(pattern)) {
[13:22:01.277]                           computeRestarts <- base::computeRestarts
[13:22:01.277]                           grepl <- base::grepl
[13:22:01.277]                           restarts <- computeRestarts(cond)
[13:22:01.277]                           for (restart in restarts) {
[13:22:01.277]                             name <- restart$name
[13:22:01.277]                             if (is.null(name)) 
[13:22:01.277]                               next
[13:22:01.277]                             if (!grepl(pattern, name)) 
[13:22:01.277]                               next
[13:22:01.277]                             invokeRestart(restart)
[13:22:01.277]                             muffled <- TRUE
[13:22:01.277]                             break
[13:22:01.277]                           }
[13:22:01.277]                         }
[13:22:01.277]                       }
[13:22:01.277]                       invisible(muffled)
[13:22:01.277]                     }
[13:22:01.277]                     muffleCondition(cond, pattern = "^muffle")
[13:22:01.277]                   }
[13:22:01.277]                 }
[13:22:01.277]                 else {
[13:22:01.277]                   if (TRUE) {
[13:22:01.277]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:01.277]                     {
[13:22:01.277]                       inherits <- base::inherits
[13:22:01.277]                       invokeRestart <- base::invokeRestart
[13:22:01.277]                       is.null <- base::is.null
[13:22:01.277]                       muffled <- FALSE
[13:22:01.277]                       if (inherits(cond, "message")) {
[13:22:01.277]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:01.277]                         if (muffled) 
[13:22:01.277]                           invokeRestart("muffleMessage")
[13:22:01.277]                       }
[13:22:01.277]                       else if (inherits(cond, "warning")) {
[13:22:01.277]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:01.277]                         if (muffled) 
[13:22:01.277]                           invokeRestart("muffleWarning")
[13:22:01.277]                       }
[13:22:01.277]                       else if (inherits(cond, "condition")) {
[13:22:01.277]                         if (!is.null(pattern)) {
[13:22:01.277]                           computeRestarts <- base::computeRestarts
[13:22:01.277]                           grepl <- base::grepl
[13:22:01.277]                           restarts <- computeRestarts(cond)
[13:22:01.277]                           for (restart in restarts) {
[13:22:01.277]                             name <- restart$name
[13:22:01.277]                             if (is.null(name)) 
[13:22:01.277]                               next
[13:22:01.277]                             if (!grepl(pattern, name)) 
[13:22:01.277]                               next
[13:22:01.277]                             invokeRestart(restart)
[13:22:01.277]                             muffled <- TRUE
[13:22:01.277]                             break
[13:22:01.277]                           }
[13:22:01.277]                         }
[13:22:01.277]                       }
[13:22:01.277]                       invisible(muffled)
[13:22:01.277]                     }
[13:22:01.277]                     muffleCondition(cond, pattern = "^muffle")
[13:22:01.277]                   }
[13:22:01.277]                 }
[13:22:01.277]             }
[13:22:01.277]         }))
[13:22:01.277]     }, error = function(ex) {
[13:22:01.277]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:01.277]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:01.277]                 ...future.rng), started = ...future.startTime, 
[13:22:01.277]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:01.277]             version = "1.8"), class = "FutureResult")
[13:22:01.277]     }, finally = {
[13:22:01.277]         if (!identical(...future.workdir, getwd())) 
[13:22:01.277]             setwd(...future.workdir)
[13:22:01.277]         {
[13:22:01.277]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:01.277]                 ...future.oldOptions$nwarnings <- NULL
[13:22:01.277]             }
[13:22:01.277]             base::options(...future.oldOptions)
[13:22:01.277]             if (.Platform$OS.type == "windows") {
[13:22:01.277]                 old_names <- names(...future.oldEnvVars)
[13:22:01.277]                 envs <- base::Sys.getenv()
[13:22:01.277]                 names <- names(envs)
[13:22:01.277]                 common <- intersect(names, old_names)
[13:22:01.277]                 added <- setdiff(names, old_names)
[13:22:01.277]                 removed <- setdiff(old_names, names)
[13:22:01.277]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:01.277]                   envs[common]]
[13:22:01.277]                 NAMES <- toupper(changed)
[13:22:01.277]                 args <- list()
[13:22:01.277]                 for (kk in seq_along(NAMES)) {
[13:22:01.277]                   name <- changed[[kk]]
[13:22:01.277]                   NAME <- NAMES[[kk]]
[13:22:01.277]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:01.277]                     next
[13:22:01.277]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:01.277]                 }
[13:22:01.277]                 NAMES <- toupper(added)
[13:22:01.277]                 for (kk in seq_along(NAMES)) {
[13:22:01.277]                   name <- added[[kk]]
[13:22:01.277]                   NAME <- NAMES[[kk]]
[13:22:01.277]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:01.277]                     next
[13:22:01.277]                   args[[name]] <- ""
[13:22:01.277]                 }
[13:22:01.277]                 NAMES <- toupper(removed)
[13:22:01.277]                 for (kk in seq_along(NAMES)) {
[13:22:01.277]                   name <- removed[[kk]]
[13:22:01.277]                   NAME <- NAMES[[kk]]
[13:22:01.277]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:01.277]                     next
[13:22:01.277]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:01.277]                 }
[13:22:01.277]                 if (length(args) > 0) 
[13:22:01.277]                   base::do.call(base::Sys.setenv, args = args)
[13:22:01.277]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:01.277]             }
[13:22:01.277]             else {
[13:22:01.277]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:01.277]             }
[13:22:01.277]             {
[13:22:01.277]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:01.277]                   0L) {
[13:22:01.277]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:01.277]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:01.277]                   base::options(opts)
[13:22:01.277]                 }
[13:22:01.277]                 {
[13:22:01.277]                   {
[13:22:01.277]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:01.277]                     NULL
[13:22:01.277]                   }
[13:22:01.277]                   options(future.plan = NULL)
[13:22:01.277]                   if (is.na(NA_character_)) 
[13:22:01.277]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:01.277]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:01.277]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:01.277]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:01.277]                     envir = parent.frame()) 
[13:22:01.277]                   {
[13:22:01.277]                     if (is.function(workers)) 
[13:22:01.277]                       workers <- workers()
[13:22:01.277]                     workers <- structure(as.integer(workers), 
[13:22:01.277]                       class = class(workers))
[13:22:01.277]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:01.277]                       workers >= 1)
[13:22:01.277]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:01.277]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:01.277]                     }
[13:22:01.277]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:01.277]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:01.277]                       envir = envir)
[13:22:01.277]                     if (!future$lazy) 
[13:22:01.277]                       future <- run(future)
[13:22:01.277]                     invisible(future)
[13:22:01.277]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:01.277]                 }
[13:22:01.277]             }
[13:22:01.277]         }
[13:22:01.277]     })
[13:22:01.277]     if (TRUE) {
[13:22:01.277]         base::sink(type = "output", split = FALSE)
[13:22:01.277]         if (TRUE) {
[13:22:01.277]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:01.277]         }
[13:22:01.277]         else {
[13:22:01.277]             ...future.result["stdout"] <- base::list(NULL)
[13:22:01.277]         }
[13:22:01.277]         base::close(...future.stdout)
[13:22:01.277]         ...future.stdout <- NULL
[13:22:01.277]     }
[13:22:01.277]     ...future.result$conditions <- ...future.conditions
[13:22:01.277]     ...future.result$finished <- base::Sys.time()
[13:22:01.277]     ...future.result
[13:22:01.277] }
[13:22:01.280] MultisessionFuture started
[13:22:01.280] - Launch lazy future ... done
[13:22:01.280] run() for ‘MultisessionFuture’ ... done
[13:22:01.280] getGlobalsAndPackages() ...
[13:22:01.281] Searching for globals...
[13:22:01.281] - globals found: [2] ‘{’, ‘Sys.sleep’
[13:22:01.282] Searching for globals ... DONE
[13:22:01.282] Resolving globals: FALSE
[13:22:01.282] 
[13:22:01.282] 
[13:22:01.282] getGlobalsAndPackages() ... DONE
[13:22:01.285] run() for ‘Future’ ...
[13:22:01.285] - state: ‘created’
[13:22:01.286] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:01.300] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:01.300] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:01.300]   - Field: ‘node’
[13:22:01.301]   - Field: ‘label’
[13:22:01.301]   - Field: ‘local’
[13:22:01.301]   - Field: ‘owner’
[13:22:01.301]   - Field: ‘envir’
[13:22:01.301]   - Field: ‘workers’
[13:22:01.301]   - Field: ‘packages’
[13:22:01.301]   - Field: ‘gc’
[13:22:01.301]   - Field: ‘conditions’
[13:22:01.301]   - Field: ‘persistent’
[13:22:01.301]   - Field: ‘expr’
[13:22:01.302]   - Field: ‘uuid’
[13:22:01.302]   - Field: ‘seed’
[13:22:01.302]   - Field: ‘version’
[13:22:01.302]   - Field: ‘result’
[13:22:01.302]   - Field: ‘asynchronous’
[13:22:01.302]   - Field: ‘calls’
[13:22:01.302]   - Field: ‘globals’
[13:22:01.302]   - Field: ‘stdout’
[13:22:01.302]   - Field: ‘earlySignal’
[13:22:01.302]   - Field: ‘lazy’
[13:22:01.302]   - Field: ‘state’
[13:22:01.302] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:01.303] - Launch lazy future ...
[13:22:01.303] Packages needed by the future expression (n = 0): <none>
[13:22:01.303] Packages needed by future strategies (n = 0): <none>
[13:22:01.303] {
[13:22:01.303]     {
[13:22:01.303]         {
[13:22:01.303]             ...future.startTime <- base::Sys.time()
[13:22:01.303]             {
[13:22:01.303]                 {
[13:22:01.303]                   {
[13:22:01.303]                     {
[13:22:01.303]                       base::local({
[13:22:01.303]                         has_future <- base::requireNamespace("future", 
[13:22:01.303]                           quietly = TRUE)
[13:22:01.303]                         if (has_future) {
[13:22:01.303]                           ns <- base::getNamespace("future")
[13:22:01.303]                           version <- ns[[".package"]][["version"]]
[13:22:01.303]                           if (is.null(version)) 
[13:22:01.303]                             version <- utils::packageVersion("future")
[13:22:01.303]                         }
[13:22:01.303]                         else {
[13:22:01.303]                           version <- NULL
[13:22:01.303]                         }
[13:22:01.303]                         if (!has_future || version < "1.8.0") {
[13:22:01.303]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:01.303]                             "", base::R.version$version.string), 
[13:22:01.303]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:01.303]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:01.303]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:01.303]                               "release", "version")], collapse = " "), 
[13:22:01.303]                             hostname = base::Sys.info()[["nodename"]])
[13:22:01.303]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:01.303]                             info)
[13:22:01.303]                           info <- base::paste(info, collapse = "; ")
[13:22:01.303]                           if (!has_future) {
[13:22:01.303]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:01.303]                               info)
[13:22:01.303]                           }
[13:22:01.303]                           else {
[13:22:01.303]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:01.303]                               info, version)
[13:22:01.303]                           }
[13:22:01.303]                           base::stop(msg)
[13:22:01.303]                         }
[13:22:01.303]                       })
[13:22:01.303]                     }
[13:22:01.303]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:01.303]                     base::options(mc.cores = 1L)
[13:22:01.303]                   }
[13:22:01.303]                   options(future.plan = NULL)
[13:22:01.303]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:01.303]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:01.303]                 }
[13:22:01.303]                 ...future.workdir <- getwd()
[13:22:01.303]             }
[13:22:01.303]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:01.303]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:01.303]         }
[13:22:01.303]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:01.303]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:01.303]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:01.303]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:01.303]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:01.303]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:01.303]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:01.303]             base::names(...future.oldOptions))
[13:22:01.303]     }
[13:22:01.303]     if (FALSE) {
[13:22:01.303]     }
[13:22:01.303]     else {
[13:22:01.303]         if (TRUE) {
[13:22:01.303]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:01.303]                 open = "w")
[13:22:01.303]         }
[13:22:01.303]         else {
[13:22:01.303]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:01.303]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:01.303]         }
[13:22:01.303]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:01.303]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:01.303]             base::sink(type = "output", split = FALSE)
[13:22:01.303]             base::close(...future.stdout)
[13:22:01.303]         }, add = TRUE)
[13:22:01.303]     }
[13:22:01.303]     ...future.frame <- base::sys.nframe()
[13:22:01.303]     ...future.conditions <- base::list()
[13:22:01.303]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:01.303]     if (FALSE) {
[13:22:01.303]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:01.303]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:01.303]     }
[13:22:01.303]     ...future.result <- base::tryCatch({
[13:22:01.303]         base::withCallingHandlers({
[13:22:01.303]             ...future.value <- base::withVisible(base::local({
[13:22:01.303]                 ...future.makeSendCondition <- local({
[13:22:01.303]                   sendCondition <- NULL
[13:22:01.303]                   function(frame = 1L) {
[13:22:01.303]                     if (is.function(sendCondition)) 
[13:22:01.303]                       return(sendCondition)
[13:22:01.303]                     ns <- getNamespace("parallel")
[13:22:01.303]                     if (exists("sendData", mode = "function", 
[13:22:01.303]                       envir = ns)) {
[13:22:01.303]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:01.303]                         envir = ns)
[13:22:01.303]                       envir <- sys.frame(frame)
[13:22:01.303]                       master <- NULL
[13:22:01.303]                       while (!identical(envir, .GlobalEnv) && 
[13:22:01.303]                         !identical(envir, emptyenv())) {
[13:22:01.303]                         if (exists("master", mode = "list", envir = envir, 
[13:22:01.303]                           inherits = FALSE)) {
[13:22:01.303]                           master <- get("master", mode = "list", 
[13:22:01.303]                             envir = envir, inherits = FALSE)
[13:22:01.303]                           if (inherits(master, c("SOCKnode", 
[13:22:01.303]                             "SOCK0node"))) {
[13:22:01.303]                             sendCondition <<- function(cond) {
[13:22:01.303]                               data <- list(type = "VALUE", value = cond, 
[13:22:01.303]                                 success = TRUE)
[13:22:01.303]                               parallel_sendData(master, data)
[13:22:01.303]                             }
[13:22:01.303]                             return(sendCondition)
[13:22:01.303]                           }
[13:22:01.303]                         }
[13:22:01.303]                         frame <- frame + 1L
[13:22:01.303]                         envir <- sys.frame(frame)
[13:22:01.303]                       }
[13:22:01.303]                     }
[13:22:01.303]                     sendCondition <<- function(cond) NULL
[13:22:01.303]                   }
[13:22:01.303]                 })
[13:22:01.303]                 withCallingHandlers({
[13:22:01.303]                   {
[13:22:01.303]                     Sys.sleep(0.5)
[13:22:01.303]                     2
[13:22:01.303]                   }
[13:22:01.303]                 }, immediateCondition = function(cond) {
[13:22:01.303]                   sendCondition <- ...future.makeSendCondition()
[13:22:01.303]                   sendCondition(cond)
[13:22:01.303]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:01.303]                   {
[13:22:01.303]                     inherits <- base::inherits
[13:22:01.303]                     invokeRestart <- base::invokeRestart
[13:22:01.303]                     is.null <- base::is.null
[13:22:01.303]                     muffled <- FALSE
[13:22:01.303]                     if (inherits(cond, "message")) {
[13:22:01.303]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:01.303]                       if (muffled) 
[13:22:01.303]                         invokeRestart("muffleMessage")
[13:22:01.303]                     }
[13:22:01.303]                     else if (inherits(cond, "warning")) {
[13:22:01.303]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:01.303]                       if (muffled) 
[13:22:01.303]                         invokeRestart("muffleWarning")
[13:22:01.303]                     }
[13:22:01.303]                     else if (inherits(cond, "condition")) {
[13:22:01.303]                       if (!is.null(pattern)) {
[13:22:01.303]                         computeRestarts <- base::computeRestarts
[13:22:01.303]                         grepl <- base::grepl
[13:22:01.303]                         restarts <- computeRestarts(cond)
[13:22:01.303]                         for (restart in restarts) {
[13:22:01.303]                           name <- restart$name
[13:22:01.303]                           if (is.null(name)) 
[13:22:01.303]                             next
[13:22:01.303]                           if (!grepl(pattern, name)) 
[13:22:01.303]                             next
[13:22:01.303]                           invokeRestart(restart)
[13:22:01.303]                           muffled <- TRUE
[13:22:01.303]                           break
[13:22:01.303]                         }
[13:22:01.303]                       }
[13:22:01.303]                     }
[13:22:01.303]                     invisible(muffled)
[13:22:01.303]                   }
[13:22:01.303]                   muffleCondition(cond)
[13:22:01.303]                 })
[13:22:01.303]             }))
[13:22:01.303]             future::FutureResult(value = ...future.value$value, 
[13:22:01.303]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:01.303]                   ...future.rng), globalenv = if (FALSE) 
[13:22:01.303]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:01.303]                     ...future.globalenv.names))
[13:22:01.303]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:01.303]         }, condition = base::local({
[13:22:01.303]             c <- base::c
[13:22:01.303]             inherits <- base::inherits
[13:22:01.303]             invokeRestart <- base::invokeRestart
[13:22:01.303]             length <- base::length
[13:22:01.303]             list <- base::list
[13:22:01.303]             seq.int <- base::seq.int
[13:22:01.303]             signalCondition <- base::signalCondition
[13:22:01.303]             sys.calls <- base::sys.calls
[13:22:01.303]             `[[` <- base::`[[`
[13:22:01.303]             `+` <- base::`+`
[13:22:01.303]             `<<-` <- base::`<<-`
[13:22:01.303]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:01.303]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:01.303]                   3L)]
[13:22:01.303]             }
[13:22:01.303]             function(cond) {
[13:22:01.303]                 is_error <- inherits(cond, "error")
[13:22:01.303]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:01.303]                   NULL)
[13:22:01.303]                 if (is_error) {
[13:22:01.303]                   sessionInformation <- function() {
[13:22:01.303]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:01.303]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:01.303]                       search = base::search(), system = base::Sys.info())
[13:22:01.303]                   }
[13:22:01.303]                   ...future.conditions[[length(...future.conditions) + 
[13:22:01.303]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:01.303]                     cond$call), session = sessionInformation(), 
[13:22:01.303]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:01.303]                   signalCondition(cond)
[13:22:01.303]                 }
[13:22:01.303]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:01.303]                 "immediateCondition"))) {
[13:22:01.303]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:01.303]                   ...future.conditions[[length(...future.conditions) + 
[13:22:01.303]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:01.303]                   if (TRUE && !signal) {
[13:22:01.303]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:01.303]                     {
[13:22:01.303]                       inherits <- base::inherits
[13:22:01.303]                       invokeRestart <- base::invokeRestart
[13:22:01.303]                       is.null <- base::is.null
[13:22:01.303]                       muffled <- FALSE
[13:22:01.303]                       if (inherits(cond, "message")) {
[13:22:01.303]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:01.303]                         if (muffled) 
[13:22:01.303]                           invokeRestart("muffleMessage")
[13:22:01.303]                       }
[13:22:01.303]                       else if (inherits(cond, "warning")) {
[13:22:01.303]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:01.303]                         if (muffled) 
[13:22:01.303]                           invokeRestart("muffleWarning")
[13:22:01.303]                       }
[13:22:01.303]                       else if (inherits(cond, "condition")) {
[13:22:01.303]                         if (!is.null(pattern)) {
[13:22:01.303]                           computeRestarts <- base::computeRestarts
[13:22:01.303]                           grepl <- base::grepl
[13:22:01.303]                           restarts <- computeRestarts(cond)
[13:22:01.303]                           for (restart in restarts) {
[13:22:01.303]                             name <- restart$name
[13:22:01.303]                             if (is.null(name)) 
[13:22:01.303]                               next
[13:22:01.303]                             if (!grepl(pattern, name)) 
[13:22:01.303]                               next
[13:22:01.303]                             invokeRestart(restart)
[13:22:01.303]                             muffled <- TRUE
[13:22:01.303]                             break
[13:22:01.303]                           }
[13:22:01.303]                         }
[13:22:01.303]                       }
[13:22:01.303]                       invisible(muffled)
[13:22:01.303]                     }
[13:22:01.303]                     muffleCondition(cond, pattern = "^muffle")
[13:22:01.303]                   }
[13:22:01.303]                 }
[13:22:01.303]                 else {
[13:22:01.303]                   if (TRUE) {
[13:22:01.303]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:01.303]                     {
[13:22:01.303]                       inherits <- base::inherits
[13:22:01.303]                       invokeRestart <- base::invokeRestart
[13:22:01.303]                       is.null <- base::is.null
[13:22:01.303]                       muffled <- FALSE
[13:22:01.303]                       if (inherits(cond, "message")) {
[13:22:01.303]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:01.303]                         if (muffled) 
[13:22:01.303]                           invokeRestart("muffleMessage")
[13:22:01.303]                       }
[13:22:01.303]                       else if (inherits(cond, "warning")) {
[13:22:01.303]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:01.303]                         if (muffled) 
[13:22:01.303]                           invokeRestart("muffleWarning")
[13:22:01.303]                       }
[13:22:01.303]                       else if (inherits(cond, "condition")) {
[13:22:01.303]                         if (!is.null(pattern)) {
[13:22:01.303]                           computeRestarts <- base::computeRestarts
[13:22:01.303]                           grepl <- base::grepl
[13:22:01.303]                           restarts <- computeRestarts(cond)
[13:22:01.303]                           for (restart in restarts) {
[13:22:01.303]                             name <- restart$name
[13:22:01.303]                             if (is.null(name)) 
[13:22:01.303]                               next
[13:22:01.303]                             if (!grepl(pattern, name)) 
[13:22:01.303]                               next
[13:22:01.303]                             invokeRestart(restart)
[13:22:01.303]                             muffled <- TRUE
[13:22:01.303]                             break
[13:22:01.303]                           }
[13:22:01.303]                         }
[13:22:01.303]                       }
[13:22:01.303]                       invisible(muffled)
[13:22:01.303]                     }
[13:22:01.303]                     muffleCondition(cond, pattern = "^muffle")
[13:22:01.303]                   }
[13:22:01.303]                 }
[13:22:01.303]             }
[13:22:01.303]         }))
[13:22:01.303]     }, error = function(ex) {
[13:22:01.303]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:01.303]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:01.303]                 ...future.rng), started = ...future.startTime, 
[13:22:01.303]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:01.303]             version = "1.8"), class = "FutureResult")
[13:22:01.303]     }, finally = {
[13:22:01.303]         if (!identical(...future.workdir, getwd())) 
[13:22:01.303]             setwd(...future.workdir)
[13:22:01.303]         {
[13:22:01.303]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:01.303]                 ...future.oldOptions$nwarnings <- NULL
[13:22:01.303]             }
[13:22:01.303]             base::options(...future.oldOptions)
[13:22:01.303]             if (.Platform$OS.type == "windows") {
[13:22:01.303]                 old_names <- names(...future.oldEnvVars)
[13:22:01.303]                 envs <- base::Sys.getenv()
[13:22:01.303]                 names <- names(envs)
[13:22:01.303]                 common <- intersect(names, old_names)
[13:22:01.303]                 added <- setdiff(names, old_names)
[13:22:01.303]                 removed <- setdiff(old_names, names)
[13:22:01.303]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:01.303]                   envs[common]]
[13:22:01.303]                 NAMES <- toupper(changed)
[13:22:01.303]                 args <- list()
[13:22:01.303]                 for (kk in seq_along(NAMES)) {
[13:22:01.303]                   name <- changed[[kk]]
[13:22:01.303]                   NAME <- NAMES[[kk]]
[13:22:01.303]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:01.303]                     next
[13:22:01.303]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:01.303]                 }
[13:22:01.303]                 NAMES <- toupper(added)
[13:22:01.303]                 for (kk in seq_along(NAMES)) {
[13:22:01.303]                   name <- added[[kk]]
[13:22:01.303]                   NAME <- NAMES[[kk]]
[13:22:01.303]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:01.303]                     next
[13:22:01.303]                   args[[name]] <- ""
[13:22:01.303]                 }
[13:22:01.303]                 NAMES <- toupper(removed)
[13:22:01.303]                 for (kk in seq_along(NAMES)) {
[13:22:01.303]                   name <- removed[[kk]]
[13:22:01.303]                   NAME <- NAMES[[kk]]
[13:22:01.303]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:01.303]                     next
[13:22:01.303]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:01.303]                 }
[13:22:01.303]                 if (length(args) > 0) 
[13:22:01.303]                   base::do.call(base::Sys.setenv, args = args)
[13:22:01.303]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:01.303]             }
[13:22:01.303]             else {
[13:22:01.303]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:01.303]             }
[13:22:01.303]             {
[13:22:01.303]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:01.303]                   0L) {
[13:22:01.303]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:01.303]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:01.303]                   base::options(opts)
[13:22:01.303]                 }
[13:22:01.303]                 {
[13:22:01.303]                   {
[13:22:01.303]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:01.303]                     NULL
[13:22:01.303]                   }
[13:22:01.303]                   options(future.plan = NULL)
[13:22:01.303]                   if (is.na(NA_character_)) 
[13:22:01.303]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:01.303]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:01.303]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:01.303]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:01.303]                     envir = parent.frame()) 
[13:22:01.303]                   {
[13:22:01.303]                     if (is.function(workers)) 
[13:22:01.303]                       workers <- workers()
[13:22:01.303]                     workers <- structure(as.integer(workers), 
[13:22:01.303]                       class = class(workers))
[13:22:01.303]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:01.303]                       workers >= 1)
[13:22:01.303]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:01.303]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:01.303]                     }
[13:22:01.303]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:01.303]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:01.303]                       envir = envir)
[13:22:01.303]                     if (!future$lazy) 
[13:22:01.303]                       future <- run(future)
[13:22:01.303]                     invisible(future)
[13:22:01.303]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:01.303]                 }
[13:22:01.303]             }
[13:22:01.303]         }
[13:22:01.303]     })
[13:22:01.303]     if (TRUE) {
[13:22:01.303]         base::sink(type = "output", split = FALSE)
[13:22:01.303]         if (TRUE) {
[13:22:01.303]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:01.303]         }
[13:22:01.303]         else {
[13:22:01.303]             ...future.result["stdout"] <- base::list(NULL)
[13:22:01.303]         }
[13:22:01.303]         base::close(...future.stdout)
[13:22:01.303]         ...future.stdout <- NULL
[13:22:01.303]     }
[13:22:01.303]     ...future.result$conditions <- ...future.conditions
[13:22:01.303]     ...future.result$finished <- base::Sys.time()
[13:22:01.303]     ...future.result
[13:22:01.303] }
[13:22:01.307] MultisessionFuture started
[13:22:01.307] - Launch lazy future ... done
[13:22:01.307] run() for ‘MultisessionFuture’ ... done
[13:22:01.307] getGlobalsAndPackages() ...
[13:22:01.308] Searching for globals...
[13:22:01.308] - globals found: [1] ‘{’
[13:22:01.308] Searching for globals ... DONE
[13:22:01.308] Resolving globals: FALSE
[13:22:01.309] 
[13:22:01.309] 
[13:22:01.309] getGlobalsAndPackages() ... DONE
[13:22:01.309] run() for ‘Future’ ...
[13:22:01.309] - state: ‘created’
[13:22:01.309] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:22:01.323] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:22:01.323] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:22:01.323]   - Field: ‘node’
[13:22:01.323]   - Field: ‘label’
[13:22:01.324]   - Field: ‘local’
[13:22:01.324]   - Field: ‘owner’
[13:22:01.324]   - Field: ‘envir’
[13:22:01.324]   - Field: ‘workers’
[13:22:01.324]   - Field: ‘packages’
[13:22:01.324]   - Field: ‘gc’
[13:22:01.324]   - Field: ‘conditions’
[13:22:01.324]   - Field: ‘persistent’
[13:22:01.324]   - Field: ‘expr’
[13:22:01.325]   - Field: ‘uuid’
[13:22:01.325]   - Field: ‘seed’
[13:22:01.325]   - Field: ‘version’
[13:22:01.325]   - Field: ‘result’
[13:22:01.325]   - Field: ‘asynchronous’
[13:22:01.325]   - Field: ‘calls’
[13:22:01.326]   - Field: ‘globals’
[13:22:01.326]   - Field: ‘stdout’
[13:22:01.326]   - Field: ‘earlySignal’
[13:22:01.326]   - Field: ‘lazy’
[13:22:01.326]   - Field: ‘state’
[13:22:01.326] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:22:01.326] - Launch lazy future ...
[13:22:01.327] Packages needed by the future expression (n = 0): <none>
[13:22:01.327] Packages needed by future strategies (n = 0): <none>
[13:22:01.327] {
[13:22:01.327]     {
[13:22:01.327]         {
[13:22:01.327]             ...future.startTime <- base::Sys.time()
[13:22:01.327]             {
[13:22:01.327]                 {
[13:22:01.327]                   {
[13:22:01.327]                     {
[13:22:01.327]                       base::local({
[13:22:01.327]                         has_future <- base::requireNamespace("future", 
[13:22:01.327]                           quietly = TRUE)
[13:22:01.327]                         if (has_future) {
[13:22:01.327]                           ns <- base::getNamespace("future")
[13:22:01.327]                           version <- ns[[".package"]][["version"]]
[13:22:01.327]                           if (is.null(version)) 
[13:22:01.327]                             version <- utils::packageVersion("future")
[13:22:01.327]                         }
[13:22:01.327]                         else {
[13:22:01.327]                           version <- NULL
[13:22:01.327]                         }
[13:22:01.327]                         if (!has_future || version < "1.8.0") {
[13:22:01.327]                           info <- base::c(r_version = base::gsub("R version ", 
[13:22:01.327]                             "", base::R.version$version.string), 
[13:22:01.327]                             platform = base::sprintf("%s (%s-bit)", 
[13:22:01.327]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:22:01.327]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:22:01.327]                               "release", "version")], collapse = " "), 
[13:22:01.327]                             hostname = base::Sys.info()[["nodename"]])
[13:22:01.327]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:22:01.327]                             info)
[13:22:01.327]                           info <- base::paste(info, collapse = "; ")
[13:22:01.327]                           if (!has_future) {
[13:22:01.327]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:22:01.327]                               info)
[13:22:01.327]                           }
[13:22:01.327]                           else {
[13:22:01.327]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:22:01.327]                               info, version)
[13:22:01.327]                           }
[13:22:01.327]                           base::stop(msg)
[13:22:01.327]                         }
[13:22:01.327]                       })
[13:22:01.327]                     }
[13:22:01.327]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:22:01.327]                     base::options(mc.cores = 1L)
[13:22:01.327]                   }
[13:22:01.327]                   options(future.plan = NULL)
[13:22:01.327]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:22:01.327]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:22:01.327]                 }
[13:22:01.327]                 ...future.workdir <- getwd()
[13:22:01.327]             }
[13:22:01.327]             ...future.oldOptions <- base::as.list(base::.Options)
[13:22:01.327]             ...future.oldEnvVars <- base::Sys.getenv()
[13:22:01.327]         }
[13:22:01.327]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:22:01.327]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:22:01.327]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:22:01.327]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:22:01.327]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:22:01.327]             future.stdout.windows.reencode = NULL, width = 80L)
[13:22:01.327]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:22:01.327]             base::names(...future.oldOptions))
[13:22:01.327]     }
[13:22:01.327]     if (FALSE) {
[13:22:01.327]     }
[13:22:01.327]     else {
[13:22:01.327]         if (TRUE) {
[13:22:01.327]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:22:01.327]                 open = "w")
[13:22:01.327]         }
[13:22:01.327]         else {
[13:22:01.327]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:22:01.327]                 windows = "NUL", "/dev/null"), open = "w")
[13:22:01.327]         }
[13:22:01.327]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:22:01.327]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:22:01.327]             base::sink(type = "output", split = FALSE)
[13:22:01.327]             base::close(...future.stdout)
[13:22:01.327]         }, add = TRUE)
[13:22:01.327]     }
[13:22:01.327]     ...future.frame <- base::sys.nframe()
[13:22:01.327]     ...future.conditions <- base::list()
[13:22:01.327]     ...future.rng <- base::globalenv()$.Random.seed
[13:22:01.327]     if (FALSE) {
[13:22:01.327]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:22:01.327]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:22:01.327]     }
[13:22:01.327]     ...future.result <- base::tryCatch({
[13:22:01.327]         base::withCallingHandlers({
[13:22:01.327]             ...future.value <- base::withVisible(base::local({
[13:22:01.327]                 ...future.makeSendCondition <- local({
[13:22:01.327]                   sendCondition <- NULL
[13:22:01.327]                   function(frame = 1L) {
[13:22:01.327]                     if (is.function(sendCondition)) 
[13:22:01.327]                       return(sendCondition)
[13:22:01.327]                     ns <- getNamespace("parallel")
[13:22:01.327]                     if (exists("sendData", mode = "function", 
[13:22:01.327]                       envir = ns)) {
[13:22:01.327]                       parallel_sendData <- get("sendData", mode = "function", 
[13:22:01.327]                         envir = ns)
[13:22:01.327]                       envir <- sys.frame(frame)
[13:22:01.327]                       master <- NULL
[13:22:01.327]                       while (!identical(envir, .GlobalEnv) && 
[13:22:01.327]                         !identical(envir, emptyenv())) {
[13:22:01.327]                         if (exists("master", mode = "list", envir = envir, 
[13:22:01.327]                           inherits = FALSE)) {
[13:22:01.327]                           master <- get("master", mode = "list", 
[13:22:01.327]                             envir = envir, inherits = FALSE)
[13:22:01.327]                           if (inherits(master, c("SOCKnode", 
[13:22:01.327]                             "SOCK0node"))) {
[13:22:01.327]                             sendCondition <<- function(cond) {
[13:22:01.327]                               data <- list(type = "VALUE", value = cond, 
[13:22:01.327]                                 success = TRUE)
[13:22:01.327]                               parallel_sendData(master, data)
[13:22:01.327]                             }
[13:22:01.327]                             return(sendCondition)
[13:22:01.327]                           }
[13:22:01.327]                         }
[13:22:01.327]                         frame <- frame + 1L
[13:22:01.327]                         envir <- sys.frame(frame)
[13:22:01.327]                       }
[13:22:01.327]                     }
[13:22:01.327]                     sendCondition <<- function(cond) NULL
[13:22:01.327]                   }
[13:22:01.327]                 })
[13:22:01.327]                 withCallingHandlers({
[13:22:01.327]                   {
[13:22:01.327]                     3
[13:22:01.327]                   }
[13:22:01.327]                 }, immediateCondition = function(cond) {
[13:22:01.327]                   sendCondition <- ...future.makeSendCondition()
[13:22:01.327]                   sendCondition(cond)
[13:22:01.327]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:01.327]                   {
[13:22:01.327]                     inherits <- base::inherits
[13:22:01.327]                     invokeRestart <- base::invokeRestart
[13:22:01.327]                     is.null <- base::is.null
[13:22:01.327]                     muffled <- FALSE
[13:22:01.327]                     if (inherits(cond, "message")) {
[13:22:01.327]                       muffled <- grepl(pattern, "muffleMessage")
[13:22:01.327]                       if (muffled) 
[13:22:01.327]                         invokeRestart("muffleMessage")
[13:22:01.327]                     }
[13:22:01.327]                     else if (inherits(cond, "warning")) {
[13:22:01.327]                       muffled <- grepl(pattern, "muffleWarning")
[13:22:01.327]                       if (muffled) 
[13:22:01.327]                         invokeRestart("muffleWarning")
[13:22:01.327]                     }
[13:22:01.327]                     else if (inherits(cond, "condition")) {
[13:22:01.327]                       if (!is.null(pattern)) {
[13:22:01.327]                         computeRestarts <- base::computeRestarts
[13:22:01.327]                         grepl <- base::grepl
[13:22:01.327]                         restarts <- computeRestarts(cond)
[13:22:01.327]                         for (restart in restarts) {
[13:22:01.327]                           name <- restart$name
[13:22:01.327]                           if (is.null(name)) 
[13:22:01.327]                             next
[13:22:01.327]                           if (!grepl(pattern, name)) 
[13:22:01.327]                             next
[13:22:01.327]                           invokeRestart(restart)
[13:22:01.327]                           muffled <- TRUE
[13:22:01.327]                           break
[13:22:01.327]                         }
[13:22:01.327]                       }
[13:22:01.327]                     }
[13:22:01.327]                     invisible(muffled)
[13:22:01.327]                   }
[13:22:01.327]                   muffleCondition(cond)
[13:22:01.327]                 })
[13:22:01.327]             }))
[13:22:01.327]             future::FutureResult(value = ...future.value$value, 
[13:22:01.327]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:01.327]                   ...future.rng), globalenv = if (FALSE) 
[13:22:01.327]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:22:01.327]                     ...future.globalenv.names))
[13:22:01.327]                 else NULL, started = ...future.startTime, version = "1.8")
[13:22:01.327]         }, condition = base::local({
[13:22:01.327]             c <- base::c
[13:22:01.327]             inherits <- base::inherits
[13:22:01.327]             invokeRestart <- base::invokeRestart
[13:22:01.327]             length <- base::length
[13:22:01.327]             list <- base::list
[13:22:01.327]             seq.int <- base::seq.int
[13:22:01.327]             signalCondition <- base::signalCondition
[13:22:01.327]             sys.calls <- base::sys.calls
[13:22:01.327]             `[[` <- base::`[[`
[13:22:01.327]             `+` <- base::`+`
[13:22:01.327]             `<<-` <- base::`<<-`
[13:22:01.327]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:22:01.327]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:22:01.327]                   3L)]
[13:22:01.327]             }
[13:22:01.327]             function(cond) {
[13:22:01.327]                 is_error <- inherits(cond, "error")
[13:22:01.327]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:22:01.327]                   NULL)
[13:22:01.327]                 if (is_error) {
[13:22:01.327]                   sessionInformation <- function() {
[13:22:01.327]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:22:01.327]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:22:01.327]                       search = base::search(), system = base::Sys.info())
[13:22:01.327]                   }
[13:22:01.327]                   ...future.conditions[[length(...future.conditions) + 
[13:22:01.327]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:22:01.327]                     cond$call), session = sessionInformation(), 
[13:22:01.327]                     timestamp = base::Sys.time(), signaled = 0L)
[13:22:01.327]                   signalCondition(cond)
[13:22:01.327]                 }
[13:22:01.327]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:22:01.327]                 "immediateCondition"))) {
[13:22:01.327]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:22:01.327]                   ...future.conditions[[length(...future.conditions) + 
[13:22:01.327]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:22:01.327]                   if (TRUE && !signal) {
[13:22:01.327]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:01.327]                     {
[13:22:01.327]                       inherits <- base::inherits
[13:22:01.327]                       invokeRestart <- base::invokeRestart
[13:22:01.327]                       is.null <- base::is.null
[13:22:01.327]                       muffled <- FALSE
[13:22:01.327]                       if (inherits(cond, "message")) {
[13:22:01.327]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:01.327]                         if (muffled) 
[13:22:01.327]                           invokeRestart("muffleMessage")
[13:22:01.327]                       }
[13:22:01.327]                       else if (inherits(cond, "warning")) {
[13:22:01.327]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:01.327]                         if (muffled) 
[13:22:01.327]                           invokeRestart("muffleWarning")
[13:22:01.327]                       }
[13:22:01.327]                       else if (inherits(cond, "condition")) {
[13:22:01.327]                         if (!is.null(pattern)) {
[13:22:01.327]                           computeRestarts <- base::computeRestarts
[13:22:01.327]                           grepl <- base::grepl
[13:22:01.327]                           restarts <- computeRestarts(cond)
[13:22:01.327]                           for (restart in restarts) {
[13:22:01.327]                             name <- restart$name
[13:22:01.327]                             if (is.null(name)) 
[13:22:01.327]                               next
[13:22:01.327]                             if (!grepl(pattern, name)) 
[13:22:01.327]                               next
[13:22:01.327]                             invokeRestart(restart)
[13:22:01.327]                             muffled <- TRUE
[13:22:01.327]                             break
[13:22:01.327]                           }
[13:22:01.327]                         }
[13:22:01.327]                       }
[13:22:01.327]                       invisible(muffled)
[13:22:01.327]                     }
[13:22:01.327]                     muffleCondition(cond, pattern = "^muffle")
[13:22:01.327]                   }
[13:22:01.327]                 }
[13:22:01.327]                 else {
[13:22:01.327]                   if (TRUE) {
[13:22:01.327]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:22:01.327]                     {
[13:22:01.327]                       inherits <- base::inherits
[13:22:01.327]                       invokeRestart <- base::invokeRestart
[13:22:01.327]                       is.null <- base::is.null
[13:22:01.327]                       muffled <- FALSE
[13:22:01.327]                       if (inherits(cond, "message")) {
[13:22:01.327]                         muffled <- grepl(pattern, "muffleMessage")
[13:22:01.327]                         if (muffled) 
[13:22:01.327]                           invokeRestart("muffleMessage")
[13:22:01.327]                       }
[13:22:01.327]                       else if (inherits(cond, "warning")) {
[13:22:01.327]                         muffled <- grepl(pattern, "muffleWarning")
[13:22:01.327]                         if (muffled) 
[13:22:01.327]                           invokeRestart("muffleWarning")
[13:22:01.327]                       }
[13:22:01.327]                       else if (inherits(cond, "condition")) {
[13:22:01.327]                         if (!is.null(pattern)) {
[13:22:01.327]                           computeRestarts <- base::computeRestarts
[13:22:01.327]                           grepl <- base::grepl
[13:22:01.327]                           restarts <- computeRestarts(cond)
[13:22:01.327]                           for (restart in restarts) {
[13:22:01.327]                             name <- restart$name
[13:22:01.327]                             if (is.null(name)) 
[13:22:01.327]                               next
[13:22:01.327]                             if (!grepl(pattern, name)) 
[13:22:01.327]                               next
[13:22:01.327]                             invokeRestart(restart)
[13:22:01.327]                             muffled <- TRUE
[13:22:01.327]                             break
[13:22:01.327]                           }
[13:22:01.327]                         }
[13:22:01.327]                       }
[13:22:01.327]                       invisible(muffled)
[13:22:01.327]                     }
[13:22:01.327]                     muffleCondition(cond, pattern = "^muffle")
[13:22:01.327]                   }
[13:22:01.327]                 }
[13:22:01.327]             }
[13:22:01.327]         }))
[13:22:01.327]     }, error = function(ex) {
[13:22:01.327]         base::structure(base::list(value = NULL, visible = NULL, 
[13:22:01.327]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:22:01.327]                 ...future.rng), started = ...future.startTime, 
[13:22:01.327]             finished = Sys.time(), session_uuid = NA_character_, 
[13:22:01.327]             version = "1.8"), class = "FutureResult")
[13:22:01.327]     }, finally = {
[13:22:01.327]         if (!identical(...future.workdir, getwd())) 
[13:22:01.327]             setwd(...future.workdir)
[13:22:01.327]         {
[13:22:01.327]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:22:01.327]                 ...future.oldOptions$nwarnings <- NULL
[13:22:01.327]             }
[13:22:01.327]             base::options(...future.oldOptions)
[13:22:01.327]             if (.Platform$OS.type == "windows") {
[13:22:01.327]                 old_names <- names(...future.oldEnvVars)
[13:22:01.327]                 envs <- base::Sys.getenv()
[13:22:01.327]                 names <- names(envs)
[13:22:01.327]                 common <- intersect(names, old_names)
[13:22:01.327]                 added <- setdiff(names, old_names)
[13:22:01.327]                 removed <- setdiff(old_names, names)
[13:22:01.327]                 changed <- common[...future.oldEnvVars[common] != 
[13:22:01.327]                   envs[common]]
[13:22:01.327]                 NAMES <- toupper(changed)
[13:22:01.327]                 args <- list()
[13:22:01.327]                 for (kk in seq_along(NAMES)) {
[13:22:01.327]                   name <- changed[[kk]]
[13:22:01.327]                   NAME <- NAMES[[kk]]
[13:22:01.327]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:01.327]                     next
[13:22:01.327]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:01.327]                 }
[13:22:01.327]                 NAMES <- toupper(added)
[13:22:01.327]                 for (kk in seq_along(NAMES)) {
[13:22:01.327]                   name <- added[[kk]]
[13:22:01.327]                   NAME <- NAMES[[kk]]
[13:22:01.327]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:01.327]                     next
[13:22:01.327]                   args[[name]] <- ""
[13:22:01.327]                 }
[13:22:01.327]                 NAMES <- toupper(removed)
[13:22:01.327]                 for (kk in seq_along(NAMES)) {
[13:22:01.327]                   name <- removed[[kk]]
[13:22:01.327]                   NAME <- NAMES[[kk]]
[13:22:01.327]                   if (name != NAME && is.element(NAME, old_names)) 
[13:22:01.327]                     next
[13:22:01.327]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:22:01.327]                 }
[13:22:01.327]                 if (length(args) > 0) 
[13:22:01.327]                   base::do.call(base::Sys.setenv, args = args)
[13:22:01.327]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:22:01.327]             }
[13:22:01.327]             else {
[13:22:01.327]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:22:01.327]             }
[13:22:01.327]             {
[13:22:01.327]                 if (base::length(...future.futureOptionsAdded) > 
[13:22:01.327]                   0L) {
[13:22:01.327]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:22:01.327]                   base::names(opts) <- ...future.futureOptionsAdded
[13:22:01.327]                   base::options(opts)
[13:22:01.327]                 }
[13:22:01.327]                 {
[13:22:01.327]                   {
[13:22:01.327]                     base::options(mc.cores = ...future.mc.cores.old)
[13:22:01.327]                     NULL
[13:22:01.327]                   }
[13:22:01.327]                   options(future.plan = NULL)
[13:22:01.327]                   if (is.na(NA_character_)) 
[13:22:01.327]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:22:01.327]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:22:01.327]                   future::plan(list(function (..., workers = availableCores(), 
[13:22:01.327]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:22:01.327]                     envir = parent.frame()) 
[13:22:01.327]                   {
[13:22:01.327]                     if (is.function(workers)) 
[13:22:01.327]                       workers <- workers()
[13:22:01.327]                     workers <- structure(as.integer(workers), 
[13:22:01.327]                       class = class(workers))
[13:22:01.327]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:22:01.327]                       workers >= 1)
[13:22:01.327]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:22:01.327]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:22:01.327]                     }
[13:22:01.327]                     future <- MultisessionFuture(..., workers = workers, 
[13:22:01.327]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:22:01.327]                       envir = envir)
[13:22:01.327]                     if (!future$lazy) 
[13:22:01.327]                       future <- run(future)
[13:22:01.327]                     invisible(future)
[13:22:01.327]                   }), .cleanup = FALSE, .init = FALSE)
[13:22:01.327]                 }
[13:22:01.327]             }
[13:22:01.327]         }
[13:22:01.327]     })
[13:22:01.327]     if (TRUE) {
[13:22:01.327]         base::sink(type = "output", split = FALSE)
[13:22:01.327]         if (TRUE) {
[13:22:01.327]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:22:01.327]         }
[13:22:01.327]         else {
[13:22:01.327]             ...future.result["stdout"] <- base::list(NULL)
[13:22:01.327]         }
[13:22:01.327]         base::close(...future.stdout)
[13:22:01.327]         ...future.stdout <- NULL
[13:22:01.327]     }
[13:22:01.327]     ...future.result$conditions <- ...future.conditions
[13:22:01.327]     ...future.result$finished <- base::Sys.time()
[13:22:01.327]     ...future.result
[13:22:01.327] }
[13:22:01.329] Poll #1 (0): usedNodes() = 2, workers = 2
[13:22:01.340] receiveMessageFromWorker() for ClusterFuture ...
[13:22:01.340] - Validating connection of MultisessionFuture
[13:22:01.341] - received message: FutureResult
[13:22:01.341] - Received FutureResult
[13:22:01.341] - Erased future from FutureRegistry
[13:22:01.341] result() for ClusterFuture ...
[13:22:01.341] - result already collected: FutureResult
[13:22:01.341] result() for ClusterFuture ... done
[13:22:01.341] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:01.341] result() for ClusterFuture ...
[13:22:01.341] - result already collected: FutureResult
[13:22:01.341] result() for ClusterFuture ... done
[13:22:01.342] result() for ClusterFuture ...
[13:22:01.342] - result already collected: FutureResult
[13:22:01.342] result() for ClusterFuture ... done
[13:22:01.343] MultisessionFuture started
[13:22:01.343] - Launch lazy future ... done
[13:22:01.343] run() for ‘MultisessionFuture’ ... done
[13:22:01.344] resolve() on list environment ...
[13:22:01.344]  recursive: 0
[13:22:01.344]  length: 4
[13:22:01.345]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:22:01.345] Future #1
[13:22:01.345]  length: 3 (resolved future 1)
[13:22:01.366]  length: 2 (resolved future 4)
[13:22:01.390] receiveMessageFromWorker() for ClusterFuture ...
[13:22:01.390] - Validating connection of MultisessionFuture
[13:22:01.390] - received message: FutureResult
[13:22:01.390] - Received FutureResult
[13:22:01.390] - Erased future from FutureRegistry
[13:22:01.390] result() for ClusterFuture ...
[13:22:01.391] - result already collected: FutureResult
[13:22:01.391] result() for ClusterFuture ... done
[13:22:01.391] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:01.391] Future #3
[13:22:01.391]  length: 1 (resolved future 3)
[13:22:01.856] receiveMessageFromWorker() for ClusterFuture ...
[13:22:01.857] - Validating connection of MultisessionFuture
[13:22:01.857] - received message: FutureResult
[13:22:01.857] - Received FutureResult
[13:22:01.857] - Erased future from FutureRegistry
[13:22:01.857] result() for ClusterFuture ...
[13:22:01.857] - result already collected: FutureResult
[13:22:01.857] result() for ClusterFuture ... done
[13:22:01.857] receiveMessageFromWorker() for ClusterFuture ... done
[13:22:01.858] Future #2
[13:22:01.858]  length: 0 (resolved future 2)
[13:22:01.858] resolve() on list environment ... DONE
[13:22:01.858] resolve() on list environment ...
[13:22:01.858]  recursive: 0
[13:22:01.859]  length: 4
[13:22:01.859]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:22:01.859] Future #1
[13:22:01.859]  length: 3 (resolved future 1)
[13:22:01.859] Future #2
[13:22:01.860]  length: 2 (resolved future 2)
[13:22:01.860] Future #3
[13:22:01.860]  length: 1 (resolved future 3)
[13:22:01.860]  length: 0 (resolved future 4)
[13:22:01.860] resolve() on list environment ... DONE
[13:22:01.861] resolve() on list environment ...
[13:22:01.861]  recursive: 0
[13:22:01.861]  length: 4
[13:22:01.861]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:22:01.862] Future #1
[13:22:01.862]  length: 3 (resolved future 1)
[13:22:01.862] Future #2
[13:22:01.862]  length: 2 (resolved future 2)
[13:22:01.862] Future #3
[13:22:01.862]  length: 1 (resolved future 3)
[13:22:01.862]  length: 0 (resolved future 4)
[13:22:01.862] resolve() on list environment ... DONE
[13:22:01.863] resolve() on list environment ...
[13:22:01.863]  recursive: 0
[13:22:01.863]  length: 4
[13:22:01.863]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:22:01.864] Future #1
[13:22:01.864]  length: 3 (resolved future 1)
[13:22:01.864] Future #2
[13:22:01.864]  length: 2 (resolved future 2)
[13:22:01.864] Future #3
[13:22:01.864]  length: 1 (resolved future 3)
[13:22:01.864]  length: 0 (resolved future 4)
[13:22:01.864] resolve() on list environment ... DONE
[13:22:01.865] resolve() on list environment ...
[13:22:01.865]  recursive: 0
[13:22:01.866]  length: 4
[13:22:01.866]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:22:01.866] Future #1
[13:22:01.866] result() for ClusterFuture ...
[13:22:01.866] - result already collected: FutureResult
[13:22:01.866] result() for ClusterFuture ... done
[13:22:01.866] result() for ClusterFuture ...
[13:22:01.866] - result already collected: FutureResult
[13:22:01.866] result() for ClusterFuture ... done
[13:22:01.866]  length: 3 (resolved future 1)
[13:22:01.867] Future #2
[13:22:01.867] result() for ClusterFuture ...
[13:22:01.867] - result already collected: FutureResult
[13:22:01.867] result() for ClusterFuture ... done
[13:22:01.867] result() for ClusterFuture ...
[13:22:01.867] - result already collected: FutureResult
[13:22:01.867] result() for ClusterFuture ... done
[13:22:01.867]  length: 2 (resolved future 2)
[13:22:01.867] Future #3
[13:22:01.867] result() for ClusterFuture ...
[13:22:01.868] - result already collected: FutureResult
[13:22:01.868] result() for ClusterFuture ... done
[13:22:01.868] result() for ClusterFuture ...
[13:22:01.868] - result already collected: FutureResult
[13:22:01.868] result() for ClusterFuture ... done
[13:22:01.868]  length: 1 (resolved future 3)
[13:22:01.868]  length: 0 (resolved future 4)
[13:22:01.868] resolve() on list environment ... DONE
[13:22:01.869] resolve() on list environment ...
[13:22:01.869]  recursive: 99
[13:22:01.869]  length: 4
[13:22:01.869]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:22:01.870] Future #1
[13:22:01.870] result() for ClusterFuture ...
[13:22:01.870] - result already collected: FutureResult
[13:22:01.870] result() for ClusterFuture ... done
[13:22:01.870] result() for ClusterFuture ...
[13:22:01.870] - result already collected: FutureResult
[13:22:01.870] result() for ClusterFuture ... done
[13:22:01.870] A MultisessionFuture was resolved
[13:22:01.870]  length: 3 (resolved future 1)
[13:22:01.871] Future #2
[13:22:01.871] result() for ClusterFuture ...
[13:22:01.871] - result already collected: FutureResult
[13:22:01.871] result() for ClusterFuture ... done
[13:22:01.871] result() for ClusterFuture ...
[13:22:01.871] - result already collected: FutureResult
[13:22:01.871] result() for ClusterFuture ... done
[13:22:01.871] A MultisessionFuture was resolved
[13:22:01.871]  length: 2 (resolved future 2)
[13:22:01.871] Future #3
[13:22:01.871] result() for ClusterFuture ...
[13:22:01.872] - result already collected: FutureResult
[13:22:01.872] result() for ClusterFuture ... done
[13:22:01.872] result() for ClusterFuture ...
[13:22:01.872] - result already collected: FutureResult
[13:22:01.872] result() for ClusterFuture ... done
[13:22:01.872] A MultisessionFuture was resolved
[13:22:01.872]  length: 1 (resolved future 3)
[13:22:01.872]  length: 0 (resolved future 4)
[13:22:01.872] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('multisession') ...
> 
> 
> message("*** resolve() - globals with non-trustful length() ...")
*** resolve() - globals with non-trustful length() ...
> 
> length.CantTrustLength <- function(x) length(unclass(x)) + 1L
> 
> .length <- future:::.length
> 
> x <- structure(as.list(1:3), class = c("CantTrustLength", "list"))
> str(list(n = length(x), n_true = .length(x)))
List of 2
 $ n     : int 4
 $ n_true: int 3
> stopifnot(length(x) > .length(x))
> x <- resolve(x)
[13:22:01.875] resolve() on list ...
[13:22:01.875]  recursive: 0
[13:22:01.875]  length: 3
[13:22:01.875] 
[13:22:01.876]  length: 2 (resolved future 1)
[13:22:01.876]  length: 1 (resolved future 2)
[13:22:01.876]  length: 0 (resolved future 3)
[13:22:01.876] resolve() on list ... DONE
> 
> message("*** resolve() - globals with non-trustful length() ... DONE")
*** resolve() - globals with non-trustful length() ... DONE
> 
> 
> message("*** resolved() - default ...")
*** resolved() - default ...
> 
> res <- resolved(42L)
> stopifnot(isTRUE(res))
> 
> message("*** resolved() - default ... DONE")
*** resolved() - default ... DONE
> 
> 
> message("*** resolve() ... DONE")
*** resolve() ... DONE
> 
> source("incl/end.R")
[13:22:01.877] plan(): Setting new future strategy stack:
[13:22:01.877] List of future strategies:
[13:22:01.877] 1. FutureStrategy:
[13:22:01.877]    - args: function (..., envir = parent.frame())
[13:22:01.877]    - tweaked: FALSE
[13:22:01.877]    - call: future::plan(oplan)
[13:22:01.878] plan(): nbrOfWorkers() = 1
> 
